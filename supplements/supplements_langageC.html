<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage C - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3schools.com/js/default.asp" target="_blank">Tutoriel JavaScript de W3Schools</a></li>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage C :</h1>
                </article>
                <article>
                    <h2 id="historique">Historique :</h2>
                    <p>Le langage C est apparu au début des années 1970. À l'époque, le développement sur les machines informatiques nécessitait l'emploi du langage d'assemblage spécifique à chacune d'elles. Le portage d'un programme, voire d'un système d'exploitation, depuis un modèle de machine vers un autre nécessitait alors une réécriture totale du code. En autorisant l'expression des constructions algorithmes usuelles (variables, boucles, fonctions...) dans un langage de plus haut niveau (plus facile à lire pour un être humain) qui pouvait être traduit (compilé) dans le langage spécifique à la machine sous-jacente, tout en autorisant l'accès aux ressources de bas niveau de cette machine (les périphériques et la mémoire notamment), le langage C pouvait être considéré comme un langage d'assemblage portable.</p>
                    <p>Le Langage C a été conçu en 1972 par Dennis Richie et Ken Thompson, au laboratoire Bell Labs, en vue de développer un nouveau système d'exploitation, Unix, portable sur différents hardwares. En 1978, Brian Kernigham et Dennis Richie publient une première définition du langage, The Programming Language, connue sous le nom <span class="em">C K&R</span> ou <span class="em">C classique</span>. u l'intérêt suscité par le langage, il est adapté par de nombreux développeurs et une standardisation s'avère nécessaire. Le "American National Standards Institute" (ANSI) débute les travaux en 1983. Ils déboucheront en 1988 sur une nouvelle norme, le standard <span class="em">ANSI C</span>. En 1990, l'ISO adopte telle quelle cette norme (C90). D'autres évolutions du langage ont suivi et ont été normalisées par l'ISO : C99 en 1999 et <span class="em">C11</span> en 2011, dernière version, qui est celle que nous utiliserons pour ce cours.</p>
                    <h2 id="avantages">Avantages :</h2>
                    <p>Le langage C reste un langage des plus utilisés, vu ses très nombreux avantages dont les principaux sont :</p>
                    <dl>
                        <dt>Langage structuré de bas niveau :</dt>
                        <dd>C est un lagage structuré, déclaratif et récursif, offrant des structures classiques de contrôle et de déclaration. Considéré à l'origine comme un langage de haut-niveau (par rapport au langage d'assemblage), il est devenu un langage de bas niveau (par rapport notamment aux langages orientés objets), proche de la machine : chaque instruction du langage est conçue pour être compilée en un nombre d'instructions machine restreint et assez prévisible en termes d'occupation mémoire et de charge de calcul.</dd>
                        <dt>Portabilité :</dt>
                        <dd>Les compilateurs et bibliothèques logicielles existent sur la plupart des architectures. Un programme écrit en ANSI C pour un certain système peut donc facilement être déployé sur d'autres systèmes (Windows, Pc, mini, mainframe, etc).</dd>
                        <dt>Code performant :</dt>
                        <dd>Comme C permet d'utiliser des expressions et opérateurs qui sont très proches du langages machine, il permet le développement de programmes efficients et rapides. Il comporte également peu de code "inutile" (vérifications, etc.) car il est supposé que le programmeur sait ce qu'il écrit. De plus, les types définis par le langage sont conçus pour pouvoir correspondre directement aux types de données supportés par le processeur.</dd>
                        <dt>Facilité d'apprentissage :</dt>
                        <dd>C est basé sur un noyau de fonctions et d'opérateurs limité, qui permet la formulation d'expressions simples, mais efficaces. Cette simplicité facilite l'assimilation du langage.</dd>
                    </dl>
                    <h2 id="inconvenients">Inconvénients :</h2>
                    <p>Tous ces avantages impliquent certains inconvénients auxquels les programmeurs devront faire particulièrement attention :</p>
                    <dl>
                        <dt>Efficience et compréhensible :</dt>
                        <dd>Le C offre la possibilité d'utiliser des expressions compactes et efficientes. Cependant, leur utilisation nécessite de l'expérience et n'est pas facilement accessible à des débutants. Sans commentaires ou explications, les programmes peuvent par conséquent devenir incompréhensibles, donc inutilisables.</dd>
                        <dt>Portabilité et bibliothèques de fonctions :</dt>
                        <dd>La portabilité est l'un des avantages les plus importants de C : en écrivant des programmes qui respectent le standard ANSI-C, nous pouvons les utiliser sur n'importe quelle machine possédant un compilateur ANSI-C. Cependant, si un programmeur désire faire appel à une fonction spécifique de la machine (p. ex : utiliser une carte graphique spéciale), il risque de perdre la portabilité. Ainsi, les avantages d'un programme portable doivent être payés par la restriction des moyens de programmation.</dd>
                        <dt>Discipline de programmation :</dt>
                        <dd>C est un langage près de la machine, donc dangereux et bien que C soit un langage de programmation structuré, les compilateurs font peu de vérifications et ne nous forcent pas à adopter un certain style de programmation. Dans un certain sens, tout est permis et la tentation de programmer du "code spaghetti" est grande. (Même la commande '<span class="em">goto</span>', si redoutée par les puristes, ne manque pas en C !) Par conséquent, si le programmeur a beaucoup de libertés, il a aussi des responsabilités : il doit veiller à sécuriser son code, adopter un style de programmation strict et programmer de manière structurée et claire.</dd>
                    </dl>
                    <h2 id="1er_programme">1er programme :</h2>
                    <p>Voici un premier programme qui affiche un message de bienvenue sur la sortie standard <span class="em">stdout</span>.</p>
<pre class="taille60"><code>1   #include &lt;stdio.h&gt;
2
3   int main(){
4       print("Hello world\n");
        return 0;
6   }</code></pre>
                    <p>Dans cet exemple, la ligne</p>
                    <ol>
                        <li>est une directive du préprocesseur (préfixée par #) qui inclut le contenu du fichier <span class="em">stdio.h</span> dans notre source.</li>
                        <li>est une ligne vide, ignorée par le compilateur.</li>
                        <li>est le nom de la function principale, point d'entrée de l'application.</li>
                        <li>est l'appel de la fonction <span class="em">printf</span> qui affiche sur la sortie standard <span class="em">stdout</span> (écran).</li>
                        <li>indique la fin de la fonction <span class="em">main</span>.</li>
                    </ol>
                    <p>Avant d'exécuter notre application, nous devons compiler la source, c'est-à-dire la traduire en langage machine. La commande pour y arriver est la commande <span class="em">cc</span> (pour C Compiler).</p>
<pre class="taille60"><code>cc pgm1.c</code></pre>
                    <p>où <span class="em">pgm1.c</span> est le nom du fichier source. Cette commande, si il n'y a aucune erreur, va générer un programme exécutable, appelé par défaut <span class="em">a.out</span>. Avec l'option -o, nous pouvons spécifier un autre nom pour notre exécutable :</p>
<pre class="taille60"><code>cc -o pgm1 pgm1.c</code></pre>
                    <h3 id="compilateur_cc">Remarque : le compilateur cc :</h3>
                    <p>Le compilateur utilisé durant ce cours est le compilateur <span class="em">cc</span> (C Compiler) d'Ubuntu, qui correspond en réalité à un lien symbolique vers <span class="em">gcc</span> (GNU Compiler Collection). gcc est une suite de logiciels libres de compilation qui gère à la fois le langage C et ses dérivés mais aussi le Java ou encore le Fortran. Afin de limiter cette suite logicielle, nous fixons différentes options de compilation :</p>
                    <ul>
                        <li><span class="em">-std=c11</span> : ce flag définit le langage standard utilisé pour la compilation; ici ISO C11, la norme la plus récente du langage C, datant de 2011.</li>
                        <li><span class="em">-pedantic</span> : ce flag indique au compilateur de rapporter tous les avertissements (warnings) liés au respect strict de la norme ISO C utilisée.</li>
                        <li><span class="em">-Werror=vla</span> : ce flag transforme un avertissement spécifique en erreur de compilation; ici, le compilateur produira une erreur si un tableau de taille variable (Variable-Length Array, c'est-à-dire un tableau dont la taille est déterminée à l'exécution) est défini dans le programme. Alors que le standard ANSI-C (C90) interdisait de tels tableaux, la norme suivante (C99) les a permis et la dernière (C11) les a rendus optionnels. Ce flag permet donc d'éviter les problèmes de comptabilité induits par cette ambiguïté de la norme C11 vis-à-vis des VLA.</li>
                    </ul>
                    <p>Pour plus d'informations sur les différentes options du compilteur, n'hésitez pas à consulter le manuel en tapant '<span class="em">man gcc</span>' dans un terminal.</p>
                </article>
                <article>
                    <h2 id="elemnts_langage">Les éléments du langage :</h2>
                    <p>Tout langage de programmation utilise un <span class="souligne">ensemble de caractères</span> qui assemblés forment les différents éléments de ce langage, notamment les <span class="souligne">commentaires</span>, les <span class="em">mots-réservés</span>, les <span class="em">identificateurs</span>, etc.</p>
                    <h3 id="caracteres_permis">Les caractères permis :</h3>
                    <ul>
                        <li>Les lettres de l'alphabet (majuscules et minuscules)</li>
                        <li>Les chiffres</li>
                        <li>Les caractères spéciaux (dans l'ordre Ascii) : ! " # % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? [ \ ] ^ _ { | }</li>
                        <li>Certains caractères, appelés séparateurs de mots, sont permis mais ignorés par le compilateur : le caractère d'espacement &lt;sp&gt;, la tabulation &lt;tab&gt;, la tabulation verticale, le carriage return, le return à la ligne '\n', le saut de page '\f'.</li>
                    </ul>
                    <h3 id="commentaires">Les commentaires :</h3>
                    <p>Les commentaires sont importants car ils permettent de se souvenir des intentions mises lors de l'écriture du programme, ou d'expliquer le code à d'autres lecteurs. En ANSI C, ils commencent par la balise ouvrante <span class="em">/*</span> et se terminent par la balise fermante <span class="em">*/</span> Ils peuvent se prolonger sur plusieurs lignes mais ne peuvent en aucun cas s'imbriquer. Par exemple :</p>
<pre class="taille60"><code>    #include &lt;stdio.h&gt;
    
    /* début du programme */
    int main(){ /* fonction principale */
        printf("Hello world\n");
        return 0;
    }</code></pre>
                    <p>Depuis la norme C99, les commentaires de fin de ligne ont été repris de C++ pour être intégrés au langage C. Introduits par la balise <span class="em">//</span>, ils mettent en commentaire tout ce qui suit sur la ligne.</p>
<pre class="taille60"><code>    #include &lt;stdio.h&gt;

    // début du programme
    int main(){ // fonction principale
        printf("Hello world\n");
        return 0;
    }</code></pre>
                    <p>Les commentaires peuvent être utilisés pour introduire votre fichier, expliquer le rôle d'une variable ou d'une fonction, décrire un morceau du code, etc.</p>
                    <h3 id="mots_reserves">Les mots réservés :</h3>
                    <p>Le langage C se réserve l'usage de 32 mots qui de ce fait ne peuvent pas être chosis par le programmeur comme identificateurs de variables ou de fonctions. Ces mots sont repris dans le tableau suivant :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>auto</td>
                                <td>double</td>
                                <td>int</td>
                                <td>struct</td>
                            </tr>
                            <tr>
                                <td>break</td>
                                <td>else</td>
                                <td>long</td>
                                <td>switch</td>
                            </tr>
                            <tr>
                                <td>case</td>
                                <td>enum</td>
                                <td>register</td>
                                <td>typpedef</td>
                            </tr>
                            <tr>
                                <td>char</td>
                                <td>extern</td>
                                <td>register</td>
                                <td>typedef</td>
                            </tr>
                            <tr>
                                <td>const</td>
                                <td>float</td>
                                <td>short</td>
                                <td>unsigned</td>
                            </tr>
                            <tr>
                                <td>continue</td>
                                <td>for</td>
                                <td>signed</td>
                                <td>void</td>
                            </tr>
                            <tr>
                                <td>default</td>
                                <td>goto</td>
                                <td>sizeof</td>
                                <td>volatile</td>
                            </tr>
                            <tr>
                                <td>do</td>
                                <td>if</td>
                                <td>static</td>
                                <td>while</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="types_base">Les types de base :</h3>
                    <p>Le tableau ci-dessous présente l'ensemble des types connus du compilateur C. On constate que le langage C dispose de deux sortes de types de base, les nombres entiers et les nombres flottants, et d'une famille infinie de types dérivés obtenus en appliquant quelques procédés récursifs de construction, soit à des types fondamentaux soit à des types dérivés définis de la même manière.</p>
                    <img src="../images/types_base_C.jpg" alt="Types de base">
                    <p>On remarque également que le C est assez pauvre en types de base. Il ne connait que les types numériques <span class="souligne">entier</span> et <spa class="souligne">réel</spa>. Par contre, pas de type <span class="souligne">booléen</span> (simulé par un type entier), ni de type <span class="souligne">chaîne de caractères</span> (considérée comme un tableau de caractères un peu particulier).</p>
                    <h4 id="types_entiers">Les types entiers :</h4>
                    <p>Ils sont codés sur un nombre déterminé de bytes. Le tableau suivant reprend les différents types entiers.</p>
                    <table>
                        <tbody>
                            <tr>
                                <td rowspan="3">1 byte</td>
                                <td class="bold">char</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td class="bold">unsigned char</td>
                                <td>0 à 255</td>
                            </tr>
                            <tr>
                                <td><span class="bold">signed char</span> (en ANSI C)</td>
                                <td>-128 à 127</td>
                            </tr>
                            <tr>
                                <td rowspan="2">2 bytes</td>
                                <td class="bold">short (short int)</td>
                                <td>-32768 à 32767</td>
                            </tr>
                            <tr>
                                <td class="bold">unsigned short (unsigned short int)</td>
                                <td>0 à 65535</td>
                            </tr>
                            <tr>
                                <td rowspan="2">2 ou 4 bytes</td>
                                <td class="bold">int</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td class="bold">unsigned (unsigned int)</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td rowspan="2">4 bytes</td>
                                <td class="bold">long (long int)</td>
                                <td>-2147483648 à 2147483647</td>
                            </tr>
                            <tr>
                                <td class="bold">unsigned long (unsigned long int)</td>
                                <td>0 à 4294967295</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En principe, le type <span class="em">int</span> correspond à la taille d'entier la plus efficace, c'est-à-dire la plus adaptée à la machine utilisée. Sur certains systèmes et compilateurs int est synonyme de short (2 bytes), sur d'autres il est synonyme de long (4 bytes) (donc nous aurons toujours : sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)). Le type int peut par conséquent poser un problème de protabilité : le même programme, compilé sur deux machines distinctes, peut avoir des comportements différents. D'où un conseil important : n'utilisez le type int que pour des variables locales destinées à contenir des valeurs raisonnablement petites (inférieures en valeur absolue à 32767). Dans les autres cas, il vaut mieux expliciter char, short ou long selon le besoin.</p>
                    <p>Le type <span class="em">char</span> est un type entier qui contient le code <span class="souligne">Ascii</span> du caractère mais qui peut être utilisé dans les expressions arithmétiques.</p>
                    <h4 id="types_reels">Les types réels :</h4>
                    <p>Leurs tailles sont laissées à la discrétion du compilateur (notamment en fonction du processeur). Le langage C connaît 3 types réels : <span class="em">float</span>, <span class="em">double</span> et <span class="em">long double</span>.</p>
                    <h4 id="pseudo-type_booleen">Le pseudo-type booléen :</h4>
                    <p>Le type booléen n'existant pas, il est recommandé d'utiliser un type <span class="souligne">entier</span>, sachant que la valeur <span class="em">FAUX</span> correspondra à la valeur nulle 0 tandis que <span class="em">VRAI</span> sera représentée par toute autre valeur. Toutefois, le résultat d'une expression logique est toujours égal à 1.</p>
                    <h3 id="operateurs_c">Opérateurs :</h3>
                    <p>La plupart des opérateurs définis dans le langage C ont été repris dans la définition du Java. Voic les principaux, classés, par ordre de priorité décroisssante (priorité maximale = 17). Nous en découvrirons d'autres par la suite.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Niveau de priorité</th>
                                <th>Opérateur</th>
                                <th>Description</th>
                                <th>Associativité</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td rowspan="4">17</td>
                                <td>[]</td>
                                <td>indice de tableau</td>
                                <td rowspan="4">gauche</td>
                            </tr>
                            <tr>
                                <td>(...)</td>
                                <td>appel de fonction</td>
                            </tr>
                            <tr>
                                <td class="bold">.</td>
                                <td class="bold">sélection de membre</td>
                            </tr>
                            <tr>
                                <td class="bold">-&gt;</td>
                                <td class="bold">sélection de membre par déréférencement</td>
                            </tr>
                            <tr>
                                <td rowspan="2">16</td>
                                <td>++</td>
                                <td>post-incrémentation</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>--</td>
                                <td>post-décrémentation</td>
                            </tr>
                            <tr>
                                <td rowspan="2">15</td>
                                <td>++</td>
                                <td rowspan="2">droite</td>
                            </tr>
                            <tr>
                                <td>--</td>
                                <td>pré-décrémentation</td>
                            </tr>
                            <tr>
                                <td rowspan="7">15</td>
                                <td>sizeof</td>
                                <td>calcule la taille d'une variable (d'un type)</td>
                                <td rowspan="7">droute</td>
                            </tr>
                            <tr>
                                <td>~</td>
                                <td>complément à 1 (inversion des bits)</td>
                            </tr>
                            <tr>
                                <td>!</td>
                                <td>non logique</td>
                            </tr>
                            <tr>
                                <td>+</td>
                                <td>identité (opérateur unaire)</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>changement de signe complément à 2</td>
                            </tr>
                            <tr>
                                <td class="bold">&amp;</td>
                                <td class="bold">adrese</td>
                            </tr>
                            <tr>
                                <td class="bold">*</td>
                                <td class="bold">indirection, déréférenciation</td>
                            </tr>
                            <tr>
                                <td>14</td>
                                <td>(type)</td>
                                <td>cast, changement forcé de type</td>
                                <td>droite</td>
                            </tr>
                            <tr>
                                <td rowspan="3">13</td>
                                <td>*</td>
                                <td>multiplication</td>
                                <td rowspan="3">gauche</td>
                            </tr>
                            <tr>
                                <td>/</td>
                                <td>division</td>
                            </tr>
                            <tr>
                                <td>%</td>
                                <td>modulo (uniquement si opérandes entiers)</td>
                            </tr>
                            <tr>
                                <td rowspan="2">12</td>
                                <td>+</td>
                                <td>addition</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>soustraction</td>
                            </tr>
                            <tr>
                                <td rowspan="2">11</td>
                                <td>&lt;&lt;</td>
                                <td>shift vers la gauche</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>&gt;&gt;</td>
                                <td>shift vers la droite (shift logique si premier opérande est unsigned)</td>
                            </tr>
                            <tr>
                                <td rowspan="4">10</td>
                                <td>&lt;</td>
                                <td>inférieur</td>
                                <td rowspan="4">gauche</td>
                            </tr>
                            <tr>
                                <td>&gt;</td>
                                <td>supérieur</td>
                            </tr>
                            <tr>
                                <td>&lt;=</td>
                                <td>inférieur ou égal</td>
                            </tr>
                            <tr>
                                <td>&gt;=</td>
                                <td>supérieur ou égal</td>
                            </tr>
                            <tr>
                                <td rowspan="2">9</td>
                                <td>==</td>
                                <td>égal</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>!=</td>
                                <td>différent</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>&amp;</td>
                                <td>AND bit à bit</td>
                                <td>gauche</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>^</td>
                                <td>XOR bit à bit</td>
                                <td>gauche</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>|</td>
                                <td>OR bit à bit</td>
                                <td>gauche</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>&amp;&amp;</td>
                                <td>AND logique (évaluation court-circuitée)</td>
                                <td>gauche</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>||</td>
                                <td>OR logique (évaluation court-circuitée)</td>
                                <td>gauche</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>?</td>
                                <td>opérateur ternaire conditionnel</td>
                                <td>droite</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</td>
                                <td>affectation</td>
                                <td>droite</td>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>,</td>
                                <td>évaluation séquentielle</td>
                                <td>gauche</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="conversions_types">Les conversions de types :</h3>
                    <p>La conversion de type est le fait de convertir une valeur d'un type (source) dans un autre (cible). On parle aussi de coercition ou de cast en anglais.</p>
                    <p>C réalise un certain nombre de conversions pour interpréter une valeur dans un autre type, soit <span class="souligne">explicite</span> grâce au cast, soit de manière <span class="souligne">implicite</span>.</p>
                    <h4 id="conversions_explicites_cast">Conversions explicites par cast :</h4>
                    <p>Le cast (ou transtypage explicite) d'une expression permet de changer de la valeur renvoyée par l'évaluation de cette expression.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>type de destination (cast)</th>
                                <th>type d'origine</th>
                                <th>exemple</th>
                                <th>Remarque</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>un type entier</td>
                                <td>un type entier ou réel</td>
                                <td>i = (int) x</td>
                                <td>ATTENTION, si x est réelle, il y a perte de la partie décimale de la valeur.</td>
                            </tr>
                            <tr>
                                <td>un type réel</td>
                                <td>un type entier ou réel</td>
                                <td>d = (double) i</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="conversions_implicites">Conversions implicites :</h4>
                    <p>Par ailleurs, C convertit automatiquement <span class="souligne">certaines expressions</span> dans un type préférentiel, lors de leur évaluation. Avant d'utiliser un opérateur binaire (sauf &lt;&lt; et &gt;&gt;), une <span class="souligne">conversion binaire</span> peut également être réalisée pour permettre aux deux opérandes d'être de même type. Enfin, une conversion peut être réalisée lors d'<span class="souligne">une affectation</span>.</p>
                    <p>Les <span class="em">conversions unaires</span> vont s'appliquer à un seul opérande, en respectant les règles énoncées dans le tableau suivant.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>type original de l'opérande</th>
                                <th>est converti en</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>char ou short</td>
                                <td>int</td>
                            </tr>
                            <tr>
                                <td>unsigned char ou unsigned short</td>
                                <td>int ou unsigned (le plus petit qui parvient à garder la valeur)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Les <span class="em">conversions binaires</span> vont s'appliquer sur un des opérandes, en respectant la hiérarchie des types suivantes :</p>
                    <p class="html">int &lt; unsigned &lt; long &lt; unsigned long &lt; float &lt; double</p>
                    <p>L'opérande d'un type inférieur est automatiquement promu dans le type de l'autre opérande (de type supérieur).</p>
                    <p>Les <span class="em">conversions d'affectation</span> permettent à l'opérande de droite d'être converti pour rester compatible avec le type de l'opérande de gauche.</p>
                    <p>Dans l'exemple suivant,</p>
<pre class="taille60"><code>long a;
int b = 4;
double x = 4.2;
double y = 2.3;

a = (int)x*y + b;</code></pre>
                    <p>en fonction de la priorité des opérateurs, nous rencontrons les conversions suivantes :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>(int)x</td>
                                <td>conversion explicite</td>
                                <td>la valeur réelle contenue dans la variable double x est convertie en int avec perte de la partie décimale</td>
                            </tr>
                            <tr>
                                <td>(int)x*y</td>
                                <td>conversion binaire</td>
                                <td>la multiplication est réalisée dans le type double, le premier opérande (int)x est converti en double (comme y)</td>
                            </tr>
                            <tr>
                                <td>(int)x*y + b</td>
                                <td>conversion binaire</td>
                                <td>la somme est réalisée dans le type double, le deuxième opérande b est converti en double</td>
                            </tr>
                            <tr>
                                <td>a = (int)x*y + b</td>
                                <td>conversion d'affectation</td>
                                <td>le résultat est converti en long int avec perte de la partie décimale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Que vaut le résultat de cette expression ?</p>
                    <h3 id="litteraux_C">Les littéraux :</h3>
                    <p>Il est tout à fait possible d'introduire des valeurs dans le code du programme. Ces valeurs peuvent être des valeurs <span class="souligne">entières</span> ou <span class="souligne">réelles</span>, des <span class="souligne">caractères</span> et même des <span class="souligne">chaînes de caractères</span> (strings).</p>
                    <p class="souligne">représentant une valeur entière :</p>
                    <ul>
                        <li>en notation décimale (int par défaut) : 15, -232</li>
                        <li>en notation décimale (pour un long) : 15L</li>
                        <li>en notation décimale (pour un unsigned) : 15U</li>
                        <li>en notation décimale (pour un unsigned long) : 15UL</li>
                        <li>en noatation octale : O17</li>
                        <li>en notation hexadécimale : 0XF, 0XABC3</li>
                    </ul>
                    <p class="souligne">représentant une valeur réelle :</p>
                    <ul>
                        <li>double par défaut : 1.45, -3.14, 31.4E-14</li>
                        <li>pour des float : 1.45F, -2E3F</li>
                        <li>pour des long double : 1.45L, -2E3L</li>
                    </ul>
                    <p class="souligne">représentant un caractère :</p>
                    <p>En général, C considère les caractères sur un byte (permettant de représenter les 128 caractères du code Ascii standard). Les caractères sont introduits entre des simples quotes. Ils peuvent être donnés :</p>
                    <ul>
                        <li><span class="em">sous forme de caractères :</span> 'a', 'z', '2'</li>
                        <li><span class="em">en notation octale :</span> '\377', '\0'</li>
                        <li>
                            <p class="em">sous forme échappée :</p>
                            <ul>
                                <li>'\a' : sonnerie</li>
                                <li>'\b' : backspace</li>
                                <li>'\f' : saut de page</li>
                                <li>'\n' : passage à la ligne</li>
                                <li>'\r' : carriage return</li>
                                <li>'\t' : tabulation</li>
                                <li>'\v' : tabulation verticale</li>
                                <li>'\\' : le caractère \</li>
                            </ul>
                        </li>
                        <li><span class="em">en notation hexadécimale :</span> '\xab'</li>
                    </ul>
                    <p class="souligne">représentant un chaîne de caractères :</p>
                    <p>Elles sont notées entre les caractères doubles quotes <span class="em">"</span>, par exemple <span class="em">"Voici une chaîne de caractères"</span>.</p>
                    <p>Elles sont stockées, en mémoire, dans le Data Segment, ce qui signifie qu'elles sont invariables durant la vie de l'application.</p>
                    <p>Elles sont constituées du tableau formé par les caractères de la chaîne et terminé par le caractère de code Ascii 0X00 ('<span class="em">0</span>').</p>
                    <p>Il est possible d'incorporer des caractères représentés par leur valeur octale ou hexadécimale, protégés par '\'. Cela nécessite toutefois d'être prudent car si la valeur du caractère ainsi précisée dépasse la taille d'un byte ou utilise des symboles incorrects, le compilateur interprétera la valeur en fonction de ses règles de conversion. Par exemple "\191" sera constituée des caractères '\1', '9', '1', '\0', de même "\1111" sera une chaîne de 2 caractères '\111', '1' et '\0', tout comme "\xabc" est constituée de '\xab', 'c', et '\0'.</p>
                    <h3 id="identificateurs">Les identificateurs :</h3>
                    <p>Les identificateurs représentent le nom d'un élément utilisé dans un programme pour identifier une variable, une constante, une fonction, etc.</p>
                    <p>Ils sont composés de lettres (minuscules ou majuscules), de chiffres et du caractère '_', mais il ne peuvent pas commencer par un chiffre. Le C est "case sensitive", c'est-à-dire que les minuscules et majuscules sont considérées comme des caractères différents.</p>
                    <h4 id="declaration_definition_variable_C">Déclaration et définition d'une variable :</h4>
                    <p>C distingue <span class="em">déclaration</span> et <span class="em">définition</span> de variables et de fonctions. Une déclaration indique simplement l'existence d'un élément dont le nom et le type ont été spécifiés. Il n'y a pas de réservation de mémoire et l'élément ne peut pas encore être utilisé. Par contre lors d'une définition de variable ou de fonction, il y a physiquement réservation d'espace mémoire (pour y stocker une valeur ou pour donner le code de la fonction). Nous reviendrons plus tard sur cette distinction.</p>
                    <p>Une variable se déclare en spécifiant son type et l'identificateur qui la représente dans le programme, tandis que lorsqu'on définit une variable, il est possible de lui donner une valeur initiale. Par exemple :</p>
<pre class="taille60"><code>int a; /* déclaration ou définition de la variable a de type int */
short b = 3; /* définition de la variable b de type short, initialisée à la valeur 3 */</code></pre>
                    <p>Les déclarations (définitions) multiples (plusieurs déclarations (définitions) dans la même expression) sont permises.</p>
<pre class="taille60"><code>int a, b, c = 5, d; /* définition des variables de type int a, b, c, d où seule c est initialisée */</code></pre>
                    <p>Remarque : la valeur d'initialisation peut être le résultat d'une expression mais elle doit être connue lors de la compilation.</p>
<pre class="taille60"><code>int taille = 3 * 4;
int tailleD = taille * 2;</code></pre>
                    <h4 id="constantes">Les constantes :</h4>
                    <p>En ANSI C, il existe deux techniques pour définir une constante : soit en utilisant une macro (via la directive de préprocesseur <span class="em">#define</span>)</p>
<pre class="taille60"><code>#define MAX 10</code></pre>
                    <p>qui sera convertie en sa valeur lors de la précompilation, soit en définissant une variable qualifiée de constante (via le mot réservé <span class="em">const</span>) :</p>
<pre class="taille60"><code>const int MAX = 10;</code></pre>
                    <p>Notez que, par convention, l'identificateur d'une constante sera toujours composé de lettres majuscules.</p>
                </article>
                <article>
                    <h2 id="instructions">Les instructions :</h2>
                    <p>Le langage C est un <span class="em">langage structuré</span>.</p>
                    <p>Un programme écrit en C est composé d'une suite d'instructions pouvant être une <span class="souligne">instruction simple</span>, un <span class="souligne">bloc d'instructions</span>, une <span class="souligne">répétitive</span> ou une <span class="souligne">alternative</span>. Le C permet également l'écriture de <span class="souligne">fonctions</span>.</p>
                    <h3 id="instructions_simples">Les instructions simples :</h3>
                    <ul>
                        <li>
                            <p>Le C accepte l'usage de l'instuction nulle (ou instruction vide), marquée par le caractère '<span class="em">;</span>', le terminateur d'instructions.</p>
<pre class="taille60"><code>; /* instruction nulle */</code></pre>
                        </li>
                        <li>
                            <p>Il permet également l'utilisation de l'instruction-expression, qui évalue l'expression pour ses effets de bord.</p>
<pre class="taille60"><code>20 + 2 * b; /* instruction sans effet de bord : évaluation puis oubli du résultat */
a = 20 + 2 * b; /* instruction avec effet de bord : évaluation puis affectation du résultat à une variable */</code></pre>
                            <p>Nous rencontrerons essentiellement trois cas d'utilisation : les affectations</p>
<pre class="taille60"><code>a = b * c;</code></pre>
                            <p>les pré ou post incrémentations et décrémentations</p>
<pre class="taille60"><code>a++; a--; ++a; --a;</code></pre>
                            <p>et les appels de fonctions de type void ou dont la valeur de retour n'est pas exploité</p>
<pre class="taille60"><code>printf(...);</code></pre>
                        </li>
                        <li><span class="em">break</span> : instruction qui permet de quitter une branche du switch ou de sortir d'une répétitive directement, sans réévaluer la condition.</li>
                        <li><span class="em">continue</span> : instruction qui permet de quitter une branche du switch ou de sortir d'une répétitive directement, sans réévaluer la condition.</li>
                    </ul>
                    <h3 id="bloc_instructions">Le bloc d'instructions :</h3>
                    <p>Lorsque plusieurs instructions doivent être traitées conjointement, elles sont regroupées en un bloc d'instructions encadrés par une paire d'accolades '<span class="em">{</span>' et '<span class="em">}</span>'.</p>
<pre class="taille60"><code>{
    instr1;
    instr2;
    ...
}</code></pre>
                    <p>Du point de vue de la syntaxe, un bloc se comporte comme une instruction unique et figure en tout endroit où une instruction simple est permise. Il n'est pas suivi par le ';' car les accolades servent de délimiteurs.</p>
                    <p>Un bloc d'instructions peut débuter par la définition d'un certain nombres de variables, locales à ce bloc d'instructions (c'est-à-dire leur existence se termine à la fin du bloc).</p>
<pre class="taille60"><code>{
    définition de variables;

    liste d'instructions
}</code></pre>
                    <p>Attention : La norme ANSI-C (C90) oblige les variables à être toujours déclarées avant la première instruction du bloc. Cette contrainte a été levée depuis la norme C99. Cependant le mélange de déclarations et d'instructions n'est pas recommandé afin de préserver la lisibilité du code.</p>
                    <p>Si un identificateur redéfinit une variable déjà existante, la nouvelle variable occulte l'ancienne, définie dans un bloc englobant. Dans l'exemple suivant,</p>
<pre class="taille60"><code>{ // bloc englobant
    int i = 5;
    { // sous-bloc
        int i = 7;
        printf("i vaut %d\n", i++);
    }
    printf("i vaut %d\n", i);
}</code></pre>
                    <p>l'affichage donnera :</p>
<pre class="taille60"><code>i vaut 7
i vaut 5</code></pre>
                    <p>Notez que les instructions imbriquées (que ce soit dans un bloc ou dans une structure de contrôle de type alternative ou répétitive) sont indentées à l'aide de tabulations ou d'espaces, de façon homogène dans tous les fichiers sources d'un projet. Cette convention d'écriture facilite la maintenance et la relecture des sources.</p>
                    <h3 id="repetitives">Les répétitives :</h3>
                    <p>Le langage C connaît différents types de répétitives : le <span class="em">while</span>, le <span class="em">for</span> et le <span class="em">do ... while</span>. Toutes ces répétitives utilisent une condition de continuation, c'est-à-dire que l'itération suivante est réalisée si la condition testée vaut VRAI. En d'autres mots, la boucle se termine lorsque la condition devient FAUX.</p>
                    <h4 id="while">while :</h4>
                    <p>Cette répétitive est utilisée lorsque l'on désire répéter plusieurs fois une instruction (ou un bloc d'instructions). La condition est vérifiée avant d'entamer l'itération et donc si la condition est directement FAUX, l'instruction n'est pas exécutée.</p>
<pre class="taille60"><code>while (cdt)
    instruction;</code></pre>
                    <p>ou</p>
<pre class="taille60"><code>while (cdt) {
    instruction1;
    instruction2;
}</code></pre>
                    <p>Pour éviter toute ambiguité, une répétitive sans instruction s'écrira comme suit (en utilisant une instruction nulle) :</p>
<pre class="taille60"><code>while (cdt)
    ;</code></pre>
                    <p>Dans l'exemple suivant, nous effectuons une lecture sur l'entrée standard stdin et quittons la répétitive lorsque l'utilisateur introduit la fin des données.</p>
<pre class="taille60"><code>char ligne[256];
while (fgets(ligne, 256, stdin) != NULL) {
    printf("%s", ligne);
}</code></pre>
                    <h4 id="do_while">do ... while :</h4>
                    <p>Cet autre type de répétitive s'emploie très rarement, uniquement lorsque l'on est certain que la répétitive doit s'exécuter au moins une fois. Pour éviter toute confusion avec le while, il est recommandé de respecter les conventions suivantes :</p>
                    <ul>
                        <li>On mettra toujours les instructions entre accolades, même si il n'y a qu'une seule instruction dans le bloc.</li>
                        <li>L'accolade fermante sera écrite sur la même ligne que le while.</li>
                        <li>On placera toujours le point virgule directement après la condition, sur la même ligne, pour éviter toute confusion avec le while instruction nulle.</li>
                    </ul>
<pre class="taille60"><code>do {
    instruction;
} while (cdt);</code></pre>
                    <h4 id="for">for :</h4>
                    <p>Le for est une écriture condensée du while. Il est constitué de 3 parties : l'<span class="em">initialisation</span>, la <span class="em">condition</span> et l'<span class="em">adaptation</span>.</p>
                    <p>L'<span class="em">initialisation</span> est exécutée à l'entame de la répétitive, une seule fois au début de l'exécution de la répétitive; si plusieurs expressions doivent composer cette initialisation, elles sont séparées par une virgule '<span class="em">,</span>'.</p>
                    <p>La <span class="em">condition</span> est une condition de continuation, elle est exécutée une première fois juste après l'initialisation (et donc le corps de la répétitive peut ne pas être exécuté) et à chaque nouvelle répétition de la boucle.</p>
                    <p>L'<span class="em">adaptation</span> est exécutée à la fin de chaque itération, juste avant une nouvelle évaluation de la condition.</p>
<pre class="taille60"><code>for (int i = 0; i &lt; 5; i++) {
    printf("%d\n", i);
}</code></pre>
                    <p>Bien que l'ANSI-C l'interdise, la définition de variables locales dans l'initialisation d'un for est autorisée dans les normes suivantes. Cette fonctionnalité entraîne la possibilité de créer une variable de boucle temporaire pour l'instruction for :</p>
<pre class="taille60"><code>{
    for (int i = 0; i &lt; 10; i++) {
        // variable i utilisable uniquement dans la boucle for
    }
    // variable i inexistante
}</code></pre>
                    <p>restreint l'utilisation de la variable compteur au corps de la boucle for, contrairement à l'écriture :</p>
<pre class="taille60"><code>{
    int i;
    for (i = 0; i &lt; 10; i++) {
        // variable i utilisable
    }
    // variable i utilisable
}
// variable i inexistante</code></pre>
                    <p>Remarque : D'un point de vue algorithmique, il est interdit de modifier la variable compteur ('i' dans l'exemple précédent) dans le corps d'une boucle for car cette structure de contrôle applique automatiquement l'adaptation du compteur (ici l'incrémentation i++) à chaque tour de boucle.</p>
                    <p>Remarque : Une boucle for peut s'écrire de manière parfaitement équivalente à l'aide d'une boucle while. Ansi, si l'on reprend la boucle for du dernier exemple :</p>
<pre class="taille60"><code>int i = 0; // initialisation
while (i &lt; 10) { //condition de continuation
    printf("%d\n", i);
    i++; // adaptation
}</code></pre>
                    <p>Dans ce cas, quand doit-on utiliser un for et quand doit-on utiliser un while ? Simple : on utilise la boucle for quand on connaît à l'avance le nombre de répétitions de la boucle et on utilise le plus souvent la boucle while quand on ne sait pas combien de fois la boucle va être exécutée.</p>
                    <h3 id="alternatives">Les alternatives :</h3>
                    <p>C connaît deux types de traitements conditionnels : les <span class="em">alternatives</span>, qui permettent de réaliser ou pas un traitement en fonction d'une condition, et les <span class="em">switch</span>, qui réalisent un traitement en fonction du contenu d'une variable dénombrable (entière).</p>
                    <h4 id="if">if :</h4>
                    <p>Plusieurs syntaxes sont possibles pour marquer une alternative simple</p>
<pre class="taille60"><code>if (cdt)
    instruction;</code></pre>
                    <p>soit la forme avec accolades (indispensables si le bloc est composé de plusieurs instructions; optionnelles si le bloc est composé d'une instruction simple)</p>
<pre class="taille60"><code>if (cdt) {
    instruction;
}</code></pre>
                    <p>et les <span class="em">if else</span></p>
<pre class="taille60"><code>if (cdt) {
    instruction1;
    ...
} else {
    instruction2;
    ...
}</code></pre>
                    <p>Attention au problème du dangling else : le <span class="em">else</span> se rapporte toujours au dernier <span class="em">if</span> libre qui le précède et dans le même bloc (quelle que soit l'indentation utilisée par le programmeur).</p>
<pre class="taille60"><code>if (a &gt; b)
    if (c &gt; d)
        if (c &gt; 0)
            c++;
        else
            d++
    else
        a++
</code></pre>
                    <h4 id="switch">switch :</h4>
                    <p>Le <span class="em">switch</span> peut être considéré comme un branchement multiple en fonction d'une valeur entière. Dès que l'on est aiguillé vers une branche, le traitement se poursuit en séquence. Cela signifie que toutes les instructions qui suivent le case sont excutées, jusqu'à la fin du bloc ou jusqu'à une instruction de rupture <span class="em">break</span> qui permet de quitter la structure de contrôle.</p>
<pre class="taille60"><code>swith (exp) {
    case val1 :
    case val2 :
        ... // instructions exécutées si exp = val1 ou val2
        break;
    case val3 :
        ... // instructions exécutées si exp = val3
    case val4 :
        ... // instructions exécutées si exp = val4 ou val3
        break;
    default:
        ... // instructions exécutées si exp &lt;&gt; val1, val2, val3, val4
}</code></pre>
                    <p>Remarque : Si l'expression du switch ne vaut aucune des valeurs case ou qu'aucun break n'a été exécuté, c'est la clause <span class="em">default</span> qui sera exécutée.</p>
                    <p>Remarquez qu'une instruction switch classique, telle que :</p>
<pre class="taille60"><code>switch (exp) {
    case val1 :
        instructions1
        break;
    case val2 :
        instructions2
        break;
    case val3 :
        instructions3
        break;
    default :
        instructions4
}</code></pre>
                    <p>peut être exprimée à l'aide d'instructions if imbriquées :</p>
<pre class="taille60"><code>if (exp == val1) {
    instructions1;
} else if (exp == val2) {
    instructions2;
} else if (exp == val3) {
    instructions3;
} else {

}</code></pre>
                    <p>Notez que pareille imbrication ne nécessite pas d'augmenter l'indentation de chaque nouveau if. Cette convention d'écriture exprime simplement le fait qu'un seul traitement du branchement conditionnel sera exécuté. Tous les traitements sont donc écrits sur le même niveau d'indentation. Bien que ces deux écritures peuvent être considérées comme équivalentes, l'utilisation d'un switch sera préférée car plus simple et plus lisible.</p>
                </article>
                <article>
                    <h2 id="tableaux">Les tableaux :</h2>
                    <p>Les tableaux en langage C ressemble à ce que vous avez appris en Java. Mais vous devez être attentifs aux nombreuses différences qui risquent de vous poser problèmes.</p>
                    <p>En C, la taille des tableaux est fixée à la compilation. C'est le résultat d'une expression entière constante qui ne peut en aucun cas être modifiée en cours d'exécution. Nous verrons plus tard qu'il existe une autre forme de tableau, dynamique, qui permet de gérer la taille de la table en cours d'exécution de l'application.</p>
                    <p>Comme il a été écrit dans l'introduction, le langage C ne réalise que très peu de contrôle, notamment en ce qui concerne la gestion des tableaux. Ni à la compilation, ni durant l'exécution, il n'y a vérification que l'indice (numéro de l'élément dans le tableau) reste dans les limites de l'index (ensemble des indices possibles (de 0 à taille-1)). Il n'y aura notamment pas d'avertissement si vous utilisez un indice négatif, ni si vous dépassez la limite de la table.</p>
                    <h3 id="definition_tableau">Définition d'un tableau :</h3>
                    <p>Pour définir un tableau dans un programme C vous devez spécifier le type des éléments, le nom du tableau et sa taille. Notez que <span class="em">l'index d'un tableau commence toujours à la valeur 0</span>.</p>
                    <p>Une seule syntaxe est reconnue :</p>
<pre class="taille60"><code>int table[4]; // définition d'une table de 4 int d'indices compris entre 0 et 3
double monTableau[N * M]; // valable si M et N sont connus à la compilation</code></pre>
                    <p>Notez que <span class="em">la dimension d'un tableau ne peut être qu'une constante ou une expression constante</span> (cf. <a href="#compilateur_cc">flag vla du compilateur cc</a>), telles que :</p>
<pre class="taille60"><code>#define N 50 // définition d'une constante N
...
int t[N];
float h[2 * N - 1];</code></pre>
                    <p>Remarquez qu'une constante symbolique, définie à l'aide du mot-clé <span class="em">const</span>, ne constitue pas une expression constante. Elle ne convient donc pas pour définir la taille d'un tableau.</p>
                    <p>Une table peut être initialisée lors de sa définition. Les valeurs doivent alors être spécifiées entre accolades, comme dans l'exemple :</p>
<pre class="taille60"><code>int table[4] = {1, 123, -15, 8};</code></pre>
                    <p>Dans ce cas, il faut rester attentif au fait que la taille de la table doit être suffisante pour éviter une erreur de compilation. Par contre, si la taille est supérieure au nombre de valeurs d'initialisation, les derniers éléments sont initialisés à la valeur 0. Par exemple : dans la définition suivante,</p>
<pre class="taille60"><code>int table[4] = {1, 3};</code></pre>
                    <p>les 2 derniers éléments (aux indices 2 et 3) de la table sont automatiquement initialisés à 0.</p>
                    <p>Autre possibilité, utiliser une taille implicite pour la table, valant le nombre d'éléments donnés en initialisation, comme dans l'exemple suivant :</p>
<pre class="taille60"><code>int[] = {1, 5, -67};</code></pre>
                    <p>La table aura dès lors une dimension de 3.</p>
                    <h3 id="utilisation_tableaux">Utilisation :</h3>
                    <p>L'accès à un élément d'un tableau se fait en spécifiant le nom de la table et la valeur de l'indice noté entre les caractères '<span class="em">[</span>' et '<span class="em">]</span>'.</p>
<pre class="taille60"><code>table[2]++; // post incrémentation du 3ème élément du tableau</code></pre>
                    <p>Le langage C n'a pas prévu de conserver la taille d'un tableau dans une structure particulière. Cette spécificité du langage a comme conséquences :</p>
                    <ul>
                        <li>qu'il est impossible d'obtenir la taille sans programmer explicitement sa gestion;</li>
                        <li>que le compilateur n'offre aucun contrôle quant aux valeurs utilisées comme indice, que cette valeur soit négative ou supérieure à la taille de la table. Ce dernier point peut constituer une grande faille de sécurité.</li>
                    </ul>
                    <p>Puisque l'index commence toujours à 0, les valeurs possibles pour un indice sont comprises entre 0 et la taille - 1.</p>
                    <h3 id="tableaux_multidimensionnels">Tableaux multidimensionnels :</h3>
                    <p>Un tableau à 2 dimensions est considéré en C comme un tableau de tableaux ce qui implique que les indices doivent s'indiquer chacun entre crochets '<span class="em">[</span>' et '<span class="em">]</span>'. L'instuction <span class="html">int matrice[4][3];</span> est la définition d'un tableau de 4 sous-tableaux (4 lignes), chacun contenant 3 int (3 colonnes). En mémoire, ces 12 éléments sont stockés consécutivement.</p>
                    <p>L'initialisation d'un tableau multidimensionnel se fait en initialisant chaque sous-tableau. Les sous-tableaux non explicitement initialisés le sont à 0.</p>
<pre class="taille60"><code>int matrice[3][5] = {{1, 3, 5}, {2, 4}};</code></pre>
                    <p>L'accès à un des éléments de cette matrice se réalise en indiquant les 2 indices, comme dans l'exemple suivant qui initialise le dernier élément de la table déclarée précédemment à 5 :</p>
<pre class="taille60"><code>matrice[2][4] = 5;</code></pre>
                    <p>Une erreur fréquente est l'utilisation d'une notation semblable à celle employée en mathématique, en séparant les indices par une virgule. Cette écriture <span class="html">matrice[2, 1];</span> est acceptée par le compilateur mais a toutefois une signification différente de ce que vous avez appris en mathématique. (Cette notation est en fait équivalente à matrice[1], qui référence la seconde ligne du tableau. En effet, en C, l'opérateur virgule signifie que les expressions qui l'entourent sont évaluées séquentiellement de gauche à droite, donc "2, 1" vaut1. Nous verrons <a href="#pointeurs">plus tard</a> que matrice[1] correspond à un pointeur vers un int.)</p>
                </article>
                <article>
                    <h2 id="pointeurs">Les pointeurs :</h2>
                    <p>La présentation du langage C nous a fait remarqué qu'un des intérêts du C est son efficacité. Une de ces bonnes performances tient à la gestion aisée de la mémoire, proche de ce que permet un langage d'assemblage. La manipulation des adresses mémoire se fait au moyen des <span class="em">pointeurs</span>. Un pointeur est un type particulier, capable de conserver l'adresse d'un byte de la mémoire. Le pointeur est intimement lié au type de la donnée stockée à cette adresse, de manière à en respecter les contraintes.</p>
                    <h3 id="utilisation_pointeurs">Utilisation :</h3>
                    <p>La définition d'une variable de type pointeur nécessite de spécifier le type de la donnée qui sera accédée par le pointeur. Le symbole utilisé pour définir un type pointeur est le caractère <span class="em">*</span>. Par exemple, <span class="html">int *ptrI;</span> définit ptrI comme étant un pointeur sur un int, c'est-à-dire une variable qui contient l'adresse du premier byte d'une zone mémoire pouvant contenir un int. Tel que défini, le pointeur n'a pas été initialisé et il n'y a pas de réservation de place mémoire pour la valeur pointée.</p>
                    <img src="../images/pointeur.png" alt="pointeur">
                    <p>définit ptrI comme étant un pointeur sur un int, c'est-à-dire une variable qui contient l'adresse du premier byte d'une zone mémoire pouvant contenir un int. Tel que défini, le pointeur n'a pas été initialisé et il n'y a pas de réservation de place mémoire pour la valeur pointée. <span class="em">Un pointeur doit donc être initialisé avant d'être utilisé.</span></p>
                    <p>Pour être initialisé, un pointeur doit recevoir une adresse. Différentes possibilités s'offrent à nous :</p>
                    <ul>
                        <li>
                            <p>l'adresse d'une variable déjà définie; pour l'obtenir, il faut utiliser l'opérateur <span class="em">&amp;</span>.</p>
<pre class="taille60"><code>ptrI = &amp;varA;</code></pre>
                            <p>ptrI reçoit l'adresse la variable varA.</p>
                            <img src="../images/pointeursurA.png" alt="pointeurs sur A">
                        </li>
                        <li>
                            <p>l'adresse d'un tableau :</p>
<pre class="taille60"><code>ptrI = tab;</code></pre>
                            <p>ptrI reçoit l'adresse du tableau tab, c'est-à-dire l'adresse du premier élément du tableau. Cette affectation est donc équivalente à : ptrI = &tab[0].</p>
                        </li>
                        <li>l'adresse d'une zone <a href="#memoire_dynamique">mémoire dynamique</a> (voir plus bas).</li>
                        <li>ou encore l'adresse NULL spécifiant une adresse inaccessible. Cette valeur sera également utilisée comme valeur de retour pour indiquer qu'une fonction ne s'est pas terminée correctement.</li>
                    </ul>
                    <p>Le contenu de la mémoire référencée par un pointeur est obtenu en appliquant l'opérateur <span class="em">*</span> au pointeur (la déréférenciation), comme le montre l'exemple suivant :</p>
<pre class="taille60"><code>printf("%d", *ptrI); // affiche la valeur entière pointée par ptrI</code></pre>
                    <h4 id="priorite_operateurs_pointeurs">La priorité des opérateurs :</h4>
                    <p>Nous avons abordé la <a href="#operateurs">priorités des principaux opérateurs</a> lors de la présentation du langage. Nous pouvons ajouter à la liste les opérateurs liés à la manipulation des pointeurs :</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Niveau de priorité</th>
                                <th>Opérateur</th>
                                <th>Description</th>
                                <th>Associativité</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td rowspan="2">17</td>
                                <td>[]</td>
                                <td>indice de tableau</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>(...)</td>
                                <td>appel de fonction</td>
                            </tr>
                            <tr>
                                <td rowspan="2">16</td>
                                <td>++</td>
                                <td>post-incrémentation</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>--</td>
                                <td>post-décrémentation</td>
                            </tr>
                            <tr>
                                <td rowspan="2">15</td>
                                <td>++</td>
                                <td>pré-incrémentation</td>
                                <td rowspan="2">droite</td>
                            </tr>
                            <tr>
                                <td>--</td>
                                <td>pré-décrémentation</td>
                            </tr>
                            <tr>
                                <td rowspan="7">15</td>
                                <td>sizeof</td>
                                <td>calcule la taille d'une variable (d'un type)</td>
                                <td rowspan="7">droite</td>
                            </tr>
                            <tr>
                                <td>~</td>
                                <td>complément à 1 (inversion des bits)</td>
                            </tr>
                            <tr>
                                <td>!</td>
                                <td>non logique</td>
                            </tr>
                            <tr>
                                <td>+</td>
                                <td>identité (opérateur unaire)</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>changement de signe complément à 2</td>
                            </tr>
                            <tr>
                                <td class="gras">&amp;</td>
                                <td class="gras">adresse</td>
                            </tr>
                            <tr>
                                <td class="gras">*</td>
                                <td class="gras">indirection, déréférenciation</td>
                            </tr>
                            <tr>
                                <td>14</td>
                                <td>(type)</td>
                                <td>cast, changement forcé de type</td>
                                <td>droite</td>
                            </tr>
                            <tr>
                                <td rowspan="3">13</td>
                                <td>*</td>
                                <td>multiplication</td>
                                <td rowspan="3">gauche</td>
                            </tr>
                            <tr>
                                <td>/</td>
                                <td>division</td>
                            </tr>
                            <tr>
                                <td>%</td>
                                <td>modulo (uniquement si opérandes entiers)</td>
                            </tr>
                            <tr>
                                <td rowspan="2">12</td>
                                <td>+</td>
                                <td>addition</td>
                                <td rowspan="2">gauche</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>soustraction</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="conversions_pointeurs">Les conversions de pointeurs :</h3>
                    <p>Les compilateurs C remplacent automatiquement les tables par des pointeurs. Ils appliquent l'<a href="#arithmetique_pointeurs">arithmétique des pointeurs</a> pour convertir les indices. En C, un tableau est donc considéré comme un pointeur constant, sa valeur (l'adresse en mémoire des données) est invariante. D'autres conversions sont permises, telles que les conversions explicites (par cast)</p>
                    <table>
                        <thead>
                            <tr>
                                <th>type de destination (cast)</th>
                                <th>type d'origine</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>type entier</td>
                                <td>pointeur</td>
                            </tr>
                            <tr>
                                <td>T* ou void*</td>
                                <td>
                                    <p>un type entier</p>
                                    <p>void*</p>
                                    <p>Q*</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>ou automatiques (lors d'affectations) sont appliquées :</p>
                    <table>
                        <thead>
                            <tr>
                                <th>type à gauche</th>
                                <th>type permis à droite (sans cast)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>void*</td>
                                <td>0 ou T* ou void*</td>
                            </tr>
                            <tr>
                                <td>T* ou void*</td>
                                <td>0 ou T* ou void*</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3 id="memoire_dynamique">Mémoire dynamique :</h3>
                    <p>Vous avez vu dans le cours de langage d'assemblage qu'il existe <a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/" target="_blank">plusieurs segments pour constituer un programme</a>.</p>
                    <img src="../images/Memory-Layout.gif" alt="Memory Layout">
                    <p>Le <span class="em">code segment</span> contient toutes les lignes de code; le <span class="em">data segment</span> contient les données initialisées, le <span class="em">bss</span> regroupe les variables globales non initialisées à la compilation (elles seront dans ce cas mise à zéro); la <span class="em">pile</span> mémorise les informations utiles des sous-programmes et le <span class="em">heap</span> correspond à la partie de la mémoire que le programme va utiliser pour alimenter les demandes de mémoire dynamique.</p>
                    <p>Dans un programme C, la mémoire dynamique est allouée en réponse à l'appel de la fonction <a href="#malloc">malloc</a>, ou d'une fonction dérivée <a href="#calloc">calloc</a> ou <a href="#realloc">realloc</a>.</p>
                    <p>La fonction <a href="http://man7.org/linux/man-pages/man3/malloc.3.html" target="_blank">malloc</a> alloue le nombre de bytes demandé dans l'argument, cette mémoire est accédée grâce au pointeur retourné par la fonction. En cas de problème, la fonction renvoie un pointeur nul NULL. Il est donc impératif de toujours tester le code retour de la fonction. Voici un exemple de création d'une zone mémoire pouvant contenir une valeur double :</p>
<pre class="taille60"><code>double *ptrD;
if ((ptrD = (double *)malloc(sizeof(double))) == NULL) {
    perror("Allocation dynamique de ptrD impossible");
    return 1;
}</code></pre>
                    <p>De même, la fonction malloc permet de créer des tableaux dynamiques, comme dans l'exemple suivant qui crée un tableau de 10 int :</p>
<pre class="taille60"><code>int *tabDyn;
if ((tabDyn = (int*)malloc(10 * sizeof(int))) == NULL) {
    perror("Allocation dynamique de ptrD impossible");
    return 1;
}</code></pre>
                    <p>La particularité de la fonction <a href="http://man7.org/linux/man-pages/man3/calloc.3.html" target="_blank">calloc</a> est d'allouer une zone mémoire initialisée à zéro tandis que la fonction <a href="http://man7.org/linux/man-pages/man3/realloc.3.html" target="_blank">realloc</a> permet de réallouer une zone mémoire en en modifiant la taille tout en conservant le contenu stocké dans la mémoire.</p>
<pre class="taille60"><code>if ((tabDyn = (int*)realloc(tabDyn, 20 * sizeof(int))) == NULL) {
	perror("Allocation dynamique de tabDyn impossible");
	return 1;
}</code></pre>
                    <p>Dans cet exemple, la table tabDyn est réallouée, éventuellement à un autre endroit de la mémoire, sa taille est doublée mais le contenu est conservé.</p>
                    <p>Pour une gestion saine de l'espace mémoire, il faut éviter de provoquer des <span class="em">fuites de mémoire</span> (memory leaks), c'est-à-dire des zones mémoires qui ne sont plus accessibles, donc perdues pour l'application. La conséquence d'une telle fuite peut être la saturation de la mémoire de la machine, ce qui provoque l'interruption du processus. Il est par conséquent recommandé de libérer toute mémoire dynamique devenue inutile dans l'application. Cette libération de mémoire se fait grâce à la fonction <a href="http://man7.org/linux/man-pages/man3/free.3.html" target="_blank">free</a>.</p>
<pre class="taille60"><code>free(tabDyn);</code></pre>
                    <p>Une règle simple à appliquer pour éviter les fuites de mémoire est de faire systématiquement correspondre un appel à free pour chaque appel à malloc ou calloc.</p>
                    <h3 id="arithmetique_pointeurs">arithmétique des pointeurs :</h3>
                    <p>Le langage C permet de modifier la valeur d'un pointeur en y appliquant des expressions mettant en jeu une arithmétique particulière, l'<span class="em">arithmétique des pointeurs</span>. Dans cette technique, le compilateur prend en compte la taille de l'élément pointé lors de l'ajout (ou la suppression) d'une ou de plusieurs unités, comme dans l'exemple suivant :</p>
<pre class="taille60"><code>int *ptr, tab[5] = {3, 8, 11, 2, -4};
ptr = tab;</code></pre>
                    <img src="../images/table1.png" alt="table1">
<pre class="taille60"><code>ptr++;</code></pre>
                    <img src="../images/table2.png" alt="table2">
                    <p>où l'incrémentation permet d'ajouter au pointeur ptr un nombre de bytes égal à la taille de l'élément et donc d'accéder à l'élément suivant de la table. Comme toujours en C, il n'y a pas de vérification et la prudence reste de vigueur.</p>
                    <p>La soustraction de 2 pointeurs de même type donne le nombre d'éléments qui séparent les 2 adresses (et pas le nombre de bytes !).</p>
<pre class="taille60"><code>indice = ptr - tab;</code></pre>
                    <p>Remarquez que l'addition de 2 pointeurs est permise par le compilateur mais le résultat sera non significatif, sans doute hors de l'espace d'adressage du programme. Les autres opérations sont sans objet.</p>
                    <h3 id="parcours_table_pointeurs">Parcours d'une table par pointeurs :</h3>
                    <p>Il est plus efficace de parcourir une table en utilisant un pointeur, car de cette façon, on évite le calcul de l'indice à chaque itération. Par exemple, le code</p>
<pre class="taille60"><code>int taille = 10, table[10];
for (int i = 0; i &lt; taille; i++)
    printf("%d\n", table[i]);</code></pre>
                    <p>sera remplacé avec bonheur par la version utilisant un pointeur :</p>
<pre class="taille60"><code>int taille = 10, table[10];
for (int *q = table; q - table &lt; taille; q++)
    printf("%d\n", *q);</code></pre>
                    <p>Dans la seconde boucle, l'accès à un élément du tableau ne nécessite que des incrémentations de pointeurs (q++), alors que dans la première boucle un tel accès implique des additions et des multiplications. En effet, table[i] est en réalité évalué comme suit : table + i*sizeof(int) (c'est-à-dire l'adresse du tableau, plus i fois le nombre de bytes occupés par un int).</p>
                </article>
                <article>
                    <h2 id="tableaux_multidimensionnels_statiques_dynamiques">Tableaux multidimensionnels statiques vs dynamiques :</h2>
                    <p>Supposons que l'on implémente un algorithme qui requiert une matrice à nl lignes et nc colonnes.</p>
                    <h3 id="version_statique">Version statique :</h3>
<pre class="taille60"><code>#define NL 20	/* constantes connues à la compilation */
#define NC 30

int main() {
    int i, j;
    
    /* définition d'une matrice statique */
    double m[NL][NC];
    
    /* initialisation de nl et nc en supposant que nl <= NL et nc <= NC */
    int nl = ... ;
    int nc = ... ;
    
    /* initialisation de la matrice m. Par exemple : */
    for (i = 0; i &lt; nl; i++)
        for (j = 0; j &lt; nc; j++)
            m[i][j] = i;
}</code></pre>
                    <p>En définissant une matrice statique, l'ensemble de l'espace mémoire nécessaire est alloué dès la compilation. La matrice est réalisée par un bloc en mémoire, comme le montre la figure 1.</p>
                    <img src="../images/matrice_statique.png" alt="matrice statique">
                    <p>La variable m contient une valeur constante égale à l'adresse du tableau, c'est-à-dire l'adresse du premier élément du tableau : m ↔ &m[0][0].</p>
                    <p>De même, <span class="em">m[i]</span>, pour i entre 0 et NL-1, est un pointeur constant vers un objet de type double, qui est le premier élément de la ligne d'indice i : m[i] ↔ &m[i][0].</p>
                    <p>Un élément particulier de cette matrice est une L-value (c'est-à-dire une variable), qui sera notée m[i][j]. On peut l'interpréter de la manière suivante :</p>
<pre class="taille60">m[i][j]
    = *(m[i] + j)
    = *(m + i * NC + j)
    = *(double) ((unsigned)m + (i * NC + j) * sizeof(double))<code></code></pre>
                    <p>Nosu retrouvons l'expression classique <span class="em">i * NC + j</span> caractérisant l'accès à un élément m[i][j] d'une matrice <span class="em">NL*NC</span>. Elle traduit la disposition "par lignes" des tableaux rectangulaires.</p>
                    <p>Ce mécanisme de double indexation implique que <span class="em">NC</span> doit être connu à la compilation pour que l'expression <span class="em">i * NC + j</span> ait un sens.</p>
                    <p>Voici différentes manières de parcourir un tableau statique :</p>
<pre class="taille60"><code>// parcours par indices pour une taille logique nl*nc
for (i = 0; i &lt; nl; i++) {
    for (j = 0; j &lt; nc; j++)
        printf("%f ", m[i][j]);
    printf("\n");
}
    
// parcours par indice pour une taille logique nl*nc
double *mptr = (double *)m;	// ou mptr = &m[0][0]
for (i = 0; i &lt; nl; i++) {
    for (j = 0; j &lt; nc; j++)
        printf("%f ", mptr[i * NC + j]);
    printf("\n");
}

// parcours par indice et pointeur pour une taille logique nl*nc
for (i = 0; i &lt; nl; i++) {
    double *lptr = (double *)m[i];	// ou lptr = &m[i][0]
    for (double *p = lptr; p - lptr &lt; nc; p++)
        printf("%f ", *p);
    printf("\n");
}

// parcours par pointeur valable uniquement si l'entièreté des NL*NC éléments (taille physique) sont parcourus!
double *mptr = (double *)m;	// ou mptr = &m[0][0]
for (double *p = mptr; p - mptr &lt; NL * NC; p++) {
    printf("%f ", *p);
    if ((p - mptr + 1) % NC == 0)
        printf("\n");
}</code></pre>
                    <p>La manipulation de tableaux, et non de pointeurs, possède certains inconvénients dûs au fait qu'un tableau est un pointeur constant. Ainsi :</p>
                    <ul>
                        <li>on ne peut pas créer de tableaux dont la talle est une variable du programme,</li>
                        <li>on ne peut pas créer de tableaux bidimensionnels dont les lignes n'ont pas toutes le même nombre d'éléments.</li>
                    </ul>
                    <p>Ces opérations deviennent possibles dès que l'on manipule des pointeurs alloués dynamiquement.</p>
                    <h3 id="version_dynamique">Version dynamique (par souci de clarté nous y avons omis la détection des échecs de malloc) :</h3>
<pre class="taille60">int main() {
	int i, j;
	
	/* définition d'une matrice en tant que pointeur vers un pointeur */
	/* (ici, pas besoin de constante connue à la compilation) */
	double **m;
	
	/* initialisation de nl et nc */
	int nl = ... ;
	int nc = ... ;
	
	/* initialisation des pointeurs */
	m = malloc(nl * sizeof(double *));
	for (i = 0; i &lt; nl; i++)
		m[i] = malloc(nc * sizeof(double));
	
	/* initialisation de la matrice m. Par exemple : */
	for (i = 0; i &lt; nl; i++) 
		for (j = 0; j &lt; nc; j++)
			m[i][j] = i;
				
	/* libération de la mémoire dynamique */
	for (i = 0; i &lt; nl; i++)
		free(m[i]);
    free(m);
}<code></code></pre>
                    <p>La première allocation dynamique réserve pour l'objet pointé par m l'espace-mémoire correspondant à nl pointeurs sur des doubles. Ces nl pointeurs correspondent aux lignes de la matrice. Les allocations dynamiques suivantes réservent pour chaque pointeur m[i] l'espace-mémoire nécessaire pour stocker nc doubles.</p>
                    <p>Dans cette manière de procéder, les lignes de la matrice sont allouées à l'occasion de <span class="em">nl</span> appels distincts de <span class="em">malloc</span>. La matrice est dès lors réalisée par des morceaux de mémoire éparpillée, comme le montre la figure 2.</p>
                    <img src="../images/matrice_dynamique.png" alt="matrice dynamique">
                    <p>Il est remarquable qu'un élément de la nouvelle matrice ainsi déclarée se note encore <span class="em">m[i][j]</span>. Mais maintenant, cette expression se traduira par :</p>
<pre class="taille60"><code>m[i][j]
	= *(m[i] + j)
	= *(*(m + i) + j)
	= *(double *) (*((unsigned)m + i * sizeof(double *)) + j * sizeof(double))</code></pre>
                    <p>Voici différentes manières de parcourir un tableau dynamique :</p>
<pre class="taille60">// parcours par indices
for (i = 0; i &lt; nl; i++) {
    for (j = 0; j &lt; nc; j++)
        printf("%f ", m[i][j]);
    printf("\n");
}

// parcours par indice et pointeur
for (i = 0; i &lt; nl; i++) {
    for (double *p = m[i]; p - m[i] &lt; nc; p++)	// ou p = &m[i][0]
        printf("%f ", *p);
    printf("\n");
}

// parcours par pointeurs
for (double **p = m; p - m &lt; nl; p++) {	// ou p = &m[0]
    for (double *q = *p; q - *p &lt; nc; q++)
        printf("%f ", *q);
    printf("\n");
}<code></code></pre>
                </article>
                <article>
                    <h2 id="chaines_caracteres">Les chaînes de caractères :</h2>
                    <p>Contrairement à d'autres langages, le type <span class="em">string</span> n'existe pas en C. Or cette notion est nécessaire pour permettre une interaction avec l'utilisateur qui s'exprime avec des mots. Il est donc important de pouvoir représenter et manipuler aisément des chaînes de caractères.</p>
                    <p>Le langage C va utiliser des tableaux de caractères pour stocker les chaînes de caractères. Dans le but de simplifier leurs traitements, il va introduire une particularité à ces tableaux : le tableau des caractères qui représente la chaîne sera toujours terminé par un caractère spécial : '<span class="em">\0</span>' (0x00).</p>
                    <p>Nous pouvons donc représenter la chaîne "Hello World\n" par le tableau suivant :</p>
                    <img src="../images/HelloW.png" alt="Hello World">
                    <p>Nous remarquons que, à cause du caractère fin de chaîne '\0', le nombre de bytes utilisés dans ce tableau est 13, même si la chaîne ne compte que 12 caractères.</p>
                    <p>Ce schéma illustre parfaitement l'intérêt du caractère de fin de chaîne. En effet, nous constatons que la variable str nous fournit uniquement l'adresse du premier caractère de la chaîne, seule information disponible sur cette chaîne. Le caractère '\0' permet dès lors au langage C de déterminer où se termine la chaîne.</p>
                    <h3 id="definition_chaines_caracteres">Définition de chaînes de caractères :</h3>
                    <p>L'utilisation de chaînes de caractères nécessite la définition de variables, soit sous forme d'un tableau de caractères (peut-être char mot[25]), soit sous la forme d'un pointeur sur un caractère (peut-être char *mot). La diféfrence se situe au niveau de la gestion de la mémoire.</p>
                    <p>La définition d'un tableau de caractères réserve un certain nombre de bytes en mémoire (indiqué par la taille du tableau); cela impose de copier les caractères dans le tableau.</p>
                    <p>Par contre, la définition d'un pointeur sur un caractère ne réserve aucun espace mémoire pour stocker la chaîne, mais uniquement un pointeur, c'est-à-dire une adresse où retrouver la chaîne de caractères. Pour utiliser ce pointeur, il est nécessaire de l'affecter, soit avec l'adresse d'une zone mémoire allouée (malloc), soit avec un tableau, soit avec un autre pointeur ou encore avec un littéral déclaré entre guillemets <span class="em">"</span> (défini dans le data segment RO).</p>
                    <h3 id="traitement_chaine_caracteres">Traitement des chaînes de caractères :</h3>
                    <p>Le premier point sur lequel il est nécessaire d'insister est qu'une chaîne de caractères est un tableau de caractères et que toutes les remarques énoncées à propos des tabelaux restent d'application, comme le fait de s'assurer que la zone mémoire est suffisante pour stocker tous les caractères dans le tableau, en n'oubliant pas de compter le caractère fin de chaîne '<span class="em">\0</span>'. Dans cette optique, il n'est pas inutile de rappeler que l'espace mémoire peut être réservé soit à la compilation (peut-être <a href="#definition_tableau">char ligne[257]</a>) lorsque l'on connaît la taille du tableau et qu'elle restera fixe durant la vie du processus, soit par une <a href="#allocation_dynamique">allocation dynamique</a> (lorsque la taille est inconnue à la compilation ou que cette taille peut varier en cours d'exécution).</p>
                    <p>Dans l'exemple suivant, nous définissons un tableau de 257 caractères permettant de stocker en mémoire une ligne lue sur l'entrée standard stdin (clavier). Comme nous ne connaissons pas à l'avance la taille de la ligne à lire, nous choisissons une taille que nous espérons suffisante et en lien avec les caractéristiques du système (la taille du buffer de lecture, multiple de 2^8 = 256).</p>
<pre class="taille60"><code>char ligne[257];
while (fgets(ligne, 257, stdin) != NULL) {
    printf("La chaîne lue est : '%s'", ligne);
}</code></pre>
                    <p>La fonction <a href="#chaines_caracteres">fgets</a> lit sur stdin une ligne (jusque et y compris le caractère '\n') et stocke les caractères lus dans le tableau ligne, avec un maximum de 255 caractères (pour laisser une place au caractère '\0', ajouté par la fonction elle-même); si l'utilisteur a introduit une ligne plus longue, la suite de la ligne sera lue lors de l'appel suivant de la fonction fgets.</p>
                    <p>Plusieurs fonctions permettent l'affichage d'une chaîne de caractères. Dans un premier temps; nous utiliserons la fonction printf. Le format à utiliser pour afficher une chaîne est le format <span class="em">%s</span>.</p>
                    <p>Un autre aspect à prendre en compte lors de l'utilisation des chaînes de caractères est que le langage C ne prévoit aucunement le stockage de la taille de la chaîne, cette information doit être gérée par l'application elle-même.</p>
                    <p>Les <a href="#litteraux">littéraux</a> représentant une chaîne de caractères sont encadrés du caractère <span class="em">"</span> (peut-être "Hello World\n").</p>
                    <h3 id="fonctions_standards">Les fonctions standards :</h3>
                    <p>Comme il n'existe pas de type string en C, les opérations que l'on désire accomplir sur les chaînes de caractères ne peuvent pas être réalisées au moyen d'opérateurs : pas d'opérateur de concaténation, pas d'opérateur de comparaison, etc.</p>
                    <p>Pourtant ces traitements sont nécessaires. La solution mise en place par les concepteurs du langage est de proposer des fonctions standards, adaptées au système sur lequel tourne l'application. La déclaration de ces fonctions est reprise dans le fichier d'entête <span class="em">string.h</span>, qu'il est donc impératif d'inclure dans chaque programme qui manipule des chaînes de caractères.</p>
                    <dl>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strlen.3.html" target="_blank">size_t strlen (const char *s)</a> :</dt>
                        <dd>fonction qui calcule la longueur (le nombre de caractères) de la chaîne passée en paramètre; size_t est un type entier non signé.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strcpy.3.html" target="_blank">char* strcpy (char *dest, const char *src)</a> :</dt>
                        <dd>fonction qui copie la chaîne contenue à l'adresse src dans la zone mémoire dont l'adresse est dest; le programme doit s'assurer que dest est suffisamment grand pour contenir le nombre de caractères de la source plus 1 (pour le caractère fin de chaîne '\0').</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strcat.3.html" target="_blank">char* strcat (char *dest, const char *src)</a> :</dt>
                        <dd>fonction qui concatène la chaîne pointée par src à la chaîne dont l'adresse est dest; le programme doit s'assurer que la longueur de la zone mémoire dest est au moins égale à la somme des longueurs des deux chaînes plus 1 (pour le caractère fin de chaîne '\0').</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strcmp.3.html" target="_blank">int strcmp (const char *dest, const char *src)</a> :</dt>
                        <dd>
                            <p>fonction qui concatène la chaîne pointée par src à la chaîne dont l'adresse est dest; le programme doit s'assurer que la longueur de la zone mémoire dest est au moins égale à la somme des longueurs des deux chaînes plus 1 (pour le caractère fin de chaîne '\0').</p>
                            <p>Attention, il ne faut pas confondre avec la comparaison :</p>
<pre class="taille60"><code>if (p == q) {
    printf(" ????????????? \n");
}</code></pre>
                            <p>qui compare 2 pointeurs, c'est-à-dire 2 adresses mémoires !</p>
                        </dd>
                    </dl>
                    <h4 id="fonctions_base_taille_maximale">Les fonctions de base avec une taille maximale :</h4>
                    <p>Les fonctions de base ne permettent pas de limiter le traitement des chaînes à un certain nombre de caractères, ce qui peut être gênant. La librairie standard string comprend d'autres fonctions qui reçoivent un paramètre supplémentaire : une taille maximale.</p>
                    <dl>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strncpy.3.html" target="_blank">char strncpy (char *dest, const char *src, size_t n)</a> :</dt>
                        <dd>fonction qui copie la chaîne contenue à l'adresse src dans la zone mémoire dont l'adresse est dest; la copie se termine au \0 ou après n caractères, mais dans ce dernier cas, le caractère \0 n'est pas recopié dans le tableau dest.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strncat.3.html" target="_blank">char* strncat (char *dest, const char *src, size_t n)</a> :</dt>
                        <dd>fonction qui concatène la chaîne pointée par src à la chaîne dont l'adresse est dest; la concaténation se termine au \0 ou après n caractères, mais dans ce dernier cas, le caractère \0 n'est pas recopié dans le tableau dest.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strncmp.3.html" target="_blank">int strncmp (const char *dest, const char *src, size_t n)</a> :</dt>
                        <dd>fonction qui compare deux chaînes de caractères; la valeur renvoyée sera nulle si les chaînes sont égales, inférieures à 0 si la première est plus petite suivant l'ordre alphabétique, plus grand que 0 si la première est supérieure.</dd>
                    </dl>
                    <h4 id="fonctions_recherches">Les fonctions de recherches :</h4>
                    <dl>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strchr.3.html" target="_blank">char* strchr (const *chaine, int car)</a> :</dt>
                        <dd>fonction qui cherche le caractère car dans la chaîne chaine; la fonction retourne l'adresse de la première occurrence du caractère ou NULL si le caractère n'est pas trouvé.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strrchr.3.html" target="_blank">char* strrchr (const char *chaine, int car)</a> :</dt>
                        <dd>fonction qui cherche le caractère car dans la chaîne chaine; la fonction retourne l'adresse de la dernière occurrence du caractère ou NULL si le caractère n'est pas trouvé.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strstr.3.html" target="_blank">char* strstr (const char *chaine, const char *sub)</a> :</dt>
                        <dd>fonction qui cherche la sous-chaîne sub dans la chaîne chaine; la fonction retourne l'adresse de la première occurrence de la sous-chaîne ou NULL si la sous-chaîne n'est pas trouvée.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strspn.3.html" target="_blank">size_t strspn (const char *chaine, const char *ensemble)</a> :</dt>
                        <dd>fonction qui cherche le premier caractère de la chaîne chaine qui n'appartient pas à l'ensemble; la fonction retourne l'indice de ce caractère ou la longueur de la chaîne si tous les caractères sont présents.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strcspn.3.html" target="_blank">size_t strcspn (const char *chaine, const char *ensemble)</a> :</dt>
                        <dd>fonction qui cherche le premier caractère de la chaîne chaine qui appartient à l'ensemble; la fonction retourne l'indice de ce caractère ou la longueur de la chaîne si aucun caractère n'est présent.</dd>
                        <dt><a href="http://man7.org/linux/man-pages/man3/strpbrk.3.html" target="_blank">char* strpbrk (const char *chaine, const char *ensemble)</a> :</dt>
                        <dd>fonction qui réalise le même traitement que strcspn mais renvoie un pointeur sur le premier caractère de la chaîne chaine qui appartient à l'ensemble, ou un pointeur nul si aucun caractère n'est présent.</dd>
                    </dl>
                    <h4 id="fonction_strtok">La fonction strtok :</h4>
                    <p>Cette fonction permet de découper une chaîne de caractères en <span class="em">tokens</span> (mais son utilisation est très différente du <span class="em">tokenizer</span> de Java). Sa déclaration <a href="http://man7.org/linux/man-pages/man3/strtok.3.html" target="_blank">char* strtok (char *str, const char *delim</a>) nous apprend que la fonction reçoit 2 arguments, le premier est la chaîne à analyser :</p>
                    <img src="../images/strtok1.png" alt="">
                    <p>et le second est une chaîne de caractères reprenant la liste des séparateurs pris en compte pour déterminer le token. La fonction renvoie l'adresse du token trouvé.</p>
<pre class="taille60"><code>char src[] = "IPL	02/764 46 46";
char *nom;

if ((nom = strtok(src, "\t \r")) == NULL) {
    fprintf(stderr, "???\n");
    return 1;
}</code></pre>
                    <p>Attention, la fonction va modifier la chaîne source en remplaçant le délimiteur par le caractère \0, qui déterminera la fin du token.</p>
                    <img src="../images/strtok2.png" alt="strtok2">
                    <p>Pour obtenir le token suivant, il faut ré-appeler la fonction, mais cette fois le premier argument n'est plus l'adresse d'une chaîne mais le pointeur nul NULL pour spécifier à la fonction que l'on continue de travailler sur la chaîne traitée lors de l'appel précédent. La liste des délimiteurs peut être modifiée lors de chaque appel de la fonction.</p>
<pre class="taille60"><code>char *prefixe;

if ((prefixe = strtok(NULL, "/")) == NULL) {
    fprintf(stderr, "???\n");
    return 1;
}</code></pre>
                    <img src="../images/strtok3.png" alt="strtok3">
                    <p>Si la fonction ne trouve pas le séparateur, elle considère la fin de la chaîne source comme le token à renvoyer.</p>
<pre class="taille60"><code>char *numero;

if ((numero = strtok(NULL, ":")) == NULL) {
    fprintf(stderr, "???\n");
    return 1;
}</code></pre>
                    <img src="../images/strtok4.png" alt="strtok4">
                    <p>Lorsque la chaîne est vide, la fonction renvoie un pointeur nul.</p>
<pre class="taille60"><code>char *adresse;
        
if ((adresse = strtok(NULL, ":;")) == NULL) {
    fprintf(stderr, "C'est fini...\n");
    return 1;
}</code></pre>
                    <img src="../images/strtok5.png" alt="strtok5">
                    <h4 id="fonctions_conversions_numeriques">Les fonctions de conversions numériques :</h4>
                    <p>La conversion d'une chaîne de caractères en la valeur numérique qu'elle représente peut se faire en utilisant des fonctions de conversion simple - double atof (const char *str), int atoi (const char *str), long atol (const char *str) - qui ne donnent aucune information sur le résultat, ou grâce à des fonctions qui fourniront des informations exploitables pour s'assurer que la conversion est correcte - double strtol (const char *str, char **pptr), long strtol (const char *str, char **pptr, int base), unsigned long strtoul (const char *str, char **pptr, int base). Ces fonctions nécessitent l'inclusion du fichier <span class="em">stdlib.h</span>.</p>
                    <p>Voici les fonctions de conversions simples :</p>
                    
                </article>
            <!-- fin de section -->
            </section>
            <footer role="contentinfo">
                <div>
                    <address>
                        Professeurs :
                        <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                        <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                    </address>
                </div>
                <div>
                    <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
                </div>
                <div id="version">
                    <p>Syllabus HTML</p>
                    <p>Version 5.0</p>
                </div>
            </footer>
        </main>
    </body>
</html>