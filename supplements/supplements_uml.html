<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>UML - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction à modélisation orientée Objet</a></li>
                        <li><a href="#uml">UML</a></li>
                        <li><a href="#use_cases">Les cas d'utilisation (Use Cases)</a></li>
                        <li><a href="#diagramme_classes">Le diagramme de classes</a></li>
                        <li><a href="#diagramme_objets">Le diagramme d'objets</a></li>
                        <li><a href="#diagramme_packages">Le diagramme de packages</a></li>
                        <li><a href="#diagramme_activites">Le diagramme d'activités</a></li>
                        <li><a href="#diagramme_interactions">Le diagramme d'interactions</a></li>
                        <li><a href="#diagramme_etats">Le diagramme d'états</a></li>
                        <li><a href="#uml_java">UML en Java</a></li>
                        <li><a href="#mise_en_oeuvre_uml">Mise en oeuvre d'UML</a></li>
                        <li><a href="#bibliographie">Bibliographie</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Analyse et modélisation : UML :</h1>
                </article>
                <article>
                    <h2 id="introduction">Chapitre 1 : Introduction à la modélisation orientée Objet :</h2>
                    <h3>1. Le génie logiciel :</h3>
                    <h4>1.1. Les TIC (Technologies de l'Information et de la Communication) :</h4>
                    <p>L'un des phénomènes les plus marquants de ces 50 dernières années est certainement l'informatisation. Les voitures possèdent des ordinateurs de bord, la domotique envahit nos maisons, nous partageons nos expériences sur les réseaux sociaux, nous échangeons des mails, nous achetons en ligne nos vêtements, nos vacances, nos places de concert, ...</p>
                    <p>La grande majorité des entreprises possèdent des systèmes informatiques pour gérer leurs stocks, gérer la comptabilité, ...</p>
                    <p>Bref, que ce soit à la maison ou au travail ou encore à l'école, l'informatique est omniprésente à notre époque. Les technologies de l'information et de la communication sont devenues partie intégrante de notre vie. Nous sommes tous et toutes devenus des utilisateurs directs et indirects des TIC. Nous avons tous le "tic des TIC".</p>
                    <p>Les systèmes informatiques se composent de matériels et de logiciels. Actuellement, le côté matériel est relativement fiable et le marché est standardisé. Les logiciels constituent la source des problèmes de l'informatique.</p>
                    <h4>1.2. Les logiciels :</h4>
                    <p>Un <span class="em">logiciel</span> ou une application est un ensemble de programmes, qui permet à un ordinateur ou à un système informatique d'assurer une tâche ou une fonction en particulier (exemple : logiciel de comptabilité, logicile de gestion des prêts).</p>
                    <p>Les logiciels, suivant leur taille, peuvent être développés par une personne seule, une petite équipe, ou un ensemble d'équipes coordonnées. Le développement de grands logicils par de grandes équipes pose d'importants problèmes de conception et de coordination. Or, le développement d'un logiciel est une phase absolument cruciale qui monopolise l'essentiel du coût et conditionne sa réussite et sa pérennité.</p>
                    <p>En 1995, une étude du <span class="em">Standish Group</span> dressait un tableau accablant de la conduite des projets informatiques. Reposant sur un échantillon représentatif de 365 entreprises, totalisant 8380 applications, cette étude établissait que :</p>
                    <ul>
                        <li>
                            <p>16,2% seulement des projets étaient conformes aux prévisions initiales,</p>
                        </li>
                        <li>
                            <p>52,7% avaient subi des dépassements en coût et délai d'un facteur 2 à 3 avec diminution du nombre des fonctions offertes,</p>
                        </li>
                        <li>
                            <p>31,1% ont été purement abandonnés durant leur développement.</p>
                        </li>
                    </ul>
                    <p>Pour les grandes entreprises (qui lancent proportionnellement davantage de gros projets), le taux de succès est de 9% seulement, 37% des projers sont arrêtés en cours de réalisation, 50% aboutissent hors délai et hors budget.</p>
                    <p>L'examen des causes de succès et d'échec est instructif : la plupart des &checs proviennent non de l'informatique, mais de la maîtrise d'ouvrage, en comprenant sous ce terme à la fois les dirigeants et les concepteurs des métiers.</p>
                    <p>Pour ces raisons, le développement de logiciels dans un contexte professionnel suit souvent des règles encadrant la conception et permettant le travail en groupe et la maintenance du code. Ainsi, une nouvelle discipline est née : le génie logiciel.</p>
                    <h4>1.3. Le génie logiciel :</h4>
                    <p>Le <span class="em">génie logiciel</span> est un domaine de recherche qui a été défini du 7 au 11 octobre 1968, à Garmisch-Partenkirchen, sous le parrainage de l'OTAN. Il a pour objectif de répondre à un problème qui s'énonçait en deux constations : d'une part, le logiciel n'était pas fiable, d'autre part, il était incroyablement difficile de réaliser dans des délais prévus des logiciels satisfaisant leur cahier des charges.</p>
                    <blockquote cite="http://fr.wikipedia.org">L'appellation génie logiciel concerne l'ingénierie appliquée au logiciel informatique. Cette branche de l'informatique s'intéresse plus particulièrement à la manière dont le code source d'un logiciel est spécifié puis produit. Le génie logiciel touche au cycle de vie des logiciels. Toutes les phases de la création d'un logiciel informatique y sont enseignées : l'analyse du besoin, l'élaboration des spécifications, la conceptualisation du mécanisme interne au logiciel ainsi que les techniques de programmation, le développement, la phase de test et finalement la maintenance.</blockquote>
                    <p>L'objectif premier du génie logiciel était d'optimiser le coût de développement du logiciel. La crise de l'industrie du logiciel, à la fin des années 70, a montré l'importance d'élaborer une approche méthodologique.</p>
                    <p>Cette crise est caractérisée par ces quelques constats :</p>
                    <ul>
                        <li>
                            <p>l'augmentation des coûts;</p>
                        </li>
                        <li>
                            <p>les difficultés de maintenance et d'évolution;</p>
                        </li>
                        <li>
                            <p>la non-fiabilité;</p>
                        </li>
                        <li>
                            <p>le non-respect des spécifications;</p>
                        </li>
                        <li>
                            <p>le non-respect des délais.</p>
                        </li>
                    </ul>
                    <p>Voici quelques exemples qui montrent l'ampleur de l'impact des défaillances dues au manque de méthodologie de développement :</p>
                    <ul>
                        <li>
                            <p>La sonde Mariner vers Vénus s'est perdue dans l'espace à cause d'une erreur de programme FORTAN;</p>
                        </li>
                        <li>
                            <p>En 1981, le premier lancement de la navette spatiale a été retardé de deux jours à cause d'un problème logiciel. La navette a d'ailleurs été lancée sans que l'on ait localisé exactement le problème (mais les symptômes étaient bien délimités)</p>
                        </li>
                        <li>
                            <p>L'explosion d'Ariane 5, le 4 juin 1996, qui a coûté un demi-milliard de dollars, est due à une faute logicielle d'une composante dont le fonctionnement n'était pas indispensable durant le vol.</p>
                        </li>
                    </ul>
                    <h4>1.4. La qualité d'un logiciel :</h4>
                    <p>Ces expériences malheureuses ont conduit de nombreux chercheurs à travailler sur la définition de la <span class="em">qualité</span> du logiciel en termes de facteurs, ceux-ci dépendent, entre autres, du domaine de l'application et des outils utilisés.</p>
                    <p>Citons les facteurs de la norme ISO 9126 :</p>
                    <ul>
                        <li>
                            <p><span class="em">Capacité fonctionnelle (validité) </span> : aptitude d'un produit logiciel à remplir exactement ses fonctions, définies par le cahier des charges et les spécifications.</p>
                        </li>
                        <li>
                            <p><span class="em">Fiabilité</span> (ou robustesse) : aptitude d'un produit logiciel à fonctionner dans des conditions anormales.</p>
                        </li>
                        <li>
                            <p><span class="em">Facilité d'utilisation</span> : facilité d'apprentissage, d'utilisation, de préparation des données, d'interprétation des erreurs et de rattrapage en cas d'erreur d'utilisation.</p>
                        </li>
                        <li>
                            <p><span class="em">Efficacité</span> : utilisations optimales des ressources matériellles.</p>
                        </li>
                        <li>
                            <p><span class="em">Maintenabilité (extensibilité)</span> : facilité avec laquelle un logiciel se prête à sa maintenance, c'est-à-dire à une modification ou à une extension des fonctions qui lui sont demandées.</p>
                        </li>
                        <li>
                            <p><span class="em">Portabilité</span> : facilité avec laquelle un logiciel peut être transféré sous différents environnements matériels et logiciels.</p>
                        </li>
                    </ul>
                    <p>Ces facteurs sont parfois contradictoires, le choix des compromis doit s'effectuer en fonction du contexte. Il existe encore de nombreux autres facteurs de qualité mais il est peu utile de tous les énumérer.</p>
                    <h3>2. La modélisation orientée Objet :</h3>
                    <h4>2.1. La modélisation :</h4>
                    <p>Souvent les formations abordent d'abord la programmation ensuite la modélisation. La programmation est l'outil qui permet de réaliser ce qui a été conçu; la modélisation fait partie du processus de conception.</p>
                    <p>Concrètement, un <span class="em">modèle</span> est une représentation abstraite et simplifiée, c'est-à-dire qui exclut certains détails, d'une entité (phénomène, processus, système, etc.) du monde réel en vue de le décrire, de l'expliquer ou de le prévoir. "Modèle" est synonyme de théorie, mais avec une connotation pratique : un modèle, c'est une théorie orientée vers l'action qu'elle doit servir.</p>
                    <p>Concrètement, un modèle permet de réduire la complexité d'un phénomène en éliminant les détailss qui n'influencent pas son comportement de manière significative. Il reflète ce que le concepteur croit important pour la compréhension et la prédiction du phénomène modélisé. Les limites du phénomène modélisé dépendent des objectifs du modèle.</p>
                    <h5>Pourquoi modéliser ?</h5>
                    <p>Modéliser un système avant sa réalisation permet de mieux comprendre le fonctionnement du système. C'est également un bon moyen de maîtriser sa complexité et d'assurer sa cohérence. Un modèle est un langages commun, précis, qui est connu par tous les membres de l'équipe (les hommes du métier et les informaticiens). Il constitue donc, à ce titre, un vecteur privilégié pour communiquer. Cette communication est essentielle pour aboutir à une compréhension commune des différentes parties prenantes (notamment entre la maîtrise d'ouvrage et maîtrise d'oeuvre informatique) et précise d'un problème donné.</p>
                    <p>Effectivement, imaginez quelques instants : on requiert vos services pour la mise en place d'un nouveau système informatique. Dira-t-on "Bonjour, j'aurai besoin d'une classe <span class="em">CompteEnBanque</span> abstraite qui sera spécialisée par deux classes <span class="em">CompteEpargne</span> et <span class="em">CompteCourant</span>..." ou "Bonjour, je désire un programme pour gérer mes comptes." ? La réponse est évidente : ce n'est pas en termes informatiques que s'expriment les demandes informatiques mais en bien en langage courant.</p>
                    <p>En d'autres termes, le client/l'employé énonce son problème tel qu'il le perçoit et non en termes informatiques. C'est le job de l'informaticien de comprendre, d'interpréter, d'<span class="em">analyser</span> les besoins et de concevoir une application y répondant au mieux. Le dessin suivant illustre ces propos.</p>
                    <p>Soulignons aussi que pour comprendre un problème dans sa globalité, l'informaticien doit tenir compte aussi de la provenance des informations dont il doispose. Par exemple, si on désire créer un système de gestion comptable, les besoins seront exprimés différemment selon la personne source : le directeur, l'employé, les secrétaires, ...</p>
                    <p>Un problème, tel qu'énoncé par quelqu'un est donc exprimé en langage courant. Que ce soit du français , de l'anglais ou du japonais, il repose sur une langue parlée, dont la structure grammaticale de la langue française et l'orthographe sont terriblement complexes. De plus, pour énoncer un problème en langage courant, on dispose de nombreuses possibilités d'expressions. Il existe de nombreux synonymes et manières différentes d'exprimer la même chose.</p>
                    <p>Lorsqu'on désire concevoir un programme, en Java par exemple, il s'agit en fait de traduire un énoncé exprimé dans un langage possédant une syntaxe et une sémantique extrêmement riches dans un langage très pauvre.</p>
                    <p>Effectivement, un <span class="em">langage informatique</span> est codifié et possède une sémantique unique :</p>
                    <ul>
                        <li>
                            <p>Le langage est <span class="em">codifié</span> car la syntaxe du Java (ou Python, C, ...) est assez pauvre : le nombre de mot appartenant au langage est limité.</p>
                        </li>
                        <li>
                            <p>De plus, en général, une <span class="em">sémantique unique</span>. Par exemple, <span class="html">if (a + b &gt; 10)</span> a un sens unique : si la somme de a et b est strictement supérieure à 10.</p>
                        </li>
                    </ul>
                    <p>Outre les aspects purement syntaxiques, un <span class="em">langage réel</span> est évolutif et ambigu.</p>
                    <ul>
                        <li>
                            <p><span class="em">Évolutif</span> car des nouveaux mots apparaissent (et disparaissent) : par exemple, mp3. Certains mots changent d'orthographe : oignon peut maintenant s'écrire onion.</p>
                        </li>
                        <li>
                            <p>Un langage réel est <span class="em">ambigu</span> car certains mots changent de signification selon le contexte dans lesquels ils sont utilisés : la souris de l'ordinateur et la souris mangée par le chat. Sans compter le sens unique vu un peu plus haut et le sens unique d'une rue.</p>
                        </li>
                    </ul>
                    <p>Ce problème d'interprétation de ce qui est exprimé en langage réel vers un langage informatique, relève de ce que l'on appelle la <span class="em">modélisation</span>.</p>
                    <figure>
                        <img src="../images/modelisation.PNG" alt="">
                        <figcaption>Figure 1 : modélisation</figcaption>
                    </figure>
                    <p>En résumé, la modélisation consiste en une représentation abstraite d'un problème. Le mot modélisation renferme le mot <span class="em">modèle</span>.</p>
                    <ul>
                        <li>
                            <p><span class="em">Représentation</span> car il s'agit de représenter dans un langage (en l'occurence un code informatique) un problème énoncé dans un autre langage (parlé).</p>
                        </li>
                        <li>
                            <p><span class="em">Abstraite</span> car ce ne sont pas les données individuellles observées d'un problème qui sont importantes mais la structure, les relations, les formats des données, ...</p>
                        </li>
                    </ul>
                    <p>Par exemple, si dans un problème quelconque on parle de quelques personnes en disant que l'une a les yeux bleus et les cheveux noirs et l'autre les yeux verts et les cheveux roux, on retient qu'une personne est décrite par la couleur de ses yeux et de ses cheveux. En d'autres termes, la représentation abstraite, le <span class="em">modèle</span>, d'une personne tient en la description de la couleur de ses cheveux et de ses yeux.</p>
                    <h4>L'oienté Objet :</h4>
                    <p>L'<span class="em">orienté Objet</span> est une approche de la conception de programmes qui tend à structurer les différentes parties d'un programme en objets ayant des responsabilités bien définies et interagissant entre eux pour les honorer.</p>
                    <p>Il est important de mettre en évidence la <span class="em">délégation des responsabilités</span> entre objets. Lorsqu'on appelle une méthode d'un objet, cet objet a la responsabilité du "bon déroulement" de l'opération jusqu'à terminaison de l'opération. Évidemment, il se peut que l'appel de méthode débouche sur un autre appel de méthode d'un autre objet et ainsi de suite. Les objets se partahent donc les responsabilités du programme : chacun remplissant (implémentant) son contrat (notamment son interface).</p>
                    <p>L'oienté Objet peut se résumer en 5 grands concepts :</p>
                    <ul>
                        <li>
                            <p><span class="em">Abstraction</span> (adaptation du programme à la logique intrinsèque du problème en créant les nouveaux types d'objets nécessaires)</p>
                        </li>
                        <li>
                            <p><span class="em">Modularisation</span> (séparation des entités : décomposition en classes et packages)</p>
                        </li>
                        <li>
                            <p><span class="em">Encapsulation</span> (regroupement et protection des données)</p>
                        </li>
                        <li>
                            <p><span class="em">Réutilisation</span> (agrégation/composition)</p>
                        </li>
                        <li>
                            <p><span class="em">Polymorphisme</span> (des objets, héritage)</p>
                        </li>
                    </ul>
                    <h4>La modélisation orientée Objet :</h4>
                    <p>Dans le monde orienté Objet, la modélisation informatique d'un objet du monde réel est une caractérisation de ce dernier à l'aide de 3 (ensembles d') information(s) :</p>
                    <ul>
                        <li>
                            <p>Le <span class="html">nom</span> de l'objet;</p>
                        </li>
                        <li>
                            <p>Un <span class="html">ensemble d'attributs</span> de cet objet qui compose l'<span class="html">état</span>de l'objet;</p>
                        </li>
                        <li>
                            <p>Un <span class="html">ensemble d'actions/méthodes</span> qui modifient les attributs précités qui définissent le <span class="html">comportement</span> de l'objet.</p>
                        </li>
                    </ul>
                    <p>En somme, un objet <span class="em">=</span> identité <span class="em">+</span> état <span class="em">+</span> comportement.</p>
                    <p>Le processus de modélisation orienté objet est basé sur ce principe simple : il consiste à exprimer tous les éléments du domaine d'application à l'aide du type de définition - également appelée spécification - évoqué plus haut, soit à en donner le nom, les attributs (que l'on appelle également l'état de l'objet) et les actions possibles.</p>
                    <p>Mais, pour modéliser un problème, il est impératif d'en définir auparavant le <span class="em">domaine d'application</span>.</p>
                    <p>Le domaine d'application permet de restreindre le monde réel à la partie couverte par le logiciel à développer (en supposant que l'on souhaite réaliser une modélisation à cette fin, et non par pur plaisir intellectuel). Il s'agit de délimiter ce qui appartient au système à développer et ce qui en est exclu.</p>
                    <p>Prenons un exemple :</p>
                    <div>
                        <img src="../images/nain_de_jardin.png" alt="" class="float_left">
                        <p>Pour modéliser le nain de jardin ci-contre, si on s'en tient à la définition, il faut exprimer les éléments du domaine d'application à l'aide du nom, des attributs et des actions du nain à modéliser.</p>
                        <p>Si nous considérons le nain contre, nous pourrions apprendre que son nom est Portkoi, qu'il est vêtu d'un manteau bleu, d'une ceinture brune et porte un pantalon marron, qu'il a dans sa main droite un marteau et qu'il se trouve debout. Les actions susceptibles de modifier son état sont entre autres "marcher", "s'asseoir", "changer de couleur", etc.</p>
                        <p>On remarque qu'une première difficulté survient : le monde réel est infiniment complexe, et même lorsque celui-ci se limite à un seul objet, le nain Portkoi. Nous pourrions lui trouver un nombre incalculable d'attributs (chapeau, barbe, poids, hauteur, ...) et d'actions.</p>
                    </div>
                    <p>C'est ici que la notion de <span class="em">domaine d'application</span> prend tout son sens. Rappelons que le domaine d'application permet de restreindre le monde réel à la partie couverte par le logiciel à développer.</p>
                    <p>Dans quel cadre sommes-nous donc en train de modéliser ce nain de jardin ?</p>
                    <p>Supposons que notre programme relève de la demande d'un collectionneur de nains de jardin.La modélisation du nain Portkoi pourrait se résumer à son surnom, un détail des couleurs de ses habits, des coordonnées de son emplacemnt dans son jardin ainsi qu'une description de l'objet en main pour ce qui est des attributs. Les actions seront en rapport avec cette restriction du monde réel : changer d'emplacement, se casser, repeindre, pivoter, ...</p>
                    <p>Par contre si le FLNJ (Front de Libération des Nains de Jardin) désire un logiciel concernant ses grandes évasions, le nain de jardin se caractériserait avant tout par sa date de libération, ses anciens tortionnaires ainsi que son nouveau lieu de vie.</p>
                    <p>Même si ces deux modélisations concernent le même objet du monde réel (Portkoi), dans des domaines d'application différents (le collectionneur et le FLNJ), on constate des divergences sur les modèles élaborés.</p>
                </article>
                <article>
                    <h2 id="uml">Chapitre 2 : UML :</h2>
                    <h3>1. Le contexte et la définition :</h3>
                    <figure>
                        <img src="../images/contexte_definition_uml.png" alt="">
                        <figcaption>Figure 2 : évolution d'UML (<a href="https://en.wikipedia.org/wiki/Object-modeling_language" target="_blank">https://en.wikipedia.org/wiki/Object-modeling_language</a>)</figcaption>
                    </figure>
                    <p>Les méthodes utilisées dans les années 1980 pour organiser la programmation impérative (notamment Merise) étaient fondées sur la modélisation séparée des données et des traitements. Lorsque la programmation orientée Objet prend de l'importance au début des années 1990, la nécessité d'une méthode qui lui soit adaptée devient évidente. Plus de cinquante méthodes apparaissent entre 1990 et 1995 (Booch, Classe-Relation, Fusion, HOOD, OMT, OOA, OOD, OOM, OOSE, etc.) mais aucune ne parvient à s'imposer.</p>
                    <p>En 1994, le consensus se fait autour de trois méthodes :</p>
                    <ul>
                        <li>
                            <p>OMT de James Rumbaugh (<span class="em">General Electric</span>) fournit une représentation graphique des aspects statique, dynamique et fonctionnel d'un système</p>
                        </li>
                        <li>
                            <p>OOD de Grady Booch, définie pour le <span class="em">Department of Defense</span>, introduit le concept de paquetage (<span class="em">package</span></p>
                        </li>
                        <li>
                            <p>OOSE d'Ivar Jacobson (Ericsson) fonde l'analyse sur la description des besoins des utilisateurs (cas d'utilisation, ou <span class="em">use cases</span>).</p>
                        </li>
                    </ul>
                    <p>Chaque méthode avait ses avantages et ses partisans.  Le nombre de méthodes en compétition s'était réduit, mais le risque d'un éclatement subsistait : la profession pouvait se diviser entre ces trois méthodes, créant autant de continents intellectuels qui auraient du mal à communiquer.</p>
                    <p>Évènement considérable et presque miracleux, les trois gourous qui régaient chacun sur l'une des trois méthodes se mirent d'accird pour définir une notation communee qui fédérerait leurs apports respectifs (on les surnomme depuis "the Amigos"). <span class="html">UML</span> (<span class="em">Unified Modeling Language</span>) est né de cet effort de convergence. L'adjectif <span class="em">unified</span> est là pour marquer qu'UML unifie, et donc remplace.</p>
                    <p>L'<span class="html">UML</span> (Unified Modeling Language), dont la norme complète se trouve sur le site <a href="https://www.uml.org/" target="_blank">https://www.uml.org/</a>, est un <span class="em">langage</span> conçu pour l'écriture de plans d'élaboration de logiciels (il ne s'agit pas d'une méthode). UML est un langage de modélisation, indépendant du processus et servant à décrire des modèles d'un système basé sur des concepts orientés Objet. Effectivement, UML véhicule en particulier les concepts des approches par objets (classe, instance, classification, etc.) mais intègre également d'autres aspects (associations, fonctionnalités, évènements, états, séquences, etc.).</p>
                    <p>L'unification a progressé par étapes. En 1995, Booch et Rumbaugh (et quelques autres) se sont mis d'accord pour construire une méthode unifiée, <span class="em">Unified Method 0.8</span>; en 1996, Jacobson les a rejoints pour produire UML 0.9 (notez le remplacement du mot <span class="em">méthode</span> par le mot <span class="em">langage</span>, plus modeste). Les acteurs les plus importants dans le monde du logiciel s'associent alors à l'éffort (IBM, Microsoft, Oracle, DEC, HP, Rational, Unisys etc.) et UML 1.0 est soumis à l'OMG. L'OMG adopte en novembre 1997 UML 1.1 comme langage de modélisation des systèmes d'information à objets. La version d'UML en cours en UML 2.1.2 et les travaux d'amélioration se poursuivent. Vous pouvez trouver sur le site de l'OMG (<a href="https://www.uml.org/" target="_blank">https://www.uml.org/</a>) les spécifications complètes des normes, bonne lecture !</p>
                    <p>UML est donc non seulement un outil intéressant mais une norme qui s'impose en technologie à objets et à objets et à laquelle se sont rangés tous les grands acteurs du domaine, acteurs qui ont d'ailleurs contribué à son élaboration.</p>
                    <p>En bref, l'UML est une <span class="em">boîte à outils de notations normalisées</span>, surtout graphiques, qui bénéficie des qualités des approches par objets.</p>
                    <h3>2. Les diagrammes vrac :</h3>
                    <p>UML 2 comporte des types de diagrammes représentant autant de manières distinctes de représenter des concepts particuliers du système d'information. Nous ne les abordons pas tous. Voici un résumé de ceux abordés répartis en deux groupes :</p>
                    <ul>
                        <li>
                            <p>Diagrammes structurels ou diagrammes statiques (<span class="em">UML Structure</span>)</p>
                            <ul>
                                <li>
                                    <p>diagramme de classes (<span class="em">Class diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagramme d'objets (<span class="em">Object diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagramme de composants (<span class="em">Component diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagramme de déploiement (<span class="em">Deployment diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagramme de paquetages (<span class="em">Package diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagralle de structures composites (<span class="em">Composite structure diagram</span>)</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Diagrammes comportementaux ou diagrammes dynamiques (<span class="em">UML Behavior</span>)</p>
                            <ul>
                                <li>
                                    <p>diagramme de cas d'utilisation (<span class="em">Use case diagram</span></p>
                                </li>
                                <li>
                                    <p>diagramme d'activités (<span class="em">Activity diagram</span>)</p>
                                </li>
                                <li>
                                    <p>diagramme d'états-transitions (<span class="em">State machine diagram</span>)</p>
                                </li>
                                <li>
                                    <p>Diagrammes d'interactions (<span class="em">Interaction diagram</span>)</p>
                                    <ul>
                                        <li>
                                            <p>diagramme de séquence (<span class="em">Sequence diagram</span>)</p>
                                        </li>
                                        <li>
                                            <p>diagramme de communication (<span class="em">Communication diagram</span>)</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Ces diagrammes, d'une utilité variable selon les cas, ne sont pas nécessairement tous produits à l'occassion d'une modélisation. Les plus utiles pour la maîtrise d'ouvrage sont les diagrammes d'<span class="html">activités</span>, de <span class="html">cas d'utilisation</span>, de <span class="html">classes</span>, d'<span class="html">objets</span>, de <span class="html">séquence</span> et d'<span class="html">états-transitions</span>. Les diagrammes de composants, de déploiement et de communication sont surtout utiles pour la maîtrise d'oeuvre à qui ils permettent de formaliser les contraintes de la réalisation et la solution technique.</p>
                    <h4>Diagramme de cas d'utilisation :</h4>
                    <p>Le diagramme de cas d'utilisation représente la structure des grandes fonctionnalités nécessaires aux utilisateurs du système. C'est le premier diagramme du modèle UML, celui où s'assure la relation entre l'utilisateur et les objets que le système met en oeuvre.</p>
                    <h4>Diagramme de classes :</h4>
                    <p>Le diagramme de classes est généralement considéré comme le plus important dans un développement orienté Objet. Il représente l'architechture conceptuelle du système : il décrit les classes que le système utilise, ainsi que leurs relations.</p>
                    <h4>Diagramme d'objets :</h4>
                    <p>Le diagramme d'objets permet d'éclairer un diagramme de classes en l'illustrant par des exemples. Il est, par exemple, utilisé pour vérifier l'adéquation d'un diagramme de classes à différents cas possibles.</p>
                    <h4>Diagramme d'états-transitions :</h4>
                    <p>Le diagramme d'états-transitions représente la façon dont évoluent (<span class="em">i.e.</span> cycle de vie) les objets appartenant à une même classe. La modélisation du cycle de vie est essentielle pour représenter et mettre en forme la dynamique du système.</p>
                    <h4>Diagramme d'activités :</h4>
                    <p>Le diagramme d'activités n'est autre que la transcription dans UML de la représentation du processus telle qu'elle a été élaborée lors du travail qui a préparé la modélisation : il montre l'enchaînement des activités qui concourent au processus.</p>
                    <h4>Diagramme de séquence et de communication :</h4>
                    <p>Le diagramme de séquence représente la succession chronologique des opérations réalisées par un acteur. Il indique les objets que l'acteur va manipuler et les opérations qui font passer d'un objet à l'autre. On peut représenter les mêmes opérations par un diagramme de communication, graphe dont les noeuds sont des objets et les arcs (numérotés selon la chronologie) les échanges entre objets. En fait, diagramme de séquence et diagramme de communication sont deux vues différentes mais logiquement équivalentes (on peut construire l'une à partir de l'autre) d'une même chronologie. Ce sont des diagrammes d'interactions.</p>
                    <h3>3. Les avantages et inconvénients :</h3>
                    <p>Les avantages reconnus de l'UML sont :</p>
                    <ul>
                        <li>
                            <p>UML est un <span class="em">standard</span> reconnu et largement accepté.</p>
                        </li>
                        <li>
                            <p>UML est <span class="em">polyvalent</span>; il permet de représenter beaucoup de choses à différents niveaux d'abstraction.</p>
                        </li>
                        <li>
                            <p>UML est un outil de <span class="em">communication</span> et de <span class="em">documentation</span>.</p>
                        </li>
                    </ul>
                    <p>Certains reprochent à l'UML quelques aspects comme sa lourdeur de mise en place dans certains processus ainsi que son apprentissage parfois long et rigoureux.</p>
                </article>
                <article>
                    <h2 id="use_cases">Chapitre 3 : Les cas d'utilisation (Use Cases) :</h2>
                    <h3>1. Introduction :</h3>
                    <p>[Jacobson 1992]</p>
                    <p>Bien souvent, la maîtrise d'ouvrage et les utilisateurs ne sont pas des informaticiens. Il leur faut donc un moyen simple d'exprimer leurs besoins. C'est précisément le rôle des diagrammes des cas d'utilisation qui permettent de recueillir, d'analyser et d'organiser les besoins, et de recenser les grandes fonctionnalités d'un système. Il s'agit donc de la première étape UML d'analyse d'un système.</p>
                    <p>Un diagramme de cas d'utilisation capture le comportement d'un système, d'un sous-système, d'une classe ou d'un composant tel qu'un utilisateur extérieur le voit. Il scinde la fonctionnalité du système en unités cohérentes, les cas d'utilisation, ayant un sens pour les acteurs.</p>
                    <p>Les diagrammes de cas d'utilisation permettent donc de définir les <span class="em">besoins fonctionnels</span> d'un système. Ils fournissent une vue, indépendante de l'implémentation, des fonctionnalités offertes par un système; ils permettent aux concepetrus de se concentrer sur les besoins de l'utilisateur final, indépendamment des détails de réalisation. Les cas d'utilisation permettent d'exprimer le besoin des utilisateurs d'un système, il sont une vision <span class="em">orientée utilisateur</span> de ce besoin au contraire d'un vision informatique.</p>
                    <p>Il ne faut pas négliger cette première étape pour produire un logiciel conforme aux attentes des utilisateurs. Pour élaborer les cas d'utilisation, il faut se fonder sur des entretiens avec les utilisateurs.</p>
                    <p>Les cas d'utilisation constituent un des outils les plus employés d'UML.</p>
                    <p>Dans ce chapitre, nous mettrons en évidence les concepts abordés en se référant à un exemple simple : le système informatique d'un magasin alimentaire, SysMag. Ce système doit gérer beaucoup de choses dans la réalité : les stocks, les employés, les ventes, ...</p>
                    <p>Ce système a été volontairement simplifié pour se limiter aux fonctionnalités suivante :</p>
                    <ul>
                        <li>
                            <p>le traitement des ventes aux clients</p>
                        </li>
                        <li>
                            <p>la gestion du retour des vidages</p>
                        </li>
                        <li>
                            <p>l'initialisation des caisses</p>
                        </li>
                    </ul>
                    <h3>2. Les éléments des cas d'utilisation :</h3>
                    <h4>2.1. Les cas d'utilisation :</h4>
                    <p>Les cas d'utilisation représentent des éléments fonctionnels bien identifiés dans un système, dans un composant ou même dans une classe. Chaque cas d'utilisation décrit en quelques mots la fonctionnalité correspondante. Il commence toujours par un <span class="em">verbe à l'infinitif</span>.</p>
                    <p>Un cas d'utilisation est une description d'un <span class="em">ensemble de séquences d'actions</span>, incluant des <span class="em">variantes</span>, faisant intervenir le <span class="em">système</span> (ou un sous-système) et un ou plusieurs <span class="em">acteurs</span> en vue de fournir un <span class="em">résultat observable</span> à l'un des acteurs.</p>
                    <p>L'ensemble de tous les cas d'utilisation définit tous les comportements d'un système assyrant aux acteurs que leurs objectids vont être réalisés. Tout comportement du système sans intérêt pour les acteurs ne doit pas être repris dans les cas d'utilisation.</p>
                    <p>Pour l'exemple SysMag :</p>
                    <img src="../images/use_cases.png" alt="">
                    <h4>2.2. Les acteurs :</h4>
                    <p>Un acteur est un <span class="em">rôle</span> joué par un utilisateur ou un autre système vis à vis du système. On évite de considérer une personne physique comme un acteur au profit de son rôle. Par exemple, on préfère un acteur "Président" plutôt que "Barack Obama". Les acteurs sont des types ou catégories d'utilisateurs. Ce sont des entités externes (personnes ou autres systèmes) qui interagissent avec le système en vue d'atteindre un objectif. Un acteur peut consulter et (ou) modifier l'état du système car il peut recevoir et (ou) émettre des messages.</p>
                    <p>Un acteur est donc une construction de l'esprit définie par l'analyste en vue de représenter un rôle joué par un utilisateur humain ou un autre système qui interagit directement avec le système étudié.</p>
                    <p>Représentations graphiques :</p>
                    <img src="../images/acteur.png" alt="">
                    <p>Les acteurs Client et Caissier sont représentés grâce à un "stick man".</p>
                    <p>Il existe différentes manières de représenter les acteurs comme montré ci-dessus. Généralement, nous employons un "stick man" pour représenter un <span class="em">acteur humain</span> et un rectangle avec le template <span class="html">&lt;&lt;actor&gt;&gt;</span> pour les <span class="em">systèmes connectés</span>.</p>
                    <p>Dans notre exemple SysMag, quels sont les acteurs du système :</p>
                    <ul>
                        <li>
                            <p>Le client ?</p>
                        </li>
                        <li>
                            <p>Le caissier ?</p>
                        </li>
                        <li>
                            <p>Le responsable du magasin ?</p>
                        </li>
                        <li>
                            <p>La carte de banque ?</p>
                        </li>
                        <li>
                            <p>Le système de lecture de carte ?</p>
                        </li>
                        <li>
                            <p>Le système de paiement ?</p>
                        </li>
                        <li>
                            <p>La caisse ?</p>
                        </li>
                        <li>
                            <p>L'écran qui affiche le total au client</p>
                        </li>
                    </ul>
                    <p>Pour répondre à ces questions, il faut définir les frontières du système.</p>
                    <h3>3. La définition du système :</h3>
                    <p>Effectivement, avant de progresser dans la définition des acteurs et de leurs rôles vis à vis du système, il est essentiel de poser les frontières du système. Il est temps de se poser les questions suivantes : qu'est-ce qui appartient au système à développer ? Qu'est-ce qui n'en fait pas partie ?</p>
                    <p>Les <span class="em">frontières</span> (limites) du système définissent la <span class="em">séparation entre le système et son environnement</span>. Il est important de clairement les définir : c'est une source fréquente de conflit entre décideurs. Un décideur est un individu ou un groupe qui a un intérêt dan sle système en développement (stakeholder).</p>
                    <p>Par définition, un cas d'utilisation décrit une fonctionnalité précise et bien identifiée. Tout ce qui n'est pas réalisé dans le contexte de cette fonctionnalité est considéré comme étant en-dehors des frontières du système, et doit être représenté sous la forme d'un acteur.</p>
                    <p>Lorsqu'on détermine les frontières d'un système, l'essentiel est de veiller à rester toujours <span class="em">cohérent</span> dans les choix posés. L'exerccice résolu ci après propose une solution (d'autres sont possibles à condition d'être cohérentes).</p>
                    <p>Reprenons l'exemple SysMag :</p>
                    <ul>
                        <li>
                            <p>Le client est-il un acteur du système ? Le caissier est-il un acteur du système ? Le responsable du magasin ?</p>
                            <ul>
                                <li>
                                    <p>L'un comme l'autre ne sont en aucun cas des composantes internes du système puisqu'il ne s'agit pas de les informatiser. Il s'agit donc d'acteurs externes au système. Mais sont-ils tous en interactions avec celui-ci ? Lors d'une vente, c'est le caissier qui interagit directement avec le système et le client indirectement. Il faudra donc déterminer précisément leur rôle vis à vis de chaque cas d'utilisation.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>La carte bancaire ou le système de lecture de carte font-ils partie du système ou jouent-t-ils un rôle déterminant vis-à-vis du système</p>
                            <ul>
                                <li>
                                    <p>La carte bancaire est le moyen d'interaction entre le client et le système de paiement. Elle n'appartient pas à notre système. Il y a peu d'intérêt à la modéliser comme acteur.</p>
                                </li>
                                <li>
                                    <p>Le lecteur de carte n'est pas un acteur mais appartient au système de paiement; c'est lui qui détecte l'introduction d'une carte bancaire et permet l'interaction avec le système de paiement.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Le système de paiement est-il une partie du système ou joue-t-il un rôle déterminant vis-à-vis du système ?</p>
                            <ul>
                                <li>
                                    <p>Le système de paiement permet kes paiements par carte bancaire. Il s'agit d'un acteur déterminant pour le business.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>La caisse ?</p>
                            <ul>
                                <li>
                                    <p>La caisse fait partie du système en développement. Mais si elle avait été dotée d'un système intelligent, nous aurions pu la considérer comme un acteur.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>L'écran qui affiche le total au client ?</p>
                            <ul>
                                <li>
                                    <p>L'écran qui affiche le total au client est considéré comme composante interne du SysMag. Il fait partie du système.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Supposons, quelques instants, la modélisation d'un système de magasin avec self scanning. Le caissier reste-t-il acteur du système ?</p>
                    <ul>
                        <li>
                            <p>Effectivement, le rôle des acteurs change dans ce cas. Le client interagit directement avec le système sans intervention du caissier.</p>
                        </li>
                    </ul>
                    <p>Lorsqu'on parle des <span class="em">composants d'un système</span>, on entend une description des <span class="em">éléments logiciels</span> qui le composent. Il ne s'agit pas de décrire les parties matérielles qui interviennent dans celui-ci. En d'autres termes, il s'agit de ce qui est sous la responsabilité des développeurs du système.</p>
                    <h3>4. Le diagramme des cas d'utilisation :</h3>
                    <p>Le diagramme des cas d'utilisation permet d'<span class="em">illustrer</span> les liens entre les acteurs et les différents cas d'utilisation.</p>
                    <h4>4.1. Les rôles des acteurs : primaire ou secondaire :</h4>
                    <p>On distingue 2 rôles d'acteur vis-à-vis d'un cas d'utilisation :</p>
                    <ul>
                        <li>
                            <p>L'<span class="em">acteur primaire</span> ou <span class="em">principal</span> est un acteur qui utilise le système pour réaliser un objectif.</p>
                        </li>
                        <li>
                            <p>Un <span class="em">acteur secondaire</span> est un acteur dont l'aide est nécessaire au système pour réaliser l'objectif d'un acteur primaire.</p>
                        </li>
                    </ul>
                    <p>En d'autres termes :</p>
                    <ul>
                        <li>
                            <p><span class="html">L'acteur primaire</span> est celui qui le cas d'utilisation produit un résultat observable</p>
                        </li>
                        <li>
                            <p><span class="html">Les acteurs secondaires</span> sont les autres; c'est-à-dire ceux qui sont consultés pour fournir des informations complémentaires pour réaliser l'objectif de l'acteur principal.</p>
                        </li>
                    </ul>
                    <p>Un cas d'utilisation possède un seul acteur primaire, à la fois, et peut posséder plusieurs secondaires.</p>
                    <h4>4.2. Graphiquement :</h4>
                    <p>Une relation d'association est un chemin de communication entre un acteur et cas d'utilisation et est représenté par un trait continu.</p>
                    <figure>
                        <img src="../images/relation_acteur_use_case.png" alt="">
                        <figcaption>Figure 3 : les cas d'utilisation : la relation entre acteur et cas d'utilisation</figcaption>
                    </figure>
                    <p>Dans le cadre du cours, on ajoute une <span class="em">flèche</span> sur le lien entre l'<span class="em">acteur primaire</span> et le cas d'utilisation, de l'acteur vers le cas d'utilisation, pour signifier qu'il s'agit de l'acteur principal de ce cas d'utilisation. On peut également ajouter des flèches du cas d'utilisation vers les acteurs secondaires. La norme n'utilise pas la flèche mais un trait continu.</p>
                    <figure>
                        <img src="../images/relation_acteur_use_case_2.png" alt="">
                        <figcaption>Figure 4 : les cas d'utilisation - acteur primaire ou secondaire</figcaption>
                    </figure>
                    <p>Dans l'exemple ci-dessus, Acteur1 est l'acteur principal du CasUtilisation2 et Acteur2 est l'acteur secondaire du CasUtilisation2 mais primaire du CasUtilisation1.</p>
                    <p>Dans le diagrammme des cas d'utilisation, on tente, dans la mesure des possibilités graphiques, de placer l'acteur principal du cas d'utilisation à gauche de celui-ci et les acteurs secondaires à droite. Ceci n'est pas toujours possible car celui qui est acteur secondaire pour un cas d'utilisation peut être acteur primaire pour un autre cas d'utilisation.</p>
                    <p>Dans le système SysMag, pour chaque cas d'utilisation, il faut encore définir quels sont les acteurs primaires et secondaires du système. Nous avons relevé 4 acteurs : le client, le caissier, le système de paiement et le responsable du magasin. Pour déterminer quels rôles jouent ces acteurs dans le système, il suffit de se poser la question suivante : "quel est l'acteur pour qui ce cas d'utilisation est un objectif, c'est-à-dire celui pour qui le cas d'utilisation produit un résultat ?". En d'autres termes, quel est le sujet qui conjugue le verbe de mon cas d'utilisation ?</p>
                    <figure>
                        <img src="../images/diagramme_sysmag.png" alt="">
                        <figcaption>Figure 5 : les cas d'utilisation - Le diagramme SysMag</figcaption>
                    </figure>
                    <p>Le diagramme des cas d'utilisation ci-dessus montre que nous avons 4 acteurs : le client, le caissier, le système de paiement et le responsable du magasin. Le système se limite à trois utilisations : traiter une vente, initier les caisses et ramener des vidanges. Les frontières du système sont également représentées.</p>
                    <p>Pour le cas "traiter une vente", le caissier est l'acteur principal et le client ainsi que le système de paiement sont des acteurs secondaires car ils interviennent dans ce cas d'utilisation. Effectivement, c'est le caissier qui a pour objectif de traiter une vente dans le système et pour ce faire, il sollicite le paiement par le client qui introduit sa carte dans le système. C'est le système de paiement qui permet la validation de la transaction bancaire.</p>
                    <p>Pour le cas "ramener des vidanges", le client est l'acteur primaire. Pour le cas "initier les caisses", le responsable du magasin est l'acteur primaire.</p>
                    <h3>5. Les relations entre cas d'utilisation :</h3>
                    <h4>5.1. Les différents types de relation :</h4>
                    <p>Le diagramme ci-après introduit un certain nombre de relation entre cas d'utilisation. Ces relations sont détaillées dans la suite.</p>
                    <p>Notons déjà qu'il existe trois types de relation entre les cas d'utilisation (détaillée par la suite) :</p>
                    <ul>
                        <li>
                            <p>L'inclusion (Cas d'utilisation interne)</p>
                        </li>
                        <li>
                            <p>L'extension</p>
                        </li>
                        <li>
                            <p>La généralisation / spécialisation</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/diagramme_sysmag_avec_relations.png" alt="">
                        <figcaption>Figure 6 : les cas d'utilisation - Le diagramme SysMag avec les relations</figcaption>
                    </figure>
                    <h4>5.2. Cas d'utilisation interne (inclusion) :</h4>
                    <p>Quand un cas n'esr pas directement relié à un acteur, il est qualifié de <span class="html">cas d'utilisation interne</span>.</p>
                    <p>UML utilise la technique des stéréotypes pour indiquer une relation d'inclusion entre cas d'utilisation : <span class="html">&lt;&lt;include&gt;&gt;</span>. Les cas d'utilisation sont reliés par des flèches marquées de ce mot.</p>
                    <p><span class="em">Include</span> (= uses, notation UML 1.x) signifie qu'un cas d'utilisation utilise un autre cas d'utilisation s'il fait à ce dernier comme à une sous-fonction.</p>
                    <figure>
                        <img src="../images/use_cases_interne.png" alt="">
                        <figcaption>Figure 7 : les cas d'utilisation - cas d'utilisation interne</figcaption>
                    </figure>
                    <p>Le CasUtilisation1 inclut le CasUtilisation2 : si le comportement décrit par le CasUtilisation1 inclut le comportement du CasUtilisation2 : le CasUtilisation1 dépend du CasUtilisation2. Lorsque le CaSUtilisation1 est soliicité, le CasUtilisation2 l'est obligatoirement, comme une partie du CasUtilisation1.</p>
                    <p>Par exemple dans SysMag, le traitement d'une vente comprend l'enregistrement des articles que le client désire acheter et le traitement du paiement.</p>
                    <figure>
                        <img src="../images/use_cases_interne_exemples.png" alt="">
                        <figcaption>Figure 8 : les cas d'utilisation - Cas d'utilisation interne : exemples</figcaption>
                    </figure>
                    <p>Les inclusions permettent de décomposer un cas complexe en sous-cas plus simples. Cependant, il ne faut pas abuser de ce type de décomposition : il faut éviter de réaliser du découpage fonctionnel d'un cas d'utilisation en plusieurs sous-cas d'utilisation pour ne pas faire de séquencement. Attention, les cas d'utilisation ne s'enchaînent pas !</p>
                    <p>Dans notre exemple, seul le cas "traiter le paiement" a un sens dans la mesure où il permet de faire de séquencement. Attention, les cas d'utilisation ne s'enchaînent pas !</p>
                    <p>Les inclusions pemettent essentielelement de factoriser une partie, de la description d'un cas d'utilisation qui serait commune à d'autres cas d'utilisation. Considérons l'exemple suivant :</p>
                    <figure>
                        <img src="../images/use_cases_interne_mauvais_exemple.png.jpg" alt="">
                        <figcaption>Figure 9 : les cas d'utilisation; cas d'utilisation interne : mauvais exemple</figcaption>
                    </figure>
                    <p>Considérant qu'un caissier doit s'authentifier sur la caisse avant de traiter une vente, on pourrait réaliser le diagramme ci-dessus ... MAIS ... Cette inclusion induit qu'à chaque vente le caissier doit s'authentifier ! Dans la réalité un caissier s'authentifie une seule fois et réalise ensuite plusieurs ventes.</p>
                    <h4>5.3. Relation d'extension :</h4>
                    <p>La relation d'extension est probablement la plus utile car elle a une sémantique qui a un sens du point de vue métier au contraire des deux autres (inclusion et généralisation) qui sont plus des artificies d'informaticiens. L'extension est symbolisée par le stéréotype <span class="html">&lt;&lt;extend&gt;&gt;</span>.</p>
                    <p><span class="em">Extend</span> signifie qu'un cas d'utilisation étend un autre cas d'utilisation si dans ce dernier il est possible à un moment donné (appelé point d'extension) de réaliser le premier. Le cas de base peut fonctionner tout seul, mais il peut également être complété par un autre, sous certaines conditions, et uniquement à certains points particuliers de son flot d'évènements (point d'extension).</p>
                    <figure>
                        <img src="../images/use_cases_extension.jpg" alt="">
                        <figcaption>Figure 10 : les cas d'utilisation - relation d'extension</figcaption>
                    </figure>
                    <p>On dit qu'un cas d'utilisation A étend un cas d'utilisation B lorsque le cas d'utilisation A peut être appelé au cours de l'exécution du cas d'utilisation B. Exécuter B peut éventuellement entraîner l'exécution de A : contrairement à l'inclusion, l'extension est optionnelle.</p>
                    <p>L'extension peut intervenir à un point précis du cas étendu. Ce point s'appelle le <span class="em">point d'extension</span>.</p>
                    <p>Graphiquement, on présente ce que l'on appelle un point d'extension dans une note. Ce point d'extension peut éventuellement être infoqié directement sous l'intitulé du cas d'utilisation (comme dans l'illustration 12). Il porte alors un nom, qui figure dans un compartiment du cas étendu sous la rubrique <span class="em">point d'extension</span>. Dans la not equi précise l'extension, on indique également la condition qui déclenche cette extension.</p>
                    <p>Prenons un exemple, lorsque le caissier traite la vente d'un client. Ce dernier peut à un moment donné présenter des coupons de réductions. Le diagramme ci-après montre un point d'extension "coupons" qui est déclenché si le client présente des coupons de réduction.</p>
                    <figure>
                        <img src="../images/use_cases_extension_exemple.jpg" alt="">
                        <figcaption>Figure 11 : les cas d'utilisation - Exemple de relation d'extension</figcaption>
                    </figure>
                    <h4>5.4. Généralisation - spécialisation :</h4>
                    <figure>
                        <img src="../images/use_cases_generalisation.jpg" alt="">
                        <figcaption>Figure 12 : les cas d'utilisation - généralisation</figcaption>
                    </figure>
                    <p>Un cas A est une généralisation d'un cas B si B est un cas particulier de A.</p>
                    <p>Une <span class="html">généralisation de cas d'utilisation</span> est typiquement utilisée pour exprimer un besoin fonctionnel de haut niveau pour un système, sans entrer dans les détails spécifiques. Les spécialisations d'un cas d'utilisation général introduisent des fonctionnalités.</p>
                    <p>Dans SysMag, lorsqu'on a précisé le cas d'utilisation "traiter le paiement", on sait qu'il y a 3 possibilités de paiement : en liquide, par chèques-repas et par carte bancaire. Ce sont là des spécialisations du cas "traiter le paiement".</p>
                    <figure>
                        <img src="../images/use_cases_generalisation_exemple.jpg" alt="">
                        <figcaption>Figure 13 : les cas d'utilisation - généralisation</figcaption>
                    </figure>
                    <p>Cette relation de généralisation/spécialisation est présente dans la plupart des diagrammes UML et se traduit par le concept d'héritage dans les langages orientés Objet.</p>
                    <h4>5.5. Les relations entre acteurs :</h4>
                    <p>La seule relation possible entre deux acteurs est la <span class="html">généralisation</span> : un acteur A est une généralisation d'un acteur B si l'acteur A peut être substitué par l'acteur B. Dans ce cas, tous les cas d'utilisation accessibles à A le sont aussi à B, mais l'inverse n'est pas vrai. Une généralisation d'acteur est utilisée typiquement pour extraire les besoins communs à différents acteurs, afin de simplifier la modélisation.</p>
                    <p>Le symbole utilisé pour la génralisation entre acteurs est une flèche avec un trait plein dont la pointe est un triangle fermé désignant l'acteur le plus général (comme nous l'avons déjà vu pour la relation de généralisation entre cas d'utilisation).</p>
                    <p>Prenons deux exemples dans SysMag :</p>
                    <ul>
                        <li>
                            <p>Le responsable du magasin peut endosser les responsabilités du caissier selon les termes de son contrat.</p>
                        </li>
                        <li>
                            <p>Le caissier peut faire ses courses dans le magasin.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/use_cases_generalisation_entre_acteurs.png" alt="">
                        <figcaption>Figure 14 : les cas d'utilisation - généralisation entre acteurs</figcaption>
                    </figure>
                    <p>Le responsable du magasin est donc une spécialisation du caissier puisqu'il a les mêmes responsabilités que celui-ci en plus de l'initialisation des caisses.</p>
                    <p>Par contre lors qu'on précise que le caissier peut faire ses courses dans le magasin, il ne s'agit pas à propremnt parler d'une nouvelle responsabilité. Lorsqu'il fait ses courses dans le magasin le caissier devient un simple client; il change de casquette !</p>
                    <h3>6. Les scénarios d'un cas d'utilisation :</h3>
                    <h4>6.1. Définition :</h4>
                    <p>Chaque acteir a un ensemble de <span class="em">responsabilités</span>. Pour assumer ces responsabilités, il établit un ou plusieurs objectifs. Pour réaliser un objectif, il exécute des actions. Une action déclenche une <span class="em">interaction</span> avec un autre acteur (interne ou externe), faisant appel à une responsabilité de cet autre acteur. Si celui-ci tient ses promesses, l'acteur primaire sera prêt à atteindre son but. Sinon, l'acteur primaire devra essayer de trouver une autre manière de réaliser son objectif. Il y aura donc une alternative.</p>
                    <p>Les interactions sont simples ou composées. Elles peuvent être réduites à un simple message. Elles peuvent aussi être une suite d'interactions. Une telle suite n'a ni branchement, ni alternatives et est généralement appelée <span class="html">scénario</span>.</p>
                    <p>Un cas d'utilisation est, dès lors, une collection de scénarios. Un scénario est symbolisé par un chemin à travers lequel sont indiquées les responsabilités qui doivent être exécutées par les composantes du système, en réponse à un élément déclenceur donné.</p>
                    <h4>6.2. Scénarios nominal et alternatifs :</h4>
                    <p>Le scénario dans lequel tout se passe bien s'appelle le <span class="html">scénario principal</span> ou <span class="html">nominal</span>. Les autres seront des <span class="html">scénarios alternatifs</span>. Les scénarios se subdivisent en sous-objectifs atteints ou ratés.</p>
                    <p>Un <span class="em">scénario</span> représente une sucesssion particulière d'enchaînements, s'exécutant du début à la fin  du cas d'utilisation, un enchaînement étant l'unité de description de séquences d'actions.</p>
                    <p>Un <span class="em">cas d'utilisation</span> est une <span class="em">collection</span> de <span class="em">scénarios</span> possibles entre le système en construction et les acteurs externes, caractérisé par l'objectif que l'acteur primaire a envers les responsabilités déclarées du syststème, indiquant comme l'objectif de l'acteur primaire peut être atteint ou peut échouer.</p>
                    <h4>6.3. Présentation d'un scénario :</h4>
                    <p>Pour présenter le scénario principal d'un cas d'utilisation :</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Étape</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>Indiquer les diverses étapes du scénario; depuis le déclenchement jusqu'à la fin du scénario (objectif atteint)</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Pour améliorer la lisibilité, on peut présenter le scénario en 2 colonnes, l'une pour les actions de l'acteur principal primaire et l'autre pour les réactions du système. La présentation en deux colonnes offre beaucoup de clarté au scénario mais présente aussi des inconvénients. Tandis qu'elle permet de faire ressortir le dialogue entre le système et l'acteur primaire, lorsqu'un autre acteur intervient, utiliser une troisième colonne devient fastidieux ! De plus, en utilisant deux (ou plusieurs) colonnes, le scénario s'étale sur beaucoup plus de pages qu'une présentation avec une simple colonne.</p>
                    <p>On présente les <span class="em">alternatives</span> au scénario séparement en mentionnant clairement l'étape du scénario à laquellle la condition alternative se vérifie; c'est-à-dire le numéro de l'étape suivi d'une lettre permettant de distinguer les différentes alternatives. Ensuite, les étapes du scénario alternatif sont numérotées linéairement.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Étape</th>
                                <th>Action de branchement</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1.a</td>
                                <td>[condition causant le branchement de l'étape 1 du scénario principal vers un scénario alternatif - action ou sous cas d'utilisation]</td>
                            </tr>
                            <tr>
                                <td>1.a.1</td>
                                <td>Première étape du scénario alternatif</td>
                            </tr>
                            <tr>
                                <td>1.a.2</td>
                                <td>Seconde étape du scénario alternatif</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>1.b</td>
                                <td>[autre condition de branchement de l'étape 1 du scénario principal]</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>3.a</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Une <span class="html">variation</span> est une manière différente de réaliser une étape du scénario mais qui ne modifie en rien les étapes suivantes.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Étape</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>Liste des variations de l'étape 1 du scénario principal</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4>6.4. Les niveaux d'interaction :</h4>
                    <p>On distingue deux niveaux de détail d'interaction :</p>
                    <ul>
                        <li>
                            <p>L'interface de <span class="em">dialogue</span> : peut contenir des objectifs du genre : entrer la rue, le numéro, le code postal et la localité, voire même, choisir dans une combo box...</p>
                        </li>
                        <li>
                            <p>L'interface <span class="em">sémantique</span> : on y préciserait simplement : entrer l'adresse.</p>
                        </li>
                    </ul>
                    <p><span class="html">On chosit généralement de travailler au niveau de l'interface sémantique pour faire le design des cas d'utilisation.</span> La raison d'un tel choix est de laisser le plus de liberté possible pour pouvoir implémenter l'interaction en utilisant des technologies différentes (ex : voix, ...) et pour accepter divers formats de données (pour divers pays par exemple) lors de l'implémentation.</p>
                    <p>Si on écrivait les cas d'utilisation en termes d'interfzace utilisateur, on fixerait les exigences alors que généralement l'interface utilisateur va être sujette à de nombreux changements. Il faudrait recommencer trop souvent le design des cas d'utilisation en s'y prenant ainsi. Par ailleurs, le design de l'interface se fait plus tard, alors que les besoins ont déjà été précisés. En réalité, il est préférable que le groupe chargé de l'interface utilisateur lise les scénarios et propose différentes présentations.</p>
                    <h4>6.5. Exemple :</h4>
                    <p>Voici le scénario principal de "traiter vente" dans SysMag :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p>1. (première étape en-dehors du système)</p>
                                    <p>Le client arrive à la caisse avec ses articles.</p>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>2. Le caissier initie la vente.</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>4. Le système enregistre l'article, affiche son intitulé et son prix ainsi que le total en cours.</td>
                            </tr>
                            <tr>
                                <td colspan="2">Le caissier répète les étapes 3 et 4 jusqu'à ce que tous les articles soient saisis.</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>5. Le système affiche le montant total des courses.</td>
                            </tr>
                            <tr>
                                <td>6. Le caissier communique ce montant au client et lui demande le paiement.</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>7. Le client règle le paiement.</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>8. Le système enregistre la vente et génère un ticket.</td>
                            </tr>
                            <tr>
                                <td>9. Le caissier donne le reçu au client.</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Et quelques alternatives :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>* A [ à tout moment, si le système tombe en panne]</td>
                            </tr>
                            <tr>
                                <td>1. le caissier relance le système et récup!re l'état précédent.</td>
                            </tr>
                            <tr>
                                <td>2. Le système reconstruit l'état précédent.</td>
                            </tr>
                            <tr>
                                <td>2.a. [le syst!me détecte une anomalie qui empêche la récupération de l'état précédent]</td>
                            </tr>
                            <tr>
                                <td>2.a.1. Le système signale l'erreur au caissier et l'enregistre.</td>
                            </tr>
                            <tr>
                                <td>2.a.2. Le caissier démarre une nouvelle vente (échec et branchement en 2)</td>
                            </tr>
                            <tr>
                                <td>Branchement au point 3</td>
                            </tr>
                            <tr>
                                <td>3.a [code article erroné]</td>
                            </tr>
                            <tr>
                                <td>3.a.1. le système signale l'anomalie au caissier.</td>
                            </tr>
                            <tr>
                                <td>3.a.2. le caissier traite l'erreur.</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a. Il y a un code lisible par un être humain.</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.1. Le caissier introduit ce code.</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.2. Le système affiche l'intitulé de l'article ainsi que son prix.</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.2.a. [le code est invalide] Le système signale l'erreur et caissier tente une autre méthode (b ou c).</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.2.b. Il n'y a pas de code mais il y a un prix.</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.2.b.1. Le cassier saisit le prix manuellement (avec l'accord du responsable).</td>
                            </tr>
                            <tr>
                                <td>3.a.2.a.2.c. Le caissier appelle un employé pour obtenir le bon code ou le prix.</td>
                            </tr>
                            <tr>
                                <td>3.b. [plusieurs articles de même code]</td>
                            </tr>
                            <tr>
                                <td>3.b.1. le caissier introduit la quantité.</td>
                            </tr>
                            <tr>
                                <td>3-6.a. [le client présente des coupons de réduction]</td>
                            </tr>
                            <tr>
                                <td>3-6.a.1. Le caissier encode les coupons.</td>
                            </tr>
                            <tr>
                                <td>3-6.a.2. Le système enregistre les coupons.</td>
                            </tr>
                            <tr>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Enfin, les variations :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>3</td>
                                <td>Le caissier encode l'article par scanning ou manuellement.</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Ceci vaut mieux que de réaliser un scénario pour chaque variante. On évite ainsi un trop grand nombre de cas d'utilisation. De plus, placer les variations dans une section séparée permet d'éviter une fois de plus l'explosion du cas d'utilisation.</p>
                    <h3>7. Le modèle de description d'un cas d'utilisation :</h3>
                    <p>Pour décrire un cas d'utilisation, nous utilisons un modèle basé sur le template proposé par Alistair Cockburn (site internet d'Alistair Cockburn : <a href="http://alistair.cockburn.us/" target="_blank">: http://alistair.cockburn.us/</a> et plus précisément : <a href="http://alistair.cockburn.us/index.php/Basic_use_case_template" target="_blank">http://alistair.cockburn.us/index.php/Basic_use_case_template</a>).</p>
                    <h4>7.1. Le modèle complet :</h4>
                    <table>
                        <tbody>
                            <tr>
                                <td>Nom du cas d'utilisation</td>
                                <td>Commencer par un verbe.</td>
                            </tr>
                            <tr>
                                <td>Objectif</td>
                                <td>Une description résumée permettant de comprendre l'intention principale du cas d'utilisation. Cette partie est souvent renseignée en début de projet dans la phase de découverte des cas d'utilisation.</td>
                            </tr>
                            <tr>
                                <td>Niveau</td>
                                <td>Tâche utilisateur ou sous-fonction.</td>
                            </tr>
                            <tr>
                                <td>Acteur principal</td>
                                <td>Fait appel au système pour obtenur un service.</td>
                            </tr>
                            <tr>
                                <td>Parties prenantes et intérêts</td>
                                <td>
                                    <p>Qui s'intéresse à ce cas d'utilisation et que souhaite-t-il ?</p>
                                    <p>Il ne s'agit pas de l'acteur principal mais des intervenants.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Préconditions</td>
                                <td>Définissent ce qui est vrai avant le début d'un scénario. Il s'agit bien de l'état du système AVANT l'enclenchement par le trigger du scénario. Les éléments définis en préconditions sont vérifiables par le système.</td>
                            </tr>
                            <tr>
                                <td>État après réussite</td>
                                <td>Définissent ce qui est vrai lorsque le cas d'utilisation se termine avec succès. Il s'agit de l'état du système APRÈS la réussite du scénario.</td>
                            </tr>
                            <tr>
                                <td>État après échec</td>
                                <td>Définissent ce qui est vrai lorsque le cas d'utilisation ne se termine pas avec succès. Il s'agit de l'état du système APRÈS l'échec du scénario.</td>
                            </tr>
                            <tr>
                                <td>Trigger</td>
                                <td>L'évènement déclencheur souvent externe au système mais peut être aussi un évènement d'horloge (ex après 30 sec).</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>On décrit ensuite :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>Scénario nominal</td>
                                <td>Scénario de succès type, sans conditions (présenté comme vu au point précédent, c'est-à-dire par étapes). On doit également présenter toutes les alternatives au scénario principal.</td>
                            </tr>
                            <tr>
                                <td>Variations et extensions</td>
                                <td>Détails des variations et extensions (généralisation).</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Quelques précisions :</p>
                    <ul>
                        <li>
                            <p>Un cas d'utilisation de niveau <span class="em">tâche utilisateur</span> est la forme courante qui décrit les scénarios servant à un acteur principal d'atteindre ses buts (correspond à un processus métier). Un cas d'utilisation de niveau <span class="em">sous-fonction</span> décrit les sous étapes nécessaires pour la réalisation d'un but utilisateur.</p>
                        </li>
                        <li>
                            <p>Usuellement, l'état après réussite s'appelle aussi post conditions de succès/ Idem pour l'état après échec.</p>
                        </li>
                        <li>
                            <p>Un cas d'utilisation doit être déclenché par quelqu'un ou par quelque chose, l'argent déclencheur étant extérieur au cas d'utilisation mais détectable par le système. Cet agent déclencheur est appelé <span class="em">trigger</span>. Ke trigger peut être le premier évènement du cas d'utilisation ou non; à vous de choisir et de rester cohérent ! Néanmoins, il faut éviter les triggers tels que "le client décide de faire des courses". Le trigger doit être une action pas une décision, une envie,... On préfère alors "le client arrive à la caisse avec ses articles" ou encore "le caissier initie une vente".</p>
                        </li>
                    </ul>
                    <h4>7.2. Exemple :</h4>
                    <table>
                        <tbody>
                            <tr>
                                <td>Nom du cas d'utilisation</td>
                                <td>Traiter une vente</td>
                            </tr>
                            <tr>
                                <td>Objectif</td>
                                <td>Permettre au client de passer ç la caisse avec ses articles et de les payer; mettre à jour les stocks; enregistrer le paiement</td>
                            </tr>
                            <tr>
                                <td>Niveau</td>
                                <td>Tâche</td>
                            </tr>
                            <tr>
                                <td>Acteur principal</td>
                                <td>Caissier</td>
                            </tr>
                            <tr>
                                <td>Parties prenantes et intrêts</td>
                                <td>Client et Banksys</td>
                            </tr>
                            <tr>
                                <td>Pré-conditions</td>
                                <td>La caisse a été initiée par le responsable de magasin, le caissier est authentifié.</td>
                            </tr>
                            <tr>
                                <td>État après réussite</td>
                                <td>La vente est enregistée (ticket imprimé). Les stocks ont été modifiés. Le paiement s'est déroulé avec succès. Le client peut partir avec ses articles.</td>
                            </tr>
                            <tr>
                                <td>État après échec</td>
                                <td>Le paiement n'a pas été effectué. Le client ne part pas avec ses articles et il faut les replacer en rayon.</td>
                            </tr>
                            <tr>
                                <td>Trigger</td>
                                <td>Le client arrive à la caisse avec ses articles.<span class="em">Même si cet événement n'est pas à proprement parler détectable par le système, on préfère préciser que c'est bien l'arrivée d'un client qui génère l'initialisation d'une vente par le caissier.</span></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Remarque : il pourrait y avoir d'autres parties prenantes éventuelles (par exemple, les services fiscaux). Celles-ci  sont indiquées uniquement lorsqu'elles interagissent avec le sytème développé.</p>
                    <h4>7.3. Les contraintes non-fonctionnelles :</h4>
                    <p>On peut intégrer des informations complémentaires à la description du cas d'utilisation</p>
                    <p>Par exemple :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>Informations diverses</td>
                                <td>Nom du Use Case</td>
                            </tr>
                            <tr>
                                <td>Priorité</td>
                                <td>À quel point ce Use Case est critique pour le système ou pour la société ?</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>La quantité de temps que peut prendre ce Use Case.</td>
                            </tr>
                            <tr>
                                <td>Fréquence</td>
                                <td>Combien de fois sera-t-il exécuté sur une période donnée ?</td>
                            </tr>
                            <tr>
                                <td>Moyens pour les acteurs</td>
                                <td>Ex : fichiers, bases de données, types d'interaction...</td>
                            </tr>
                            <tr>
                                <td>Informations utiles</td>
                                <td>
                                    <p>Questions ouvetes qui attendent une décision, planning,...</p>
                                    <p>Liens avec d'autres Use Cases (UC qui appellent celui-ci qui lui sont subordonnés)</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Variantes des données et des technologies</td>
                                <td>
                                    <p>Autres méthodes d'entrées et sorties, format de données...</p>
                                    <p>Langage utilisé, appel à du code Open Source, licence...</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Pour le système SysMag, voici quelques contraintes non fonctionnelles que l'on pourrait ajouter :</p>
                    <ul>
                        <li>
                            <p><span class="em">Performance</span> : le système doit réagir dans un délai inférieur à 4 secondes, peu importe l'action de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="em">Résistance aux pannes</span> : si une coupure de courant ou une autre défaillance survient au cours du cas d'utilisation, la transaction sera annulée, la vente n'aura pas eu lieu. Le système doit pouvoir redémarrer automatiquement dans un état cohérent et sans intervention humaine.</p>
                        </li>
                        <li>
                            <p><span class="em">Résistance à la charge</span> : le système doit pouvoir gérer plus de 4000 ventes par jour.</p>
                        </li>
                    </ul>
                    <h4>7.4. Validation des cas d'utilisation et conseils :</h4>
                    <p>Les cas d'utilisation doivent être validés complètement. On peut le faire en répondant à quelques questions :</p>
                    <ul>
                        <li>
                            <p>Le cas d'utilisation est-il complet ? Des détails doivent-ils être ajoutés ?</p>
                        </li>
                        <li>
                            <p>L'objectif de l'acteur primaire est-il correctement atteint ?</p>
                        </li>
                        <li>
                            <p>Des changements au niveau des exigences ou de la procédure peuvent-ils simplifier le processus décrit dans le cas d'utilisation ?</p>
                        </li>
                        <li>
                            <p>Y a-t-il des objectifs supplémentaires qui n'ont pas été traités ?</p>
                        </li>
                        <li>
                            <p>Y a-t-il des acteurs supplémentaires qui n'ont pas été représentés ?</p>
                        </li>
                    </ul>
                    <p>Les recommandations essentielles présentées ci-après, sont celles de Cockburn. En voici un résumé :</p>
                    <ul>
                        <li>
                            <p>Partir du sommet (les grandes fonctions), et se maintenir le plus possible au niveau <span class="em">objectif utilisateur</span>.</p>
                        </li>
                        <li>
                            <p>Centrer son attention sur le cas nominal (un scénario typique de succès).</p>
                        </li>
                        <li>
                            <p>Préciser toujours les parties prenantes et leurs intérêts.</p>
                        </li>
                        <li>
                            <p>Utiliser un verbe au présent de l'indicatif à chaque étape.</p>
                        </li>
                        <li>
                            <p>Utiliser la voic active pour décrire les sous-objectifs en cours de satisfaction.</p>
                        </li>
                        <li>
                            <p>Le sujet doit être clairement localisable (en début de phrase généralement).</p>
                        </li>
                        <li>
                            <p>Rester concis et pertinent (éviter les longs documents).</p>
                        </li>
                        <li>
                            <p>Éviter les <span class="em">si</span>, et placer les comportements alternatifs dans les <span class="em">extensions</span>.</p>
                        </li>
                        <li>
                            <p>Signaler les sous-cas d'utilisation. Ils sont toujours représentés par la relation d'inclusion d'UML.</p>
                        </li>
                        <li>
                            <p>Identifier le bon objectif.</p>
                        </li>
                        <li>
                            <p>Signaler la portée.</p>
                        </li>
                        <li>
                            <p>Laisser de côté l'interface utilisateur.</p>
                        </li>
                    </ul>
                    <p>Pour écrire les cas d'utilisation, nous proposons de procéder dans l'ordre indiqué ci-dessous :</p>
                    <ol>
                        <li>
                            <p>Description globale du système :</p>
                            <ul>
                                <li>
                                    <p>Limites du système</p>
                                </li>
                                <li>
                                    <p>Acteurs</p>
                                </li>
                                <li>
                                    <p>Cas d'utilisation</p>
                                </li>
                                <li>
                                    <p>Relations entre acteurs</p>
                                </li>
                                <li>
                                    <p>Relations entre acteurs et cas d'utilisation</p>
                                </li>
                                <li>
                                    <p>Relations entre cas d'utilisation.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Description textuelle des cas d'utilisation - modèle (scénarios inclus)</p>
                        </li>
                        <li>
                            <p>Flux alternatifs et variations</p>
                        </li>
                        <li>
                            <p>Vérification globale (redondance, relation, ...)</p>
                        </li>
                    </ol>
                    <h3>8. La dynamique des cas d'utilisation :</h3>
                    <p>Les cas d'utilisation traduisent en termes fonctionnels les besoins des utilisateurs. Lorsque cette étape de définition des cas d'utilisation est achevée, on requiert souvent l'utilisation des diagrammes dynamiques d'UML (diagramme de séquence et d'activités notamment) pour détailler les scénarios.</p>
                    <figure>
                        <img src="../images/dynamique_use_cases.jpg" alt="">
                        <figcaption>Figure 15 : la dynamiqeu des cas d'utilisation</figcaption>
                    </figure>
                    <p>Les diagrammes d'activités permettent de décrire un cas d'utilisation complet (scénario + alternatives + variations) ou encore un ensemble de cas d'utilisation. Les diagrammes de séquence permettent de détailler un scénario particulier (sans alternative ni variation).</p>
                    <p>Dans le cas "traiter une vente" :</p>
                    <figure>
                        <img src="../images/dynamique_use_cases_exemple.jpg" alt="">
                        <figcaption>Figure 16 : la dynamique des cas d'utilisation - exemple</figcaption>
                    </figure>
                    <p>Remarquez que, bien que le diagramme d'activités semble plus compréhensible, il est plus compliqué à réaliser que le diagramme de séquence.</p>
                    <h3>9. Conclusion :</h3>
                    <p>Il est important de noter que l'utilisation des relations n'est pas primordiale dans la rédaction des cas d'utilisation et donc dans l'expression du besoin. Ces relations peuvent être utiles dans certains cas mais une trop forte focalisation sur leur usage conduit souvent à une perte de temps ou à un usage faussé, pour une valeur ajoutée, au final, relativement faible.</p>
                    <p>Unanimement reconnus comme cartonnés à l'ingénierie des besoins, les diagrammes de cas d'utilisation ne peuvent être qualifiés de modélisation à proprement parler. D'ailleurs, de nombreux éléments descriptifs sont en langage naturel. De plus, ils ne correspondent pas <span class="em">stricto sensu</span> à une approche objet. En effet, capturer les besoins, les découvrir, les réfuter, les consolider, etc., correspond plus à une analyse fonctionnelle classique.</p>
                    <p>Les cas d'utilisation sont une bonne approche pour trouver le <span class="html">QUOI</span> plutôt que le <span class="html">COMMENT</span>. Ils forcent à voir les cas exceptionnels aussi bien que les cas normaux.</p>
                    <p>Les cas d'utilisation peuvent aider à formuler les (cas de) tests. Effectivement les scénarios décrits fournissent les grandes lignes des jeux de tests à effectuer sur l'application. Ils constituent le référentiel des tests de validation. C'est-à-dire les tests qui permettent de vérifier que l'application répond bien aux spécifications énoncées.</p>
                </article>
                <article>
                    <h2 id="diagramme_classes">Chapitre 4 : Le diagramme de classes :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Le diagramme de classes est considéré comme le plus important de la modélisation orientée objet, il est le seul obligatoire lors d'une telle modélisation.</p>
                    <p>Alors que le diagramme de cas d'utilisation montre un système du point de vue des acteurs, le diagramme de classes en montre la structure interne. Il permet de fournir une représentation abstraite des objets du système qui vont interagir ensemble pour réaliser les cas d'utilisation. Il est important de noter qu'un même objet peut très bien intervenir dans la réalisation de plusieurs cas d'utilisation.</p>
                    <p>Le <span class="html">diagramme de classes</span> permet de décrire les entités du monde modélisé et les relations existant entre ces entités. Il permet de décrire l'<span class="html">état</span> et le <span class="html">comportement</span> des objets : il montre les <span class="html">attributs</span> et les <span class="html">opérations</span> de chaque classe. De plus, il indique les <span class="html">contraintes</span> devant exister entre les objets.</p>
                    <p>On relève 3 manières (3 perspectives) de concevoir un diagramme de classes :</p>
                    <ul>
                        <li>
                            <p><span class="html">Conceptuelle</span> : On y représente les concepts du domaine étudié. À ce niveau, le diagramme est indépendant du langage d'implémentation.</p>
                        </li>
                        <li>
                            <p><span class="html">De spécification</span> : On précise ici les interfaces pour le langage de programmation qui sera utilisé.</p>
                        </li>
                        <li>
                            <p><span class="html">D'implémentation</span> : On y indique comment les interfaces seront implémentés.</p>
                        </li>
                    </ul>
                    <p>Attention, les diagramme de classes sont très riches, les notations y sont très nombreuses. N'utilisez dans un premier temps que les <span class="em">concepts principaux</span> : classes, associations, attributs, opérations, contraintes et généralisations. N'introduisez les <span class="em">autres notions</span> que quand vous en avez vraiment besoin (10% des cas).</p>
                    <h3>2. Les classes :</h3>
                    <h4>2.1. Les notions de classes et d'objet :</h4>
                    <p>Une <span class="html">classe</span> est la description formelle d'un ensemble d'objets ayant une sémantique et des propriétés communes. Elle représente la description d'un ensemble d'<span class="html">objets</span> possédant les mêmes caractéristiques.</p>
                    <p>Un <span class="html">objet</span> est une entité aux frontières bien définies, possédeant une identité et encapsulant un <span class="html">état</span> et un <span class="html">comportement</span>. Un <span class="html">objet</span> est une <span class="html">instance</span> d'une <span class="html">classe</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_notion_classe_objet.jpg" alt="">
                        <figcaption>Figure 17 : le diagramme de classes - les notions de classe et d'objet</figcaption>
                    </figure>
                    <p>Par exemple, la classe <span class="em">Personne</span> est définie ci-dessus.</p>
                    <ul>
                        <li>
                            <p>Son état englobe 3 attributs : le nom, le prénom et la date de naissance.</p>
                        </li>
                        <li>
                            <p>Son comportement se résume en 2 actions : calculer son âge et donner son nom complet.</p>
                        </li>
                        <li>
                            <p>L'instance <span class="em">qqn</span> est représentée également sur ce diagramme. <span class="em">qqn</span> est un objet de type <span class="em">Personne</span> dont les valeurs de l'état sont indiquées (dubois / jean / 18061982).</p>
                        </li>
                    </ul>
                    <p>En Java, le schéma ci-dessus se traduit par le code suivant :</p>
<pre><code>public class Personne {

    private String nom;
    private String prenom;
    private int dateNaissance;

    public Personne(String nom, String prenom, int dateNaissance) {
        this.nom = nom;
        this.prenom = prenom;
        this.dateNaissance = dateNaissance;
    }

    public int calculerAge() {
        // faire le calcul
        return 0;
    }

    public String renseignerNomComplet() {
        return prenom + " " + nom;
    }

    public static void main(String[] args) {
        Personne qqn = new Personne("dubois", "jean", 18061982);
    }

}</code></pre>
                    <h4>2.2. Les propriétés :</h4>
                    <p>Une classe définit un jeu d'objets dotés de propriétés. Les propriétés d'un objet permettent de spécifier son <span class="html">état</span> et son <span class="html">comportement</span>. Précédemment, nous avons dit que les propriétés d'un objet étaient soit des <span class="html">attributs</span>, soit des <span class="html">opérations</span>, auxquels nous pouvons ajouter les <span class="html">terminaisons d'associations</span>.</p>
                    <h5>2.2.1. État d'un objet :</h5>
                    <p>Ce sont les <span class="html">attributs</span> et les <span class="html">terminaisons d'associations</span> (voir partie sur l'association entre classes) qui décrivent l'<span class="html">état</span> d'un objet. On utilise les attributs pour des valeurs de données pures, dépourvues d'identité, telles que les nombres et les chaînes de caractères. On utilise les associations pour connecter les classes du diagramme de classe. Dans ce cas, la terminaison de l'association (du côté de la classe cible) est une propriété de la classe de base.</p>
                    <p>Les propriétés décrites par les attributs prennent des valeurs lorsque la classe est instanciée.</p>
                    <h5>2.2.2. Comportement d'un objet :</h5>
                    <p>Les <span class="html">opérations</span> décrivent les éléments individuels d'un <span class="html">comportement</span> que l'on peut invoquer. Ce sont des fonctions qui peuvent prendre des valeurs en entrée et modifier les attributs ou produire des résultats. Une opération est la spécification (déclaration) d'une méthode. L'implémentation (définition) d'une méthode est également appelée méthode. Il y a donc une ambiguïté sur le terme méthode.</p>
                    <p>Les attributs, les terminaisons d'association et les méthodes constitient donc les propriétés d'une classe (et de ses instances).</p>
                    <h4>2.3. Graphiquement :</h4>
                    <p>Une classe est représentée par un rectangle divisé en trois à cinq compartiments :</p>
                    <figure>
                        <img src="../images/diagramme_classes_une_classe.jpg" alt="">
                        <figcaption>Figure 18 : le diagramme de classes - une classe</figcaption>
                    </figure>
                    <p>Le premier indique le nom de la classe, le deuxième ses attributs et le troisième ses opérations. Un compartiment des responsabilités peut être ajouté pour énumérer l'ensemble de tâches devant être assurées par la classe mais pour lesquelles on ne dispose pas encore assez d'informations. Un compartiment des exceptions peut également être ajouté pour énumérer les situations exceptionnelles devant être gérées par la classe.</p>
                    <p>Le <span class="em">nom</span> de la classe doit évoquer le concept décrit par la classe. Il commence par une majuscule. On peut ajouter des informations subsidiaires comme le nom de l'auteur de la modélisation, la date, etc.</p>
                    <p>La syntaxe de base de la déclaration d'un nom d'une classe est la suivante :</p>
<pre><code>[ &lt;Nom_du_paquetage_1&gt;::...::&lt;Nom_du_paquetage_N&gt; ] &lt;Nom_de_la_classe&gt; [ { [abstract], [&lt;auteur&gt;], [&lt;date&gt;], ... } ]</code></pre>
                    <h4>2.4. La classe abstraite :</h4>
                    <p>Une classe peut être <span class="html">abstraite</span> : dans ce cas, son nom est indiqué en italique ou en le spécifiant explicitement en utilisant la contrainte <span class="html">&lt;&lt;abstract&gt;&gt</span>. Une classe abstraite est une classe qui n'est pas destinée à être instanciée. Une classe abstraite peut contenir un eou des méthodes qui ne sont pas implémentées. Ces méthodes sont alors appelées méthodes abstraites.</p>
                    <p>Elle peut définir des constructeurs (voir plus bas) mais aucun objet n'aura comme type d'exécution celui d'une classe abstraite. De telles classes servent de canevas pour la construction de sous-classes.</p>
                    <p>Pour indiquer qu'une classe est abstraite (sur un diagramme fait à la main), on utilise la contrainte (pas facile d'écrire en italique à la main :-)).</p>
                    <h4>2.5. Les interfaces :</h4>
                    <p>Une <span class="html">interface</span> est une classe dans laquelle aucune méthode n'est implémentée, et où les champs ne sont pas indiqués.</p>
                    <p>Une interface est représentée comme une classe excepté l'absence du mot-clef <span class="html">abstract</span> (car l'interface et toutes ses méthodes sont, par définition, abstraites) et l'ajout du stéréotype <span class="html">&lt;&lt;interface&gt;&gt;</span>.</p>
                    <p>En Java, on dit qu'une interface est une classe abstraite où tous les attributs sont des constantes (<span class="html">static final</span>).</p>
                    <p>Une interface êut être implémentée par une ou plusieurs classes. Graphiquement, cela est représentée par un trait discontinu terminé par une flèche triangulaire.</p>
                    <p>Par exemple :</p>
                    <figure>
                        <img src="../images/diagramme_classes_interfaces.jpg" alt="">
                        <figcaption>Figure 19 : le diagramme de classes - les interfaces</figcaption>
                    </figure>
                    <p>Une variante plus compacte est de représenter les interfaces à l'aide de petits cercles reliés aux classes qui les implémentent.</p>
                    <figure>
                        <img src="../images/diagramme_classes_interfaces_representation_compacte.jpg" alt="">
                        <figcaption>Figure 20 : le diagramme de classes - les interfaces : représentation compacte</figcaption>
                    </figure>
                    <p>La notation compacte (la petite boule dans le diagramme ci-dessus) permet de monter qu'une classe implémente une interface sans détailler les méthodes de l'interface. Cela permet d'alléger le diagramme de classes.</p>
                    <h4>2.6. Les attributs :</h4>
                    <h5>2.6.1. Notation :</h5>
                    <p>Les attributs définissent des informations qu'une classe ou un objet doivent connaître. Ils représentent les données encapsulées dans les objets de cette classe. Chacune de ces informations est définie par un nom, un type de données, une visibilité et peut être initialisé. Le nom de l'attribut doit être unique dans la classe.</p>
                    <p>La syntaxe de la déclaration d'un attribut est la suivante :</p>
<pre><code>[visibilité] [/] nom [:type] ['['multiplicité']'] [=valeur initiale] [{contrainte}] </code></pre>
                    <p>Exemples :</p>
                    <table role="presentation">
                        <tbody>
                            <tr>
                                <td>+ tailleMoy : int</td>
                                <td>Public</td>
                            </tr>
                            <tr>
                                <td># nom : String[0..10]</td>
                                <td>Protected, tableau</td>
                            </tr>
                            <tr>
                                <td>- prénom : String</td>
                                <td>Private</td>
                            </tr>
                            <tr>
                                <td class="souligne">+ tailleMaximum : int = 2</td>
                                <td>Public, static, valeur initiale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><span class="html">visibilité</span> (ordre décroissant) :</p>
                    <ul>
                        <li>
                            <p><span class="html">public (+)</span> : toutes les classes peuvent accéder à l'attribut <span class="html">public</span>.</p>
                        </li>
                        <li>
                            <p><span class="html">protected (#)</span> : les classes du package ainsi que ses descendants peuvent accéder à l'attribut <span class="html">protected</span>.</p>
                        </li>
                        <li>
                            <p><span class="html">Default (~ ou package)</span> : toutes les classes du même package peuvent accéder à l'attribut <span class="html">package</span>. Lorsqu'aucune visibilité n'est spécifiée, cela correspond à la visibilité par défaut.</p>
                        </li>
                        <li>
                            <p><span class="html">private (-)</span> : la classe uniquement peut accéder à l'attribut <span class="html">private</span>.</p>
                        </li>
                    </ul>
                    <p><span class="html">type</span> indique le type de l'attribut : soit un type primitif (boolean, char ou entier) ou un type de référence.</p>
                    <p><span class="html">Multiplicité</span> indique le nombre de valeurs que peut contenir l'attribut. Sans précision, elle est par défaut à 1. Lorsqu'une multiplicité supérieure à 1 est précisée, cela signifie que cette variable est capable de retenir une référence vers un plusieurs données. Par exemple : <span class="em">int tab []</span> ou encore <span class="em">matrice [] []</span>.</p>
                    <h5>2.6.2. Attribut dérivé :</h5>
                    <p>Certains attributs ont une valeur qui peut se déduire de celles des autres attributs de la classe ou des classes en relation avec elle. Un tel attribut est appelé <span class="html">attribut dérivé</span> et on le représente en faisant précéder son nom de <span class="html">/</span>. Ainsi, la classe <span class="em">Produit</span> peut contenir un champ <span class="em">prixTTC</span> dont la valeur est calculable à l'aide de renseignements provenant des champs <span class="em">TVA</span> et <span class="em">prixHT</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_attribut_derive.jpg" alt="">
                        <figcaption>Figure 21 : le diagramme de classes - l'attribut dérivé</figcaption>
                    </figure>
                    <h5>2.6.3. Attribut de classe :</h5>
                    <p>Un attribut peut être <span class="html">de classe</span> ou <span class="html">d'instance</span>. Les variables de classe sont celles dont la valeur est toujours identique pour toutes les instances de la classe. Les variables d'instance ont une valeur qui peut différer entre plusieurs instances de la classe (leur valeur est propre à instance). Concrètement, une variable de classe associe une certaine quantité de mémoire à une classe. Une variable d'instance associe de la mémoire aux objets.</p>
                    <p>On indique un attribut de classe dans un diagramme de classes en le soulignant.</p>
                    <p>Par exemple : <span class="souligne">tailleMoyenne : int</span>.</p>
                    <h4>2.7. Les méthodes</h4>
                    <h5>2.7.1. Notation :</h5>
                    <p>La déclaration d'une opération contient les types des paramètres et le type de la valeur de retour, sa syntaxe est la suivante :</p>
<pre><code>&lt;visibilité&gt; &lt;nom_méthode&gt; ( [ &lt;paramètre&gt; [, &lt;paramètre&gt; [, &lt;paramètre&gt; ...] ] ] ) :[&lt;type_retour&gt;]</code></pre>
                    <ul>
                        <li>
                            <p><span class="html">type_retour</span> précise le type du résultat de la méthode décrite. Exemple : <span class="em">somme(int, int) : int</span>.</p>
                        </li>
                        <li>
                            <p><span class="html">paramètres</span> indique les types des différents paramètres de la méthode. Exemple : <span class="em">somme(int, int)</span>.</p>
                        </li>
                    </ul>
                    <p>La syntaxe de définition d'un paramètre (<span class="html">&lt;paramètre&gt;</span>) est la suivante :</p>
<pre><code>[&lt;direction&gt;] &lt;nom_paramètre&gt;:&lt;type&gt; ['['&lt;multiplicité&gt;']'] [=&lt;valeur_initiale&gt;] </code></pre>
                    <ul>
                        <li>
                            <p><span class="html">direction</span> permet d'indiquer si le paramètre est un input, un output ou les deux. C'est-à-dire in, out ou inout. En Java, étant donné que les paramètres étant in pour les types primitifs et inout pour les autres, nous <span class="html">ne le spécifierons pas dans le cadre du cours</span>.</p>
                        </li>
                    </ul>
                    <p>Dans une classe, une opération (même nom et mêmes types de paramètres) doit être unique. Quand le nom d'une opération apparaît plusieurs fois avec des paramètres différents, on dit que l'opération est surchargée. En revanche, il est impossible que deux opérations ne se distinguent que par leur valeur retournée.</p>
                    <h5>2.7.2. Méthode de classe :</h5>
                    <p>Une méthode peut être <span class="html">de classe</span> ou <span class="html">d'instance</span>. Les méthodes de classe ne peuvent lire ou modifier que les variables de classe. Les méthodes d'instance peuvent manipuler l'ensemble des variables de l'objet. Contrairement aux variables, les méthodes d'instance sont identiques pour plusieurs instances d'une même classe. Les méthodes de classe sont invoquées en envoyant un message soit à la classe qui les définit, soit à n'importe quelle instance de cette classe.</p>
                    <p>On indique une méthode de classe en la soulignant. Par exemple : <span class="souligne">getTailleMoyenne() : int</span>.</p>
                    <h5>2.7.3. Méthode abstraite :</h5>
                    <p>On peut également signifier qu'une opération est abstraite en la plaçant en italique. Si toutefois, vous élaborez votre schéma à la main, préférez noter le mot <span class="html">abstract</span> comme une contrainte de la méthode. Une <span class="html">méthode abstraite</span> est une <span class="html">méthode ne possédant pas d'implémentation</span>.</p>
                    <p>Lorsqu'il y a au moins une méthode abstraite dans une classe, celle-ci est donc abstraite.</p>
                    <h5>2.7.4. Les types d'opérations :</h5>
                    <p>On distingue différents types d'opérations :</p>
                    <ul>
                        <li>
                            <p>Getter et setter : elles obtiennent (<span class="html">get</span>) et modifient (<span class="html">set</span>) respectivement la valeur d'un attribut et ne font rien d'autre.</p>
                        </li>
                        <li>
                            <p>Un <span class="html">query</span> est une opération qui renvoie une valeur associée à l'objet, sans en changer l'<span class="html">état observable</span>. Autrement dit après l'exécution d'un query les valeurs renvoyées par l'ensemble des queries seront les mêmes. Ce qui ne veut pas dire que les attributs sont tous restés inchangés ! Par exemple, la classe <span class="em">Commande</span> peut contenir un champ <span class="em">montant_total</span> et une opération <span class="em">total_commande()</span>. La première fois que cette opération est appelée, elle calcule le total de la commande et renvoie cette valeur. Elle en profite pour stocker ce total dans le champ <span class="em">montant_total</span>, afin de ne plus devoir le recalculer au prochain appel.</p>
                        </li>
                        <li>
                            <p>Un <span class="html">modificateur</span> change l'état observable d'un objet.</p>
                        </li>
                        <li>
                            <p>Le <span class="html">constructeur</span> est une opération particulière d'une classe qui permet l'<span class="html">instanciation</span>, qui est invoquée pour créer un <span class="em">nouvel objet</span>. Le constructeur initialise les attributs de l'objet construit, c'est-à-dire donne des valeurs à ses attributs. Le constructeur doit avoir :</p>
                            <ul>
                                <li>
                                    <p>Le même nom que la classe</p>
                                </li>
                                <li>
                                    <p>Pas de type de retour</p>
                                </li>
                                <li>
                                    <p>Être invoqué en utilisant </p>
                                    <span class="html">new</span>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Dans le Chapitre 10 : UML en Java, vous trouverez un exemple en Java de ces différentes opérations.</p>
                    <h3>3. Les relations entre classes :</h3>
                    <h4>3.1. L'association :</h4>
                    <p>Une association est une <span class="html">relation entre deux classes</span> (association <span class="html">binaire</span>) ou plus (association <span class="html">n-aire</span>), qui décrit les connexions structurelles entre leurs instances.</p>
                    <p>Une association peut donc relier deux classes mais aussi une classe à un attribut propre (association dégénérée).</p>
                    <p>Les terminaisons d'associations et les attributs sont donc deux éléments conceptuellement très proches.</p>
                    <p>On peut paramétrer les terminaisons d'associations par les éléments suivants :</p>
                    <h5>3.1.1. Le nom :</h5>
                    <p>Comme un attribut, une terminaison d'association (c'est-à-dire une extrémité de l'association) peut être nommée. Le nom est situé à proximité de la terminaison, mais contrairement à un attribut, ce nom est facultatif. Le nom d'une terminaison d'association est appelé <span class="html">nom du rôle</span>. Une association peut donc posséder autant de noms de rôle que de terminaisons (deux pour une association binaire et n pour une association n-aire). Le nom de rôle n'est pas obligatoire; s'il n'est pas présent, il s'agit de la classe d'arrivée.</p>
                    <p>Conventionnellement, on le place sur le côté gauche de l'association en se dirigeant vers la terminaison en question.</p>
                    <h5>3.1.2. La multiplicité :</h5>
                    <p>Comme un attribut, une terminaison d'association peut posséder une multiplicité. Elle est mentionnée à proximité de la terminaison. Contrairement à un attribut dont la multiplicité par défaut est 1, la multiplicité par défaut d'une terminaison d'association est <span class="em">non spécifiée</span>. La multiplicité indique combien d'objets participent à une relation.</p>
                    <p>On les indique en précisant la valeur inférieure et la valeur supérieure, par exemple :</p>
                    <ul>
                        <li>
                            <p class="em">1 .. 10</p>
                        </li>
                        <li>
                            <p class="em">0 .. 1</p>
                        </li>
                        <li>
                            <p>...</p>
                        </li>
                    </ul>
                    <p>Si les valeurs inférieure et supérieure sont identiques, on n'indique qu'un seul nombre; par exemple, <span class="em">1</span> au lieu de <span class="em">1 .. 1</span>.</p>
                    <p>L'abbréviation <span class="html">*</span> désigne une valeur quelconque; on peut utiliser <span class="html">*</span> comme suit :</p>
                    <ul>
                        <li>
                            <p><span class="em">*</span> qui signifie <span class="em">0 .. infini</span>, autrement dit 0, 1 ou plusieurs.</p>
                        </li>
                        <li>
                            <p><span class="em">1 .. *</span> signifie 1 ou plusieurs.</p>
                        </li>
                    </ul>
                    <h5>3.1.3. La visibilité :</h5>
                    <p>Comme un attribut, une terminaison d'association possède une visibilité. La visibilité (<span class="html">private</span>, <span class="html">package</span>, <span class="html">public</span> ou <span class="html">protected</span>) est mentionnée à proximité de la terminaison, et plus précisément, le cas échéant, devant le nom de la terminaison.</p>
                    <h5>3.1.4. La navigabilité :</h5>
                    <p>Pour un attribut, la navigabilité est implicite, navigable, et toujours depuis la classe vers l'attribut. Pour une terminaison d'association, la navigabilité peut être précisée.</p>
                    <p>Une flèche indique dans quel sens se lit l'association (direction). Une flèche est appelée une <span class="html">navigation</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_association_bidirectionnelle.jpg" alt="">
                        <figcaption>Figure 22 : le diagramme de classes - association bidirectionnelle</figcaption>
                    </figure>
                    <p>Utilisation d'une flèche de navigation :</p>
                    <figure>
                        <img src="../images/diagramme_classes_association_unidirectionnelle.jpg" alt="">
                        <figcaption>Figure 23 : le diagramme de classes - association unidirectionnelle</figcaption>
                    </figure>
                    <p>On supprime la responsabilité pour la pizza de fournir la liste de ses commandes.</p>
                    <p>Une association sans navigation peut être interprétée dans deux sens : soit il s'agit d'une association bidirectionnelle, soit il s'agit d'une association pour laquelle on n'a pas  encore précisé les navigations.</p>
                    <p>Par exemple :</p>
                    <figure>
                        <img src="../images/diagramme_classes_exemple_associations_bidirectionnelle_unidirectionnelle.jpg" alt="">
                        <figcaption>Figure 24 : le diagramme de classes - exemple d'associations bidirectionnelle et unidirectionnelle</figcaption>
                    </figure>
                    <p>Une association <span class="em">unidirectionelle</span> implique qu'un seul des deux objets (celui à l'origine de la flèche) liés par la relation connaît l'autre. Par exemple, un objet de type <span class="em">Personne</span> référence zéro ou plusieurs voitures. Cependant, à partir d'un objet de type <span class="em">Voiture</span>, on ignore l'objet de type <span class="em">Personne</span> auquel il est lié.</p>
                    <p>Une association <span class="em">bidirectionnelle</span> implique une contrainte supplémentaire : les deux rôles doivent être inverses l'un de l'autre. Un objet de type <span class="em">Personne</span> référence ou non un objet de type <span class="em">PermisConduire</span> et un objet de type <span class="em">PermisConduire</span> référence toujours un objet de type <span class="em">Personne</span>. Et si un <span class="em">PermisConduire</span> référence telle <span class="em">Personne</span>, cette <span class="em">Personne</span> doit référencer ce <span class="em">PermisConduire</span> et de même dans l'autre sens.</p>
                    <h4>3.2. L'association qualifiée :</h4>
                    <p>Quand une classe est liée à une autre classe par une association, il est parfois préférable de restreindre la portée de l'association à quelques éléments cibles (comme un ou plusieurs attributs) de la classe. Ces éléments cibles sont appelés un <span class="html">qualificatif</span>.</p>
                    <p>Un qualificatif permet donc de sélectionner un objet dans les objets reliés par l'association qualifiée à l'objet principal. L'objet sélectionné par la valeur du qualificatif est appelé <span class="em">objet cible</span>.</p>
                    <p>L'association est appelée <span class="html">association qualifiée</span>. Un qualificatif agit toujours sur une association dont la multiplicité est plusieurs (avant que l'association ne soit qualifiée) du côté cible.</p>
                    <p>Un objet qualifié et une valeur de qualificatif génèrent un objet cible lié unique. En considérant un objet qualifié, chaque valeur de qualificatif désigne un objet cible unique. Un <span class="html">qualificatif</span> est donc un attribut d'association dont les valeurs partitionnent la liste des objets reliés par le biais d'une association. En d'autres termes, la connaissance d'un objet et d'une valeur de qualificatif permet de retrouver un objet lié à l'autre bout de l'association concernée.</p>
                    <p>Par exemple, le numéro du quai permet de retrouver le quai dans une gare.</p>
                    <p>Le fait de qualifier l'association montre l'importance du numéro dans l'association par rapport à la version avec l'agrégation. Les qualifications des associations sont traduites en programmation par les clés des tables de hachage.</p>
                    <figure>
                        <img src="../images/diagramme_classes_association_qualifiee_1.jpg" alt="">
                        <figcaption>Figure 25 : le diagramme de classes - l'association qualifiée 1</figcaption>
                    </figure>
                    <p>Autre exemple, une instance du triplet {<span class="em">Echiquier</span>, <span class="em">rangée</span>, <span class="em">colonne</span>} est en association avec une instance unique de la classe <span class="em">Case</span>. Inversement, une instance de la classe <span class="em">Case</span> est en classe <span class="em">Case</span> est en association avec une instance unique du triplet {<span class="em">Echiquier</span>, <span class="em">rangée</span>, <span class="em">colonne</span>}.</p>
                    <figure>
                        <img src="../images/diagramme_classes_association_qualifiee_2.jpg" alt="">
                        <figcaption>Figure 26 : le diagramme de classes - l'association qualifiée 2</figcaption>
                    </figure>
                    <h4>3.3. Classes - Associations :</h4>
                    <p>Une <span class="html">classe-association</span> possède les propriétés des associations et des classes : elle se connecte à deux ou plusieurs classes et possède également des attributs et des opérations.</p>
                    <p>Une classe-association est caractérisée par un trait discontinu entre la classe et l'association qu'elle représente.</p>
                    <p>Considérons le cas suivant : une personne est compétente dans certaines matières et une matière relève de la compétence de certaines personnes. Pour chaque compétence, on désire mentionner un niveau.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe-association_exemple_1.jpg" alt="">
                        <figcaption>Figure 27 : le diagramme de classes - classe-association, exemple 1</figcaption>
                    </figure>
                    <p>Ici, la classe-association s'impose : le niveau de compétence d'une personne est unique dans chaque matière.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe-association_exemple_2.jpg" alt="">
                        <figcaption>Figure 28 : le diagramme de classes - classe-association, exemple 2</figcaption>
                    </figure>
                    <p>On suppose qu'une personne ne travaille que pour un employeur à la fois. On voudrait préciser la période (date de début et date de fin) pendant laquelle il est employé. Pour ce faire, on rajoute une classe-association <span class="em">Emploi</span> qui permet de garder cette information. Placer ce renseignement dans la classe <span class="em">Personne</span> est possible mais non justifié, car il concerne l'association et non la personne elle-même.</p>
                    <p>Une autre manière de représenter cette information est de faire d'<span class="em">Emploi</span> une classe.</p>
                    <figure>
                        <img src="../images/diagramme_classes_association_derivee.jpg" alt="">
                        <figcaption>Figure 29 : le diagramme de classes - l'association dérivée</figcaption>
                    </figure>
                    <p>Dans ce cas, l'association employeur est appelée une <span class="html">association dérivée</span>. Cela signifie que l'association est déductible des autres associations déjà présentes dans le diagramme de classes. On l'indique en faisant précéder le nom du rôle par un <span class="em">/</span>.</p>
                    <h5>Quand choisir une classe-association plutôt qu'une véritable classe ?</h5>
                    <p>Le fait qu'une classe-association ajoute une contrainte qui n'ajouterait pas l'emploi d'une vraie classe. Reprenons l'exemple composé des trois classes <span class="em">Personne</span>, <span class="em">Société</span> et <span class="em">Emploi</span>. Supposons maintenant qu'on désire tenir compte des divers emplois occupés par une personne au cours de sa carrière. On placera, alors, une multiplicité <span class="em">*</span> au lieu de <span class="em">0..1</span> à l'extrémité de l'association côté <span class="em">Société</span> :</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe-association_exemple_3.jpg" alt="">
                        <figcaption>Figure 30 : le diagramme de classes - classe-association, exemple 3 (mauvais usage)</figcaption>
                    </figure>
                    <p>Dans ce diagramme, l'emploi d'une classe-association restreint une personne à ne pouvoir travailler qu'une seule fois pour une société, ce qui est irréaliste. Il est judicieux d'utiliser ici une vraie classe; on utilisera donc une classe <span class="em">Emploi</span> à part entière comme le montre le diagramme suivant :</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe-association_exemple_4.jpg" alt="">
                        <figcaption>Figure 31 : le diagramme de classes - classe-association, exemple 4</figcaption>
                    </figure>
                    <h4>3.4. Agrégation / composition :</h4>
                    <p>L'<span class="html">agrégation</span> est la relation qui relie la partie au tout. Elle représente une relation d'inclusion d'un élément dans un ensemble.</p>
                    <p>Contrairement à une association simple, l'agrégation est transitive.</p>
                    <p>L'agrégation se représente par un petit losange placé du côté de l'agrégat.</p>
                    <figure>
                        <img src="../images/diagramme_classes_agregation.jpg" alt="">
                        <figcaption>Figure 32 : le diagramme de classes - agrégation</figcaption>
                    </figure>
                    <p>Si on modifie l'agrégat, certains constituants peuvent changer.</p>
                    <p>La <span class="html">composition</span> est une forme forte d'agrégation. Les parties vivent et meurent avec le tout et font définitivement partie de lui. Une partie ne peut faire partie que d'un seul tout. Ceci implique la suppression en cascade des parties avec le tout. Si le nombre de composants est fixé, ils peuvent être représentés par des attributs.</p>
                    <p>La composition est représentée sur le diagramme par un losange noir.</p>
                    <figure>
                        <img src="../images/diagramme_classes_composition.jpg" alt="">
                        <figcaption>Figure 33 : le diagramme de classes - composition</figcaption>
                    </figure>
                    <h4>3.5. Généralisation / spécialisation :</h4>
                    <h5>3.5.1. Les concepts :</h5>
                    <p>La <span class="html">généralisation</span> décrit une relation entre une classe générale (classe de base ou classe parent) et une classe spécialisée (sous-classe). La classe spécialisée est intégralement cohérente avec la classe de base, mais comporte des informations supplémentaires (attributs, opérations, associations). Un objet de la classe spécialisée peut être utilisé partout où un objet de la classe de base est autorisé.</p>
                    <p>Dans le langage UML, ainsi que dans la plupart des langages objet, cette relation de généralisation se traduit par le concept d'héritage. On parle également de <span class="html">relation d'héritage</span>.</p>
                    <p>Le symbole utilisé pour la relation d'héritage ou de généralisation est une flèche avec un trait plein dont la pointe est un triangle fermé désignant le cas le plus général.</p>
                    <p>Quand des classes ont entre elles un certain nombre de différences mais beaucoup de ressemblances, ces similiarités seront placées dans une classe générale. Par exemple : un client de type société et un client de type privé donnent lieu à la classe générale <span class="em">Client</span>.</p>
                    <h5>3.5.2. Graphiquement :</h5>
                    <figure>
                        <img src="../images/diagramme_classes_generalisation.jpg" alt="">
                        <figcaption>Figure 34 : le diagramme de classes - généralisation</figcaption>
                    </figure>
                    <p>En résumé :</p>
                    <ul>
                        <li>
                            <p>L'option de la généralisation :</p>
                            <ul>
                                <li>
                                    <p>Factorisation d'éléments communs, permettant l'expression d'énoncés plus génériques</p>
                                </li>
                                <li>
                                    <p>Abstraction des détails spécifiques aux classes spécialisées</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>L'optique de la spécialisation :</p>
                            <ul>
                                <li>
                                    <p>Ajout de caractéristiques spécifiques à cette sous-classe</p>
                                </li>
                                <li>
                                    <p>Focalisation sur les aspects spécifiques de cette sous-classe</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h5>3.5.3. Complet - incomplet :</h5>
                    <figure>
                        <img src="../images/diagramme_classes_generalisation_complete.jpg" alt="">
                        <figcaption>Figure 35 : le diagramme de classes - généralisation complète</figcaption>
                    </figure>
                    <figure>
                        <img src="../images/diagramme_classes_generalisation_incomplete.jpg" alt="">
                        <figcaption>Figure 36 : le diagramme de classes - généralisation incomplète</figcaption>
                    </figure>
                    <p>Les généralisations ci-dessus précisent si l'ensemble des enfants d'une classe est <span class="html">complet</span> ou <span class="html">incomplet</span>.</p>
                    <ul>
                        <li>
                            <p>Dans le premier diagramme, un objet de type Personne ne pourra plus être spécialisé par une autre classe que celles mentionnées (Etudiant, Professeur ou Autre).</p>
                        </li>
                        <li>
                            <p>Par contre, dans le second, on pourra davantage spécialiser le type Sportif si nécessaire. Sans aucune mention, une généralisation est incomplète.</p>
                        </li>
                    </ul>
                    <h4>3.6. Classification / instanciation :</h4>
                    <h5>3.6.1. Les concepts :</h5>
                    <p>L'<span class="html">instanciation</span>d'une classe A correspond à la création d'objets de type A. Dans l'exemple qui suit, <span class="em">obj3</span> est une une instanciation du type <span class="em">Professeur</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classification.png" alt="">
                        <figcaption>Figure 37 : Le diagramme de classes - classification</figcaption>
                    </figure>
                    <p>La <span class="html">classification</span> réfère à la relation entre un objet et son type. Un objet possède un type d'une certaine classe.</p>
                    <p>Dans la classification simple, un objet appartient à un type unique, qui peut hériter d'autres types.</p>
                    <p>Une classification doit être stable et extensible.</p>
                    <p>L'héritage permet la classification des objets. Effectiment, sur base de l'exemple du diagramme de l'héritage <span class="em">Animal - Chien (figure 39)</span>, une instance de <span class="em">Chien</span> est également une instance d'<span class="em">Animal</span>.</p>
                    <p>Le principe de substitution (Liksow, 1987) permet de déterminer si une relation d'héritage est bien employée par la classification : "Il doit être possible de substituer n'importe quelle instance d'une super-classe, par n'importe quelle instance d'une de ses sous-classes, sans que la sémantique d'un programme écrit dans les termes de la super-classe n'en soit affectés.".</p>
                    <h5>3.6.2. Classification dynamique :</h5>
                    <p>En <span class="html">classification statique</span>, l'objet ne peut pas changer de type. Ceci est permis en <span class="html">classification dynamique</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classificateur_dynamique.jpg" alt="">
                        <figcaption>Figure 38 : le diagramme de classes - classificateur dynamique</figcaption>
                    </figure>
                    <p>Dans l'exemple ci-dessus, une personne peut changer de poste durant sa carrière : elle peut, par exemple, être vendeur et ensuite être promu manager.</p>
                    <p>Les classifications dynamiques sont utiles au niveau conceptuel. Le problème est de les implémenter de manière à respecter ce modèle en ce qui concerne l'interface/ Si, passer d'une interface dynamique à une implémentation simple et statique est trop compliqué, mieux vaut alors s'en passer.</p>
                    <h5>3.6.3. Association "est un" :</h5>
                    <p>Les notations de <span class="html">généralisation/spécialisation</span> et de <span class="html">classification</span> génèrent des associations de type "est un".</p>
                    <p>Les généralisations sont transitives tandis qu'une classification n'est pas transitive.</p>
                    <p>Exemple :</p>
                    <ol>
                        <li>
                            <p>Une généralisation : Un Labrador est un Chien.</p>
                            <p>Dans ce cas, Labrabor est une classe spécialisant la classe Chien.</p>
                        </li>
                        <li>
                            <p>Autre généralisation "Un Chien est un Animal".</p>
                        </li>
                        <li>
                            <p>Enfin, on ajoute une classification : "Le Chien est une Espèce"</p>
                            <p>Dans ce cas, Chien est un objet de la classe Espèce.</p>
                        </li>
                    </ol>
                    <p>Un Labrador est bien un Animal par (1) et (2) mais n'est pas une Espère comme l'impliquerait (1) et (3).</p>
                    <p><span class="html">On évitera dès lors d'employer le terme "est un" pour nommer une association</span>, car, comme on le voit, il est source de confusion et peut conduire à créer des sous-types respectant le principe de substitution là où il ne s'applique pas.</p>
                    <h4>3.7. Dépendance :</h4>
                    <p>Une classe (classe cliente de l'interface) peut dépendre d'une interface ou d'une autre classe. On représente cela par une relation de dépendance et le stéréotype <span class="html">&lt;&lt;use&gt;&gt;</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_dependance.jpg" alt="">
                        <figcaption>Figure 39 : le diagramme de classes - les interfaces avec une relation de dépendance</figcaption>
                    </figure>
                    <p>Ceci signifie que la classe <span class="em">Client</span> utilise l'interface <span class="em">List</span>. Il y a donc une dépendance de la classe <span class="em">Client</span> vis-à-vis de l'interface <span class="em">List</span>; un changement dans <span class="em">List</span> a des répercussions dans <span class="em">Client</span> qui en dépend.</p>
                    <h3>4. Les contraintes supplémentaires :</h3>
                    <p>Un diagramme de classes est une manière de préciser des contraintes à respecter par le système. Les multiplicités en sont une forme : ainsi on apprend qu'une <span class="em">Commande</span> est faite par un seul client. Les constructions de base : associations, attributs, généralisations précisent en réalité les contraintes principales.</p>
                    <p>Il est possible dans les diagrammes UML (pas uniquement les classes) d'ajouter d'autres contraintes comme le fait qu'un attribut doive être final par exemple. Il suffit d'ajouter ces contraintes à la suite de la définition de la propriété entre {}.</p>
                    <p>Il existe aussi un langage qui formalise l'expression des <span class="em">contraintes</span> : <span class="html">OCL</span> (Object Constraint Language). Ce langage formel est volontairement simple d'accès et possède une grammaire élémentaire (OCL peut être interprété par des outils). Les contraintes seront mises entre accolades : {}. Il n'y a pas de syntaxe particulière pour les écrire. UML n'oblige pas l'utilisation d'OCL. On pourra donc utiliser du français courant, ou un langage semi-formel voire un fragment de code.</p>
                    <p>Par exemple, le <span class="html">XOR</span> est une notation que l'on peut ajouter pour ajouter une contrainte entre associations. Un XOR est un "ou exclusif".</p>
                    <figure>
                        <img src="../images/diagramme_classes_xor.png" alt="">
                        <figcaption>Figure 40 : le diagramme de classes - XOR</figcaption>
                    </figure>
                    <h3>5. Les stéréotypes :</h3>
                    <p>Il s'agit d'un mécanisme génral d'extension du langage UML.</p>
                    <p>Les stéréotypes sont indiqués entre guillemets (&lt; &gt;).</p>
                    <p>Certains stéréotypes sont prédéfinis, mais chacun peut en définir d'autre à sa convenance.</p>
                    <p>Ici, nous pourrions définir le stéréotype <span class="em">&lt;historique&gt;</span> pour infiquer que nous voulons nous conformer au pattern <span class="html">Historic Mapping</span> décrit dans Fowler : Analysis Pattern (Addison - Wesley, 1997).</p>
                    <p>Le diagramme de l'illustration 31 se résume alors à :</p>
                    <figure>
                        <img src="../images/diagramme_classes_pattern_historique.jpg" alt="">
                        <figcaption>Figure 41 : le diagramme de classes - pattern historique</figcaption>
                    </figure>
                    <p>Ce modèle nous apprend qu'une personne ne peut travailler que pour un seul employeur à la fois, mais qu'au cours du temps, il peut changer de société.</p>
                    <h3>6. Les classes paramétrées :</h3>
                    <p>Aussi appelé <span class="html">generics</span> en Java (depuis Java 1.5), ce concept est utile pour définir des collections d'objets dans un environnement fortement typé.</p>
                    <p>La notation UML est :</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe_parametree.jpg" alt="">
                        <figcaption>Figure 42 : le diagramme de classes - classe paramétrée</figcaption>
                    </figure>
                    <p>La classe <span class="em">Ensemble</span> possède deux méthodes chacune prenant en paramètre un objet de type <span class="em">T</span> (non indiqué dans le diagramme).</p>
                    <p>L'emploi d'une classe paramétrée donne lieu à ce qu'UML appelle un <span class="html">élément lié</span>.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe_parametree_element_lie.jpg" alt="">
                        <figcaption>Figure 43 : le diagramme de classes - classe paramétrée, élément lié</figcaption>
                    </figure>
                    <p>On peut également la représenter comme suit :</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe_parametree_autre_notation.jpg" alt="">
                        <figcaption>Figure 44 : le diagramme de classes - classe paramétrée, autre notation</figcaption>
                    </figure>
                    <p><span class="em">EnsembleDEmployés</span> possède une implémentation de toutes les méthodes d'<span class="em">Ensemble</span> pour lesquels le paramètre <span class="em">T</span> est chaque fois remplacé par le paramètre <span class="em">Employé</span>.</p>
                    <p>Les classes paramétrées ne sont quasi jamais utilisées dans un modèle conceptuel. Elles servent à représenter des collections qui sont, à ce niveau, indiquées par les associations.</p>
                    <p>Aux niveaux de spécification et d'implémentation, on ne les emploiera que si le langage utilisé les supporte.</p>
                    <h3>7. Conclusion :</h3>
                    <p>En respectant la norme, il est aisé de reconnaître les relations entre classes en observant le graphisme de celle-ci.</p>
                    <div>
                        <figure class="float-left">
                            <img src="../images/diagramme_classes_graphisme_relations.png" alt="">
                            <figcaption>Figure 45 : le diagramme de classes - le graphisme des relations</figcaption>
                        </figure>
                        <p>Dans l'exemple ci-contre, nous observons immédiatement :</p>
                        <ul>
                            <li>
                                <p>une dépendance entre A et B</p>
                            </li>
                            <li>
                                <p>une association entre A1 et B1</p>
                            </li>
                            <li>
                                <p>une spécialisation entre A2 et B2</p>
                            </li>
                            <li>
                                <p>une implémentation entre A3 et B3</p>
                            </li>
                        </ul>
                    </div>
                    <p>Aux différentes étapes de l'analyse, dessinez des diagrammes de classes <span class="html">appropriés</span> sans essayer de mettre la charrue avant les boeufs.</p>
                    <ul>
                        <li>
                            <p>Durant l'analyse, ne dessinez que des diagrammes conceptuels.</p>
                        </li>
                        <li>
                            <p>Quand vous commencez à travailler avec le langage choisi, dessinez des diagrammes de spécialisation, afin de définir les interfaces.</p>
                        </li>
                        <li>
                            <p>Si vous avez besoin de préciser telle ou telle technique d'implémentation particulière, dessinez un diagramme d'implémentation. Ne le faites pas si l'implémentation coule de source.</p>
                        </li>
                    </ul>
                    <p>Ne dessinez de diagrammes que pour les <span class="html">points clés</span>. Mieux vaut peu de diagrammes utilisés qu'un tas de schémas non employés.</p>
                    <h3>8. CRC Cards :</h3>
                    <p>L'orienté Objet semble une vision naturelle du monde mais cela reste complexe de concevoir un système orienté objets, de répartir les responsabilités dans une architecture orientée objets, ...</p>
                    <p>Les cartes CRC, <span class="html">Classes Responsabilités Collaborateurs</span>, sont apparues comme un moyen aussi simple qu'efficace d'analyser les scénarios. Initialement proposé par Beck et Cunnigham comme outil pour l'enseignement de la programmation orientée Objet, elles se sont montrées d'excellents outils de développement qui facilitent les remue-méninges et améliorent la communication entre développeurs.</p>
                    <p>La méthodologie employée pour concevoir les CRC est le brainstorming qui se base sur l'analyse des scénarios pour concevoir le design de l'architecture du système.</p>
                    <p>Les principes du brainstorming :</p>
                    <ul>
                        <li>
                            <p>Toutes les idées potentielles sont bonnes;</p>
                            <ul>
                                <li>
                                    <p>Pas de censure !</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Penser rapidement et furtivement; pondérer plus tard !</p>
                            <ul>
                                <li>
                                    <p>Une discussion rapide encourage la créativité individuelle.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Donner la parole à chacun;</p>
                            <ul>
                                <li>
                                    <p>Ne laisser personne s'imposer !</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Un peu d'humour est bénéfique;</p>
                            <ul>
                                <li>
                                    <p>L'humour permet de relâcher les tensions et de rendre le groupe plus cohérent et effectif.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Les classes sont représentées sur des <span class="html">fiches</span> standard (10 cm x 15 cm) et non en diagramme. Il est interdit d'utiliser plus d'une fiche par classe.</p>
                    <figure>
                        <img src="../images/carte_crc.png" alt="">
                        <figcaption>Figure 46 : une carte CRC</figcaption>
                    </figure>
                    <p>On y indique les <span class="html">responsabilités</span> de la classe au lieu d'attributs et de méthodes.</p>
                    <ul>
                        <li>
                            <p>Une responsabilité est une description de haut niveau d'un but de la classe.</p>
                        </li>
                        <li>
                            <p>La liste doit être courte : trois responsabilités est une borne supérieure normale.</p>
                        </li>
                        <li>
                            <p>Il ne faut pas y lister de nombreuses petites responsabilités de bas niveau.</p>
                        </li>
                    </ul>
                    <p>Une deuxième colonne indique les <span class="html">collaborateurs</span> nécessaires pour chaque responsabilité. Ceci donne une idée, à un haut niveau, des liens entre classes.</p>
                    <p>Les cartes CRC encouragent la discussion entre développeurs et experts métier, particulièrement pour décider comment mettre en oeuvre un cas d'utilisation. En général, une équipe se compose de 5 ou 6 personnes idéalement :</p>
                    <ul>
                        <li>
                            <p>1 ou 2 experts métier</p>
                        </li>
                        <li>
                            <p>1 ou 2 analystes</p>
                        </li>
                        <li>
                            <p>1 analyste spécialisé OO</p>
                        </li>
                        <li>
                            <p>1 leader (pas un boss)</p>
                        </li>
                    </ul>
                    <p>Avoir une petite équipe, c'est un manque de diversité, mais, l'inverse amène des difficultés à s'accorder.</p>
                    <p>Les CRC sont particulièrement utiles pour se démarquer d'un modèle de données, vu leur côté comportemental. Les CRC peuvent être considérées comme un <span class="html">diagramme de classes de niveau conceptuel</span> dans lequel les responsabilités sont définies pour chaque classe.</p>
                    <h4>8.1. Les principes :</h4>
                    <ul>
                        <li>
                            <p>Le texte de chaque carte doit rester simple. En particulier, les détails non essentiels du système ne doivent pas y être données.</p>
                        </li>
                        <li>
                            <p>Il est permis d'effacer et de réécrire le contenu d'une carte au fur et à mesure de l'étude des scénarios.</p>
                        </li>
                        <li>
                            <p>On y indique les responsabilités de la classe au lieu d'attributs et de méthodes.</p>
                            <ul>
                                <li>
                                    <p>Une responsabilité = description de haut niveau d'un but de la classe.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>La liste des responsabilités doit être courte.</p>
                            <ul>
                                <li>
                                    <p>Trois responsabilités est une borne supérieure normale.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Une deuxième colonne indique les collaborateurs nécessaires pour chaque responsabilité.</p>
                            <ul>
                                <li>
                                    <p>Ceci donne une idée, à un haut niveau, des liens entre classes.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h4>8.2. Le déroulement :</h4>
                    <ol>
                        <li>
                            <p>Déterminer les scénarios sur lesquels on travaille :</p>
                            <ul>
                                <li>
                                    <p>Choisir un ensemble de cas d'utilisation cohérent c'est-à-dire liés aux mêmes objets.</p>
                                </li>
                                <li>
                                    <p>Avant de commencer le jeu, chaque membre doit réaliser sa propre investigation parmi les <span class="html">sources d'informations</span> :</p>
                                    <ul>
                                        <li>
                                            <p>Documents d'études des besoins (cas d'utilisation) &#8594; les scénarios</p>
                                        </li>
                                        <li>
                                            <p>Interviews des utilisateurs</p>
                                        </li>
                                        <li>
                                            <p>Rapports existants</p>
                                        </li>
                                        <li>
                                            <p>Fichiers existants et bases de données existantes</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Un bon analyste est un bon détective !</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Lister les intervenants potentiels (classes candidates) :</p>
                            <ul>
                                <li>
                                    <p>Comment repérer les classes candidates ?</p>
                                    <ul>
                                        <li>
                                            <p>Par brainstorming</p>
                                        </li>
                                        <li>
                                            <p>On relève tous les termes qui appartiennent à la définition du business (glossaire)</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Trier les classes candidates en 3 :</p>
                                    <ul>
                                        <li>
                                            <p>Les classes <span class="html">critiques</span> (core classes) <span class="em">&#8594;</span> les gagnantes &#8594; celles qui seront sur une CRC card.</p>
                                        </li>
                                        <li>
                                            <p>Les classes <span class="html">non pertinentes</span> (irrelevant classes) <span class="em">&#8594;</span> les perdantes &#8594; celles qui sont hors sujet/intérêt.</p>
                                        </li>
                                        <li>
                                            <p>Les classes <span class="html">indécises</span> (undecided classes) <span class="em">&#8594;</span> les "peut-être" &#8594; qui peuvent réintégrer le système.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Placer les cartes sur la table :</p>
                            <ul>
                                <li>
                                    <p>La première carte placée est celle de l'acteur principal du cas d'utilisation.</p>
                                </li>
                                <li>
                                    <p>La seconde carte placée est celle du premier intervenant dans le scénario (celui qui reçoit le premier message).</p>
                                </li>
                                <li>
                                    <p>Conseils :</p>
                                    <ul>
                                        <li>
                                            <p>Ne jamais jeter des cartes, les mettre sur le côté... Un design initial très mauvais peut s'avérer être le meilleur plus tard.</p>
                                        </li>
                                        <li>
                                            <p>Varier les situations : en changeant les cartes sur table, en ajoutant des nouvelles cartes, en redistribuant les rôles dans l'équipe...</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Lire les scénarios et alternatives.</p>
                            <ul>
                                <li>
                                    <p>Lire les scénarios et alternatives.</p>
                                    <ul>
                                        <li>
                                            <p>En parcourant le scénario, on remplit les responsabilités des objets sur les cartes.</p>
                                        </li>
                                        <li>
                                            <p>Il faut éventuellement ajouter des nouvelles cartes ou renommer des responsabilités.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Concrètement :</p>
                                    <ul>
                                        <li>
                                            <p>Un lecteur parcourt le scénario.</p>
                                        </li>
                                        <li>
                                            <p>Les autres membres de l'équipe montrent les objets qui collaborent à la réalisation du scénario. [prise de note des responsabilités]</p>
                                        </li>
                                        <li>
                                            <p>Lorsqu'un objet en utilise un autre, ce dernier est appelé "collaborateur" du premier. [prise de note des collaborateurs d'un objet]</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h4>8.3. Exemple :</h4>
                    <p>Reprenons notre exemple SysMag pour lequel nous avions défini le diagramme des cas d'utilisation suivant :</p>
                    <figure>
                        <img src="../images/diagramme_sysmag_avec_relations.png" alt="">
                    </figure>
                    <p>Le résultat du jeu :</p>
                    <figure>
                        <img src="../images/resultat_jeu_sysmag_1.png" alt="">
                    </figure>
                    <figure>
                        <img src="../images/resultat_jeu_sysmag_2.png" alt="">
                    </figure>
                    <p>Ces cartes permettent la réalisation d'un premier diagramme de classes conceptuel :</p>
                    <figure>
                        <img src="../images/crc_diagramme_classes_conceptuel.jpg" alt="">
                        <figcaption>Figure 47 : CRC - diagramme de classes conceptuel</figcaption>
                    </figure>
                    <h4>8.4. Conclusion :</h4>
                    <p>Les CRC ne sont qu'une notation ! Les CRC n'apportent rien de plus si on ne les conçoit pas par le biais de jeu de rôles et de brainstorming influant sur le dynamissme/l'implication de l'équipe de développement.</p>
                    <p>Effectivement, souvent pour résoudre un problème, il suffit de le poser autrement !</p>
                    <figure>
                        <img src="../images/ancienne_legende_chinoise.jpg" alt="">
                        <figcaption>Figure 48 : ancienne légende chinoise</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="diagramme_objets">Chapitre 5 : Le diagramme d'objets :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Les <span class="html">diagramme d'objets</span> constituent des instanciations des diagrammes de classes. Ils montrent les objets et leurs relations. On y indique l'<span class="html">état des objets</span>; c'est-à-dire l'ensemble des valeurs de ses attributs. Pour rappel, un objet se compose d'un état et d'un comportement.</p>
                    <p>On les emploiera de temps en temps pour mieux comprendre un diagramme de classes, pour mettre en évidence la structure et le contexte.</p>
                    <p>Ci-dessous, on présente d'abord un diagramme de classes et ensuite un exemple de diagramme d'objets représentatnt l'état de certains objets de ce diagramme de classe.</p>
                    <figure>
                        <img src="../images/diagramme_classes_classe_Personne.jpg" alt="">
                        <figcaption>Figure 49 : le diagramme de classes - la classe Personne</figcaption>
                    </figure>
                    <figure>
                        <img src="../images/diagramme_objets_famille.png" alt="">
                        <figcaption>Figure 50 : le diagramme d'objets - une famille</figcaption>
                    </figure>
                    <h3>2. Notation :</h3>
                    <p>En UML, un objet est représenté par un rectangle dans lequel on fait figurer le nom de l'objet et/ou le nom de la classe. Ces noms sont toujours <span class="em">soulignés</span> et en <span class="em">miniscule</span>. Le nom de la classe est précédé d'un double point (:). Si le nom de l'objet est absent, on parle d'<span class="html">objet anonyme</span>. Le nom indiqué peut même être suivi du nom du package précédé de deux doubles points (::).</p>
                    <figure>
                        <img src="../images/diagramme_objets_notation_des_objets.png" alt="">
                        <figcaption>Figure 51 : le diagramme d'objets - notation des objets</figcaption>
                    </figure>
                    <p>Analysons les diverses notations ci-dessus partant de gauche vers la droite :</p>
                    <ol>
                        <li>
                            <p>La première manière n'est utilisée que si le design de la classe n'a pas encore été fait, donc tout au début du processus d'analyse.</p>
                        </li>
                        <li>
                            <p>L'objet <span class="em">qqn</span> est de type <span class="em">Personne</span>.</p>
                        </li>
                        <li>
                            <p>Il y a un objet anonyme de la classe <span class="em">Personne</span>.</p>
                        </li>
                        <li>
                            <p>Il y a un objet anonyme de la classe <span class="em">Personne</span> qui se trouve dans le package <span class="em">Domaine</span>.</p>
                        </li>
                    </ol>
                    <p>La valeur des attributs peut être indiquée dans le rectangle représentant l'objet. On utilisera pour ce faire un deuxième compartiment comme le montre les objets de la figure ci-dessus.</p>
                    <h3>3. Les liens entre objets :</h3>
                    <p>Les associations entre classes s'instancient en <span class="html">liens</span> reliant les objets. Si l'association de la classe A vers la classe B est multiple, l'objet de classe A sera relié à plusieurs objets de classe B.</p>
                    <figure>
                        <img src="../images/diagramme_objets_liens_entre_objets_1.jpg" alt="">
                        <figcaption>Figure 52 : le diagramme d'objets - les liens entre objets 1</figcaption>
                    </figure>
                    <p>Les <span class="em">liens</span> (instances d'une association) sont donc les relations entre objets (ou instances). Rappelons que les <span class="em">associations</span> permettent d'établir des relations entre classes. Un <span class="em">lien</span> est bien une connexion entre des instances d'objets. Une <span class="em">association</span> décrit un groupe de liens ayant un sens commun et c'est une connexion entre des classes d'objets.</p>
                    <p>On peut aussi utiliser une notation proche du diagramme de classe :</p>
                    <figure>
                        <img src="../images/diagramme_objets_liens_entre_objets_2.jpg" alt="">
                        <figcaption>Figure 53 : le diagramme d'objets - les liens entre objets 2</figcaption>
                    </figure>
                    <p>Les mêmes caractéristiques que celles des associations peuvent se retrouver sur un diagramme d'objet : agrégation, composition, rôles, navigation, qualification... Seule la multiplicité ne peut pas être utilisée, puisqu'elle donne lieu à autant de liens.</p>
                </article>
                <article>
                    <h2 id="diagramme_packages">Chapitre 6 : Le diagramme de packages :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Au fur et à mesure qu'un projet se développe, se repose l'éternelle question de le subdiviser en sous-systèmes de tailles raisonnables. L'idée est de regrouper des classes en unités de haut niveau. En UML, ces unités sont appelées <span class="html">packages</span>.</p>
                    <p>Le problème est de savoir comment regrouper les classes en packages. Malheureusement, il n'y a pas de solutions formelles miracles, tout au plus quelques conseils heuristiques.</p>
                    <h3>2. Les dépendances :</h3>
                    <p>Le concept le plus utile à ce propos est la notation de <span class="html">dépendance</span>. Une dépendance existe entre deux éléments si un changement fait à l'un implique de modifier l'autre. Ce dernier est alors dit dépendant du premier. Cette notation est générale et s'applique déjà au cas des classes.</p>
                    <p>Une classe peut dépendre d'une autre pour de multiples raisons :</p>
                    <ul>
                        <li>
                            <p>si elle envoie un message à l'autre</p>
                        </li>
                        <li>
                            <p>si elle possède un membre de l'autre classe</p>
                        </li>
                        <li>
                            <p>si une de ses opérations a pour paramètre un objet de l'autre classe ou renvoie un tel objet</p>
                        </li>
                        <li>
                            <p>...</p>
                        </li>
                    </ul>
                    <p>La dépendance d'une classe vis à vis d'une autre classe se résume au fait que si l'autre classe change son interface, la première classe doit être modifiée.</p>
                    <p>En UML, la dépendance  se note à l'aide d'une flèche pointillée.</p>
                    <h3>3. Graphiquement :</h3>
                    <p>Le diagramme de packages introduit une nouvelle notation :</p>
                    <figure>
                        <img src="../images/diagramme_packages_un_package.jpg" alt="">
                        <figcaption>Figure 54 : le diagramme de packages - un package</figcaption>
                    </figure>
                    <p>Voici un exemple de diagramme de packages :</p>
                    <figure>
                        <img src="../images/diagramme_packages_exemple.jpg" alt="">
                        <figcaption>Figure 55 : le diagramme de packages - exemple</figcaption>
                    </figure>
                    <h3>4. La conception des packages :</h3>
                    <p>Lorsqu'on conçoit des packages, on veille à <span class="html">minimiser les dépendances</span> existantes entre les classes situées dans différents packages. Il va de soi qu'il n'est pas possible de les éliminer totalement sinon on aurait affaire à deux applications et non une seule. En réalité, on essaye de faire en sorte qu'un package soit dépendant d'un minimum de packages, afin que des modifications faites dans les interfaces des classes d'un package ait des répercutions sur le moins de packages possibles.</p>
                    <p>La principale raison qui rend ceci faisable, est la constation du fait que les dépendances ne sont <span class="html">pas transitives</span>; si une classe A dépend d'une classe B qui dépend de la classe C, des changements à l'interface de C provoqueront des modifications à l'implémentation de B, pas à son interface, ce qui arrête la propagation du mal.</p>
                    <p>Cette non-transitivité peut être renforcée par la <span class="html">visibilité</span> gérée par le langage de programmation utilisé. Ainsi le langage Java propose une visibilité limitée au package importé et ce de manière non transitive, contrairement au mécanisme des <span class="html">includes</span> en C++. De plus certaines classes du package, peuvent être marquée de manière à en limiter la visibilité aux classes de ce package et à ne pas pouvoir être importées.</p>
                    <p>On essayera <span class="html">d'éviter les cycles de dépendances</span>, mais ce n'est pas toujours possible. Dans un tel cas on aura intérêt à regrouper un tel cycle à l'intérieur d'un package conteneur.</p>
                    <p>On pourra encore limiter les dépendances en réduisant l'interface du package par l'exportation d'un nombre minimal d'opérations. Ceci peut se faire en créant une ou plusieurs nouvelles classes dans le package. Ces classes regrouperont toutes les opérations qu'on pourra importer et seront les seules classes publiques (importables) du package.</p>
                    <p>De telles classes sont appelées <span class="html">Façades</span>.</p>
                    <figure>
                        <img src="../images/diagramme_packages_pattern_facade.jpg" alt="">
                        <figcaption>Figure 56 : le diagramme de packages - le pattern façade</figcaption>
                    </figure>
                    <h3>5. Les autres possibilités :</h3>
                    <p>UML permet de montrer le <span class="html">contenu</span> d'un package en dessinant une icône pour chaque classe qu'il contient, en y incluant un diagramme de classe ou un diagramme de package, s'il s'agit d'un package conteneur.</p>
                    <p>UML définit aussi des <span class="html">généralisations</span> pour les packages : les packages spécifiques doivent se conformer à l'interface fourni par le package général. Ce dernier pourra être marqué <span class="html">{abstrait}</span>, comme pour les classes.</p>
                    <p>De même, un package pourra être marqué <span class="html">{global}</span> pour indiquer que tous les autres packages dépendnat de lui, sans avoir à dessiner toutes ces dépendances. Ceci permet d'alléger le dessin.</p>
                    <p>L'exemple ci-dessous illustre ces notations.</p>
                    <figure>
                        <img src="../images/diagramme_packages_notations_abstrait_global.jpg" alt="">
                        <figcaption>Figure 57 : le diagramme de packages - les notations{abstrait} et {global}</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="diagramme_activites">Chapitre 7 : Le diagramme d'activités :</h2>
                    <h3>1. Introduction :</h3>
                    <p class="html">Modéliser les activités d'un système consiste à décrire son exécution et à identifier les comportements successifs de celui-ci, sans s'intéresser à sa structure.</p>
                    <p>Si les diagrammes d'interactions mettent l'accent sur les objets qui échangent des messages et mènent à bonne fin des activités, les diagrammes d'activités, au contraire, insistent sur les activités se déroulant dans le temps.</p>
                    <p>Les diagrammes d'activités offrent une vue graphique aidant à la validation des exigences du client.</p>
                    <p>Ils permettent de modéliser :</p>
                    <ul>
                        <li>
                            <p>Des processus (à tous niveaux)</p>
                        </li>
                        <li>
                            <p>Les comportements des cas d'utilisation</p>
                        </li>
                        <li>
                            <p>Les comportements des classes (méthodes, ...)</p>
                        </li>
                    </ul>
                    <p>Dans la phase de conception, les diagrammes d'activités sont particulièrement adaptés à la description des cas d'utilisation. Plus précisément, ils viennent illustrer et consolider la description textuelle des cas d'utilisation.</p>
                    <h3>2. Les concepts :</h3>
                    <h4>2.1. L'activité :</h4>
                    <p>Les <span class="html">activités</span> sont des comportements avec au moins une action interne et au moins une transition sortante se déclenchant lors de la complétion de l'action. Les activités n'ont ni transitions internes ni transition sortantes déclenchées par un évènement extérieur.</p>
                    <p>On les représente par un rectangle arrondi sur les côtés et droit en bas et en haut. <img src="../images/une_activite.jpg" alt=""></p>
                    <h4>2.2. Le noeud initial et le noeud final :</h4>
                    <p>Un noeud initial est un noeud de contrôle à partir duquel le flot débute lorsque l'activité enveloppante est invoquée. Une activité peut avoir plusieurs noeuds initiaux. Un noeud initial possède un arc sortant et pas d'arc entrant.</p>
                    <p>Graphiquement, un noeud initial est représenté par un petit cercle plein : <img src="../images/noeud_initial.png" alt="">.</p>
                    <p>Un noeud final est un noeud de contrôle possédant une ou plusieurs arcs entrants et aucun arc sortant.</p>
                    <p>Un noeud final est représenté par un petit cercle plein entouré d'un autre cercle : <img src="../images/noeud_final.jpg" alt="">.</p>
                    <p>Il peut y avoir plusieurs noeuds finaux; il faut alors spécifier s'il s'agit d'un état final avec succès ou échec.</p>
                    <p>Le passage d'une activité vers une autre est matérialisé par une <span class="html">transition</span>.</p>
                    <figure>
                        <img src="../images/diagramme_activites_transition.jpg" alt="">
                        <figcaption>Figure 58 : le diagramme d'activités - transition</figcaption>
                    </figure>
                    <h4>2.4. La condition de garde :</h4>
                    <p>Une <span class="html">condition de garde</span> représente une condition de transition pour passer d'une activité à l'autre.</p>
                    <figure>
                        <img src="../images/diagramme_activites_condition_de_garde.png" alt="">
                        <figcaption>Figure 59 : le diagramme d'activités - condition de garde</figcaption>
                    </figure>
                    <h4>2.5. La décision :</h4>
                    <p>Les <span class="html">décisions</span> sont employées quand des conditions de gardes sont utilisées pour indiquer différentes transitions possibles. Elles sont représentées par un losange avec une seule transition entrante et au moins deux transitions sortantes. Ces dernières doivent être labélisées par des conditions de gardes mutuellement exclusives.</p>
                    <figure>
                        <img src="../images/diagramme_activites_decision.jpg" alt="">
                        <figcaption>Figure 60 : le diagramme d'activités - décision</figcaption>
                    </figure>
                    <p>On place une décision dans un diagramme lorsque le choix ne relève pas directement de l'activité précédente. Sinon, on peut se contenter de marquer les possibilité dans des conditions sur les transitions comme dans l'illustration qui suit.</p>
                    <figure>
                        <img src="../images/diagramme_activites_sans_decision.jpg" alt="">
                        <figcaption>Figure 61 : le diagramme d'activités - sans décision</figcaption>
                    </figure>
                    <h4>2.6. La barre de synchronisation :</h4>
                    <p>Les <span class="html">barres de synchronisation</span>, représentées par une barre horizontale épaisse, indiquent que les transitions sortantes conduisent à des activités pouvant se dérouler en parallèle, et que les transitions entrantes doivent se synchroniser avant de continuer le flot d'activité. Les activités se déroulant en parallèle peuvent en réalité être exécutée dans n'importe quel ordre et même en alternance.</p>
                    <p>Les barres de synchronisations permettent de décrire des :</p>
                    <ul>
                        <li>
                            <p><span class="html">Transitions sortantes</span> : activités pouvant débuter en parallèle. On parle de synchronisation disjonctive :</p>
                            <figure>
                                <img src="../images/diagramme_activites_transition_sortante.jpg" alt="">
                                <figcaption>Figure 62 : le diagramme d'activités - transition sortante</figcaption>
                            </figure>
                            <p>Les activités "uneActivité" et "uneAutreActivité" doivent être achevées avant de débuter "encoreUneAutreActivités".</p>
                            <p>Exemple :</p>
                            <figure>
                                <img src="../images/diagramme_activites_transitions_entrantes_exemple.jpg" alt="">
                                <figcaption>Figure 65 : le diagramme d'activités - transitions entrantes, exemple</figcaption>
                            </figure>
                            <p>Pour passer un examen, un étudiant doit impérativement avoir entièrement payé son minerval et être inscrit.</p>
                        </li>
                        <li>
                            <p><span class="html">Activités parallèles</span> : exécutées dans n'immporte quel ordre et même en alternance :</p>
                            <figure>
                                <img src="../images/diagramme_activites_activites_paralleles.jpg" alt="">
                                <figcaption>Fugure 66 : le diagramme d'activités - activités parallèles</figcaption>
                            </figure>
                            <p>Les activités "uneAutreActivité" et "encoreUneAutreActivité" doivent débuter lorsque l'activité "uneActivité" est terminée. L'activité "encoreUneDernièreActivité" ne peut commencer que si "uneAutreActivité" et "encoreUneAutreActivité" sont terminées toutes les deux.</p>
                            <p>Les activités parallèles ne doivent pas nécessairement se dérouler en même temps. Le parallélisme signifie seuelement que l'ordre dans lequel les activités parallèles sont réalisées importe peu.</p>
                            <p>Exemple :</p>
                            <figure>
                                <img src="../images/diagramme_activites_activites_paralleles_exemple.jpg" alt="">
                                <figcaption>Figure 67 : le diagramme d'activités parallèles, exemple</figcaption>
                            </figure>
                            <p>Lorsqu'on reçoit  une reçoit une livraison, il faut à la fois effectuer un contrôle de la quantité commandée et un contrôle de la qualité des produits avant de l'enregistrer. Peu importe que le contrôle quantité soit effectué avant ou après le contrôle qualité mais il faut impérativement que ces deux contrôles soient achevés avant d'enregistrer la livraison.</p>
                        </li>
                    </ul>
                    <h4>2.7. L'itération :</h4>
                    <p>On peut marquer l'<span class="html">itération</span> d'une activité. Pour marquer la répétition, on dessine une barre de synchronisation qu'on annote avec un itérateur (pour i allant de 1 à n, tant que telle condition, ...).</p>
                    <p>L'itération se poursuit tant qu'il n'y a pas de barre de synchronisation.</p>
                    <figure>
                        <img src="../images/diagramme_activites_iteration_1.PNG" alt="">
                        <figcaption>Figure 68 : le diagramme d'activités - l'itération 1</figcaption>
                    </figure>
                    <p>Dans le diagramme ci-dessus, on doit réaliser N fois "uneActivité" avant de débuter "uneActivitéAprèsItération".</p>
                    <p>Les activités "uneActivitéAvantItération" et "uneActivitéAprèsItération" sont réalisées une seule fois.</p>
                    <p>Exemples :</p>
                    <figure>
                        <img src="../images/diagramme_activites_iteration_exemples.jpg" alt="">
                        <figcaption>Figure 69 : le diagramme d'activités - itération, exemples</figcaption>
                    </figure>
                    <p>Dans le diagramme de gauche ci-dessus, lorsqu'on reçoit une commande, on vérifie la présence de chaque article de la commande dans le stock. Lorsque toutes les vérifications (pour tous les articles de commande) sont terminées, on peut préparer les articles pour la livraison au client.</p>
                    <p>Tandis que dans le diagramme de droite, on prépare chaque article dès que la vérification de cet article est terminée.</p>
                    <h4>2.8. Le noeud de fusion (merge node en anglais) :</h4>
                    <p>Dans le premier diagramme ci-dessous, A1 ET A2 doivent être terminés pour que B puisse commencer. Ce premier diagramme est en fait, équivalent au second.</p>
                    <figure>
                        <img src="../images/diagramme_activites_utilisation_barre_synchronisation.png" alt="">
                        <figcaption>Figure 70 : le diagramme d'activités - utilisation de la barre de synchronisation</figcaption>
                    </figure>
                    <p>La représentation suivante est donc erronée :</p>
                    <figure>
                        <img src="../images/diagramme_activites_decision_erronee.PNG" alt="">
                        <figcaption>Figure 71 : le diagramme d'activités - décision erronée</figcaption>
                    </figure>
                    <p>A1 et A2 devraient avoir été exécutés tous les deux pour que B puisse commencer. Cependant, A1 est exécuté lorsque la condition est vraie et A2 lorqu'elle est fausse. Ils ne seront donc jamais exécutés en parallèle.</p>
                    <p>Les <span class="html">noeuds de fusion</span> permettent d'éviter le problème rencontré ci-dessous.</p>
                    <p>Un noeud de fusion est un noeud qui rassemble plusieurs transitions entrantes en une seule transition sortante.</p>
                    <figure>
                        <img src="" alt="">
                        <figcaption>Figure 72 : Le diagramme d'activité - noeud de fusion</figcaption>
                    </figure>
                    <p>Cela permet d'exécuter B, que ce soit A1 ou A2 qui ait été précédemment exécuté.</p>
                    <p>Les noeuds de fusion doivent également être utilisés dans les cas suivants :</p>
                    <ul>
                        <li>
                            <p>Intération après un noeud de décision</p>
                        </li>
                        <li>
                            <p>Barre de synchronisation après un noeud de décision</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/diagramme_activites_utilisation_noeuds_fusion.PNG" alt="">
                        <figcaption>Figure 73 : Le diagramme d'activités - utilisation des noeuds de fusion</figcaption>
                    </figure>
                    <p>On voudrait exprimer :</p>
                    <ul>
                        <li>
                            <p>Trois activités X1, X2 et X4 doivent être exécutées avant qu'"activité suivante" ne puisse débuter</p>
                        </li>
                        <li>
                            <p>X1 et X2 peuvent être exécutées dans n'omporte quel ordre</p>
                        </li>
                        <li>
                            <p>X4 peut débuter dès que X1 ou X2 est terminée</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/diagramme_activites_utilisation_noeuds_fusion_2.png" alt="">
                        <figcaption>Figure 74 : Le diagramme d'activités - utilisation des noeuds de fusion</figcaption>
                    </figure>
                    <h3>3. Les partitions :</h3>
                    <p>Les <span class="html">partitions</span>, souvent appelées <span class="html">couloirs</span> ou lignes d'eau (<span class="em">swim lane</span>) du fait de leur notation, permettent d'organiser les noeuds d'activités dans un diagramme d'activités en opérant des regroupements.</p>
                    <p>Les partitions n'ont pas de signification bien arrêtée, mais correspondent souvent à des unités d'organisation du modèle. On peut, par exemple, les utiliser pour spécifier la classe responsable de la mise en oeuvre d'un ensemble de tâches. Dans ce cas, la classe en question est responsable de l'implémentation du comportement des noeuds inclus dans ladite partition. Les couloirs partitionnent le système entre les différents acteurs, classes, ...</p>
                    <p>Graphiquement, les partitions sont délimitées par des lignes discontinues. Il s'agit généralement de lignes verticales, mais elles peuvent être horizontales ou mêmes courbes.</p>
                    <figure>
                        <img src="../images/diagramme_activites_partition_exemple.jpg" alt="">
                        <figcaption>Figure 75 : le diagramme d'activités - partition, exemple</figcaption>
                    </figure>
                    <h3>4. Informations supplémentaires :</h3>
                    <p>Il est même possible d'identifier les objets principaux, qui sont manipulés d'activités en activités et de visualiser leur changement d'état. Par exemple, dans le diagramme ci-après, la commande passe dans deux états (passée et facturée) suite à certaines activités du fournisseur.</p>
                    <figure>
                        <img src="../images/diagramme_activites_informations_supplementaires.jpg" alt="">
                        <figcaption>Figure 76 : le diagramme d'activités - informations supplémentaires</figcaption>
                    </figure>
                    <h3>5. Conclusion :</h3>
                    <p>Le diagramme d'activités est difficile à réaliser vu le côté parallélisme mais sa grande <span class="em">force</span> est cette aptitude à supporter et à encourager les comportements parallèles.</p>
                    <p>Les diagrammes d'activités sont très utiles pour :</p>
                    <ul>
                        <li>
                            <p>analyser un cas d'utilisation; à ce stade les objets n'ont pas encore été clairement précisés.</p>
                        </li>
                        <li>
                            <p>comprendre le flux d'activité à travers plusieurs cas d'utilisation et montrer comment ceux-ci réagissent entre eux.</p>
                        </li>
                        <li>
                            <p>traiter des applications multi-threads vu leur côté concurrent.</p>
                        </li>
                    </ul>
                    <p>Par contre on ne les utilisera pas si on désire :</p>
                    <ul>
                        <li>
                            <p>voir comment les objets collaborent entre eux : on utilisera un diagramme d'interactions.</p>
                        </li>
                        <li>
                            <p>voir le comportement d'un objet tout au long de sa vie : on emploiera un diagramme d'états-transitions.</p>
                        </li>
                    </ul>
                    <p>En effet, leur principale <span class="em">faiblesse</span> est de ne pas montrer clairement les liens entre objets et actions. Même l'usage de couloirs n'a pas l'aspect immédiat qu'on trouve dans un diagramme d'interactions.</p>
                </article>
                <article>
                    <h2 id="diagramme_interactions">Chapitre 8 : Le diagramme d'interactions :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Les <span class="html">diagrammes d'interactions</span> sont utilisés pour décrire les modalités de communication entre les objets d'une application. Ils se focalisent sur les messages spécifiques échangés par les objets, et sur la façon dont ces messages concourent à la réalisation de fonctionnalités.</p>
                    <p>Les diagrammes d'interactions montrent comment les groupes d'objets collaborent au sein d'un comportement. Généralement, on y représente le comportement se rapportant à <span class="html">un seul cas d'utilisation</span>.</p>
                    <p>Effectivement, les diagrammes d'interactions ont pour but de décrire <span class="em">l'évolution du système</span> dans une <span class="em">utilisation particulière</span>.</p>
                    <ul>
                        <li>
                            <p><span class="em">Évolution du système</span> : c'est-à-dire comment les objets interagissent via des messages.</p>
                        </li>
                        <li>
                            <p><span class="em">Utilisation particulière</span> : cela signifie une présentation partielle, non l'entièreté du système.</p>
                        </li>
                    </ul>
                    <p>À un niveau conceptuel, on utilise également les diagrammes d'interactions pour décrire les modalités de communication dans un processus ou une organisation.</p>
                    <p>Nous abordons dans le cadre de ce cours 2 types de diagrammes d'interactions :</p>
                    <ul>
                        <li>
                            <p>Diagramme de <span class="html">séquence</span></p>
                        </li>
                        <li>
                            <p>Diagramme de <span class="html">communication</span></p>
                        </li>
                    </ul>
                    <p>Les diagrammes d'interactions sont des diagrammes concernant les <span class="html">objets</span> et non les classes : ils montrent les <span class="html">messages</span> qui sont envoyés d'un objet à un autre. Il est parfois utile de dessiner des diagrammes d'interactions où on représente des classes, voire même des packages ou des composants. Il doit être bien clair, dans ce cas, qu'en réalité, l'envoyeur et le receveur sont des instances de ces classes, des objets d'une classe du package ou du composant. Les chemins par lesquels les messages seront envoyés sont les liens entre objets, les associations et les dépendances.</p>
                    <p>Les <span class="html">diagrammes de séquence</span> représentent une interaction de manière chronologique mais ne montrent pas les associations entre les objets. Ils sont utiles en programmation en temps réel ou pour des interactions complexes.</p>
                    <p>Les <span class="html">diagrammes de communication</span> montrent les associations existantes entre objets et sont préférables pour comprendre les effets de l'interaction dans son contexte.</p>
                    <h3>2. Le diagramme de séquence :</h3>
                    <h4>2.1. Les lignes de vie :</h4>
                    <p>Un diagramme de séquence a deux dimensions :</p>
                    <ul>
                        <li>
                            <p>la dimension verticale représente le <span class="html">temps</span>. Le temps s'écoule vers le bas de la page; il se lit de haut en bas.</p>
                        </li>
                        <li>
                            <p>la dimension horizontale représente les différents <span class="html">objets</span>.</p>
                        </li>
                    </ul>
                    <p>Chaque objet est représenté dans un rectangle situé, le plus souvent, au sommet du diagramme. Sous ces objets, on dessine une ligne verticale pointillée, représentant l'écoulement du temps pour cet objet : c'est la <span class="html">ligne de vie</span> de l'objet.</p>
                    <p>On peut décider de <span class="html">nommer</span> les objets.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_objets.jpg" alt="">
                        <figcaption>Figure 77 : le diagramme de séquence - les objets</figcaption>
                    </figure>
                    <h4>2.2. Les messages :</h4>
                    <p>Les messages sont représentés à l'aide de flèches. Ils sont surmontés d'un court texte précisant de quel message il s'agit.</p>
                    <p>Au niveau <span class="html">conceptuel</span>, les messages représentent des actions effectuées dans le cadre du cas d'utilisation étudié.</p>
                    <p>Au niveau <span class="html">spécification</span>, ils ont une signification informatique et correspondent à des appels de méthodes, des évènements, des signaux, des interruptions.</p>
                    <ul>
                        <li>
                            <p>Pour un message <span class="html">synchrone (appel)</span>, l'envoyeur sera bloqué en attendant la fin du traitement du message par le receveur. En UML 2, l'appel est représenté par une flèche pleine dirigée vers le destinaire : <span class="em">&#8594;</span>.</p>
                            <p>Nous utiliserons également la flèche standard :</p>
                            <figure>
                                <img src="../images/diagramme_sequence_appel.jpg" alt="">
                                <figcaption>Figure 78 : le diagramme de séquence - l'appel</figcaption>
                            </figure>
                            <p>Si le message est <span class="html">asynchrone (signal)</span>, l'envoyeur continuera son exécution sans attendre. En UML 2, le signal est représenté par une flèche standard vers le destinataire.</p>
                        </li>
                    </ul>
                    <p>Nous préférons utiliser la <span class="html">demi-flèche</span> pour représenter les signaux asynchrones :</p>
                    <figure>
                        <img src="../images/diagramme_sequence_signal.jpg" alt="">
                        <figcaption>Figure 79 : le diagramme de séquence - le signal</figcaption>
                    </figure>
                    <p>Si on désire montrer que les délais de transmissions sont longs, on pourra représenter le message obliquement :</p>
                    <figure>
                        <img src="../images/diagramme_sequence_delai_transmission.jpg" alt="">
                        <figcaption>Figure 80 : le diagramme de séquence - le délai de transmission</figcaption>
                    </figure>
                    <h4>2.3. Les activations :</h4>
                    <p>On peut montrer explicitement durant quelle période de temps un objet exécute une action en indiquant une <span class="html">barre d'activation</span> (représentée par une fin rectangle) sur la ligne de vie de l'objet.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_barre_activation.jpg" alt="">
                        <figcaption>Figure 81 : le diagramme de séquence - la barre d'activation</figcaption>
                    </figure>
                    <h4>2.4. La création et la destruction d'objet :</h4>
                    <figure>
                        <img src="../images/diagramme_sequence_creation_destruction_objet.jpg" alt="">
                        <figcaption>Figure 82 : le diagramme de séquence - création et destruction d'objet</figcaption>
                    </figure>
                    <p>Si un objet est créé durant l'interaction, on le représentera par une flèche (un message) pointant sur l'objet et par l'indication "new". Si en cours d'interaction, un objet est détruit, on marque la fin de sa ligne de vie d'une croix. L'objet peut être détruit parce qu'il termine sa vie normalement ou parce qu'un autre objet a provoqué sa destruction par l'envoi d'un message approprié.</p>
                    <h4>2.5. Les retours d'exécution :</h4>
                    <p>Les retours d'exécution d'une action "return" peuvent être indiqués. S'ils le sont, ce sera au moyen d'une flèche inverse pointillée.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_return_explicite.jpg" alt="">
                        <figcaption>Figure 83 : le diagramme de séquence - return explicite</figcaption>
                    </figure>
                    <p>Le "return" peut être <span class="html">explicite</span> (c'est-à-dire représenté dans le schéma) ou <span class="html">implicite</span> (c'est-à-dire non représenté graphiquement).</p>
                    <p>Si le "return" est implicite, la valeur renvoyée peut être éventuellement indiquée par une petite flèche inverse, accompagnant le message aller. Sinon, on n'indique rien sur le diagramme.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_return_implicite.jpg" alt="">
                        <figcaption>Figure 84 : le diagramme de séquence - return implicite</figcaption>
                    </figure>
                    <h4>2.6. Les appels récursifs :</h4>
                    <p>Un objet peut s'envoyer un message à lui-même. Un tel message se représentera par une flèche bouclant sur la ligne de vie de l'objet : on parle d'<span class="html">auto-délégation</span> ou de message réflexif. Cela représente un appel récursif.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_appel_recursif.jpg" alt="">
                        <figcaption>Figure 85 : le diagramme de séquence - appel récursif</figcaption>
                    </figure>
                    <p>Si on veut insister sur le côté récursif d'une auto-délégation, on conseille l'usage des barres d'activations. Dans ce cas, on indique un second rectangle superposé au premier.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_appel_recursif_avec_barres_activation.jpg" alt="">
                        <figcaption>Figure 86 : le diagramme de séquence - appel récursif avec barres d'activation</figcaption>
                    </figure>
                    <h4>2.7. Les structures de contrôle :</h4>
                    <p>UML donne la possibilité d'indiquer des structures de contrôle sur un diagramme de séquence. Ces structures sont essentiellement le branchement, l'itération et le parallélisme.</p>
                    <h5>2.7.1. Le branchement :</h5>
                    <p>Un <span class="html">branchement</span> surviendra dans un diagramme pour représenter une <span class="html">alternative</span>.</p>
                    <p>Les messages de branchement partent tous du même point de la ligne de vie de l'objet et sont marqués d'une condition de garde entre crochets.</p>
                    <p>Selon que ces conditions sont mutuellement exclusives ou non, on aura une alterntaive ou un parallélisme.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_alternative.png" alt="">
                        <figcaption>Figure 87 : le diagramme de séquence - l'alternative</figcaption>
                    </figure>
                    <h5>2.7.2. L'itération :</h5>
                    <p>Si un groupe de message doit être envoyé itérativement on entourera ce groupe d'indications d'itération.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_iteration_bloc.png" alt="">
                        <figcaption>Figure 88 : le diagramme de séquence - l'itération (bloc)</figcaption>
                    </figure>
                    <h5>2.7.3. Le parallélisme :</h5>
                    <p>Dans un diagramme de séquence, il est possible de représenter des opérations parallèles. Le parallélisme signifie que l'ordre dans lequel les deux opérations parrallèles sont effectuées importe peu.</p>
                    <figure>
                        <img src="../images/uml_java_parallelisme.jpg" alt="">
                        <figcaption>Figure 89 : le diagramme de séquence - le parallélisme</figcaption>
                    </figure>
                    <p>Dans l'exemple ci-dessus, lorsqu'un client retire de l'argent à un automate, il demande (après introduction de la carte et du code) un certain montant à retirer (X). À la fin de sa transaction, il reçoit les billets et son ticket. Le parallélisme signifie que l'ordre dans lequel il reçoit le billet et le ticket n'est pas déterminé : soit le client reçoit d'abord les billets puis le ticket, soit l'inverse ou encore les deux en même temps.</p>
                    <h4>2.8. La marge de gauche :</h4>
                    <p>La marge de gauche peut être utilisée pour des descriptions textuelles de ce qui est fait, mais aussi pour des indications de timing. Ces dernières sont génralement placées entre accolades.</p>
                    <figure>
                        <img src="../images/diagramme_sequence_marge_gauche.jpg" alt="">
                        <figcaption>Figure 90 : le diagramme de séquence - la marge de gauche</figcaption>
                    </figure>
                    <h4>2.9. Système en boîte noire :</h4>
                    <p>Il existe deux manières de représenter le système dans les diagrammes de séquence :</p>
                    <ul>
                        <li>
                            <p>On présente le système comme une <span class="em">boîte noire</span> : le système est représenté dans un seul objet. Il est considéré comme un tout unique et n'est pas décomposé en objets.</p>
                        </li>
                        <li>
                            <p>On représente le système par ses diverses composantes. Les interactions entre les objets du système sont donc dévoilées.</p>
                        </li>
                    </ul>
                    <p>On conçoit des diagrammes de séquences à différents moments du cycle de vie du projet informatique. Les diagrammes de séquence sont plus ou moins détaillés selon les objectifs qu'on se fixe.</p>
                    <p>En début de projet, on peut représenter les scénarios des cas d'utilisation sous forme graphique grâce aux diagrammes de séquence ou encore aux diagrammes d'activités afin de montrer les interactions des utilisateurs avec le système. À ce stade, le système est considéré comme une boîte noire; il est vu comme un tout unique (une seule ligne de vie). On parle de <span class="html">diagramme de séquence système</span>.</p>
                    <p>En cours de projet, on réalise souvent des diagrammes de séquence pour détailler les interactions entre les différentes classes, objets, acteurs,... Lorsqu'on a déjà procédé à l'analyse statique du système et qu'on connaît alors les classes qui le composent, on représente alors celles qui interviennent dans les scénarios d'utilisation. Le diagramme de séquence permet, donc, à ce stade, de montrer les interactions (appels de méthodes par exemple) entre les composants du système. Le système est alors représenté par différentes lignes de vie correspondant aux composants qui le composent.</p>
                    <h3>3. Le diagramme de communication :</h3>
                    <h4>3.1. Introduction :</h4>
                    <p>Un <span class="html">diagramme de communication</span> (en UML 1, on parle de diagramme de collaboration) représente les objets participant à une interaction en indiquant les relations existant entre eux et les messages envoyés. Un tel diagramme se présente donc comme un fragment d'un immense diagramme qui indiquerait les relations entre tous les objets.</p>
                    <p>L'ensemble d'objets reliés entre eux s'appelle une <span class="html">collaboration</span>. L'<span class="html">interaction</span> est l'ensemble des messages échangés.</p>
                    <p>La présentation des objets sur le diagramme est une présentation spatiale, comme sur une diagramme de classes ou d'objets, ce qui permet d'indiquer les liens existant entre objets. Le côté temporel passe ainsi au second plan. Pour indiquer l'ordre des messages, ceux-ci seront numérotés.</p>
                    <h4>3.2. La numérotation :</h4>
                    <p>Plusieurs schémas de numérotations sont utilisés pour réfléter les aspects temporels des communications :</p>
                    <ul>
                        <li>
                            <p><span class="html">Numérotation simple</span> : 1, 2, 3</p>
                            <ul>
                                <li>
                                    <p>Les messages sont numérotés à partir de 1 dans l'ordre chronologique de l'envoi. Cette numérotation était utilisée par beaucoup de gens.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="html">Numérotation imbriquée</span> : 1, 1.1, 1.2, 1.2.1</p>
                            <ul>
                                <li>
                                    <p>UML préconise la <span class="html">numérotation par niveaux</span> : si une opération en appelle d'autres, on reprend le numéro de l'opération appelante et on ajoute un niveau. Pour ce niveau, on recommence à numéroter à partir de 1 les diverses opérations appelées, en comptant dans l'ordre des appels.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="html">Numérotation imbriquée et concurrente</span> : 1, 1.1a, 1.1b</p>
                            <ul>
                                <li>
                                    <p>Idem numérotation imbriquée mais les ponts 1.1a et 1.1b peuvent être effectués en parallèle.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/diagramme_communication_exemple_1.jpg" alt="">
                        <figcaption>Figure 91 : le diagramme de communication - exemple 1</figcaption>
                    </figure>
                    <h4>3.3. Les messages :</h4>
                    <h5>3.3.1. Synchrone - asynchrone :</h5>
                    <p>Les messages peuvent être <span class="html">synchrones</span> ou <span class="html">asynchrones</span> et se représentent comme dans les diagrammes de séquence.</p>
                    <h5>3.3.2. Syntaxe des messages :</h5>
                    <p>Il existe une syntaxe particulière aux messages dans les diagrammes de communication. Dans le cadre de ce cours, nous ne l'aborderons pas. Nous nous contentons d'indiquer les messages comme dans les diagrammes de séquence (avec la numérotation vu précédemment en plus).</p>
                    <h4>3.4. Le return :</h4>
                    <p>Un return a lieu dans un diagramme de communication quand toutes les activations emboîtées sont terminées. La valeur de retour renvoyée peut être indiquée avec le numéro du message (voir plus haut, la numérotation des messages).</p>
                    <p>Une autre manière est de dessiner une flèche inverse le long du lien.</p>
                    <figure>
                        <img src="../images/diagramme_communication_return.jpg" alt="">
                        <figcaption>Figure 92 : le diagramme de communication - return</figcaption>
                    </figure>
                    <h4>Les acteurs :</h4>
                    <p>UML permet la représentation sur le diagramme d'acteurs initiant une communication. Ceux-ci sont représentés de la même façon que dans les diagrammes des cas d'utilisation avec un "stick man".</p>
                    <figure>
                        <img src="../images/diagramme_communication_avec_acteur.jpg" alt="">
                        <figcaption>Figure 93 : le diagramme de communication - avec acteur</figcaption>
                    </figure>
                    <h4>3.6. Conseils :</h4>
                    <p>Les diagrammes de communication deviennent vite surchargés. Comment faire pour l'éviter ?</p>
                    <p>On pourra tenir compte des conseils qui suivent :</p>
                    <ul>
                        <li>
                            <p><span class="em">Règle 1</span> : Utiliser une même flèche pour tous les messages de même direction entre les deux mêmes objets.</p>
                        </li>
                        <li>
                            <p><span class="em">Règle 2</span> : Ne pas utiliser de flèches du tout. Indiquer les navigations sur le diagramme. Si un lien est bidirectionnel (c'est-à-dire si des messages circulent dans les deux sens sur ce lien), on indiquera deux liens unidirectionnels. Quant aux messages asynchrones, on les marquera de la contrainte {asynchrone}. Cette deuxième règle est surtout utile quand il n'y a pas trop de messages asynchrones, ni trop de synchronisations.</p>
                        </li>
                    </ul>
                    <h3>4. Comparaison entre diagrammes de séquence et diagrammes de communication :</h3>
                    <p>Les diagrammes de séquence mettent l'accent sur le côté temporel, chronologique de l'interaction. Par contre, on n'y voit pas comment les objets sont reliés statiquement.</p>
                    Inversement, les diagrammes de communication indiquent clairement les liens statiques existant entre les objets. Par contre, suivre le déroulement chronologique de l'interaction relève vite du tour de force.
                    <h3>5. Conclusion :</h3>
                    Les diagrammes d'interactions ont pour principal avantage, la simplicité. Sur un diagramme clair, on voit bien les messages qui sont envoyés. Toutefois, représenter plus q'un processus séquentiel simple sans trop de branchements ni d'itérations conduit à des diagrammes trop complexes.
                    <p>Un diagramme d'interactions permet de voir le comportement de plusieurs objets au sein d'un même cas d'utilisation. On peut alors songer à créer plusieurs diagrammes, un par scénario, et éviter ainsi les branchements.</p>
                    <p>Si on désire capturer un comportement compliqué dans un seul diagramme, on préférera un diagramme d'activité.</p>
                    <p>Si on désire voir le comportement d'un même objet au sein de plusieurs cas d'utilisation, on dessinera un diagramme d'états - transitions.</p>
                    <p>Si on désire étudier le comportement de plusieurs objets au sein de plusieurs cas d'utilisation, on se tournera vers un diagramme d'activité.</p>
                    <p>La seule vraie raison d'utiliser un diagramme d'interactions est dès lors sa simplicité.</p>
                </article>
                <article>
                    <h2 id="diagramme_etats">Chapitre 9 : Le diagramme d'états :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Les <span class="html">diagrammes d'états - transitions</span> (State diagrams) retenus par UML sont issus des Statecharts de Harel. Ils furent utilisés pour la première fois dans un contexte orienté objet par OMT, puis furent adoptés par Grady Booch avant d'être repris dans UML.</p>
                    <p>Beaucoup de classes ont un comportement tel que leur état varie dans le temps. Si c'est le cas on aura intérêt à représenter sur un diagramme d'états - transitions, l'évolution d'un objet de la classe dans le temps.</p>
                    <p>Ainsi, un feu de circulation sera rouge, jaune ou vert, un ascenseur, en montée, en descente, en attente ou hors d'usage...</p>
                    <p>Les diagrammes d'états - transitions étudient le <span class="html">comportement d'un objet</span> dans toute sa vie, donc au sein de plusieurs cas d'utilisation.</p>
                    <h3>2. Les notations :</h3>
                    <h4>2.1. Les états :</h4>
                    <p>Les <span class="html">états</span> modélisent un moment spécifique du comportement d'une classe. Cet instant est défini par une certaine condition qui doit être satisfaite par le classificateur.</p>
                    <p>Ceux-ci sont représentés par un rectangle arrondi contenant le nom de l'état. <img src="../images/etat.jpg" alt=""></p>
                    <p>Deux états particuliers ont une notation différente : l'état initial est représenté par un gros point noir. <img src="../images/etat_particulier.png" alt=""></p>
                    <p>Tandis que l'état final sera représenté par un même point noir encerclé : <img src="../images/etat_final.jpg" alt=""></p>
                    <h4>2.2. Les transitions :</h4>
                    <p>Les états sont reliés par des connexions unidirectionnelles appelées <span class="html">transitions</span>. Une transition représente une relation, ou chemin, entre deux états.</p>
                    <p>Le diagramme forme ainsi un graphe dirigé. Les transitions sont représentées par des flèches.</p>
                    <p>Une transition peut relier deux états différents, mais aussi relier un état à lui-même.</p>
                    <figure>
                        <img src="../images/diagramme_etats_transitions.jpg" alt="">
                        <figcaption>Figure 94 : le diagramme d'états - les transitions</figcaption>
                    </figure>
                    <p>Les transitions sont provoquées par des évènements extérieurs.</p>
                    <p>La syntaxe complète pour libeller une transition est : <span class="html">évènement '[' condition de garde ']' '/' action</span>.</p>
                    <p>Chaque transition doit posséder une condition de garde précisant si cette transition peut être effectuée, un élement déclencheur provoquant l'exécution de la transition, ainsi que tout effet résultant de la transition si celle-ci est exécutée.</p>
                    <ul>
                        <li>
                            <p>L'<span class="html">évènement</span> est celui qui déclecnche la transition.</p>
                        </li>
                        <li>
                            <p>La <span class="html">condition de garde</span> est une condition qui doit être vérifiée pour que l'évènement déclenche bien la transition. Pour un diagramme concurrent (voir plus loin), une condition de garde peut indiquer qu'une transition n'aura lieu que si l'objet est dans tel état ou au contraire, que s'il n'est pas dant cette état.</p>
                        </li>
                        <li>
                            <p>L'<span class="html">action</span> est une <span class="html">opération membre de la classe</span> de l'objet qui reçoit l'évènement (celui dont traite le diagramme).</p>
                        </li>
                    </ul>
                    <h4>2.3. Les évènements internes :</h4>
                    <p>Le rectangle représentant un état peut être divisé en deux compartiments.</p>
                    <ul>
                        <li>
                            <p>Le premier compartiment (le seul que nous ayons dessiné jusqu'à présent) est réservé au <span class="html">nom de l'état</span>.</p>
                        </li>
                        <li>
                            <p>Le second compartiment est le compartiment des <span class="html">évènements internes</span>. Ceux-ci ont la même syntaxe que celle utilisée pour les transitions.</p>
                            <p class="em">évènement '[' condition de garde ']' '/' action</p>
                        </li>
                    </ul>
                    <p>Certains évènements internes particuliers sont prédéfinis :</p>
                    <p class="em">entry '/' action</p>
                    <p>qui est exécutée à l'entrée de l'état,</p>
                    <p class="em">exit '/' action</p>
                    <p>qui est exécutée à la sortie de l'état.</p>
                    <p>D'autre part, on pourra noter <span class="em">do '/' activité</span> pour indiquer qu'il faut exécuter une activité tant que l'objet reste à cet état. L'activité peut être décrite par un autre diagramme d'états - transitions.</p>
                    <h4>2.4. Action et activité :</h4>
                    <p>Si les deux représentent des processus généralement implémentés à l'aide d'une méthode de l'objet, les actions sont considérées comme courtes et atomiques. Elles ne peuvent pas être interrompues. Les activités, par contre, peuvent prendre plus longtemps et être interrompues à la réception d'un évènement (qui peut changer l'état de l'objet).</p>
                    <h4>2.5. Transitions réflexives et évènements internes :</h4>
                    <p>Une <span class="html">transition réflexive</span> est une transition qui, à la réception d'un évènement, fait passer l'objet d'un état à ce même état.</p>
                    <p>Quelle est la différence avec un évènement interne ? En réalité, la seule différence si situe dans l'exécution des actions d'entry et d'exit. Celles-ci sont exécutées pour une transition réflexive. Elles ne le seront pas pour un évènement interne.</p>
                    <h4>2.6. Transition automatique :</h4>
                    <p>Si une transition ne comporte pas d'évènement dans son libellé, elle sera réalisée dès la fin de l'activité associée à l'état source. Une telle transition est dite automatique.</p>
                    <p>Considérons le diagramme d'états - transitions de l'envoi d'une commande. On constate que les trois transitions partant de l'état "en vérification" sont automatiques. Elles comportent néanmoins une condition de garde qui permet de choisir laquelle est réalisée.</p>
                    <figure>
                        <img src="../images/diagramme_etats_exemple_transitions_automatiques.jpg" alt="">
                        <figcaption>Figure 95 : le diagramme d'états - exemple de transitions automatiques</figcaption>
                    </figure>
                    <h3>3. Les super-états :</h3>
                    <p>Si dans le diagramme précédent, nous remarquons que de plus, une commande peut être annulée, il nous faut rajouter un état. Comme la commande peut être annulée à tout moment, on obtient un diagramme du style :</p>
                    <figure>
                        <img src="../images/diagramme_etats_super_etat_1.PNG" alt="">
                        <figcaption>Figure 96 : le diagramme d'états - super-état 1</figcaption>
                    </figure>
                    <p>On constate que le diagramme devient surchargé. Pour y remédier, on peut regrouper une partie de celui-ci en un super-état. On y retrouvera tous les états où la commande est encore active d'où le nom de cet état :</p>
                    <figure>
                        <img src="../images/diagramme_etats_super_etat_2.jpg" alt="">
                        <figcaption>Figure 97 : le diagramme d'états - super-état 2</figcaption>
                    </figure>
                    <h3>4. Diagrammes d'états concurrents :</h3>
                    <p>UML prévoit de pouvoir regrouper dans un diagramme composite des diagrammes qui doivent se dérouler concurremment.</p>
                    <p>Considérons de nouveau l'exemple de la commande à traiter. Il ne suffit pas que tous les articles soient disponibles pour que la commande puisse être envoyée. Encore faut-il vérifier le moyen de paiement.</p>
                    <p>Ce point donne le diagramme :</p>
                    <figure>
                        <img src="../images/diagramme_etats_etats_concurrents_1.jpg" alt="">
                        <figcaption>Figure 98 : le diagramme d'états - états concurrents 1</figcaption>
                    </figure>
                    <p>Nous indiquerons le côté concurrent des deux diagrammes en les incluant dans un diagramme composite. Quand la commande arrive aux deux états finaux des diagrammes internes, elle peut passer à l'état "Livrée". Entre-temps, les deux diagrammes peuvent se dérouler dans n'importe quel ordre.</p>
                    <figure>
                        <img src="../images/diagramme_etats_etats_concurrents_2.jpg" alt="">
                        <figcaption>Figure 99 : le diagramme d'états - états concurrents 2</figcaption>
                    </figure>
                    <h3>5. L'historique :</h3>
                    <p>Une région d'un super-état (éventuellement composite) peut contenir un indicateur d'<span class="html">historique</span> représenté par un cercle contenant un <span class="em">H</span>. Il s'applique uniquement à la région qui le contient.</p>
                    <p>Un tel indicateur pourra avoir plusieurs transitions dirigées vers lui, mais n'aura qu'une seule transition sortante.</p>
                    <p>Si on sort du super-état puis qu'on rentre de nouveau dans cet état, l'historique se souvient du sous-état actif lors de la sortie et reprend l'activité dans ce sous-état. La seule transition sortante du H indique le sous-état actif par défaut, si aucun sous-état n'a encore été activé.</p>
                    <figure>
                        <img src="../images/diagramme_etats_historique_1.jpg" alt="">
                        <figcaption>Figure 100 : le diagramme d'états - historique 1</figcaption>
                    </figure>
                    <p>Après interruption et reprise, on revient au sous-état B1 ou B2 qui était actif avant l'interruption. L'état B2 est l'état de reprise par défaut. UML prévoit de plus des historiques profonds H* qui se souviennent du sous-état actif au niveau le plus bas (sous-état de B1 ou encore plus bas) et prennent l'activité à ce niveau.</p>
                    <p>Exemple d'historique : la représentation des états d'une voiture dans un car-wash :</p>
                    <figure>
                        <img src="../images/diagramme_etats_historique_2.jpg" alt="">
                        <figcaption>Figure 101 : le diagramme d'états - historique 2</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="uml_java">Chapitre 10 : UML en Java :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Ce chapitre présente différents aspects de l'implémentation de diagrammes UML en Java. Il s'agit simplement de soulever quelques principes et non de détailler en profondeur le code Java pouvant découler des diagrammes. Voyez donc ce chapitre comme un premier lien entre l'UML et le Java.</p>
                    <h3>2. Les types de méthodes :</h3>
<pre><code>class Personne {

    private Qtring nom, prenom;
    private LocalDate dateNaissance;
    private List&lt;String&gt; emails;

    ...
    // getter et setter
    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    // queries
    public String fournirNomComplet() {
        return prenom + " " + nom;
    }

    public int nombreEmails() {
        return emails.size();
    }

    // modificateurs
    public boolean ajouter(String email) {
        return emails.add(email);
    }

    public boolean supprimer(String email) {
        return emails.remove(email);
    }

}</code></pre>
                    <h3>3. Les associations :</h3>
                    <p>Lorsqu'il y a une association entre deux objets, celle-ci se traduit en Java par une référence vers l'objet à l'extrémité de l'association. Notons la différence entre une association unidirectionnelle qui sera traduite par une seule référence et bidirectionnelle qui sera représentée par des références mutuelles entre les objets associés.</p>
                    <h4>3.1. L'association unidirectionnelle :</h4>
                    <figure>
                        <img src="../images/uml_java_association_unidirectionnelle.jpg" alt="">
                        <figcaption>Figure 102 : UML en Java - association unidirectionnelle</figcaption>
                    </figure>
                    <p>En Java :</p>
<pre><code>public class Personne {

    String nom;
    String prenom;
    Calendar dateNaissance;
    Adresse[] résidences;
}

public class Adresse {

    String rue;
    int numero;
    String ville;
    int codePostal;
    String pays;

}</code></pre>
                    <h4>3.2. L'association bidirectionnelle :</h4>
                    <figure>
                        <img src="../images/uml_java_association_bidirectionnelle.jpg" alt="">
                        <figcaption>Figure 103 : UML en Java - association bidirectionnelle</figcaption>
                    </figure>
                    <p>En Java :</p>
<pre><code>public class Personne {

    String nom;
    String prenom;
    Calendar dateNaissance;
    Adresse[] résidences;
}

public class Adresse {

    String rue;
    int numero;
    String ville;
    int codePostal;
    String pays;
    Personne residant;

}</code></pre>
                    <p>Maintenir correctement une <span class="html">association bidirectionnelle</span> relève d'une véritable gymnastique algorithmique puisqu'il faut que les références soient à jour pour chaque ajout, retrait ou mise à jour de part et d'autre de l'association.</p>
                    <p>Imaginons dans notre exemple ci-dessus, on ajoute une nouvelle adresse à un client : il faut l'ajouter dans la collection des adresses du client et mettre la référence du client dans la nouvelle adresse. Si la classe <span class="em">Personne</span> possède une méthode <span class="em">ajouterAdresse(Adresse uneAdresse)</span>, il suffit d'appeler cette méthode. Il faut aussi veiller à mettre la référence du client dans <span class="em">uneAdresse</span>; somple, la méthode <span class="em">ajouterAdresse</span> n'a qu'à appeler la méthode <span class="em">enregistrerPersonne(Personne unePersonne)</span> de la classe <span class="em">Adresse</span>. Oui mais supposons qu'<span class="em">uneAdresse</span> sans passer par la méthode <span class="em">ajouterAdresse</span>. Dans ce dernier cas, il faut que <span class="em">enregistrerPersonne</span> d'<span class="em">Adresse</span> appelle <span class="em">ajouterAdresse</span> de <span class="em">Personne</span> et tout ceci nous embarque dans un jeu de méthodes qui s'appellent l'une l'autre : risque de <span class="em">stackOverFlow</span>. Et ainsi de suite...</p>
                    <p>Bref, ceci pour vous montrer qu'il n'est pas simple d'implémenter ces associations !</p>
                    <h3>4. Les multiplicités :</h3>
                    <p>Dans un diagramme de classe, on bénéficie de plusieurs mécanismes pour spécifier une multiplicité ou une association qualifiée. Ces différentes manières de lier des objets ont de l'influence sur l'implémentation Java. En général, plus on est précis en UML (plus on donne de l'information sur la multiplicité), plus on restreint le choix de l'implémentation.</p>
                    <p>Voici comment implémenter les informations sur les multiplicités en Java :</p>
                    <figure>
                        <img src="../images/uml_java_multiplicites_1.jpg" alt="">
                        <figcaption>Figure 104 : UML en Java - les multiplicités 1</figcaption>
                    </figure>
<pre><code>public class Classe1 {

    private Classe2 uneClasse2;

}</code></pre>
                    <figure>
                        <img src="../images/uml_java_multiplicites_2.jpg" alt="">
                        <figcaption>Figure 105 : UML en Java - les multiplicités 2</figcaption>
                    </figure>
<pre><code>public class Classe1 {

    private Classe2[] lesClasses2; // tableau ou List ou Set

}</code></pre>
                    <figure>
                        <img src="../images/uml_java_multiplicites_3.jpg" alt="">
                        <figcaption>Figure 106 : UML en Java - les multiplicités 3</figcaption>
                    </figure>
<pre><code>public class Classe1 {

    private SortedSet&lt;Classe2&gt; uneClasse2 = new TreeSet&lt;Classe2&gt;();

}</code></pre>
                    <figure>
                        <img src="../images/uml_java_multiplicites_4.jpg" alt="">
                        <figcaption>Figure 107 : UML en Java - les multiplicités 4</figcaption>
                    </figure>
<pre><code>public class Classe1 {

    private Map&lt;Q, Classe2&gt; uneClasse2 = new HashMap&lt;Q, Classe2&gt;();

}</code></pre>
                    <h3>5. Les classes paramétrées :</h3>
                    <p>Pour rappel, une <span class="html">classe paramétrée</span> est représentée comme suit :</p>
                    <figure>
                        <img src="../images/uml_java_classe_parametree.jpg" alt="">
                        <figcaption>Figure 108 : UML en Java - classe paramétrée</figcaption>
                    </figure>
                    <p>En Java, on obtient par exemple le code suivant :</p>
<pre><code>public class Ensemble&lt;T&gt; {

    void inserer(T t);
    void enlever(T t);

}</code></pre>
                    <h3>6. Le diagramme de séquence :</h3>
                    <h4>6.1. L'objet nommé :</h4>
                    <p>Par exemple, le diagramme de séquence suivant renferme 2 objets dont un seul est nommé (monObj).</p>
                    <figure>
                        <img src="../images/uml_java_objet_nomme_pas_nomme.png" alt="">
                        <figcaption>Figure 109 : UML en Java - objet nommé ou pas nommé</figcaption>
                    </figure>
                    <p>En Java, on traduit ce diagramme par :</p>
<pre><code>public class Objet1 {

    private Objet2 monObjet;

    // ...

    public void Message1() {
        monObjet.Message2();
        monObjet.Message3();
    }

}

public class Objet2 {

    public void Message2() {
        // je fais quelque chose
    }

    public void Message3() {
        // je fais autre chose
    }

}</code></pre>
                    <h4>6.2. Le délai de transmission :</h4>
                    <p>Par exemple pour le diagramme de séquence ci-dessous :</p>
                    <figure>
                        <img src="../images/uml_java_delai_transmission.jpg" alt="">
                        <figcaption>Figure 110 : UML en Java - délai de transmission</figcaption>
                    </figure>
                    <p>En Java, on traduit l'appel par :</p>
<pre><code>public class Classe2 {

    public void unAppel() { // connexion sur une BD distante par exemple }

}

public class Classe1 {

    private Classe2 objet2;

    // ...

    public A() {
        objet2.unAppel();
    }

}</code></pre>
                    <h4>6.3. Le signal :</h4>
                    <p>En Java, implémenter le signal revient à faire de la programmation évènementielle. Autrement dit, en Java, on utilise des threads.</p>
                    <h4>6.4. La création et destruction d'objet :</h4>
                    <p>Pour rappel :</p>
                    <figure>
                        <img src="../images/uml_java_creation_destruction_objet.jpg" alt="">
                        <figcaption>FIgure 111 : UML en Java - création et destruction d'objet</figcaption>
                    </figure>
                    <p>En Java, on traduit ce schéma par :</p>
<pre>public class Registre {

    private Vente vente;

    // ...

    public void qqChoseSePasse() {
        int montant = // récupération du montant
        vente.creerPaiement(montant);
    }

}

public class Vente {

    public void creerPaiement(int montant) {
        Paiement p = new Paiement(montant);
        // ...
        p = null;
    }
}

public class Paiement {

    private int montant;

    public Paiement(int montant) {
        this.montant = montant;
    }

}<code></code></pre>
                    <p>Pour rappel, il n'existe pas en Java de moyen de détruire complètement un objet de la mémoire. La seule possibilité qu'on a est de casser toutes les références vers l'objet à détruire et attendre que le garbage collector s'active !</p>
                    <h4>6.5. L'alternative :</h4>
                    <p>Pour rappel :</p>
                    <figure>
                        <img src="../images/uml_java_alternative.jpg" alt="">
                        <figcaption>Figure 112 : UML en Java - l'alternative</figcaption>
                    </figure>
                    <p>En Java :</p>
<pre><code>public class Compte {

    private int solde;
    private int credit;

    // ...

    public boolean demande(int montant) {
        if (montant &lt; solde + credit) return true;
        return false;
    }

}</code></pre>
                    <h4>6.6. L'itération :</h4>
                    <p>Pour rappel :</p>
                    <figure>
                        <img src="../images/uml_java_iteration.jpg" alt="">
                        <figcaption>Figure 113 : UML en Java - l'itération</figcaption>
                    </figure>
                    <p>En Java :</p>
<pre><code>public class ATM  {

    private BufferedReader clavier = new BufferedReader(new InputStreamReader(System.in));

    public void ecranCode() throws IOException; MauvaisCodeException {
        System.out.println("Entrer votre code");
        String code = clavier.readLine();
        for (int i = 0; i &lt; 3; i++)
            if (verifierCode(code)) return;
        throw new MauvaisCodeException();
    }

    private boolean verifierCode(String code) {
        // ...
        return true;
    }

}</code></pre>
                    <h4>6.7. Le parallélisme :</h4>
                    <p>Pour rappel :</p>
                    <figure>
                        <img src="../images/uml_java_parallelisme.jpg" alt="">
                        <figcaption>Figure 114 : UML en Java - le parallélisme</figcaption>
                    </figure>
                    <p>Le parallélisme signifie que l'ordre dans lequel les deux opérations parallèles sont effectuées importe peu.</p>
                    <p>En Java :</p>
<pre><code>public class ATM {

    private DistributeurBillets lesBillets;
    private Imprimante imprimante;

    // ...

    public void retrait(int montant) {
        this.lesBillets.donnerBillets(montant);
        this.imprimante.imprimerTicket(montant);
    }

}</code></pre>
                    <p>Ou bien :</p>
<pre><code>public class ATM {

    private DistributeurBillets lesBillets;
    private Imprimante imprimante;

    // ...

    public void retrait(int montant) {
        this.imprimante.imprimerTicket(montant);
        this.lesBillets.donnerBillets(montant);
    }

}</code></pre>
                    <p>Si on désire faire du vrai parallélisme, c'est-à-dire que les deux opérations se déroulent exactement en même temps : on fait alors de la programmation évènementielle au moyen notamment des threads.</p>
                </article>
                <article>
                    <h2 id="mise_en_oeuvre_uml">Chapitre 11 : Mise en oeuvre d'UML :</h2>
                    <h3>1. Introduction :</h3>
                    <p>Comment mettre en oeuvre UML ?</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_1.jpg" alt="">
                        <figcaption>Figure 116 : mise en oeuvre d'UML 1</figcaption>
                    </figure>
                    <p>UML est une <span class="html">boîte à outils standardisés</span>, UML ne prône aucune méthodologie de développement de projet. En effet, UML ne propose pas de démarche pas de démarche de modélisation explicitant et encadrant toutes les étapes d'un projet, de la compréhension des besoins à la production du code de l'application. Une méthode se doit de définir une séquence d'étapes, partiellement ordonnées, dont l'objectif est de produire un logiciel de qualité qui répond aux besoins des utilisateurs dans des temps et des coûts prévisibles.</p>
                    <p>Bien qu'UML ne soit pas une méthode, ses auteurs précisent néanmoins qu'une méthode basée sur l'utilisation UML doit être :</p>
                    <ul>
                        <li>
                            <p class="em">Pilotée par les cas d'utilisation :</p>
                            <p>La principale qualité d'un logiciel étant son utilité, c'est-à-dire son adéquation avec les besoins des utilisateurs, toutes les étapes, de la spécification des besoins à la maintenance, doivent être guidées par les cas d'utilisation qui modélisent justement les besoins des utilisateurs.</p>
                        </li>
                        <li>
                            <p class="em">Centrée sur l'architecture :</p>
                            <p>L'architecture est conçue pour satisfaire les besoins exprimés dans les cas d'utilisation, mais aussi pour prendre en compte les évolutions futures et les contraintes de réalisation. La mise en place d'une architecture adaptée conditionne le succès d'un développement. Il est important de la stabiliser le plus tôt possible.</p>
                        </li>
                        <li>
                            <p class="em">Itérative et incrémentale :</p>
                            <p>L'ensemble du problème est décomposé en petites itérations, définies à partir des cas d'utilisation et de l'étude des risques. Les risques majeurs et les cas d'utilisation les plus importants sont traités en priorité. Le développpement procède par des itérations qui conduisent à des livraisons incrémentales du système.</p>
                        </li>
                    </ul>
                    <p>Dans ce chapitre, nous proposons une méthode simple et générique, inspirée par la méthode présentée par Roques. Cette méthode rend le projet plus flexible et ouvert au changement.</p>
                    <p>Elle a donc montré son efficacité dans la pratique et est :</p>
                    <ul>
                        <li>
                            <p>conduite par les cas d'utilisation;</p>
                        </li>
                        <li>
                            <p>relativement légère et restreinte mais sans négliger les activités de modélisation en analyse et conception;</p>
                        </li>
                        <li>
                            <p>fondée sur l'utilisation d'un sous-ensemble nécessaire et suffisant du langage UML.</p>
                        </li>
                    </ul>
                    <p>Dans tous les cas, il faut garder à l'esprit qu'une méthode n'est pas une formule magique. Le fait de produire des diagrammes UML selon un ordre établi n'est en aucun cas une garantie de réussite. Une méthode ne sert qu'à canaliser et ordonner les étapes de la modélisation. La valeur n'est pas dans la méthode mais dans les personnes qui la mettent en oeuvre.</p>
                    <h3>2. Identification des besoins et spécification des fonctionnalités :</h3>
                    <h4>2.1. Les cas d'utilisation :</h4>
                    <p>Les cas d'utilisation constituent la base du projet; ils constituent le fil conducteur du projet. Dans un premier temps, on les crée pour identifier et modéliser les besoins des utilisateurs. Ces besoins sont déterminés à partir des informations recueillies lors des rencontres entre informaticiens et utilisateurs. Il faut impérativement proscrire toute considération de réalisation lors de cette étape.</p>
                    <p>Durant cette étape, vous devrez déterminer les limites du système, identifier les acteurs et recenser les cas d'utilisation.</p>
                    <p>On détaillera ensuite les scénarios des cas d'utilisation; on opère alors une description textuelle des besoins. Les scénarios de la description textuelle des cas d'utilisation peuvent être vus comme des instances de cas d'utilisation et sont illustrés par des diagrammes de séquence système. Il faut, au minimum, représenter le scénario nominal de chacun des cas d'utilisation par un diagramme de séquence qui rend compte de l'interaction entre l'acteur, ou les acteurs, et le système. Le système est ici considéré comme un tout et est représenté par une seule ligne de vie. Chaque acteur est également associé à une ligne de vie. Lorsque les scénarios alternatifs d'un cas d'utilisation sont nombreux et importants, l'utilisation d'un diagramme d'activités peut s'avérer préférable à une multitude de diagrammes de séquence.</p>
                    <p>Cette étape amène souvent à mettre à jour le diagramme de cas d'utilisation puisque nous sommes toujours dans la spécification des besoins.</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_2.jpg" alt="">
                        <figcaption>Figure 116 : mise en oeuvre d'UML 2</figcaption>
                    </figure>
                    <p>Les prototypes (ou la maquette) d'IHM (Interface Homme-Machine) sont des représentations des futures interfaces de l'application. Il s'agit d'un produit jetable mettant aux utilisateurs d'avoir une idée concrète mais non définitive des interfaces de l'application. La maquette peut très bien consister en un ensemble de dessins produits par un logiciel de présentation ou de dessin. Par la suite, la marquette pourra intégrer des fonctionnalités de navigation permettant à l'utilisateur de tester l'enchaînement des écrans ou des menus, même si les fonctionnalités restent fictives. La maquette doit être développée rapidement afin de provoquer des retours de la part des utilisateurs.</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_3.jpg" alt="">
                        <figcaption>Figure 117 : mise en oeuvre d'UML 3</figcaption>
                    </figure>
                    <h3>3. Analyse :</h3>
                    <h4>3.1. Modèle du domaine : les CRC cards :</h4>
                    <p>La modélisation des besoins par des cas d'utilisation s'apparente à une analyse fonctionnelle classique. L'élaboration du modèle des classes du domaine permet d'opérer une transition vers une véritable modélisation objet. L'analyse du domaine est une étape totalement dissociée de l'analyse des besoins. Elle peut être menée en parallèle ou après cetter dernière.</p>
                    <p>La phase d'analyse du domaine permey d'élaborer la première version du diagramme de classes appelée modèle du domaine. Ce modèle doit définir les classes qui modélisent les entités ou concepts présents dans le domaine (on utilise aussi le terme de <span class="em">métier</span> ou encore <span class="em">business</span>) de l'application. Ces entités ou concepts peuvent être identifiés directement à partir de la connaissance du domaine ou par des entretiens avec des experts du domaine. Il faut absolument utiliser le vocabulaire du métier pour nommer les classes et leurs attributs. Les classes du modèle du domaine ne doivent pas contenir d'opérations, mais seulement des attributs.</p>
                    <p>Les fiches CRC offrent une méthodologie pour concevoir de modèle business.</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_4.jpg" alt="">
                        <figcaption>Figure 118 : mise en oeuvre d'UML 4</figcaption>
                    </figure>
                    <h4>3.2. Diagrammes des classes conceptuels : la découpe en couches :</h4>
                    <p>Le diagramme de classes conceptuel ou des classes participantes est particulièrement important puisqu'il effectue la jonction entre, d'une part, les cas d'utilisation, le modèle du domaine et la maquette, et d'autre part, les diagrammes de conception logicielle que sont les diagrammes d'interactions et le diagramme de classes de conception.</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_5.jpg" alt="">
                        <figcaption>Figure 11ç : mise en oeuvre d'UML 5</figcaption>
                    </figure>
                    <p>Il n'est pas souhaitable que les utilisateurs interagissent directement avec les instances des classes du domaine par le biais de l'interface graphique. En effet, le modèle du domaine doit être indépendant des utilisateurs et de l'interface graphique. De même, l'interface graphique du logiciel doit pouvoir évoluer sans répercussion sur le coeur de l'application. C'est le principe fondamental du découpage en couches d'une application. Ainsi, le diagramme de classes participantes modélise trois types de classes d'analyse, les <span class="em">dialogues</span>, les <span class="em">contrôles</span> et les <span class="em">entités</span> ainsi que leurs relations.</p>
                    <ul>
                        <li>
                            <p class="em">Les classes de dialogues :</p>
                            <p>Les classes qui permettent les interactions entre l'IHM et les utilisateurs sont qualifiées de <span class="em">dialogues</span>. Ces classes sont directement issues de l'anamyse de la maquette. Il y a au moins un dialogue pour chaque association entre un acteur et un cas d'utilisation du diagramme de cas d'utilisation. En général, les dialogues vivent seulement le temps du déroulement du cas d'utilisation concerné.</p>
                        </li>
                        <li>
                            <p class="em">Les classes de contrôles :</p>
                            <p>Les classes qui modélisent la cinématique de l'application sont appelées <span class="em">contrôles</span>. Elles font la jonction entre les dialogues et les classes métier en permettant aux différentes vues de l'application de manipuler des informations détenues par un ou plusieurs objets métier. Elles contiennent les règles applicatives et les isolent à la fois des dialogues et des entités.</p>
                        </li>
                        <li>
                            <p class="em">Les classes entités :</p>
                            <p>Les classes métier, qui proviennent directement du modèle du domaine, sont qualifiées d'<span class="em">entités</span>. Ces classes sont généralement persistantes, c'est-à-dire qu'elle survivent à l'exécution d'un cas d'utilisation particulier et qu'elles permettent à des données et des relations d'être stockées dans des fichiers ou des bases de données. Lors de l'implémentation, ces classes peuvent ne pas se concrétiser par des classes mais par des relations, au sens des bases de données relationnelles.</p>
                        </li>
                    </ul>
                    <p>Par la suite, on affinera le diagramme de classes en couches :</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_decoupe_en_couches.jpg" alt="">
                        <figcaption>Figure 120 : mise en oeuvre d'UML - découpe en couches</figcaption>
                    </figure>
                    <p>Découper en couches notre application revient à faire le design de celle-ci. On parle d'<span class="html">architecture nTiers</span> qui permet de coupler le moins possible les interfaces, la logique business et les données.</p>
                    <p>L'<span class="html">architecture trois tiers</span> ("3-Tier" en anglais) est l'application du modèle plus génral qu'est le multi-tiers. L'architecture logique du système est divisée en trois niveaux ou couches :</p>
                    <ul>
                        <li>
                            <p>couche présentation</p>
                        </li>
                        <li>
                            <p>couche métier</p>
                        </li>
                        <li>
                            <p>couche accès aux données</p>
                        </li>
                    </ul>
                    <p>L'architecture 3-tier (en anglais, "tiers" signifie "étage" ou "niveau") est un modèle logique d'architecture applicative qui vise à séparer très nettement trois couches logicielles au sein d'une même application ou système, à modéliser et présenter cette application comme un empilement de trois couches, étages, niveaux ou strates dont le rôle est clairemnt défini :</p>
                    <ul>
                        <li>
                            <p>La <span class="html">présentation des données</span> correspond à l'affichage, la restitution sur le poste de travail, le dialogue avec l'utilisateur.</p>
                        </li>
                        <li>
                            <p>Le <span class="html">traitement métier des données</span> correspond à la mise en oeuvre de l'ensemble des règles de gestion et de la logique applicative.</p>
                        </li>
                        <li>
                            <p>L'<span class="html">accès aux données persistantes</span> correspond aux données qui sont destinées à être conservées sur la durée, voire de manière définitive.</p>
                        </li>
                    </ul>
                    <p>Dans cette approche, les couches communiquent entre elles au travers d'un "modèle d'échange", et chacune d'entre elles propose un ensemble de services rendus. Les services d'une couche sont mis à disposition de la couche supérieure. On s'interdit par conséquent qu'une couche invoque les services d'une couche plus basse que la couche immédiatement inférieure ou plus haute que la couche immédiatement inférieure ou plus haute que la couche immédiatement supérieure (chaque niveau ne communique qu'avec ses voisins immédiats).</p>
                    <h4>3.3. Diagrammes de navigation :</h4>
                    <p>Les IHM modernes facilitent la communication entre l'application et l'utilisateur en offrant toute une gamme de moyens d'action et de visualisation comme des menus déroulants ou contextuels, des palettes d'outils, des boîtes de dialogues, des fenêtres de visualisation, etc. Cette combinaison possible d'options d'affichage, d'interaction et de navigation aboutit aujourd'hui à des interfaces de plus en plus riches et puissantes.</p>
                    <p>UML offre la possibilité de représenter graphiquement cette activté de navigation dans l'interface en produisant des diagrammes dynamiques. On appelle ces diagrammes des diagrammes de navigation. Le concepteur peut opter soit pour des diagrammes d'états-transitions soit pour des diagrammes d'activités. Les diagrammes d'activités constituent peut-être un choix plus souple judicieux.</p>
                    <p>La modélisation de la navigation à intérêt à être structurée par acteur.</p>
                    <h3>4. Conception :</h3>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_6.jpg" alt="">
                        <figcaption>Figure 121 : mise en oeuvre d'UML 6</figcaption>
                    </figure>
                    <h4>4.1. Diagrammes d'interactions :</h4>
                    <p>Maintenant, il faut attribuer précisément les responsabilités de comportement, dégagée par le diagramme de séquence système aux classes d'analyse du diagramme de classes participantes élaboré. Les diagrammes d'interactions système permettent une représentation des différents objets collaborant dans le cadre d'un scénario d'exécution du système.</p>
                    <p>Dans les diagrammes d'interactions, les objets communiquent en s'envoyant des messages qui invoquent des opérations sur les objets récepteurs. Il est ainsi possible de suivre visuellement les interactions dynamiques entre objets, et les traitements réalisés pour chacun d'eux.</p>
                    <p>Parallèlement, une première ébauche de la vue statique de conception, c'est-à-dire du diagramme de classes de conception, est construite et complétée. Durant cette phase, l'ébauche du diagramme de classes de conception reste indépendante des choix technologiques qui seront faits ultérieurement (dans la section suivante).</p>
                    <h4>4.2. Diagrammes de classes - Architecture :</h4>
                    <p>L'objectif de cette étape est de produire le diagramme de classes qui servira pour l'implémentation. Une première ébauche du diagramme de classes de conception a déjà été élaborée en parallèle des diagrammes d'interactions. Il faut maintenant le compléter en précisant les opérations privées des différentes classes. Il faut prendre en compte les choix techniques, comme le choix du langage de programmation, le choix des différentes librairies utilisées (notamment pour l'implémentation de l'interface graphique), etc.</p>
                    <p>Pour une classe, le <span class="em">couplage</span> est la mesure de la quantité d'autres classes auxquelles elle est connectée par des associations, des relations de dépendance, etc. Durant toute l'élaboration du diagramme de classes de conception, il faut veiller à conserver un couplage faible pour obtenir une application plus évolutive et plus facile à maintenir. L'utilisation des <span class="em">design patterns</span> est fortement conseillée lors de l'élaboration du diagramme de classes.</p>
                    <figure>
                        <img src="../images/mise_en_oeuvre_uml_7.jpg" alt="">
                        <figcaption>Figure 122 : mise en oeuvre d'UML 7</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="bibliographie">Bibliographie :</h2>
                    <h3>Les sites à consulter :</h3>
                    <ul>
                        <li>
                            <a href="http://www.uml.org/" target="_blank">OMT - UML resource Page</a>
                        </li>
                        <li>
                            <a href="http://www-306.ibm.com/software/awdtools/rup/" target="_blank">RUP</a>
                        </li>
                        <li>
                            <a href="http://www.2tup.net/" target="_blank">2tup</a>
                        </li>
                        <li>
                            <a href="http://scrum.aubryconseil.com/" target="_blank">Scrum</a>
                        </li>
                        <li>
                            <a href="http://agile.thierrycros.net/" target="_blank">Agile</a>
                        </li>
                        <li>
                            <a href="http://www.refactoring.com/tools.html" target="_blank">Refactoring</a>
                        </li>
                        <li>
                            <a href="http://www.extremeprogramming.org/" target="_blank">XP</a>
                        </li>
                        <li>
                            <a href="http://www.wikipedia.org/" target="_blank">Wikipédia</a>
                        </li>
                        <li>
                            <a href="http://alistair.cockburn.us/index.php/Basic_use_case_template" target="_blank">Use Case</a> - <a href="http://alistair.cockburn.us/" target="_blank">template d'Alistair Cockburn</a>
                        </li>
                    </ul>
                    <h3>Les manuels de référence se trouvant à la bibliothèque de l'IPL :</h3>
                    <ul>
                        <li>
                            <p>Pilone Dan et Neil Pitman, UML 2 en concentré - manuel de référence, Paris, O'Reilly, 2006, 222 pages</p>
                            <p>&#8594; Traduction de "UML 2.0 in a Nutshell"</p>
                        </li>
                        <li>
                            <p>Roques Pascal et Franck Vallée, UML en action - De l'analyse des besoins à la conception en Java (2<sup>ème</sup> édition), Paris, Eyrolles, 2003, 388 pages</p>
                        </li>
                        <li>
                            <p>Roques Pascal, UML 2 par la pratique - Etudes de cas et exercices dirigés, Paris, Eyrolles, 2004, 309 pages</p>
                        </li>
                        <li>
                            <p>Rumbaugh James, Ivar Jackobson et Booch Grady, UML 2.0 - Guide de référence, Paris, CampusPress, 2004, 774 pages</p>
                            <p>&#8594; Traduction de "The Unified Modeling Language Reference Manual, Second Edition"</p>
                        </li>
                        <li>
                            <p>Boem Barry et Richard Turner, Balancing Agility and Discipline : A Guide for the Perplexed, Addison-Wesley, 2003, 304 pages</p>
                        </li>
                    </ul>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>