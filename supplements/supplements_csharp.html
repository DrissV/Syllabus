<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>C# et .NET - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_sdk">Installation du SDK</a></li>
                        <li><a href="#premier_projet">Création du premier projet</a></li>
                        <li><a href="#premiere_instruction">Anatomie d'une instruction C#</a></li>
                        <li><a href="#variables_constantes">Les variables et constantes</a></li>
                        <li><a href="#types_en_details">Les types en détails</a></li>
                        <li><a href="#operateurs">Les opérateurs</a></li>
                        <li><a href="#conversion_entre_types">La conversion entre types</a></li>
                        <li><a href="#if">L'instruction de test (if)</a></li>
                        <li><a href="#operateurs_booleens">Les opératuers booléens</a></li>
                        <li><a href="#tableaux_listes">Les tableaux et les listes</a></li>
                        <li><a href="#boucles">Les boucles</a></li>
                        <li><a href="#gestion_erreurs">La gestion des erreurs</a></li>
                        <li><a href="#conclusion_1">Conclusion n° 1</a></li>
                        <li><a href="#explications_technologies_.NET">Explications sur les technologies .NET</a></li>
                        <li><a href="#poo">La programmation orientée objet</a></li>
                        <li><a href="#linq">LINQ</a></li>
                        <li><a href="#linq_to_objects">LINQ To Objects</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage C# et le framework .NET :</h1>
                    <p>D'après Christophe Mommer, développeur C# ayant écrit des livres dessus : <q>Un développeur C#/.NET n'st pas expert sur toutes les technologies .NET !</q>.</p>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage C# (prononcé C Sharp) est un langage de programmation <span class="em">fortement
                            typé</span>, <span class="em">orienté objet</span> et <span class="em">multi-plateforme</span>.
                    </p>
                    <p><span class="em">Fortement typé</span> : chaque élément appartient à un type <span class="em">tout au
                            long de sa vie</span>. Par exemple, si on déclare une variable pour y stocker un entier, on ne
                        pourra JAMAIS y stocker une chaîne de caractères ou une date.</p>
                    <p><span class="em">Orienté objet</span> : approche du développement informatique où l'on peut créer des
                        objets pour y stocker diverses informations.</p>
                    <p><span class="em">Multi-plateforme</span> : le code C# permet de réaliser des applications sur
                        Windows; Mac, téléphone mobile, Web, ... et même votre télévision Samsung !</p>
                    <p>Le C# est <span class="em">compilé</span> par un compilateur qui transforme le code C# en code <span
                            class="em">IL</span> (Intermediate Language).</p>
                    <p>Ce dernier est ensuite interprété par une machine virtuelle (le <span class="em">CLR</span>) qui le
                        transforme en instruction machine.</p>
                    <p>Le gros avantage d'un langage compilé : vérification du code à la compilation.</p>
                    <p>Le compositeur est votre MEILLEUR ami (et il optimise votre code).</p>
                    <p>Le langage de programmation contient un ensemble d'instructions de programmation (comme les
                        conditions, boucles, etc.).</p>
                    <p>Il est fourni avec un framework, .NET, qui contint une collection d'outils prêts à l'emploi.</p>
                    <p>Il existe une version dédiée à Windows (.NET Framework 4.8) et une version multi-plateforme (.NET).
                    </p>
                </article>
                <article>
                    <h2 id="installation_sdk">Installation du SDK :</h2>
                    <p>Le framework .NET 8 s'installe sur tous les systèmes d'exploitation récents (Windows 10/11, Mac OS,
                        Linux).</p>
                    <ol>
                        <li>
                            <p>Se rendre à l'URL <a href="https://dotnet.microsoft/com/download"
                                    target="_blank">https://dotnet.microsoft/com/download</a>.</p>
                        </li>
                        <li>
                            <p>Télécharger la dernière version du SDK .NET (et non .NET Core ni .NET Framewrok).</p>
                        </li>
                        <li>
                            <p>Exécuter l'assistant d'installation.</p>
                        </li>
                        <li>
                            <p>Vérifier que l'installation s'est bien passée en tapant dans une invite de commande :</p>
                            <pre><code>dotnet --version</code></pre>
                        </li>
                    </ol>
                    <p>Le SDK (Software Development Kit) installé contient le compilateur et le runtime.</p>
                    <p>Pour coder, il est possible d'utiliser :</p>
                    <ul>
                        <li>
                            <p>Un éditeur de texte (non recommandé)</p>
                        </li>
                        <li>
                            <p>Visual Studio 2022 (Windows et Mac)</p>
                        </li>
                        <li>
                            <p>Visual Studio Code (Windows, Mac & Linux)</p>
                        </li>
                        <li>
                            <p>Rider (Windows, Mac & Linux)</p>
                        </li>
                    </ul>
                    <p>Visual Studio Code est un éditeur de code <span class="em">gratuit</span> et <span
                            class="em">multi-plateforme</span> suffisant pour notre apprentissage.</p>
                    <p>Se rendre à l'adresse <a href="https://code.visualstudio.com/"
                            target="_blank">https://code.visualstudio.com/</a> pour télécharger la dernière version sable
                        correspondant à votre système d'exploitation.</p>
                    <p>Pour avoir tout le confort de travail, il faut configurer VS Code :</p>
                    <ol>
                        <li>
                            <p>Installation de l'extension <span class="em">OmniSharp</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">Bracket Pair Colorizer</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">VS Sharper for C#</span></p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premier_projet">Création du premier projet :</h2>
                    <p>Un projet C# contient le code nécessaire pour créer une application.</p>
                    <p>Pour apprendre, nous allons commencer par créer une application <span class="em">Console</span>.</p>
                    <ol>
                        <li>
                            <p>Ouvrir VS Code dans un dossier défini.</p>
                        </li>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Écrire la commande :</p>
                            <pre><code>dotnet new console -n MonPremierProjet</code></pre>
                        </li>
                    </ol>
                    <p>Lorsque le code est prêt, un programme C# est exécutable.</p>
                    <p>Dans notre cas, nous avons une application console, son exécution se passe donc dans un terminal.</p>
                    <ol>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Au niveau du répertoire où se situe le fichier <span
                                    class="em">MonPremierProjet.csproj</span>, écrire la commande :</p>
                            <pre><code>dotnet run</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premiere_instruction">Anatomie d'une instruction C# :</h2>
                    <p>L'extension d'un fichier C# est "<span class="em">.cs</span>".</p>
                    <p>La ligne est une instruction C# :</p>
                    <pre><code>Console.WriteLine("Hello, World!");</code></pre>
                    <p>Décomposons cette instruction :</p>
                    <ul>
                        <li>
                            <p><span class="em">Console</span> : objet à utiliser</p>
                        </li>
                        <li>
                            <p><span class="em">.</span> : accesseur à un élément de l'objet le précédant</p>
                        </li>
                        <li>
                            <p><span class="em">WriteLine</span> : méthode d'un objet</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : parenthèses pour passage de paramètres</p>
                        </li>
                        <li>
                            <p><span class="em">"Hello, World!"</span> : valeur du paramètre</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : point-virgule en fin d'instruction</p>
                        </li>
                    </ul>
                    <p>Le commentaire commence par <span class="em">//</span> comme dans l'exemple ci-dessous :</p>
<pre><code>// See https://aka.ms/new-console-template for more information</code></pre>
                    <p>Le commentaire permet d'écrire du texte libre à côté du code source (pour donner une indication quelconque).</p>
                    <p>Exercice : Écrire l'instruction C#, à la ligne de la première, permettant d'afficher "J'apprends le C#" :</p>
<pre><code>Console.WriteLine("J'apprends le C#");</code></pre>
                    <p>En C#, le placement des accolades pour définir le corps des fonctions (méthodes) est une une question de style de codage. Il existe deux approches principales : avec les accolades à la ligne ou sur la même ligne que la déclaration de la fonction.</p>
                    <ol>
                        <li>
                            <p>Accolades à la ligne (Allman Style) :</p>
<pre><code>public void Exemple()
{
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                        <li>
                            <p>Accolades sur la même ligne (K&R Style) :</p>
<pre><code>public void Exemple() {
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                    </ol>
                    <p>Les deux styles sont acceptés par le compilateur C# et sont largement une question de préférence personnelle ou de convention d'équipe. Certains développeurs préfèrent l'un sur l'autre pour des raisons de lisibilité, de style, ou même d'adhésion à des normes de codage spécifiques.</p>
                    <p>Dans la suite du cours, on utilisera la première méthode car Visual Studio 2022 l'utilise, mais il est essentiel de choisir un style cohérent au sein d'un projet ou d'une équipe pour maintenir la lisibilité et la cohérence du code.</p>
                </article>
                <article>
                    <h2 id="variables">Les variables et constantes :</h2>
                    <p>Une variable est une donnée que l'on souhaite stocker pour travailler, dont le contenu peut changer.</p>
                    <p>En C#; une variable est <span class="em">fortement typée</span>, c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer.</p>
                    <p>La syntaxe pour déclare une variable est :</p>
<pre><code>TYPE NOM + VALEUR;</code></pre>
                    <p>Quelques-uns des types les plus courants :</p>
                    <ul>
                        <li>
                            <p><span class="em">Entier</span> &#8594; déclaration avec le mot clé "int".</p>
                            <ul>
                                <li>
                                    <p>La valeur est directement écrite en chiffres.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Chaîne de caractères</span> &#8594; déclaration avec le mot clé "string".</p>
                            <ul>
                                <li>
                                    <p>La valeur est écrite entre guillemets.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Booléen</span> &#8594; déclaration avec le mot clé "bool".</p>
                            <ul>
                                <li>
                                    <p>Peut seulement valor "true" (vrai) ou "false" (faux).</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Le nom d'une variable ne peut pas contenir d'espace. Voici quelques exemples de déclaration de variables :</p>
<pre><code>int age = 29;
string prenom = "Driss";
bool estVivant = true;</code></pre>
                    <p>Dans VS Code, ne prêter pas attention au soulignage. Il 'agit d'un avertissement du compilateur comme quoi une variable est déclarée mais non utilisée.</p>
                    <p>Il existe une syntaxe appelée "typage implicite" permettant d'utiliser un mot clé commun (<span class="em">var</span>) pour que le compilateur devine le type en fonction de la valeur.</p>
<pre><code>var NOM = VALEUR</code></pre>
                    <p>Attention, en l'absence de valeur, le comilateur ne peut pas déduire le type, et il est donc illicite de faire uen instruction <span class="html">var NOM</span>.</p>
<pre><code>var taille = 172;
var nom = "Vandenheede";
var faux = false;</code></pre>
                    <p>La syntaxe pour affecter une variable est :</p>
<pre><code>NOM = VALEUR;</code></pre>
                    <p>Cela <span class="em">impose</span> que la variable ait été déclarée au préalable, sinon cela ne fonctionnera pas.</p>
                    <p>Ainsi, il est possible de chnager une valeur d'une variable après sa création.</p>
<pre><code>taille = 200;</code></pre>
                    <p>Une constante est une donnée que l'on souhaite stocker pour travailler, dont le contenu ne changera jamais.</p>
                    <p>En C#, une constante est <span class="em">fortement typée</span> c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer, tout comme sa valeur.</p>
                    <p>La syntaxe pour déclarer une constante est :</p>
<pre><code>const TYPE NOM = VALEUR;</code></pre>
                    <p>Attention, le mot clé "<span class="em">const</span>" est réservé au langage C# et ne peut pas être utilisé comme nom pour une variable ou une constante.</p>
                    <p>Voici quelques exemples :</p>
<pre><code>const int valeur = 42;
const string pays = "Belgique";
const bool vrai = true;</code></pre>
                    <p>Une variable peut aussi être affectée par une valeur renvoyée par une fonction.</p>
                    <p>Par exemple, la fonction <span class="html">Console.ReadLine();</span> attends la saisie de l'utilisateur (finalisée par l'appui sur entrée) ey renvoie cette valeur.</p>
                    <p>Ainsi, on peut récupérer la valeur dans une variable en définissant l'affectation de la valeur comme étant l'appel de la fonction :</p>
<pre><code>var saisie = Console.ReadLine();</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et de lui dire "Bonjour prénom".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="html">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire la valeur.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string saisie = Console.ReadLine();
Console.WriteLine("Bonjour");
Console.WriteLine(saisie);</code></pre>
                </article>
                <article>
                    <h2 id="types_en_details">Les types en détails :</h2>
                    <p>Bien que le langage se réserve des mots-clés pour les types, ceux-ci sont définis au sein du framework .NET.</p>
                    <p>Par exemple, il y a beaucoup de types différents pour représenter un chiffre, selon sa taille, le fait qu'il puisse être négatif ou non, ainsi que s'il peut avoir une virgule ou pas !</p>
                    <p>Voici une table de référence des types numériques :</p>
                    <table class="tableBalises">
                       <thead>
                        <tr>
                            <th>Type en c#</th>
                            <th>Type système</th>
                            <th>Suffixe</th>
                            <th>Taille mémoire</th>
                            <th>Plage</th>
                        </tr>
                       </thead>
                       <tbody>
                        <tr>
                            <td colspan="5">Types entiers signés</td>
                        </tr>
                        <tr>
                            <td>sbyte</td>
                            <td>System.Sbyte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>-2<sup>7</sup> à 2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td>short</td>
                            <td>System.Int16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>-2<sup>15</sup> à 2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td>int</td>
                            <td>System.Int32</td>
                            <td></td>
                            <td>32 bits</td>
                            <td>-2<sup>31</sup> à 2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td>long</td>
                            <td>System.Int64</td>
                            <td>L</td>
                            <td>64 bits</td>
                            <td>-2<sup>63</sup> à 2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <td colspan="5">Types entiers non signés</td>
                        </tr>
                        <tr>
                            <td>byte</td>
                            <td>System.Byte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>0 à 2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ushort</td>
                            <td>System.UInt16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>0 à 2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td>uint</td>
                            <td>System.UInt32</td>
                            <td>U</td>
                            <td>32 bits</td>
                            <td>0 à 2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ulong</td>
                            <td>System.UInt64</td>
                            <td>UL</td>
                            <td>64 bits</td>
                            <td>0 à 2<sup>64</sup>-1</td>
                        </tr>
                        <tr>
                            <td colspan="5">Types réels</td>
                        </tr>
                        <tr>
                            <td>float</td>
                            <td>System.Single</td>
                            <td>F</td>
                            <td>32 bits</td>
                            <td>&#117; -10<sup>45</sup> à 10<sup>38</sup></td>
                        </tr>
                        <tr>
                            <td>double</td>
                            <td>System.Double</td>
                            <td>D</td>
                            <td>64 bits</td>
                            <td>&#117; -10<sup>324</sup> à &#117; 10<sup>308</sup></td>
                        </tr>
                        <tr>
                            <td>decimal</td>
                            <td>System.Decimal</td>
                            <td>M</td>
                            <td>128 bits</td>
                            <td>&#117; -10<sup>28</sup> à &#117; 10<sup>28</sup></td>
                        </tr>
                       </tbody>
                    </table>
                    <p>Les types entiers signés est utilisé lorsque la valeur peut être positif ou négatif.</p>
                    <p>Les types entiers non signés sont l'inverse des types entiers signés dont la valeur minimale est 0.</p>
                    <p>Les types réels est lorsque la valeur est avec une virgule.</p>
                    <p>Quelques détails supplémentaires :</p>
                    <ul>
                        <li>
                            <p>Le type <span class="html">float</span> ou <span class="html">double</span> est recommandé pour les <span class="em">calculs mathématiques</span> (hautre précision) alors que <span class="em">decimal</span> est recommandé pour les <span class="em">calculs financiers</span>.</p>
                        </li>
                        <li>
                            <p>Depuis C# 7, il est possible d'utiliser un séparateur pour les gros chiffres :</p>
<pre><code>int unMilliard = 1_000_000_000;</code></pre>
                        </li>
                        <li>
                            <p>Le suffixe n'est obligatoire que ds'il existe une ambigüité :</p>
<pre><code>var jeVeuxUnLong = 16UL // ici, par défaut, le type aurait été int</code></pre>
                        </li>
                    </ul>
                    <p>Nous avons déjà travaillé avec les chaînes de caractères :</p>
                    <p>Pour en définir une, il suffit de mettre la valeur entre guillemets :</p>
<pre><code>string prenom = "Driss";</code></pre>
                    <p>Mais qui dit "chaîne" dit "ensemble", ainsi, il existe un type pour un caractère unique.</p>
                    <p>Pour en définir un, il suffit de mettre la valeur entre apostrophes :</p>
<pre><code>char a = 'a';</code></pre>
                    <p>Attention, définir plusieurs caractères entre apostrophes, sauf exceptions ci-après, provoquera une erreur de compilation.</p>
                    <p>Certains caractères particuliers et nécessite un traitement particulier.</p>
                    <p>Le caractère ("\") est utilisé pour les définir.</p>
                    <p>Par exemple : le fait qu'une chaîne de caracyères soit entourées par des guillemets, comment est-ce que je peux avoir des guillemets dans ma chaîne ? Ou stocker le caractère apostrophe ?</p>
                    <p>Voici un tableau de références des caractères spéciaux :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Car</th>
                                <th>Signification</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>\'</td>
                                <td>Apostrophe (dans un char)</td>
<pre><code>char apostrophe = '\'';</code></pre>
                            </tr>
                            <tr>
                                <td>\"</td>
                                <td>Guillemet (dans un string)</td>
<pre><code>string jacquesADit = "Jacques a dit : \"Debout !\"";</code></pre>
                            </tr>
                            <tr>
                                <td>\\</td>
                                <td>Antislash</td>
<pre><code>string cheminWindows = "C:\\docs\\fichier.txt";</code></pre>
                            </tr>
                            <tr>
                                <td>\0</td>
                                <td>Null</td>
                            </tr>
                            <tr>
                                <td>\a</td>
                                <td>Alerte (bip sonore)</td>
                            </tr>
                            <tr>
                                <td>\b</td>
                                <td>Retour arrière</td>
                            </tr>
                            <tr>
                                <td>\f</td>
                                <td>Saut de page</td>
                            </tr>
                            <tr>
                                <td>\n</td>
                                <td>Nouvelle ligne</td>
                            </tr>
                            <tr>
                                <td>\r</td>
                                <td>Retour chariot (entrée)</td>
                            </tr>
                            <tr>
                                <td>\t</td>
                                <td>Tabulation (découplage vers la droite)</td>
                            </tr>
                            <tr>
                                <td>\v</td>
                                <td>Tabulation verticale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>L'antislash peut aussi être utilisé pour représenter directement un caractère de la table Unicode : <a href="https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)" target="_blank">https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)</a>.</p>
<pre><code>char copyright = '\u00A9';</code></pre>
                    <p>La manipulation des chaînes de caractères offre des facilités d'échappement grâce à un syntaxe particulière.</p>
                    <p>Le caractère @ avant les guillemets d'ouverture permet de ne pas avoir à échapper les antislashs (mais empêcje l'utilisation des caractères spéciaux) :</p>
<pre><code>string cheminWindowsSimple = @"C:\docs\fichier.txt";</code></pre>
                    <p>Dans ce cas, èle guillemet dans la chaîne doit être doublé :</p>
<pre><code>string jacquesADit2 = @"Jacques a dit : ""Assis !""";</code></pre>
                    <p>Lorsqu'on utilise deux chaînes, il est possible de "mettre l'une dans l'autre" grâce à un procédé particulier : l'interpolation.</p>
                    <p>Le caractère "1" permet d'insérer une valeur entre accolades au sein d'une chaîne (généralement une variable) :</p>
<pre><code>string prenom = "Driss";
string bonjour = $"Bonjour {prenom}";</code></pre>
                    <p>Dans ce cas, la variable bonjour contiendra "Bonjour Driss".</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser l'interpolation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>Les types vus jsuqu'à présent supportent l'utilisation d'opérateurs (comme l'addition ou la soustraction pour deux valeurs numériques).</p>
                    <p>Pour ce faire, on utilisera les caractères suivants :</p>
                    <ul>
                        <li>
                            <p>"+" pour l'addition</p>
                            <li>
                                <p>"-" pour la soustraction</p>
                            </li>
                            <li>
                                <p>"*" pour la multiplication</p>
                            </li>
                            <li>
                                <p>"/" pour la division</p>
                            </li>
                            <li>
                                <p>"%" pour le modulo (reste de la division entière)</p>
                            </li>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de manipuler les opérateurs avec les types numériques.</p>
                    <p>Pour bien commencer :</p>
                    <ul>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Créer deux variables contenant 9 et 2.</p>
                        </li>
                        <li>
                            <p>Faire la totalité des opérateurs mathématiques sur les numériques et constater les résultats !</p>
                        </li>
                    </ul>
                    <p>9 + 2 = 11 // aucun commentaire</p>
                    <p>9 - 2 = 7 // aucun commentaire</p>
                    <p>9 * 2 = 18 // aucun commentaire</p>
                    <p>9 / 2 = 4</p>
                    <ul>
                        <li>
                            <p>Nous divisons un entier par un entier, le résultat doit être entier. Nous avons ici le quotient d'une division Euclidienne. Le reste est calculé par la fonction modulo.</p>
                        </li>
                    </ul>
                    <p>9 % 2 = 1</p>
                    <ul>
                        <li>
                            <p>C'est le reste correspondant à notre division Euclidienne ci-dessus.</p>
                        </li>
                    </ul>
                    <p>Dans le cas des chaînes de caractères, un opérateur a été implémenté afin de réaliser une concaténation.</p>
                    <p>Pour ce faire, on utilisera le caractère "+" afin de concaténer deux chaînes :</p>
<pre><code>string bonjourChaine = "Bonjour " + "Driss";</code></pre>
                    <p>Cela a tout son intérêt lorsqu'on utilise des variables :</p>
<pre><code>string bonjour = "Bonjour ";
string prenom = "Driss";

string bonjourComplet = bonjour + prenom;</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser la concaténation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine("Bonjour " + prenom + ", vous avez " + age + " ans");</code></pre>
                    <p>Rappel : un booléen est une valeur valant vrai (true) ou faux (false).</p>
                    <p>Ainsi, pour savoir si quelque chose est vrai ou faux, il faut une comparaison. Par exemple, on peut tester l'égalité grâce à l'opérateur "==" (attention, double égal) :</p>
<pre><code>int a1 = 42;
int a2 = 43;
bool egaux = a1 == a2; // La variable "egaux" vaudra "false" ici.</code></pre>
                    <p>La différence se teste avec l'opérateur "!=" :</p>
<pre><code>bool different = a1 != a2; // La variable "different" vaudra "true" ici.</code></pre>
                    <p>On peut utiliser également des opérateurs mathématiques traditionnels :</p>
                    <ul>
                        <li>
                            <p>Supérieur à : utilisation du caractère "&gt;"</p>
                        </li>
                        <li>
                            <p>Supérieur ou égal à : utilisation du caractère "&gt;="</p>
                        </li>
                        <li>
                            <p>Inférieur à : utilisation du caractère "&lt;"</p>
                        </li>
                        <li>
                            <p>Inférieur ou égal à : utilisation du caractère "&lt;="</p>
                        </li>
                    </ul>
<pre><code>int a1 = 42;
int a2 = 43;
bool a1PlusGrand = a1 &gt; 10; // Vaudra "true"
bool a2InfOuEgal = a2 &lt;= 100; // Vaudra "true"</code></pre>
                </article>
                <article>
                    <h2 id="conversion_entre_types">La conversion entre types :</h2>
                    <p>Rappel : le langage C# est fortement type, il n'est pas possible de changer le type d'une variable déjà déclarée.</p>
                    <p>Il arrive que l'on ait besoin de convertir une variable d'un type A vers un type B, par exemple, transformer une chaîne de caractères en entier.</p>
                    <p>Il existe de nombreuses façons de créer une variable d'un aure type à partir d'une variable déjà définie.</p>
                    <p>Un des besoins les plus courants est d'obtenir une chaîne de caractères depuis un type quelconque.</p>
                    <p>Nous verrons pourquoi lorsque nous ferons le moddule sur la programmation orientée objet, mais chaque élément C# poss!de une méthode particulière : <span class="html">ToString()</span>.</p>
                    <p>Ainsi, il est possible de transformer un entier en chaîne comme ceci :</p>
<pre><code>int valeurEntiere = 42;
string entierChaine = valeurEntiere.ToString();</code></pre>
                    <p>Lorsqu'on récupère une saisie d'un utilisateur, nous obtenons une valeur de type de chaîne de caractères.</p>
                    <p>Néanmoins, pour certaines opérations (comparaison avec un autre entier, addition...), il faut convertir cette valeur vers un entier.</p>
                    <p>Il y a plusieurs façons de faire cette opération.</p>
                    <p>Une classe très pratique, <span class="html">Convert</span>, nous permet de transformer une valeur vers n'importe quel autre type, sous réserve que cela soit possible :</p>
<pre><code>string valeurChaine = "29";
int vingtNeuf = Convert.ToInt32(valeurChaine);</code></pre>
                    <p>La classe <span class="html">Convert</span> est très pratique, mais beaucoup de types exposent aussi une méthode appelée <span class="html">Parse</span>, comme par exemple :</p>
<pre><code>string saisie = Console.ReadLine();
int saisieEntier = int.Parse(saisie);</code></pre>
                    <p>Attention, au niveau de connaissance actuel, les deux alternatives peuvent être utilisées indistinctement.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables (<span class="html">string</span> pour le prénom et <span class="html">int</span> pour l'âge) et utiliser l'interpolation pour construire la phrase attendue.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="if">L'instruction de test (if) :</h2>
                    <p>Un booléen seul ne présente pas grand intérêt s'il n'est pas testé pour une branche de code.</p>
                    <p>À cet effet, le langage C# propose une instruction pour tester un booléen l'instruction "<span class="em">if</span>".</p>
                    <p>Cette instruction a la syntaxe suivante :</p>
<pre><code>if (booléen)  // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}</code></pre>
                    <p>Lorsqu'on teste une condition, il y a deux possibilités : vrai ou faux.</p>
                    <p>Le bloc défini après l'instruction ne sera exécuté que si la condition renvoie vrai.</p>
                    <p>On peut définir l'autre alternative grâce au mot-clé "<span class="html">else</span>".</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
} else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer si le booléen testé initialement vaut "<span class="em">false</span>".
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Puis d'écrire si la personne est majeure ou mineure (l'âge de la majorité sera défini en constante).</p>
                    <p>Quelques indicatons :</p>
                    <ul>
                        <li>
                            <p>utiliser <span class="html">if</span> et <span class="html">else</span> afin d'afficher uniquement la phrase correspondante.</p>
                        </li>
                        <li>
                            <p>Le test entre les deux valeurs peut être fait directement entre les parenthèses du <span class="em">if</span>.</p>
                        </li>
                    </ul>
<pre><code>const int majorite = 18;
Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");

if (age &gt;= majorite)
{
    Console.WriteLine("Vous êtes majeur");
}
else
{
    Console.WriteLine("Vous êtes mineur");
}</code></pre>
                </article>
                <article>
                    <h2 id="operateurs_booleens">Les opérateurs booléens :</h2>
                    <p>Un booléen peut s'inverser grâce au caractère "<span class="html">!</span>" :</p>
<pre><code>bool estFaux = !true;</code></pre>
                    <p>Bien qu'un booléen ne puisse prendre que deux valeurs (vrai ou faux), la logique répond à l'algèbre de Boole.</p>
                    <p>Ainsi, il existe trois opérateurs en algèbre booléen :</p>
                    <ul>
                        <li>
                            <p>Le<span class="em">ET</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU EXCLUSIF</span></p>
                        </li>
                    </ul>
                    <p>Ces opérateurs prennent deux booléens pour en former un seul.</p>
                    <p>Les tales de résultats de ces opérateurs sont les suivantes :</p>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>ET</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">ET</span> est le "<span class="html">&</span>"."</p>
<pre><code>etVrai = true & true;
bool etFaux = true & false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU</span> est le "<span class="html">|</span>".</p>
<pre><code>bool ouVrai = false | true;
bool ouFaux = false | false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU EXCLUSIF</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU EXCLUSIF</span> est le "<span class="html">^</span>".</p>
<pre><code>bool ouExVrai = true ^ false;
bool ouExFaux = true ^ true;</code></pre>
                    <p>L'opérateur <span class="em">&</span> ou <span class="em">|</span> seul implique que chacune des valeurs sera testée.</p>
                    <p>Lorsqu'on double l'opérateur (donc <span class="em">&&</span> ou <span class="em">||</span>), l'exécution s'arrêtera dès lors qu'une valeur rend la condition fausse.</p>
                    <p>Par exemple :</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true & vrai == true)
{

}</code></pre>
                    <p>Les deux tests seront effectués.</p>
                    <p>Alors que...</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true && vrai == true)
{

}</code></pre>
                    <p>Seulement le premier sera effectué.</p>
                    <h3>Exercice :</h3>
                    <p>Cet exercice est le début de l'implémentation de votre premier projet qui sera un jeu exécutable.</p>
                    <p>Ce jeu, c'est le nombre mystère : le joueur doit deviner le nombre caché en entrant une valeur.</p>
                    <p>Il s'agit ici d'implémenter la logique initiale :</p>
                    <ul>
                        <li>
                            <p>Créer un nouveau projet dédié (appelons le <span class="em">NombreMystere</span>).</p>
                        </li>
                        <li>
                            <p>Définir le nombre mystère en tant que constante.</p>
                        </li>
                        <li>
                            <p>Demander à l'utilisateur de deviner le nombre mystère.</p>
                        </li>
                        <li>
                            <p>Vérifier la valeur avec celle effective :</p>
                            <ul>
                                <li>
                                    <p>Si c'est plus grand, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est plus petit, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est le bon nombre , lui dire qu'il a gagné.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>BONUS : demander en préambule le prénom du joueur pour le conserver, cela nous sera utile par la suite.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
int nbSaisi = int.Parse(Console.ReadLine());

if (nbSaisi == nbMystere)
{
    Console.WriteLine("Vous avez gagné !");
}
else
{
    if (nbSaisi &gt; nbMystere)
    {
        Console.WriteLine("Le nombre mystère est plus petit");
    }
    else
    {
        Console.WriteLine("Le nombre mystère est plus grand");
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="tableaux_listes">Les tableaux et les listes :</h2>
                    <p>Une collection est un ensemble de valeurs réunies.</p>
                    <p>Il existe un grand nombre de collections C#.</p>
                    <p>La première collection qu'on va étudier est la plus simple : le tableau.</p>
                    <p>Un tableau est un ensemble défini d'avance d'éléments du même type, c'est-à-dire qu'on ne pourra pas avoir un tableau qui mélange des chaînes de caractères et des entiers.</p>
                    <p>La syntaxe pour déclarer un tableau est d'utiliser des crochets ("[" et "]") après le type :</p>
<pre><code>string[] tableauDeStrings = new string[10];</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans le tableau.</p>
                        </li>
                        <li>
                            <p><span class="em">[]</span> : doubles crochets vides pour la déclaration du type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer le tableau en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">[10]</span> : doubles crochets avec la taille pour l'affectation de la valeur.</p>
                        </li>
                    </ul>
                    <p>Comme on vient de le voir, un tableau doit être déclaré avec une taille initiale.</p>
                    <p>L'avantage de cette approche est qu'on est très précis sur la mémoire que l'on occupe.</p>
                    <p>L'inconvénient est que le tableau n'est pas facilement redimensionnable.</p>
                    <p>Pour accéder à un élément du tableau (en lecture comme en écriture), on utilisera un index, qui commence à O pour la 1<sup>ère</sup> position, que l'on placera entre les crochets après le nom de la variable :</p>
<pre><code>tableauDeStrings[0] = "toto";
string toto = tableauDeStrings[0];</code></pre>
                    <p>Il est possible de définir les valeurs initiales du tableau en utilisant une syntaxe particulière :</p>
<pre><code>TYPE[] NOM = new TYPE[x] { VALEUR1, VALEUR2, ..., VALEURX };</code></pre>
<pre><code>int[] unACinq = new int[5] { 1, 2, 3, 4, 5 };</code></pre>
                    <p>La force du tableau est sa faible empreinte mémoire, il a une faiblesse indéniable qui est la difficulté de gérer sa taille facilement.</p>
                    <p>Bien heureusement, le framework .NET nous offre une autre type de collection : la liste.</p>
                    <p>De façon sous-jacente, la liste utilise un tableau, mais propose des facilités, car la taille est gérée de façon automatique.</p>
                    <p>Pour utiliser une liste, il faut écrire le code suivant :</p>
<pre><code>List&lt;TYPE&gt; NOM = new List&lt;TYPE&gt;();</code></pre>
                    <p>La syntaxe est très particulière, car elle fait appel à deux notions que nous n'avons encore vues : la construction d'objet et les génériques.</p>
                    <p>Ces notions seront vues en détail plus tard afin de bien comprendre.</p>
                    <p>Par exemple, pour créer une liste de chaîne de caractères :</p>
<pre><code>List&lt;string&gt; chaines = new List&lt;string&gt;();</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans la liste.</p>
                        </li>
                        <li>
                            <p><span class="em">&lt;&gt;</span> : utilisation des chevrons pour encadrer le type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer la liste en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">List&lt;string&gt;</span> : reprise du type complet après le mot-clé "<span class="html">new</span>".</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : double parenthèses comme l'appel d'une fonction.</p>
                        </li>
                    </ul>
                    <p>La liste offre une fonction permettant de facilement ajouter un élément, la fonction <span class="html">Add</span>.</p>
<pre><code>chaines.Add("une valeur");</code></pre>
                    <p>La liste peut s'utiliser comme un tableau à l'aide des index (en mettant le chiffre dans les croches après le nom de la variable).</p>
<pre><code>string valeurListe = chaines[0];</code></pre>
                    <p>Attention, comme le tableau, accéder à un index invalide provoquera un plantage du programme.</p>
                </article>
                <article>
                    <h2 id="boucles">Les boucles :</h2>
                    <p>Il peut arriver qu'il est nécessaire de répéter une action un certain nombre de fois.</p>
                    <p>Par exemple, dans notre jeu, la partie s'arrête dès le premier essai.</p>
                    <p>Or, on souhaiterait peut-être donner plusieurs chances au joueur.</p>
                    <p>Pour ça, il faut utiliser une boucle. On peut créer une boucle :</p>
                    <ul>
                        <li>
                            <p>Qui s'arrête sur la base d'une condition.</p>
                        </li>
                        <li>
                            <p>Qui effectue un nombre de tours défini d'avance.</p>
                        </li>
                        <li>
                            <p>Qui parcourt toutes valeurs d'une collection.</p>
                        </li>
                    </ul>
                    <p>La boucle "for" est une boucle qui prend 3 éléments en considération :</p>
                    <ul>
                        <li>
                            <p>Un état de départ.</p>
                        </li>
                        <li>
                            <P>Une condition de sortie.</P>
                        </li>
                        <li>
                            <p>Une fonction à exécuter à chaque pas.</p>
                        </li>
                    </ul>
                    <p>Elle est généralement utilisée pour faire un nombre défini d'avance de tours.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>for (ÉTAT DE DÉPART ; CONDITION DE SORTIE ; FONCTION)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
<pre><code>for (int i = 0; i &lt; 10; i++)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">for</span> : mot-clé "for" de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">int i = 0</span> : état de départ.</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : attention, séparation par un ";".</p>
                        </li>
                        <li>
                            <p><span class="em">i &lt; 10</span> : condition de sortie.</p>
                        </li>
                        <li>
                            <p><span class="em">i++</span> : fonction à chaque tour de boucle. Ici, c'est une post-incrémentation, c'est-à-dire que ça augmente de 1 la valeur de i.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander à un utilisateur de saisir 3 choses puis de les afficher sur chaque ligne.</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser un tableau pour stocker les nombres.</p>
                        </li>
                        <li>
                            <p>Utiliser la boucle "<span class="html">for</span>" afin d'afficher les éléments. Indice : l'index se trouve dans la boucle et change à chaque tour.</p>
                        </li>
                    </ol>
<pre><code>string[] valeurs = new string[3];

for (int i = 0; i &lt; 3; i++)
{
    Console.WriteLine($"Veuillez saisir la valeur {i + 1}");
    valeurs[i] = Console.ReadLine();
}

for(int i = 0; i &lt; 3; i++)
{
    Console.WriteLine(valeurs[i]);
}</code></pre>
                    <p>La boucle "while" est une boucle qui considère une condition pour s'exécuter.</p>
                    <p>Tant que la conditon ne renvoie pas "false", la boucle dera des tours sans s'arrêter.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>while (condition)
{
    // Comme le "for", on mettra entre accolades le code à effecteuer entre chaque tour de boucle.
}</code></pre>
                    <p>Attention, le compilateur ne vous préviendra pas si votre boucle est infinie !</p>
<pre><code>int entier = 0;
while (entier &lt; 10)
{
    entier++;
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions entre accolades sera exécuté tant que la condition ne sera pas égale à "false".</p>
                        </li>
                        <li>
                            <p><span class="em">entier &lt; 10</span> : condition qui sera évaluée à chaque tour.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur n'a qu'une seule tentative et doit relancer l'application.</p>
                    <p>Il faut transformer le jeu pour que le joueur puisse jouer jusqu'à ce qu'il ait gagné.</p>
                    <p>&#8597; une boucle "<span class="html">while</span>" pour faire que le joueur puisse jouer tant qu'il n'a pas gagné.</p>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;

while (!gagne)
{
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
    int nbSaisi = int.Parse(Console.ReadLine());

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    } else
    {
        if (nbSaisi &gt; nbMystere)
        {
            Console.WriteLine("Le nombre mystère est plus petit");
        }
        else
        {
            Console.WriteLine("Le nombre mystère est plus grand");
        }
    }
}</code></pre>
                    <p>Bien qu'il soit possible de parcourir une collection en entier grâce aux boucles "<span class="html">for</span>" et "<span class="html">while</span>", il exitste une boucle particulière dédiée à cela.</p>
                    <p>La boucle "<span class="html">foreach</span>" permet de prendre chacun des éléments d'une collection, un par un, afin d'effectuer une action.</p>
                    <p>La syntaxe est la suivante :</p>
<pre><code>foreach(TYPE NOM in COLLECTION)
{

}</code></pre>
<pre><code>foreach(int entier in unACinq)
{

}</code></pre>
                    <p>Disséquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions sera exécuté pour chaque élément de la collection parcourue.</p>
                        </li>
                        <li>
                            <p><span class="em">int</span> : type de la variable qui sera déclarée localement.</p>
                        </li>
                        <li>
                            <p><span class="em">entier</span> : nom de la variable qui sera disponible dans le bloc de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">unACinq</span> : collection à parcourir.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur doit remonter dans l'historique du terminal afin de savoir quels chiffres il a déjà joués.</p>
                    <p>Nous allons améliorer l'interface graphique du jeu :</p>
                    <ol>
                        <li>
                            <p>En stockant dans une collection la liste des chiffres déjà joués.</p>
                        </li>
                        <li>
                            <p>En nettoyant la console grâce à <span class="html">Console.Clear()</span> entre chaque tour de jeu.</p>
                        </li>
                        <li>
                            <p>En affichant en début de tour la liste des chiffres déjà joués (utiliser la boucle "<span class="html">foreach</span>").</p>
                        </li>
                    </ol>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");

    int nbSaisi = int.Parse(Console.ReadLine());
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>      
                </article>
                <article>
                    <h2 id="gestion_erreurs">La gestion des erreurs :</h2>
                    <p>Lorsqu'un programme C# rencontre une erreur à l'exécution, l'application cesse de fonctionner si cette erreur n'est pas gérée.</p>
                    <p>Cela s'appelle une <span class="em">exception</span>.</p>
                    <p>Par exemple, le code suivant provoquera une erreur à l'exécution si l'utilisateur ne saisit pas un chiffre valide :</p>
<pre><code>string saisie = Console.ReadLine();
int saisiEntier = int.Parse(saisie);</code></pre>
                    <p>Il est heureusement possible de gérer les erreurs en utilisant un mécanisme particulier : try-catch.</p>
                    <p>Ce mécanisme est défini comme suit :</p>
<pre><code>try
{
    // Bloc contenant le code à "essayer".
}
catch
{
    // Bloc contenant le code en cas d'erreur.
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur peut saisir une valeur différente d'un entier et faire planter l'application.</p>
                    <p>Nous allons améliorer le comportement du jeu :</p>
                    <ul>
                        <li>
                            <p>Si l'utilisateur saisit un chiffre, continuer le déroulé classique du jeu.</p>
                        </li>
                        <li>
                            <p>Si l'utilisateur saisit une autre valeur, afficher un message sur la console lui demandant de corriger sa saisie avant de continuer.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;
const int nbMin = 1;
const int nbMax = 10;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    int nbSaisi = 0;
    while (nbSaisi &lt; nbMin || nbSaisi &gt; nbMax)
    {
        Console.WriteLine($"Veuillez entrer un nombre entre {nbMin} et {nbMax}");
        try
        {
            nbSaisi = int.Parse(Console.ReadLine());
        }
        catch
        {
            nbSaisi = 0;
        }
    }
    
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="conclusion">Conclusion n°1 :</h2>
                    <p>Le contenu jusqu'à présent a été dense, et avant de poursuivre, il faut vous <span class="em">assurer</span> que vous maîtrisez les points suivants :</p>
                    <ol>
                        <li>
                            <p>La différence entre une variable et une constante.</p>
                        </li>
                        <li>
                            <p>Le typage en C#.</p>
                        </li>
                        <li>
                            <p>Les opérations sur les numériques, chaînes de caractères et booléens.</p>
                        </li>
                        <li>
                            <p>Les tests avec <span class="html">if</span> et <span class="html">else</span>.</p>
                        </li>
                        <li>
                            <p>La connaissance élémentaire des collections basiques (tableau et liste).</p>
                        </li>
                        <li>
                            <p>Les boucles <span class="html">for</span>, <span class="html">while</span> et <span class="html">foreach</span>.</p>
                        </li>
                        <li>
                            <p>La gestion des erreurs avec <span class="em">try.catch</span>.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="explications_technologies_" class="NET">Explications sur les technologies .NET :</h2>
                    <p>.NET a fortement évolué ces dernières années, avec l'arrivée de nouvelles solutions et de nouveaux frameworks.</p>
                    <p>Les nouveaux arrivants, les recruteurs et même quelques habitués ont perdus leurs repères.</p>
                    <p>À l'origine, quand .NET est sorti, c'était sous la forme de .NET Framework : une solution de développement sous Windows, exclusivement.</p>
                    <p>Il y avait 3 solutions : des librairies (faire des DLL), des applications graphiques (tout d'abord WinForms, puis plus tard WPF) et du web (ASP.NET WebForms, puis ASP.NET MVC).</p>
                    <p>Il y a eu des problèmes : .NET a été ré-implémenté en open-souce sous le nom Mono, notamment pour ASP.NET. Linux est majoritaire sur les serveurs, et ASP.NET n'était pas compatible.</p>
                    <p>Avec l'arrivée de Windows 10, Microsoft investit sur un nouveau CLR &#894; CoreCLR.</p>
                    <p>Suite à cela, .NET est open-source avec la création de .NET Core 1.0.</p>
                    <p>Mais .NET Framework existe tourjous. .NET Core et .NET Framework partagent un sous-ensemble commun (en dehors du langage).</p>
                    <p>Microsoft a créé un standard, .NET Standard, qui est la définition d'un sous-ensemble du framework comme un standard, accessible aussi bien en .NET Core qu'en .NET Framework (il y a eu 9 versions, en fonction des plateformes et des versions du framework...).</p>
                    <p>Pour résumer, .NET Core est la version open-source multi-plateforme, .NET Framework est la version Windows et .NET Standard est la définition de ce qui est commun entre les différentes versions .NET.</p>
                    <p>Afin de supprimer les incohérences, Microsoft annonce un nouveau .NET, qui se base sur .NET Core, et qui doit devenir "la seule façon de faire .NET".</p>
                    <p>On commence à la version 5, car .NET Core est en 3.1 et .NET Framework en 4.8.</p>
                    <p>Avec .NET on peut faire du web (ASP.NET, Blazor), du Machine Learning (ML.NET), de l'IOT (Runtimes optimisés), des apps Windows (WinForms, WPF, WinUI), des jeux vidéos (Unity) et du mobile (Xamarin, MAUI).</p>
                    <p>Il existes différents frameworks.</p>
                    <p>ASP.NET est dorénavant disponible :</p>
                    <ol>
                        <li>
                            <p>Razor Pages, pour faire des applications "classiques" (comme PHP, mais avec C#).</p>
                        </li>
                        <li>
                            <p>MVC, pareil que ci-dessus, mais avec le pattern du même nom.</p>
                        </li>
                        <li>
                            <p>WebAPI, pour faire des APIs (existe en MVC et Minimal APIs).</p>
                        </li>
                        <li>
                            <p>Blazor, pour faire des SPA (existe en version Serveur et WebAssembly).</p>
                        </li>
                    </ol>
                    <p>Xamarin : Approche historique &#8594; C# compilé en natif.</p>
                    <p>Xamarin Forms : Surcouche graphique pour des composants unifiés.</p>
                    <p>MAUI : Réécriture de Xamarin pour standardiisation et offrir plus de destination.</p>
                    <p>Pour les applications Windows, il y a WinForms (Approche historique, toujours valide), WPF (Propulsé avec Windows Vista) et WinUI (Successeur d'UWP, exclusivement pour Win 10/11 (store)).</p>
                </article>
                <article>
                    <h2 id="poo">La programmation orientée objet :</h2>
                    <p>Les conventions C# :</p>
                    <ul>
                        <li>
                            <p>Nom des champs &#8594; _champ</p>
                        </li>
                        <li>
                            <p>Méthode &#8594; Commence par une lettre majuscule</p>
                            <ul>
                                <li>
                                    <p>Attention Main</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>C# utilise des propriétés plutôt que getter/setter.</p>
                            <ul>
                                <li>
                                    <p>Propriété en Majuscule !</p>
                                </li>
                            </ul>
<pre><code>private readonly DateTime _dateDeNaissance;
public DateTime DateDeNaissance
{
get { return _dateDeNaissance; }
}</code></pre>
                        </li>
                        <li>
                            <p>Propriéts simples auto-implémentées :</p>
<pre><code>public DateDeNaissance { get; set; }</code></pre> 
                        </li>
                    </ul>
                    <p>Le package est une organisation physique et logique et le namespace est une organisation logique.</p>
                    <p>C# utilise un mécanisme d'annotations qui est notamment utilisé pour la sérialisation. Les annotations sont placées entre []. Par exemple : [Serializable].</p>
                    <p>Les interfaces commencent par un "I" (ex : IList, IDictionnary).</p>
                    <p>Les collections disposent d'une classe de base qui correspond au nom de l'interface sans le "I" (ex : List, Dictionnary, ...).</p>
                    <p>Lors l'héritage en Java, toutes les méthodes sont "virtual", c'est-à-dire qu'elles peuvent être redéfinies dans les classes enfants et que le type de l'objet est recherché à l'exécution.</p>
                    <p>Lors de l'héritage en C#, par défaut les méthodes ne sont pas "virtual", c'est-à-dire que le type de l'objet à l'exécution sera la classe la plus haute dans la hiérarchie.</p>
                    <p>Si on veut le même comportement qu'en Java, virtual (parent) et override (enfant).</p>
                    <p>Comme en Java, C# possède un Iterator : <span class="html">IEnumerator</span>. La proriété GetEnulmerator sur les listes, dictionnaires, ...</p>
                    <p>Pour boucler l'itérateur, il existe la méthode <span class="html">it.MoveNext()</span> (hashNext + next en Java)</p>
                    <p>Pour trouver l'objet courant, il y a la propriété <span class="html">it.Current</span>.</p>
                </article>
                <article>
                    <h2 id="linq">LINQ :</h2>
                    <h3>Introduction à LINQ :</h3>
                    <p>LINQ (<span class="em">Langauage Integrated Query</span>) est une innovation de la version 3.5 du .NET Framework qui permet de rapprocher le monde des objets et le monde des données.</p>
                    <p>Le Framework .NET 4.0, quant à lui, a implémenté une nouvelle couche à LINQ. Cette nouvelle couche appelée <span class="em">PLINQ</span>, pour "<span class="em">Parallel LINQ</span>", est un complément à "<span class="em">LINQ To Objects</span>" qui implémente un jeu complet de méthodes afin de combiner la simplicité et la lisibilité de la syntaxe LINQ et la puissance de la programmation parrallèle.</p>
                    <p>Dans de nombreux scénarios, <span class="em">PLINQ</span> peut ainsi augmenter considérablement la vitesse des requêtes "<span class="em">LINQ To Objects</span>", sur de gros volumes de données, en utilisant plus efficacement tous les coeurs disponibles sur l'ordinateur hôte.</p>
                    <p>Cette performance accrue apporte une puissance de calcul haute performance sur le Bureau.</p>
                    <p>Cependant, l'utilisation de <span class="em">PLINQ</span> pour des petits volumes de données est déconseillée en raison des ressources mises en place pour la gestion parallèle qui, au final, risquerait d'alourdir votre application.</p>
                    <p>Traditionnellement, lorsque nous souhaitons réaliser des requêtes sur des données, ces dernières étaient exprimées sous forme de chaînes de caractères sans possibilité de vérification à la compilation et sans prise en charge par "l'IntelliSense".</p>
                    <p>En outre, nous devions apprendre des langages complémentaires en fonction des sources de données (XPath, SQL, TSQL, PL/SQL, ...).</p>
                    <p>Avec LINQ, toute requête prendra la forme d'une construction de langage de premier ordre (C# ou VB). De plus, nous pourrons écrire ces requêtes en utilisant des mots clés du langage et des opérateurs familiers.</p>
                    <p>LINQ a été prévu pour travailler pour travailler avec différentes sources de données :</p>
                    <ul>
                        <li>
                            <p>Collections d'objets fortement typées (<span class="em">LINQ To Objects</span>)</p>
                        </li>
                        <li>
                            <p>Fichiers XML (<span class="em">LINQ To XML</span>)</p>
                        </li>
                        <li>
                            <p>Bases de données SQL Server (<span class="em">LINQ To SQL</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET (<span class="em">LINQ To DataSet</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET Entities Framework (<span class="html">LINQ To Entities</span>)</p>
                        </li>
                    </ul>
                    <h3>Le mot clé "var" :</h3>
                    <p>Ce mot clé est probablement le plus important qu'à apporter LINQ et, bien que nécessaire, le plus controversé aussi.</p>
                    <p>En effet, C# et VB (en mode "Strict") étant des langages "fortement typé", chaque variable doit être déclarée avec un type avant d'être instanciée. Or, le mot clé "var" permet de déclarer des variables dont le type sera implicitement donné par le compilateur lors de la compilation.</p>
                    <p class="em">Si le mot clé "var" est utilisé, la variable doit être instanciée lors de sa déclaration.</p>
<pre><code>static void Main(string[] args)
{
    int i = 5;
    var s = "Hello World !";
    var o = new object();
    
    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>Bien que l'utilisation du mot clé "var" soit permise, il n'en reste que son utilisation abusive risque de nuire à la compréhension du code. Sans oublier que cela implique que nous laisserons le compilateur choisir implicitement, pour nous, le type de la variable.</p>
                    <p>Ce qui en soit pourra poser des problèmes dans le cadre des valeurs littérales et dans le cadre du polymorphisme pour ne citer qu'eux.</p>
<pre><code>static void Main(string[] args)
{
    var i = 5;
    var s = "Hello World !";
    var o = new object();

    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>i sera de type "System.Int32".</p>
                    <p class="em">Par conséquent, lorsque nous connaissons le type à utiliser, nous devrons utiliser ce type plutôt que "var".</p>
                    <h3>Les types anonymes :</h3>
                    <p>Mais, alors pourquoi avoir ajoutée un type "fourre tout" dans un environnement "fortement typé" ?</p>
                    <p>Car LINQ étant un langage puissant, et il se peut que la requête retourne un type qui ne sera connu que lors de la compilation. Ces types sont appelés "Type anonyme".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
}</code></pre>
                    <p>On peut remarquer que, dans LINQ, la convention de nommage des propriétés d'une classe suit généralement les conventions de nommage des propriétés en C#. Selon la convention de style courante en C#, les noms des propriétés commencent par une majuscule (PascalCase).</p>
<pre><code>static void Main(string[] args)
{
    List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
    Contacts.AddRange(new Contact[] {
        new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be"},
        new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be"}
    });

    // On ne prend que le Nom et l'Email du Contatct en créant implicitement un nouveau type.
    // Ce "nouveau type" est un type anonyme.
    var InfosDeContactsChoisies = from Contact c in Contacts
                                  select new { Nom = c.Nom, Email = c.Email };
    
    foreach (var Infos in InfosDeContactsChoisies)
    {
        Console.WriteLine("{0} {1}", Infos.Name, Infos.Email);
    }

    Console.ReadLine();
}</code></pre>
                    <h3>Les expressions "LAMBDA" :</h3>
                    <p>Une expression "LAMBDA" est une fonction anonyme qui peut contenir des expressions et des instructions, cette expression pourra être utilisée pour créer des délégués (delegate) ou des types d'arborescence d'expression.</p>
                    <p>Toutes ces expressions utilisent l'opérateur LAMDBA "=&gt;" qui se lit "conduit à".</p>
<pre><code>class Program
{
   delegate int del(int i);
   
   static void Main(string[] args)
   {
    del Mydelegate = x =&gt; x * x;
    int j = Mydelegate(5);

    Console.WriteLine(j);
    Console.ReadLine();
   }
}</code></pre>
                    <p class="em">Dans l'exemple, nous lirons "x conduit à x fois x".</p>
                    <p>Le côté gauche de l'expression spécifie les paramètres en entrée (le cas échéant) et le côté droit contient le bloc d'expression ou d'instructions.</p>
                    <p>Une expression LAMBDA avec une expression sur le côté est appelée "<span class="em">lambda-expression</span>.</p>
                    <p>Les "lambda-expression" sont utilisées dans la construction d'arborescences d'expression, elle retourne le résultat de l'expression et prend la forme suivante : (Paramètres d'entrée) =&gt; expression.</p>
                    <p>Les parenthèses sont facultatives uniquement dans le cas où nous n'avons qu'un seul paramètre.</p>
                    <p>Dans le cas contraire, elles sont obligatoires :</p>
<pre><code>class Program
{
    delegate long Addition(int x, int y);

    static void Main(string[] args)
    {
        Addition MonAddition = (x, y) =&gt; (long)x + y;

        long j = MonAddition(5, 7);

        Console.WriteLine(j);
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si l'expression ne reçoit aucun paramètre, nous le signalerons par des parenthèses vides.</p>
<pre><code>class Program
{
    delegate bool del();

    static void Main(string[] args)
    {
        del Mydelegate = () =&gt; UneMethode();

        Console.WriteLine(MyDelegate());
        Console.ReadLine();
    }

    static bool UneMethode()
    {
        bool Result = true;
        // ... traitement
        return Result;
    }
}</code></pre>
                    <p class="em">Nous remarquons aussi dans cet exemple que le corps d'une expression "LAMBDA" peut se composer d'un appel de méthode.</p>
                    <p>Il existe un autre type d'expression "LAMBDA", celle qui ont à droite un bloc d'instruction.</p>
                    <p>Elles sont appelées "lambda-instruction". Une "lambda-instruction" est similaire à la "lambda-expression", sauf que les instructions sont mises entre accolades.</p>
                    <p>Bien que le corps d'une "lambda-instruction" puisse contenir une infinité d'instructions; dans la pratique ce nombre est généralement de 2 ou 3.</p>
<pre><code>class Program
{
    delegate void del(string s);

    static void Main(string[] args)
    {
        del MyDelegate = n =&gt; {
            string s = string.Format("Hello {0}!!", n);
            Console.WriteLine(s);
        };

        MyDelegate("Michael");

        Console.ReadLine();
    }
}</code></pre>
                    <p>Nous verrons plus tard que de nombreux "opérateurs de requêtes standard" comportent un paramètre d'entrée dont le type, "Func&lt;T, Result&gt;", fait partie de la famile des délégués génériques.</p>
                    <p>Nous verrons ces opérateurs de requêtes standard dans la partie "LINQ To Object".</p>
<pre><code>public delegate TResult Func&lt;TArg0, TResult&gt;(TArg0 Arg0);</code></pre>
                    <p>Décortiquons la syntaxe ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">TResult</span> : Type de retour.</p>
                        </li>
                        <li>
                            <p><span class="em">TArg0</span> : Type du paramètre.</p>
                        </li>
                    </ul>
                    <p>Ces délégués génériques sont très utiles pour encapsuler des expressions définies par l'utilisateur appliquées à chaque élément dans un ensemble de données.</p>
                    <p>Nous pourrions instancier ce type de délégués comme suit :</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Func&lt;int, bool&gt; EstImpaire = x =&gt; x % 2 == 1;

        Console.WriteLine(EstImpaire(5));
        Console.WriteLine(EstImpaire(4));

        Console.ReadLine();
    }
}</code></pre>
                    <p>Lorsque nous écrivons des expressions "LAMBDA", nous n'aurons généralement pas à spécifier les types de paramètres d'entrées. En effet, le compilateur pourra déduire leur type en fonction du corps du lambda, du type de délégué sous-jacent ainsi que d'autres facteurs décrits dans la spécification du langage C#.</p>
                    <p>Ce qui signifie que nous aurons accès à leurs méthodes et leurs propriétés.</p>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        del Contains = (s1, s2) =&gt; s1.ToUpper().Contains(s2.ToUpper());

        string content = "lu";

        Console.WriteLine(Contains("Hello", content));
        Console.WriteLine(Contains("Aluminium", content));

        Console.ReadLine();
    }
}</code></pre>
                    <h3>Les méthodes d'extension :</h3>
                    <p>Lorsque LINQ est arrivé, il a apporté bon nombre de nouvelles fonctionnalités aux objets du Framework .NET. Les plus communes sont les "opérateurs de requêtes standard LINQ" qui ajoute des fonctionnalités de requête aux types "IEnumerable" et "IEnumerable&lt;&gt;".</p>
                    <p>Ces types d'objets ont donc vu leur nombre de fonctionnalités augmenté mais "Microsoft" n'a pas modifié leur type d'origine. Ils ont utilisé le principe de méthodes d'extension.</p>
                    <p>Ces dernières vont nous permettent d'ajouter des méthodes à des types existants sans créer un type dérivé ou sans devoir modifier et recompiler le type d'origine.</p>
                    <p>Nous allons les définir comme méthodes statiques mais nous appellerons en utilisant la syntaxe de méthode d'instance.</p>
                    <p>Leur paramètre spécifie les types sur lesquels la méthode fonctionne et ce paramètre sera précédé par le modificateur "this".</p>
                    <p class="em">Leurs types héritant du type sur lequel nous avons ajouter une méthode d'extension, hériteront également de la méthode d'extension.</p>
                    <p>Ajoutons la méthode "CompteMot" au type "string".</p>
<pre><code>public static class MesExtensions
{
    public static int CompteMot(this string s)
    {
        return s.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        string s = "Il fait très beau aujourd'hui";

        Console.WriteLine(s.CompteMot());
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si un ou plusieurs paramètres sont nécessaires nous devons simplement les mettre à la suite du premier paramète.</p>
<pre><code>public static long Addition(this int i, params int[] ints)
{
    long result = i;

    foreach (int n in ints)
    {
        result += n;
    }

    return result;
}</code></pre>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(String[] args)
    {
        int x = 7;

        Console.WriteLine(x.Addition(8, 5, 63, 9, 4));
        Console.ReadLine();
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_objects">LINQ To Objects :</h2>
                    <h3>Introduction à LINQ To Objects :</h3>
                    <p><span class="em">LINQ To Objects</span> fait référence à l'utilisation directe de requêtes LINQ, avec n'importe quelle collection "IEnumerable" et "IEnumerable&lt;T&gt;" telles que "List&lt;T&gt;", "Array" ou "Dictionary&lt;Tkey, Tvalue&gt;" définies par l'utilisateur ou retournées par une API du Framework .NET.</p>
                    <p>Auparavant, nous devions écrire des boucles complexes pour spécifier comment récupérer des données d'une collection. Maintenant grâce à LINQ, nous pourrons écrire du code déclaratif qui décrira exactement ce que nous voudrons.</p>
                    <p>Ces requêtes offrent trois principaux avantages par rapport aux boucles :</p>
                    <ul>
                        <li>
                            <p>Elles sont plus concises et lisibles.</p>
                        </li>
                        <li>
                            <p>Elles fournissent des fonctions puissantes de filtrage, de classement et de regroupement avec un minimum de code.</p>
                        </li>
                        <li>
                            <p>Elles peuvent être appliquées à d'autres sources de données avec peu ou pas de changement.</p>
                        </li>
                    </ul>
                    <p>En gros, plus l'opération sur les données à d'autres sources de données avec peu ou pas de changement.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom, c.Nom
                                                    select c;</code></pre>
                    <h3>LINQ &#8594; Query ou pas ! :</h3>
                    <p><span class="em">LINQ</span> étant l'abréviation de "<span class="em">Language Integrated Query</span>", nous pourrions penser qu'il se limite à l'interrogation de données. Mais en réalité, son utilisation peut aller bien au-delà.</p>
<pre><code>string[] ValuesAsStrings = { "110", "987", "205", "341" };
int[] ints = ValuesAsStrings.Select(s =&gt; Int32.Parse(s)).ToArray();

foreach (int i in ints)
{
    Console.WriteLine(i);
}

Console.ReadLine();</code></pre>
                    <p class="em">La conversion de ce tableau de "string" en "int" pourrait être plus simple ?</p>
                    <h3>IEnumerable&lt;T&gt; et séquence :</h3>
                    <p>Cette interface a été implémentée par les tableaux et les classes de collections génériques de C# 2.0. Elle permet, de par son fonctionnement, d'énumérer les éléments d'une collection.</p>
                    <p>Une séquence est un terme logique d'une collection implémentant l'interface "IEnumerable&lt;T&gt;". En d'autres termes, si nous avions une variable de type "IEnumerable&lt;string&gt;", nous pourrons dire que nous avons une séquence de "string".</p>
                    <p>Nous allons voir, par la suite que la plupart des "Opérateurs de requête standard" sont prototypées de façon à retourner une séquence (IEnumerable&lt;T&gt;).</p>
                    <h3>Opérateurs de requête standard :</h3>
                    <p>Les "opérateurs de requête standard" sont les méthodes qui composent le modèle LINQ.</p>
                    <p>Ka plupart de ses méthodes fonctionnent sur des séquences et fournissent des fonctions de requête, notamment le filtrage (Where), la projection (Select), l'agrégation (Sum), le tri (Orderby), etc.</p>
                    <p>Elles sont définies, dans la classe "Enumerable", comme méthodes d'extension à l'interface "IEnumerable", cela implique qu'elles peuvent être appelées sur n'importe quelle collection générique comme méthode d'instance.</p>
                    <p>Ces opérateurs sont regroupés par fonctionnalité :</p>
                    <ul>
                        <li>
                            <p>Agrégation</p>
                        </li>
                        <li>
                            <p>Concaténation</p>
                        </li>
                        <li>
                            <p>Conversion</p>
                        </li>
                        <li>
                            <p>Égalité</p>
                        </li>
                        <li>
                            <p>Élément</p>
                        </li>
                        <li>
                            <p>Ensemble</p>
                        </li>
                        <li>
                            <p>Filtrage</p>
                        </li>
                        <li>
                            <p>Génération</p>
                        </li>
                        <li>
                            <p>Jointure</p>
                        </li>
                        <li>
                            <p>Partitionnement</p>
                        </li>
                        <li>
                            <p>Projection</p>
                        </li>
                        <li>
                            <p>Quantificateur</p>
                        </li>
                        <li>
                            <p>Regroupement</p>
                        </li>
                        <li>
                            <p>Tri</p>
                        </li>
                    </ul>
                    <p class="em">En annexe, vous trouverez la liste complète de ces opérateurs (.NET 3.5) par ordre alphabérique.</p>
                    <h3>Modes d'exécutions :</h3>
                    <p>Les opérateurs de requêtes standard se divisent en 2 modes d'exécution : immédiat et différé.</p>
                    <p>L'exécution immédiate signifie que la source de données est lue et que l'opérateur est effectuée au point où la requête est déclarée dans le code. Ce mode d'exécution vise tous les opérateurs de requête standard qui retournent un résultat unique et non énumérable comme les opérateurs d'agrégation, d'élément, etc.</p>
                    <p>L'exécution différée signifie que l'opération n'est pas effectuée au point où la requête est déclarée dans le code mais qu'elle le sera uniquement que lorsque la variable de requête est énumérée (boucle foreach par exemple).</p>
                    <p>Cela signifie que les résultats de l'exécution de la requête dépendent du contenu de la source de données lorsque la requête est exécutée plutôt que lorsqu'elle est définie. Si la variable de requête est énumérée plusieurs fois, les résultats peuvent s'avérer différents chaque fois. Presque tous les opérateurs de requête standard dont le type de retour est IEnumerable&lt;T&gt; s'exécutent de manière différée.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Certains des opérateurs de requêtes standard, les plus courants, possèdent une syntaxe de mots clé du langage C# qui leur permet d'être appelés dans le cadre d'une expression de requête.</p>
                    <p>Par défaut, pour utiliser LINQ, nous devrions appeler ces opérateurs qui sont des méthodes. L'expression de requête nous offre une forme plus lisible que son équivalent fondé sur des méthodes.</p>
                    <p>Les clausses de requêtes sont traduites en appels de méthodes lors de la compilation.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom,c.Nom
                                                    select c;</code></pre>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
                                                    .Where(c =&gt; c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1))
                                                    .OrderBy(c =&gt; c.Prenom)
                                                    .ThenBy(c =&gt; c.Nom);</code></pre>
                    <p>Une expression de requête doit commencer par une clause "from" et doit se terminer par une clause "select" ou "group". Entre la première clause from et la dernière clause select ou group, elle peut contenir une ou plusieurs clauses facultatives : where, orderby, join, let et même d'autres clauses from supplémentaires.</p>
                    <p>Nous pourrons également utiliser le mot clé "into" pour que le résultat d'une clause "join" ou "group" puisse servir de source pour des clauses de requête supplémentaires dans la même expression de requête.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Liste des Opérateurs supportant l'expression de requête en C# :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Opérateur</th>
                                <th>Syntaxe d'expression de requête</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Cast</td>
                                <td>'from <span class="em">int</span> n in numbers' explicitement typé</td>
                            </tr>
                        </tbody>
                    </table>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="pre.js"></script>
    </body>

</html>