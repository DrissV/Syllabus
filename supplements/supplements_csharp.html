<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>C# et .NET - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_sdk">Installation du SDK</a></li>
                        <li><a href="#premier_projet">Création du premier projet</a></li>
                        <li><a href="#premiere_instruction">Anatomie d'une instruction C#</a></li>
                        <li><a href="#variables_constantes">Les variables et constantes</a></li>
                        <li><a href="#types_en_details">Les types en détails</a></li>
                        <li><a href="#operateurs">Les opérateurs</a></li>
                        <li><a href="#conversion_entre_types">La conversion entre types</a></li>
                        <li><a href="#if">L'instruction de test (if)</a></li>
                        <li><a href="#operateurs_booleens">Les opérateurs booléens</a></li>
                        <li><a href="#tableaux_listes">Les tableaux et les listes</a></li>
                        <li><a href="#boucles">Les boucles</a></li>
                        <li><a href="#gestion_erreurs">La gestion des erreurs</a></li>
                        <li><a href="#conclusion_1">Conclusion n° 1</a></li>
                        <li><a href="#explications_technologies_.NET">Explications sur les technologies .NET</a></li>
                        <li><a href="#poo">La programmation orientée objet</a></li>
                        <li><a href="#asynchronisme">L'asynchronisme</a></li>
                        <li><a href="#linq">LINQ</a></li>
                        <li><a href="#linq_to_objects">LINQ To Objects</a></li>
                        <li><a href="#intro_blazor">Introduction à Blazor</a></li>
                        <li><a href="#entity_framework_blazor">Entity Framework dans Blazor</a></li>
                        <li><a href="#blazor_.NET_8">Blazor en .NET 8</a></li>
                        <li><a href="#ASP.NET_creation_api_web_c#_minimal_apis">ASP.NET : Création d'API Web avec C# et Minimal APIs</a></li>
                        <li><a href="#MVC">Le framework .NET Core MVC</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage C# et le framework .NET :</h1>
                    <p>D'après Christophe Mommer, développeur C# ayant écrit des livres dessus et fait diverses formations : <q>Un développeur C#/.NET n'st pas expert sur toutes les technologies .NET !</q>.</p>
                    <p>Ce cours est un mélange entre les cours de C# et .NET que j'ai eu à l'école, <a href="https://www.youtube.com/@HTSCoding" target="_blank">les formations gratuites sur le sujet trouvées sur YouTube dont celles de Christopher Mommer</a> et <a href="https://www.hts-learning.com/shop" target="_blank">les formations payantes de Christopher Mommer</a>.</p>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage C# (prononcé C Sharp) est un langage de programmation <span class="em">fortement typé</span>, <span class="em">orienté objet</span> et <span class="em">multi-plateforme</span>.</p>
                    <p><span class="em">Fortement typé</span> : chaque élément appartient à un type <span class="em">tout au
                            long de sa vie</span>. Par exemple, si on déclare une variable pour y stocker un entier, on ne
                        pourra JAMAIS y stocker une chaîne de caractères ou une date.</p>
                    <p><span class="em">Orienté objet</span> : approche du développement informatique où l'on peut créer des
                        objets pour y stocker diverses informations.</p>
                    <p><span class="em">Multi-plateforme</span> : le code C# permet de réaliser des applications sur
                        Windows; Mac, téléphone mobile, Web, ... et même votre télévision Samsung !</p>
                    <p>Le C# est <span class="em">compilé</span> par un compilateur qui transforme le code C# en code <span
                            class="em">IL</span> (Intermediate Language).</p>
                    <p>Ce dernier est ensuite interprété par une machine virtuelle (le <span class="em">CLR</span>) qui le
                        transforme en instruction machine.</p>
                    <p>Le gros avantage d'un langage compilé : vérification du code à la compilation.</p>
                    <p>Le compositeur est votre MEILLEUR ami (et il optimise votre code).</p>
                    <p>Le langage de programmation contient un ensemble d'instructions de programmation (comme les
                        conditions, boucles, etc.).</p>
                    <p>Il est fourni avec un framework, .NET, qui contint une collection d'outils prêts à l'emploi.</p>
                    <p>Il existe une version dédiée à Windows (.NET Framework 4.8) et une version multi-plateforme (.NET).
                    </p>
                </article>
                <article>
                    <h2 id="installation_sdk">Installation du SDK :</h2>
                    <p>Le framework .NET 8 s'installe sur tous les systèmes d'exploitation récents (Windows 10/11, Mac OS,
                        Linux).</p>
                        <p>La plateforme de développement .NET Core ne cesse de gagner en popularité dans le monde entier. En effet, de plus en plus d'entreprises sont séduites par sa puissance et sa flexibilité. Par conséquent, les développeurs .NET sont actuellement très demandés sur le marché du travail.</p>
                    <ol>
                        <li>
                            <p>Se rendre à l'URL <a href="https://dotnet.microsoft/com/download"
                                    target="_blank">https://dotnet.microsoft/com/download</a>.</p>
                        </li>
                        <li>
                            <p>Télécharger la dernière version du SDK .NET (et non .NET Core ni .NET Framewrok).</p>
                        </li>
                        <li>
                            <p>Exécuter l'assistant d'installation.</p>
                        </li>
                        <li>
                            <p>Vérifier que l'installation s'est bien passée en tapant dans une invite de commande :</p>
                            <pre><code>dotnet --version</code></pre>
                        </li>
                    </ol>
                    <p>Le SDK (Software Development Kit) installé contient le compilateur et le runtime.</p>
                    <p>Pour coder, il est possible d'utiliser :</p>
                    <ul>
                        <li>
                            <p>Un éditeur de texte (non recommandé)</p>
                        </li>
                        <li>
                            <p>Visual Studio 2022 (Windows et Mac)</p>
                        </li>
                        <li>
                            <p>Visual Studio Code (Windows, Mac & Linux)</p>
                        </li>
                        <li>
                            <p>Rider (Windows, Mac & Linux)</p>
                        </li>
                    </ul>
                    <p>Visual Studio Code est un éditeur de code <span class="em">gratuit</span> et <span
                            class="em">multi-plateforme</span> suffisant pour notre apprentissage.</p>
                    <p>Se rendre à l'adresse <a href="https://code.visualstudio.com/"
                            target="_blank">https://code.visualstudio.com/</a> pour télécharger la dernière version sable
                        correspondant à votre système d'exploitation.</p>
                    <p>Pour avoir tout le confort de travail, il faut configurer VS Code :</p>
                    <ol>
                        <li>
                            <p>Installation de l'extension <span class="em">OmniSharp</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">Bracket Pair Colorizer</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">VS Sharper for C#</span></p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premier_projet">Création du premier projet :</h2>
                    <p>Un projet C# contient le code nécessaire pour créer une application.</p>
                    <p>Pour apprendre, nous allons commencer par créer une application <span class="em">Console</span>.</p>
                    <ol>
                        <li>
                            <p>Ouvrir VS Code dans un dossier défini.</p>
                        </li>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Écrire la commande :</p>
                            <pre><code>dotnet new console -n MonPremierProjet</code></pre>
                        </li>
                    </ol>
                    <p>Lorsque le code est prêt, un programme C# est exécutable.</p>
                    <p>Dans notre cas, nous avons une application console, son exécution se passe donc dans un terminal.</p>
                    <ol>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Au niveau du répertoire où se situe le fichier <span
                                    class="em">MonPremierProjet.csproj</span>, écrire la commande :</p>
                            <pre><code>dotnet run</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premiere_instruction">Anatomie d'une instruction C# :</h2>
                    <p>L'extension d'un fichier C# est "<span class="em">.cs</span>".</p>
                    <p>La ligne est une instruction C# :</p>
                    <pre><code>Console.WriteLine("Hello, World!");</code></pre>
                    <p>Décomposons cette instruction :</p>
                    <ul>
                        <li>
                            <p><span class="em">Console</span> : objet à utiliser</p>
                        </li>
                        <li>
                            <p><span class="em">.</span> : accesseur à un élément de l'objet le précédant</p>
                        </li>
                        <li>
                            <p><span class="em">WriteLine</span> : méthode d'un objet</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : parenthèses pour passage de paramètres</p>
                        </li>
                        <li>
                            <p><span class="em">"Hello, World!"</span> : valeur du paramètre</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : point-virgule en fin d'instruction</p>
                        </li>
                    </ul>
                    <p>Le commentaire commence par <span class="em">//</span> comme dans l'exemple ci-dessous :</p>
<pre><code>// See https://aka.ms/new-console-template for more information</code></pre>
                    <p>Le commentaire permet d'écrire du texte libre à côté du code source (pour donner une indication quelconque). Il existe une autre syntaxe pour le commentaire : celui sur plusieurs lignes :</p>
<pre><code>/* Mon commentaire
sur plusieurs
lignes */</code></pre>
                    <p>Il est bon usage d'ajouter au dessus des méthodes un "<span class="em">summary</span>" qui précise les informations de la méthode comme ce qu'elle fait, les paramètres qui sont associés et éventuellement un paramètre de retour. Il peut aussi arriver qu'on lui précise les erreurs qui peuvent être remontées, etc. :</p>
<pre><code>/// &lt;summary&gt;Méthode qui permet de dire bonjour&lt;/summary&gt;
/// &lt;param name="civilite"&gt;Civilité de la personne (M, MME, ...)&lt;/param&gt;
/// &lt;param name="message"&gt;Message à ajouter au bonjour&lt;/param&gt;
void DireBonjour(string civilite, string message)
{
    // Mon commentaire sur une ligne
    string result = civilite switch
    {
        "M" =&gt; "Monsieur"
        "MME" =&gt; "Madamade"
        "..." =&gt; ""
    }
    /* Mon commentaire
    sur plusieurs
    lignes */
    Console.WriteLine($"Bonjour {result}, {message}");
}</code></pre>
                    <p>L'avantage du summary est quand quelqu'un va utiliser votre méthode, même vous, Visual Studio va automatiquement afficher ses informations.</p>
                    <p>Enfin, les régions vont permettre d'entourer un bloc de code logique et de le replier pour plus de lisibilité. Donc, on tape <span class="html">#region</span> suivi du nom que l'on souhaite lui donnée et on termine avec <span class="html">#endregion</span>.</p>
                    <p>Exercice : Écrire l'instruction C#, à la ligne de la première, permettant d'afficher "J'apprends le C#" :</p>
<pre><code>Console.WriteLine("J'apprends le C#");</code></pre>
                    <p>En C#, le placement des accolades pour définir le corps des fonctions (méthodes) est une une question de style de codage. Il existe deux approches principales : avec les accolades à la ligne ou sur la même ligne que la déclaration de la fonction.</p>
                    <ol>
                        <li>
                            <p>Accolades à la ligne (Allman Style) :</p>
<pre><code>public void Exemple()
{
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                        <li>
                            <p>Accolades sur la même ligne (K&R Style) :</p>
<pre><code>public void Exemple() {
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                    </ol>
                    <p>Les deux styles sont acceptés par le compilateur C# et sont largement une question de préférence personnelle ou de convention d'équipe. Certains développeurs préfèrent l'un sur l'autre pour des raisons de lisibilité, de style, ou même d'adhésion à des normes de codage spécifiques.</p>
                    <p>Dans la suite du cours, on utilisera la première méthode car Visual Studio 2022 l'utilise, mais il est essentiel de choisir un style cohérent au sein d'un projet ou d'une équipe pour maintenir la lisibilité et la cohérence du code.</p>
                </article>
                <article>
                    <h2 id="variables">Les variables et constantes :</h2>
                    <p>Une variable est une donnée que l'on souhaite stocker pour travailler, dont le contenu peut changer.</p>
                    <p>En C#; une variable est <span class="em">fortement typée</span>, c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer.</p>
                    <p>La syntaxe pour déclare une variable est :</p>
<pre><code>TYPE NOM + VALEUR;</code></pre>
                    <p>Quelques-uns des types les plus courants :</p>
                    <ul>
                        <li>
                            <p><span class="em">Entier</span> &#8594; déclaration avec le mot clé "int".</p>
                            <ul>
                                <li>
                                    <p>La valeur est directement écrite en chiffres.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Chaîne de caractères</span> &#8594; déclaration avec le mot clé "string".</p>
                            <ul>
                                <li>
                                    <p>La valeur est écrite entre guillemets.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Booléen</span> &#8594; déclaration avec le mot clé "bool".</p>
                            <ul>
                                <li>
                                    <p>Peut seulement valor "true" (vrai) ou "false" (faux).</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Le nom d'une variable ne peut pas contenir d'espace. Voici quelques exemples de déclaration de variables :</p>
<pre><code>int age = 29;
string prenom = "Driss";
bool estVivant = true;</code></pre>
                    <p>Dans VS Code, ne prêter pas attention au soulignage. Il 'agit d'un avertissement du compilateur comme quoi une variable est déclarée mais non utilisée.</p>
                    <p>Il existe une syntaxe appelée "typage implicite" permettant d'utiliser un mot clé commun (<span class="em">var</span>) pour que le compilateur devine le type en fonction de la valeur.</p>
<pre><code>var NOM = VALEUR</code></pre>
                    <p>Attention, en l'absence de valeur, le comilateur ne peut pas déduire le type, et il est donc illicite de faire uen instruction <span class="html">var NOM</span>.</p>
<pre><code>var taille = 172;
var nom = "Vandenheede";
var faux = false;</code></pre>
                    <p>La syntaxe pour affecter une variable est :</p>
<pre><code>NOM = VALEUR;</code></pre>
                    <p>Cela <span class="em">impose</span> que la variable ait été déclarée au préalable, sinon cela ne fonctionnera pas.</p>
                    <p>Ainsi, il est possible de chnager une valeur d'une variable après sa création.</p>
<pre><code>taille = 200;</code></pre>
                    <p>Une constante est une donnée que l'on souhaite stocker pour travailler, dont le contenu ne changera jamais.</p>
                    <p>En C#, une constante est <span class="em">fortement typée</span> c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer, tout comme sa valeur.</p>
                    <p>La syntaxe pour déclarer une constante est :</p>
<pre><code>const TYPE NOM = VALEUR;</code></pre>
                    <p>Attention, le mot clé "<span class="em">const</span>" est réservé au langage C# et ne peut pas être utilisé comme nom pour une variable ou une constante.</p>
                    <p>Voici quelques exemples :</p>
<pre><code>const int valeur = 42;
const string pays = "Belgique";
const bool vrai = true;</code></pre>
                    <p>Une variable peut aussi être affectée par une valeur renvoyée par une fonction.</p>
                    <p>Par exemple, la fonction <span class="html">Console.ReadLine();</span> attends la saisie de l'utilisateur (finalisée par l'appui sur entrée) ey renvoie cette valeur.</p>
                    <p>Ainsi, on peut récupérer la valeur dans une variable en définissant l'affectation de la valeur comme étant l'appel de la fonction :</p>
<pre><code>var saisie = Console.ReadLine();</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et de lui dire "Bonjour prénom".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="html">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire la valeur.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string saisie = Console.ReadLine();
Console.WriteLine("Bonjour");
Console.WriteLine(saisie);</code></pre>
                </article>
                <article>
                    <h2 id="types_en_details">Les types en détails :</h2>
                    <p>Bien que le langage se réserve des mots-clés pour les types, ceux-ci sont définis au sein du framework .NET.</p>
                    <p>Par exemple, il y a beaucoup de types différents pour représenter un chiffre, selon sa taille, le fait qu'il puisse être négatif ou non, ainsi que s'il peut avoir une virgule ou pas !</p>
                    <p>Voici une table de référence des types numériques :</p>
                    <table class="tableBalises">
                       <thead>
                        <tr>
                            <th>Type en c#</th>
                            <th>Type système</th>
                            <th>Suffixe</th>
                            <th>Taille mémoire</th>
                            <th>Plage</th>
                        </tr>
                       </thead>
                       <tbody>
                        <tr>
                            <th colspan="5">Types entiers signés</th>
                        </tr>
                        <tr>
                            <td>sbyte</td>
                            <td>System.Sbyte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>-2<sup>7</sup> à 2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td>short</td>
                            <td>System.Int16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>-2<sup>15</sup> à 2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td>int</td>
                            <td>System.Int32</td>
                            <td></td>
                            <td>32 bits</td>
                            <td>-2<sup>31</sup> à 2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td>long</td>
                            <td>System.Int64</td>
                            <td>L</td>
                            <td>64 bits</td>
                            <td>-2<sup>63</sup> à 2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types entiers non signés</th>
                        </tr>
                        <tr>
                            <td>byte</td>
                            <td>System.Byte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>0 à 2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ushort</td>
                            <td>System.UInt16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>0 à 2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td>uint</td>
                            <td>System.UInt32</td>
                            <td>U</td>
                            <td>32 bits</td>
                            <td>0 à 2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ulong</td>
                            <td>System.UInt64</td>
                            <td>UL</td>
                            <td>64 bits</td>
                            <td>0 à 2<sup>64</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types réels</th>
                        </tr>
                        <tr>
                            <td>float</td>
                            <td>System.Single</td>
                            <td>F</td>
                            <td>32 bits</td>
                            <td>&#117; -10<sup>45</sup> à 10<sup>38</sup></td>
                        </tr>
                        <tr>
                            <td>double</td>
                            <td>System.Double</td>
                            <td>D</td>
                            <td>64 bits</td>
                            <td>&#117; -10<sup>324</sup> à &#117; 10<sup>308</sup></td>
                        </tr>
                        <tr>
                            <td>decimal</td>
                            <td>System.Decimal</td>
                            <td>M</td>
                            <td>128 bits</td>
                            <td>&#117; -10<sup>28</sup> à &#117; 10<sup>28</sup></td>
                        </tr>
                       </tbody>
                    </table>
                    <p>Les types entiers signés est utilisé lorsque la valeur peut être positif ou négatif.</p>
                    <p>Les types entiers non signés sont l'inverse des types entiers signés dont la valeur minimale est 0.</p>
                    <p>Les types réels est lorsque la valeur est avec une virgule.</p>
                    <p>Quelques détails supplémentaires :</p>
                    <ul>
                        <li>
                            <p>Le type <span class="html">float</span> ou <span class="html">double</span> est recommandé pour les <span class="em">calculs mathématiques</span> (hautre précision) alors que <span class="em">decimal</span> est recommandé pour les <span class="em">calculs financiers</span>.</p>
                        </li>
                        <li>
                            <p>Depuis C# 7, il est possible d'utiliser un séparateur pour les gros chiffres :</p>
<pre><code>int unMilliard = 1_000_000_000;</code></pre>
                        </li>
                        <li>
                            <p>Le suffixe n'est obligatoire que ds'il existe une ambigüité :</p>
<pre><code>var jeVeuxUnLong = 16UL // ici, par défaut, le type aurait été int</code></pre>
                        </li>
                    </ul>
                    <p>Nous avons déjà travaillé avec les chaînes de caractères :</p>
                    <p>Pour en définir une, il suffit de mettre la valeur entre guillemets :</p>
<pre><code>string prenom = "Driss";</code></pre>
                    <p>Mais qui dit "chaîne" dit "ensemble", ainsi, il existe un type pour un caractère unique.</p>
                    <p>Pour en définir un, il suffit de mettre la valeur entre apostrophes :</p>
<pre><code>char a = 'a';</code></pre>
                    <p>Attention, définir plusieurs caractères entre apostrophes, sauf exceptions ci-après, provoquera une erreur de compilation.</p>
                    <p>Certains caractères particuliers et nécessite un traitement particulier.</p>
                    <p>Le caractère ("\") est utilisé pour les définir.</p>
                    <p>Par exemple : le fait qu'une chaîne de caracyères soit entourées par des guillemets, comment est-ce que je peux avoir des guillemets dans ma chaîne ? Ou stocker le caractère apostrophe ?</p>
                    <p>Voici un tableau de références des caractères spéciaux :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Car</th>
                                <th>Signification</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>\'</td>
                                <td>Apostrophe (dans un char)</td>
<pre><code>char apostrophe = '\'';</code></pre>
                            </tr>
                            <tr>
                                <td>\"</td>
                                <td>Guillemet (dans un string)</td>
<pre><code>string jacquesADit = "Jacques a dit : \"Debout !\"";</code></pre>
                            </tr>
                            <tr>
                                <td>\\</td>
                                <td>Antislash</td>
<pre><code>string cheminWindows = "C:\\docs\\fichier.txt";</code></pre>
                            </tr>
                            <tr>
                                <td>\0</td>
                                <td>Null</td>
                            </tr>
                            <tr>
                                <td>\a</td>
                                <td>Alerte (bip sonore)</td>
                            </tr>
                            <tr>
                                <td>\b</td>
                                <td>Retour arrière</td>
                            </tr>
                            <tr>
                                <td>\f</td>
                                <td>Saut de page</td>
                            </tr>
                            <tr>
                                <td>\n</td>
                                <td>Nouvelle ligne</td>
                            </tr>
                            <tr>
                                <td>\r</td>
                                <td>Retour chariot (entrée)</td>
                            </tr>
                            <tr>
                                <td>\t</td>
                                <td>Tabulation (découplage vers la droite)</td>
                            </tr>
                            <tr>
                                <td>\v</td>
                                <td>Tabulation verticale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>L'antislash peut aussi être utilisé pour représenter directement un caractère de la table Unicode : <a href="https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)" target="_blank">https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)</a>.</p>
<pre><code>char copyright = '\u00A9';</code></pre>
                    <p>La manipulation des chaînes de caractères offre des facilités d'échappement grâce à un syntaxe particulière.</p>
                    <p>Le caractère @ avant les guillemets d'ouverture permet de ne pas avoir à échapper les antislashs (mais empêcje l'utilisation des caractères spéciaux) :</p>
<pre><code>string cheminWindowsSimple = @"C:\docs\fichier.txt";</code></pre>
                    <p>Dans ce cas, èle guillemet dans la chaîne doit être doublé :</p>
<pre><code>string jacquesADit2 = @"Jacques a dit : ""Assis !""";</code></pre>
                    <p>Lorsqu'on utilise deux chaînes, il est possible de "mettre l'une dans l'autre" grâce à un procédé particulier : l'interpolation.</p>
                    <p>Le caractère "1" permet d'insérer une valeur entre accolades au sein d'une chaîne (généralement une variable) :</p>
<pre><code>string prenom = "Driss";
string bonjour = $"Bonjour {prenom}";</code></pre>
                    <p>Dans ce cas, la variable bonjour contiendra "Bonjour Driss".</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser l'interpolation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>Les types vus jsuqu'à présent supportent l'utilisation d'opérateurs (comme l'addition ou la soustraction pour deux valeurs numériques).</p>
                    <p>Pour ce faire, on utilisera les caractères suivants :</p>
                    <ul>
                        <li>
                            <p>"+" pour l'addition</p>
                            <li>
                                <p>"-" pour la soustraction</p>
                            </li>
                            <li>
                                <p>"*" pour la multiplication</p>
                            </li>
                            <li>
                                <p>"/" pour la division</p>
                            </li>
                            <li>
                                <p>"%" pour le modulo (reste de la division entière)</p>
                            </li>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de manipuler les opérateurs avec les types numériques.</p>
                    <p>Pour bien commencer :</p>
                    <ul>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Créer deux variables contenant 9 et 2.</p>
                        </li>
                        <li>
                            <p>Faire la totalité des opérateurs mathématiques sur les numériques et constater les résultats !</p>
                        </li>
                    </ul>
                    <p>9 + 2 = 11 // aucun commentaire</p>
                    <p>9 - 2 = 7 // aucun commentaire</p>
                    <p>9 * 2 = 18 // aucun commentaire</p>
                    <p>9 / 2 = 4</p>
                    <ul>
                        <li>
                            <p>Nous divisons un entier par un entier, le résultat doit être entier. Nous avons ici le quotient d'une division Euclidienne. Le reste est calculé par la fonction modulo.</p>
                        </li>
                    </ul>
                    <p>9 % 2 = 1</p>
                    <ul>
                        <li>
                            <p>C'est le reste correspondant à notre division Euclidienne ci-dessus.</p>
                        </li>
                    </ul>
                    <p>Dans le cas des chaînes de caractères, un opérateur a été implémenté afin de réaliser une concaténation.</p>
                    <p>Pour ce faire, on utilisera le caractère "+" afin de concaténer deux chaînes :</p>
<pre><code>string bonjourChaine = "Bonjour " + "Driss";</code></pre>
                    <p>Cela a tout son intérêt lorsqu'on utilise des variables :</p>
<pre><code>string bonjour = "Bonjour ";
string prenom = "Driss";

string bonjourComplet = bonjour + prenom;</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser la concaténation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine("Bonjour " + prenom + ", vous avez " + age + " ans");</code></pre>
                    <p>Rappel : un booléen est une valeur valant vrai (true) ou faux (false).</p>
                    <p>Ainsi, pour savoir si quelque chose est vrai ou faux, il faut une comparaison. Par exemple, on peut tester l'égalité grâce à l'opérateur "==" (attention, double égal) :</p>
<pre><code>int a1 = 42;
int a2 = 43;
bool egaux = a1 == a2; // La variable "egaux" vaudra "false" ici.</code></pre>
                    <p>La différence se teste avec l'opérateur "!=" :</p>
<pre><code>bool different = a1 != a2; // La variable "different" vaudra "true" ici.</code></pre>
                    <p>On peut utiliser également des opérateurs mathématiques traditionnels :</p>
                    <ul>
                        <li>
                            <p>Supérieur à : utilisation du caractère "&gt;"</p>
                        </li>
                        <li>
                            <p>Supérieur ou égal à : utilisation du caractère "&gt;="</p>
                        </li>
                        <li>
                            <p>Inférieur à : utilisation du caractère "&lt;"</p>
                        </li>
                        <li>
                            <p>Inférieur ou égal à : utilisation du caractère "&lt;="</p>
                        </li>
                    </ul>
<pre><code>int a1 = 42;
int a2 = 43;
bool a1PlusGrand = a1 &gt; 10; // Vaudra "true"
bool a2InfOuEgal = a2 &lt;= 100; // Vaudra "true"</code></pre>
                </article>
                <article>
                    <h2 id="conversion_entre_types">La conversion entre types :</h2>
                    <p>Rappel : le langage C# est fortement type, il n'est pas possible de changer le type d'une variable déjà déclarée.</p>
                    <p>Il arrive que l'on ait besoin de convertir une variable d'un type A vers un type B, par exemple, transformer une chaîne de caractères en entier.</p>
                    <p>Il existe de nombreuses façons de créer une variable d'un aure type à partir d'une variable déjà définie.</p>
                    <p>Un des besoins les plus courants est d'obtenir une chaîne de caractères depuis un type quelconque.</p>
                    <p>Nous verrons pourquoi lorsque nous ferons le moddule sur la programmation orientée objet, mais chaque élément C# poss!de une méthode particulière : <span class="html">ToString()</span>.</p>
                    <p>Ainsi, il est possible de transformer un entier en chaîne comme ceci :</p>
<pre><code>int valeurEntiere = 42;
string entierChaine = valeurEntiere.ToString();</code></pre>
                    <p>Lorsqu'on récupère une saisie d'un utilisateur, nous obtenons une valeur de type de chaîne de caractères.</p>
                    <p>Néanmoins, pour certaines opérations (comparaison avec un autre entier, addition...), il faut convertir cette valeur vers un entier.</p>
                    <p>Il y a plusieurs façons de faire cette opération.</p>
                    <p>Une classe très pratique, <span class="html">Convert</span>, nous permet de transformer une valeur vers n'importe quel autre type, sous réserve que cela soit possible :</p>
<pre><code>string valeurChaine = "29";
int vingtNeuf = Convert.ToInt32(valeurChaine);</code></pre>
                    <p>La classe <span class="html">Convert</span> est très pratique, mais beaucoup de types exposent aussi une méthode appelée <span class="html">Parse</span>, comme par exemple :</p>
<pre><code>string saisie = Console.ReadLine();
int saisieEntier = int.Parse(saisie);</code></pre>
                    <p>Attention, au niveau de connaissance actuel, les deux alternatives peuvent être utilisées indistinctement.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables (<span class="html">string</span> pour le prénom et <span class="html">int</span> pour l'âge) et utiliser l'interpolation pour construire la phrase attendue.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="if">L'instruction de test (if) :</h2>
                    <p>Un booléen seul ne présente pas grand intérêt s'il n'est pas testé pour une branche de code.</p>
                    <p>À cet effet, le langage C# propose une instruction pour tester un booléen l'instruction "<span class="em">if</span>".</p>
                    <p>Cette instruction a la syntaxe suivante :</p>
<pre><code>if (booléen)  // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}</code></pre>
                    <p>Lorsqu'on teste une condition, il y a deux possibilités : vrai ou faux.</p>
                    <p>Le bloc défini après l'instruction ne sera exécuté que si la condition renvoie vrai.</p>
                    <p>On peut définir l'autre alternative grâce au mot-clé "<span class="html">else</span>".</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer si le booléen testé initialement vaut "<span class="em">false</span>".
}</code></pre>
                    <p>Il existe également le mot-clé "<span class="html">else if</span>" pour tester un autre booléen. Voici sa syntaxe :</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else if (autreBooléen) // On teste la valeur booléenne entre parenthèses. Ça signifie "sinon si".
{
    // On définit entre accolades le code à effectuer si l'autre booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer tous les autres booléens testés initialement valent "<span class="em">false</span>".
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Puis d'écrire si la personne est majeure ou mineure (l'âge de la majorité sera défini en constante).</p>
                    <p>Quelques indicatons :</p>
                    <ul>
                        <li>
                            <p>utiliser <span class="html">if</span> et <span class="html">else</span> afin d'afficher uniquement la phrase correspondante.</p>
                        </li>
                        <li>
                            <p>Le test entre les deux valeurs peut être fait directement entre les parenthèses du "<span class="em">if</span>".</p>
                        </li>
                    </ul>
<pre><code>const int majorite = 18;
Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");

if (age &gt;= majorite)
{
    Console.WriteLine("Vous êtes majeur");
}
else
{
    Console.WriteLine("Vous êtes mineur");
}</code></pre>
                    <p>On peut utiliser l'instruction <span class="em">switch</span> pour sélectionner l'un des nombreux blocs de code à exécuter. Voici sa syntaxe :</p>
<pre><code>switch (expression)
{
    case x:
        // bloc de code exécuté si "expression == x" est <span class="em">true</span>.
        break;
    case y:
        // bloc de code exécuté si "expression == y" est <span class="em">true</span>.
        break;
    default:
        // bloc de code exécuté par défaut s'il n'y a pas de correspondance de <span class="em">case</span>.
        break;
}</code></pre>
                </article>
                <article>
                    <h2 id="operateurs_booleens">Les opérateurs booléens :</h2>
                    <p>Un booléen peut s'inverser grâce au caractère "<span class="html">!</span>" :</p>
<pre><code>bool estFaux = !true;</code></pre>
                    <p>Bien qu'un booléen ne puisse prendre que deux valeurs (vrai ou faux), la logique répond à l'algèbre de Boole.</p>
                    <p>Ainsi, il existe trois opérateurs en algèbre booléen :</p>
                    <ul>
                        <li>
                            <p>Le<span class="em">ET</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU EXCLUSIF</span></p>
                        </li>
                    </ul>
                    <p>Ces opérateurs prennent deux booléens pour en former un seul.</p>
                    <p>Les tales de résultats de ces opérateurs sont les suivantes :</p>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>ET</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">ET</span> est le "<span class="html">&</span>"."</p>
<pre><code>etVrai = true & true;
bool etFaux = true & false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU</span> est le "<span class="html">|</span>".</p>
<pre><code>bool ouVrai = false | true;
bool ouFaux = false | false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU EXCLUSIF</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU EXCLUSIF</span> est le "<span class="html">^</span>".</p>
<pre><code>bool ouExVrai = true ^ false;
bool ouExFaux = true ^ true;</code></pre>
                    <p>L'opérateur <span class="em">&</span> ou <span class="em">|</span> seul implique que chacune des valeurs sera testée.</p>
                    <p>Lorsqu'on double l'opérateur (donc <span class="em">&&</span> ou <span class="em">||</span>), l'exécution s'arrêtera dès lors qu'une valeur rend la condition fausse.</p>
                    <p>Par exemple :</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true & vrai == true)
{

}</code></pre>
                    <p>Les deux tests seront effectués.</p>
                    <p>Alors que...</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true && vrai == true)
{

}</code></pre>
                    <p>Seulement le premier sera effectué.</p>
                    <h3>Exercice :</h3>
                    <p>Cet exercice est le début de l'implémentation de votre premier projet qui sera un jeu exécutable.</p>
                    <p>Ce jeu, c'est le nombre mystère : le joueur doit deviner le nombre caché en entrant une valeur.</p>
                    <p>Il s'agit ici d'implémenter la logique initiale :</p>
                    <ul>
                        <li>
                            <p>Créer un nouveau projet dédié (appelons le <span class="em">NombreMystere</span>).</p>
                        </li>
                        <li>
                            <p>Définir le nombre mystère en tant que constante.</p>
                        </li>
                        <li>
                            <p>Demander à l'utilisateur de deviner le nombre mystère.</p>
                        </li>
                        <li>
                            <p>Vérifier la valeur avec celle effective :</p>
                            <ul>
                                <li>
                                    <p>Si c'est plus grand, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est plus petit, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est le bon nombre , lui dire qu'il a gagné.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>BONUS : demander en préambule le prénom du joueur pour le conserver, cela nous sera utile par la suite.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
int nbSaisi = int.Parse(Console.ReadLine());

if (nbSaisi == nbMystere)
{
    Console.WriteLine("Vous avez gagné !");
}
else
{
    if (nbSaisi &gt; nbMystere)
    {
        Console.WriteLine("Le nombre mystère est plus petit");
    }
    else
    {
        Console.WriteLine("Le nombre mystère est plus grand");
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="tableaux_listes">Les tableaux et les listes :</h2>
                    <p>Une collection est un ensemble de valeurs réunies.</p>
                    <p>Il existe un grand nombre de collections C#. On distingue les collections génériques et non génériques. Les collections génériques sont typées alors que les non génériques , donc on peut mettre un string et un int dans une collection non générique.</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Non génériques</th>
                                <th>Génériques</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ArrayList</td>
                                <td>List&lt;T&gt;</td>
                                <td>Permet de stocker des éléments comme un tableau dynamique, où les éléments ont un index.</td>
                            </tr>
                            <tr>
                                <td>Hashtable</td>
                                <td>Dictionary&lt;TKey,TValue&gt;</td>
                                <td>Permet de stocker des éléments sous forme de clé-valeur.</td>
                            </tr>
                            <tr>
                                <td>SortedList</td>
                                <td>SortedList&lt;TKey,TValue&gt;</td>
                                <td>Permet de stocker des éléments sous forme de clé-valeur, triée par défaut sur la clé.</td>
                            </tr>
                            <tr>
                                <td>Stack</td>
                                <td>Stack&lt;T&gt;</td>
                                <td>Permet de stocker des éléments selon le principe LIFO (dernier ajouté, premier de la liste).</td>
                            </tr>
                            <tr>
                                <td>Queue</td>
                                <td>Queue&lt;T&gt;</td>
                                <td>Permet de stocker des éléments selon le principe FIFO (premier ajouté, premier de la liste).</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>La première collection qu'on va étudier est la plus simple : le tableau.</p>
                    <p>Un tableau est un ensemble défini d'avance d'éléments du même type, c'est-à-dire qu'on ne pourra pas avoir un tableau qui mélange des chaînes de caractères et des entiers.</p>
                    <p>La syntaxe pour déclarer un tableau est d'utiliser des crochets ("[" et "]") après le type :</p>
<pre><code>string[] tableauDeStrings = new string[10];</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans le tableau.</p>
                        </li>
                        <li>
                            <p><span class="em">[]</span> : doubles crochets vides pour la déclaration du type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer le tableau en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">[10]</span> : doubles crochets avec la taille pour l'affectation de la valeur.</p>
                        </li>
                    </ul>
                    <p>Comme on vient de le voir, un tableau doit être déclaré avec une taille initiale.</p>
                    <p>L'avantage de cette approche est qu'on est très précis sur la mémoire que l'on occupe.</p>
                    <p>L'inconvénient est que le tableau n'est pas facilement redimensionnable.</p>
                    <p>Pour accéder à un élément du tableau (en lecture comme en écriture), on utilisera un index, qui commence à O pour la 1<sup>ère</sup> position, que l'on placera entre les crochets après le nom de la variable :</p>
<pre><code>tableauDeStrings[0] = "toto";
string toto = tableauDeStrings[0];</code></pre>
                    <p>Il est possible de définir les valeurs initiales du tableau en utilisant une syntaxe particulière :</p>
<pre><code>TYPE[] NOM = new TYPE[x] { VALEUR1, VALEUR2, ..., VALEURX };</code></pre>
<pre><code>int[] unACinq = new int[5] { 1, 2, 3, 4, 5 };</code></pre>
                    <p>La force du tableau est sa faible empreinte mémoire, il a une faiblesse indéniable qui est la difficulté de gérer sa taille facilement.</p>
                    <p>Bien heureusement, le framework .NET nous offre une autre type de collection : la liste.</p>
                    <p>De façon sous-jacente, la liste utilise un tableau, mais propose des facilités, car la taille est gérée de façon automatique.</p>
                    <p>Pour utiliser une liste, il faut écrire le code suivant :</p>
<pre><code>List&lt;TYPE&gt; NOM = new List&lt;TYPE&gt;();</code></pre>
                    <p>La syntaxe est très particulière, car elle fait appel à deux notions que nous n'avons encore vues : la construction d'objet et les génériques.</p>
                    <p>Ces notions seront vues en détail plus tard afin de bien comprendre.</p>
                    <p>Par exemple, pour créer une liste de chaîne de caractères :</p>
<pre><code>List&lt;string&gt; chaines = new List&lt;string&gt;();</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans la liste.</p>
                        </li>
                        <li>
                            <p><span class="em">&lt;&gt;</span> : utilisation des chevrons pour encadrer le type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer la liste en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">List&lt;string&gt;</span> : reprise du type complet après le mot-clé "<span class="html">new</span>".</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : double parenthèses comme l'appel d'une fonction.</p>
                        </li>
                    </ul>
                    <p>La liste offre une fonction permettant de facilement ajouter un élément, la fonction <span class="html">Add</span>.</p>
<pre><code>chaines.Add("une valeur");</code></pre>
                    <p>La liste peut s'utiliser comme un tableau à l'aide des index (en mettant le chiffre dans les croches après le nom de la variable).</p>
<pre><code>string valeurListe = chaines[0];</code></pre>
                    <p>Attention, comme le tableau, accéder à un index invalide provoquera un plantage du programme.</p>
                    <p>En gros, ArrayList et List permettent de stocker des éléments comme un tableau dynamique, où les éléments ont un index.</p>
                    <p>Hashtable et Dictionary permettent de stocker des éléments sous forme de clé-valeur.</p>
<pre><code>Dictionary&lt;string,string&gt; col1 = new Dictionary&lt;string,string&gt;();

// Ajouter des éléments
col1.Add("A", "Ligne 1");
col1.Add("B", "Ligne 2");
col1.Add("C", "Ligne 3");

// Supprimer des éléments
col1.Remove("B");

// Récupérer un élément
Console.WriteLine(col1["C"]);

// Parcours de la collection
foreach (DictionaryEntry item in col1)
{
    Console.WriteLine($"Clé : {item.Key}, Valeur : {item.Value}");
}</code></pre>
                    <p>Stack permet de stocker des éléments selon le principe LIFO (dernier ajouté, premier de la liste). C'est ce que l'on appelle une pile.</p>
<pre><code>Stack&lt;string&gt; col1 = new Stack&lt;string&gt;();

// Ajouter des éléments
col1.Push("Ligne 1");
col1.Push("Ligne 2");
col1.Push("Ligne 3");

// Récupérer l'objet en haut de la pile
object elem = col1.Peek(); // Ligne 3
// récupérer l'objet en haut de la pile et le supprime
object elem = col1.Pop(); // Ligne 3

// Parcours de la collection
foreach (string item in col1)
{
    Console.WriteLine(item);
}</code></pre>
                    <p>À l'inverse de la Stack, on retrouve la Queue qui permet de stocker des éléments selon le principe FIFO (premier ajouté, premier de la liste).</p>
<pre><code>Stack&lt;string&gt; col1 = new Stack&lt;string&gt;();

// Ajouter des éléments
col1.Enqueue("Ligne 1");
col1.Enqueue("Ligne 2");
col1.Enqueue("Ligne 3");

// Récupérer l'objet en haut de la pile
object elem = col1.Peek(); // Ligne 1
// récupérer l'objet en haut de la pile et le supprime
object elem = col1.Dequeue(); // Ligne 1

// Parcours de la collection
foreach (string item in col1)
{
    Console.WriteLine(item);
}</code></pre>
                    <p>Les avantages des types génériques sont : la réutilisabilité, la sécurité de type et la performance.</p>
                </article>
                <article>
                    <h2 id="boucles">Les boucles :</h2>
                    <p>Il peut arriver qu'il est nécessaire de répéter une action un certain nombre de fois.</p>
                    <p>Par exemple, dans notre jeu, la partie s'arrête dès le premier essai.</p>
                    <p>Or, on souhaiterait peut-être donner plusieurs chances au joueur.</p>
                    <p>Pour ça, il faut utiliser une boucle. On peut créer une boucle :</p>
                    <ul>
                        <li>
                            <p>Qui s'arrête sur la base d'une condition.</p>
                        </li>
                        <li>
                            <p>Qui effectue un nombre de tours défini d'avance.</p>
                        </li>
                        <li>
                            <p>Qui parcourt toutes valeurs d'une collection.</p>
                        </li>
                    </ul>
                    <p>La boucle "for" est une boucle qui prend 3 éléments en considération :</p>
                    <ul>
                        <li>
                            <p>Un état de départ.</p>
                        </li>
                        <li>
                            <P>Une condition de sortie.</P>
                        </li>
                        <li>
                            <p>Une fonction à exécuter à chaque pas.</p>
                        </li>
                    </ul>
                    <p>Elle est généralement utilisée pour faire un nombre défini d'avance de tours.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>for (ÉTAT DE DÉPART ; CONDITION DE SORTIE ; FONCTION)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
<pre><code>for (int i = 0; i &lt; 10; i++)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">for</span> : mot-clé "for" de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">int i = 0</span> : état de départ.</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : attention, séparation par un ";".</p>
                        </li>
                        <li>
                            <p><span class="em">i &lt; 10</span> : condition de sortie.</p>
                        </li>
                        <li>
                            <p><span class="em">i++</span> : fonction à chaque tour de boucle. Ici, c'est une post-incrémentation, c'est-à-dire que ça augmente de 1 la valeur de i.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander à un utilisateur de saisir 3 choses puis de les afficher sur chaque ligne.</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser un tableau pour stocker les nombres.</p>
                        </li>
                        <li>
                            <p>Utiliser la boucle "<span class="html">for</span>" afin d'afficher les éléments. Indice : l'index se trouve dans la boucle et change à chaque tour.</p>
                        </li>
                    </ol>
<pre><code>string[] valeurs = new string[3];

for (int i = 0; i &lt; 3; i++)
{
    Console.WriteLine($"Veuillez saisir la valeur {i + 1}");
    valeurs[i] = Console.ReadLine();
}

for(int i = 0; i &lt; 3; i++)
{
    Console.WriteLine(valeurs[i]);
}</code></pre>
                    <p>La boucle "while" est une boucle qui considère une condition pour s'exécuter.</p>
                    <p>Tant que la conditon ne renvoie pas "false", la boucle dera des tours sans s'arrêter.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>while (condition)
{
    // Comme le "for", on mettra entre accolades le code à effecteuer entre chaque tour de boucle.
}</code></pre>
                    <p>Attention, le compilateur ne vous préviendra pas si votre boucle est infinie !</p>
<pre><code>int entier = 0;
while (entier &lt; 10)
{
    entier++;
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions entre accolades sera exécuté tant que la condition ne sera pas égale à "false".</p>
                        </li>
                        <li>
                            <p><span class="em">entier &lt; 10</span> : condition qui sera évaluée à chaque tour.</p>
                        </li>
                    </ul>
                    <p>Il existe également le mot clé "<span class="html">do ... while</span>" dont voici la syntaxe :</p>
<pre><code>int entier = 0;
do {
    Console.WriteLine("entier = {0}", entier);
    entier++;
} while (entier &lt; 10);</code></pre>
                    <p>Ça permet d'exécuter au moins une fois le code entre accolades avant de tester la condition.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur n'a qu'une seule tentative et doit relancer l'application.</p>
                    <p>Il faut transformer le jeu pour que le joueur puisse jouer jusqu'à ce qu'il ait gagné.</p>
                    <p>&#8597; une boucle "<span class="html">while</span>" pour faire que le joueur puisse jouer tant qu'il n'a pas gagné.</p>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;

while (!gagne)
{
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
    int nbSaisi = int.Parse(Console.ReadLine());

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            Console.WriteLine("Le nombre mystère est plus petit");
        }
        else
        {
            Console.WriteLine("Le nombre mystère est plus grand");
        }
    }
}</code></pre>
                    <p>Bien qu'il soit possible de parcourir une collection en entier grâce aux boucles "<span class="html">for</span>" et "<span class="html">while</span>", il exitste une boucle particulière dédiée à cela.</p>
                    <p>La boucle "<span class="html">foreach</span>" permet de prendre chacun des éléments d'une collection, un par un, afin d'effectuer une action.</p>
                    <p>La syntaxe est la suivante :</p>
<pre><code>foreach (TYPE NOM in COLLECTION)
{

}</code></pre>
<pre><code>foreach(int entier in unACinq)
{

}</code></pre>
                    <p>Disséquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions sera exécuté pour chaque élément de la collection parcourue.</p>
                        </li>
                        <li>
                            <p><span class="em">int</span> : type de la variable qui sera déclarée localement.</p>
                        </li>
                        <li>
                            <p><span class="em">entier</span> : nom de la variable qui sera disponible dans le bloc de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">unACinq</span> : collection à parcourir.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur doit remonter dans l'historique du terminal afin de savoir quels chiffres il a déjà joués.</p>
                    <p>Nous allons améliorer l'interface graphique du jeu :</p>
                    <ol>
                        <li>
                            <p>En stockant dans une collection la liste des chiffres déjà joués.</p>
                        </li>
                        <li>
                            <p>En nettoyant la console grâce à <span class="html">Console.Clear()</span> entre chaque tour de jeu.</p>
                        </li>
                        <li>
                            <p>En affichant en début de tour la liste des chiffres déjà joués (utiliser la boucle "<span class="html">foreach</span>").</p>
                        </li>
                    </ol>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");

    int nbSaisi = int.Parse(Console.ReadLine());
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>      
                </article>
                <article>
                    <h2 id="gestion_erreurs">La gestion des erreurs :</h2>
                    <p>Lorsqu'un programme C# rencontre une erreur à l'exécution, l'application cesse de fonctionner si cette erreur n'est pas gérée.</p>
                    <p>Cela s'appelle une <span class="em">exception</span>.</p>
                    <p>Par exemple, le code suivant provoquera une erreur à l'exécution si l'utilisateur ne saisit pas un chiffre valide :</p>
<pre><code>string saisie = Console.ReadLine();
int saisiEntier = int.Parse(saisie);</code></pre>
                    <p>Il est heureusement possible de gérer les erreurs en utilisant un mécanisme particulier : try-catch.</p>
                    <p>Ce mécanisme est défini comme suit :</p>
<pre><code>try
{
    // Bloc contenant le code à "essayer".
}
catch
{
    // Bloc contenant le code en cas d'erreur.
}
finally
{
    // Bloc contenant le code à exécuter s'il y a une erreur attrapée ou pas. 
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur peut saisir une valeur différente d'un entier et faire planter l'application.</p>
                    <p>Nous allons améliorer le comportement du jeu :</p>
                    <ul>
                        <li>
                            <p>Si l'utilisateur saisit un chiffre, continuer le déroulé classique du jeu.</p>
                        </li>
                        <li>
                            <p>Si l'utilisateur saisit une autre valeur, afficher un message sur la console lui demandant de corriger sa saisie avant de continuer.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;
const int nbMin = 1;
const int nbMax = 10;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    int nbSaisi = 0;
    while (nbSaisi &lt; nbMin || nbSaisi &gt; nbMax)
    {
        Console.WriteLine($"Veuillez entrer un nombre entre {nbMin} et {nbMax}");
        try
        {
            nbSaisi = int.Parse(Console.ReadLine());
        }
        catch
        {
            nbSaisi = 0;
        }
    }
    
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="conclusion">Conclusion n°1 :</h2>
                    <p>Le contenu jusqu'à présent a été dense, et avant de poursuivre, il faut vous <span class="em">assurer</span> que vous maîtrisez les points suivants :</p>
                    <ol>
                        <li>
                            <p>La différence entre une variable et une constante.</p>
                        </li>
                        <li>
                            <p>Le typage en C#.</p>
                        </li>
                        <li>
                            <p>Les opérations sur les numériques, chaînes de caractères et booléens.</p>
                        </li>
                        <li>
                            <p>Les tests avec <span class="html">if</span> et <span class="html">else</span>.</p>
                        </li>
                        <li>
                            <p>La connaissance élémentaire des collections basiques (tableau et liste).</p>
                        </li>
                        <li>
                            <p>Les boucles <span class="html">for</span>, <span class="html">while</span> et <span class="html">foreach</span>.</p>
                        </li>
                        <li>
                            <p>La gestion des erreurs avec <span class="em">try.catch</span>.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="explications_technologies_" class="NET">Explications sur les technologies .NET :</h2>
                    <p>.NET a fortement évolué ces dernières années, avec l'arrivée de nouvelles solutions et de nouveaux frameworks.</p>
                    <p>Les nouveaux arrivants, les recruteurs et même quelques habitués ont perdus leurs repères.</p>
                    <p>À l'origine, quand .NET est sorti, c'était sous la forme de .NET Framework : une solution de développement sous Windows, exclusivement.</p>
                    <p>Il y avait 3 solutions : des librairies (faire des DLL), des applications graphiques (tout d'abord WinForms, puis plus tard WPF) et du web (ASP.NET WebForms, puis ASP.NET MVC).</p>
                    <p>Il y a eu des problèmes : .NET a été ré-implémenté en open-souce sous le nom Mono, notamment pour ASP.NET. Linux est majoritaire sur les serveurs, et ASP.NET n'était pas compatible.</p>
                    <p>Avec l'arrivée de Windows 10, Microsoft investit sur un nouveau CLR &#894; CoreCLR.</p>
                    <p>Suite à cela, .NET est open-source avec la création de .NET Core 1.0.</p>
                    <p>Mais .NET Framework existe tourjous. .NET Core et .NET Framework partagent un sous-ensemble commun (en dehors du langage).</p>
                    <p>Microsoft a créé un standard, .NET Standard, qui est la définition d'un sous-ensemble du framework comme un standard, accessible aussi bien en .NET Core qu'en .NET Framework (il y a eu 9 versions, en fonction des plateformes et des versions du framework...).</p>
                    <p>Pour résumer, .NET Core est la version open-source multi-plateforme, .NET Framework est la version Windows et .NET Standard est la définition de ce qui est commun entre les différentes versions .NET.</p>
                    <p>Afin de supprimer les incohérences, Microsoft annonce un nouveau .NET, qui se base sur .NET Core, et qui doit devenir "la seule façon de faire .NET".</p>
                    <p>On commence à la version 5, car .NET Core est en 3.1 et .NET Framework en 4.8.</p>
                    <p>Avec .NET on peut faire du web (ASP.NET, Blazor), du Machine Learning (ML.NET), de l'IOT (Runtimes optimisés), des apps Windows (WinForms, WPF, WinUI), des jeux vidéos (Unity) et du mobile (Xamarin, MAUI).</p>
                    <p>Il existes différents frameworks.</p>
                    <p>ASP.NET est dorénavant disponible :</p>
                    <ol>
                        <li>
                            <p>Razor Pages, pour faire des applications "classiques" (comme PHP, mais avec C#).</p>
                        </li>
                        <li>
                            <p>MVC, pareil que ci-dessus, mais avec le pattern du même nom.</p>
                        </li>
                        <li>
                            <p>WebAPI, pour faire des APIs (existe en MVC et Minimal APIs).</p>
                        </li>
                        <li>
                            <p>Blazor, pour faire des SPA (existe en version Serveur et WebAssembly).</p>
                        </li>
                    </ol>
                    <p>Xamarin : Approche historique &#8594; C# compilé en natif.</p>
                    <p>Xamarin Forms : Surcouche graphique pour des composants unifiés.</p>
                    <p>MAUI : Réécriture de Xamarin pour standardiisation et offrir plus de destination.</p>
                    <p>Pour les applications Windows, il y a WinForms (Approche historique, toujours valide), WPF (Propulsé avec Windows Vista) et WinUI (Successeur d'UWP, exclusivement pour Win 10/11 (store)).</p>
                    <p>En résumé, ASP.NET Core est un Framework opebn source (optimisé pour le Cloud) permettant de développer des applications Web modernes. Avec ASP.NET Core, les applications peuvent être développées et exécutées sur Linux, Mac et Windows (elles sont multi-plateformes).</p>
                    <p>L'architecture d'ASP.BET COre est un cadre beaucoup plus léger et modulaire. ASP.NET Core n'est pas basé sur System.Web.dll. Il est basé sur un ensemble de paquets NuGet granulaires et bien factorisés.Donc, pour l'optimisation de votre application, il faudra inclure uniquement les packages NuGet dont vous avez besoin.</p>
                    <p>Les avantages pour les petites applications comprennent une sécurité renforcée, une maintenance réduite, des performances améliorées et une réduction de coûts.</p>
                    <p>Avec ASP.NET Core, il est possible d'héberger sur IIS ou d'auto-héberger dans votre propre processus.</p>
                </article>
                <article>
                    <h2 id="poo">La programmation orientée objet :</h2>
                    <p>Pour rappel, la Programmation Orientée Objet est un moyen de structurer et d'organiser le code de manière logique.</p>
                    <p>Une classe est la description de comment est représenté un objet.</p>
                    <p>Un objet est une instance de la classe, c'est-à-dire son utilisation réelle.</p>
                    <p>Une méthode est une action qu'il est possible de réaliser sur l'objet.</p>
                    <p>L'encapsultaion des données est le fait de restreindre l'accès direct aux méthodes et données d'un objet à l'intérieur de celui-ci. Ses avantages sont :</p>
                    <ul>
                        <li>
                            <p>Contrôle d'accès aux données</p>
                        </li>
                        <li>
                            <p>Flexibilité en cas de modifications</p>
                            <li>
                                <p>Sécurité de l'intégrité des données</p>
                            </li>
                        </li>
                    </ul>
                    <p>Il y a différents niveaux d'accessibilité :</p>
                    <ul>
                        <li>
                            <p><span class="html">public</span> : Les membres sont accessibles de n'importe où dans le code, sans aucune restriction.</p>
                        </li>
                        <li>
                            <p><span class="html">private</span> : Les membres ne sont accessibles que depuis la classe où ils sont déclarés.</p>
                        </li>
                        <li>
                            <p><span class="html">protected</span> Les membres sont accessibles au sein de leur classe et par les classes dérivées.</p>
                        </li>
                        <li>
                            <p><span class="html">internal</span> : Les membres sont accessibles au sein de l'assembly (exe ou dll) où ils sont déclarés.</p>
                        </li>
                        <li>
                            <p><span class="html">protected internal</span> : Les membres sont accessibles au sein de l'assembly (exe ou dll) où ils sont déclarés et également par les classes dérivées.</p>
                        </li>
                        <li>
                            <p><span class="html">private protected</span> Les membres sont accessibles au sein de leur classe et par les classes dérivées, mais uniquement si les classes dérivées sont dans le même assembly.</p>
                        </li>
                    </ul>
                    <p>À noter qu'en l'absence du mot clé d'accessibilité, le membre est considéré comme "private" par défaut.</p>
                    <p>Les conventions C# :</p>
                    <ul>
                        <li>
                            <p>Nom des champs &#8594; _champ</p>
                        </li>
                        <li>
                            <p>Méthode &#8594; Commence par une lettre majuscule</p>
                            <ul>
                                <li>
                                    <p>Attention Main</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>C# utilise des propriétés plutôt que getter/setter.</p>
                            <ul>
                                <li>
                                    <p>Propriété en Majuscule !</p>
                                </li>
                            </ul>
<pre><code>private readonly DateTime _dateDeNaissance;
public DateTime DateDeNaissance
{
    get { return _dateDeNaissance; }
}</code></pre>
                        </li>
                        <li>
                            <p>Propriéts simples auto-implémentées :</p>
<pre><code>public DateDeNaissance { get; set; }</code></pre> 
                        </li>
                    </ul>
                    <p>Exemple :</p>
<pre><code>public class Machine
{
    #region Attributs
    private double _capacite;
    #endregion

    #region Propriétés
    public string Marque { get; set; }
    public string Modele { get; private set; }
    public string NumeroSerie { get; init; }
    public double Capacite
    {
        get { return _capacite; }
        set {
            if (value &lt; 0 || value &gt; 10)
            {
                // déclencher une exception
            }
            _capacite = value;
        }
    }
    #endregion

    #region Constructeurs
    public Machine()
    {
        // Faire quelque chose
    }

    public Machine (string marque, string modele)
    {
        Marque = marque;
        Modele = modele;
    }

    public Machine (string marque, string modele, double capacite)
    {
        Marque = marque;
        Modele = modele;
        Capacite = capacite;
    }
    #endregion

    #region méthodes
    private void VerifierEtatMachine()
    {
        // Faire quelque chose
    }

    private void Nettoyer()
    {
        // Faire quelque chose
    }

    public void Allumer()
    {
        VerifierEtatMachine();
        Nettoyer();
    }
    #endregion
}</code></pre>
                    <p>Avec l'arrivée de .NET 8, il est maintenant possible de déclarer ce qu'on appelle "<span class="em">constructeur primaire</span>" afin de simplifier les déclarations :</p>
<pre><code>public class Machine(string marque, string modele)
{
    public string Marque { get; } = marque;
    public string Modele { get; } = modele;
}</code></pre>
                    <p>On peut créer des objets de la classe Machine comme ceci :</p>
<pre><code>Machine tassimo = new Machine();
tassimo.Marque = "Tassimo";
// ou
Machine tassimo = new Machine { Marque = "Tassimo", NumeroSerie = "AB12" };
// ou encore
machine tassimo = new Machine("Tassimo", "AB12");
Machine tassimo = new Machine("Tassimo", "AB12", 3.2);</code></pre>
                    <p>Le package est une organisation physique et logique et le namespace est une organisation logique.</p>
                    <p>C# utilise un mécanisme d'annotations qui est notamment utilisé pour la sérialisation. Les annotations sont placées entre []. Par exemple : [Serializable].</p>
                    <p>Les interfaces commencent par un "I" (ex : IList, IDictionnary). <span class="em">Implements</span> et <span class="em">Extends</span> se traduisent tous les deux par le caractère "<span class="em">:</span>".</p>
                    <p>Les collections disposent d'une classe de base qui correspond au nom de l'interface sans le "I" (ex : List, Dictionnary, ...).</p>
                    <p>Lors l'héritage en Java, toutes les méthodes sont "virtual", c'est-à-dire qu'elles peuvent être redéfinies dans les classes enfants et que le type de l'objet est recherché à l'exécution.</p>
                    <p>Lors de l'héritage en C#, par défaut les méthodes ne sont pas "virtual", c'est-à-dire que le type de l'objet à l'exécution sera la classe la plus haute dans la hiérarchie.</p>
                    <p>Si on veut le même comportement qu'en Java, virtual (parent) et override (enfant).</p>
                    <p>Comme en Java, C# possède un Iterator : <span class="html">IEnumerator</span>. La proriété GetEnulmerator sur les listes, dictionnaires, ...</p>
                    <p>Pour boucler l'itérateur, il existe la méthode <span class="html">it.MoveNext()</span> (hashNext + next en Java)</p>
                    <p>Pour trouver l'objet courant, il y a la propriété <span class="html">it.Current</span>.</p>
                    <p>Prenons l'exemple de la Machine pour comprendre les notions d'héritage et d'interface :</p>
<pre><code>public interface IMachine
{
    void Allumer();
    void Eteindre();
    void Demarrer(Dosette dosette);
    void Interrompre()
    {
        // Faire quelque chose
    }
}

public abstract class Machine : IMachine
{
    public string Marque { get; init; }
    public string Modele { get; init; }
    public string Capacite { get; init; }

    public virtual void Allumer()
    {
        // Faire quelque chose
    }
    public virtual void Eteindre()
    {
        // Faire quelque chose
    }
    public abstract void Demarrer(Dosette dosette);
}

public class Tassimo : Machine
{
    public Tassimo(string marque, string modele, double capacite)
    {
        Marque = marque;
        Modele = modele;
        Capacite = capacite;
    }

    private void VerifierEtatMachine() { }
    private void VerifierCodeBarre() { }
    private void Nettoyer() { }
    public void Interrompre() { }

    public override void Allumer() { }
    public override void Eteindre() { }
    public override void Demarrer(Dosette dosette)
    {
        // Faire quelque chose
    }
}</code></pre>
                    <p>Il existe égalemnt des méthodes communes qu'il faut redéfinir dans les classes comme la méthode "<span class="em">ToString()</span>" car sans ça la ligne suivante va afficher dans la console : <span class="em">Machine : MonProjet.Machine</span> :</p>
<pre><code>Machine m = new Machine("Tassimo", "AB12", 3.2);
Console.WriteLine($"Machine : { m.ToString() }");</code></pre>
                    <p>On pourra la redéfinir comme ceci :</p>
<pre><code>public class Machine
{
    public override string ToString()
    {
        return $"{marque} {Modele} ({Capacite} litres)";
    }

    public override bool Equals(object? obj) {
        if (obj is Machine m)
        {
            return Marque == m.Marque && Modele == m.Modele && Capacite == m.Capacite;
        }
        return false;
    }

    public override int GetHashCode()
    {
        int hash = 17;
        hash = hash * 23 + (Marque?.GetHashCode() ?? 0);
        hash = hash * 23 + (Modele?.GetHashCode() ?? 0);
        hash = hash * 23 + Capacite.GetHashCode();
        return hash;
    }

    public override void Dispose()
    {
        // Faire quelque chose
    } 
}</code></pre>
                    <p>Un record se déclare comme ceci :</p>
<pre><code>public record Machine(string Marque, string Modele);</code></pre>
                    <p>On peut les appeler comme ceci :</p>
<pre><code>Machien t = new Machine("Tassimo", "AB12);
Machine t2 = new Machine("Tassimo", "AB12");
t.Equals(t2); // true

Machine t3 = t with { Modele = "AB12" };</code></pre>
                </article>
                <article>
                    <h2 id="asynchronisme">L'asynchronisme :</h2>
                    <p>Pour faire de l'asynchronisme en C#, comme dans plusieurs autres langages de programmation, on va s'appuyer principalement sur deux mots clés : <span class="html">async</span> et <span class="html">await</span>.</p>
                    <p>L'asynchronisme est un concept essentiel permettant d'améliorer les performances en permettant à une application penfant l'attente de tâches longues sans bloquer le thread principal.</p>
                    <p>Le mot-clé <span class="em">async</span> permet de déclarer une méthode comme asynchrone. Une méthode asynchrone retourne généralement une <span class="html">Task</span> ou une <span class="html">Task&lt;TResult&gt;</span>, indiquant que son exécution peut être effectuée de manière asynchrone.</p>
<pre><code>public async Task&lt;int&gt; GetNumberAsync()
{
    // Implémentation asynchrone
}</code></pre>
                    <p>L'utilisation du mot-clé <span class="em">await</span> est associée à l'appel des méthodes asynchrones. Il permet de suspendre l'exécution de la méthode jusqu'à ce que la tâche soit complétée.</p>
<pre><code>int number = await GetNumberAsync();
Console.WriteLine(number); // Cette ligne s'exécute après la complétion de GetNumberAsync</code></pre>
                    <p>La classe <span class="em">Task</span> représente une unité de travail asynchrone qui peut être exécutée et gérée de manière indépendante.</p>
                    <p>Pour créer une tâche en C#, on peut utiliser la syntaxe suivante :</p>
<pre><code>Task tache = new Task(() =&gt;
{
    // Code pour une opération longue
});

await tache.Start();</code></pre>
                    <p>Une approche plus concise est d'utiliser la méthode <span class="em">Task.Run</span> pour créer et exécuter une tâcje simultanément :</p>
<pre><code>Task&lt;int&gt; tache2 = Task.Run(() =&gt;
{
    // Code pour une opération longue
    return 123;
});

int result = await tache2;</code></pre>
                    <p>Il est possible de paralléliser les tâches et attendre qu'elles soient toutes exécutées pour passer à la suite. Pour cela, la méthode <span class="em">Task.WhenAll</span> est utile :</p>
<pre><code>Task tache1 = Task.Run(() =&gt;
{
    Console.WriteLine("Début de tâche 1");
    Thread.Sleep(3000); // Attends 3 secondes
    Console.WriteLine("Fin de tâche 1");
});

Task tache2 : Task.Run(() =&gt;
{
    Console.WriteLine("Début de tâche 2");
    Thread.Sleep(500); // Attends 0,5 secondes
    Console.WriteLine("Milieu de tâche 2");
    Thread.Sleep(500); // Attends 0,5 secondes
    Console.WriteLine("Fin de tâche 2");
});

Console.WriteLine("Avant l'exécution");
await Task.WhenAll(tache1, tache2);
Console.WriteLine("Après l'exécution");</code></pre>
                </article>
                <article>
                    <p>Cette approche parallèle peut améliorer les performanceslors de l'exécution des tâches indépendantes les unes des autres.</p>
                    <h2 id="linq">LINQ :</h2>
                    <h3>Introduction à LINQ :</h3>
                    <p>LINQ (<span class="em">Langauage Integrated Query</span>) est une innovation de la version 3.5 du .NET Framework qui permet de rapprocher le monde des objets et le monde des données.</p>
                    <p>Le Framework .NET 4.0, quant à lui, a implémenté une nouvelle couche à LINQ. Cette nouvelle couche appelée <span class="em">PLINQ</span>, pour "<span class="em">Parallel LINQ</span>", est un complément à "<span class="em">LINQ To Objects</span>" qui implémente un jeu complet de méthodes afin de combiner la simplicité et la lisibilité de la syntaxe LINQ et la puissance de la programmation parrallèle.</p>
                    <p>Dans de nombreux scénarios, <span class="em">PLINQ</span> peut ainsi augmenter considérablement la vitesse des requêtes "<span class="em">LINQ To Objects</span>", sur de gros volumes de données, en utilisant plus efficacement tous les coeurs disponibles sur l'ordinateur hôte.</p>
                    <p>Cette performance accrue apporte une puissance de calcul haute performance sur le Bureau.</p>
                    <p>Cependant, l'utilisation de <span class="em">PLINQ</span> pour des petits volumes de données est déconseillée en raison des ressources mises en place pour la gestion parallèle qui, au final, risquerait d'alourdir votre application.</p>
                    <p>Traditionnellement, lorsque nous souhaitons réaliser des requêtes sur des données, ces dernières étaient exprimées sous forme de chaînes de caractères sans possibilité de vérification à la compilation et sans prise en charge par "l'IntelliSense".</p>
                    <p>En outre, nous devions apprendre des langages complémentaires en fonction des sources de données (XPath, SQL, TSQL, PL/SQL, ...).</p>
                    <p>Avec LINQ, toute requête prendra la forme d'une construction de langage de premier ordre (C# ou VB). De plus, nous pourrons écrire ces requêtes en utilisant des mots clés du langage et des opérateurs familiers.</p>
                    <p>LINQ a été prévu pour travailler pour travailler avec différentes sources de données :</p>
                    <ul>
                        <li>
                            <p>Collections d'objets fortement typées (<span class="em">LINQ To Objects</span>)</p>
                        </li>
                        <li>
                            <p>Fichiers XML (<span class="em">LINQ To XML</span>)</p>
                        </li>
                        <li>
                            <p>Bases de données SQL Server (<span class="em">LINQ To SQL</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET (<span class="em">LINQ To DataSet</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET Entities Framework (<span class="html">LINQ To Entities</span>)</p>
                        </li>
                    </ul>
                    <h3>Le mot clé "var" :</h3>
                    <p>Ce mot clé est probablement le plus important qu'à apporter LINQ et, bien que nécessaire, le plus controversé aussi.</p>
                    <p>En effet, C# et VB (en mode "Strict") étant des langages "fortement typé", chaque variable doit être déclarée avec un type avant d'être instanciée. Or, le mot clé "var" permet de déclarer des variables dont le type sera implicitement donné par le compilateur lors de la compilation.</p>
                    <p class="em">Si le mot clé "var" est utilisé, la variable doit être instanciée lors de sa déclaration.</p>
<pre><code>static void Main(string[] args)
{
    int i = 5;
    var s = "Hello World !";
    var o = new object();
    
    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>Bien que l'utilisation du mot clé "var" soit permise, il n'en reste que son utilisation abusive risque de nuire à la compréhension du code. Sans oublier que cela implique que nous laisserons le compilateur choisir implicitement, pour nous, le type de la variable.</p>
                    <p>Ce qui en soit pourra poser des problèmes dans le cadre des valeurs littérales et dans le cadre du polymorphisme pour ne citer qu'eux.</p>
<pre><code>static void Main(string[] args)
{
    var i = 5;
    var s = "Hello World !";
    var o = new object();

    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>i sera de type "System.Int32".</p>
                    <p class="em">Par conséquent, lorsque nous connaissons le type à utiliser, nous devrons utiliser ce type plutôt que "var".</p>
                    <h3>Les types anonymes :</h3>
                    <p>Mais, alors pourquoi avoir ajoutée un type "fourre tout" dans un environnement "fortement typé" ?</p>
                    <p>Car LINQ étant un langage puissant, et il se peut que la requête retourne un type qui ne sera connu que lors de la compilation. Ces types sont appelés "Type anonyme".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
}</code></pre>
                    <p>On peut remarquer que, dans LINQ, la convention de nommage des propriétés d'une classe suit généralement les conventions de nommage des propriétés en C#. Selon la convention de style courante en C#, les noms des propriétés commencent par une majuscule (PascalCase).</p>
<pre><code>static void Main(string[] args)
{
    List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
    Contacts.AddRange(new Contact[] {
        new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be"},
        new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be"}
    });

    // On ne prend que le Nom et l'Email du Contatct en créant implicitement un nouveau type.
    // Ce "nouveau type" est un type anonyme.
    var InfosDeContactsChoisies = from Contact c in Contacts
                                  select new { Nom = c.Nom, Email = c.Email };
    
    foreach (var Infos in InfosDeContactsChoisies)
    {
        Console.WriteLine("{0} {1}", Infos.Name, Infos.Email);
    }

    Console.ReadLine();
}</code></pre>
                    <h3>Les expressions "LAMBDA" :</h3>
                    <p>Une expression "LAMBDA" est une fonction anonyme qui peut contenir des expressions et des instructions, cette expression pourra être utilisée pour créer des délégués (delegate) ou des types d'arborescence d'expression.</p>
                    <p>Toutes ces expressions utilisent l'opérateur LAMDBA "=&gt;" qui se lit "conduit à".</p>
<pre><code>class Program
{
   delegate int del(int i);
   
   static void Main(string[] args)
   {
    del Mydelegate = x =&gt; x * x;
    int j = Mydelegate(5);

    Console.WriteLine(j);
    Console.ReadLine();
   }
}</code></pre>
                    <p class="em">Dans l'exemple, nous lirons "x conduit à x fois x".</p>
                    <p>Le côté gauche de l'expression spécifie les paramètres en entrée (le cas échéant) et le côté droit contient le bloc d'expression ou d'instructions.</p> 
                    <p>Une expression LAMBDA avec une expression sur le côté est appelée "<span class="em">lambda-expression</span>.</p>
                    <p>Le premier avantage d'une expression lambda permet d'écrire du code plus concis. Ce code définit un comportement qui est localisé uniquement là où il est utilisé.</p>
                    <p>Elles sont flexibles car elles sont utilisées dans pas mal de contextes comme les opérations de filtrage, de tri, dans les événements, etc.</p>
                    <p>Les "lambda-expression" sont utilisées dans la construction d'arborescences d'expression, elle retourne le résultat de l'expression et prend la forme suivante : (Paramètres d'entrée) =&gt; expression.</p>
                    <p>Les parenthèses sont facultatives uniquement dans le cas où nous n'avons qu'un seul paramètre.</p>
                    <p>Dans le cas contraire, elles sont obligatoires :</p>
<pre><code>class Program
{
    delegate long Addition(int x, int y);

    static void Main(string[] args)
    {
        Addition MonAddition = (x, y) =&gt; (long)x + y;

        long j = MonAddition(5, 7);

        Console.WriteLine(j);
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si l'expression ne reçoit aucun paramètre, nous le signalerons par des parenthèses vides.</p>
<pre><code>class Program
{
    delegate bool del();

    static void Main(string[] args)
    {
        del Mydelegate = () =&gt; UneMethode();

        Console.WriteLine(MyDelegate());
        Console.ReadLine();
    }

    static bool UneMethode()
    {
        bool Result = true;
        // ... traitement
        return Result;
    }
}</code></pre>
                    <p class="em">Nous remarquons aussi dans cet exemple que le corps d'une expression "LAMBDA" peut se composer d'un appel de méthode.</p>
                    <p>Il existe un autre type d'expression "LAMBDA", celle qui ont à droite un bloc d'instruction.</p>
                    <p>Elles sont appelées "lambda-instruction". Une "lambda-instruction" est similaire à la "lambda-expression", sauf que les instructions sont mises entre accolades.</p>
                    <p>Bien que le corps d'une "lambda-instruction" puisse contenir une infinité d'instructions; dans la pratique ce nombre est généralement de 2 ou 3.</p>
<pre><code>class Program
{
    delegate void del(string s);

    static void Main(string[] args)
    {
        del MyDelegate = n =&gt; {
            string s = string.Format("Hello {0}!!", n);
            Console.WriteLine(s);
        };

        MyDelegate("Michael");

        Console.ReadLine();
    }
}</code></pre>
                    <p>Nous verrons plus tard que de nombreux "opérateurs de requêtes standard" comportent un paramètre d'entrée dont le type, "Func&lt;T, Result&gt;", fait partie de la famile des délégués génériques.</p>
                    <p>Nous verrons ces opérateurs de requêtes standard dans la partie "LINQ To Object".</p>
<pre><code>public delegate TResult Func&lt;TArg0, TResult&gt;(TArg0 Arg0);</code></pre>
                    <p>Décortiquons la syntaxe ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">TResult</span> : Type de retour.</p>
                        </li>
                        <li>
                            <p><span class="em">TArg0</span> : Type du paramètre.</p>
                        </li>
                    </ul>
                    <p>Ces délégués génériques sont très utiles pour encapsuler des expressions définies par l'utilisateur appliquées à chaque élément dans un ensemble de données.</p>
                    <p>Nous pourrions instancier ce type de délégués comme suit :</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Func&lt;int, bool&gt; EstImpaire = x =&gt; x % 2 == 1;

        Console.WriteLine(EstImpaire(5));
        Console.WriteLine(EstImpaire(4));

        Console.ReadLine();
    }
}</code></pre>
                    <p>Lorsque nous écrivons des expressions "LAMBDA", nous n'aurons généralement pas à spécifier les types de paramètres d'entrées. En effet, le compilateur pourra déduire leur type en fonction du corps du lambda, du type de délégué sous-jacent ainsi que d'autres facteurs décrits dans la spécification du langage C#.</p>
                    <p>Ce qui signifie que nous aurons accès à leurs méthodes et leurs propriétés.</p>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        del Contains = (s1, s2) =&gt; s1.ToUpper().Contains(s2.ToUpper());

        string content = "lu";

        Console.WriteLine(Contains("Hello", content));
        Console.WriteLine(Contains("Aluminium", content));

        Console.ReadLine();
    }
}</code></pre>
                    <p>La différence entre <span class="em">Func</span> et <span class="em">Action</span> est que Func possède au moins un type de retour et que Action ne retourne rien. Ils ont tous les deux un maximum de 16 paramères d'entrée.</p>
<pre><code>public int GetCleINSEE(long numero
{
    return (int)(97 - (num %97));
}

Func&lt;long, int&gt; GetCleINSEE = new Func&lt;long, int&gt;(n =&gt; (int)(97 - (n % 97)));

int cle = GetCleINSEE(1720579191241); // cle = 38;

public static void Bonjour (string message)
{
    Console.WriteLine("Bonjour, " + message);
}

Action&lt;string&gt; SayHello = new Action&lt;string&gt;(msg =&gt; Console.WriteLine("Bonjour, " + msg));

SayHello("Driss"); // Affiche "Bonjour, Driss"</code></pre>
                    <h3>Les méthodes d'extension :</h3>
                    <p>Lorsque LINQ est arrivé, il a apporté bon nombre de nouvelles fonctionnalités aux objets du Framework .NET. Les plus communes sont les "opérateurs de requêtes standard LINQ" qui ajoute des fonctionnalités de requête aux types "IEnumerable" et "IEnumerable&lt;&gt;".</p>
                    <p>Ces types d'objets ont donc vu leur nombre de fonctionnalités augmenté mais "Microsoft" n'a pas modifié leur type d'origine. Ils ont utilisé le principe de méthodes d'extension.</p>
                    <p>Ces dernières vont nous permettent d'ajouter des méthodes à des types existants sans créer un type dérivé ou sans devoir modifier et recompiler le type d'origine.</p>
                    <p>Nous allons les définir comme méthodes statiques mais nous appellerons en utilisant la syntaxe de méthode d'instance.</p>
                    <p>Leur paramètre spécifie les types sur lesquels la méthode fonctionne et ce paramètre sera précédé par le modificateur "this".</p>
                    <p class="em">Leurs types héritant du type sur lequel nous avons ajouter une méthode d'extension, hériteront également de la méthode d'extension.</p>
                    <p>Ajoutons la méthode "CompteMot" au type "string".</p>
<pre><code>public static class MesExtensions
{
    public static int CompteMot(this string s)
    {
        return s.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        string s = "Il fait très beau aujourd'hui";

        Console.WriteLine(s.CompteMot());
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si un ou plusieurs paramètres sont nécessaires nous devons simplement les mettre à la suite du premier paramète.</p>
<pre><code>public static long Addition(this int i, params int[] ints)
{
    long result = i;

    foreach (int n in ints)
    {
        result += n;
    }

    return result;
}</code></pre>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(String[] args)
    {
        int x = 7;

        Console.WriteLine(x.Addition(8, 5, 63, 9, 4));
        Console.ReadLine();
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_objects">LINQ To Objects :</h2>
                    <h3>Introduction à LINQ To Objects :</h3>
                    <p><span class="em">LINQ To Objects</span> fait référence à l'utilisation directe de requêtes LINQ, avec n'importe quelle collection "IEnumerable" et "IEnumerable&lt;T&gt;" telles que "List&lt;T&gt;", "Array" ou "Dictionary&lt;Tkey, Tvalue&gt;" définies par l'utilisateur ou retournées par une API du Framework .NET.</p>
                    <p>Auparavant, nous devions écrire des boucles complexes pour spécifier comment récupérer des données d'une collection. Maintenant grâce à LINQ, nous pourrons écrire du code déclaratif qui décrira exactement ce que nous voudrons.</p>
                    <p>Ces requêtes offrent trois principaux avantages par rapport aux boucles :</p>
                    <ul>
                        <li>
                            <p>Elles sont plus concises et lisibles.</p>
                        </li>
                        <li>
                            <p>Elles fournissent des fonctions puissantes de filtrage, de classement et de regroupement avec un minimum de code.</p>
                        </li>
                        <li>
                            <p>Elles peuvent être appliquées à d'autres sources de données avec peu ou pas de changement.</p>
                        </li>
                    </ul>
                    <p>En gros, plus l'opération sur les données à d'autres sources de données avec peu ou pas de changement.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom, c.Nom
                                                    select c;</code></pre>
                    <h3>LINQ &#8594; Query ou pas ! :</h3>
                    <p><span class="em">LINQ</span> étant l'abréviation de "<span class="em">Language Integrated Query</span>", nous pourrions penser qu'il se limite à l'interrogation de données. Mais en réalité, son utilisation peut aller bien au-delà.</p>
<pre><code>string[] ValuesAsStrings = { "110", "987", "205", "341" };
int[] ints = ValuesAsStrings.Select(s =&gt; Int32.Parse(s)).ToArray();

foreach (int i in ints)
{
    Console.WriteLine(i);
}

Console.ReadLine();</code></pre>
                    <p class="em">La conversion de ce tableau de "string" en "int" pourrait être plus simple ?</p>
                    <h3>IEnumerable&lt;T&gt; et séquence :</h3>
                    <p>Cette interface a été implémentée par les tableaux et les classes de collections génériques de C# 2.0. Elle permet, de par son fonctionnement, d'énumérer les éléments d'une collection.</p>
                    <p>Une séquence est un terme logique d'une collection implémentant l'interface "IEnumerable&lt;T&gt;". En d'autres termes, si nous avions une variable de type "IEnumerable&lt;string&gt;", nous pourrons dire que nous avons une séquence de "string".</p>
                    <p>Nous allons voir, par la suite que la plupart des "Opérateurs de requête standard" sont prototypées de façon à retourner une séquence (IEnumerable&lt;T&gt;).</p>
                    <h3>Opérateurs de requête standard :</h3>
                    <p>Les "opérateurs de requête standard" sont les méthodes qui composent le modèle LINQ.</p>
                    <p>Ka plupart de ses méthodes fonctionnent sur des séquences et fournissent des fonctions de requête, notamment le filtrage (Where), la projection (Select), l'agrégation (Sum), le tri (Orderby), etc.</p>
                    <p>Elles sont définies, dans la classe "Enumerable", comme méthodes d'extension à l'interface "IEnumerable", cela implique qu'elles peuvent être appelées sur n'importe quelle collection générique comme méthode d'instance.</p>
                    <p>Ces opérateurs sont regroupés par fonctionnalité :</p>
                    <ul>
                        <li>
                            <p>Agrégation</p>
                        </li>
                        <li>
                            <p>Concaténation</p>
                        </li>
                        <li>
                            <p>Conversion</p>
                        </li>
                        <li>
                            <p>Égalité</p>
                        </li>
                        <li>
                            <p>Élément</p>
                        </li>
                        <li>
                            <p>Ensemble</p>
                        </li>
                        <li>
                            <p>Filtrage</p>
                        </li>
                        <li>
                            <p>Génération</p>
                        </li>
                        <li>
                            <p>Jointure</p>
                        </li>
                        <li>
                            <p>Partitionnement</p>
                        </li>
                        <li>
                            <p>Projection</p>
                        </li>
                        <li>
                            <p>Quantificateur</p>
                        </li>
                        <li>
                            <p>Regroupement</p>
                        </li>
                        <li>
                            <p>Tri</p>
                        </li>
                    </ul>
                    <p class="em">En annexe, vous trouverez la liste complète de ces opérateurs (.NET 3.5) par ordre alphabérique.</p>
                    <h3>Modes d'exécutions :</h3>
                    <p>Les opérateurs de requêtes standard se divisent en 2 modes d'exécution : immédiat et différé.</p>
                    <p>L'exécution immédiate signifie que la source de données est lue et que l'opérateur est effectuée au point où la requête est déclarée dans le code. Ce mode d'exécution vise tous les opérateurs de requête standard qui retournent un résultat unique et non énumérable comme les opérateurs d'agrégation, d'élément, etc.</p>
                    <p>L'exécution différée signifie que l'opération n'est pas effectuée au point où la requête est déclarée dans le code mais qu'elle le sera uniquement que lorsque la variable de requête est énumérée (boucle foreach par exemple).</p>
                    <p>Cela signifie que les résultats de l'exécution de la requête dépendent du contenu de la source de données lorsque la requête est exécutée plutôt que lorsqu'elle est définie. Si la variable de requête est énumérée plusieurs fois, les résultats peuvent s'avérer différents chaque fois. Presque tous les opérateurs de requête standard dont le type de retour est IEnumerable&lt;T&gt; s'exécutent de manière différée.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Certains des opérateurs de requêtes standard, les plus courants, possèdent une syntaxe de mots clé du langage C# qui leur permet d'être appelés dans le cadre d'une expression de requête.</p>
                    <p>Par défaut, pour utiliser LINQ, nous devrions appeler ces opérateurs qui sont des méthodes. L'expression de requête nous offre une forme plus lisible que son équivalent fondé sur des méthodes.</p>
                    <p>Les clausses de requêtes sont traduites en appels de méthodes lors de la compilation.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom,c.Nom
                                                    select c;</code></pre>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
                                                    .Where(c =&gt; c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1))
                                                    .OrderBy(c =&gt; c.Prenom)
                                                    .ThenBy(c =&gt; c.Nom);</code></pre>
                    <p>Une expression de requête doit commencer par une clause "from" et doit se terminer par une clause "select" ou "group". Entre la première clause from et la dernière clause select ou group, elle peut contenir une ou plusieurs clauses facultatives : where, orderby, join, let et même d'autres clauses from supplémentaires.</p>
                    <p>Nous pourrons également utiliser le mot clé "into" pour que le résultat d'une clause "join" ou "group" puisse servir de source pour des clauses de requête supplémentaires dans la même expression de requête.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Liste des Opérateurs supportant l'expression de requête en C# :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Opérateur</th>
                                <th>Syntaxe d'expression de requête</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Cast</td>
                                <td>'from <span class="em">int</span> n in numbers' explicitement typé</td>
                            </tr>
                            <tr>
                                <td>GroupBy</td>
                                <td>'group ... by' ou 'group ... by ... into ...'</td>
                            </tr>
                            <tr>
                                <td>GroupJoin</td>
                                <td>'join ... in ... on ... equals ... into ...'</td>
                            </tr>
                            <tr>
                                <td>Join</td>
                                <td>'join ... in ... on ... equals ...'</td>
                            </tr>
                            <tr>
                                <td>OrderBy</td>
                                <td>'order by ...'</td>
                            </tr>
                            <tr>
                                <td>OrderByDescending</td>
                                <td>'orderby ... descending'</td>
                            </tr>
                            <tr>
                                <td>Select</td>
                                <td>'select'</td>
                            </tr>
                            <tr>
                                <td>SelectMany</td>
                                <td>Plusieurs clauses 'from'</td>
                            </tr>
                            <tr>
                                <td>ThenBy</td>
                                <td>'orderby ..., ...'</td>
                            </tr>
                            <tr>
                                <td>ThenByDescending</td>
                                <td>'orderby ..., ... descending'</td>
                            </tr>
                            <tr>
                                <td>Where</td>
                                <td>'where'</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Les opérateurs courants :</h3>
                    <p>Nous allons à présent faire le tour des opérateurs les plus souvent utilisés en LINQ. Les exemples qui vont suivre seront exécutés sur une liste générique de "Contact".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
    public int AnneeDeNaissance { get; set; }
}

List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
Contacts.AddRange(new Contact[] {
    new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be", AnneeDeNaissance = 1982 },
    new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be", AnneeDeNaissance = 1974 },
    new Contact() { Nom = "Dupuis", Prenom="Thierry", Email="thierry.depuis@cognitic.be", AnneeDeNaissance = 1988 },
    new Contact() { Nom = "Faulkner", Prenom="Stéphane", Email="stephane.faulkner@cognitic.be", AnneeDeNaissance = 1969 },
    new Contact() { Nom = "Selleck", Prenom="Tom", Email="tom.selleck@imdb.com", AnneeDeNaissance = 1945 },
    new Contact() { Nom = "Anderson", Prenom="Richard Dean", Email="richard.dean.anderson@imdb.com", AnneeDeNaissance = 1950 },
    new Contact() { Nom = "Bullock", Prenom="Sandra", Email="sandra.bullock@imdb.com", AnneeDeNaissance = 1964 },
    new Contact() { Nom = "Peppard", Prenom="George", Email="peppard.george@ateam.com", AnneeDeNaissance = 1928 },
    new Contact() { Nom = "Estevez", Prenom="Emilio", Email="emilio.estevez@breakfirstclub.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Moore", Prenom="Demo", Email="demi.moore@imdb.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Willis", Prenom="Bruce", Email="bruce.willis@diehard.com", AnneeDeNaissance = 1955 },

});</code></pre>
                    <p>Voici les opérateurs que nous allons voir :</p>
                    <ul>
                        <li>
                            <p>Opérateurs "Cast&lt;T&gt;" & "OfType&lt;T&gt;"</p>
                        </li>
                        <li>
                            <p>Opérateur "Where"</p>
                        </li>
                        <li>
                            <p>Opérateur "Select"</p>
                        </li>
                        <li>
                            <p>Opérateur "Distinct"</p>
                        </li>
                        <li>
                            <p>Opérateur "SingleOrDefault"</p>
                        </li>
                        <li>
                            <p>Opérateur "FirstOrDefault"</p>
                        </li>
                        <li>
                            <p>Opéreateurs "OrderBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "ThenBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Count" & "LongCount"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Min" & "Max"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Sum" & "Average"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupBy"</p>
                        </li>
                        <li>
                            <p>Opérateur "Join"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupJoin"</p>
                        </li>
                    </ul>
                    <p class="html">Dans certains cas, les oéprateurs ont des surcharges. Pour ne pas rallonger inutilement ce cours, je me contenterai des prototypes de base.</p>
                    <p class="html">Vous trouverez l'ensemble des surcharges sur le site "MSDN" ou dans la classe "Enumerable".</p>
                    <p class="em">J'ajouterai la requête sous forme d'"expression de requête", lorsque l'opérateur supportera cette syntaxe.</p>
                    <h3>Opérateurs "Cast&lt;T&gt;" & "TypeOf&lt;T&gt;" :</h3>
                    <p>La grande majorité des opérateurs de requête LINQ ne peut être utilisée que sur des collections qui implémentent l'interface "IEnumerable&lt;T&gt;"/ Or, aucune des collections présente dans l'espace de nom "System.Collections", telles que Array, ArrayList ou HashTable, n'implémentent cette interface."</p>
                    <p>Mais alors comment utiliser LINQ avec ces collections ?</p>
                    <p>En regardant de plus près la classe "Enumerable" qui implémente les méthodes d'extension de LINQ. Nous retrouvons deux méthodes qui ne sont pas des méthodes d'extension sur l'interface "IEnumerable&lt;T&gt;" mais sur "IEnumerable".</p>
                    <p>Ces deux opérateurs sont là pour transformer une collection "IEnumerable" en une séquence "IEnumerable&lt;T&gt;".</p>
                    <p>Cependant, ces opérateurs sont quelque pei différents l'un de l'autre.</p>
                    <h4>Cast&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet oéprateur va tenter de convertir tous les éléments de la collection en une séquence de type 'T'. Si celle-ci n'y parvient pas, elle lèvera une exception.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.Cast&lt;Contact&gt;();</code></pre>
                    <p>Cet opérateur supporte la syntaxe d'expresion de requête. En spécifiant explicitement le type à utiliser.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = from Contact c in MyArrayList
                                    select c;</code></pre>
                    <h4>OfType&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet opérateur, quant à lui, va filtrer en fonction de leur capacité à être castées dans le type spécifié.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.OfType&lt;Contact&gt;();</code></pre>
                    <p>Cet opérateur n'étant pas supporter par l'expression de requête, voici comment spécifier que l'on utilise "OfType&lt;T&gt;" plutôt que "Cast&lt;T&gt;".</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

// Attention 2 requêtes LINQ imbriquées
IEnumerable&lt;Contact&gt; Result = from c in MyArrayList.OfType&lt;Contact&gt;()
                                    select c;</code></pre>
                    <h4>Préférons "OfType&lt;T&gt;" à "Cast&lt;T&gt;" :</h4>
                    <p>Bien que ces deux opérateurs soient utilisables sur une collection héritée (System.Collection), "Cast&lt;T&gt;" nécessite que tous les éléments aient le type attendu.</p>
                    <p>Pour éviter de générer des excceptions en cas d'incompatibilité de types, préférons-lui l'opérateur "OfType&lt;T&gt;". Par son intermédiaire, seuls les objets pouvant être castés dans le type attendu seront stockés dans la séquence.</p>
                    <p>Les autres seront purement et simplement ignoré.</p>
                    <h3>Opérateur "Where" :</h3>
<pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>L'opérateur "Where" est utilisé pour filtrer une séquence.</p>
                    <p class="em">Cet opérateur utilise le "delegate" générique "Func&lt;T, bool&gt;" vu dans le chapitre précédent.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Where(c =&gt; c.AnneeDeNaissance &gt;= 1950);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    where c.AnneeDeNaissance &gt;= 1950
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateur "Select" :</h3>
<pre><code>public static IEnumerable&lt;TR&gt; Select&lt;T, TR&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TR&gt; selector);</code></pre>
                    <p>L'opérateur "Select" est utilisé pour retourner une séquence d'éléments sélectionnés dans la séquence d'entrée ou à partir d'une portion de la séquence d'entrée.</p>
                    <p>Dans les requêtes LINQ basées sur les appels de méthodes, l'opérateur "Select" est facultatif et sert principalement à sélectionner une portion, en termes de Propriétés, des objets en entrée et de créer de nouveaux types d'objets (types anomymes).</p>
                    <p>Dans les expressions de requête, que l'on crée un type anonyme ou non, celui-ci est obligatoire.</p>
<pre><code>// Sélectionne tous les contacts et retourne une séquence de type "Contact"
IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                         select c;</code></pre>
                    <h4>Création d'un type anonyme :</h4>
                    <p>Pour créer un type anonyme, nous devons joindre à notre select le mot clé "new".</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Nom = c.Nom, Courriel = c.Email });

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <h4>Expresion de requête :</h4>
<pre><code>var QueryResult = from c in Contacts
                             select new { Nom = c.Nom, Courriel = c.Email };

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <p class="em">Création à la volée de propriétés.</p>
                    <h3>Opérateur "Distinct" :</h3>
<pre><code>public static IEnumerable&lt;T&gt; Distinct&lt;T&gt;§(this IEnumerable&lt;T&gt; source);</code></pre>
                    <p>L'opérateur "Ditinct" permet de supprimer les doublons dans une séquence.</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Prenom = c.Prenom }).Distinct();

foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>var QueryResult = (from c in Contacts
                             select new { Prenom = c.Prenom }).Distinct();
                            
foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <p class="html">Le distinct se fait sur la valeur de l'ensemble des propriétés.</p>
                    <h3>Opérateur "SingleOrDefault" :</h3>
                    <p>L'opérateur "SingleOrDefault" retourne un élément unique d'une séquence de type 'T', si la valeur est introuvable, il retourne la valeur de "default(T)".</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre"))
    .SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>Contact QueryResult = (from c in Contacts
                                 where c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre")
                                 select c).SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <p>Cependant, si la requête retourne plus d'un élément, l'opérateur "SingleOrDefault" lèvera une exception.</p>
                    <p class="em">Dans ce cas de figure et afin d'éviter l'erreur, il est conseillé d'utiliser "FirstOrDefault".</p>
                    <h3>Opérateur "FirstOrDefault" :</h3>
<pre><code>public static TSource FirstOrDefault&lt;TSource&gt;(this Ienumerable&lt;TSource&gt; source);</code></pre>
                    <p>L'opérateur "FirstOrDefault" retourne le premier élément d'une séquence de type 'T' ou la valeur de "default(T)" dans le cas ou aucune valeur ne serait trouvée.</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry"))
    .FirstOrDefault();

if (QueryResult != null)
    Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h3>Opérateurs "OrderBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; OrderBy&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; OrderByDescending&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "OrderBy" trie par ordre croissant les éléments d'une séquence sur base d'une clé (propriété). Pour un ordre décroissant, nous devrions utiliser "OrderByDescending". Si nous sous souhaitons trier sur base de plusieurs clés, ces opérateurs doivent être les premiers à être utiliser.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.OrderBy(c =&gt; c.AnneeDeNaissance);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;T&gt; QueryResult = from c in Contacts
                                              orderby c.AnneeDeNaissance
                                              select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "ThenBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; ThenBy&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; ThenByDescending&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>Les opérateurs "ThenBy" (Croissant) et "ThenByDescending" (Décroissant) permet de trier une séquence sur plusieurs clés (propriétés). Nous pouvons avoir autant de clé "ThenBy" ou "ThenByDescending" que nous voulons. Cependant, ceux-ci ne sont utilisables que si un des opérateurs "OrderBy" ou "OrderByDescending' a été déclaré en premier lieu.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
    .OrderBy(c =&gt; c.AnneeDeNaissance)
    .ThenByDescending(c =&gt; c.Nom);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    orderby c.AnneeDeNaissance, c.Nom descending
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "Count" & "LongCount" :</h3>
<pre><code>public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>Ces deux opérateurs comptent le nombre d'éléments dans une collection. Leur différence se situe dans leur type de retour. Ceux-ci peuvent être accompagné d'une expression booléenne qui va permettre de filtrer le nombre d'éléments à compter.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne le nombre de l'ensemble des éléments
Console.WriteLine(string.Format("Nombre total : {0}", ints.Count()));
// retourne le nombre des éléments pairs
Console.WriteLine(string.Format("Nombre d'éléments pairs : {0}", ints.Count(i =&gt; i % 2 == 0)));</code></pre>
                    <h3>Opérateurs "Min" & "Max" :</h3>
                    <p>Comme l'indique leurs noms, les opérateurs "Min" et "Max" retournent respectivement la valeur minimale et maximale d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// retourne la plus petite valeur
Console.WriteLine(string.Format("Minimum : {0}", ints.Min()));
// Retourne la plus grande valeur
Console.WriteLine(string.Format("Maximum : {0}", ints.Max()));
// Retourne l'année de naissance du contact le plus vieux
int AnneeDeNaissance = Contacts.Min(c =&gt; c.AnneeDeNaissance);
Console.WriteLine("Le contatct le plus vieux est né en {0}", AnneeDeNaissance);</code></pre>
                    <p class="html">Voir les différentes surcharges dans la classe "Enumerable".</p>
                    <h3>Opérateurs "Sum" & "Average" :</h3>
                    <p>Les opérateurs "Sum" et "Average" retournent respectivement la somme et la moyenne d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne la somme
Console.WriteLine(string.Format("Somme : {0}", ints.Sum()));
// Retourne la moyenne
Console.WriteLine(string.Format("Moyenne : {0}", ints.Average(i =&gt; (float)i)));
// Retourne l'âge moyen des contacts
Console.WriteLine("L'âge moyen de nos contacts est de {0} ans", DateTime.Now.Year - (int)Contacts.Average(c =&gt; c.AnneeDeNaissance));</code></pre>
                    <h3>Opérateur "GroupBy" :</h3>
<pre><code>public static IEnumerable&lt,IGrouping&lt;TKey, TSource&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "GroupBy" est un peu différent des autres, par défaut celui-ci travaille avec l'interface "IGrouping&lt;TKey, TElement&gt;" qui hérite de "IEnumerable&lt;T&gt;" et intégrant une propriété "Key".</p>
<pre><code>public interface IGrouping&lt;out TKey, out TElement&gt; : IEnumerable&lt;TElement&gt;,, IEnumerable
{
    TKey Key { get; }
}</code></pre>
                    <p>Ce qui donne ceci :</p>
<pre><code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = Contacts
    .GroupBy(c =&gt; c.Email.Substring(c.Email.IndexOf('@') + 1));

foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</code></pre>
                    <p class="html">Il existe plusieurs surcharges, ici c'est la plus utilisée qui est vue.</p>
                    <p>De plus, dans le cadre de l'expression régulière, "GroupBy" ne peut être utilisé avec l'opérateur "Select" excepté dans le cadre du "group ... by ... into ...".</p>
                    <h4>Expression de requête :</h4>
<pre><code></code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = from c in Contacts
                                                                                    group c by c.Email.Substring(c.Email.IndexOf('@') + 1);
                                                            
foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</pre>
                    <p class="em">Notons l'absence de l'opérateur "Select" dans la requête.</p>
                    <p>Dans ce cas, comment utiliser l'opérateur "GroupBy" avec les types anonymes ?</p>
<pre><code>var QueryResult = Contacts
    .Select(c =&gt; new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
    .GroupBy(c =&gt; c.Email.Substring(c.Email.indexOf('@') + 1));

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">En utilisant l'opérateur "Select" avant le "GroupBy"...</p>
                    <h4>Expression de requête :</h4>
<pre><code>var QueryResult = from c2 in (from c in Contacts
                                        select new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
                             group c2 by c2.Email.Substring(c2.Email.indexOf('@') + 1);

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">... qui se traduira par une sous-requête dans l'expression de requête.</p>
                    <h3>Opérateur "Join" :</h3>
                    <p>L'opérateur "Join" est utile pour associer des séquences différentes sur base de valeurs pouvant être comparée pour définir une égalité.</p>
                    <p>La jointure est une opération importante dans les requêtes qui ciblent les sources de données dont les relations ne peuvent pas être suivies directement. Dans la programmation orientée objet, cela pourrait signifier <span class="em">une corrélation entre objets qui n'est pas modélisée</span>.</p>
                    <p class="html">Cette corrélation est fortement utilisée en "LINQ To SQL" & "LINQ To Entities".</p>
                    <p>Quand on parle de jointures, il y en a trois qui reviennent régulièrement :</p>
                    <img src="../images/join_linq.png" alt="">
                    <p>Croisée (Cross Join), Interne (Inner Join), Externe (Outer Join - Left, Right & full). Celles-ci peuvent peuvent être basées sur une équalité "Equi Join" et ou non "Non Equi Join".</p>
                    <p>L'opérateur "Join" en LINQ ne reprend qu'une seule forme de jointure ("Inner Join" basée sur une égalité). Cependant, nous allons voir comment réaliser les autres jointures en utilisant LINQ.</p>
                    <p>Pour les "Cross Join" ou les "Non Equi Join", nous ne pourrons pas utiliser l'opérateur "Join". Cependant, nous pourrons contourner le problème par l'utilisation de plusieurs clauses "from" et l'utilisation de clauses "where".</p>
                    <p>Afin de comprendre les jointures en LINQ, nous allons ajouter une nouvelle classe "RDV" et de nouvelles données (Liste "RendezVous") à notre environnement.</p>
<pre><code>public class RDV
{
    public string Email { get; set; }
    public DateTime Date { get; set; }
}</code></pre>
<pre><code>List&lt;RDV&gt; RendezVous = new List&lt;RDV&gt;();
RendezVous.AddRange(new RDV[] {
    new RDV() { Email = "stephane.faulkner@cognitic.be", Date = new DateTime(2012, 5, 12) },
    new RDV() { Email = "peppard.george@ateam.com", Date = new DateTime(2011, 8, 14) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 19) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 20) },
    new RDV() { Email = "michael.person@cognitic.be", Date = new DateTime(2012, 4, 19) },
});</code></pre>
<pre><code>public static IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; resultSelector);</code></pre>
                    <h4>Inner Join :</h4>
                    <p>Obtenir l'email, le nom, le prénom du contact et la date de tous les rendez-vous.</p>
<pre><code>var QueryResult = Contacts.Join(RendezVous,
                                           c =&gt; c.Email,
                                           rdv =&gt; rdv.Email,
                                           (c, rdv) =&gt; new {
                                            Email = c.Email,
                                            Nom = c.Nom,
                                            Prenom = c.Prenom,
                                            DateRDV = rdv.Date});

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <h5>Expression de requête :</h5>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.Email equals rdv.Email
                             select new {
                                Email = c.Email,
                                Prenom = c.Prenom,
                                DateRDV = rdv.Date
                             };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <p>L'utilisation des types anonymes n'est pas obligatoire dans le cadre des jointures, son emploi résulte en effet de ce que nous allons sélectionner.</p>
                    <p>Exemple : Obtenir les contacts ayant pris rendez-vous.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Join(RendezVous,
                                                                 c =&gt; c.Email,
                                                                 rdv =&gt; rdv.Email,
                                                                 (c, rdv) =&gt; c);</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    join rdv in RendezVous on c.Email equals rdv.Email
                                                    select c;</code></pre>
                    <p class="em">Nous obtenons bien une séquence de Contacts.</p>
                    <h3>Opérateur "GroupJoin" :</h3>
<pre><code>public static IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector);</code></pre>
                    <p>L'opérateur "GroupJoin" travaille de manière comparable à l'opérateur "Join, à ceci près que l'opérateur "Join" ne passe qu'un seul élémént de la séquence interne à la fonction "resultSelector".</p>
                    <p>Cela signifie que si plusieurs éléments de la séquence intérieur (inner) correspondent à un élément de la séquence extérieur (outer), nous aurons plusieurs lignes dans notre "result set".</p>
                    <p>L'opérateur "GroupJoin" va, quant à lui, produire une structure de donnée hiérarchique. Il va associé pour chaque élément de la séquence extérieur les éléments de la séquence intérieure qui le concerne.</p>
                    <p>Si aucun élément de la séquence intérieur n'existe, il retournera une séquence vide.</p>
                    <p>Il s'apparente donc à une Jointure externe gauche ("Left Join").</p>
                    <p>Exemple :</p>
                    <p>Pour tous contacts, obtenir les noms, prénoms et date de rendez-vous éventuels.</p>
<pre><code>var QueryResult = Contacts.GroupJoin(RendezVous,
                                                c =&gt; c.Email,
                                                rdv =&gt; rdv.Email,
                                                (c, rdvs) =&gt; new {
                                                    Email = c.Email,
                                                    Prenom = c.Prenom,
                                                    RendezVous = rdvs
                                                });

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h4>Expression de requête :</h4>
                    <p>Dans le cadre de l'expression de requêtes, nous devons ajouter l'expression "into" à notre jointure.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.EDmail equals rdv.Email into grdvs
                             select new { Nom = c.Nom, Prenom = c.Prenom, RendezVous = grdvs };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h3>Utilisation de clés composites :</h3>
                    <p>Dans le cadre de jointures, nous sommes parfois amené à gérer les clés étrangères utilisant plusieurs champs (clé composite) et "LINQ" n'échappe à la règle. Afin de résoudre ce "problème" nous devrons utiliser les classes anonymes.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on new { c.ID, c.Email } equals new { rdv.ID, rdv.Email }
                            select new { c.Nom, c.Prenom, rdv.Date };

var QueryResult2 = Contacts.Join(RendezVous,
                                c =&gt; new { c.ID, c.Email },
                                rdv =&gt; new { rdv.ID, rdv.Email },
                                (c, rdv) =&gt; new { c.Nom, c.Prenom, rdv.Date });

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                    <h3>Multiple clause "from" :</h3>
                    <p>Nous venons de voir que les jointures en "LINQ" sont des jointures internes basées sur une égalité. Comment, dans ce cas, faire une jointure croisée ("Cross Join") ou une "Non Equi Join" ?</p>
                    <p>Elles ne sont possibles que dans le cadre des expressions de requêtes en utilisant plusieurs clauses "from".</p>
                    <h4>Exemple de "Cross Join" :</h4>
<pre><code>var QueryResult = from c in Contacts
                             from rdv in RendezVous
                             select new { c.Nom, c.Prenom, rdv.Date };

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_entities">LINQ Providers :</h2>
                    <p>Dans LINQ, le concept de "<span class="html">DataContext</span>" est souvent associé aux fournisseurs LINQ, qui sont des implémentations spécifiques de LUNQ pour différentes sources de données. Un "<span class="html">DataContext</span>" est une classe qui représente la connexion à la source de données et fournit un moyen de récupérer et de manipuler les données.</p>
                    <img src="../images/linq_providers.gif" alt="">
                    <p>Chaque fournisseur LINQ a sa propre implémentation de "<span class="html">DataContext</span>" qui est spécifique à la source de données qu'il cible. je vais expliquer cela en relation avec deux fournisseurs LINQ populaires : LINQ To SQL et LINQ To Entities.</p>
                    <h3>LINQ To SQL :</h3>
                    <p>Dans LINQ To SQL, le "<span class="em">DataContext</span>" est une classe générée automatiquement par le concepteur LINQ To SQL dans Visual Studio. Cette classe est spécifique à une base de données SQL Server particulière. Elle contient des propriétés pour accéder aux tables de la base de données sous forme de séquences d'objets, et elle gère également le suivi des modifications et l'envoi des modifications à la base de données.</p>
                    <h3>LINQ To Entities (Entity Framework) :</h3>
                    <p>Dans LINQ To Entities, qui fait partie du framework Entity Framework, le concept équivalent au "<span class="em">DataContext</span>" est généralement représenté par la classe "<span class="em">DbContext</span>". La classe "<span class="em">DbContext</span>" est responsable de la connexion à la base de données, du suivi des entités, et de la gestion des opérations CRUD (Create, Read, Update, Delete).</p>
<pre><code>// crate the ObjectContext
NorthwindEntities context = new NorthwindEntities();

// retrieve customer LAZY K
Customer cust = (from c in context.Customers
                where c.CustoùerID == "LAZY K"
                select c).Single&lt;Customer&gt;();

// Update the contact name
cust.ContactName = "Ned Plimpton";

// save the changes
try {
    context.SaveChanges();
} catch (OptimisticConcurrencyException) {
    context.Refresh(RefreshMode.ClientWIns, context.Customers);
    context.SaveChanges();
}</code></pre>
                    <p>En résumé, le "<span class="em">DataContext</span>" (ou "<span class="em">DbContext</span>" dans le cas d'Entity Framework) est une composante clé des fournisseurs LINQ. Il facilite l'accès à la source de données, la manipulation des données et la gestion des transactions, offrant ainsi une abstraction orientée objet pour interagir avec la bse de données.</p>
                    <p>On peut installer Entity Framework avac la commande suivante :</p>
<pre><code>Install-Package EntityFramework</code></pre>
                    <p>On peut configurer une chaîne de connexion dans le fichier de configration de votre application ("<span class="em">app.config</span>" ou "<span class="em">web.config</span>").</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion" connectionString="votre_chaine_de_connexion" providerName="System.Data.EntityClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>Cette chaîne de connexion doit spécifier le type de base de données que vous utilisez et les détails de connexion. Comme par exemple :</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion"  connectionString="Server=nom_du_serveur;Database=nom_de_la_base_de_donnees;User Id=nom_utilisateur;Password=mot_de_passe;" providerName="MySql.Data.MySqlClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>POCO (Plain Old CLR Objects) fait référence à des objets simples sans dépendance à une infrastructure particulière, ce qui permet une plus grande flexibilité.</p>
                    <p>Les collections générées par "<span class="html">DbSet</span>" dans Entity Framework représentent les ensembles d'entités associées à une table dans la base données. Vous pouvez utiliser ces collections pour effectuer des oéprations CRUD sans avoir à manipuler explicitement les requêtes SQL.</p>
                    <ul>
                        <li>
                            <p>context.Customers.Remove(cust)</p>
                        </li>
                        <li>
                            <p>context.Customers.Add(cust)</p>
                        </li>
                        <li>
                            <p>cust.name = "mise à jour du nom"</p>
                        </li>
                    </ul>
                    <p>Les clefs étrangères créent des associations. Les clefs étrangères créent des propriétés de navigation.</p>
                    <h4>Opérations : Insert objets associés :</h4>
<pre><code>// create the new order
// Clef étrangère
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the order to the customer
cust.Orders.Add(ord);

// add the new Customer
context.Customers.AddObject(cust);

// save the changes
// L'objet or sera persisté.
context.SaveChanges();</code></pre>
                    <p>Dans l'autre sens :</p>
<pre><code>// create the new order
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the customer to the order
ord.Customer = cust;

// add the new Customer
context.Orders.AddObject(ord);

// save the changes
// L'objet cust sera persisté.
context.SaveChanges();</code></pre>
                    <h4>Opérations : Requêtes :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.City = "London"
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("Customer: {0}", cust.CompanyName);
}</code></pre>
                    <p><span class="em">IQueryable</span> étend <span class="em">IEnumerable</span> &#8594; avantage performance filtre effectué côté base de données.</p>
                    <h4>Lazy Loading : par défaut :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.Country == "UK" && c.City == "London"
                                   orderby c.CustomerID
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>On va chercher les Orders à ce moment-là via un query.</p>
                    <p>On a un query par tour de boucle !</p>
                    <p>Le lazy loading est une technique dans laquelle les données associées à une entité ne sont chargées depuis la base de données que lorsque vous accédez explicitement à ces données.</p>
                    <h4>Eager Loading :</h4>
<pre><code>IQueryable custs = from c in context.Customers.Include("Orders")
                              where c.Country == "UK" && c.City == "London"
                              orderby c.CustomerID
                              select c;

foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>Les orders sont tout de suite chargés en mémoire.</p>
                    <p>Pas de query à chaque tour de boucle !</p>
                    <p>L'eager loading consiste à charger immédiatement toutes les données associées à une entité au moment où l'entité principale est chargée.</p>
                    <h4>Opérations : update :</h4>
<pre><code>Employee emp = (from e in context.Employees
                          where e.EmployeeID == 9
                          select e).Single&lt;Employee&gt;();
                        
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : update sur association :</h4>
<pre><code>Order order = (from o in context.Orders
                         where o.EmployeeID == 5
                         orderby o.orderDate descending
                         select o).First&lt;Order&gt;();

Employee emp = (from e in context.Employees
               where e.EmployeeID == 9
               select e).Single&lt;Employee&gt;();
  
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : delete (via DbSet) :</h4>
<pre><code>// get the order details for order 10248
IQueryable&lt;Order_Detail&gt; ods = from o in context.Order_Details
                                     where o.OrderID == 10248
                                    select o;

// delete the first order detail
context.Order_Details.DelegateObject(obj.First());

// save the changes
context.SaveChanges();</code></pre>
                    <p><span class="html">DeleteObject</span> est une ancienne méthode utilisée en Entity Framework 4 et 5. En Entity Framework 6, il y a la méthode <span class="html">Remove</span>.</p>
                    <h4>delete et objets associés :</h4>
                    <p>Delete d'une commande (Order) :</p>
                    <ul>
                        <li>
                            <p>Si le détail d'une commande n'est pas détruit (order_details) &#8594; risque de violation de clé étrangère.</p>
                        </li>
                        <li>
                            <p>Solution 1 : delete manuel &#8594; suppression du détail de la commande avant de supprimer la commande.</p>
                        </li>
                        <li>
                            <p>Solution 2 : delete cascade &#8594; à configurer dans le model.</p>
                        </li>
                    </ul>
                    <h4>Optimistic lock :</h4>
                    <p>Par défaut, la stratégie "optimistic lock" est appliquée.</p>
                    <h4>Pattern Repository :</h4>
                    <p>Le modèle de conception Repository est un motif de conception (design pattern) fréquemment utilisé pour abstraire la logique d'accès aux données. Ce motif  est particulièrement utile dans le contexte des applications C# et de l'accès aux bases de données.</p>
                    <p>Il permet la séparation de la couche DATA et BUSINESS et permet d'éviter le code redondant.</p>
<pre><code>public interface IRepository&lt;T&gt;
{
    void Insert(T entity);
    void Delete(T entity);
    IQueryable&lt;T&gt; SearchFor(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    // insertOrUpdate
    bool Save(T entity, Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    IQueryable&lt;T&gt; GetAll();
    T GetById(int id);
}</code></pre>
                    <p>L'interface <span class="em">IRepository&lt;T&gt;</span> définit génrélament les opérations CRUD de base pour une entité spécifique <span class="em">T</span>. Elle fournit un contrat standard que les classes concrètes implémentent pour interagir avec une source de données (par exemple, une base de données).</p>
<pre><code>public class BaseRepository&lt;TEntity&gt; : IRepository&lt;TEntity&gt; where TEntity : class
{
    private readonly DbContext _dbContext;

    public BaseRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public void Insert(TEntity entity) {
        // ...
    }
}</code></pre>
                    <p>Avec la généricité, il y a quelques changements. Comme par exemple :</p>
<pre><code>_dbContext.CouseSet.Add(course);
&#8594;
_dbContext.Set&lt;TEntity&gt;().Add(entity);</code></pre>
                </article>
                <article>
                    <h2 id="intro_blazor">Introduction à Blazor :</h2>
                    <h3>Qu'est-ce que Blazor ?</h3>
                    <p>Blazor est une technologie Microsoft basée sur ASP.NET Core permettant de réaliser des applications Web dynamique.</p>
                    <p>Il rentre en concurrence directe avec des frameworks JavaScript comme Angular, Vue ou encore React.</p>
                    <p>Il nous permet d'écrire du C# de bout en bout, même pour réagir aux événements web !</p>
                    <h3>Blazor Server VS WebAssembly :</h3>
                    <h4>Blazor Server :</h4>
                    <img src="../images/blazor_server.png" alt="">
                    <p>Le code s'exécute sur le serveur.</p>
                    <p>Les événements sont envoyés par un pont SignalR.</p>
                    <h4>Blazor Client (ou WebAssembly) :</h4>
                    <img src="../images/blazor_webassembly.png" alt="">
                    <p>Le code et un runtime .NET sont téléchargés sur le poste client.</p>
                    <p>Tout fonctionne dans le navigateur en contexte WebAssembly.</p>
                    <h4>Serveur ou Client ?</h4>
                    <p>Pas de réponse universelle !</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Server</th>
                                <th>WebAssembly</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p>Client léger</p>
                                        </li>
                                        <li>
                                            <p>Sollicitation du serveur</p>
                                        </li>
                                        <li>
                                            <p>Code sécurisé</p>
                                        </li>
                                        <li>
                                            <p>Outils 100% adaptés</p>
                                        </li>
                                        <li>
                                            <p>API totale</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <p>100% chez le client</p>
                                        </li>
                                        <li>
                                            <p>Mode déconnecté</p>
                                        </li>
                                        <li>
                                            <p>Hébergement simplifié</p>
                                        </li>
                                        <li>
                                            <p>Autre technologie d'API</p>
                                        </li>
                                        <li>
                                            <p>Beaucoup d'utilisateurs</p>
                                        </li>
                                        <li>
                                            <p>Possibilité de PWA</p>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Création d'un premier projet en Blazor :</h3>
                    <p>La plupart des développeurs C# développent avec Visual Studio 2022. Quand on clique sur "Créer un projet", on sélectionne "Application Blazor".</p>
                    <p>Après avoir entrer un nom de projet, on doit sélectionner la version de .NET (moi, j'ai mis .NET 8). On doit choisir entre "Application serveur Blazor" et "Blazor WebAssembly App".</p>
                    <p>Il faut bien décocher le "HTTPS".</p>
                    <p>On peut faire la même chose en ligne de commande. Donc, dans le dossier "MyApp", on peut lancer une invite de commandes (Powershell ou Shell) et exécuter la commande suivante :</p>
<pre><code>dotnet --version</code></pre>
                    <p>Ctte commande permet d'afficher la version du runtime et non du SDK. Ensuite, on crée le projet "Blazor Server App" sans le "HTTPS" avec la commande suivante :</p>
<pre><code>dotnet new blazorserver --no-https</code></pre>
                    <h3>Présentation des fichiers :</h3>
                    <p>Pour lancer le projet en lignes de commandes, il faut entrer cette instruction :</p>
<pre><code>dotnet run</code></pre>
                    <p><span class="em">Program.cs</span> est une application Console qui va lancer un serveur qui va répondre aux requêtes HTTP.</p>
                    <h3>Le routeur Blazor :</h3>
                    <p>Dans le fichier <span class="em">_Imports.razor</span>, on va définir toutes les instructions <span class="html">using</span> en préfixant bien par un '@'. C'est la même chose que le fichier <span class="em">_Imports.cs</span> dans ASP.NET Core.</p>
                    <p><span class="html">@page "/"</span> : ça permet de dire que ce fichier sera exécuter sur l'url "/".</p>
                    <h3>Qu'est-ce qu'un composant Blazor ?</h3>
                    <p>Le Layout se trouve dans le dossier "Shared" qui est un dossier contenant des composants visibles pour tous les autres composants.</p>
                    <h3>Les parmètres de route :</h3>
                    <p>On peut rajouter une deuxième instruction "<span class="html">@page</span>". Comme par exemple : @page "/counter/{value:int}". On doit rajouter l'annotation <span class="em">[Parameter]</span> à la propriété "<span class="em">public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }</span>.</p>
                    <p>Donc, le fichier Counter.razor devient :</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;

@code {
    private int currentCount = 0;

    [Parameter]
    public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

    private void IncrementCount()
    {
        currentCount++;
    }
}</code></pre>
                    <h3>Séparation de la vue du code :</h3>
                    <p>Certains développeurs, comme moi, préfèrent avoir deux fichiers : le comportement et la vue. On peut utiliser le concept de classes partielles. On va créér une nouvelle classe "Counter.razor.cs".</p>
                    <p>Pour que ça fonctionne correctement, dans cette nouvelle classe, il faut rajouter le mot-clé "<span class="html">partial</span>" dans le nom de la classe.</p>
                    <p>Ensuite, on doit copier tout ce qu'il y a dans le "<span class="html">@code</span>" dans la nouvelle classe.</p>
                    <p>Voici le code dans le fichier "Counter.razor" :</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;</code></pre>
                    <p>Dans le fichier "Counter.razor.cs", voici le code :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace MyApp.Pages
{

    public partial class Counter
    {
        private int currentCount = 0;

        [Parameter]
        public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

        private void IncrementCount()
        {
            currentCount++;
        }
    }
}</code></pre>
                    <p>Moi, au lieu d'avoir une classe partielle, je prèfère avoir une notion d'héritage avec une classe "CounterBase" qui hérite de "ComponentBase". Donc, le fichier "Counter.razor.cs" devient :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace MyApp.Pages
{

    public class CounterBase : ComponentBase
    {
        protected int currentCount = 0;

        [Parameter]
        public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

        protected void IncrementCount()
        {
            currentCount++;
        }
    }
}</code></pre>
                    <p>Dans le fichier "Counter.razor", on devra ajouter l'instruction "<span class="html">@inherits</span>" pour préciser que la classe partielle qui représente ce composant Blazor hérite de ma classe "CounterBase" que j'ai créée.</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"
@inherits CounterBase

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;</code></pre>
                    <h3>Cycle de vie d'un composant :</h3>
                    <p>En Blazor, les composants suivent un cycle de vie bien défini, avec plusieurs méthodes de cycle de vie permettant d'interagir avec ces phases. Voici les principales phases du cycle de vie du composant en Blazor ainsi que les fonctions associées :</p>
                    <ol>
                        <li>
                            <p class="em">Initialization (Initialisation) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">OnInitialized</span> : Cette méthode est appelée une fois que le composant a été initialisé et qu'il est prêt à être utilisé. C'est le point de départ du cycle de vie du composant.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Parameters Set (Paramètres définis) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">OnParametersSet</span> : Cette méthode est appelée lorsque les paramètres du composant ont été définis ou modifiés. Elle est utilisée pour réagir aux changements de paramètres du composant.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Rendering (Rendu) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">OnAfterRender</span> : Cette méthode est appelée après que le rendu du composant et de ses enfants a été effectué.</p>
                                </li>
                                <li>
                                    <p><span class="html">OnAfterRenderAsync</span> : Similaire à <span class="em">OnAfterRender</span>, mais asynchrone.</p>
                                </li>
                                <li>
                                    <p><span class="html">OnAfterRender(bool firstRender)</span> : Cette méthode est appelée après le rendu initial du composant et après chaque mise à jour du rendu, avec un paramètre indiquant si c'est la première fois que le composant est rendu.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Update (Mise à jour) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">ShouldRender</span> : Cette méthode est utilisée pour déterminer si le composant doit être rendu à nouveau en réponse à des modifications d'état interne. Elle retourne <span class="em">true</span> si le composant doit être rendu à nouveau et <span class="em">false</span> sinon.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Disposal (Élimination) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">Dispose</span> : Cette méthode est appelée lorsque le composant est éliminé de la mémoire et qu'il n'est plus nécessaire. C'est le point de sortie du cycle de vie du composant.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>ces méthodes fournisssent des points d'entrée pour exécuter du code à différentes étapes du cycle de vie du composant, ce qui permet de réagir aux événements et de contrôler le comportement du composant en fonction de son état.</p>
                    <h3>Premier exercice :</h3>
                    <p>On instancie tout notre jeu du nombre mystère dans la fonction <span class="html">protected override void OnInitialized() =&gt; base.OnInitialized();</span></p>
                    <p>Pour les nombres aléatoires, on utilise la classe <span class="html">Random</span>. Comme par exemple, <span class="em">var random = new Random();</span></p>
                    <p>Créons un projet "NombreMagique" sans "HTTPS". Sur le dossier "Pages", créons un nouveau composant Razor "NombreMagique".</p>
                    <p>Pas oublié de rajouter un nouveau lien dans la barre de navigation.</p>
                    <p>Dans le fichier "NombreMagique.razor.cs", voici le code :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace NombreMagique.Pages
{

    public class NombreMagiqueBase : ComponentBase
    {
        protected const int NbLifesMax = 5;
        protected const int NbMax = 20;

        protected int value;

        protected int nbMagique;
        protected int nbRemainingLifes;
        protected bool? gameWon;

        protected override void OnInitialized()
        {
            ReinitGame();
            base.OnInitialized();
        }

        protected void ReinitGame()
        {
            var random = new Random();

            nbMagique = random.Next(NbMax);
            nbRemainingLifes = NbLifesMax;
            gameWon = null;
            value = 0;
        }

        protected void TestNumber()
        {
            if (value == nbMagique)
            {
                gameWon = true;
            }
            else
            {
                nbRemainingLifes--;
                if (nbRemainingLifes == 0)
                {
                    gameWon = false;
                }
            }
        }
    }
}</code></pre>
                    <p>Dans le fichier "NombreMagique.razor", on écrit :</p>
<pre><code>@inherits NombreMagiqueBase


@page "/nombre"

&lt;h3&gt;Nombre magique&lt;/h3&gt;
@if (gameWon.HasValue)
{
    if (gameWon.Value)
    {
        &lt;h2&gt;Gagn&eacute;!&lt;/h2&gt;
    }
    else
    {
        &lt;h2&gt;Perdu&lt;/h2&gt;
    }
    &lt;button class="btn btn-primary" onclick="() =&gt; ReinitGame()"&gt;Rejouer&lt;/button&gt;
}
else {
    &lt;div&gt;
        &lt;h4&gt;Devinez le nombre compris entre 0 et @NbMax&lt;/h4&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type="number" @bind="value"&gt;
        &lt;button class="btn btn-primary" @onclick="() =&gt; TestNumber()"&gt;Tester&lt;/button&gt;
    &lt;/div&gt;
    &lt;div&gt;
        @for (int i = 0; i &lt; nbRemainingLifes; i++)
        {
            &lt;span&gt;&amp;hearts;&amp;nbsp;&lt;/span&gt;
        }
    &lt;/div&gt;
}</code></pre>
                    <p>Dans le dossier "Properties", il faut supprimer le "profiles" de "IISExpress" du fichier "lauchSettings.json", ainsi que le "listSettings".</p>
                    <p>Dans Blazor, "<span class="html">@bind</span>" et "<span class="html">@bind-Value</span>" sont deux façons d'effectuer la liaison de données bidirectionnelle. Cependant, il existe quelques différences subtiles entre les deux.</p>
                    <ol>
                        <li>
                            <p>@bind :</p>
                            <ul>
                                <li>
                                    <p>"<span class="em">@bind</span>" est une syntaxe concise qui combine la liaison en lecture seule ("<span class="em">@bind="propriete"</span>") et la liaison en écriture ("<span class="em">@oninput="e =&gt; propriete = e.Value")</span>).</p>
                                </li>
                                <li>
                                    <p>Il est souvent utilisé dans des éléments d'entrée de formulaire tels que "<span class="em">&lt;input&gt;</span>", "<span class="em">&lt;select&gt;</span>" et "<span class="em">&lt;textarea&gt;</span>".</p>
                                </li>
                                <li>
                                    <p>La syntaxe "<span class="em">@bind</span> se charge à la fois de la mise à jour de la valeur de la propriété lorsqu'un utilisateur interagit avec l'élément d'entrée lorsque la propriété change dans le code.</p>
                                </li>
                            </ul>
                            <p>Exemple :</p>
<pre><code>&lt;input type="text" @bind="Nom" /&gt;</code></pre>
                        </li>
                        <li>
                            <p>@bind-Value :</p>
                            <ul>
                                <li>
                                    <p>"<span class="em">@bind-Value</span>" est utilisé dans des contextes où vous souhaitez explicitement la propriété liée de l'élément.</p>
                                </li>
                                <li>
                                    <p>Il est souvent utilisé avec des composants personnalisés où la propriété à lier peut être déterminée dynamiquement.</p>
                                </li>
                                <li>
                                    <p>Vous devez spécifier la propriété explicitement, par exemple, <span class="em">@bind-Value="model.Nom"</span>.</p>
                                </li>
                            </ul>
                            <p>Exemple :</p>
<pre><code>&lt;MonComposant @bind-Value="model.Nom /&gt;</code></pre>
                        </li>
                    </ol>
                    <p>En résumé, <span class="em">@bind</span> est plsu concis et pratique pour les cas d'utilisation courants où vous liez directement une propriété à la valeur d'un élément d'entrée, tandis que <span class="em">@bind-Value</span> offre une flexibilité accrue en permettant de spécifier explicitement la propriété liée à la valeur. Vous pouvez choisir celui qui convient le mieux à votre scénario d'utilisation.</p>
                </article>
                <article>
                    <h2 id="entity_framework_blazor">Entity Framework dans Blazor :</h2>
                    <h3>Configuration :</h3>
                    <p>Avant de faire quoi que ce soit, il faut télécharger et installer les logiciels suivants : <a href="https://www.microsoft.com/fr-be/sql-server/sql-server-downloads" target="_blank">SQL Server</a> et <a href="https://learn.microsoft.com/fr-fr/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16#download-ssms" target="_blank">SQL Server Management Studio (SSMS)</a>.</p>
                    <p>Dans SSMS, il faut se connecter au SQL Server local installé précédemment. Ensuite, il suffit créer une nouvelle base de données (par exemple : "MyApplicationDb").</p>
                    <p>Ensuite, dans Visual Studio 2022, en ouvrant la fenêtre de l'explorateur de serveurs, il faut "ajouter une connexion" et remplir les champs "Souce de données" par "Microsoft SQL Server (SqlClient)", "Nom du serveur" par ".\" et "Sélectionner ou entrer un nom de base de données" par "MyApplicationDb".</p>
                    <p>Enfin, dans la solution, en gérant les paquets NuGet, on va vérifier si les paquets "<span class="em">Micosft.EntityFrameworkCore</span>", "<span class="em">Microsoft.EntityFrameworkCore.Tools</span>" et "<span class="em">Micosft.EntityFrameworkCore.SqlServer</span>" sont bien installés, sinon on installe ceux qui manquent en sélectionnant bien la dernière version stable.</p>
                    <p>Dans le projet, créez un nouveau dossier "Data" s'il n'existe pas et dedans créez une nouvelle classe "<span class="em">MyDbContext</span>" :</p>
<pre><code>using Micorsoft.EntityFrameworkCore;

namespace MyApplication.Data
{

    public class MyDbContext : DbContext
    {

        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options)
        {

        }

    }

}</code></pre>
                    <p>Dans appsettings.json, il faut rajouter la "ConnectionStrings" qu'on trouve dans les propriétés de la connexion qu'on a créée précédemment :</p>
<pre><code>{
    "ConnectionStrings": {
      "Default": "Data Source=.\\;Initial Catalog=MyApplicationDb;Integrated Security=True;Encrypt=False"
    },
    "Logging": {
      "LogLevel": {
        "Default": "Information",
        "Microsoft.AspNetCore": "Warning"
      }
    },
    "AllowedHosts": "*"
}</code></pre>
                    <p>Enfin, dans le programme principal, qui a normalement pour nom "Program.cs", il faut rajouter quelques lignes :</p>
<pre><code>using MyApplication.Components;
using MyApplication.Data;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
var connectionString = builder.Configuration.GetConnectionString("Default") ?? throw new NullReferenceException("No connection string in config !");
// Add services to the container.
builder.Services.AddRazorComponents().AddInteractiveServerComponents();

builder.Services.AddDbContextFactory&lt;MyDbContext&gt;((DbContextOptionsBuilder options) => options.UseSqlServer(connectionString));

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
}

app.UseStaticFiles();
app.UseAntiforgery();

app.MapRazorComponents&lt;App&gt;().AddInteractiveServerRenderMode();

app.Run();</code></pre>
                    <h3>Création des entitiés :</h3>
                    <p>Dans le dossier "Data", créez un dossier "Models" et créez un nouvelle classe (par exemple : "Customer.cs") :</p>
<pre><code>using System.ComponentModel.DataAnnotations;

namespace MyApplication.Data.Models
{
    public class Customer
    {
        [Key]
        public int Id { get; set; }
        public string Name { get; set; }
        public int Age { get; set; }
        public DateTime CreatedDate { get; set; }
    }
}</code></pre>
                    <p>Ensuite, dans notre DbContext, on peut créez des <span class="html">DbSet</span> :</p>
<pre><code>using MyAplication.Data.Models;
using Microsoft.EntityFrameworkCore;

namespace MyApplication.Data
{

    public class MyDbContext : DbContext
    {

        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options)
        {

        }

        public DbSet&lt;Customer&gt; Customers { get; set; }
    }

}</code></pre>
                    <h3>Les migrations :</h3>
                    <p>D'après l'article sur <a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli" target="_blank">la vue d'ensemble des migrtions</a> :</p>
                    <blockquote>
                        <p>Dans la pratique, les modèles de données des projets évoluent au fur et à mesure que des fonctionnalités sont implémentées : de nouvelles entités et propriétés sont ajoutées et supprimées, et les schémas de la base de données doivent être modifiés en conséquence pour rester synchronisés avec l'application. La fonctionnalité de migration dans Entity Framework Core permet de mettre à jour de manière incrémentielle le schéma de la base de données pour qu'il reste synchronisé avec le moèle de données de l'application tout en conservant les données existantes dans la base de données.</p>
                        <p>Dans les grandes lignes, les mogrations fonctionnent de la façon suivante :</p>
                        <ul>
                            <li>
                                <p>Lors de l'introduction d'une modification du modèle de données, le développeur utilise des outils Entity Framework Core afin d'ajouter une migration correspondante décrivant les mises à jour nécessiares pour préserver la synchronisation du schéma de la base de données. Entity Framework Core compare le modèle actuel à un instantané de l'ancien modèle pour déterminer les différences et génère des fichiers sources de migration. Ces fichiers peuvent, comme n'importe quel fichier source, faire l'objet d'un suivi dans le contrôle de code source du projet.</p>
                            </li>
                            <li>
                                <p>Une fois générée, la nouvelle migration peut être appliquée à une base de données de différentes façons. Entity Framework Core enregistre toutes les migrations appliquées dans une table d'historique spéciale, ce qui lui permet de savoir quelles migrations ont été appliquées.</p>
                            </li>
                        </ul>
                    </blockquote>
                    <p>Dans l'onglet "Outils", sélectionnez "Gestionnaire de package NuGet" et ensuite "Console du Gestionnaire de package".</p>
                    <p>Tapez la commande suivante :</p>
<pre><code>Add-Migration "Added_Customer_Table"</code></pre>
                    <p>Entity Framework Core créera un répertoire nommé "<span class="em">Migrations</span>" dans votre projet et générera des fichiers. Il est judicieux d'inspecter précisément les fichiers en question, et éventuellement de les modifier, mais nous allons nous en passer pour l'instant.</p>
                    <p>Voici le fichier généré par la commande pour les customers :</p>
<pre><code>using System;
using Micorsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MyApplication.Migrations
{

    public partial class Added_Customer_Table : Migration
    {
        
        protected override void Up(migrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Customers",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int", nullable: false)
                         .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
                    Age = table.Column&lt;int&gt;(type: "int", nullable: false),
                    CreatedDate = table.Column&lt;DateTime&gt;(type: "datetime2", nullable: false) 
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Customers", x =&gt; x.Id);
                });
        }
    }

    protected override Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Customers");
    }
}</code></pre>
                    <p>Une fois la migration créée, il faut mettre à jour la base de données avec la commande :</p>
<pre><code>Update-Database</code></pre>
                    <p>S'il y a pas eu d'erreurs, on devrait retrouver deux tables dans notre base de données : la table par défaut "<span class="em">dbo._EFMigrationHistory</span>" et la table "dbo.Customers".</p>
                    <h3>Les relations :</h3>
                    <p>On va créer une nouvelle classe dans "Models" : "Order.cs".</p>
<pre><code>using System.ComponentModel.DataAnnotations;

    namespace MyApplication.Data.Models
    {
        public class Order
        {
            [Key]
            public int Id { get; set; }
            public string ItemDescription { get; set; }
            public int Quantity { get; set; }

            public Customer Customer { get; set; }
        }
    }</code></pre>
                    <p>Dans le DbContext, pas oublier de rajouter un nouveau <span class="em">DbSet</span>, d'ajouter une nouvelle migration "Added_Orders_Table" et de mettre à jour la base de données.</p>
<pre><code>using System;
using Micorsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MyApplication.Migrations
{

    public partial class Added_Orders_Table : Migration
    {
        
        protected override void Up(migrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Orders",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int", nullable: false)
                         .Annotation("SqlServer:Identity", "1, 1"),
                    ItemDescription = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
                    Quantity = table.Column&lt;int&gt;(type: "int", nullable: false),
                    CustomerId = table.Column&lt;int&gt;(type: "int", nullable: false) 
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Orders", x =&gt; x.Id);
                    table.ForeignKey(
                        name: "FK_Orders_Customers_customerId",
                        column: x =&gt; x.CustomerId,
                        principalTable: "Customers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            
            migrationBuilder.CreateIndex(
                name: "IX_Orders_customerId",
                table: "Orders",
                column: "CustomerId");
        }
    }

    protected override Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Orders");
    }
}</code></pre>
                    <p>Pour ajouter une contrainte d'unicité (unique en SQL) sur la propriété "Name", il faut rajouter, dans la partie "constraints" des migrations, la ligne suivante :</p>
<pre><code>table.UniqueConstraint("UQ_VotreTable_Name", x =&gt; x.Name);</code></pre>
                    <p>Pour ajouter une contrainte précisant les valeurs spécifiques que peut prendre une propriété (par exemple : la propriété "Sexe" peut prendre "M", "F" ou "X" comme valeur), rajoutez toujours dans "constraints" la ligne suivante :</p>
<pre><code>table.CheckConstraint("CK_VotreTable_Sexe", "Sexe IN ('M', 'F', 'X')");</code></pre>
                    <h3>Créer un service pour interagir avec le contexte (CRUD) :</h3>
                    <p>Dans le projet, on crée un nouveau répertoire "Services" et créons la classe "CustomerService.cs" dedans.</p>
<pre><code>using MyApplication.Data;
using MyApplication.Data.Models;
using Microsoft.EntityFrameworkCore;

namespace MyApplication.Service
{

    public class CustomerService
    {
        private IDbContextFactory&lt;MyDbContext&gt; _dbContextFactory;

        public CustomerService(IDbContextFactory&lt;MyDbContext&gt; dbContextFactory)
        {
            _dbContextFactory = dbContextFactory;
        }

        public void AddCustomer(Customer customer)
        {
            using (var context = _dbContext.CreateDbContext())
            {
                context.Customers.Add(customer);
                context.SaveChanges();
            }
        }

        public Customer GetCustomerByName(string name)
        {
            using (var context = _dbContextFactory.CreateDbContext())
            {
                var customer = context.Customers.SingleOrDefault(x =&gt; x.Name == name);
                return customer;
            }
        }

        public void UpdateCustomerByName(string name, int age)
        {
            var customer = GetCustomerByName(name);
            if (customer == null)
            {
                throw new Exception("Customer does not exist. Cannot update");
            }
            customer.Age = age;
            using (var context = _dbContextFactory.CreateDbContext())
            {
                context.Customers.Update(customer);
                context.SaveChanges();
            }
        }

        public void RemoveCustomerByName(string name)
        {
            var customer = GetCustomerByName(name);
            if (customer == null)
            {
                throw new Exception("Customer does not exist. Cannot delete");
            }

            using (var context = _dbContextFactory.CreateDbContext())
            {
                context.Customers.Remove(customer);
                context.SaveChanges();
            }
        }

    }
}</code></pre>
                    <p>Dans le "Program.cs", n'oubliez pas de rajouter les lignes suivantes à la bonne place avant l'ajout du DbContextFactory :</p>
<pre><code>using MyApplication.Services;
builder.Services.AddTransient&lt;CustomerService&gt;();</code></pre>
                    <p>Dans le fichier "Index.razor" du dossier "Pages", on va créer un formulaire pour insérer un nouveau "Customer" dans la base de données :</p>
<pre><code>@page "/"
@using MyApplication.Services
@using MyAplication.Data.Models
@inject CustomerService customerService

&lt;PageTitle&gt;Index&lt;/PageTitle&gt;

&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.

&lt;SurveyPrompt Title="How is Blazor working for you?" /&gt;

&lt;EditForm Model="@customer" OnValidSubmit="HandleSubmit"&gt;
    &lt;label for="NameInput"&gt;Name&lt;/label&gt;
    &lt;InputText id="NameInput" @bind-Value="@customer.Name"&gt;&lt;/InputText&gt;
    &lt;label for="AgeInput"&gt;Age&lt;/label&gt;
    &lt;InputNumber id="AgeInput" @bind-Value="@customer.Age"&gt;&lt;/InputNumber&gt;
    &lt;button type="submit" class="btn btn-primary"&gt;Create&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    Customer customer = new Customer();

    public void HandleSubmit(EditContext editContext)
    {
        var newCustomer = (Customer)editContext.Model;
        newCustomer.CreatedDate = DateTime.Now;
        customerService.AddCustomer(newCustomer);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="blazor_.NET_8">Blazor en .NET 8 :</h2>
                    <p>Dans ce cours, on va apprendre à développer des applications Web et Mobiles avec Blazor.</p>
                    <p>Les prérequis pour faire du Blazor sont les fondamentaux de C# et les fondamentaux HTML/CSS. Des notions MAUI sont un plus.</p>
                    <h3>Qu'est-ce que Blazor ?</h3>
                    <p>Pour rappel, Blazor est la technologie ASP.NET de Microsoft pour réaliser des applications graphiques riches et interactives.</p>
                    <p>Blazor permet de réaliser des applications web, mais pas que ! Il est possible d'utiliser Blazor dans des applications natives (mobile ou desktop).</p>
                    <p>L'avantage principal de la technologie : on utilise C# de bout en bout (pas de JavaScript nécessaire !!!).</p>
                    <h3>Les variantes de Blazor : WebApp, WASM & Hybrid :</h3>
                    <h4>Blazor WebApp - Server :</h4>
                    <p>Avant Blazor en .NET 8, on avait Blazor Server qui était une application ASP.NET s'exécutant sur le serveur. Donc, avec tout le potentiel de .NET côté serveur ! Du côté client, on avait un petit client en JavaScript qui ouvrait un pont WebSocket avec le serveur pour lui demander d'exécuter certaines interactions et de récupérer les modifications de DOM à appliquer sur la partie graphique. On avait pas la possibilité de dire tel composant n'a pas d'interactivité pas dynamiquement riche donc on peut le rendre de façon statique du côté serveur vu que l'utilisateur ne va pas réagir avec ce composant-là. Donc, toute l'application était connectée en permanence à ce pont en WebSocket.</p>
                    <p>Le moteur s'exécute sur le serveur et renvoie aux clients des instructions pour mettre à jour le DOM.</p>
                    <p>Le client maintient un lien avec le serveur par le biais d'un pont WebSocket si l'interactivité est nécessaire.</p>
                    <p>On a un équivalent en JavaScript avec les React Component Server.</p>
                    <h4>Blazor Web App - WebAssembly :</h4>
                    <p>Il y a deux modes de fonctionnement. Nous avons la possibilité en Blazor de créer une application WebAssembly autonome, c'est-à-dire qu'on va créer une application statique au sens qu'elle n'a pas de lien avec un serveur comme on créerait une application Angular, React ou autres.</p>
                    <p>Le runtime .NET (spécifique) ainsi que l'application est téléchargé sur le poste du client.</p>
                    <p>100% du code est exécuté sur le poste client.</p>
                    <h4>Blazor Hybrid :</h4>
                    <p>Les composants Blazor fonctionnent dans un composant natif (navigateur/webview) de la plateforme cible.</p>
                    <p>Cette dernière expose des accès à certaines APIs natives.</p>
                    <h4>Blazor WebApp :</h4>
                    <p>Depuis .NET 8, Blazor pour le web a été unifié dans un seul template : Blazor WebApp !</p>
                    <p>Le mode de rendu (Server, WebAssembly ou automatique) se définit par composant.</p>
                    <h4>Server ou WASM :</h4>
                    <p>Si on part sur une application Web... Pas de réponses universelles !</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Server</th>
                                <th>WASM</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p>Client léger</p>
                                        </li>
                                        <li>
                                            <p>Tout est sur le serveur</p>
                                        </li>
                                        <li>
                                            <p>Sécurisé</p>
                                        </li>
                                        <li>
                                            <p>100% de l'expérience dev</p>
                                        </li>
                                        <li>
                                            <p>100% du framework .NET</p>
                                        </li>
                                        <li>
                                            <p>Performant</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <p>100% sur le poste client</p>
                                        </li>
                                        <li>
                                            <p>Mode déconnecté</p>
                                        </li>
                                        <li>
                                            <p>hébergement simplifié</p>
                                        </li>
                                        <li>
                                            <p>Supporte la charge</p>
                                        </li>
                                        <li>
                                            <p>Transformable en PWA</p>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Créer un projet Blazor avec VS 2022 :</h3>
                    <p>Nous allons créer un projet Blazor Web App dans Visual Studio. On peut toujours faire du WebAssembly dans la Web App. Attention, de bien choisir le type de projet pour que ça reste en .NET 8.</p>
                    <p>Donnons-lui un nom (par exemple : MyAppBlazor) et on choisit bien .NET 8 sans configuration le HTTPS. Le type d'interactivité passe maintenant en auto, c'est-à-dire la combinaison entre Server et WebAssembly.</p>
                    <p>En choisissant le mode automatique, on a deux projets : MyAppBlazor et MyAppBlazor.Client.</p>
                    <h3>Créer un projet Blazor avec le CLI :</h3>
                    <p>Pour ceux qui veulent pas utiliser VS 2022, on utilisera le CLI (l'abréviation pour "lignes de commande"). La commande suivante va nous permettre d'afficher la totalité des templates existants sur notre machine nous permettant de créer une nouvelle application :</p>
<pre><code>dotnet new list</code></pre>
                    <p>Dans cette liste qui est assez grande, vont nous intéresser certains templates. En l'occurence, Application .NET MAUI Blazor va nous permettre de créer une application Blazor Hybrid. Attention de ne pas se servir des trois templates suivants : blazorserver, blazorserver-empty ou encore blazorwasm-empty car les versions de .NET utilisées sont les versions de .NET 7 ou moins.</p>
                    <p>blazorwasm est toujours valable en .NET 8 et permet de faire une WebAssembly. Ici, dans ce cours, on utilisera le nouveau template Blazor Web App : blazor.</p>
                    <p>Pour faire le même projet que dans Visual Studio 2022 en lignes de commande :</p>
<pre><code>dotnet new blazor -int Auto --no-https</code></pre>
                    <h3>Composant statique et streaming :</h3>
                    <p>On parle ici de Server Side Rendering (SSR) et de Stream Rendering.</p>
                    <p>Les composants qui nécessitent une interactivité doivent être placés dans MyAppBlazor.Client. Donc, les composants statiques sont dans MyAppBlazor et les composants dynamiques dans MyAppBlazor.Client.</p>
                    <p>C'est MyAppBlazor qui se lance au démarrage et non MyAppBlazor.Client. Le code HTML est dans le fichier App.razor.</p>
                    <p>Dans la page Weather se trouvant dans MyAppBlazor, on a rajouté un attribut : <span class="html">@attribute[StrealRendering(true)</span>.</p>
                    <h3>Composant interactif :</h3>
                    <p>Dans la page Counter se trouvant dans MyAppBlazor.Client, on a rajouté un attribut : <span class="html">@attribute [RenderModelInteractiveAuto]</span>. Depuis un certain temps, Microsoft a abandonné cet attribut et on utilisera l'instruction <span class="html">@rendermode InteractiveAuto</span> à la place.</p>
                    <p>Blazor met toujours un élément <span class="html">@code</span>, mais moi je préfère séparer le HTML du code C# de l'élément <span class="em">@code</span> en extrayant le bloc vers le code-behind. Ça créra un nouveau fichier Counter.razor.cs qui contient la classe partial.</p>
                    <h3>Blazor Hybrid avec MAUI :</h3>
                    <p>On va créer un nouveau projet dans notre application. Cette fois-ci, ce sera un projet Blazor Hybrid avec .NET MAUI Blazor : MyAppBlazor.Mobile. Si vous avez une erreur dans Visual Studio 2022 lors de la création de ce projet, il faut vérifier dans Visual Studio Installer qu'on a bien coché "Développement .NET Multi-Platform App UI et exécutez la commande suivante dans un terminal qui va installer tous les packages liés à MAUI :</p>
<pre><code>dotnet workload install maui</code></pre>
                    <p>On a le MauiProgram.cs qui ressemble au Program.cs. MauiProgram.cs et CreateMauiApp() sont des points d'entrée que va utiliser le framework MAUI. Mais pour qu'une application MAUI fonctionne, on a un <span class="em">MauiBlazorWebView</span>. MainPage.xaml (XAML est un langage de balisage inspiré de XML) est la page principale de notre application Blazor Hybrid.</p>
                    <h3>Librairie de composants Blazor :</h3>
                    <p>Ce qu'on va faire prochainement dans Visual Studio 2022, on peut utiliser la commande suivante à la place :</p>
<pre><code>dotnet new razorclasslib</code></pre>
                    <p>Donc soit on fait cette commande soit on ajoute un nouveau projet dans notre application : Bibliothèque de classes Razor. On va l'appeler "MyAppBlazor.Components" et on va supprimer les fichiers "Component1.razor" et "Example.JsInterop.cs" ainsi que les fichiers dans le dossier wwwroot.</p>
                    <p>Le fichier "<span class="em">_Imports.razor</span>" contient une collection <span class="em">@using</span> qui sont implicitement à chacun des composants pour éviter de faire les différents <span class="em">@using</span>.</p>
                    <p>On crée le fichier "Home.razor" dans le projet "MyAppBlazor.Components" avec le contenu suivant :</p>
<pre><code>&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.</code></pre>
                    <p>Dans les projets, on oublie de rajouter une référence vers le projet "MyAppBlazor.Components".</p>
                    <p>Dans le fichier "Index.razor" du projet "MyAppBlazor.Mobile", on modifie pour que ça donne ceci :</p>
<pre><code>@page "/"

&lt;Home&gt;&lt;/Home&gt;</code></pre>
                    <p>Dans le fichier "_Imports.razor", on rajoute la ligne suivante :</p>
<pre><code>@using MyAppBlazor.Components</code></pre>
                    <p>Dans le fichier "Home.razor" du projet "MyAppBlazor", on le modifiera avec le code ci-dessous :</p>
<pre><code>@page "/"

&lt;PageTitle&gt;Home&lt;/PageTitle&gt;

&lt;MyAppBlazor.Components.Home /&gt;</code></pre>
                    <p>Ensuite, on va rajouter un projet "MyAppBlazor.Models". On va supprimer le fichier "Class1.cs" et on va créer le fichier "WeatherForecast.cs" avec le contenu suivant :</p>
<pre><code>namespace MyAppBlazor.Models;

public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    public string Summary { get; set; }
}</code></pre>
                    <p>On va rajouter la référence dans le projet Hybrid vers le Models, ainsi que la référence dans le projet Blazor Web App. Dans le fichier "_Imports.razor", on oublie pas de rajouter le using suivant :</p>
<pre><code>@using MyAppBlazor.Models</code></pre>
                    <p>On va supprimer le dossier "Data" du projet "MyAppBlazor.Mobile" et on va créer un projet "MyAppBlazor.Services" en supprimant le fichier "Class1.cs". On fait une référence le projet Models et on va créer le fichier "WeatherForecastService.cs" avec le contenu suivant :</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyAppBlazor.Services;

public class WeatherForecastService
{
    public async Task&lt;WeatherForecast[]&gt; GetForecasts()
    {
        await Task.Delay(1000);
        var DateOnly startDate = DateOnly.FromDateTime(DateTime.Now);
        var string[]? summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Hot", "Sweltering" "Scoching" };
        return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summmary = summaries(Random.Shared.Next(summaries.Length))
        }).ToArray();
    }
}</code></pre>
                    <p>On rajoute une référence vers le Service que je viens de créer au projet Mobile et, dans le fichier "MauiProgram.cs", on utilise le bon using dans la ligne suivante :</p>
<pre><code>builder.Services.AddSingleton&lt;WeatherForecastService&gt;();</code></pre>
                    <p>Dans le fichier "_Imports.razor" du projet Mobile, il faut vérifier que les using suivants y sont sinon rajoutez-les :</p>
<pre><code>@using MyAppBlazor.Components
@using MyAppBlazor.Models
@using MyAppBlazor.Services</code></pre>
                    <p>Dans le fichier "FetchData.razor" du projet Mobile, on va modifier la méthode "OnInitializedAsync()" comme ceci :</p>
<pre><code>@inject WeatherForecastService ForecastService
    
protected override async Task OnInitializedAsync()
{
    await Task.Delay(2000);
    forecasts = await ForecastService.GetForecasts();
}</code></pre>
                    <p>N'oubliez pas de rajouter la ligne suivante dans le "Program.cs" du projet "MyAppBlazor" :</p>
<pre><code>builder.Services.AddScoped&lt;WeatherForecastService&gt;();</code></pre>
                    <h3>Créer un composant routable :</h3>
                    <p>Tout doit passer par la notion de routeur qui se trouve dans le fichier "Routes.razor" du projet "MyAppBlazor" :</p>
<pre><code>&lt;Router AppAssembly="@typeof(Program).Assembly" AdditionalAssemblies="new[] { typeof(Client._Imports).Assembly }"&gt;
    &lt;Found Context="routerData"&gt;
        &lt;RouteView RouteData="@routeData" DefaultLayout="@typeof(Layaout.MainLayout)" /&gt;
        &lt;FocusOnNavigate RouteData="@routeData" Selector="h1" /&gt;
    &lt;/Found&gt;
&lt;/Router&gt;</code></pre>
                    <h3>Blazor Web App - Interactivité serveur :</h3>
                    <p>Créons un nouveau projet "MyAppBlazor.Server" avec le type d'interactivité en "Server" et le lieu d'interactivité en "Global" tout en supprimant la partie "HTTPS".</p>
                    <h3>Blazor WASM autonome :</h3>
                    <p>Créons un nouveau projet WebAssembly "MyAppBlazor.WASM" tout en supprimant comme d'habitude le "HTTPS".</p>
                    <h3>Exercice pratique :</h3>
                    <p>Créons un petit jeu qui s'appelle "le nombre magique". Pour cela, on crée une solution "NombreMagique" avec quatre projets à l'intérieur : "NombreMagique.Components" (librairie), "NombreMagique.Hybrid" (MAUI), "NombreMagique.Server" (en "Global") et "NombreMagique.WASM".</p>
                    <p>On a des fichiers images qu'il faut copier dans le "wwwroot" des divers projets. On a un fichier "script.html" qu'il faudra modifier pour les divers projets :</p>
<pre><code>&lt;!-- Dans la balise &lt;head&gt; --&gt;
&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous"&gt;

&lt;body class="d-flex align-items-center justify-content-center"&gt;
    &lt;div class="bg-image"&gt;&lt;/div&gt;

    &lt;!-- JEU --&gt;
    &lt;div class="content"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-2 mb-3 mb-md-0 d-flex align-items-center justify-content-center"&gt;
                &lt;img src="images/etoile.png" class="rotating" height="128" /&gt;
            &lt;/div&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-8 d-flex align-items-center justify-content-center flex-column"&gt;

                &lt;h1&gt;Le nombre magique&lt;/h1&gt;

                &lt;h4&gt;Tentez de deviner un nombre entre 1 et 20&lt;/h4&gt;
                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        &lt;input type="number"/&gt;
                    &lt;/div&gt;
                    &lt;div class="col"&gt;
                        &lt;a class="btn bth-success btn-valid"&gt;
                            Go
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row mt-4"&gt;
                    &lt;!-- À UTILISER POUR AFFICHER LES VIES --&gt;
                    &lt;div class="col-auto"&gt;
                        &lt;img src="/images/life.png" height="32" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;!-- À AFFICHER À LA FIN DU JEU --&gt;
                &lt;a class="btn btn-primary btn-valid"&gt;
                    Rejouer
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-12 mt-3 mt-md-0 d-flex align-items-center justify-content-center"&gt;
                &lt;img src="images/etoile.png" class="rotating" height=128" /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;!-- Avant la fermeture de &lt;body&gt; --&gt;
&lt; script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hc4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+014" crossorgin="anonymous"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
                    <p>On doit modifier le fichier "App.razor" du projet "NombreMagique.Server" :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;base href="/" /&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous"&gt;
    &lt;HeadOutlet @rendermode="@renderMode.InteractiveServer" ./&gt;
&lt;/head&gt;

&lt;body class="d-flex align-items-center justify-content-center"&gt;
    &lt;div class="bg-image"&gt;&lt;/div&gt;
    &lt;Routes @rendermode="@RenderMode.InteravtiveServer" /&gt;
    &lt;script src="_framework/lblazor.web.js"&gt;&lt;/script&gt;
    &lt; script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hc4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+014" crossorgin="anonymous"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
                    <p>On oublie pas de supprimer les composants de base fournis dans le projet "NombreMagique.Components" et on crée dedansd le fichier "Game.razor" :</p>
<pre><code> &lt;!-- JEU --&gt;
&lt;div class="content"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-2 mb-3 mb-md-0 d-flex align-items-center justify-content-center"&gt;
            &lt;img src="images/etoile.png" class="rotating" height="128" /&gt;
        &lt;/div&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-8 d-flex align-items-center justify-content-center flex-column"&gt;

            &lt;h1&gt;Le nombre magique&lt;/h1&gt;
            @if (gameWon is null)
            {
                &lt;h4&gt;Tentez de deviner un nombre entre 1 et 20&lt;/h4&gt;

                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        @if (!string.IsNullOrEmpty(indice))
                        {
                            @indice
                        }
                        else
                        {
                            &lt;text&gt;&amp;nbsp;&lt;/text&gt;
                        }
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        &lt;input type="number" min="@NbMin" max="@NbMax" @bind="value" /&gt;
                    &lt;/div&gt;
                    &lt;div class="col"&gt;
                        &lt;a class="btn bth-success btn-valid" @onclick="CheckNumber"&gt;
                            Go
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row mt-4"&gt;
                    &lt;!-- À UTILISER POUR AFFICHER LES VIES --&gt;
                    @for (int i = 0; i &lt; nbRemainingLifes; i++)
                    {
                        &lt;div class="col-auto"&gt;
                            &lt;img src="/images/life.png" height="32" /&gt;
                        &lt;/div&gt;
                    }
                &lt;/div&gt;
            }
            else
            {
                @if (gameWon.Value)
                {
                    &lt;h3&gt;C'est gagné !&lt;/h3&gt;
                }
                else
                {
                    &lt;h3&gt;C'est perdu ! Le nombre magique était @nbMagic&lt;/h3&gt;
                }
                &lt;!-- À AFFICHER À LA FIN DU JEU --&gt;
                &lt;a class="btn btn-primary btn-valid" @onclick="InitGame"&gt;
                    Rejouer
                &lt;/a&gt;
            }
        &lt;/div&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-12 mt-3 mt-md-0 d-flex align-items-center justify-content-center"&gt;
            &lt;img src="images/etoile.png" class="rotating" height=128" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    <p>Dans le fichier "Game.razor.cs", on a le code-behind qui va nous permettre d'interagir avec notre jeu :</p>
<pre><code>// &lt;auto-generated/&gt;
namespace NombreMagique.Components;

public partial class Game
{
    private const int Lifes = 5;
    private const int NbMin = 1;
    private const int NbMax = 20;

    private int nbMagic;
    private bool? gameWon;
    private int nbRemainingLifes;
    private int? value;
    private string indice;

    protected override void OnInitizlized()
    {
        InitGame();
    }

    private void InitGame()
    {
        gameWon = null;
        nbMagic = Random.Shared.Next(NbMin, nbMax + 1);
        nbRemainingLifes = Lifes;
        value = null;
        indice = null;
    }

    private void CheckNumber()
    {
        if (value == nbMagic)
        {
            gameWon = true;
            indice = null;
            return;
        }
        nbRemainingLifes--;
        if (nbRemainingLifes &lt;= 0)
        {
            gameWon = false;
            indice = null;
            return;
        }
        if (value &gt; nbMagic) indice = "Le nombre magique est plus petit";
        else if (value &lt; nbMagic) indice = "Le nombre magique est plus grand";
    }
}</code></pre>
                    <p>On oublie d'ajouter la dépendance du Components sur le Server et de modifier le fichier "Home.razor" :</p>
<pre><code>@page "/"

&lt;NombreMagique.Components.Game /&gt;</code></pre>
                    <p>Ensuite, supprimons le dossier "Data" ainsi que les fichiers d'exemples dans le projet "NombreMagique.Hybrid" tout en ajoutant une dépendance vers le projet Components et modifions le fichier "Index.razor" :</p>
<pre><code>@page "/"

&lt;NombreMagique.Components.Game /&gt;</code></pre>
                    <p>Dans le dossier "Shared" du projet Hybrid, je n'ai ni besoin du "MainLayout.razor" ni du "NavMenu.razor" car on va déplacer le "MainLayout.razor" du projet Server. Et je nettoie la notion de Singleton dans le "MauiProgram.cs" qui n'a palus de sens ici.</p>
                    <p>On supprime le fichier CSS et on modifie le fichier "index.html" des projets Hybrid et WASM en ajoutant les liens Bootstrap et la "Bg-Image". Supprimons le loading du WASM.</p>
                    <h3>Le cycle de vie :</h3>
                    <p>Quand on tape "override" dans Visual Studio 2022, on voit, en plus des méthodes de la classe Object, les méthodes du cycle de vie.</p>
                    <p>Lors de l'appel à la méthode <span class="html">SetParametersAsync</span> du cycle de vie, il appelle les méthodes <span class="html">OnInitialized</span>, <span class="html">OnInitializedAsync</span>, <span class="html">OnParametersSet</span> et <span class="html">OnParametersSetAsync</span> du cycle de vie. Il le répète deux fois avant d'appeler les méthodes <span class="html">OnAfterRender</span> et <span class="html">OnAfterRenderAsync</span>.</p>
                    <p>On peut se demander pourquoi certaines méthodes sont appelées plusieurs fois. C'est la notion de prérendu qui va nous guider sur le chemin de la compréhension de pourquoi c'est appelé plusieurs fois.</p>
                    <p>En effet, quand un composant Blazor va être invoqué, il va être prérendu. Un composant Blazor doit forcément avoir un constructeur sans paramètres, mais il n'est pas possible de définir un constructeur avec des paramètres en Blazor (en .NET 8 actuellement) parce que le composant Blazor doit être généré dynamiquement par le framework Blazor.</p>
                    <p>Donc, le premier appel correspond au prérendu et le second appel correspond au rendu effectif quand le composant va commencer à pouvoir être interactif et qu'il va communiquer avec le serveur. C'est uniquement à partir de là qu'on aura le <span class="html">OnAfterRender</span> qui va se mettre en place.</p>
                    <p>Pour résumer, comprendre le cycle de vie est crucial pour maîtriser le fonctionnement des composants Blazor. Lorsqu'un composant Blazor est invoqué, il subit un processus de prérendu (le composant est rendu sur le serveur et ça permet de générer le contenu HTML initial qui sera renvoyé au navigateur web) suivi du rendu effectif (une fois que le contenu initial est renvoyé au naviagteur client, le composant devient interactif et peut communiquer avec le serveur).</p>
                    <p>Pour éviter le prérendu dans Blazor Server, dans le fichier App.razor, on doit modifier les Routes pour qu'elles deviennent <span class="html">&lt;Routes @rendermode=@(new InteravtiveServerRenderMode(false))" /&gt;</span>.</p>
                    <p>Quand on met un <span class="em">await Task.Delay(2000)</span> dans la méthode <span class="em">OnInitializedAsync</span>, on passera par un <span class="em">OnAfterRender</span> entre le début et la fin et on aura un <span class="em">ShouldRnder</span> avant la fin du <span class="em">SetParametersAsync</span>.</p>
                    <p>Le prerendering existe qu'en Blazor Server et non pas en Web Assembly. Dans cette dernière, on a le <span class="em">ShouldRnder</span> et le <span class="em">OnAfterRender</span> avant la fin du <span class="em">SetParametersAsync</span> et non plus après.</p>
                    <h3>Les paramètres (routing & composant) :</h3>
                    <p>Il y a une condition pour qu'on puisse passer un paramètre d'un composant A à un composant B, c'et-à-dire d'un composant parent à un composant enfant : c'est le fait que l'objet que l'on va passer en paramètres puisse être sérialisable. En effet, si on veut passer cette information, il faut que Blazor puisse la sérialiser pour la communiquer par le biais de l'arbre de rendu au composant enfant.</p>
                    <p>Par exemple, le fichier SubComponent.razor :</p>
<pre><code>&lt;p&gt;
    SubComponent : @Data
&lt;/p&gt;
@code {
    [Parameter]
    public string Data { get; set; }
}</code></pre>
                    <p>Il va être appelé  comme ceci dans le composant parent :</p>
<pre><code>&lt;SubComponent Data="Valeur du composant parent" /&gt;</code></pre>
                    <p>Pour rendre ce paramètre obligatoire, on doit modifier l'annotation comme ceci :</p>
<pre><code>[Parameter, EditorRequired]</code></pre>
                    <p>On peut également extraire un paramètre d'une URL comme par exemple :</p>
<pre><code>@page "/{Data}"

&lt;p&gt;
    Infos de route : @Data
&lt;/p&gt;

@code {
    [Parameter]
    public string Data { get; set; }
}</code></pre>
                    <p>Si on veut accéder à la page <span class="em">localhost:5283/?Data=toto</span>, on fait ceci :</p>
<pre><code>@page "/"

&lt;p&gt;
    Infos de route : @Data
&lt;/p&gt;

@code {
    [SupplyParameterFromQuery]
    public string Data { get; set; }
}</code></pre>
                    <p><a href="https://learn.microsoft.com/fr-fr/aspnet/core/fundamentals/routing?view=aspnetcore-8.0&WT.mc_id=DT-MVP-5004836#route-constraints" target="_blank">Voir la documentation de Microsoft pour les contraintes de route.</a></p>
                    <h3>OnParametersSet :</h3>
                    <p>Pour rappel, la méthode <span class="html">OnParametersSet</span> est appelée après celle de <span class="html">OnInitialized</span>.</p>
                    <p>L'affectation des paramètres du composant n'est pas faite par la méthode <span class="html">OnParametersSet</span> mais par la méthode <span class="html">SetParametersAsync</span>.</p>
                    <p>Si tous les paramètres, de route ou de composant, sont tous initialisés dans la méthode <span class="em">OnInitialized</span>, on est en droit de se poser la question à quoi sert la méthode <span class="em">OnParametersSet</span>.</p>
                    <p>Cette méthode <span class="em">OnParametersSet</span> sert à réagir aux modifications des paramètres du composant après leur initialisation initiale, c'est-à-dire qu'elle est appelée à chaque fois que les paramètres du composant sont mis à jour.</p>
                    <h3>OnAfterRender :</h3>
                    <p>Cette méthode est un peu particulière car, comme son nom l'indique, elle sera exécutée lorsque le composant sera affiché.</p>
                    <p>On va mettre dans cette méthode tout le code qui va se passer après le rendu du composant. Le paramètre <span class="em">firstRender</span> est à <span class="em">true</span> comme dans l'exemple suivant :</p>
<pre><code>protected override async Task OnAfterRenderAsync(bool firstRender)
{
    _steps.Add(nameof(OnAfterRenderAsync));
    await Console.Write($"OnAfterRenderAsync - DEBUT (First ? {firstRender})");

    if (firstRender)
    {
        await Task.Delay(5000);
        _apiResponse = "Réponse de l'API";
        StateHasChanged();
    }

    await base.OnAfterRenderAsync(firstRender);
    await Console.Write($"OnAfterRenderAsync - FIN (First ? {firstRender})");
}</code></pre>
                    <p>Une autre solution que je n'ai pas mentionnée est d'utiliser la méthode <span class="html">StateHasChanged</span> dans le <span class="em">OnInitialized</span> pour provoquer un 1<sup>er</sup> rendu avant votre appel API, mais le résultat est similaire.</p>
                    <p>Chaque fois que Blazor a détecté qu'une interface doit être rafraîchie, il va appeler la méthode <span class="html">ShouldRender</span> pour savoir si le composant va être rafraîchi en retournant un booléen. Il n'existe pas de méthode qui s'appelle <span class="em">ShouldRenderAsync</span>.</p>
                    <p>Cela permet au développeur de contrôler finement le rendu des composants en fonction de divers critères tels que l'état interne du composnat, les propriétés qui ont changé ou d'autres conditions métier. En implémentant <span class="em">ShouldRender</span>, vous pouvez optimiser les performances de votre application en évitant les rendus inutiles lorsque le contenu du composant n'a pas changé.</p>
                    <h3>SetParametersAsync & BuildRenderTree :</h3>
                    <p>On a vu précédemment que la méthode <span class="em">SetParametersAsync</span> encadre l'appel au cycle d'initialisation de notre composant composé de <span class="em">OnInitialized</span> et de <span class="em">OnParametersSet</span>. Voici son implémentation basique :</p>
<pre><code>public override async Task SetParametersAsync(ParameterView parameters)
{
    await base.SetParametersAsync(parameters);
}</code></pre>
                    <p>La méthode <span class="html">BuilderRenderTree</span> est une méthode automatiquement générée par le compilateur qui va lire le code HTML ou plus ou moins le code RAZOR du composant et va construire l'arbre de rendu.</p>
                    <p>Voici comment ça fonctionne :</p>
<pre><code>public class ElementsList : ComponentBase
{
    [Parameter, EditorRequired]
    public List&lt;string&gt; Items { get; set; }

    portected override void BuilderRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "ul"); // &lt;ul&gt;
        int sequence = 1;
        foreach (var item in Items) {
            builer.OpenElement(sequence, "li"); // &lt;li&gt;
            builder.AddContent(++sequence, item); // valeur Item
            builder.CloseElement(); // &lt;/li&gt;
            sequence++;
        }
        builder.CloseElement(); //&lt;/ul&gt;
    }
}</code></pre>
                    <p>Il sera appelé comme ceci :</p>
<pre><code>&lt;ElementsList Items="_steps" /&gt;</code></pre>
                    <p>En résumé, en combinant <span class="em">SetParametersAsync</span> pour gérer les mises à jour de paramètres et <span class="em">BuildRenderTree</span> pour constuire l'arbre de rendu, vous avez un moyen puissant de créer des composants Blazor flexibles et dynamiques.</p>
                    <h3>Dispose :</h3>
                    <p>Cependant, lorsqu'un composant n'est plus affiché à l'écran, il va se décharger de la mémoire et donc typiquement être détruit dans le sens où la mémoire qu'il utilisait va pouvoir être collectée mais surtout il va devoir nettoyer d'éventuelles ressources qu'il aurait occupées.</p>
                    <p>On peut implémenter l'interface <span class="html">IDisposable</span> ou <span class="html">IAsyncDisposable</span> et implémenter la méthode <span class="html">public void Dispose()</span> ou la méthode <span class="html">public async ValueTask DisposeAsync()</span> selon si c'est synchrone ou asynchrone.</p>
                    <h3>TP 2 : Photo Explorer (v1) :</h3>
                    <p>On va d'abord créer une solution nomée PhotoExplorer avec la ligne de commandes suivante :</p>
<pre><code>dotnet new sln -n PhotoExplorer</code></pre>
                    <p>Ensuite, on va ajouter trois nouveaux dossiers de solution nommés "api", "libs" et "ui". On va ensuite copier tous les éléments depuis le zip "api" dans un nouveau dossier nommé "PhotoExplorer.Api". Dans la solution, on oublie pas d'ajouter un projet existant dans le dossier "api".</p>
                    <p>À partir de ce moment-là, on va vérifier et gérer les mises à jour des packages NuGet.</p>
                    <p>On va ajouter un nouveau projet Blazor Web App nommé "PhotoExplorer.Manager" dans le dossier "ui". On décoche le HTTPS, on met aucun type d'authentification et "Server" "Per page/component" pour l'interactivité.</p>
                    <p>On va également ajouter un nouveau projet Bibliothèque de classes Razor nommé "PhotoExplorer.Components" dans le dossier "libs". Dans le dossier "wwwroot" du projet, on copie les dossiers "css" et "images" et on crée un dossier "Layouts" dans lequel on met le fichier "MainLayout.razor".</p>
                    <p>Maintenant, il faut pas oublier d'ajouter une référence vers le projet "Components" dans le projet "Manager" ainsi que supprimer le répertoire "Layout" et ajouter la ligne suivante dans le fichier "_Imports.razor" :</p>
<pre><code>@using PhotoExplorer.Components.Layouts</code></pre>
                    <p>Ainsi que dans le fichier "Routes.razor", le MainLayout pointe bien vers le bon fichier.</p>
                    <p>Ensuite, on va créer un projet Application WebAssembly Blazor nommé "PhotoExplorer.Explorer" sans "HTTPS" et on va rajouter la référence vers le projet "Components", supprimer le dossier "Layout" et ajouter la ligne dans le "_Imports.razor".</p>
                    <p>Enfin, on va créer le dernier projet qui est un projet Application .NET MAUI Blazor nommé "PhotoExplorer.Mobile" et ajouter la référence vers le projet "Components". On supprime les dossiers "Data" et "Shared", on supprime les fichiers exemples dans le dossier "Pages" et on ajoute la ligne dans le fichier "_Imports.razor". Dans le "MauiProgram.cs", on va supprimer le lien vers le "Data" et le Service.</p>
                    <p>Commençons maintenant à créer nos premiers composants. On va créer un composant "PhotoList.razor" dans le projet "Components".</p>
                    <p>On va créer un dossier "Models" dans le projet "Components" toujours, ajouter une classe photo, copier le JSON d'une photo récupérée depuis l'API et cliquer sur "Édition", "Collage spécial" et "Coller le code JSON en tant que classes". Le résultat final sera :</p>
<pre><code>namespace PhotoExplorer.Components.Models;

public class Photo
{
    public string Id { get; set; }
    public string Path { get; set; }
    public string Author { get; set; }
    public string Description { get; set; }
}</code></pre>
                    <p>Dans le fichier "PhotoList.razor.cs", on rajoute un <span class="em">private List&lt;Photo&gt;? _photos;</span>.</p>
                    <p>Dans le fichier "PhotoList.razor", on aura ceci :</p>
<pre><code>@if(_photos is null)
{
    &lt;div class="d-flex align-items-center justify-content-center"&gt;
        &lt;h1&gt;Chargement...&lt;/h1&gt;
    &lt;/div&gt;
}
else
{
    &lt;div class="row"&gt;
        @foreach (var photo in _photos)
        {
            &lt;div class="card shadow" style="width: 18trm;"&gt;
                &lt;img src="https://localhost:7198/photos/@photo.Path" class="card-img-top" alt="@photo.Description"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;@photo.Description&lt;/h5&gt;
                    &lt;p class="card-text"&gt;
                        @photo.Author
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        }
    &lt;/div&gt;
}</code></pre>
                    <p>On oublie pas de rajouter les liens CDN de Bootstrap dans le fichier "App.razor" ainsi que le lien suivant :</p>
<pre><code>&lt;link rel="stylesheet" href="_content/PhotoExplorer.Components/css/site.css"/&gt;</code></pre>
                    <p>Voici l'implémentation du fichier "PhotoList.razor.cs" :</p>
<pre><code>namespace PhotoExplorer.Components;

public partial class PhotoList
{

    private List&lt;Photo&gt;? _photos;

    protected override async Task OnInitializedAsync()
    {
        using (var client = new HttpClient())
        {
            _photos = await client.GetFromJsonAsync&lt;List&lt;Photo&gt;&gt;("https://localhost:7198/photos");
        }
    }
}</code></pre>
                    <p>Attention aux CORS de la WASM où il faut bien indiquer l'URL de la WASM autorisée dans l'API.</p>
                    <h3>La navigation optimisée en Blazor Web App .NET 8 :</h3>
                    <p>La navigation dans une application Blazor est essentielle pour permettre aux utilisateurs de passer d'une page à une autre de manière fluide.</p>
                    <p>La balise de base est le <span class="html">&lt;a&gt;</span> qui est, comme en HTML, utilisée pour créer des liens dans une page web. Par exemple suivant :</p>
<pre><code>&lt;a href="2"&gt;Aller sur la page 2&lt;/a&gt;</code></pre>
                    <p>C'est la navigation intelligente de Blazor qui fait un <span class="em">fetch</span> en JavaScript en arrière plan.</p>
                    <p>Si vous voulez désactiver cette navigation intelligente de Blazor pour notamment contrôler le chargement précoce des ressources, il faut modifier le fichier "App.razor" du projet "Components" comme ceci :</p>
<pre><code>&lt;script src="_framework/blazor.web/js" autostart="false"&gt;&lt;/script&gt;
&lt;script&gt;
    Blazor.start({
        ssr: {
            disableDomPreservation: true
        }
    });
&lt;/script&gt;</code></pre>
                    <p>Cette configuration empêchera Blazor de préserver le DOM lors de la navigation, offrant ainsi un contrôle accru sur le chargement des ressoruces.</p>
                    <p>Microsoft a introduit un composant dédié à la navigation : <span class="html">NavLink</span>. Dans sa méthode <span class="em">BuildRenderTree</span>, ce composant génère une balise <span class="em">&lt;a&gt;</span>.</p>
                    <p>L'avantage du <span class="em">NavLink</span> par rapport à un <span class="em">a</span> classique est qu'il va gérer pour nous la notion de <span class="em">isActive</span>. En se basant sur Bootstrap, il utilise la classe CSS <span class="em">active</span> mais vous pouvez définir votre propre classe en rajoutant la propriété <span class="html">ActiveClass</span> dans le composant <span class="em">NavLink</span>.</p>
                    <p>On peut également ajouter des attributs additionnels à ce composant comme dans l'exemple suivant :</p>
<pre><code>&lt;NavLink ActiveClass="current" AdditionalAttributes="@(new Dictionary&lt;string, object&gt;
{
    ["data-active"] = true,
    ["href"] = "/"
})"&gt;Aller sur l'accueil&lt;/NavLink&gt;</code></pre>
                    <p>Ce composant a aussi la notion de <span class="em">Match</span> qui va déterminer le comportement à avoir par rapport à ce lien en particulier. Par exemple, pour la route <span class="em">/personnes/details/1</span>, on peut dire <span class="em">Match="NavLinkMatch.All"</span> pour dire qu'on prend l'URL au complet ou <span class="em">Math="NavLinkMatch.Prefix"</span> pour dire que l'URL <span class="em">/personnes</span> suffit.</p>
                    <h3>Les services :</h3>
                    <p>Il faut savoir que <span class="html">NavigationManager</span> est un service fourni par Blazor.</p>
                    <p>Mais avant tout, il faut savoir qu'est-ce qu'un service. Un service va nous permettre de respecter le principe "SOLID S", c'est-à-dire de délocaliser la responsabilité de faire quelque chose dans une classe qui ne fera que ça.</p>
                    <p>On va créer dans notre librairie de composants, un nouveau dossier "Services" dans lequel on va ajouter un nouvel élément "IApiService.cs" avec le code suivant :</p>
<pre><code>public interface IApiService
{
    Task&lt;string&gt; GetDataFromApi();
}</code></pre>
                    <p>Pour l'appel dans notre fichier, on doit faire :</p>
<pre><code>[Inject] private IApiService ApiService { get; set; } = default!</code></pre>
                    <p><span class="em">default!</span> permet de dire qu'il y aura une valeur dans ce ApiService.</p>
                    <p>Dans notre projet "Blazor Server", on va créer le dossier "Services" avec la classe "ServerApiService.cs" ci-dessous :</p>
<pre><code>public class ServerApiService : IApiService
{
    public async Task&lt;string&gt; GetDataFromApi()
    {
        await Task.Delay(1000);
        return "Valeur API Serveur";
    }
}</code></pre>
                    <p>Dans le "Progam.cs" du projet "Blazor Server", on doit rajouter le service avec la ligne suivante :</p>
<pre><code>builder.Services.AddSingleton&lt;IApiService, ServerApiService&gt;();</code></pre>
                    <p>Comme dans le projet "Blazor Server", on doit créer le dossier "Services" et la classe "WASMApiService" dans le projet "WASM" tout en oubliant pas de rajouter ce service dans le "Program.cs".</p>
                    <p>Dans le projet "Hybrid", il faut faire la même chose, c'est-à-dire la classe "HybridApiService" et son ajout dans "MauiProgram.cs".</p>
                    <h3>Durée de vie des services (Transient & Singleton) :</h3>
                    <p>Le Singleton Service aura une instance unique pour toute la durée de vie de l'application mais également pour tous les utilisateurs de l'application.</p>
                    <p>Le Scoped Service permet de définir un périmètre et le Transient Service est éphémère.</p>
                    <p>Il faut savoir que si le conteneur gère la construction et l'instanciation de notre service, il va aussi gérer sa destruction/sa durée de vie. Si on ne spécifie rien, la durée de vie du service sera liée à l'utilisation qu'on va en faire et donc sera typiquement collectée par le garbage collector.</p>
                    <p>On peut tout simplement dire également qu'on veut que le service soit <span class="em">IDisposable</span> pour récrire la fonction <span class="em">Dispose</span>.</p>
                    <p>Comme le Transient Service est éphémère, ça veut tout simplement dire également qu'il sera détruit dès que le composant sera détruit et il sera reconstruit à chaque demande d'un composant.</p>
                    <p>Donc, il sera crée et supprimé lors du pré-rendu et fera la même chose pour le rendu effectif.</p>
                    <p>Attention, un service éphémère peut utiliser un Singleton mais inversement c'est pas possible par ce que le Singleton est créé une seule fois or le service éphémère qu'il prend en paramètre lui devrait être recréé chaque fois donc ce n'est pas possible.</p>
                    <p>Peu importe l'interactivité (WASM, Hybrid ou Server), le Transient Service sera recrée à chaque fois.</p>
                    <h3>Le cas particulier de Scoped :</h3>
                    <p>Selon les variantes de Blazor, on va pas avoir le même résultat avec le Scoped Service.</p>
                    <p>La variante la plus facile à implémenter avec le Scoped Service est WASM. En Web Assembly, la notion de Scoped va être intimement liée à la session de l'utilisation sur notre application Web Assembly. Donc, Scoped est équivalent à Singleton dans WASM et dans Hybrid.</p>
                    <p>Dans un projet "Blazor Server", le Scoped Service en interactivité globale va se comporter comme un Singleton par session utilisateur.</p>
                    <p>Alors que le Scoped Service en interactivité par composants ou sans interactivité sera lié à la durée de vie du composant. Donc, une fois que le render est terminé, le composant est dispose et donc le service avec.</p>
                    <h3>NavigationManager :</h3>
                    <p>Le NavigationManager est un Scoped Service injecté automatiquement par le framework Blazor dans nos applications. Donc, on peut l'utiliser n'importe où n'importe quand sans le configurer. C'est également une classe abstraite, c'est-à-dire qu'on aura pas la même instance concrète de cette classe en fonction de la variante de Blazor (Hybrid, Server ou WASM).</p>
                    <p>Comme c'est un service, il faut pas oublier de l'injecter dans notre code via <span class="em">@innject</span> ou via <span class="em">[Inject]</span>. Le cas tout à fait classique est :</p>
<pre><code>@inject NavigationManager Navigation

&lt;button @onclick="@(() =&gt; Navigation.NavigateTo("/2"))"&gt;
    Aller sur la page 2
&lt;/button&gt;</code></pre>
                    <p>Attention, contrairement au href et au NavLink, pour que la fonction <span class="em">NavigateTo</span> fonctionne, il est nécessaire d'être en mode interactif.</p>
                    <p>On peut utiliser la méthode <span class="em">NavigateTo</span> du <span class="em">NavigationManager</span> pour déclencher des transitions entre les pages de manière programmatique.</p>
                    <p>Le paramètre <span class="em">forceLoad</span> de la méthode <span class="em">NavigateTo</span> va rafraîchir complètement le contexte de notre application. Ça peut être utile pour des problématiques de sécurité avec l'authentification. Ça peut être utile aussi pour pouvoir éventuellement libérer d'éventuelles ressources. Il est défini à <span class="em">false</span> par défaut.</p>
                    <p>Le paramètre <span class="em">replace</span> de la méthode <span class="em">NavigateTo</span> est défini à <span class="em">false</span> par défaut. Il va simplement remplacer l'élément dans l'historique de navigation sans ajouter une nouvelle entrée.</p>
                    <p>On a les propriétés <span class="em">BaseUri</span> et <span class="em">Uri</span> du <span class="em">NavigationManager</span>. Ce dernier va aussi nous donner les informations de contexte de notre navigation actuelle. En gros, vous n'aurez pas besoin de faire des appels JavaScript pour dire qu'elle est l'URL de ma page par exemple.</p>
                    <p>Le code suivant permet de récupérer ce qui est après le BaseUri dans la valeur de la propriété Uri :</p>
<pre><code>var str = Navigation.ToBaseRelativePath(Navigation.Uri);</code></pre>
                    <p>En gros, ça permet de remplacer le BaseUri dans l'Uri par une chaîne vide et de stocker cette nouvelle valeur dans la variable str.</p>
                    <p>La méthode <span class="em">Refresh()</span> pemet de rafraîchir la page actuelle, simulant l'action d'appuyer sur F5 dans le navigateur.</p>
                    <p>NavigationManager propose la possibilité de passer un état quand on navigue d'un composant à l'autre pour pouvoir justement envoyer des informations sans passer par la notion de paramètres.</p>
                    <p>La troisième signature de la méthode <span class="em">NavigateTo</span> permet de spécifier des <span class="em">NavigationOptions</span> qui est une structure qui contient les deux booléens vus précédemment (ForceLoad et ReplaceHistoryEntry) mais également le HistoryEntryState. Par exemple :</p>
<pre><code>@inject NavigationManager Navigation

&lt;button @onclick="@(() =&gt; Navigation.NavigateTo("/2", new NavigationOptions {
    HistoryEntryState = "contexte de la page 1"
}))"&gt;
    Aller sur la page 2
&lt;/button&gt;</code></pre>
                    <p>Il propose aussi la possibilité de s'abonner et de mettre du code lorsque l'utilisateur va changer de composant.</p>
                    <p>Par exemple, dans le fichier "MainLayout" :</p>
<pre><code>@inherits LayoutComponentBase
@inject NavigationManager Navigation

&lt;p&gt;
    Page courante : @_page
&lt;/p&gt;

@Body

@code {
    private string _page = "Index";
    protected override void OnInitialized()
    {
        Navigation.LocationChanged += (s, e) =&gt;
        {
            // _page = Navigation.ToBaseRelativePath(e.Location);
            // StateHasChanged();
        };
        Navigation.RegisterLocationChangingHandler(LocationChanged);
        base.OnInitialized();
    }

    public async ValueTask LocationChanged(LocationChangingContext context) {
        _page = context.TargetLocation;
    }
}</code></pre>
                    <p>Enfin, le composant <span class="html">NavigationLock</span> permet de verrouiller la navigation pendant le chargement d'une page, évitant ainsi que l'utilisateur ne navigue à une autre page avant que le chargement en cours soit terminé. Par exemple :</p>
<pre><code>@page "/2"

&lt;a href="/"&gt;Aller sur la page 1&lt;/a&gt;

&lt;p&gt;
    Contexte de navigation : @context
&lt;/p&gt;

&lt;button @onclick="() =&gt; count++"&gt;Compteur : @count&lt;button&gt;

&lt;NavigationLock ConfirmExternalNavigation="@(count &gt; 0)" OnBeforeInternalNavigation="OnBeforeInternalNavigation"&gt;
&lt;/NavigationLock&gt;

@code {
    private string? context;
    private int count;

    protected override void OnInitialized()
    {
        context = Navigation.HistoryEntryState;
        base.OnInitialized();
    }

    private async Task OnBeforeInternalNavigation(LocationChangingContext context)
    {
        if (count &gt; 0)
        {
            context.PreventNavigation();
        }
    }

}</code></pre>
                    <h3>Déterminer la variante de Blazor dans un composant :</h3>
                    <p>Pour déterminer la variante de Blazor dans un composant, on peut utiliser le NavigationManager car il est différent d'une variante à l'autre. On peut faire ainsi :</p>
<pre><code>[Inject] private NavigationManager Navigation { get; set; } = default !;

private string _platform = "Inconnue";

protected override void OnInitialized()
{
    _platform = Navigation.GetType().AssemblyQualifiedName switch
    {
        string s when s.Contains("Server", StringComparaison.OrdinalIgnoreCase) =&gt; "Blazor Web App Server",
        string s when s.Contains("WebAssembly", StringComparaison.OrdinalIgnoreCase) =&gt; "Blazor WebAssembly",
        _ =&gt; "Hybrid"
    };
}</code></pre>
                    <p>On peut également faire autrement :</p>
<pre><code>[Inject] private NavigationManager Navigation { get; set; } = default !;

private string _platform = "Blazor Web App Server";

protected override void OnInitialized()
{
    var isWasm = RuntimeInformation.IsOSPlatform(OSPlatform.Create("BROWSER"));
    if (isWasm)
    {
        _platform = "Blazor WebAssembly";
    }
    else
    {
        var isHybrid = RuntimeInformation.IsOSPlatform(OSPlatform.Create("IOS")) || RuntimeInformation.IsOSPlatform(OSPlatform.Create("ANDROID")) || RuntimeInformation.IsOSPlatform(OSPlatform.Create("WINDOWS"));
        _platform = "Blazor Hybrid";
    }
}</code></pre>
                    <h3>Appels HTTP (WASM & Hybrid) :</h3>
                    <p>Dans le projet de librairie, on crée l'élément "Dogs" qui va afficher une photo d'un client :</p>
<pre><code>public partial class Dogs
{

    [Inject] private IDogService DogService { get; set; }

    private string? picture;

    protected override Task OnInitializedAsync() {
        _picture = await DogService.GetDogImage();
    }
}</code></pre>
                    <p>On crée également un service "IDogService" avec une méthode <span class="em">public async Task&lt;string&gt; getDogImage();</span>.</p>
                    <p>Dans le projet WASM, on crée le service "WASMDogService" comme ceci :</p>
<pre><code>public class WASMDogService : IDogService
{
    private readonly HttpClient client;

    public WASMDogService(HttpClient client)
    {
        this.client = client;
    }

    public async Task&lt;string&gt; GetDogImage() {
        var data = await client.GetAsync("https://dog.ceo/api/breeds/image/random");
        if (data.IsSuccessStatusCode)
        {
            JsonDocument doc = JsonDocument.Parse(await data.Content.ReadAsStringAsync());
            return doc.RootElement.GetProperty("message").GetString();
        }
        return "";
    }
}</code></pre>
                    <p>En Hybrid, il faut faire un <span class="em">builder.Services.AddScoped(sp =&gt; new HttpClient());</span>.</p>
                    <h3>Appels HTTP (Blazor Web App) :</h3>
                    <p>Dans notre projet "Server", on va créer la classe "ServerDogsService" :</p>
<pre><code>public class ServerDogsService : IDogService
{
    private readonly IHttpClientFactory httpClientFactory;

    public ServerDogsService(IHttpClientFactory httpClientFactory)
    {
        this.httpClientFactory = httpClientFactory;
    }

    public async Task&lt;string&gt; GetDogImage() {
        using var client = httpClientFactory.CreateClient();
        var data = await client.GetAsync("https://dog.ceo/api/breeds/image/random");
        if (data.IsSuccessStatusCode)
        {
            JsonDocument doc = JsonDocument.Parse(await data.Content.ReadAsStringAsync());
            return doc.RootElement.GetProperty("message").GetString();
        }
        return "";
    }
}</code></pre>
                    <p>Dans le "Program.cs" du projet Server, on doit ajouter le <span class="em">builder.Services.AddhttpClient();</span>.</p>
                    <h3>TP 3 : Photo Explorer (v2) :</h3>
                    <p>On va créer le dossier "Services" dans le projet "Components" et on y crée l'interface "IPhotoService" avec la méthode <span class="em">Task&lt;List&lt;Photo&gt;?&gt; GetPhotosFromApi();</span>.</p>
                    <p>Dans le fichier "PhotoList.rajor.cs" de mon projet "Components", on va injecter ce nouveau service :</p>
<pre><code>public partial class PhotoList
{
    [Inject] private IPhotoService PhotoService { get; set; } = default!;

    private List&lt;Photo&gt;? _photos;

    protected override async Task OnInitializedAsync()
    {
        var photos = await PhotoService.GetPhotosFromApi();
        if (photos is not null)
        {
            _photos = photos;
        }
        else
        {
            _photos = new List&lt;Photo&gt;();
        }
    }
}</code></pre>
                    <p>Dans le projet WASM, on crée la classe "WASMPhotoService" et on l'ajoute dans le "Program.cs" :</p>
<pre><code>public class WASMPhotoService : IPhotoService
{
    private readonly HttpClient client;

    public WASMPhotoService(HttpClient client)
    {
        this.client = client;
    }

    public Task&lt;List&lt;Photo&gt;?&gt; GetPhotosFromApi()
    {
        return client.GetFromJsonAsync&lt;List&lt;Photo&gt;&gt;("https://localhost:7198/photos");
    }
}</code></pre>
                    <p>Pour le projet Hybrid, c'est la même chose. Et pour le projet Server, on aura un IHttpClientFactory come vu précédemment.</p>
                    
                </article>
                <article>
                    <h2 id="ASP.NET_creation_api_web_c#_minimal_apis">ASP.NET : Création d'API Web avec C# et Minimal APIs :</h2>
                    <h3>Prérequis :</h3>
                    <ul>
                        <li>
                            <p>Connaître les fondamentaux du langage C#</p>
                        </li>
                        <li>
                            <p>Avoir installé le SDK .NET 6+</p>
                        </li>
                        <li>
                            <p>Avoir un environnement de développement (Visual Studio Code, Visual Studio, Rider, etc.)</p>
                        </li>
                        <li>
                            <p>Être motivé !</p>
                        </li>
                    </ul>
                    <h3>Introduction :</h3>
                    <p>API veut dire <q>Application Programming Interface</q>.</p>
                    <p>Le rôle d'une API est d'exposer du comportement métier à d'autres applications.</p>
                    <p>La communication d'une API peut se faire :</p>
                    <ul>
                        <li>
                            <p>En XML</p>
                        </li>
                        <li>
                            <p>En JSON (recommandé)</p>
                        </li>
                        <li>
                            <p>En gRPC (ultra performant)</p>
                        </li>
                    </ul>
                    <p>En .NET, il est possible de faire des APIs de deux façons :</p>
                    <ul>
                        <li>
                            <p>Avec les minimals APIs (plus rapide & performant)</p>
                        </li>
                        <li>
                            <p>Avec le pattern MVC</p>
                        </li>
                    </ul>
                    <p>Dans ce cours, nous verrons les deux façons de procéder, de telle sorte que vous puissiez faire votre choix, mais nous mettrons le focus sur la partie minimal APIs, car c'est l'approche moderne recommandée.</p>
                    <h3>REST :</h3>
                    <p>Les APIs respectent la philosophie REST (Representational State Transfer).</p>
                    <p>On va utiliser des verbes HTTP pour indiquer l'intention :</p>
                    <ul>
                        <li>
                            <p><span class="html">GET</span> &#8594; lecture</p>
                        </li>
                        <li>
                            <p><span class="html">POST</span> &#8594; création</p>
                        </li>
                        <li>
                            <p><span class="html">PUT/PATCH</span> &#8594; mise à jour</p>
                        </li>
                        <li>
                            <p><span class="html">DELETE</span> &#8594; suppression</p>
                        </li>
                    </ul>
                    <p>On va utiliser les codes HTTP pour indiquer le résultat :</p>
                    <ul>
                        <li>
                            <p><span class="html">2xx</span> &#8594; résultat positif</p>
                        </li>
                        <li>
                            <p><span class="html">3xx</span> &#8594; ressource déplacée</p>
                        </li>
                        <li>
                            <p><span class="html">4xx</span> &#8594; erreur dans la requête</p>
                        </li>
                        <li>
                            <p><span class="html">5xx</span> &#8594; erreur sur le serveur</p>
                        </li>
                    </ul>
                    <h3>Création du projet :</h3>
                    <p>Dans PowerShell, on lance la commande suivante pour créer un projet Console que j'ai nommé "MinimalApis" :</p>
<pre><code>dotnet new console</code></pre>
                    <p>On va modifier le fichier "MinimalApis.csproj" :</p>
<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
        &lt;ImplicitUsings&gt;enable&lt;ImplicitUsings&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;

&lt;/Project&gt;</code></pre>
                    <p>On va recharger les projets et modifier le fichier "Program.cs" :</p>
<pre><code>var builder = WebApplication.CreateBuilder();

var app = builder.Build();

app.MapGet("/hello", () =&gt; "Hello World !");

app.Run();</code></pre>
                    <p>Quand on lance le projet et qu'on accède à l'URL "/hello", la page va afficher "Hello World !".</p>
                    <h3>Les autres verbes HTTP :</h3>
                    <p>Il existe également les méthodes <span class="html">MapDelete()</span>, <span class="html">MapPost()</span>, <span class="html">MapPut()</span> et <span class="html">MapPatch()</span>.</p>
                    <p>Pour utiliser plusieurs verbes HTTP pour une seule URL, on utilisera la méthode <span class="html">MapMehods()</span> :</p>
<pre><code>app.MapMethods("/methods", new[] { "GET", "POST" }, () =&gt; "Hello methods");</code></pre>
                    <p>Pour faire des requêtes via une URL, on va installer le logiciel "Postman". On va désactiver la certification SSL.</p>
                    <h3>Gestion des objets et des routes :</h3>
                    <p>On va créer un nouveau record "Article" :</p>
<pre><code>namespace MinimalApis
{
    public record Article(int Id, string Title);
}</code></pre>
                    <p>On peut envoyer un nouvel article en GET via l'url "/article" avec la ligne suivante : </p>
<pre><code>app.MapGet("/article", () =&gt; new Article(1, "Marteau"));</code></pre>
                    <p>Pour récupérer l'article avec un tel id en GET, on doit faire :</p>
<pre><code>app.MapGet("/articles/{id}", (int id) =&gt; new Article(id, "Marteau"));</code></pre>
                    <h3>Gestion des résultats :</h3>
                    <p>On va créer une liste d'articles pour chercher le bon article selon l'id :</p>
<pre><code>var list = List&lt;Article&gt;
{
    new Article(1, "Marteau"),
    new Article(2, "Scie")
};

aap.MapGet("/articles/{id:int}", (int id) =&gt;
{
    var article = list.Find(a =&gt; a.Id == id);
    if (article is not null) return Results.Ok(article);

    return Results.notFound();
});</code></pre>
                    <h3>Gestion de paramètres entrants (route, requête, etc.) :</h3>
                    <p>On peut utiliser l'annotation <span class="html">FromRoute</span> pour bien préciser que le paramètre de la lambda est lié au paramètre dans la route :</p>
<pre><code>app.MapGet("/personne/{nom}", (
    [FromRoute(Name = "nom")] string nomPersonne,
    [FromQuery(Name = "prenom")] string? prenomPersonne,
    [FromHeader(Name = "Accept-Encoding")] string encoding) =&gt; Results.Ok($"{nomPersonne} {prenomPersonne} {encoding}"));</code></pre>
                    <p>L'annotation <span class="html">FromQuery</span> permet de donner un nom plus explicite pour le paramètre de l'URL.</p>
                    <p>L'annotation <span class="html">FromHeader</span> permet de récupérer une valeur depuis le Header de la réponse HTTP.</p>
                    <h3>Gestion des paramètres spéciaux :</h3>
                    <p>Créons une nouvelle classe "Personne" :</p>
<pre><code>namespace MinimalApis
{
    public class Personne
    {
        public string Nom { get; set; }
        public string Prenom { get; set; }

        public static bool TryParse(string value, out Personne? person)
        {
            try
            {
                var data = value.Split(' ');
                person = new Personne
                {
                    Nom = data[0],
                    Prenom = data[1]
                };
                return true;
            }
            catch (Exception)
            {
                person = null;
                return false;
            }
        }

        public static async ValueTask&lt;Personne&gt; BindAsync(HttpContext context, ParameterInfo parameterInfo)
        {
            try
            {
                using var streamReader = new StreamReader(context.Request.Body);
                var body = await streamReader.readToEndAsync();
                var data = body.Split(' ');
                var person = new Personne
                {
                    Nom = data[0],
                    Prenom = data[1]
                };
                return person;
            }
            catch (Exception)
            {
                return null;
            }
        }
    }
}</code></pre>
                    <p>Dans le "Program.cs", on peut envoyer en GET la personne :</p>
<pre><code>app.MapGet("/personne/identite", (Personne p) =&gt; Results.Ok(p)); <span class="em">// appelle la méthode TryParse()</span>

app.MapPost("/personne/identite", (Personne p) =&gt; Results.Ok(p)); <span class="em">// appelle la méthide BindAsync()</span></code></pre>
                    <h3>Gestion des services :</h3>
                    <p>On va créer une classe "ArticleService" :</p>
<pre><code>namespace MinimalApis
{
    public class ArticleService
    {
        private List&lt;Article&gt; list = new List&lt;Article&gt;
        {
            new Article(1, "Marteau"),
            new Article(2, "Scie")
        };

        public List&lt;Article&gt; GetAll() =&gt; list;

        public Article Add(string title)
        {
            var article = new Article(list.Max(a =&gt; a.Id) + 1, title);
            list.Add(article);
            return article;
        }
    }
}</code></pre>
                    <p>On va ajouter ce service en Singleton dans le builder du programme principal :</p>
<pre><code>builder.Services.AddSingleton&lt;ArticleService&gt;();

app.MapPost("/articles", (Article a, ArticleService service) =&gt;
{
    var result = service.Add(a.Title);
    return Results.Ok(result);
});</code></pre>
                    <p>On peut également utiliser l'annotation "<span class="html">FromServices</span>".</p>
                    <h3>Exercice pratique :</h3>
                    <p>Le but du TP est de réaliser un exercice en totale autonomie de A à Z.</p>
                    <p>Ce TP vous fera implémenter une API de gestion des tâches (TodoList).</p>
                    <p>Pour réaliser ce TP dans les meilleures conditions, voici quelques instructions destinées à vous guider :</p>
                    <ol>
                        <li>
                            <p>Créer un projet</p>
                        </li>
                        <li>
                            <p>Créer un record pour héberger les données d'un Todo (titre, startDate, endDate)</p>
                        </li>
                        <li>
                            <p>Créer un service pour gérer les Todo (singleton)</p>
                        </li>
                    </ol>
                    <p>Dans PowerShell, on commence par la commande :</p>
<pre><code>dotnet new console -n TodoListApi</code></pre>
                    <p>On passe par le Sdk.Web et on crée le builder. On crée une classe Model "Todo" :</p>
<pre><code>namespace TodoListApi
{
    public record Todo(int Id, string Title, DateTime StartDate, DateTime? EndTime = null);
}</code></pre>
                    <p>Ensuite, on va créer le "TodoService" :</p>
<pre><code>namespace TodoListApi
{
    public class TodoService
    {
        private List&lt;Todo&gt; list = new();

        public List&lt;Todo&gt; GetAll() =&gt; list;

        public Todo? GetById(int id) =&gt; list.Find(t =&gt; t.Id = id);

        public bool Delete(int id)
        {
            var todo = GetById(id);
            if (todo is not null)
            {
                list.Remove(todo);
                return true;
            }
            return false;
        }

        public Todo Add(string title)
        {
            var id = list.Count &gt; 0 ? list.Max(t =&gt; t.Id) + 1 : 1;
            var todo = new Todo(
                id,
                title,
                DateTime.Now
            );
            list.Add(todo);
            return todo;
        }

        public void Update(int id, Todo item)
        {
            Delete(id);
            list.Add(new Todo(id, item.Title, item.StartDate, item.EndDate));
        }
    }
}</code></pre>
                    <p>Modifions le fichier "Program.cs" :</p>
<pre><code>using Microsoft.AspNetCore.Mvc;
using TodoListApi;

var builder = WebApplication.CreateBuilder();

builder.Services.AddSingleton&lt;TodoService&gt;();

var app = builder.Build();

app.MapGet("todos", ([FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.GetAll());
});

app.MapGet("todos/{id:int}", ([FromRoute] int id, [FromServices] TodoService service) =&gt;
{
    var toto = service.GetById(id);

    if (todo is null) return Results.NotFound();
    return Results.Ok(todo);
});

app.MapGet("todos/active", ([FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.GetAll().Where(t =&gt; t.EndDate is null));
});

app.MapPost("todos", ([FromBody] string todo, [FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.Add(todo));
});

app.MapDelete("todos/{id:int}", ([FromRoute] int id, [FromServices] TodoService service) =&gt;
{
    var result = service.Delete(id);
    if (result)
    {
        return Results.NoContent();
    }
    return Results.NotFound();
});

app.MapUpdate("todos/{id:int}", ([FromRoute] int id, [FromBody] Todo item, [FromServices] TodoService service) =&gt;
{
    service.Update(id, item);
    return Results.NoContent();
});

app.Run();</code></pre>
                </article>
                <article>
                    <h2 id="MVC">Le framework .NET Core MVC :</h2>
                    <h3>Introduction :</h3>
                    <p>.NET Core MVC est l'implémentation par Microsoft du <span class="em">design pattern MVC (modèle-vue-contrôleur)</span> dans un <span class="em">framework de développement</span>. Il est conçu pour <span class="em">faciliter</span> le processus de développement et <span class="em">fournir</span> aux dévelopeurs les outils nécessaires pour créer des applications web <span class="em">modernes et robustes</span> sur <span class="em">n'importe quelle plateforme</span>.</p>
                    <p>Il s'agit également d'une méthode de <span class="em">développement agile</span>, d'une partie centrale de la <span class="em">plateforme ASP.NET</span> et d'un outil qui remplace les formulaires web lents et obsolètes. Avec .NET Core, le framework MVC va encore plus loin en rendant aussi possible le développement <span class="em">API RESTful</span>.</p>
                    <h3>Création d'un projet :</h3>
                    <p>Pour créer un projet sur Visual Studio, il faut sélectionner "<span class="em">Application ASP.NET Core (modèle-vue-contrôleur)</span>". Il faut remplacer le type d'authentification par "<span class="em">Comptes individuels</span>" et sélectionner "<span class="em">Stocker les comptes d'utilisateurs dans l'application</span>".</p>
                    <p>Avant de tester cette nouvelle application, il reste une dernière étape à franchir pour s'assurer que tout fonctionne correctement : le code pour créer et interagir avec votre base de données a été généré, mais la base de données elle-même n'a pas été mise à jour.</p>
                    <p>Pour ce faire, on va utiliser un processus appelé <span class="html">migration code first</span> en tappant dans la <span class="em">console du gestionnaire de package</span> la commande <span class="em">update-database</span> qui, comme son nom l'indique, va mettre à jour la base ded onnées en utilisant l'état de migration actuel qui a été généré lorsque vous avez créé le projet.</p>
                    <p>Les paramètres par défaut d'ASP.NET Core Identity exigent les caractéristiques suivantes pour les mots de passe :</p>
                    <ul>
                        <li>
                            <p>Une longueur minimale de six caractères;</p>
                        </li>
                        <li>
                            <p>Au moins un chiffre;</p>
                        </li>
                        <li>
                            <p>Au moins un caractère majuscule</p>
                        </li>
                        <li>
                            <p>Au moins un caractère minuscule;</p>
                        </li>
                        <li>
                            <p>Au moins un caractère non alphanumérique</p>
                        </li>
                    </ul>
                    <h3>Découverte de l'arborescence d'un projet .NET MVC :</h3>
                    <p>Les dossiers <span class="em">Controllers</span>, <span class="em">Models</span> et <span class="em">Views</span> représentent les composants du design pattern MVC que vous utiliserez pour créer cette application. Le dossier Models contient tous les modèles de vue (classes c#) qui seront utilisés pour représenter les données de votre base de données dans le navigateur. Le dossier Views contient toutes les pages HTML qui afficheront les données représentées par les modèles. Le dossier Controllers contient les classes de contrôleuer qui traitent les données, construisent les modèles et appellent les vues sur le serveur, afin de les retourner en réponse à chaque requête.</p>
                    <p>Notez que les noms de chaque contrôleur sont les mêmes que ceux des sous-dossiers du dossier Views. Chaque sous-dossier Views correspond donc à un contrôleur. C'est ainsi que le mécanisme de routage MVC sait quelle vue doit être rendue et où la trouver. Les requêtes URL suivent le format [domaine] / [contrôleur] / [action] / {id}.Le nom du contrôleur est la première partie de l'URL après le nom de domaine. Il est suivi de l'action du contrôleur qui sera appelée. Le nom de l'action est également le nom de la page HTML du sous-dossier du dossier Views qui correspond au contrpoleur. Le paramètre id est facultatif et est fourni lors de la récupération d'un élément spécifique de la base de données.</p>
                    <p>Le dossier <span class="em">Shared</span> contient toutes les plages pouvant être appelées à partir de n'importe quel contrôleur : les dispositions et les vues partielles. Les dispositions contiennent un code qui est commun à plusieurs pages, comme le menu de navigation et d'autres élements d'en-tête, ainsi que les pieds de page. Les vues partielles se composent quant à elles de petits extraits HTML repris sur plusieurs pages. Il peut s'agir par exemple d'un formulaire de contact.</p>
                    <p>Dans le dossier <span class="em">Data</span>, on a le dossier <span class="em">Mogrations</span> contenant le code généré par Entity Framework pour construire une base de données relationnelle pour votre application et la classe <span class="Em">ApplicationDbContext.cs</span> qui est classe C# héritant de la classe <span class="html">IdentityDbContext</span> et contenant les fonctions de base permettant de gérer les comptes d'utilisateur et votre base de données. En gros, la classe est la représentation codée de cotre base de données et sert à interagir avec la base de données par le biais du <span class="html">mapping objet-relationnel (ORM - Object Relational Mapping)</span> (moyen de faire correspondre les entités de la base de données au code C#).</p>
                    <h3>Création du projet Watchlist :</h3>
                    <p>Nous allons créer un projet nommé Watchlist qui permet de noter des films.</p>
                    <p>Lorsqu'on crée une nouvelle application .NET MVC, comme pour toute autre application, vous <span class="em">commencez par un concept et une liste de besoins</span>. Comme les applications MVC sont également <span class="em">axées sur les données</span>, on va, par conséquence, commenter par travailler sur le modèle de données de l'application.</p>
                    <p>Donc, on doit se poser la question suivante <q>Quelles sont les principales entités de notre schéma conceptuel ?</q> et une fois la réponse trouvée on doit se poser la deuxième question qui est <q>Comment définir les relations entre ces entités ?</q></p>
                    <p>Dans le cas de notre projet Watchlist, on a quatre entités :</p>
                    <ul>
                        <li>
                            <p>Utilisateur : notre système comporte plusieurs utilisateurs.</p>
                        </li>
                        <li>
                            <p>Liste des films vus : chaque utilisateur possède une liste des films qu'il a vus.</p>
                        </li>
                        <li>
                            <p>Film : chaque liste contient plusieurs films.</p>
                        </li>
                        <li>
                            <p>Note : chaque film d'une liste associé à une note.</p>
                        </li>
                    </ul>
                    <p>Voici les relations entre ces entités selon mes suggestions :</p>
                    <ul>
                        <li>
                            <p>Chaque utilisateur dispose d'une seule liste de films.</p>
                        </li>
                        <li>
                            <p>Chaque liste contient plusieurs films.</p>
                        </li>
                        <li>
                            <p>Plusieurs utilisateurs peuvent noter le même film. Ainsi, la note doit être liée à la fois à l'utilisateur et au film.</p>
                        </li>
                    </ul>
                    <p>Voici un diagramme approximatif du modèle jusqu'à présent :</p>
                    <img src="../images/watchlist_modele_1.png" alt="">
                    <p>Dans le modèle MVC, les contrôleurs sont des zones d'action, représentent et gères les <span class="em">requêtes HTTP entrantes</span> et les <span class="em">réponses sortantes</span>. J'ai mentionné le pattern de route (domaine/contrôleur/action) du MVC. La partie contrôleur de la route (ou URL) est le nom du contrôleur, et l'action est le nom de la méthode du contrôleur qui crée la vue que l'utilisateur veut voir. Cela signifie qu'il existe une relation directe, de type one-to-one, entre un modèle et un contrôleur.</p>
                    <p>La vue est appelée par l'instruction return dans l'action du contrôleur :</p>
<pre><code>return View();</code></pre>
                    <p>La méthode View de .NET MVC recherche dans le dossier Views du projet en cours un fichier de vue dont le nom correspond à l'action et au contrôelur. Elle charge le fichier de disposition correspondant, puis lit le fichier de vue et exécute le code Razor qu'elle trouve tout en produisant le HTML brut. Elle construit ainsi un fichier HTML dynamique à partir des résultats et le retourne au navigateur en réponse à la requête originale.</p>
                    <p>Comme mentionné précédemment, les dispositions dans .NET MVC sont tout simplement géniales car elles vous permettent <span class="em">de diviser les pages HTML</span> en blocs réutilisables.</p>
                    <h3>Concevoir un modèle de données :</h3>
                    <p>On va commencer à ajouter les propriétés logiquement associées à chaque entité de données. Pour l'entité Utilisateur, nous n'avons pas besoin de grand-chose pour le moment. Il nous faut juste une adresse e-mail et un mot de passe pour la connexion. Puisque nous utilisons Entity Framework et Identity pour gérer les comptes d'utilisateur, ces propriétés seront déjà présentes dans notre objet Utilisateur, accompagnées d'un propriété Id, qui identifie de manière unique objet et sert également de <span class="em">clé primaire</span> dans la table correspondante de la base de données. Chacun des autres objets doit lui aussi avoir une propriété Id qui servira de clé primaire.</p>
                    <p>D'après la liste des besoins établie pour notre application, chaque utilisateur n'aura qu'une seule liste contenant plusieurs films. Par conséquent, cette liste a-t-elle besoin de ses propres propriétés ? Nous savons qu'elle appartient à un utilisateur et qu'elle contient des films, mais nous n'avons pas précisé si elle aurait besoin de propriétés supplémentaires. Par conséquent, nous pourrions la considérer comme une propriété de l'entité Utilisateur, une liste d'objets Film. Voici un autre design possible :</p>
                    <img src="../images/watchlist_modele_2.png" alt="">
                    <p>Dans ce schéma, nous avons ajouté des propriétés aux entités et supprimé l'entité Liste de films, en la plaçant dans l'entité FilmUtilisateur. Utilisez les propriétés Id des entités Utilisateur et Film comme <span class="em">clés primaires composites</span> pour l'entité FilmUtilisateur. Cela permet d'identifier de manière unique uen entité FilmUtilisateur comme appartenant à un utilisateur et à un film précis. Ce type de relation est également connu sous le nom de relation <span class="em">many-to-many (plusieurs à plusieurs)</span> dans le vocabulaire des bases de données, ce qui signifie que plusieurs utilisateurs peuvent regarder et noter le même film et que plusieurs films peuvent appartenir au même utilisateur.</p>
                    <p>Pour créer une classe d'entité, il faut cliquer sur le dossier Data, sélectionner <span class="em">Ajouter</span> et puis <span class="em">Classe</span>. Pour l'entité primaire Film, on va nommer la classe <span class="em">Film.cs</span> et ensuite on va ajouter les propriétés nécessaires, comme indiqué ci-dessous :</p>
<pre><code>public class Film
{
    public int Id { get; set; }
    public string Titre { get; set; }
    public int Annee { get; set; }
}</code></pre>
                    <p>Passons à l'entité Utilisateur. Celle-ci est un peu plus délicate. Puisque le projet comprend des comptes d'utilisateur individuels, des objets de compte d'utilisateur sont déjà intégrés dans le projet grâce à ASP.NET Identity. Ils sont créés à l'aide d'une classe appelée Identity User, qui se trouve dans le package Microsoft.AspNetCore.Identity. La classe IdentityUser contient toutes les informations importantes permettant de sécuriser les connexions des utilisateurs, telles que le nom d'utilisateur, l'adresse e-mail, le mot de passe, le numéro de téléphone, etc. Cependant, elle ne contient pas de champs pour les informations personnelles telles que le nom ou le prénom, l'adresse, la ville, l'État, etc. Heureusement, il s'agit d'une classe que vous pouvez <span class="em">étendre</span> à une autre classe de votre conception qui peut contenir tous les champs supplémentaires que vous souhaitez ajouter.</p>
                    <p>Il y a un autre point que je tiens à mentionner avant d'ajouter cette classe. ASP.NET Identity possède déjà un appel appelé User et qui est réservé à l'accès au compte de l'utilisateur connecté. Par conséquent, il ne faut pas nommer votre classe d'entité utilisateur User. Appelons-la plutôt Utilisateur. AJoutez donc une autre classe au dossier Data, appelez-la Utilisateur, puis intégrez-y les éléments suivants :</p>
                    <ol>
                        <li>
                            <p>La classe doit étendre Microsoft.AspNetCore.Identity.IdentityUser.</p>
                        </li>
                        <li>
                            <p>Elle doit disposer d'un constructeur qui appelle le constructeur de l'objet hérité. Si vous n'avez jamais utilisé cette syntaxe auparavant, voici à quoi elle doit ressembler :</p>
<pre><code>public Utilisateur() : base()
{    
}</code></pre>
                        </li>
                        <li>
                            <p>Elle doit contenur au moins une propriété Prenom de type chaîne de caractères.</p>
                        </li>
                    </ol>
                    <p>En gros, l'utilisation de <span class="html">base()</span> dans C# est similaire à <span class="html">this()</span> en Java, dans le sens où elle appelle le constructeur de la classe de base.</p>
                    <p>En C#, <span class="em">base()</span> est utilisé dans le contexte d'un constructeur pour appeler le constructeur de la classe de base. Cela peut être utile lorsqe vous avez une hiérarchie de classes et que vous souhaitez exécuter le constructeur de la classe de base avant d'initialiser les membres de la classe dérivée.</p>
                    <p>En Java, <span class="em">this()</span> est utilisé pour appeler un autre constructeur dans la même classe comme en C#, généralement avec des paramètres différents, tandis que <span class="html">super()</span> est utilisé pour appeler le constructeur de la classe parente. Les concepts sont similaires, bien que la syntaxe diffère légèrement.</p>
                    <p>Voici un exemple en C# :</p>
<pre><code>public class BaseClass
{
    public BaseClass()
    {
        // Initialisation de la classe de base
    }
}

public class DerivedClass : BaseClass
{
    private int myValue;

    // Premier constructeur
    public DerivedClass() : this(42) // Appelle le deuxième constructeur avec la valeur par défaut 42
    {
    }

    // Deuxième constructeur avec un paramètre
    public DerivedClass(int value) : base()
    {
        // Initialisation de la classe dérivée après avoir appelé le constructeur de la classe de base
        myValue = value;
        // Autres initialisations nécessaires
    }
}</code></pre>
                    <p>Voici un exemple en Java :</p>
<pre><code>public class BaseClass {
    public BaseClass() {
        // Initialisation de la classe de base
    }
}

public class DerivedClass extends BaseClass
{
    public DerivedClass() {
        super(); // Appel du constructeur de la classe de base
        // Initialisation de la classe dérivée
    }
}</code></pre>
                    <p>L'opérateur <span class="html">??=</span> est disponible à partir de C# 8.0. Il effectue une opération d'affectation uniquement si l'opérande de gauche est null. Il peut être utilisé pour simplifier l'affectation conditionnelle. Par exemple, <span class="em">x ??= y</span> signifie que, si <span class="em">x</span> est null, on lui attribue la valeur de <span class="em">y</span>.</p>
                    <p>La classe FilmUtilisateur possède la clé primaire composite dont nous avons fait mention plus haut. Cette clé est composée de deux propriétés  IdUtilisateur et IdFilm. La propriété IdUtilisateur correspond à la propriété Id de la classe Utilisateur, qu'elle a héritée de IdentityUser. La classe IdFilm correpsond à la propriété Id de la classe Film. On a également besoin de deux autres propriétés utilisant le mot clé <span class="html">virtual</span> qui représentent la relation entre l'objet FilmUtilisateur et les objets Utilisateur et Film :</p>
<pre><code>public class FilmUtilisateur
{
    public string IdUtilisateur { get; set; }
    public int IdFilm { get; set; }
    public bool Vu { get; set; }
    public int Note { get; set; }
    public virtual Utilisateur User { get; set; }
    public virtual Film Film { get; set; }
}</code></pre>
                    <p>Avant de compiler le code, on doit ajouter une propriété virtuelle pour représenter la liste des films de l'utilisateur dans la classe Utilisateur. Il s'agit d'une collection ou d'une liste d'objets FilmUtilisateur, et plus précisément, de tous les objets FilmUtilisateur contenant l'identifiant de l'utilisateur. mettons à jour notre classe Utilisateur pour inclure cette propriété et initialisons-la dans le constructeur, comme indiqué -dessous :</p>
<pre><code>public class Utilisateur : Microsoft.AspNetCore.Identity.IdentityUser
{
    public Utilisateur() : base()
    {
        this.ListeFilms = new HashSet&lt;FilmUtilisateur&gt;();
    }

    public string Prenom { get; set; }
    public virtual ICollection&lt;FilmUtilisateur&gt; ListeFilms { get; set; }
}</code></pre>
                    <p>En .NET Core, les classes <span class="html">IdentityUser</span> et <span class="html">IdentityRole</span> font partie du système d'authentification ASP.NET Core Identity, qui est utilisé pour gérer les fonctionnalités d'authentification, d'autorisation et de gestion des utilisateurs dans une application.</p>
                    <p><span class="html">IdentityUser</span> est la classe de base pour représenter un utilisateur dans le système d'authentification. Elle est définie dans l'espace de noms <span class="em">Microsoft.AspNetCore.Identity</span>. Ses propriétés principales sont :</p>
                    <ul>
                        <li>
                            <p><span class="html">Id</span> : La clé primaire de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">UserName</span>: Le nom d'utilisateur de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">NormalizedUserName</span> : Le nom d'utilisateur normalisé, généralement en majuscules, utilisé pour les opérations de recherche.</p>
                        </li>
                        <li>
                            <p><span class="html">Email</span> : L'adresse e-mail de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">NormalizedEmail</span> : L'adresse e-mail normalisée, généralement en majuscules, utilisée pour les opérations de recherche.</p>
                        </li>
                        <li>
                            <p><span class="html">EmailConfirmed</span> : Indique si l'adresse e-mail de l'utilisateur a été confirmée.</p>
                        </li>
                        <li>
                            <p><span class="html">PasswordHash</span> : Le hachage du mot de passe de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">SecurityStamp</span> : Un jeton de sécurité utilisé pour régénérer les identités externes liées à cet utilisateur en cas de changement de mot de passe ou de tout autre événeemnt de sécurité.</p>
                        </li>
                        <li>
                            <p><span class="html">ConcurrencyStamp</span> : Un jeton de concurrence utilisé pour gérer les conflits de mise à jour concurrente.</p>
                        </li>
                        <li>
                            <p><span class="html">PhoneNumber</span> : Le numéro de téléphone de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">PhoneNumberConfirmed</span> : Indique si le numéro de téléphone de l'utilisateur a été confirmé.</p>
                        </li>
                        <li>
                            <p><span class="html">TwoFactorEnabled</span> : Indique si l'authentification à deux facteurs est activée pour l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">LockoutEnd</span> : La date et l'heure de la fin de la période de verrouillage de l'utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">LockoutEnabled</span> : Indique si le verrouillage de l'utilisateur est activé.</p>
                        </li>
                        <li>
                            <p><span class="html">AccessfailedCount</span> : Nombre de tentatives d'accès infructueuses.</p>
                        </li>
                    </ul>
                    <p><span class="html">IdentityRole</span> est la classe de base pour représenter un rôle dans le système d'authentification. Elle est également définie dans l'espace de noms <span class="em">Microsoft.AspNetCore.Identity</span>. Ses propriétés principales sont :</p>
                    <ul>
                        <li>
                            <p><span class="html">Id</span> : La clé primaire du rôle.</p>
                        </li>
                        <li>
                            <p><span class="html">Name</span> : Le nom du rôle.</p>
                        </li>
                        <li>
                            <p><span class="html">NormalizedName</span> : Le nom du rôle normalisé, généralement en majuscules, utilisé pour les opérations de recherche.</p>
                        </li>
                        <li>
                            <p><span class="html">ConcurrencyStamp</span> : Un jeton de concurrence utilisé pour gérer les conflits de mise à jour concurrente.</p>
                        </li>
                    </ul>
                    <p>En plus des classes de base <span class="em">IdentityUser&lt;TKey&gt;</span> et <span class="em">IdentityRole&lt;TKey&gt;</span>, ASP.NET Core Identity fournit d'autres classes liées à la gestion des utilisateurs et des rôles. Voici quelques-unes de ces classes :</p>
                    <ol>
                        <li>
                            <p><span class="html">IdentityRoleClaim&lt;TKey&gt;</span> : Représente une revendication (claim) associée à un rôle.</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserClaim&lt;TKey&gt;</span> : Représente une revendication (claim) associée à un utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserLogin&gt;TKey&gt;</span> : Représente une connexion externe (comme une connexion avec un compte Google ou Facebook) associée à un utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserToken&lt;TKey&gt;</span> : Représente un jeton associé à un utilisateur (par exemple, un jeton de réinitialisation de mot de passe).</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserRole&lt;TKey&gt;</span> : Représente la relation entre les utilisateurs et les rôles. Elle a généralement une clé étrangère pour l'utilisateur (<span class="em">UserId</span>) et une clé étrangère pour le rôle (<span class="em">RoleId</span>).</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserLogin&lt;TKey&gt;</span> : Représente une connexion externe associée à un utilisateur.</p>
                        </li>
                        <li>
                            <p><span class="html">IdentityUserToken&lt;TKey&gt;</span> : Représente un jeton de sécurité associé à un utilisateur.</p>
                        </li>
                    </ol>
                    <p>Ces classes sont paramétrées par la clé primaire (<span class="html">TKey</span>) utilisée dans votre application. Par défaut, cette clé est de type <span class="html">string</span> pour les identifiants, mais elle peut être personnalisée en fonction de vos besoins.</p>
                    <p>Voici un exemple simplifié de certaines de ces classes et de leurs propriétés :</p>
<pre><code>public class IdentityRoleClaim&lt;TKey&gt;
{
    public TKey Id { get; set; }
    public TKey RoleId { get; set; }
    public string ClaimType { get; set; }
    public string ClaimValue { get; set; }
}

public class IdentityUserClaim&lt;TKey&gt;
{
    public TKey Id { get; set; }
    public TKey UserId { get; set; }
    public string ClaimType { get; set; }
    public string ClaimValue { get; set; }
}

public class IdentityUserLogin&lt;TKey&gt;
{
    public TKey LoginProvider { get; set; }
    public TKey ProviderKey { get; set; }
    public string ProviderDisplayName { get; set; }
    public TKey UserId { get; set; }
}

public class IdentityUserRole&lt;TKey&gt;
{
    public TKey UserId { get; set; }
    public TKey RoleId { get; set; }
}

public class IdentityUserToken&lt;TKey&gt;
{
    public TKey UserId { get; set; }
    public string LoginProvider { get; set; }
    public string Name { get; set; }
    public string Value { get; set; }
}</code></pre>
                    <h3>Modification du contexte DbContext :</h3>
                    <p>On doit ajouter les objets DbSet pour vos classes Film et FilmUtilisateur dans la classe ApplicationDbContext :</p>
<pre><code>public DbSet&lt;Film&gt; Films { get; set; }
public DbSet&lt;FilmUtilisateur&gt; FilmsUtilisateur { get; set; }</code></pre>
                    <p>Remarquez que nous n'avons pas ajouté d'objet DbSet pour la classe Utilisateur. Cela est dû au fait qu'il existe déjà une table AspNetUsers dans la base de données. Puisque nous avons créé la classe Utilisateur qui hérite de la classe IdentityUser, tout ce que vous ajoutez à Utilisateur sera automatiquement traduit dans la table AspNetUsers de la base de données.</p>
                    <p>Voici quelques-unes des proproétés DbSet les plus couramment utilisées dans <span class="html">IdentityDbContext&lt;TUser&gt:</span> :</p>
                    <ul>
                        <li>
                            <p class="em">Users :</p>
<pre><code>public DbSet&lt;TUser&gt; Users { get; set; }</code></pre>
                            <p>Cette propriété représente la table des utilisateurs dans la base de données.</p>
                        </li>
                        <li>
                            <p class="em">Roles :</p>
<pre><code>public DbSet&lt;TRole&gt; Roles { get; set; }</code></pre>
                            <p>Cette propriété représente la table des rôles dans la base de données.</p>
                        </li>
                        <li>
                            <p class="em">UserClaims :</p>
<pre><code>public DbSet&lt;TUserClaim&gt; UserClaims { get; set; }</code></pre>
                            <p>Cette propriété représente la table des revendications (claims) des utilisateurs.</p>
                        </li>
                        <li>
                            <p class="em">UserLogins :</p>
<pre><code>public DbSet&lt;TUserLogin&gt; UserLogins { get; set; }</code></pre>
                            <p>Cette propriété représente la table des informations de connexion des utilisateurs, comme les fournisseurs extenes.</p>
                        </li>
                        <li>
                            <p class="em">UserTokens :</p>
<pre><code>public DbSet&lt;TUserToken&gt; UserTokens { get; set; }</code></pre>
                            <p>Cette propriété représente la table des jetons associés aux utilisateurs, généralement utilisés pour les opérations liées à la récupération de mot de passe.</p>
                        </li>
                        <li>
                            <p class="em">UserRoles :</p>
<pre><code>public DbSet&lt;TUserRole&gt; UserRoles { get; set; }</code></pre>
                            <p>Cette propriété représente la table de liaison entre les utilisateurs et les rôles; indiquant quels utilisateurs appartiennent à quels rôles.</p>
                        </li>
                    </ul>
                    <p>La dernière modification est un peu plus délicate. Dans la version actuelle d'ASP.NET Core, il n'est pas possible de migrer automatiquement des objets ayant des relations many-to-many. Heureusement, ASP.NET inclut l'<span class="em">API Fluent</span>. Cette API vous permet de donner à Entity Framework des instructions précises pour créer ou modifier la base de données. Pour ce faire, vous devez remplacer une méthode de votre classe ApplicationDbContext, appelée OnModelCreating, qui est héritée de IdentityDbContext. Vous pouvez le faire n'importe où en dessous du constructeur, dans la classe application DbContext :</p>
<pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    modelBuilder.Entity&lt;FilmUtilisateur&gt;().HasKey(t => new { t.IdUtilisateur, t.IdFilm});
}</code></pre>
                    <h3>Mettre à jour ASP.NET Identity :</h3>
                    <p>Par défaut, ASP.NET Identity utilise l'objet IdentityUser pour tous les comptes d'utilisateur. Nous avons créé la classe Utilisateur pour étendre la classe IdentityUser et pouvoir donner des informations supplémentaires sur les comptes d'tilisateur. Cependant, puisque nous voulons que la classe Utilisateur soit la base des objets Identity, nous devons encore un peu modifier le code. Les deux fichiers à modifier sont <span class="em">Program.cs</span> et <span class="em">_LoginPartial.cshtml</span>.</p>
                    <p>Dans le fichier <span class="em">Program.cs</span>, il faut chercher la méthode <span class="em">ConfigureServices</span> :</p>
<pre><code>builder.Services.AddIdentity&lt;IdentityUser, IdentityRole&gt;(options =&gt;
{
    options.SignIn.RequireConfirmedAccount = true;
}).AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();</code></pre>
                    <p>Remplacez ce segment de code par celui-ci :</p>
<pre><code>builder.Services.AddIdentity&lt;Utilisateur, IdentityRole&gt;(options =&gt;
{
    options.SignIn.RequireConfirmedAccount = true;
}).AddEntityFrameworkStores&lt;ApplicationDbContext&gt;().AddDefaultTokenProviders();</code></pre>
                    <p>Remarquez le changement de IdentityUser à Utilisateur dans la configuration du service Identity. Cette modication permettra à .NET Identity d'utiliser votre classe Utilisateur pour tous les processus et services Identity; comme la configuration de UserMangaer et SignINManager.</p>
                    <p>ASP.NET Core Identity offre de nombreuses options de configuration pour personnaliser son comportement. Voici quelques-unes des options disponibles dans <span class="html">IdentityOptions</span> que vous pouvez configurer dans votre fichier <span class="em">Program.cs</span> :</p>
<pre><code>// Cofiguration des options Identity dans ConfigureServices
builder.Services.Configure&lt;IdentityOptions&gt;(options =&gt;
{
    // Options relatives aux mots de passe
    options.Password.RequireDigit = true;
    options.Password.RequireLowercase = true;
    options.Password.RequireUppercase = true;
    options.Password.RequireNonAlphanumeric = true;
    options.Password.RequiredLength = 8;

    // Options de verrouillage de compte
    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
    options.Lockout.MaxFailedAccessAttempts = 5;
    options.Lockout.AllowedForNewUsers = true;

    // Options de connexion
    options.SignIn.RequireConfirmedEmail = false;
    options.SignIn.RequireConfirmedPhoneNumber = false;
    options.SignIn.RequireConfirmedAccount = false;

    // Options de l'utilisateur
    options.User.RequireUniqueEmail = true;

    // Autres options ...
});

// Configuration d'ASP.NET Core Identity
builder.Services.AddIdentity&lt;Utilisateur, IdentityRole&gt;().AddEntityFrameworkStores&lt;ApplicationDbContext&gt;().AddDefaultTokenProviders();</code></pre>
                    <p>L'utilisation de <span class="em">builder.Services.Configure&lt;IdentityOptions&gt;</span> configure les options d'Identity, et ensuite, <span class="em">builder.Services.AddIdentity</span> utilise ces options configurées.</p>
                    <p>Voici quelques explications sur certaines de ces options :</p>
                    <ul>
                        <li>
                            <p class="em">Options relatives aux mots de passe :</p>
                            <ul>
                                <li>
                                    <p><span class="html">RequireDigit</span> : Spécifie si le mot de passe doit contenir au moins un chiffre.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequireLowercase</span> : Spécifie si le mot de passe doit contenir au moins une lettre minuscule.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequireUppercase</span> : Spécifie si le mot de passe doit contenir au moins une lettre majuscule.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequireNonAlphanumeric</span> : Spécifie si le mot de passe doit contenir au moins un caractère spécial.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequiredLength</span> : Spécifie la longueur minimale du mot de passe.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Options de verrouillage de compte :</p>
                            <ul>
                                <li>
                                    <p class="html">DefaultLockoutTimeSpan</p>
                                     La durée pendant laquelle un utilisateur est verrouillé après avoir dépassé le nombre maximum de tentatives de connexion infructueuses.
                                </li>
                                <li>
                                    <p><span class="html">MaxFailedAccessAtempts</span> : Le nombre maximale de tentatives de connexion infructeuses avant que le compte ne soit verrouillé.</p>
                                </li>
                                <li>
                                    <p><span class="html">AllowedForNewUsers</span> : Indique si le verrouillage est activé pour les nouveaux utilisateurs.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Options de connexion :</p>
                            <ul>
                                <li>
                                    <p><span class="html">RequireConfirmedEmail</span> : Spécifie si un compte doit être confirmé par e-mail pour être connecté.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequireConfirmedPhoneNumber</span> : Spécifie si un compte doit être confirmé par numéro de téléphone pour être connecté.</p>
                                </li>
                                <li>
                                    <p><span class="html">RequireConfirmedAccount</span> : Spécifie si un compte doit être confirmé pour être connecté.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p class="em">Options de l'utilisateur :</p>
                            <ul>
                                <li>
                                    <p><span class="html">RequireUniqueEmail</span> : Spécifie si les adresses e-mail doivent être uniques entre les utilisateurs.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Le cookie d'application dans ASP.NET Core Identity offre plusieurs options que vous pouvez configurer selon vos besoins. Voici quelques-unes des options couramment utilisées :</p>
                    <ul>
                        <li>
                            <p><span class="html">ExpireTimeSpan</span> : La durée de vie du cookie d'authentification. Par exemple, <span class="em">options.ExpireTimeSpan = TimeSpan.FromDays(1);</span> définirait le cookie pour expirer après un jour.</p>
                        </li>
                        <li>
                            <p><span class="html">LoginPath</span> : Le chemin où les utilisateurs seront redirigés s'ils tentent d'accéder à une ressource nécessitant une authentification sans être connectés. Par exemple, <span class="em">options.LoginPath = "/Account/Login";</span> définirait le chemin de connexion à "Account/Login".</p>
                        </li>
                        <li>
                            <p><span class="html">LogoutPath</span> : Le chemin où les utilisateurs seront redirigés après avoir été déconnectés. Par exemple, <span class="em">options.LogoutPath = "/Account/Logout";</span> définirait le chemin de déconnexion à "Account/Logout".</p>
                        </li>
                        <li>
                            <p><span class="html">ReturnUrlParameter</span> : Le nom du paramètre sans l'URL qui stocke l'URL à laquelle l'utilisateur doit être redirigé après une connexion réussie. Par exemple, <span class="em">options.ReturnUrlParameter = "returnUrl";</span> utiliserait "returnUrl" comme paramètre.</p>
                        </li>
                        <li>
                            <p><span class="html">CookieName</span> : Le nom du cookie d'authentification. Par défaut, c'est ".AspNetCore.ApplicationCookie", mais vous pouvez le personnaliser avec <span class="em">options.CookieName = "MonCookie";</span>.</p>
                        </li>
                        <li>
                            <p><span class="html">SlidingExpiration</span> : Si <span class="em">true</span>, la durée de vie du cookie est prolongée lors de chaque demande réussie. Si <span class="em">false</span>, le cookie expirera après la période définie par <span class="em">ExpireTimeSpan</span>, même si l'utilisateur est actif.</p>
                        </li>
                    </ul>
                    <p>Voici un exemple de configuration avec quelques-unes de ces options :</p>
<pre><code>builder.Services.ConfigureApplicationCookie(options =>
{
    options.ExpireTimeSpan = TimeSpan.FromDays(1);
    options.LoginPath = "/login";
    options.LogoutPath = "/logout";
    options.ReturnUrlParameter = "returnUrl";
    options.CookieName = "MonCookie";
    options.SlidingExpiration = true;
});</code></pre>
                    <p>La deuxième modification doit intervenir dans <span class="em">Views &gt; Shared &gt; _LoginPartial.cshtml</span>. Les trois premières lignes de code de ce fichier sont les suivantes :</p>
<pre><code>@using Microsoft.AspNetCore.Identity
@inject SignInManager&lt;IdentityUser&gt; SignInManager
@inject UserManager&lt;IdentityUser&gt; UserManager</code></pre>
                    <p>Vous devez ajouter une autre instruction using pour l'espace de noms Data de l'application, puis remplacer les références à IdentityUser par Utilisateur, comme indiqué ci-dessous :</p>
<pre><code>@using Microsoft.AspNetCore.Identity
@using Watchlist.Data
@inject SignInManager&lt;Utilisateur&gt; SignInManager
@inject UserManager&lt;Utilisateur&gt; UserManager</code></pre>
                    <h3>Effectuer la migration :</h3>
                    <p>Maintenant que le contexte de la base de données et le service Identity ont été mis à jour pour utiliser votre classe Utilisateur, le modèle est achevé et peut être migré. Ajoutez une nouvelle mogration et nommez-la comme vous le souhaitez, mais n'oubliez pas qu'il est recommandé de lui attribuer un nom représentatif de l'action réalisée ou de son ordre dans la séquence. Vous pouvez l'appeler SecondeMigration ou MogrationFilmUtilisateur par exemple :</p>
                    <figure>
                        <img src="../images/migration_1.png" alt="">
                        <figcaption>Ajout d'une nouvelle migration dans le Gestionnaire de package</figcaption>
                    </figure>
                    <figure>
                        <img src="../images/migration_2.png" alt="">
                        <figcaption>Mise à jour de la base de données dans le Gestionnaire de package</figcaption>
                    </figure>
                    <p>Votre base de données est maintenant à jour et correspond au modèle de données que vous venez de créer, mais vous ne pouvez pas encore faire grand-chose avec. La prochaine étape sera donc de générer automatiquement des contrôleurs et des vues à partir du modèle.</p>
                    <h3>Qu'est-ce que la génération automatique ?</h3>
                    <p>La génération automatique d'ASP.NET a été introduite dans Visual Studio 2013 et reste un élément important de la plateforme de développement .NET Core.</p>
                    <p>Il s'agit d'un framework de génération de code automatique qui vous permet d'ajouter rapidement du code modélisé qui interagit avec vos modèles de données. Son utilisation pour générer les contrôleurs et vues MVC de vos modèles permet d'accélérer le développement de toutes les opérations de données standard de votre projet, ainsi que des pages HTML/Razor servant à visualiser ces données.</p>
                    <h3>Utiliser la génération automatique avec Entity Framework :</h3>
                    <p>Avant de générer automatiquement vos contrôleurs et vos vues, vous devez créer une classe supplémentaire. Elle ne représente pas une entité spécifique de la base de données, mais plutôt un mélange d'éléments provenant de différentes entités. C'est ce qu'on appelle un <span class="em">modèle d'affichage</span>, et vous en avez besoin pour configurer correctement l'affichage de votre liste de films. La liste de films est une collection d'identifiants d'utilisateurs et de films dans la table FilmUtilisateur, et vous devez la rendre lisible et facile à utiliser. C'est là que le modèle d'affichage entre en jeu.</p>
                    <h4>Ajouter les modèles d'affichage :</h4>
                    <p>Ajoutez une nouvelle classe appelée <span class="em">ModeleVueFilm</span> dans le dossier Models. Modifiez ensuite la classe pour ajouter l'identifiant du film, son titre, son année, sa présence ou absence dans la liste de l'utilisateur, son statut de visionnage par l'utilisateur et sa note (le cas échéant).</p>
<pre><code>public class ModeleVueFilm
{
    public int IdFilm { get; set; }
    public string Titre { get; set; }
    public int Annee { get; set; }
    public bool PresentDansListe { get; set; }
    public bool Vu { get; set; }
    public int? Note { get; set; }
}</code></pre>
                    <h4>Générer automatiquement une entité de modèle :</h4>
                    <p>Pour générer automatiquement des contrôleurs et des vues pour une entité de données, cliquez avec le bouton doit sur le dossier Controllers, puis choisissez <span class="em">Ajouter &gt; Nouvel élément généré automatiquement</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_entite_modele.png" alt="">
                        <figcaption>Dans l'Explorateur de solutions, clic droit sur Controllers, puis Ajouter &gt; Nouvel élément généré automatiquement.</figcaption>
                    </figure>
                    <p>Vous pouvez choisir parmi de nombreuses options, mais ce qui nous intéresse c'est la génération automatique d'un <span class="em">contrôleur MVC avec vues, utilisant Entity Framework</span>. Sélectionnez cette option, puis cliquez sur le bouton <span class="em">Ajouter</span>.</p>
                    <figure>
                        <img src="../images//generer_automatiquement_entite_modele_1.png" alt="">
                        <figcaption>La fenêtre Ajouter un nouvel élément généré automatiquement présente de nombreuses options.</figcaption>
                    </figure>
                    <p>Vous entrez à présent dans les détails du processus de génération automatique. Sélectionnez la classe du modèle à partir de laquelle vous allez générer automatiquement le contrôleur et les vues (il s'agit de la classe Film) et définissez le nom du contrôleur (FilmsController). Assurez-vous que les trois cases sont cochées : nous voulons générer des vues, référencer les bibliothèques de scripts telles que jQuery et Bootstrap, et utiliser une page de disposition (dans ce cas, la page de disposition par défaut convient).</p>
                    <figure>
                        <img src="../images/generer_automatiquement_entite_modele_2.png" alt="">
                        <figcaption>Vérifiez que les trois vues sont cochées.</figcaption>
                    </figure>
                    <p>Une fois le processus terminé, vous verrez apparaître un nouveau fichier FilmsController.cs dans le dossier Controller et un nouveau dossier Films dans le dossier Views de votre projet.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_entite_modele_3.png" alt="">
                        <figcaption>Le nouveau fichier FilmsController.cs et le nouveau dossier Films</figcaption>
                    </figure>
                    <h3>Générez automatiquement des composants individuels :</h3>
                    <p>Vous avez déjà généré automatiquement un contrôleur complet avec des vues utilisant Entity Framework pour la classe Film. Je vais maintenant vous montrer comment générer automatiquement des éléments à plus petite échelle, par exemple pour ajouter un ou deux éléments, et non un ensemble complet d'opérations CRUD.</p>
                    <h4>Ajouter un contrôleur Liste de films :</h4>
                    <p>Ajoutons un nouveau contrôleur que vous pouvez utiliser pour créer et afficher votre liste de films. Il s'agira d'un code personnalisé et non pas d'un code généré à partir d'un modèle, vous devez donc commencer par créer un <span class="em">contrôleur vide</span>. Pour ce faire, faites un clic droit sur le dossier Controllers, puis choisissez <span class="em">Ajouter &gt; Contrôleur</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels.png" alt="">
                        <figcaption>Faites un clic droit sur le dossier Controllers et choisissez Ajouter &gt; Contrôleur.</figcaption>
                    </figure>
                    <p>La fenêtre suivante est similaire à celle qui présente les options de génération automatique que nous avons vue dans la section précédente, mais comporte moins d'éléments. C'est le premier qui nous intéresse : <span class="em">Contrôleur MVC - Vide</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels_1.png" alt="">
                        <figcaption>Dans la fenêtre Ajouter un nouvel élément généré automatiquement, choisissez Contrôleur MVC - Vide.</figcaption>
                    </figure>
                    <p>Il est mainteant temps de nommer le nouveau contrôleur. Appelons-le <span class="em">ListeFilmsController</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels_2.png" alt="">
                        <figcaption>Nommez le contrôleur.</figcaption>
                    </figure>
                    <h4>AJoutez une vue par défaut :</h4>
                    <p>Après avoir ajouté une classe ListeFilmsController vide, vous devez ajouter une vue unique pour afficher la liste de films.</p>
                    <p>Ajoutez un nouveau sous-dossier dans le dossier Views appelé <span class="em">ListeFilms</span>. Faites un clic droit sur le nouveau dossier ListeFilms et choisissez <span class="em">Ajouter &gt; Vue</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels_3.png" alt="">
                        <figcaption>Ajoutez le sous-dossier ListeFilms. Faites un clic droit et choisissez Ajouter &gt; Vue.</figcaption>
                    </figure>
                    <p>C'est ici que vous pouvez définir les types de vues que vous souhaitez ajouter au projet. Vous savez que la liste de films est une liste qui contient des titres de films et des informations supplémentaires, comme des notes, mais c'est toujours et avant tout une liste d'éléments. par conséquent, vous devez créer une vue en liste.</p>
                    <p>Nommez cette nouvelle page <span class="em">Index</span> afin qu'ele s'affiche par défaut chaque fois que le contrôleur ListFilmsController est appelé. Pour le type de modèle, sélectionnez <span class="em">Liste</span>. Pour la classe de modèle, sélectionnez la classe <span class="em">ModeleVueFilm</span> que vous avez créée précédemment. Ensuite, supprimez tout ce qui est présent dans la liste déroulante Classe du contexte de données. On ne veut pas qu'elle soit liée directement à la base de données, car les données se trouveront dans un modèle de vue et non dans un modèle de données (base de données). Enfin, assurez-vous que la case à cocher <span class="em">Créer en tant que vue partielle</span> n'est pas cochée. En revanche, cochez les cases <span class="em">Bibliothèques de scripts de référence</span> et <span class="em">Utiliser une page de disposition</span>, puis cliquez sur <span class="em">Ajouter</span>.</p>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels_4.png" alt="">
                        <figcaption>L'option Ajouter un nouvel élément généré automatiquement.</figcaption>
                    </figure>
                    <figure>
                        <img src="../images/generer_automatiquement_composants_individuels_5.png" alt="">
                        <figcaption>L'option Créer en tant que vue partielle n'est pas cochée, mais les options Bibliothèques de scripts de référence et Utiliser une page de disposition le sont.</figcaption>
                    </figure>
                    <p>Vous avez maintenant un nouveau contrôleur et une nouvelle vue pour gérer la création et l'affichage de la liste des films d'un utilisateur. Mais aucun des deux n'est fonctionnel pour le moment. Vous devez créer la liste de films, ce qui signifie ajouter du code personnalisé au contrôleur ListeFilmsController.</p>
                    <h3>Modifier le contrôleur ListeFilmsController :</h3>
                    <p>Le contrôleur ListeFilmsController est vide. La seule chose qu'il contient est une méthode appelée Index, qui ouvrira la vue Index.cshtml que vous venez d'ajouter. Pour remplir cette vue avec les données de la liste de films, vous devez ajouter quelques éléments à ce contrôleur.</p>
                    <h4>Récupérer le contexte de la base de données :</h4>
                    <p>Tout d'abord, vous devez accéder à la base de données via l'objet de contexte de base de données, ApplicationDbContext. ASP.NET Core utilise l'injection de dépendances pour fournir des instances des objets importants à utiliser dans les contrôleurs. Ainsi, pour avoir accès au contexte de la base de données, vous devez le demander à .NET Core en l'ajoutant comme paramètre dans le constructeur du contrôleur ListeFilmsController.</p>
                    <p>Vous devrez ajouter quelques déclarations using au début de votre classe ListeFilmsController :</p>
<pre><code>using Microsoft.AspNetCore.Identity;
using Watchlist.Data;
using Watchlist.Models;</code></pre>
                    <p>Elles permettent d'accéder aux données et aux objets du modèle, ainsi qu'à .NET Core Identity, dont vous aurez besoin pour récupérer les films de l'utilisateur connecté.</p>
                    <p>Ensuite, pour injecter le contexte de la base de données dans votre contrôleur ListeFilmsController, ajoutez le code suivant au-dessus de la classe ListeFilmsController :</p>
<pre><code>private readonly ApplicationDbContext _contexte;

public ListeFilmsController(ApplicationDbContext contexte)
{
    _contexte = contexte;
}</code></pre>
                    <p>Dans l'exemple ci-dessus, une variable privée en <span class="html">readonly</span> contient une instance du contexte de la base de données pour ce contrôleur. Affectez-le à l'objet de contexte qui est injecté dans le constructeur.</p>
                    <p>Cela vous permettra de fécupérer les films de la liste de l'utilisateur. Vous devez être capable d'identifier l'utilisateur, puisque les films sont associés à son identifiant unique. Par conséquent, vous devez récupérer l'identifiant de l'utilisateur connecté pour obtenir ses films et générer la liste.</p>
                    <h4>Récupérer l'utilisateur connecté :</h4>
                    <p>Pour obtenir l'utilisateur connecté, appelez le service UserManager de .NET Identity, qui fournit toutes les méthodes dont vous avez besoin pour obtenir les informations sur l'utilisateur. Pour avoir accès au service User, injectez-le dans le constructeur, comme vous l'avez fait pour le contexte de la base de données.</p>
<pre><code>public class ListeFilmsController : Controller
{
    private readonly ApplicationDbContext _contexte;
    private readonly UserManager&lt;Utilisateur&gt; _gestionnaire;

    public ListeFilmsController(ApplicationDbContext contexte, UserManager&lt;Utilisateur&gt; gestionnaire)
    {
        _contexte = contexte;
        _gestionnaire = gestionnaire;
    }
}</code></pre>
                    <p>Le service UserManager étant maintenant disponible, vous pouvez écrire du code pour récupérer les informations de l'utilisateur. Une bonne pratique consiste à ajouter une méthode privée dans le contrôleur qui appelle le service, puis une requête HTTP GET publique pour récupérer l'identifiant de l'utilisateur.</p>
<pre><code>public class ListeFilmsController : Controller
{
    private readonly ApplicationDbContext _contexte;
    private readonly UserManager&lt;Utilisateur&gt; _gestionnaire;

    public ListeFilmsController(ApplicationDbContext contexte, UserManager&lt;Utilisateur&gt; gestionnaire)
    {
        _contexte = contexte;
        _gestionnaire = gestionnaire;
    }

    private Task&lt;Utilisateur&gt; GetCurrentUserAsync() =&gt; _gestionnaire.GetUserAsync(HttpContext.User);

    [HttpGet]
    public async Task&lt;string&gt; RecupererIdUtilisateurCourant()
    {
        Utilisateur utilisateur = await GetCurrentUserAsync();
        return utilisateur?.Id;
    }
}</code></pre>
                    <p>Enfin, vous pouvez appeler votre méthode RecupererIdUtilisateurCourant à partir de la méthode Index où vous allez construire le modèle de vue pour la liste de films. Remarquez que la méthode Index a changé, passant d'une méthode synchrone à une tâche asynchrone. Cette évolution est nécessaire pour appeler les méthodes du service UserManager.</p>
<pre><code>public async Task&lt;IActionResult&gt; Index()
{
    var id = await RecupererIdUtilisateurCourant();
    return View();
}</code></pre>
                    <h3>Créer la liste de films de l'utilisateur :</h3>
                    <p>Cela nous a demandé un peu de boulot, mais c'était nécessaire pour créer la liste de films spécifique à l'utilisateur connecté. Dans la méthode <span class="em">Index</span>, insérez le code suivant :</p>
<pre><code>public async Task&lt;IActionResult&gt; Index()
{
    var id = await RecupererIdUtilisateurCourant();
    var filmsUtilisateur = _contexte.FilmsUtilisateur.Where(x =&gt; x.IdUtilisateur == id);
    var modele = filmsUtilisateur.Select(x =&gt; new ModelVueFIlm {
        IdFilm = x.IdFilm,
        Titre = x.Film.Titre,
        Annee = x.Film.Annee,
        Vu = x.Vu,
        PresentDansListe = true,
        Note = x.Note
    }).ToList();

    return View(modele);
}</code></pre>      
                    <p>Après avoir récupéré l'identifiant de l'utilisateur connecté, une requête LINQ récupère tous les enregistrements <span class="em">FilmsController</span> de la base de données qui le contiennent. Ensuite, à partir des résultats de cette requête, on sélectionne des éléménts spécifiques tels que le titre du film, son année, son statut de visionnage par l'utilisateur et sa note. Ensuite, on transmet cette liste d'objets <span class="em">ModeleVueFilm</span> à la vue via la variable <span class="em">modele</span>. Les données sont alors rendues dans un fichier HTML dynamique.</p>
                    <h3>Une dernière modification, juste pour le plaisir :</h3>
                    <p>Réfléchissons maintenant à l'ergonomie. Ne serait-il pas intéressant que l'utilisateur soit dirigé automatiquement vers sa liste de films lors de sa connexion ? Il n'y a aucun intérêt à le faire arriver sur la page d'accueil. En effet, il est fort probable qu'il utilise l'application pour interagir avec sa liste de films. Voyons comment ajouter cette fonctionnalité, puis exécutons à nouveau l'application.</p>
                    <p>Ouvrez maintenant le contrôleur <span class="em">HomeController</span> et examinez la méthode <span class="em">Index</span>. Vous pouvez y ajouter une simple vérification pour redirger l'utilisateur s'il est connecté lorsque la page d'accueil est demandée. Regardez attentivement le code ajouté ci-dessous :</p>
<pre><code>public IActionResult Index()
{
    if (User.Identity.IsAuthenticated)
    {
        return RedirectToAction("Index", "ListeFilms");
    }
    return View();
}</code></pre>
                    <p>Ce code supplémentaire exploite l'objet statique User fourni par le contrôleur. Il examine la propriété booléenne IsAuthenticated de la propriété Identity de l'objet User. Si l'utilisateur est connecté, il est considéré comme <span class="em">authentifié</span>, et cette propriété sera vraie (true). Par conséquent, si cette propriété est vraie, vous pouvez rediriger l'utilisateur vers la méthode Index du contrôleur ListeFilms.</p>
                    <p>Vous pouvez trouver tout le code de navigation dans le menu dans le fichier de disposition de votre application : <span class="em">Views &gt; Shared &gt; _Layout.cshtml</span>.</p>
                    <h3>Pourquoi modifier les vues ?</h3>
                    <p>Les vues créées par défaut lorsque vous procédez à la génération automatique des entités du modèle sont généralement fonctionnelles sans modification. Cependant, dans certains cas, vous devrez leur apporter de petits ajustements.</p>
                    <h3>Assurez-vous d'utiliser le bon type de champ de formulaire :</h3>
                    <p>Les champs de formulaire peuvent parfois poser problème. Il est particulièrement agaçant de constater que vous ne parvenez pas à saisir vos données correctement parce que le type de champ de formulaire utilisé n'est pas le bon. Voici quelques points sensibles à surveiller :</p>
                    <ul>
                        <li>
                            <p>Assurez-vous que les bonens données s'affichent dans les listes. Si une liste permet plusieurs sélections, optez pour une liste à sélection multiple plutôt que pour une liste à sélection simple, même si c'est ce dernier type de contrôle qui est habituellement généré.</p>
                        </li>
                        <li>
                            <p>C# utilise des objets DateTime à la fois pour les dates et les heures. Si vous avez besoin d'un champ de type heure dans votre formulaire, n'affichez pas un champ de type deate, et inversement. Pour des raisons de cohérence, utilisez un sélecteur de date dans votre formulaire et spécifiez également des champs de type heure.</p>
                        </li>
                        <li>
                            <p>Si des champs nécessitent uniquement la saisie d'un nombre entier, assurez-vous d'utiliser le bon type d'entrée. Les entrées des espaces de texte sont particulièrement délicates. Un champ de texte simple est généré pour chaque entrée composée de chaînes de caractères. Entity Framework ne sait pas si vous devez prévoir un emplacement pour un paragraphe ou deux, et certainement pas si vous pourriez avoir besoin d'une entrée au format HTML. Si vous utilisez de telles entrées dans vos formulaires, vous devrez les spécifier et mettre en forme directement. Le moyen le pls simple est d'utiliser la méthode d'assisatnce @Html.TextAreaFor(). L'utilisation de cette méthode créera l'élément HTML de champ de texte approprié dans votre formulaire. Par exemple :</p>
<pre><code>@Html.TextAreaFor(model =&gt; model.Commentaires, 8, 0, new { @class = "form-control", required = "required" })</code></pre>
                            <p>Cette instruction crée un nouvel espace de texte pour un élément de modèle appelé <span class="em">Commentaires</span>. Le deuxième paramètre indique le nombre de lignes (8), et le troisième paramètre est le npmbre de colonnes. Une valeur de zéro signifie que l'espace remplira la largeur de l'espace disponible, tout comme les colonnes. Le dernier paramètre est un objet anonyme qui représente les attributs HTML appliqués au champ. Dans ce cas, la classe CSS form-control est appliquée, de même que l'attribut <span class="em">required</span>.</p>
                        </li>
                    </ul>
                    <p>Ce ne sont là que quelques exemples de problèmes auxquels il faut faire attention. Comme toujours, surveillez attentivement tous les détails de vos formulaires pour vous assurer qu'ils sont intuitifs et faciles à appréhender pour vos utilisateurs.</p>
                    <h3>Optimiser la cohérence des formulaires :</h3>
                    <p>Les formulaires Create (Créer) et Edit (Modifier) sont presque identiques lorsqu'ils sont générés. Toute modification apportée à l'un doit être répercutée sur l'autre. Vous devez en effet éviter d'avoir un sélecteur de date dans un formulaire et un espace de texte pour le même champ dans l'autre.</p>
                    <p>Faites également attention à la navigation. Par défaut, chaque formulaire intègre une action d'envoi et une action d'annulation. L'action d'envoi est un bouton intitulé <span class="em">Create</span> (Créer) dans le formulaire du même nom et <span class="em">Save</span> (Enregistrer) dans le formulaire Edit (Modifier). L'action d'annulation est un hyyperlien <span class="em">Back to List</span> (Retour à la liste) dans tous les formulaires. Les développeurs remplacent souvent ce lien par un bouton intitulé Annuler ou autre nom similaire en fonction du design choisi. Si vous faites ce choix, veillez à l'appliquer à tous les formulaires de vos différentes vues.</p>
                    <h3>Gérer les erreurs humaines avec la validation :</h3>
                    <p>La validation fait déjà partie du processus de génération automatique MVC pour la plupart des types de données. Chaque formulaire qui requiert une saisie sera généré avec la ligne suivante après la balise &lt;form&gt; :</p>
<pre><code>&lt;div asp-validation-summary="ModelOnly" class="text-danger"&gt;&lt;/div&gt;</code></pre>
                    <p>Cette balise indique où s'affichera un résumé des erreurs de validation. Les valeurs qui peuvent être utilisées sont <span class="html">All</span>, <span class="html">ModelOnly</span> et <span class="html">None</span>. validationSummary.All affichera les messages de validation au niveau de la propriété et du modèle. validationSummary.ModelOnly affichera uniquement les messages de validation qui s'appliquent au niveau du modèle. validationSummary.Bibe indique à cette balise de ne rien faire.</p>
                    <p>Toutes les erreurs de saisie de données seront indiquées par un texte rouge sous le champ de saisie. Le code HTML qui génère de telles erreurs ressemble à ceci :</p>
<pre><code>&lt;span asp-validation-for="Title" class="text-danger"&gt;&lt;/span&gt;</code></pre>
                    <p>Cette ligen définit un message de validation pour un élément de modèle appelé Title. Si la saisie est obligatoire et que rien n'est indiqué dans ce champ, un message de validation indiquant que le champ est obligatoire s'affiche sous le champ de saisie.</p>
                    <h3>Ajouter des films à la liste des films :</h3>
                    <p>Avez-vous remarqué qu'il n'existe aucun moyen d'ajouter des films à votre liste de films ? Vous pouvez les ajouter à la base de données, ainsi que les modifier et les supprimer, mais vous n'avez actuellement aucun moyen de les placer dans votre liste de films. C'est un gros problème pour notre application !</p>
                    <p>Plusieurs options s'offrent à vous, je vais vous en présenter quelques-unes :</p>
                    <ol>
                        <li>
                            <p>Ajouter/supprimer des films directement à partir de la page de liste des films (Index) via des boutons individuels Ajouter/Supprimer pour chaque film.</p>
                        </li>
                        <li>
                            <p>Ajouter/supprimer des films directement à partir de la page de liste de films (Index) via des cases à cocher à côté de chaque film.</p>
                        </li>
                        <li>
                            <p>Ajouter un film via la page Create (Créer).</p>
                        </li>
                        <li>
                            <p>Ajouter/supprimer un film via la page Edit (Modifier).</p>
                        </li>
                        <li>
                            <p>Ajouter/supprimer un film via la page Details (Détails).</p>
                        </li>
                    </ol>
                    <p>Chacune de ces options présente des avantages et des inconvénients. Les options 1 et 2 sont les plus efficaces et les plus pratiques, mais elles nécessitent un codage JavaScript supplémentaire et un appel de type API au contrôleur. Les options 3 à 5 conviennent à une application basée uniquement sur MVC, mais n'offrent pas une interaction idéale et pourraient entraîner une certaine insatisfaction chez l'utilisateur. Dans cette optique, je suggère l'option 1. C'est la plus simple des deux premières, et son utilisation me permet de vous montrer comment les contrôleurs MVC peuvent également servir de passerelle vers des fonctions d'API.</p>
                    <p>Puisque vous disposez déjà de la vue, il vous suffit de la modifier et d'apporter quelques modifications au contrôleur FilmsController. Concrètement, vous devez :</p>
                    <ol>
                        <li>
                            <p>indiquer si le film figure dans la liste de films de l'utilisateur;</p>
                        </li>
                        <li>
                            <p>insérer des boutons Ajouter/Supprimer dans chaque ligne du tableau;</p>
                        </li>
                        <li>
                            <p>ajouter du JavaScript pour gérer les clics sur les boutons et appeler une nouvelle action issue du contrôleur <span class="em">FilmsController</span>;</p>
                        </li>
                        <li>
                            <p>mettre à jour la méthode Index dans le contrôleur FilmsController pour créer le modèle en utilisant les objets <span class="em">ModelVueFilm</span> au lieu des objets <span class="em">Film</span>;</p>
                        </li>
                        <li>
                            <p>ajouter une nouvelle méthode (AjouterSupprimer) au contrôleur FilsmController.</p>
                        </li>
                    </ol>
                    <p>Écrivons un bout de code supplémentaire.</p>
                    <h4>Indiquer si le film film figure dans la liste de films de l'utilisateur :</h4>
                    <p>Pour ce faire, vous devez modifier le modèle que la page utilise. Heureusement, nous en avons un qui est parfait dans la classe <span class="em">ModelVueFIlm</span> que nous avons écrite plus tôt. Voici la définition du modèle actuel, sur la première ligne de la page Index :</p>
<pre><code>@model IEnumerable&lt;Watchlist.Data.Film&gt;</code></pre>
                    <p>Remplacez-la par ceci :</p>
<pre><code>@model IEnumerable&lt;Watchlist.Models.ModeleVueFilm&gt;</code></pre>
                    <p>Ensuite, vous devez ajouter une colonne supplémentaire au tableau. Ajoutez-en une à l'en-tête et au corps du tableau, entre la colonne <span class="em">Année</span> et la dernière colonne. Nommez l'en-tête <span class="em">Présent dans la liste</span>.</p>
                    <p>Dans le corps du tableau, la nouvelle colonne doit afficher un bouton avec un signe plus (+) si le film n'est pas dans la liste de films de l'utilisateur, et un signe moins (-) dans le cas contraire. Chaque bouton doit avoir son identifiant, ainsi qu'un attribut de données qui contient la valeur de l'attribut de modèle <span class="em">PresentDansListe</span>. Par exemple :</p>
<pre><code>&lt;button id="@item.MovieId" data-val="@item.InWatchlist" class="btn"&gt;
    @(item.PresentDansListe ? " - " : " + ")
&lt;/button&gt;</code></pre>
                    <p>Cet exemple mpntre comment utiliser la syntaxe Razor, indiquée par le signe @ précédant un nom de variable, pour accéder aux données de notre modèle. Insérez l'<span class="em">identifiant</span> de chaque film comme attribut <span class="em">Id</span> du biuton correspondant. Ajoutez également <span class="em">presentDansListe-val</span> comme paramètre et donnez-lui la valeur de l'attribut <span class="em">PresentDansListe</span> de l'objet <span class="em">ModeleVueFilm</span>. Pour afficher le signe approprié sur le bouton, vérifiez la valeur de l'attribut <span class="em">PresentDansListe</span>. Si la valeur est vraie (true), affichez le signe moins, sinon affichez le signe plus.</p>
                    <h4>Utiliser JavaScript pour gérer l'interaction avec l'utilisateur :</h4>
                    <p>Les boutons ajoutés doivent tous appeler une action du contrôleur FilmsController lors du clic. Pour que le script soit appelé au bon moment, ajoutez-le dans une section Razor appelée Scripts, en bas de la page. Ajoutez le script suivant en bas de la page Index :</p>
<pre><code>@section Scripts {
    &lt;script&gt;
        $(() =&gt; {
            $('.btn').click((e) =&gt; {
                var btn = $(this);
                var idFilm = btn.attr('id');
                var valFilm = btn.attr('presentDansListe-val') === "False" ? 0 : 1;
                $.get(`/Films/AjouterSupprimer?id=${idFilm}&val=${valFilm}`, (data) =&gt; {
                    if (data === 0) {
                        btn.attr('presentDansListe-val', 'False');
                        btn.html(' + ');
                    }
                    else if (data === 1) {
                        btn.attr('presentDansListe-val', 'True');
                        btn.html(' - ');
                    }
                });
            });
        });
    &lt;/script&gt;
}</code></pre>
                    <p>Ce script capture chaque clic sur le bouton, récupère les attributs <span class="em">Id</span> et <span class="em">presentDansListe-val</span> du bouton, puis appelle la méthode <span class="em">AjouterSupprimer</span> du contrôleur <span class="em">FilmsController</span> et lui transmet ces valeurs dans l'URL. Ensuite, en fonction de la valeur renvoyée (présence ou absence du film dans la liste de films de l'utilisateur), il modifie le signe affiché sur le bouton.</p>
                    <p>Cependant, pour que cela fonctionne, vous devez écrire cette méthode <span class="em">AjouterSupprimer</span> dans le contrôleur <span class="Em">FilmsController</span>, mais avant de la créer allons d'abord parler de la priorité à la sécurité.</p>
                    <h3>Priorité à la sécurité :</h3>
                    <p>Chaque fois que vous créez une nouvelle application web ASP.NET, vous avez la possibilité d'ajouter un module d'authentification. Pour notre application Watchlist, nous avons choisi l'authentification par des comptes individuels. L'authentification, c'est tout simplement le processus par lequel votre application vérifie l'identité d'un utilisateur, généralement par le biais d'un nom d'utilisateur et d'un mot de passe. Cette fonctionnalité est déjà opérationnelle, et vous l'avez testée en inscrivant un nouveau compte d'utilisateur.</p>
                    <p>Il existe un autre mécanisme de sécurité dans ASP.NET appelé autorisation. Il faudrait un cours complet sur la sécurité .NET, mais, pour simplifier, l'autorisation est la façon dont vous décidez à quelles parties de votre site les utilisateurs peuvent accéder. Par exemple, voulez-vous permettre aux utilisateurs non inscrits de consulter les listes de films de vos abonnés ? Peuvent-ils ajouter des films à votre base de données, en modifier ou en supprimer ? L'autorisation vous permet de contrôler ces différents éléments. Elle est gérée grâce à <span class="em">l'attribut de données AUthorize</span>.</p>
                    <p>Cet attribut n'est pas difficile à implémenter. Je vous recommande de dresser une liste des contrôleurs et des actions de contrôleur de votre application, et d'attribuer un niveau d'accès à chacun d'eux. Commencez par ces quatre catégories d'accès :</p>
                    <ol>
                        <li>
                            <p>Tous les utilisateurs</p>
                        </li>
                        <li>
                            <p>Utilisateurs inscrits (authentifiés)</p>
                        </li>
                        <li>
                            <p>Types précis d'utilisateurs inscrits</p>
                        </li>
                        <li>
                            <p>Utilisateurs précis</p>
                        </li>
                    </ol>
                    <p>Une fois que vous avez identifié le type d'accès requis par les classes et les actions (méthodes) de votre contrôleur, vous pouvez ajouter l'attribut de données approprié à cette classe ou méthode. Vous pouvez sécuriser une classe entière ou des méthodes individuelles, et la syntaxe est simple. Par exemple, pour autoriser uniquement les utilisateurs inscrits à accéder à tout élément de la classe FilmsController, vous devez ajouter l'attribut de données Authorize directement au-dessus de la déclaration de la classe. Pour utiliser cet attribut, vous devez également ajouter une nouvelle déclaration using :</p>
<pre><code>using Microsoft.AspNetCore.Authorization;

[Authorize]
public class FilmsController : Controller
{
    ...
}</code></pre>
                    <p>L'utilisation de cet attribut au-dessus de la définition de la classe sécurise l'ensemble de la classe. Toute requête auprès de l'une des méthodes de la classe sécurise l'ensemble de la classe. Toute requête auprès de l'une des méthodes de la classe nécessitera l'authentification de l'utilisateur par son nom d'utilisateur et son mot de passe. Si l'utilisateur n'est pas connecté, il sera automatiquement redirigé vers la page de connexion.</p>
                    <p>Vous pouvez également sécuriser des méthodes spécifiques tout en laissant les autres méthodes du même contrôleur librement accessibles. Pour ce faire, vous ne devez pas placer l'attribut Authorize au-dessus de la définition de la classe, mais au-dessus de chaque méthode à sécuriser. Seules ces méthodes nécessiteront l'authentification de l'utilisateur.</p>
                    <p>Nous pourrions aller plus loin sur le sujet, par exemple en expliquant comment sécuriser des sections de votre application en fonction du type d'utilisateur ou même du nom d'utilisateur. Toutefois, ce n'est pas indispensable pour cecours et ce projet.</p>
                    <h3>Lier les données :</h3>
                    <p>Les actions du contrôleur reçoivent des données provenant de requêtes HTTP. Ces données ne sont pas transmises en des types de données .NET prédéfinis. Écrire du code pour récupérer chaque valeur et la convertir de chaîne de caractères en type .NET approprié serait compliqué. Le modèle dynamique s'en charge pour vous. La liaison dynamique de données (modèle) :</p>
                    <ul>
                        <li>
                            <p>récupère les données envoyées à partir des routes URL, des champs de formulaire et de la requête;</p>
                        </li>
                        <li>
                            <p>transmet les données à la méthode du contrôleur par le biais de ses paramètres;</p>
                        </li>
                        <li>
                            <p>convertit les données de la chaîne en types de données .NET appropriés.</p>
                        </li>
                    </ul>
                    <p>Par défaut, toutes les propriétés de modèle envoyées à partir d'un formulaire sont liées à une méthode du contrôleur correspondant avec Bind. La syntaxe se présente comme suit :</p>
<pre><code>[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; Create([Bind("Id,Titre,Annee")] Film film)
{
    if (ModelState.IsValid)
    {
        _contexte.Add(film);
        await _contexte.SaveChangesAsync();
        return RedirectToAction(nameof(Index));
    }
    return View(film);
}</code></pre>
                    <p>Si une propriété est absente de la liste Bind, sa valeur ne sera pas ajoutée aux données de l'objet entrant. Si vous ajoutez des propriétés à vos modèles de données après avoir généré automatiquement vos contrôleurs, assurez-vous de les insérer dans les listes Bind des méthodes de vos contrôleurs.</p>
                    <h3>Ajouter une nouvelle fonctionnalité à Watchlist :</h3>
                    <p>Précédemment, nous avons apporté plusieurs modifications à la page Index des films pour permettre d'ajouter et de supprimer facilement des films de la liste de films de l'utilisateur. Une fois ces opérations terminées au niveau du front-end, vous devez apporter plusieurs changements au contrôleur <span class="em">FilmsController</span> pour que la vue soit effectivement modifiée.</p>
                    <p>Tout d'abord, vous avez besoin de l'identifiant de l'utilisateur pour créer sa liste de films à partir de la base de données. Cela signifie que vous devez avoir accès au UserManager, que vous pouvez injecter dans le contrôleur par le biais de son constructeur, tout comme vous le faites avec l'objet de contexte de la base de données. Par exemple :</p>
<pre><code>public class FilmsController : Controller
{
    private readonly ApplicationDbContext _contexte;
    private readonly UserManager&lt;Utilisateur&gt; _gestionnaire;

    public FilmsController(ApplicationDbContext contexte, UserManager&lt;Utilisateur&gt; gestionnaire)
    {
        _contexte = contexte;
        _gestionnaire = gestionnaire;
    }

    ...
}</code></pre>
                    <p>Récupérez ensuite les données de l'utilisateur avec UserManager.</p>
<pre><code>public class FilmsController : Controller
{
    private readonly ApplicationDbContext _contexte;
    private readonly UserManager&lt;Utilisateur&gt; _gestionnaire;

    public FilmsController(ApplicationDbContext contexte, UserManager&lt;Utilisateur&gt; gestionnaire)
    {
        _contexte = contexte;
        _gestionnaire = gestionnaire;
    }

    [HttpGet]
    public async Task&lt;string&gt; RecupererIdUtilisateurCourant()
    {
        Utilisateur utilisateur = await GetCurrentUserAsync();
        return utilisateur?.Id;
    }

    private Task&lt;Utilisateur&gt; GetCurrentUserAsync() =&gt; _gestionnaire.GetUserAsync(HttpContext.User);

    ...
}</code></pre>
                    <p>Maintenant que vous pouvez obtenir l'identifiant de l'utilisateur, vous pouvez déterminer quels films se trouvent dans sa liste de films pour construire le modèle. Pour l'instant, la méthode Index envoie une liste d'objets <span class="em">Films</span> à la page Index. Vous devez changer ce comportement pour qu'elle envoie une liste d'objets <span class="em">ModeleVueFilm</span>.</p>
<pre><code>public class FilmsController : Controller
{
    ...

    public async Task&lt;IActionResult&gt; Index()
    {
        var idUtilisateur = await RecupererIdUtilisateurCourant();
        
        var modele = await _contexte.Films.Select(x =&gt; new ModeleVieFilm
        {
            IdFilm = x.Id,
            Titre = x.Titre,
            Annee = x.Annee
        }).ToListAsync();

        foreach(var item in modele)
        {
            var m = await _contexte.FilmsUtilisateur.FirstOrDefaultAsync(x =&gt; x.IdUtilisateur == idUtilisateur && x.IdFilm = item.IdFilm);

            if (m != null)
            {
                item.PresentDansListe = true;
                item.Note = m.Note;
                item.Vu = m.Vu;
            }
        }

        return View(modele);
    }
}</code></pre>
                    <p>Vous pouvez maintenant ajouter la méthode <span class="em">AjouterSupprimer</span> au contrôleur <span class="em">FilmsController</span>. Cette méthode doit renvoyer un objet <span class="em">JsonResult</span> au lieu d'une vue. De cette façon, vous pouvez mettre à jour le DOM de la page Index sans recharger toute la page. Déterminez si le film est ajouté ou retiré de la liste de films, et renvoyez une valeur en conséquence. Le plus simple est de retourner -1 s'il n'y a pas de changement, 0 si le film est supprimé, et 1 si le film est ajouté. Définissez la méthode comme suit :</p>
<pre><code>[HttpGet]
public async Task&lt;JsonResult&gt; AjouterSupprimer()
{

}</code></pre>
                    <p>Ajoutez maintenant une variable pour stocker la valeur de retour et récupérer l'identifiant de l'utilisateur.</p>
<pre><code>[HttpGet]
public async Task&lt;JsonResult&gt; AjouterSupprimer()
{
    int valret = -1;
    var idUtilisateur = await RecupererIdUtilisateurCourant();
}</code></pre>
                    <p>Ensuite, vérifiez la valeur du paramètre valret pour savoir si vous ajoutez ou supprimez un film. Si la valeur est 1, le film est déjà dans la liste de films et doit donc être supprimé. Si la valeur est 0, le film n'est pas dans la liste de films et doit être ajouté.</p>
<pre><code>[HttpGet]
public async Task&lt;JsonResult&gt; AjouterSupprimer()
{
    int valret = -1;
    var idUtilisateur = await RecupererIdUtilisateurCourant();
    if (valret == 1)
    {
        // s'il existe un enregistrement dans FilmsUtilisateur qui contient à la fois l'identifiant de l'utilisateur
        // et celui du film, alors le film existe dans la liste de films et peut être supprimé
        var film = _contexte.FilmsUtilisateur.FirstOrDefault(x =&gt; x.IdFilm == id && x.IdUtilisateur == idUtilisateur);
        if (film != null)
        {
            _contexte.FilmsUtilisateur.Remove(film);
            valret = 0;
        }
    }
    else
    {
        // le film n'est pas dans la liste de films, nous devons donc
        // créer un nouvel objet FilmUtilisateur et l'ajouter à la base de données.
        _contexte.FilmsUtilisateur.Add(new FilmsUtilisateur
        {
            IdUtilisateur = idUtilisateur,
            IdFilm = id,
            Vu = false,
            Note = 0
        });
        valret = 1;
    }
    // nous pouvons maintenant enregistrer les changements dans la base de données
    await _contexte.SaveChangesAsync();
    // et renvoyer notre valeur de retour (-1, 0 ou 1) au script qui a appelé
    // cette méthode depuis la page Index
    return Json(valret);
}</code></pre>
                    <p></p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>