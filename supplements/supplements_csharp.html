<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>C# et .NET - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_sdk">Installation du SDK</a></li>
                        <li><a href="#premier_projet">Création du premier projet</a></li>
                        <li><a href="#premiere_instruction">Anatomie d'une instruction C#</a></li>
                        <li><a href="#variables_constantes">Les variables et constantes</a></li>
                        <li><a href="#types_en_details">Les types en détails</a></li>
                        <li><a href="#operateurs">Les opérateurs</a></li>
                        <li><a href="#conversion_entre_types">La conversion entre types</a></li>
                        <li><a href="#if">L'instruction de test (if)</a></li>
                        <li><a href="#operateurs_booleens">Les opératuers booléens</a></li>
                        <li><a href="#tableaux_listes">Les tableaux et les listes</a></li>
                        <li><a href="#boucles">Les boucles</a></li>
                        <li><a href="#gestion_erreurs">La gestion des erreurs</a></li>
                        <li><a href="#conclusion_1">Conclusion n° 1</a></li>
                        <li><a href="#explications_technologies_.NET">Explications sur les technologies .NET</a></li>
                        <li><a href="#poo">La programmation orientée objet</a></li>
                        <li><a href="#linq">LINQ</a></li>
                        <li><a href="#linq_to_objects">LINQ To Objects</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage C# et le framework .NET :</h1>
                    <p>D'après Christophe Mommer, développeur C# ayant écrit des livres dessus : <q>Un développeur C#/.NET n'st pas expert sur toutes les technologies .NET !</q>.</p>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage C# (prononcé C Sharp) est un langage de programmation <span class="em">fortement
                            typé</span>, <span class="em">orienté objet</span> et <span class="em">multi-plateforme</span>.
                    </p>
                    <p><span class="em">Fortement typé</span> : chaque élément appartient à un type <span class="em">tout au
                            long de sa vie</span>. Par exemple, si on déclare une variable pour y stocker un entier, on ne
                        pourra JAMAIS y stocker une chaîne de caractères ou une date.</p>
                    <p><span class="em">Orienté objet</span> : approche du développement informatique où l'on peut créer des
                        objets pour y stocker diverses informations.</p>
                    <p><span class="em">Multi-plateforme</span> : le code C# permet de réaliser des applications sur
                        Windows; Mac, téléphone mobile, Web, ... et même votre télévision Samsung !</p>
                    <p>Le C# est <span class="em">compilé</span> par un compilateur qui transforme le code C# en code <span
                            class="em">IL</span> (Intermediate Language).</p>
                    <p>Ce dernier est ensuite interprété par une machine virtuelle (le <span class="em">CLR</span>) qui le
                        transforme en instruction machine.</p>
                    <p>Le gros avantage d'un langage compilé : vérification du code à la compilation.</p>
                    <p>Le compositeur est votre MEILLEUR ami (et il optimise votre code).</p>
                    <p>Le langage de programmation contient un ensemble d'instructions de programmation (comme les
                        conditions, boucles, etc.).</p>
                    <p>Il est fourni avec un framework, .NET, qui contint une collection d'outils prêts à l'emploi.</p>
                    <p>Il existe une version dédiée à Windows (.NET Framework 4.8) et une version multi-plateforme (.NET).
                    </p>
                </article>
                <article>
                    <h2 id="installation_sdk">Installation du SDK :</h2>
                    <p>Le framework .NET 8 s'installe sur tous les systèmes d'exploitation récents (Windows 10/11, Mac OS,
                        Linux).</p>
                    <ol>
                        <li>
                            <p>Se rendre à l'URL <a href="https://dotnet.microsoft/com/download"
                                    target="_blank">https://dotnet.microsoft/com/download</a>.</p>
                        </li>
                        <li>
                            <p>Télécharger la dernière version du SDK .NET (et non .NET Core ni .NET Framewrok).</p>
                        </li>
                        <li>
                            <p>Exécuter l'assistant d'installation.</p>
                        </li>
                        <li>
                            <p>Vérifier que l'installation s'est bien passée en tapant dans une invite de commande :</p>
                            <pre><code>dotnet --version</code></pre>
                        </li>
                    </ol>
                    <p>Le SDK (Software Development Kit) installé contient le compilateur et le runtime.</p>
                    <p>Pour coder, il est possible d'utiliser :</p>
                    <ul>
                        <li>
                            <p>Un éditeur de texte (non recommandé)</p>
                        </li>
                        <li>
                            <p>Visual Studio 2022 (Windows et Mac)</p>
                        </li>
                        <li>
                            <p>Visual Studio Code (Windows, Mac & Linux)</p>
                        </li>
                        <li>
                            <p>Rider (Windows, Mac & Linux)</p>
                        </li>
                    </ul>
                    <p>Visual Studio Code est un éditeur de code <span class="em">gratuit</span> et <span
                            class="em">multi-plateforme</span> suffisant pour notre apprentissage.</p>
                    <p>Se rendre à l'adresse <a href="https://code.visualstudio.com/"
                            target="_blank">https://code.visualstudio.com/</a> pour télécharger la dernière version sable
                        correspondant à votre système d'exploitation.</p>
                    <p>Pour avoir tout le confort de travail, il faut configurer VS Code :</p>
                    <ol>
                        <li>
                            <p>Installation de l'extension <span class="em">OmniSharp</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">Bracket Pair Colorizer</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">VS Sharper for C#</span></p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premier_projet">Création du premier projet :</h2>
                    <p>Un projet C# contient le code nécessaire pour créer une application.</p>
                    <p>Pour apprendre, nous allons commencer par créer une application <span class="em">Console</span>.</p>
                    <ol>
                        <li>
                            <p>Ouvrir VS Code dans un dossier défini.</p>
                        </li>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Écrire la commande :</p>
                            <pre><code>dotnet new console -n MonPremierProjet</code></pre>
                        </li>
                    </ol>
                    <p>Lorsque le code est prêt, un programme C# est exécutable.</p>
                    <p>Dans notre cas, nous avons une application console, son exécution se passe donc dans un terminal.</p>
                    <ol>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Au niveau du répertoire où se situe le fichier <span
                                    class="em">MonPremierProjet.csproj</span>, écrire la commande :</p>
                            <pre><code>dotnet run</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premiere_instruction">Anatomie d'une instruction C# :</h2>
                    <p>L'extension d'un fichier C# est "<span class="em">.cs</span>".</p>
                    <p>La ligne est une instruction C# :</p>
                    <pre><code>Console.WriteLine("Hello, World!");</code></pre>
                    <p>Décomposons cette instruction :</p>
                    <ul>
                        <li>
                            <p><span class="em">Console</span> : objet à utiliser</p>
                        </li>
                        <li>
                            <p><span class="em">.</span> : accesseur à un élément de l'objet le précédant</p>
                        </li>
                        <li>
                            <p><span class="em">WriteLine</span> : méthode d'un objet</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : parenthèses pour passage de paramètres</p>
                        </li>
                        <li>
                            <p><span class="em">"Hello, World!"</span> : valeur du paramètre</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : point-virgule en fin d'instruction</p>
                        </li>
                    </ul>
                    <p>Le commentaire commence par <span class="em">//</span> comme dans l'exemple ci-dessous :</p>
<pre><code>// See https://aka.ms/new-console-template for more information</code></pre>
                    <p>Le commentaire permet d'écrire du texte libre à côté du code source (pour donner une indication quelconque).</p>
                    <p>Exercice : Écrire l'instruction C#, à la ligne de la première, permettant d'afficher "J'apprends le C#" :</p>
<pre><code>Console.WriteLine("J'apprends le C#");</code></pre>
                    <p>En C#, le placement des accolades pour définir le corps des fonctions (méthodes) est une une question de style de codage. Il existe deux approches principales : avec les accolades à la ligne ou sur la même ligne que la déclaration de la fonction.</p>
                    <ol>
                        <li>
                            <p>Accolades à la ligne (Allman Style) :</p>
<pre><code>public void Exemple()
{
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                        <li>
                            <p>Accolades sur la même ligne (K&R Style) :</p>
<pre><code>public void Exemple() {
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                    </ol>
                    <p>Les deux styles sont acceptés par le compilateur C# et sont largement une question de préférence personnelle ou de convention d'équipe. Certains développeurs préfèrent l'un sur l'autre pour des raisons de lisibilité, de style, ou même d'adhésion à des normes de codage spécifiques.</p>
                    <p>Dans la suite du cours, on utilisera la première méthode car Visual Studio 2022 l'utilise, mais il est essentiel de choisir un style cohérent au sein d'un projet ou d'une équipe pour maintenir la lisibilité et la cohérence du code.</p>
                </article>
                <article>
                    <h2 id="variables">Les variables et constantes :</h2>
                    <p>Une variable est une donnée que l'on souhaite stocker pour travailler, dont le contenu peut changer.</p>
                    <p>En C#; une variable est <span class="em">fortement typée</span>, c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer.</p>
                    <p>La syntaxe pour déclare une variable est :</p>
<pre><code>TYPE NOM + VALEUR;</code></pre>
                    <p>Quelques-uns des types les plus courants :</p>
                    <ul>
                        <li>
                            <p><span class="em">Entier</span> &#8594; déclaration avec le mot clé "int".</p>
                            <ul>
                                <li>
                                    <p>La valeur est directement écrite en chiffres.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Chaîne de caractères</span> &#8594; déclaration avec le mot clé "string".</p>
                            <ul>
                                <li>
                                    <p>La valeur est écrite entre guillemets.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Booléen</span> &#8594; déclaration avec le mot clé "bool".</p>
                            <ul>
                                <li>
                                    <p>Peut seulement valor "true" (vrai) ou "false" (faux).</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Le nom d'une variable ne peut pas contenir d'espace. Voici quelques exemples de déclaration de variables :</p>
<pre><code>int age = 29;
string prenom = "Driss";
bool estVivant = true;</code></pre>
                    <p>Dans VS Code, ne prêter pas attention au soulignage. Il 'agit d'un avertissement du compilateur comme quoi une variable est déclarée mais non utilisée.</p>
                    <p>Il existe une syntaxe appelée "typage implicite" permettant d'utiliser un mot clé commun (<span class="em">var</span>) pour que le compilateur devine le type en fonction de la valeur.</p>
<pre><code>var NOM = VALEUR</code></pre>
                    <p>Attention, en l'absence de valeur, le comilateur ne peut pas déduire le type, et il est donc illicite de faire uen instruction <span class="html">var NOM</span>.</p>
<pre><code>var taille = 172;
var nom = "Vandenheede";
var faux = false;</code></pre>
                    <p>La syntaxe pour affecter une variable est :</p>
<pre><code>NOM = VALEUR;</code></pre>
                    <p>Cela <span class="em">impose</span> que la variable ait été déclarée au préalable, sinon cela ne fonctionnera pas.</p>
                    <p>Ainsi, il est possible de chnager une valeur d'une variable après sa création.</p>
<pre><code>taille = 200;</code></pre>
                    <p>Une constante est une donnée que l'on souhaite stocker pour travailler, dont le contenu ne changera jamais.</p>
                    <p>En C#, une constante est <span class="em">fortement typée</span> c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer, tout comme sa valeur.</p>
                    <p>La syntaxe pour déclarer une constante est :</p>
<pre><code>const TYPE NOM = VALEUR;</code></pre>
                    <p>Attention, le mot clé "<span class="em">const</span>" est réservé au langage C# et ne peut pas être utilisé comme nom pour une variable ou une constante.</p>
                    <p>Voici quelques exemples :</p>
<pre><code>const int valeur = 42;
const string pays = "Belgique";
const bool vrai = true;</code></pre>
                    <p>Une variable peut aussi être affectée par une valeur renvoyée par une fonction.</p>
                    <p>Par exemple, la fonction <span class="html">Console.ReadLine();</span> attends la saisie de l'utilisateur (finalisée par l'appui sur entrée) ey renvoie cette valeur.</p>
                    <p>Ainsi, on peut récupérer la valeur dans une variable en définissant l'affectation de la valeur comme étant l'appel de la fonction :</p>
<pre><code>var saisie = Console.ReadLine();</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et de lui dire "Bonjour prénom".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="html">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire la valeur.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string saisie = Console.ReadLine();
Console.WriteLine("Bonjour");
Console.WriteLine(saisie);</code></pre>
                </article>
                <article>
                    <h2 id="types_en_details">Les types en détails :</h2>
                    <p>Bien que le langage se réserve des mots-clés pour les types, ceux-ci sont définis au sein du framework .NET.</p>
                    <p>Par exemple, il y a beaucoup de types différents pour représenter un chiffre, selon sa taille, le fait qu'il puisse être négatif ou non, ainsi que s'il peut avoir une virgule ou pas !</p>
                    <p>Voici une table de référence des types numériques :</p>
                    <table class="tableBalises">
                       <thead>
                        <tr>
                            <th>Type en c#</th>
                            <th>Type système</th>
                            <th>Suffixe</th>
                            <th>Taille mémoire</th>
                            <th>Plage</th>
                        </tr>
                       </thead>
                       <tbody>
                        <tr>
                            <th colspan="5">Types entiers signés</th>
                        </tr>
                        <tr>
                            <td>sbyte</td>
                            <td>System.Sbyte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>-2<sup>7</sup> à 2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td>short</td>
                            <td>System.Int16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>-2<sup>15</sup> à 2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td>int</td>
                            <td>System.Int32</td>
                            <td></td>
                            <td>32 bits</td>
                            <td>-2<sup>31</sup> à 2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td>long</td>
                            <td>System.Int64</td>
                            <td>L</td>
                            <td>64 bits</td>
                            <td>-2<sup>63</sup> à 2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types entiers non signés</th>
                        </tr>
                        <tr>
                            <td>byte</td>
                            <td>System.Byte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>0 à 2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ushort</td>
                            <td>System.UInt16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>0 à 2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td>uint</td>
                            <td>System.UInt32</td>
                            <td>U</td>
                            <td>32 bits</td>
                            <td>0 à 2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ulong</td>
                            <td>System.UInt64</td>
                            <td>UL</td>
                            <td>64 bits</td>
                            <td>0 à 2<sup>64</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types réels</th>
                        </tr>
                        <tr>
                            <td>float</td>
                            <td>System.Single</td>
                            <td>F</td>
                            <td>32 bits</td>
                            <td>&#117; -10<sup>45</sup> à 10<sup>38</sup></td>
                        </tr>
                        <tr>
                            <td>double</td>
                            <td>System.Double</td>
                            <td>D</td>
                            <td>64 bits</td>
                            <td>&#117; -10<sup>324</sup> à &#117; 10<sup>308</sup></td>
                        </tr>
                        <tr>
                            <td>decimal</td>
                            <td>System.Decimal</td>
                            <td>M</td>
                            <td>128 bits</td>
                            <td>&#117; -10<sup>28</sup> à &#117; 10<sup>28</sup></td>
                        </tr>
                       </tbody>
                    </table>
                    <p>Les types entiers signés est utilisé lorsque la valeur peut être positif ou négatif.</p>
                    <p>Les types entiers non signés sont l'inverse des types entiers signés dont la valeur minimale est 0.</p>
                    <p>Les types réels est lorsque la valeur est avec une virgule.</p>
                    <p>Quelques détails supplémentaires :</p>
                    <ul>
                        <li>
                            <p>Le type <span class="html">float</span> ou <span class="html">double</span> est recommandé pour les <span class="em">calculs mathématiques</span> (hautre précision) alors que <span class="em">decimal</span> est recommandé pour les <span class="em">calculs financiers</span>.</p>
                        </li>
                        <li>
                            <p>Depuis C# 7, il est possible d'utiliser un séparateur pour les gros chiffres :</p>
<pre><code>int unMilliard = 1_000_000_000;</code></pre>
                        </li>
                        <li>
                            <p>Le suffixe n'est obligatoire que ds'il existe une ambigüité :</p>
<pre><code>var jeVeuxUnLong = 16UL // ici, par défaut, le type aurait été int</code></pre>
                        </li>
                    </ul>
                    <p>Nous avons déjà travaillé avec les chaînes de caractères :</p>
                    <p>Pour en définir une, il suffit de mettre la valeur entre guillemets :</p>
<pre><code>string prenom = "Driss";</code></pre>
                    <p>Mais qui dit "chaîne" dit "ensemble", ainsi, il existe un type pour un caractère unique.</p>
                    <p>Pour en définir un, il suffit de mettre la valeur entre apostrophes :</p>
<pre><code>char a = 'a';</code></pre>
                    <p>Attention, définir plusieurs caractères entre apostrophes, sauf exceptions ci-après, provoquera une erreur de compilation.</p>
                    <p>Certains caractères particuliers et nécessite un traitement particulier.</p>
                    <p>Le caractère ("\") est utilisé pour les définir.</p>
                    <p>Par exemple : le fait qu'une chaîne de caracyères soit entourées par des guillemets, comment est-ce que je peux avoir des guillemets dans ma chaîne ? Ou stocker le caractère apostrophe ?</p>
                    <p>Voici un tableau de références des caractères spéciaux :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Car</th>
                                <th>Signification</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>\'</td>
                                <td>Apostrophe (dans un char)</td>
<pre><code>char apostrophe = '\'';</code></pre>
                            </tr>
                            <tr>
                                <td>\"</td>
                                <td>Guillemet (dans un string)</td>
<pre><code>string jacquesADit = "Jacques a dit : \"Debout !\"";</code></pre>
                            </tr>
                            <tr>
                                <td>\\</td>
                                <td>Antislash</td>
<pre><code>string cheminWindows = "C:\\docs\\fichier.txt";</code></pre>
                            </tr>
                            <tr>
                                <td>\0</td>
                                <td>Null</td>
                            </tr>
                            <tr>
                                <td>\a</td>
                                <td>Alerte (bip sonore)</td>
                            </tr>
                            <tr>
                                <td>\b</td>
                                <td>Retour arrière</td>
                            </tr>
                            <tr>
                                <td>\f</td>
                                <td>Saut de page</td>
                            </tr>
                            <tr>
                                <td>\n</td>
                                <td>Nouvelle ligne</td>
                            </tr>
                            <tr>
                                <td>\r</td>
                                <td>Retour chariot (entrée)</td>
                            </tr>
                            <tr>
                                <td>\t</td>
                                <td>Tabulation (découplage vers la droite)</td>
                            </tr>
                            <tr>
                                <td>\v</td>
                                <td>Tabulation verticale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>L'antislash peut aussi être utilisé pour représenter directement un caractère de la table Unicode : <a href="https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)" target="_blank">https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)</a>.</p>
<pre><code>char copyright = '\u00A9';</code></pre>
                    <p>La manipulation des chaînes de caractères offre des facilités d'échappement grâce à un syntaxe particulière.</p>
                    <p>Le caractère @ avant les guillemets d'ouverture permet de ne pas avoir à échapper les antislashs (mais empêcje l'utilisation des caractères spéciaux) :</p>
<pre><code>string cheminWindowsSimple = @"C:\docs\fichier.txt";</code></pre>
                    <p>Dans ce cas, èle guillemet dans la chaîne doit être doublé :</p>
<pre><code>string jacquesADit2 = @"Jacques a dit : ""Assis !""";</code></pre>
                    <p>Lorsqu'on utilise deux chaînes, il est possible de "mettre l'une dans l'autre" grâce à un procédé particulier : l'interpolation.</p>
                    <p>Le caractère "1" permet d'insérer une valeur entre accolades au sein d'une chaîne (généralement une variable) :</p>
<pre><code>string prenom = "Driss";
string bonjour = $"Bonjour {prenom}";</code></pre>
                    <p>Dans ce cas, la variable bonjour contiendra "Bonjour Driss".</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser l'interpolation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>Les types vus jsuqu'à présent supportent l'utilisation d'opérateurs (comme l'addition ou la soustraction pour deux valeurs numériques).</p>
                    <p>Pour ce faire, on utilisera les caractères suivants :</p>
                    <ul>
                        <li>
                            <p>"+" pour l'addition</p>
                            <li>
                                <p>"-" pour la soustraction</p>
                            </li>
                            <li>
                                <p>"*" pour la multiplication</p>
                            </li>
                            <li>
                                <p>"/" pour la division</p>
                            </li>
                            <li>
                                <p>"%" pour le modulo (reste de la division entière)</p>
                            </li>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de manipuler les opérateurs avec les types numériques.</p>
                    <p>Pour bien commencer :</p>
                    <ul>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Créer deux variables contenant 9 et 2.</p>
                        </li>
                        <li>
                            <p>Faire la totalité des opérateurs mathématiques sur les numériques et constater les résultats !</p>
                        </li>
                    </ul>
                    <p>9 + 2 = 11 // aucun commentaire</p>
                    <p>9 - 2 = 7 // aucun commentaire</p>
                    <p>9 * 2 = 18 // aucun commentaire</p>
                    <p>9 / 2 = 4</p>
                    <ul>
                        <li>
                            <p>Nous divisons un entier par un entier, le résultat doit être entier. Nous avons ici le quotient d'une division Euclidienne. Le reste est calculé par la fonction modulo.</p>
                        </li>
                    </ul>
                    <p>9 % 2 = 1</p>
                    <ul>
                        <li>
                            <p>C'est le reste correspondant à notre division Euclidienne ci-dessus.</p>
                        </li>
                    </ul>
                    <p>Dans le cas des chaînes de caractères, un opérateur a été implémenté afin de réaliser une concaténation.</p>
                    <p>Pour ce faire, on utilisera le caractère "+" afin de concaténer deux chaînes :</p>
<pre><code>string bonjourChaine = "Bonjour " + "Driss";</code></pre>
                    <p>Cela a tout son intérêt lorsqu'on utilise des variables :</p>
<pre><code>string bonjour = "Bonjour ";
string prenom = "Driss";

string bonjourComplet = bonjour + prenom;</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser la concaténation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine("Bonjour " + prenom + ", vous avez " + age + " ans");</code></pre>
                    <p>Rappel : un booléen est une valeur valant vrai (true) ou faux (false).</p>
                    <p>Ainsi, pour savoir si quelque chose est vrai ou faux, il faut une comparaison. Par exemple, on peut tester l'égalité grâce à l'opérateur "==" (attention, double égal) :</p>
<pre><code>int a1 = 42;
int a2 = 43;
bool egaux = a1 == a2; // La variable "egaux" vaudra "false" ici.</code></pre>
                    <p>La différence se teste avec l'opérateur "!=" :</p>
<pre><code>bool different = a1 != a2; // La variable "different" vaudra "true" ici.</code></pre>
                    <p>On peut utiliser également des opérateurs mathématiques traditionnels :</p>
                    <ul>
                        <li>
                            <p>Supérieur à : utilisation du caractère "&gt;"</p>
                        </li>
                        <li>
                            <p>Supérieur ou égal à : utilisation du caractère "&gt;="</p>
                        </li>
                        <li>
                            <p>Inférieur à : utilisation du caractère "&lt;"</p>
                        </li>
                        <li>
                            <p>Inférieur ou égal à : utilisation du caractère "&lt;="</p>
                        </li>
                    </ul>
<pre><code>int a1 = 42;
int a2 = 43;
bool a1PlusGrand = a1 &gt; 10; // Vaudra "true"
bool a2InfOuEgal = a2 &lt;= 100; // Vaudra "true"</code></pre>
                </article>
                <article>
                    <h2 id="conversion_entre_types">La conversion entre types :</h2>
                    <p>Rappel : le langage C# est fortement type, il n'est pas possible de changer le type d'une variable déjà déclarée.</p>
                    <p>Il arrive que l'on ait besoin de convertir une variable d'un type A vers un type B, par exemple, transformer une chaîne de caractères en entier.</p>
                    <p>Il existe de nombreuses façons de créer une variable d'un aure type à partir d'une variable déjà définie.</p>
                    <p>Un des besoins les plus courants est d'obtenir une chaîne de caractères depuis un type quelconque.</p>
                    <p>Nous verrons pourquoi lorsque nous ferons le moddule sur la programmation orientée objet, mais chaque élément C# poss!de une méthode particulière : <span class="html">ToString()</span>.</p>
                    <p>Ainsi, il est possible de transformer un entier en chaîne comme ceci :</p>
<pre><code>int valeurEntiere = 42;
string entierChaine = valeurEntiere.ToString();</code></pre>
                    <p>Lorsqu'on récupère une saisie d'un utilisateur, nous obtenons une valeur de type de chaîne de caractères.</p>
                    <p>Néanmoins, pour certaines opérations (comparaison avec un autre entier, addition...), il faut convertir cette valeur vers un entier.</p>
                    <p>Il y a plusieurs façons de faire cette opération.</p>
                    <p>Une classe très pratique, <span class="html">Convert</span>, nous permet de transformer une valeur vers n'importe quel autre type, sous réserve que cela soit possible :</p>
<pre><code>string valeurChaine = "29";
int vingtNeuf = Convert.ToInt32(valeurChaine);</code></pre>
                    <p>La classe <span class="html">Convert</span> est très pratique, mais beaucoup de types exposent aussi une méthode appelée <span class="html">Parse</span>, comme par exemple :</p>
<pre><code>string saisie = Console.ReadLine();
int saisieEntier = int.Parse(saisie);</code></pre>
                    <p>Attention, au niveau de connaissance actuel, les deux alternatives peuvent être utilisées indistinctement.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables (<span class="html">string</span> pour le prénom et <span class="html">int</span> pour l'âge) et utiliser l'interpolation pour construire la phrase attendue.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="if">L'instruction de test (if) :</h2>
                    <p>Un booléen seul ne présente pas grand intérêt s'il n'est pas testé pour une branche de code.</p>
                    <p>À cet effet, le langage C# propose une instruction pour tester un booléen l'instruction "<span class="em">if</span>".</p>
                    <p>Cette instruction a la syntaxe suivante :</p>
<pre><code>if (booléen)  // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}</code></pre>
                    <p>Lorsqu'on teste une condition, il y a deux possibilités : vrai ou faux.</p>
                    <p>Le bloc défini après l'instruction ne sera exécuté que si la condition renvoie vrai.</p>
                    <p>On peut définir l'autre alternative grâce au mot-clé "<span class="html">else</span>".</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer si le booléen testé initialement vaut "<span class="em">false</span>".
}</code></pre>
                    <p>Il existe également le mot-clé "<span class="html">else if</span>" pour tester un autre booléen. Voici sa syntaxe :</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else if (autreBooléen) // On teste la valeur booléenne entre parenthèses. Ça signifie "sinon si".
{
    // On définit entre accolades le code à effectuer si l'autre booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer tous les autres booléens testés initialement valent "<span class="em">false</span>".
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Puis d'écrire si la personne est majeure ou mineure (l'âge de la majorité sera défini en constante).</p>
                    <p>Quelques indicatons :</p>
                    <ul>
                        <li>
                            <p>utiliser <span class="html">if</span> et <span class="html">else</span> afin d'afficher uniquement la phrase correspondante.</p>
                        </li>
                        <li>
                            <p>Le test entre les deux valeurs peut être fait directement entre les parenthèses du "<span class="em">if</span>".</p>
                        </li>
                    </ul>
<pre><code>const int majorite = 18;
Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");

if (age &gt;= majorite)
{
    Console.WriteLine("Vous êtes majeur");
}
else
{
    Console.WriteLine("Vous êtes mineur");
}</code></pre>
                    <p>On peut utiliser l'instruction <span class="em">switch</span> pour sélectionner l'un des nombreux blocs de code à exécuter. Voici sa syntaxe :</p>
<pre><code>switch (expression)
{
    case x:
        // bloc de code exécuté si "expression == x" est <span class="em">true</span>.
        break;
    case y:
        // bloc de code exécuté si "expression == y" est <span class="em">true</span>.
        break;
    default:
        // bloc de code exécuté par défaut s'il n'y a pas de correspondance de <span class="em">case</span>.
        break;
}</code></pre>
                </article>
                <article>
                    <h2 id="operateurs_booleens">Les opérateurs booléens :</h2>
                    <p>Un booléen peut s'inverser grâce au caractère "<span class="html">!</span>" :</p>
<pre><code>bool estFaux = !true;</code></pre>
                    <p>Bien qu'un booléen ne puisse prendre que deux valeurs (vrai ou faux), la logique répond à l'algèbre de Boole.</p>
                    <p>Ainsi, il existe trois opérateurs en algèbre booléen :</p>
                    <ul>
                        <li>
                            <p>Le<span class="em">ET</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU EXCLUSIF</span></p>
                        </li>
                    </ul>
                    <p>Ces opérateurs prennent deux booléens pour en former un seul.</p>
                    <p>Les tales de résultats de ces opérateurs sont les suivantes :</p>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>ET</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">ET</span> est le "<span class="html">&</span>"."</p>
<pre><code>etVrai = true & true;
bool etFaux = true & false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU</span> est le "<span class="html">|</span>".</p>
<pre><code>bool ouVrai = false | true;
bool ouFaux = false | false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU EXCLUSIF</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU EXCLUSIF</span> est le "<span class="html">^</span>".</p>
<pre><code>bool ouExVrai = true ^ false;
bool ouExFaux = true ^ true;</code></pre>
                    <p>L'opérateur <span class="em">&</span> ou <span class="em">|</span> seul implique que chacune des valeurs sera testée.</p>
                    <p>Lorsqu'on double l'opérateur (donc <span class="em">&&</span> ou <span class="em">||</span>), l'exécution s'arrêtera dès lors qu'une valeur rend la condition fausse.</p>
                    <p>Par exemple :</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true & vrai == true)
{

}</code></pre>
                    <p>Les deux tests seront effectués.</p>
                    <p>Alors que...</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true && vrai == true)
{

}</code></pre>
                    <p>Seulement le premier sera effectué.</p>
                    <h3>Exercice :</h3>
                    <p>Cet exercice est le début de l'implémentation de votre premier projet qui sera un jeu exécutable.</p>
                    <p>Ce jeu, c'est le nombre mystère : le joueur doit deviner le nombre caché en entrant une valeur.</p>
                    <p>Il s'agit ici d'implémenter la logique initiale :</p>
                    <ul>
                        <li>
                            <p>Créer un nouveau projet dédié (appelons le <span class="em">NombreMystere</span>).</p>
                        </li>
                        <li>
                            <p>Définir le nombre mystère en tant que constante.</p>
                        </li>
                        <li>
                            <p>Demander à l'utilisateur de deviner le nombre mystère.</p>
                        </li>
                        <li>
                            <p>Vérifier la valeur avec celle effective :</p>
                            <ul>
                                <li>
                                    <p>Si c'est plus grand, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est plus petit, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est le bon nombre , lui dire qu'il a gagné.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>BONUS : demander en préambule le prénom du joueur pour le conserver, cela nous sera utile par la suite.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
int nbSaisi = int.Parse(Console.ReadLine());

if (nbSaisi == nbMystere)
{
    Console.WriteLine("Vous avez gagné !");
}
else
{
    if (nbSaisi &gt; nbMystere)
    {
        Console.WriteLine("Le nombre mystère est plus petit");
    }
    else
    {
        Console.WriteLine("Le nombre mystère est plus grand");
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="tableaux_listes">Les tableaux et les listes :</h2>
                    <p>Une collection est un ensemble de valeurs réunies.</p>
                    <p>Il existe un grand nombre de collections C#.</p>
                    <p>La première collection qu'on va étudier est la plus simple : le tableau.</p>
                    <p>Un tableau est un ensemble défini d'avance d'éléments du même type, c'est-à-dire qu'on ne pourra pas avoir un tableau qui mélange des chaînes de caractères et des entiers.</p>
                    <p>La syntaxe pour déclarer un tableau est d'utiliser des crochets ("[" et "]") après le type :</p>
<pre><code>string[] tableauDeStrings = new string[10];</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans le tableau.</p>
                        </li>
                        <li>
                            <p><span class="em">[]</span> : doubles crochets vides pour la déclaration du type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer le tableau en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">[10]</span> : doubles crochets avec la taille pour l'affectation de la valeur.</p>
                        </li>
                    </ul>
                    <p>Comme on vient de le voir, un tableau doit être déclaré avec une taille initiale.</p>
                    <p>L'avantage de cette approche est qu'on est très précis sur la mémoire que l'on occupe.</p>
                    <p>L'inconvénient est que le tableau n'est pas facilement redimensionnable.</p>
                    <p>Pour accéder à un élément du tableau (en lecture comme en écriture), on utilisera un index, qui commence à O pour la 1<sup>ère</sup> position, que l'on placera entre les crochets après le nom de la variable :</p>
<pre><code>tableauDeStrings[0] = "toto";
string toto = tableauDeStrings[0];</code></pre>
                    <p>Il est possible de définir les valeurs initiales du tableau en utilisant une syntaxe particulière :</p>
<pre><code>TYPE[] NOM = new TYPE[x] { VALEUR1, VALEUR2, ..., VALEURX };</code></pre>
<pre><code>int[] unACinq = new int[5] { 1, 2, 3, 4, 5 };</code></pre>
                    <p>La force du tableau est sa faible empreinte mémoire, il a une faiblesse indéniable qui est la difficulté de gérer sa taille facilement.</p>
                    <p>Bien heureusement, le framework .NET nous offre une autre type de collection : la liste.</p>
                    <p>De façon sous-jacente, la liste utilise un tableau, mais propose des facilités, car la taille est gérée de façon automatique.</p>
                    <p>Pour utiliser une liste, il faut écrire le code suivant :</p>
<pre><code>List&lt;TYPE&gt; NOM = new List&lt;TYPE&gt;();</code></pre>
                    <p>La syntaxe est très particulière, car elle fait appel à deux notions que nous n'avons encore vues : la construction d'objet et les génériques.</p>
                    <p>Ces notions seront vues en détail plus tard afin de bien comprendre.</p>
                    <p>Par exemple, pour créer une liste de chaîne de caractères :</p>
<pre><code>List&lt;string&gt; chaines = new List&lt;string&gt;();</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans la liste.</p>
                        </li>
                        <li>
                            <p><span class="em">&lt;&gt;</span> : utilisation des chevrons pour encadrer le type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer la liste en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">List&lt;string&gt;</span> : reprise du type complet après le mot-clé "<span class="html">new</span>".</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : double parenthèses comme l'appel d'une fonction.</p>
                        </li>
                    </ul>
                    <p>La liste offre une fonction permettant de facilement ajouter un élément, la fonction <span class="html">Add</span>.</p>
<pre><code>chaines.Add("une valeur");</code></pre>
                    <p>La liste peut s'utiliser comme un tableau à l'aide des index (en mettant le chiffre dans les croches après le nom de la variable).</p>
<pre><code>string valeurListe = chaines[0];</code></pre>
                    <p>Attention, comme le tableau, accéder à un index invalide provoquera un plantage du programme.</p>
                </article>
                <article>
                    <h2 id="boucles">Les boucles :</h2>
                    <p>Il peut arriver qu'il est nécessaire de répéter une action un certain nombre de fois.</p>
                    <p>Par exemple, dans notre jeu, la partie s'arrête dès le premier essai.</p>
                    <p>Or, on souhaiterait peut-être donner plusieurs chances au joueur.</p>
                    <p>Pour ça, il faut utiliser une boucle. On peut créer une boucle :</p>
                    <ul>
                        <li>
                            <p>Qui s'arrête sur la base d'une condition.</p>
                        </li>
                        <li>
                            <p>Qui effectue un nombre de tours défini d'avance.</p>
                        </li>
                        <li>
                            <p>Qui parcourt toutes valeurs d'une collection.</p>
                        </li>
                    </ul>
                    <p>La boucle "for" est une boucle qui prend 3 éléments en considération :</p>
                    <ul>
                        <li>
                            <p>Un état de départ.</p>
                        </li>
                        <li>
                            <P>Une condition de sortie.</P>
                        </li>
                        <li>
                            <p>Une fonction à exécuter à chaque pas.</p>
                        </li>
                    </ul>
                    <p>Elle est généralement utilisée pour faire un nombre défini d'avance de tours.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>for (ÉTAT DE DÉPART ; CONDITION DE SORTIE ; FONCTION)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
<pre><code>for (int i = 0; i &lt; 10; i++)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">for</span> : mot-clé "for" de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">int i = 0</span> : état de départ.</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : attention, séparation par un ";".</p>
                        </li>
                        <li>
                            <p><span class="em">i &lt; 10</span> : condition de sortie.</p>
                        </li>
                        <li>
                            <p><span class="em">i++</span> : fonction à chaque tour de boucle. Ici, c'est une post-incrémentation, c'est-à-dire que ça augmente de 1 la valeur de i.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander à un utilisateur de saisir 3 choses puis de les afficher sur chaque ligne.</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser un tableau pour stocker les nombres.</p>
                        </li>
                        <li>
                            <p>Utiliser la boucle "<span class="html">for</span>" afin d'afficher les éléments. Indice : l'index se trouve dans la boucle et change à chaque tour.</p>
                        </li>
                    </ol>
<pre><code>string[] valeurs = new string[3];

for (int i = 0; i &lt; 3; i++)
{
    Console.WriteLine($"Veuillez saisir la valeur {i + 1}");
    valeurs[i] = Console.ReadLine();
}

for(int i = 0; i &lt; 3; i++)
{
    Console.WriteLine(valeurs[i]);
}</code></pre>
                    <p>La boucle "while" est une boucle qui considère une condition pour s'exécuter.</p>
                    <p>Tant que la conditon ne renvoie pas "false", la boucle dera des tours sans s'arrêter.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>while (condition)
{
    // Comme le "for", on mettra entre accolades le code à effecteuer entre chaque tour de boucle.
}</code></pre>
                    <p>Attention, le compilateur ne vous préviendra pas si votre boucle est infinie !</p>
<pre><code>int entier = 0;
while (entier &lt; 10)
{
    entier++;
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions entre accolades sera exécuté tant que la condition ne sera pas égale à "false".</p>
                        </li>
                        <li>
                            <p><span class="em">entier &lt; 10</span> : condition qui sera évaluée à chaque tour.</p>
                        </li>
                    </ul>
                    <p>Il existe également le mot clé "<span class="html">do ... while</span>" dont voici la syntaxe :</p>
<pre><code>int entier = 0;
do {
    Console.WriteLine("entier = {0}", entier);
    entier++;
} while (entier &lt; 10);</code></pre>
                    <p>Ça permet d'exécuter au moins une fois le code entre accolades avant de tester la condition.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur n'a qu'une seule tentative et doit relancer l'application.</p>
                    <p>Il faut transformer le jeu pour que le joueur puisse jouer jusqu'à ce qu'il ait gagné.</p>
                    <p>&#8597; une boucle "<span class="html">while</span>" pour faire que le joueur puisse jouer tant qu'il n'a pas gagné.</p>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;

while (!gagne)
{
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
    int nbSaisi = int.Parse(Console.ReadLine());

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            Console.WriteLine("Le nombre mystère est plus petit");
        }
        else
        {
            Console.WriteLine("Le nombre mystère est plus grand");
        }
    }
}</code></pre>
                    <p>Bien qu'il soit possible de parcourir une collection en entier grâce aux boucles "<span class="html">for</span>" et "<span class="html">while</span>", il exitste une boucle particulière dédiée à cela.</p>
                    <p>La boucle "<span class="html">foreach</span>" permet de prendre chacun des éléments d'une collection, un par un, afin d'effectuer une action.</p>
                    <p>La syntaxe est la suivante :</p>
<pre><code>foreach (TYPE NOM in COLLECTION)
{

}</code></pre>
<pre><code>foreach(int entier in unACinq)
{

}</code></pre>
                    <p>Disséquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions sera exécuté pour chaque élément de la collection parcourue.</p>
                        </li>
                        <li>
                            <p><span class="em">int</span> : type de la variable qui sera déclarée localement.</p>
                        </li>
                        <li>
                            <p><span class="em">entier</span> : nom de la variable qui sera disponible dans le bloc de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">unACinq</span> : collection à parcourir.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur doit remonter dans l'historique du terminal afin de savoir quels chiffres il a déjà joués.</p>
                    <p>Nous allons améliorer l'interface graphique du jeu :</p>
                    <ol>
                        <li>
                            <p>En stockant dans une collection la liste des chiffres déjà joués.</p>
                        </li>
                        <li>
                            <p>En nettoyant la console grâce à <span class="html">Console.Clear()</span> entre chaque tour de jeu.</p>
                        </li>
                        <li>
                            <p>En affichant en début de tour la liste des chiffres déjà joués (utiliser la boucle "<span class="html">foreach</span>").</p>
                        </li>
                    </ol>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");

    int nbSaisi = int.Parse(Console.ReadLine());
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>      
                </article>
                <article>
                    <h2 id="gestion_erreurs">La gestion des erreurs :</h2>
                    <p>Lorsqu'un programme C# rencontre une erreur à l'exécution, l'application cesse de fonctionner si cette erreur n'est pas gérée.</p>
                    <p>Cela s'appelle une <span class="em">exception</span>.</p>
                    <p>Par exemple, le code suivant provoquera une erreur à l'exécution si l'utilisateur ne saisit pas un chiffre valide :</p>
<pre><code>string saisie = Console.ReadLine();
int saisiEntier = int.Parse(saisie);</code></pre>
                    <p>Il est heureusement possible de gérer les erreurs en utilisant un mécanisme particulier : try-catch.</p>
                    <p>Ce mécanisme est défini comme suit :</p>
<pre><code>try
{
    // Bloc contenant le code à "essayer".
}
catch
{
    // Bloc contenant le code en cas d'erreur.
}
finally
{
    // Bloc contenant le code à exécuter s'il y a une erreur attrapée ou pas. 
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur peut saisir une valeur différente d'un entier et faire planter l'application.</p>
                    <p>Nous allons améliorer le comportement du jeu :</p>
                    <ul>
                        <li>
                            <p>Si l'utilisateur saisit un chiffre, continuer le déroulé classique du jeu.</p>
                        </li>
                        <li>
                            <p>Si l'utilisateur saisit une autre valeur, afficher un message sur la console lui demandant de corriger sa saisie avant de continuer.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;
const int nbMin = 1;
const int nbMax = 10;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    int nbSaisi = 0;
    while (nbSaisi &lt; nbMin || nbSaisi &gt; nbMax)
    {
        Console.WriteLine($"Veuillez entrer un nombre entre {nbMin} et {nbMax}");
        try
        {
            nbSaisi = int.Parse(Console.ReadLine());
        }
        catch
        {
            nbSaisi = 0;
        }
    }
    
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="conclusion">Conclusion n°1 :</h2>
                    <p>Le contenu jusqu'à présent a été dense, et avant de poursuivre, il faut vous <span class="em">assurer</span> que vous maîtrisez les points suivants :</p>
                    <ol>
                        <li>
                            <p>La différence entre une variable et une constante.</p>
                        </li>
                        <li>
                            <p>Le typage en C#.</p>
                        </li>
                        <li>
                            <p>Les opérations sur les numériques, chaînes de caractères et booléens.</p>
                        </li>
                        <li>
                            <p>Les tests avec <span class="html">if</span> et <span class="html">else</span>.</p>
                        </li>
                        <li>
                            <p>La connaissance élémentaire des collections basiques (tableau et liste).</p>
                        </li>
                        <li>
                            <p>Les boucles <span class="html">for</span>, <span class="html">while</span> et <span class="html">foreach</span>.</p>
                        </li>
                        <li>
                            <p>La gestion des erreurs avec <span class="em">try.catch</span>.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="explications_technologies_" class="NET">Explications sur les technologies .NET :</h2>
                    <p>.NET a fortement évolué ces dernières années, avec l'arrivée de nouvelles solutions et de nouveaux frameworks.</p>
                    <p>Les nouveaux arrivants, les recruteurs et même quelques habitués ont perdus leurs repères.</p>
                    <p>À l'origine, quand .NET est sorti, c'était sous la forme de .NET Framework : une solution de développement sous Windows, exclusivement.</p>
                    <p>Il y avait 3 solutions : des librairies (faire des DLL), des applications graphiques (tout d'abord WinForms, puis plus tard WPF) et du web (ASP.NET WebForms, puis ASP.NET MVC).</p>
                    <p>Il y a eu des problèmes : .NET a été ré-implémenté en open-souce sous le nom Mono, notamment pour ASP.NET. Linux est majoritaire sur les serveurs, et ASP.NET n'était pas compatible.</p>
                    <p>Avec l'arrivée de Windows 10, Microsoft investit sur un nouveau CLR &#894; CoreCLR.</p>
                    <p>Suite à cela, .NET est open-source avec la création de .NET Core 1.0.</p>
                    <p>Mais .NET Framework existe tourjous. .NET Core et .NET Framework partagent un sous-ensemble commun (en dehors du langage).</p>
                    <p>Microsoft a créé un standard, .NET Standard, qui est la définition d'un sous-ensemble du framework comme un standard, accessible aussi bien en .NET Core qu'en .NET Framework (il y a eu 9 versions, en fonction des plateformes et des versions du framework...).</p>
                    <p>Pour résumer, .NET Core est la version open-source multi-plateforme, .NET Framework est la version Windows et .NET Standard est la définition de ce qui est commun entre les différentes versions .NET.</p>
                    <p>Afin de supprimer les incohérences, Microsoft annonce un nouveau .NET, qui se base sur .NET Core, et qui doit devenir "la seule façon de faire .NET".</p>
                    <p>On commence à la version 5, car .NET Core est en 3.1 et .NET Framework en 4.8.</p>
                    <p>Avec .NET on peut faire du web (ASP.NET, Blazor), du Machine Learning (ML.NET), de l'IOT (Runtimes optimisés), des apps Windows (WinForms, WPF, WinUI), des jeux vidéos (Unity) et du mobile (Xamarin, MAUI).</p>
                    <p>Il existes différents frameworks.</p>
                    <p>ASP.NET est dorénavant disponible :</p>
                    <ol>
                        <li>
                            <p>Razor Pages, pour faire des applications "classiques" (comme PHP, mais avec C#).</p>
                        </li>
                        <li>
                            <p>MVC, pareil que ci-dessus, mais avec le pattern du même nom.</p>
                        </li>
                        <li>
                            <p>WebAPI, pour faire des APIs (existe en MVC et Minimal APIs).</p>
                        </li>
                        <li>
                            <p>Blazor, pour faire des SPA (existe en version Serveur et WebAssembly).</p>
                        </li>
                    </ol>
                    <p>Xamarin : Approche historique &#8594; C# compilé en natif.</p>
                    <p>Xamarin Forms : Surcouche graphique pour des composants unifiés.</p>
                    <p>MAUI : Réécriture de Xamarin pour standardiisation et offrir plus de destination.</p>
                    <p>Pour les applications Windows, il y a WinForms (Approche historique, toujours valide), WPF (Propulsé avec Windows Vista) et WinUI (Successeur d'UWP, exclusivement pour Win 10/11 (store)).</p>
                </article>
                <article>
                    <h2 id="poo">La programmation orientée objet :</h2>
                    <p>Les conventions C# :</p>
                    <ul>
                        <li>
                            <p>Nom des champs &#8594; _champ</p>
                        </li>
                        <li>
                            <p>Méthode &#8594; Commence par une lettre majuscule</p>
                            <ul>
                                <li>
                                    <p>Attention Main</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>C# utilise des propriétés plutôt que getter/setter.</p>
                            <ul>
                                <li>
                                    <p>Propriété en Majuscule !</p>
                                </li>
                            </ul>
<pre><code>private readonly DateTime _dateDeNaissance;
public DateTime DateDeNaissance
{
get { return _dateDeNaissance; }
}</code></pre>
                        </li>
                        <li>
                            <p>Propriéts simples auto-implémentées :</p>
<pre><code>public DateDeNaissance { get; set; }</code></pre> 
                        </li>
                    </ul>
                    <p>Le package est une organisation physique et logique et le namespace est une organisation logique.</p>
                    <p>C# utilise un mécanisme d'annotations qui est notamment utilisé pour la sérialisation. Les annotations sont placées entre []. Par exemple : [Serializable].</p>
                    <p>Les interfaces commencent par un "I" (ex : IList, IDictionnary). <span class="em">Implements</span> et <span class="em">Extends</span> se traduisent tous les deux par le caractère "<span class="em">:</span>".</p>
                    <p>Les collections disposent d'une classe de base qui correspond au nom de l'interface sans le "I" (ex : List, Dictionnary, ...).</p>
                    <p>Lors l'héritage en Java, toutes les méthodes sont "virtual", c'est-à-dire qu'elles peuvent être redéfinies dans les classes enfants et que le type de l'objet est recherché à l'exécution.</p>
                    <p>Lors de l'héritage en C#, par défaut les méthodes ne sont pas "virtual", c'est-à-dire que le type de l'objet à l'exécution sera la classe la plus haute dans la hiérarchie.</p>
                    <p>Si on veut le même comportement qu'en Java, virtual (parent) et override (enfant).</p>
                    <p>Comme en Java, C# possède un Iterator : <span class="html">IEnumerator</span>. La proriété GetEnulmerator sur les listes, dictionnaires, ...</p>
                    <p>Pour boucler l'itérateur, il existe la méthode <span class="html">it.MoveNext()</span> (hashNext + next en Java)</p>
                    <p>Pour trouver l'objet courant, il y a la propriété <span class="html">it.Current</span>.</p>
                </article>
                <article>
                    <h2 id="linq">LINQ :</h2>
                    <h3>Introduction à LINQ :</h3>
                    <p>LINQ (<span class="em">Langauage Integrated Query</span>) est une innovation de la version 3.5 du .NET Framework qui permet de rapprocher le monde des objets et le monde des données.</p>
                    <p>Le Framework .NET 4.0, quant à lui, a implémenté une nouvelle couche à LINQ. Cette nouvelle couche appelée <span class="em">PLINQ</span>, pour "<span class="em">Parallel LINQ</span>", est un complément à "<span class="em">LINQ To Objects</span>" qui implémente un jeu complet de méthodes afin de combiner la simplicité et la lisibilité de la syntaxe LINQ et la puissance de la programmation parrallèle.</p>
                    <p>Dans de nombreux scénarios, <span class="em">PLINQ</span> peut ainsi augmenter considérablement la vitesse des requêtes "<span class="em">LINQ To Objects</span>", sur de gros volumes de données, en utilisant plus efficacement tous les coeurs disponibles sur l'ordinateur hôte.</p>
                    <p>Cette performance accrue apporte une puissance de calcul haute performance sur le Bureau.</p>
                    <p>Cependant, l'utilisation de <span class="em">PLINQ</span> pour des petits volumes de données est déconseillée en raison des ressources mises en place pour la gestion parallèle qui, au final, risquerait d'alourdir votre application.</p>
                    <p>Traditionnellement, lorsque nous souhaitons réaliser des requêtes sur des données, ces dernières étaient exprimées sous forme de chaînes de caractères sans possibilité de vérification à la compilation et sans prise en charge par "l'IntelliSense".</p>
                    <p>En outre, nous devions apprendre des langages complémentaires en fonction des sources de données (XPath, SQL, TSQL, PL/SQL, ...).</p>
                    <p>Avec LINQ, toute requête prendra la forme d'une construction de langage de premier ordre (C# ou VB). De plus, nous pourrons écrire ces requêtes en utilisant des mots clés du langage et des opérateurs familiers.</p>
                    <p>LINQ a été prévu pour travailler pour travailler avec différentes sources de données :</p>
                    <ul>
                        <li>
                            <p>Collections d'objets fortement typées (<span class="em">LINQ To Objects</span>)</p>
                        </li>
                        <li>
                            <p>Fichiers XML (<span class="em">LINQ To XML</span>)</p>
                        </li>
                        <li>
                            <p>Bases de données SQL Server (<span class="em">LINQ To SQL</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET (<span class="em">LINQ To DataSet</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET Entities Framework (<span class="html">LINQ To Entities</span>)</p>
                        </li>
                    </ul>
                    <h3>Le mot clé "var" :</h3>
                    <p>Ce mot clé est probablement le plus important qu'à apporter LINQ et, bien que nécessaire, le plus controversé aussi.</p>
                    <p>En effet, C# et VB (en mode "Strict") étant des langages "fortement typé", chaque variable doit être déclarée avec un type avant d'être instanciée. Or, le mot clé "var" permet de déclarer des variables dont le type sera implicitement donné par le compilateur lors de la compilation.</p>
                    <p class="em">Si le mot clé "var" est utilisé, la variable doit être instanciée lors de sa déclaration.</p>
<pre><code>static void Main(string[] args)
{
    int i = 5;
    var s = "Hello World !";
    var o = new object();
    
    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>Bien que l'utilisation du mot clé "var" soit permise, il n'en reste que son utilisation abusive risque de nuire à la compréhension du code. Sans oublier que cela implique que nous laisserons le compilateur choisir implicitement, pour nous, le type de la variable.</p>
                    <p>Ce qui en soit pourra poser des problèmes dans le cadre des valeurs littérales et dans le cadre du polymorphisme pour ne citer qu'eux.</p>
<pre><code>static void Main(string[] args)
{
    var i = 5;
    var s = "Hello World !";
    var o = new object();

    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>i sera de type "System.Int32".</p>
                    <p class="em">Par conséquent, lorsque nous connaissons le type à utiliser, nous devrons utiliser ce type plutôt que "var".</p>
                    <h3>Les types anonymes :</h3>
                    <p>Mais, alors pourquoi avoir ajoutée un type "fourre tout" dans un environnement "fortement typé" ?</p>
                    <p>Car LINQ étant un langage puissant, et il se peut que la requête retourne un type qui ne sera connu que lors de la compilation. Ces types sont appelés "Type anonyme".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
}</code></pre>
                    <p>On peut remarquer que, dans LINQ, la convention de nommage des propriétés d'une classe suit généralement les conventions de nommage des propriétés en C#. Selon la convention de style courante en C#, les noms des propriétés commencent par une majuscule (PascalCase).</p>
<pre><code>static void Main(string[] args)
{
    List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
    Contacts.AddRange(new Contact[] {
        new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be"},
        new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be"}
    });

    // On ne prend que le Nom et l'Email du Contatct en créant implicitement un nouveau type.
    // Ce "nouveau type" est un type anonyme.
    var InfosDeContactsChoisies = from Contact c in Contacts
                                  select new { Nom = c.Nom, Email = c.Email };
    
    foreach (var Infos in InfosDeContactsChoisies)
    {
        Console.WriteLine("{0} {1}", Infos.Name, Infos.Email);
    }

    Console.ReadLine();
}</code></pre>
                    <h3>Les expressions "LAMBDA" :</h3>
                    <p>Une expression "LAMBDA" est une fonction anonyme qui peut contenir des expressions et des instructions, cette expression pourra être utilisée pour créer des délégués (delegate) ou des types d'arborescence d'expression.</p>
                    <p>Toutes ces expressions utilisent l'opérateur LAMDBA "=&gt;" qui se lit "conduit à".</p>
<pre><code>class Program
{
   delegate int del(int i);
   
   static void Main(string[] args)
   {
    del Mydelegate = x =&gt; x * x;
    int j = Mydelegate(5);

    Console.WriteLine(j);
    Console.ReadLine();
   }
}</code></pre>
                    <p class="em">Dans l'exemple, nous lirons "x conduit à x fois x".</p>
                    <p>Le côté gauche de l'expression spécifie les paramètres en entrée (le cas échéant) et le côté droit contient le bloc d'expression ou d'instructions.</p>
                    <p>Une expression LAMBDA avec une expression sur le côté est appelée "<span class="em">lambda-expression</span>.</p>
                    <p>Les "lambda-expression" sont utilisées dans la construction d'arborescences d'expression, elle retourne le résultat de l'expression et prend la forme suivante : (Paramètres d'entrée) =&gt; expression.</p>
                    <p>Les parenthèses sont facultatives uniquement dans le cas où nous n'avons qu'un seul paramètre.</p>
                    <p>Dans le cas contraire, elles sont obligatoires :</p>
<pre><code>class Program
{
    delegate long Addition(int x, int y);

    static void Main(string[] args)
    {
        Addition MonAddition = (x, y) =&gt; (long)x + y;

        long j = MonAddition(5, 7);

        Console.WriteLine(j);
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si l'expression ne reçoit aucun paramètre, nous le signalerons par des parenthèses vides.</p>
<pre><code>class Program
{
    delegate bool del();

    static void Main(string[] args)
    {
        del Mydelegate = () =&gt; UneMethode();

        Console.WriteLine(MyDelegate());
        Console.ReadLine();
    }

    static bool UneMethode()
    {
        bool Result = true;
        // ... traitement
        return Result;
    }
}</code></pre>
                    <p class="em">Nous remarquons aussi dans cet exemple que le corps d'une expression "LAMBDA" peut se composer d'un appel de méthode.</p>
                    <p>Il existe un autre type d'expression "LAMBDA", celle qui ont à droite un bloc d'instruction.</p>
                    <p>Elles sont appelées "lambda-instruction". Une "lambda-instruction" est similaire à la "lambda-expression", sauf que les instructions sont mises entre accolades.</p>
                    <p>Bien que le corps d'une "lambda-instruction" puisse contenir une infinité d'instructions; dans la pratique ce nombre est généralement de 2 ou 3.</p>
<pre><code>class Program
{
    delegate void del(string s);

    static void Main(string[] args)
    {
        del MyDelegate = n =&gt; {
            string s = string.Format("Hello {0}!!", n);
            Console.WriteLine(s);
        };

        MyDelegate("Michael");

        Console.ReadLine();
    }
}</code></pre>
                    <p>Nous verrons plus tard que de nombreux "opérateurs de requêtes standard" comportent un paramètre d'entrée dont le type, "Func&lt;T, Result&gt;", fait partie de la famile des délégués génériques.</p>
                    <p>Nous verrons ces opérateurs de requêtes standard dans la partie "LINQ To Object".</p>
<pre><code>public delegate TResult Func&lt;TArg0, TResult&gt;(TArg0 Arg0);</code></pre>
                    <p>Décortiquons la syntaxe ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">TResult</span> : Type de retour.</p>
                        </li>
                        <li>
                            <p><span class="em">TArg0</span> : Type du paramètre.</p>
                        </li>
                    </ul>
                    <p>Ces délégués génériques sont très utiles pour encapsuler des expressions définies par l'utilisateur appliquées à chaque élément dans un ensemble de données.</p>
                    <p>Nous pourrions instancier ce type de délégués comme suit :</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Func&lt;int, bool&gt; EstImpaire = x =&gt; x % 2 == 1;

        Console.WriteLine(EstImpaire(5));
        Console.WriteLine(EstImpaire(4));

        Console.ReadLine();
    }
}</code></pre>
                    <p>Lorsque nous écrivons des expressions "LAMBDA", nous n'aurons généralement pas à spécifier les types de paramètres d'entrées. En effet, le compilateur pourra déduire leur type en fonction du corps du lambda, du type de délégué sous-jacent ainsi que d'autres facteurs décrits dans la spécification du langage C#.</p>
                    <p>Ce qui signifie que nous aurons accès à leurs méthodes et leurs propriétés.</p>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        del Contains = (s1, s2) =&gt; s1.ToUpper().Contains(s2.ToUpper());

        string content = "lu";

        Console.WriteLine(Contains("Hello", content));
        Console.WriteLine(Contains("Aluminium", content));

        Console.ReadLine();
    }
}</code></pre>
                    <h3>Les méthodes d'extension :</h3>
                    <p>Lorsque LINQ est arrivé, il a apporté bon nombre de nouvelles fonctionnalités aux objets du Framework .NET. Les plus communes sont les "opérateurs de requêtes standard LINQ" qui ajoute des fonctionnalités de requête aux types "IEnumerable" et "IEnumerable&lt;&gt;".</p>
                    <p>Ces types d'objets ont donc vu leur nombre de fonctionnalités augmenté mais "Microsoft" n'a pas modifié leur type d'origine. Ils ont utilisé le principe de méthodes d'extension.</p>
                    <p>Ces dernières vont nous permettent d'ajouter des méthodes à des types existants sans créer un type dérivé ou sans devoir modifier et recompiler le type d'origine.</p>
                    <p>Nous allons les définir comme méthodes statiques mais nous appellerons en utilisant la syntaxe de méthode d'instance.</p>
                    <p>Leur paramètre spécifie les types sur lesquels la méthode fonctionne et ce paramètre sera précédé par le modificateur "this".</p>
                    <p class="em">Leurs types héritant du type sur lequel nous avons ajouter une méthode d'extension, hériteront également de la méthode d'extension.</p>
                    <p>Ajoutons la méthode "CompteMot" au type "string".</p>
<pre><code>public static class MesExtensions
{
    public static int CompteMot(this string s)
    {
        return s.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        string s = "Il fait très beau aujourd'hui";

        Console.WriteLine(s.CompteMot());
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si un ou plusieurs paramètres sont nécessaires nous devons simplement les mettre à la suite du premier paramète.</p>
<pre><code>public static long Addition(this int i, params int[] ints)
{
    long result = i;

    foreach (int n in ints)
    {
        result += n;
    }

    return result;
}</code></pre>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(String[] args)
    {
        int x = 7;

        Console.WriteLine(x.Addition(8, 5, 63, 9, 4));
        Console.ReadLine();
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_objects">LINQ To Objects :</h2>
                    <h3>Introduction à LINQ To Objects :</h3>
                    <p><span class="em">LINQ To Objects</span> fait référence à l'utilisation directe de requêtes LINQ, avec n'importe quelle collection "IEnumerable" et "IEnumerable&lt;T&gt;" telles que "List&lt;T&gt;", "Array" ou "Dictionary&lt;Tkey, Tvalue&gt;" définies par l'utilisateur ou retournées par une API du Framework .NET.</p>
                    <p>Auparavant, nous devions écrire des boucles complexes pour spécifier comment récupérer des données d'une collection. Maintenant grâce à LINQ, nous pourrons écrire du code déclaratif qui décrira exactement ce que nous voudrons.</p>
                    <p>Ces requêtes offrent trois principaux avantages par rapport aux boucles :</p>
                    <ul>
                        <li>
                            <p>Elles sont plus concises et lisibles.</p>
                        </li>
                        <li>
                            <p>Elles fournissent des fonctions puissantes de filtrage, de classement et de regroupement avec un minimum de code.</p>
                        </li>
                        <li>
                            <p>Elles peuvent être appliquées à d'autres sources de données avec peu ou pas de changement.</p>
                        </li>
                    </ul>
                    <p>En gros, plus l'opération sur les données à d'autres sources de données avec peu ou pas de changement.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom, c.Nom
                                                    select c;</code></pre>
                    <h3>LINQ &#8594; Query ou pas ! :</h3>
                    <p><span class="em">LINQ</span> étant l'abréviation de "<span class="em">Language Integrated Query</span>", nous pourrions penser qu'il se limite à l'interrogation de données. Mais en réalité, son utilisation peut aller bien au-delà.</p>
<pre><code>string[] ValuesAsStrings = { "110", "987", "205", "341" };
int[] ints = ValuesAsStrings.Select(s =&gt; Int32.Parse(s)).ToArray();

foreach (int i in ints)
{
    Console.WriteLine(i);
}

Console.ReadLine();</code></pre>
                    <p class="em">La conversion de ce tableau de "string" en "int" pourrait être plus simple ?</p>
                    <h3>IEnumerable&lt;T&gt; et séquence :</h3>
                    <p>Cette interface a été implémentée par les tableaux et les classes de collections génériques de C# 2.0. Elle permet, de par son fonctionnement, d'énumérer les éléments d'une collection.</p>
                    <p>Une séquence est un terme logique d'une collection implémentant l'interface "IEnumerable&lt;T&gt;". En d'autres termes, si nous avions une variable de type "IEnumerable&lt;string&gt;", nous pourrons dire que nous avons une séquence de "string".</p>
                    <p>Nous allons voir, par la suite que la plupart des "Opérateurs de requête standard" sont prototypées de façon à retourner une séquence (IEnumerable&lt;T&gt;).</p>
                    <h3>Opérateurs de requête standard :</h3>
                    <p>Les "opérateurs de requête standard" sont les méthodes qui composent le modèle LINQ.</p>
                    <p>Ka plupart de ses méthodes fonctionnent sur des séquences et fournissent des fonctions de requête, notamment le filtrage (Where), la projection (Select), l'agrégation (Sum), le tri (Orderby), etc.</p>
                    <p>Elles sont définies, dans la classe "Enumerable", comme méthodes d'extension à l'interface "IEnumerable", cela implique qu'elles peuvent être appelées sur n'importe quelle collection générique comme méthode d'instance.</p>
                    <p>Ces opérateurs sont regroupés par fonctionnalité :</p>
                    <ul>
                        <li>
                            <p>Agrégation</p>
                        </li>
                        <li>
                            <p>Concaténation</p>
                        </li>
                        <li>
                            <p>Conversion</p>
                        </li>
                        <li>
                            <p>Égalité</p>
                        </li>
                        <li>
                            <p>Élément</p>
                        </li>
                        <li>
                            <p>Ensemble</p>
                        </li>
                        <li>
                            <p>Filtrage</p>
                        </li>
                        <li>
                            <p>Génération</p>
                        </li>
                        <li>
                            <p>Jointure</p>
                        </li>
                        <li>
                            <p>Partitionnement</p>
                        </li>
                        <li>
                            <p>Projection</p>
                        </li>
                        <li>
                            <p>Quantificateur</p>
                        </li>
                        <li>
                            <p>Regroupement</p>
                        </li>
                        <li>
                            <p>Tri</p>
                        </li>
                    </ul>
                    <p class="em">En annexe, vous trouverez la liste complète de ces opérateurs (.NET 3.5) par ordre alphabérique.</p>
                    <h3>Modes d'exécutions :</h3>
                    <p>Les opérateurs de requêtes standard se divisent en 2 modes d'exécution : immédiat et différé.</p>
                    <p>L'exécution immédiate signifie que la source de données est lue et que l'opérateur est effectuée au point où la requête est déclarée dans le code. Ce mode d'exécution vise tous les opérateurs de requête standard qui retournent un résultat unique et non énumérable comme les opérateurs d'agrégation, d'élément, etc.</p>
                    <p>L'exécution différée signifie que l'opération n'est pas effectuée au point où la requête est déclarée dans le code mais qu'elle le sera uniquement que lorsque la variable de requête est énumérée (boucle foreach par exemple).</p>
                    <p>Cela signifie que les résultats de l'exécution de la requête dépendent du contenu de la source de données lorsque la requête est exécutée plutôt que lorsqu'elle est définie. Si la variable de requête est énumérée plusieurs fois, les résultats peuvent s'avérer différents chaque fois. Presque tous les opérateurs de requête standard dont le type de retour est IEnumerable&lt;T&gt; s'exécutent de manière différée.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Certains des opérateurs de requêtes standard, les plus courants, possèdent une syntaxe de mots clé du langage C# qui leur permet d'être appelés dans le cadre d'une expression de requête.</p>
                    <p>Par défaut, pour utiliser LINQ, nous devrions appeler ces opérateurs qui sont des méthodes. L'expression de requête nous offre une forme plus lisible que son équivalent fondé sur des méthodes.</p>
                    <p>Les clausses de requêtes sont traduites en appels de méthodes lors de la compilation.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom,c.Nom
                                                    select c;</code></pre>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
                                                    .Where(c =&gt; c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1))
                                                    .OrderBy(c =&gt; c.Prenom)
                                                    .ThenBy(c =&gt; c.Nom);</code></pre>
                    <p>Une expression de requête doit commencer par une clause "from" et doit se terminer par une clause "select" ou "group". Entre la première clause from et la dernière clause select ou group, elle peut contenir une ou plusieurs clauses facultatives : where, orderby, join, let et même d'autres clauses from supplémentaires.</p>
                    <p>Nous pourrons également utiliser le mot clé "into" pour que le résultat d'une clause "join" ou "group" puisse servir de source pour des clauses de requête supplémentaires dans la même expression de requête.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Liste des Opérateurs supportant l'expression de requête en C# :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Opérateur</th>
                                <th>Syntaxe d'expression de requête</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Cast</td>
                                <td>'from <span class="em">int</span> n in numbers' explicitement typé</td>
                            </tr>
                            <tr>
                                <td>GroupBy</td>
                                <td>'group ... by' ou 'group ... by ... into ...'</td>
                            </tr>
                            <tr>
                                <td>GroupJoin</td>
                                <td>'join ... in ... on ... equals ... into ...'</td>
                            </tr>
                            <tr>
                                <td>Join</td>
                                <td>'join ... in ... on ... equals ...'</td>
                            </tr>
                            <tr>
                                <td>OrderBy</td>
                                <td>'order by ...'</td>
                            </tr>
                            <tr>
                                <td>OrderByDescending</td>
                                <td>'orderby ... descending'</td>
                            </tr>
                            <tr>
                                <td>Select</td>
                                <td>'select'</td>
                            </tr>
                            <tr>
                                <td>SelectMany</td>
                                <td>Plusieurs clauses 'from'</td>
                            </tr>
                            <tr>
                                <td>ThenBy</td>
                                <td>'orderby ..., ...'</td>
                            </tr>
                            <tr>
                                <td>ThenByDescending</td>
                                <td>'orderby ..., ... descending'</td>
                            </tr>
                            <tr>
                                <td>Where</td>
                                <td>'where'</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Les opérateurs courants :</h3>
                    <p>Nous allons à présent faire le tour des opérateurs les plus souvent utilisés en LINQ. Les exemples qui vont suivre seront exécutés sur une liste générique de "Contact".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
    public int AnneeDeNaissance { get; set; }
}

List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
Contacts.AddRange(new Contact[] {
    new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be", AnneeDeNaissance = 1982 },
    new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be", AnneeDeNaissance = 1974 },
    new Contact() { Nom = "Dupuis", Prenom="Thierry", Email="thierry.depuis@cognitic.be", AnneeDeNaissance = 1988 },
    new Contact() { Nom = "Faulkner", Prenom="Stéphane", Email="stephane.faulkner@cognitic.be", AnneeDeNaissance = 1969 },
    new Contact() { Nom = "Selleck", Prenom="Tom", Email="tom.selleck@imdb.com", AnneeDeNaissance = 1945 },
    new Contact() { Nom = "Anderson", Prenom="Richard Dean", Email="richard.dean.anderson@imdb.com", AnneeDeNaissance = 1950 },
    new Contact() { Nom = "Bullock", Prenom="Sandra", Email="sandra.bullock@imdb.com", AnneeDeNaissance = 1964 },
    new Contact() { Nom = "Peppard", Prenom="George", Email="peppard.george@ateam.com", AnneeDeNaissance = 1928 },
    new Contact() { Nom = "Estevez", Prenom="Emilio", Email="emilio.estevez@breakfirstclub.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Moore", Prenom="Demo", Email="demi.moore@imdb.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Willis", Prenom="Bruce", Email="bruce.willis@diehard.com", AnneeDeNaissance = 1955 },

});</code></pre>
                    <p>Voici les opérateurs que nous allons voir :</p>
                    <ul>
                        <li>
                            <p>Opérateurs "Cast&lt;T&gt;" & "OfType&lt;T&gt;"</p>
                        </li>
                        <li>
                            <p>Opérateur "Where"</p>
                        </li>
                        <li>
                            <p>Opérateur "Select"</p>
                        </li>
                        <li>
                            <p>Opérateur "Distinct"</p>
                        </li>
                        <li>
                            <p>Opérateur "SingleOrDefault"</p>
                        </li>
                        <li>
                            <p>Opérateur "FirstOrDefault"</p>
                        </li>
                        <li>
                            <p>Opéreateurs "OrderBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "ThenBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Count" & "LongCount"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Min" & "Max"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Sum" & "Average"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupBy"</p>
                        </li>
                        <li>
                            <p>Opérateur "Join"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupJoin"</p>
                        </li>
                    </ul>
                    <p class="html">Dans certains cas, les oéprateurs ont des surcharges. Pour ne pas rallonger inutilement ce cours, je me contenterai des prototypes de base.</p>
                    <p class="html">Vous trouverez l'ensemble des surcharges sur le site "MSDN" ou dans la classe "Enumerable".</p>
                    <p class="em">J'ajouterai la requête sous forme d'"expression de requête", lorsque l'opérateur supportera cette syntaxe.</p>
                    <h3>Opérateurs "Cast&lt;T&gt;" & "TypeOf&lt;T&gt;" :</h3>
                    <p>La grande majorité des opérateurs de requête LINQ ne peut être utilisée que sur des collections qui implémentent l'interface "IEnumerable&lt;T&gt;"/ Or, aucune des collections présente dans l'espace de nom "System.Collections", telles que Array, ArrayList ou HashTable, n'implémentent cette interface."</p>
                    <p>Mais alors comment utiliser LINQ avec ces collections ?</p>
                    <p>En regardant de plus près la classe "Enumerable" qui implémente les méthodes d'extension de LINQ. Nous retrouvons deux méthodes qui ne sont pas des méthodes d'extension sur l'interface "IEnumerable&lt;T&gt;" mais sur "IEnumerable".</p>
                    <p>Ces deux opérateurs sont là pour transformer une collection "IEnumerable" en une séquence "IEnumerable&lt;T&gt;".</p>
                    <p>Cependant, ces opérateurs sont quelque pei différents l'un de l'autre.</p>
                    <h4>Cast&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet oéprateur va tenter de convertir tous les éléments de la collection en une séquence de type 'T'. Si celle-ci n'y parvient pas, elle lèvera une exception.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.Cast&lt;Contact&gt;();</code></pre>
                    <p>Cet opérateur supporte la syntaxe d'expresion de requête. En spécifiant explicitement le type à utiliser.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = from Contact c in MyArrayList
                                    select c;</code></pre>
                    <h4>OfType&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet opérateur, quant à lui, va filtrer en fonction de leur capacité à être castées dans le type spécifié.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.OfType&lt;Contact&gt;();</code></pre>
                    <p>Cet opératue n'étant pas supporter par l'expression de requête, voici comment spécifier que l'on utilise "OfType&lt;T&gt;" plutôt que "Cast&lt;T&gt;".</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

// Attention 2 requêtes LINQ imbriquées
IEnumerable&lt;Contact&gt; Result = from c in MyArrayList.OfType&lt;Contact&gt;()
                                    select c;</code></pre>
                    <h4>Préférons "OfType&lt;T&gt;" à "Cast&lt;T&gt;" :</h4>
                    <p>Bien que ces deux opérateurs soient utilisables sur une collection héritée (System.Collection), "Cast&lt;T&gt;" nécessite que tous les éléments aient le type attendu.</p>
                    <p>Pour éviter de générer des excceptions en cas d'incompatibilité de types, préférons-lui l'opérateur "OfType&lt;T&gt;". Par son intermédiaire, seuls les objets pouvant être castés dans le type attendu seront stockés dans la séquence.</p>
                    <p>Les autres seront purement et simplement ignoré.</p>
                    <h3>Opérateur "Where" :</h3>
<pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>L'opérateur "Where" est utilisé pour filtrer une séquence.</p>
                    <p class="em">Cet opérateur utilise le "delegate" générique "Func&lt;T, bool&gt;" vu dans le chapitre précédent.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Where(c =&gt; c.AnneeDeNaissance &gt;= 1950);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    where c.AnneeDeNaissance &gt;= 1950
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateur "Select" :</h3>
<pre><code>public static IEnumerable&lt;TR&gt; Select&lt;T, TR&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TR&gt; selector);</code></pre>
                    <p>L'opérateur "Select" est utilisé pour retourner une séquence d'éléments sélectionnés dans la séquence d'entrée ou à partir d'une portion de la séquence d'entrée.</p>
                    <p>Dans les requêtes LINQ basées sur les appels de méthodes, l'opérateur "Select" est facultatif et sert principalement à sélectionner une portion, en termes de Propriétés, des objets en entrée et de créer de nouveaux types d'objets (types anomymes).</p>
                    <p>Dans les expressions de requête, que l'on crée un type anonyme ou non, celui-ci est obligatoire.</p>
<pre><code>// Sélectionne tous les contacts et retourne une séquence de type "Contact"
IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                         select c;</code></pre>
                    <h4>Création d'un type anonyme :</h4>
                    <p>Pour créer un type anonyme, nous devons joindre à notre select le mot clé "new".</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Nom = c.Nom, Courriel = c.Email });

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <h4>Expresion de requête :</h4>
<pre><code>var QueryResult = from c in Contacts
                             select new { Nom = c.Nom, Courriel = c.Email };

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <p class="em">Création à la volée de propriétés.</p>
                    <h3>Opérateur "Distinct" :</h3>
<pre><code>public static IEnumerable&lt;T&gt; Distinct&lt;T&gt;§(this IEnumerable&lt;T&gt; source);</code></pre>
                    <p>L'opérateur "Ditinct" permet de supprimer les doublons dans une séquence.</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Prenom = c.Prenom }).Distinct();

foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>var QueryResult = (from c in Contacts
                             select new { Prenom = c.Prenom }).Distinct();
                            
foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <p class="html">Le distinct se fait sur la valeur de l'ensemble des propriétés.</p>
                    <h3>Opérateur "SingleOrDefault" :</h3>
                    <p>L'opérateur "SingleOrDefault" retourne un élément unique d'une séquence de type 'T', si la valeur est introuvable, il retourne la valeur de "default(T)".</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre"))
    .SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>Contact QueryResult = (from c in Contacts
                                 where c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre")
                                 select c).SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <p>Cependant, si la requête retourne plus d'un élément, l'opérateur "SingleOrDefault" lèvera une exception.</p>
                    <p class="em">Dans ce cas de figure et afin d'éviter l'erreur, il est conseillé d'utiliser "FirstOrDefault".</p>
                    <h3>Opérateur "FirstOrDefault" :</h3>
<pre><code>public static TSource FirstOrDefault&lt;TSource&gt;(this Ienumerable&lt;TSource&gt; source);</code></pre>
                    <p>L'opérateur "FirstOrDefault" retourne le premier élément d'une séquence de type 'T' ou la valeur de "default(T)" dans le cas ou aucune valeur ne serait trouvée.</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry"))
    .FirstOrDefault();

if (QueryResult != null)
    Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h3>Opérateurs "OrderBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; OrderBy&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; OrderByDescending&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "OrderBy" trie par ordre croissant les éléments d'une séquence sur base d'une clé (propriété). Pour un ordre décroissant, nous devrions utiliser "OrderByDescending". Si nous sous souhaitons trier sur base de plusieurs clés, ces opérateurs doivent être les premiers à être utiliser.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.OrderBy(c =&gt; c.AnneeDeNaissance);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;T&gt; QueryResult = from c in Contacts
                                              orderby c.AnneeDeNaissance
                                              select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "ThenBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; ThenBy&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; ThenByDescending&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>Les opérateurs "ThenBy" (Croissant) et "ThenByDescending" (Décroissant) permet de trier une séquence sur plusieurs clés (propriétés). Nous pouvons avoir autant de clé "ThenBy" ou "ThenByDescending" que nous voulons. Cependant, ceux-ci ne sont utilisables que si un des opérateurs "OrderBy" ou "OrderByDescending' a été déclaré en premier lieu.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
    .OrderBy(c =&gt; c.AnneeDeNaissance)
    .ThenByDescending(c =&gt; c.Nom);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    orderby c.AnneeDeNaissance, c.Nom descending
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "Count" & "LongCount" :</h3>
<pre><code>public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>Ces deux opérateurs comptent le nombre d'éléments dans une collection. Leur différence se situe dans leur type de retour. Ceux-ci peuvent être accompagné d'une expression booléenne qui va permettre de filtrer le nombre d'éléments à compter.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne le nombre de l'ensemble des éléments
Console.WriteLine(string.Format("Nombre total : {0}", ints.Count()));
// retourne le nombre des éléments pairs
Console.WriteLine(string.Format("Nombre d'éléments pairs : {0}", ints.Count(i =&gt; i % 2 == 0)));</code></pre>
                    <h3>Opérateurs "Min" & "Max" :</h3>
                    <p>Comme l'indique leurs noms, les opérateurs "Min" et "Max" retournent respectivement la valeur minimale et maximale d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// retourne la plus petite valeur
Console.WriteLine(string.Format("Minimum : {0}", ints.Min()));
// Retourne la plus grande valeur
Console.WriteLine(string.Format("Maximum : {0}", ints.Max()));
// Retourne l'année de naissance du contact le plus vieux
int AnneeDeNaissance = Contacts.Min(c =&gt; c.AnneeDeNaissance);
Console.WriteLine("Le contatct le plus vieux est né en {0}", AnneeDeNaissance);</code></pre>
                    <p class="html">Voir les différentes surcharges dans la classe "Enumerable".</p>
                    <h3>Opérateurs "Sum" & "Average" :</h3>
                    <p>Les opérateurs "Sum" et "Average" retournent respectivement la somme et la moyenne d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne la somme
Console.WriteLine(string.Format("Somme : {0}", ints.Sum()));
// Retourne la moyenne
Console.WriteLine(string.Format("Moyenne : {0}", ints.Average(i =&gt; (float)i)));
// Retourne l'âge moyen des contacts
Console.WriteLine("L'âge moyen de nos contacts est de {0} ans", DateTime.Now.Year - (int)Contacts.Average(c =&gt; c.AnneeDeNaissance));</code></pre>
                    <h3>Opérateur "GroupBy" :</h3>
<pre><code>public static IEnumerable&lt,IGrouping&lt;TKey, TSource&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "GroupBy" est un peu différent des autres, par défaut celui-ci travaille avec l'interface "IGrouping&lt;TKey, TElement&gt;" qui hérite de "IEnumerable&lt;T&gt;" et intégrant une propriété "Key".</p>
<pre><code>public interface IGrouping&lt;out TKey, out TElement&gt; : IEnumerable&lt;TElement&gt;,, IEnumerable
{
    TKey Key { get; }
}</code></pre>
                    <p>Ce qui donne ceci :</p>
<pre><code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = Contacts
    .GroupBy(c =&gt; c.Email.Substring(c.Email.IndexOf('@') + 1));

foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</code></pre>
                    <p class="html">Il existe plusieurs surcharges, ici c'est la plus utilisée qui est vue.</p>
                    <p>De plus, dans le cadre de l'expression régulière, "GroupBy" ne peut être utilisé avec l'opérateur "Select" excepté dans le cadre du "group ... by ... into ...".</p>
                    <h4>Expression de requête :</h4>
<pre><code></code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = from c in Contacts
                                                                                    group c by c.Email.Substring(c.Email.IndexOf('@') + 1);
                                                            
foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</pre>
                    <p class="em">Notons l'absence de l'opérateur "Select" dans la requête.</p>
                    <p>Dans ce cas, comment utiliser l'opérateur "GroupBy" avec les types anonymes ?</p>
<pre><code>var QueryResult = Contacts
    .Select(c =&gt; new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
    .GroupBy(c =&gt; c.Email.Substring(c.Email.indexOf('@') + 1));

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">En utilisant l'opérateur "Select" avant le "GroupBy"...</p>
                    <h4>Expression de requête :</h4>
<pre><code>var QueryResult = from c2 in (from c in Contacts
                                        select new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
                             group c2 by c2.Email.Substring(c2.Email.indexOf('@') + 1);

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">... qui se traduira par une sous-requête dans l'expression de requête.</p>
                    <h3>Opérateur "Join" :</h3>
                    <p>L'opérateur "Join" est utile pour associer des séquences différentes sur base de valeurs pouvant être comparée pour définir une égalité.</p>
                    <p>La jointure est une opération importante dans les requêtes qui ciblent les sources de données dont les relations ne peuvent pas être suivies directement. Dans la programmation orientée objet, cela pourrait signifier <span class="em">une corrélation entre objets qui n'est pas modélisée</span>.</p>
                    <p class="html">Cette corrélation est fortement utilisée en "LINQ To SQL" & "LINQ To Entities".</p>
                    <p>Quand on parle de jointures, il y en a trois qui reviennent régulièrement :</p>
                    <img src="../images/join_linq.png" alt="">
                    <p>Croisée (Cross Join), Interne (Inner Join), Externe (Outer Join - Left, Right & full). Celles-ci peuvent peuvent être basées sur une équalité "Equi Join" et ou non "Non Equi Join".</p>
                    <p>L'opérateur "Join" en LINQ ne reprend qu'une seule forme de jointure ("Inner Join" basée sur une égalité). Cependant, nous allons voir comment réaliser les autres jointures en utilisant LINQ.</p>
                    <p>Pour les "Cross Join" ou les "Non Equi Join", nous ne pourrons pas utiliser l'opérateur "Join". Cependant, nous pourrons contourner le problème par l'utilisation de plusieurs clauses "from" et l'utilisation de clauses "where".</p>
                    <p>Afin de comprendre les jointures en LINQ, nous allons ajouter une nouvelle classe "RDV" et de nouvelles données (Liste "RendezVous") à notre environnement.</p>
<pre><code>public class RDV
{
    public string Email { get; set; }
    public DateTime Date { get; set; }
}</code></pre>
<pre><code>List&lt;RDV&gt; RendezVous = new List&lt;RDV&gt;();
RendezVous.AddRange(new RDV[] {
    new RDV() { Email = "stephane.faulkner@cognitic.be", Date = new DateTime(2012, 5, 12) },
    new RDV() { Email = "peppard.george@ateam.com", Date = new DateTime(2011, 8, 14) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 19) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 20) },
    new RDV() { Email = "michael.person@cognitic.be", Date = new DateTime(2012, 4, 19) },
});</code></pre>
<pre><code>public static IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; resultSelector);</code></pre>
                    <h4>Inner Join :</h4>
                    <p>Obtenir l'email, le nom, le prénom du contact et la date de tous les rendez-vous.</p>
<pre><code>var QueryResult = Contacts.Join(RendezVous,
                                           c =&gt; c.Email,
                                           rdv =&gt; rdv.Email,
                                           (c, rdv) =&gt; new {
                                            Email = c.Email,
                                            Nom = c.Nom,
                                            Prenom = c.Prenom,
                                            DateRDV = rdv.Date});

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <h5>Expression de requête :</h5>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.Email equals rdv.Email
                             select new {
                                Email = c.Email,
                                Prenom = c.Prenom,
                                DateRDV = rdv.Date
                             };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <p>L'utilisation des types anonymes n'est pas obligatoire dans le cadre des jointures, son emploi résulte en effet de ce que nous allons sélectionner.</p>
                    <p>Exemple : Obtenir les contacts ayant pris rendez-vous.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Join(RendezVous,
                                                                 c =&gt; c.Email,
                                                                 rdv =&gt; rdv.Email,
                                                                 (c, rdv) =&gt; c);</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    join rdv in RendezVous on c.Email equals rdv.Email
                                                    select c;</code></pre>
                    <p class="em">Nous obtenons bien une séquence de Contacts.</p>
                    <h3>Opérateur "GroupJoin" :</h3>
<pre><code>public static IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector);</code></pre>
                    <p>L'opérateur "GroupJoin" travaille de manière comparable à l'opérateur "Join, à ceci près que l'opérateur "Join" ne passe qu'un seul élémént de la séquence interne à la fonction "resultSelector".</p>
                    <p>Cela signifie que si plusieurs éléments de la séquence intérieur (inner) correspondent à un élément de la séquence extérieur (outer), nous aurons plusieurs lignes dans notre "result set".</p>
                    <p>L'opérateur "GroupJoin" va, quant à lui, produire une structure de donnée hiérarchique. Il va associé pour chaque élément de la séquence extérieur les éléments de la séquence intérieure qui le concerne.</p>
                    <p>Si aucun élément de la séquence intérieur n'existe, il retournera une séquence vide.</p>
                    <p>Il s'apparente donc à une Jointure externe gauche ("Left Join").</p>
                    <p>Exemple :</p>
                    <p>Pour tous contacts, obtenir les noms, prénoms et date de rendez-vous éventuels.</p>
<pre><code>var QueryResult = Contacts.GroupJoin(RendezVous,
                                                c =&gt; c.Email,
                                                rdv =&gt; rdv.Email,
                                                (c, rdvs) =&gt; new {
                                                    Email = c.Email,
                                                    Prenom = c.Prenom,
                                                    RendezVous = rdvs
                                                });

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h4>Expression de requête :</h4>
                    <p>Dans le cadre de l'expression de requêtes, nous devons ajouter l'expression "into" à notre jointure.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.EDmail equals rdv.Email into grdvs
                             select new { Nom = c.Nom, Prenom = c.Prenom, RendezVous = grdvs };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h3>Utilisation de clés composites :</h3>
                    <p>Dans le cadre de jointures, nous sommes parfois amené à gérer les clés étrangères utilisant plusieurs champs (clé composite) et "LINQ" n'échappe à la règle. Afin de résoudre ce "problème" nous devrons utiliser les classes anonymes.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on new { c.ID, c.Email } equals new { rdv.ID, rdv.Email }
                            select new { c.Nom, c.Prenom, rdv.Date };

var QueryResult2 = Contacts.Join(RendezVous,
                                c =&gt; new { c.ID, c.Email },
                                rdv =&gt; new { rdv.ID, rdv.Email },
                                (c, rdv) =&gt; new { c.Nom, c.Prenom, rdv.Date });

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                    <h3>Multiple clause "from" :</h3>
                    <p>Nous venons de voir que les jointures en "LINQ" sont des jointures internes basées sur une égalité. Comment, dans ce cas, faire une jointure croisée ("Cross Join") ou une "Non Equi Join" ?</p>
                    <p>Elles ne sont possibles que dans le cadre des expressions de requêtes en utilisant plusieurs clauses "from".</p>
                    <h4>Exemple de "Cross Join" :</h4>
<pre><code>var QueryResult = from c in Contacts
                             from rdv in RendezVous
                             select new { c.Nom, c.Prenom, rdv.Date };

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_entities">LINQ Providers :</h2>
                    <p>Dans LINQ, le concept de "<span class="html">DataContext</span>" est souvent associé aux fournisseurs LINQ, qui sont des implémentations spécifiques de LUNQ pour différentes sources de données. Un "<span class="html">DataContext</span>" est une classe qui représente la connexion à la source de données et fournit un moyen de récupérer et de manipuler les données.</p>
                    <img src="../images/linq_providers.gif" alt="">
                    <p>Chaque fournisseur LINQ a sa propre implémentation de "<span class="html">DataContext</span>" qui est spécifique à la source de données qu'il cible. je vais expliquer cela en relation avec deux fournisseurs LINQ populaires : LINQ To SQL et LINQ To Entities.</p>
                    <h3>LINQ To SQL :</h3>
                    <p>Dans LINQ To SQL, le "<span class="em">DataContext</span>" est une classe générée automatiquement par le concepteur LINQ To SQL dans Visual Studio. Cette classe est spécifique à une base de données SQL Server particulière. Elle contient des propriétés pour accéder aux tables de la base de données sous forme de séquences d'objets, et elle gère également le suivi des modifications et l'envoi des modifications à la base de données.</p>
                    <h3>LINQ To Entities (Entity Framework) :</h3>
                    <p>Dans LINQ To Entities, qui fait partie du framework Entity Framework, le concept équivalent au "<span class="em">DataContext</span>" est généralement représenté par la classe "<span class="em">DbContext</span>". La classe "<span class="em">DbContext</span>" est responsable de la connexion à la base de données, du suivi des entités, et de la gestion des opérations CRUD (Create, Read, Update, Delete).</p>
<pre><code>// crate the ObjectContext
NorthwindEntities context = new NorthwindEntities();

// retrieve customer LAZY K
Customer cust = (from c in context.Customers
                where c.CustoùerID == "LAZY K"
                select c).Single&lt;Customer&gt;();

// Update the contact name
cust.ContactName = "Ned Plimpton";

// save the changes
try {
    context.SaveChanges();
} catch (OptimisticConcurrencyException) {
    context.Refresh(RefreshMode.ClientWIns, context.Customers);
    context.SaveChanges();
}</code></pre>
                    <p>En résumé, le "<span class="em">DataContext</span>" (ou "<span class="em">DbContext</span>" dans le cas d'Entity Framework) est une composante clé des fournisseurs LINQ. Il facilite l'accès à la source de données, la manipulation des données et la gestion des transactions, offrant ainsi une abstraction orientée objet pour interagir avec la bse de données.</p>
                    <p>On peut installer Entity Framework avac la commande suivante :</p>
<pre><code>Install-Package EntityFramework</code></pre>
                    <p>On peut configurer une chaîne de connexion dans le fichier de configration de votre application ("<span class="em">app.config</span>" ou "<span class="em">web.config</span>").</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion" connectionString="votre_chaine_de_connexion" providerName="System.Data.EntityClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>Cette chaîne de connexion doit spécifier le type de base de données que vous utilisez et les détails de connexion. Comme par exemple :</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion" 
         connectionString="Server=nom_du_serveur;Database=nom_de_la_base_de_donnees;User Id=nom_utilisateur;Password=mot_de_passe;" 
         providerName="MySql.Data.MySqlClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>POCO (Plain Old CLR Objects) fait référence à des objets simples sans dépendance à une infrastructure particulière, ce qui permet une plus grande flexibilité.</p>
                    <p>Les collections générées par "<span class="html">DbSet</span>" dans Entity Framework représentent les ensembles d'entités associées à une table dans la base données. Vous pouvez utiliser ces collections pour effectuer des oéprations CRUD sans avoir à manipuler explicitement les requêtes SQL.</p>
                    <ul>
                        <li>
                            <p>context.Customers.Remove(cust)</p>
                        </li>
                        <li>
                            <p>context.Customers.Add(cust)</p>
                        </li>
                        <li>
                            <p>cust.name = "mise à jour du nom"</p>
                        </li>
                    </ul>
                    <p>Les clefs étrangères créent des associations. Les clefs étrangères créent des propriétés de navigation.</p>
                    <h4>Opérations : Insert objets associés :</h4>
<pre><code>// create the new order
// Clef étrangère
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the order to the customer
cust.Orders.Add(ord);

// add the new Customer
context.Customers.AddObject(cust);

// save the changes
// L'objet or sera persisté.
context.SaveChanges();</code></pre>
                    <p>Dans l'autre sens :</p>
<pre><code>// create the new order
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the customer to the order
ord.Customer = cust;

// add the new Customer
context.Orders.AddObject(ord);

// save the changes
// L'objet cust sera persisté.
context.SaveChanges();</code></pre>
                    <h4>Opérations : Requêtes :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.City = "London"
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("Customer: {0}", cust.CompanyName);
}</code></pre>
                    <p><span class="em">IQueryable</span> étend <span class="em">IEnumerable</span> &#8594; avantage performance filtre effectué côté base de données.</p>
                    <h4>Lazy Loading : par défaut :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.Country == "UK" && c.City == "London"
                                   orderby c.CustomerID
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>On va chercher les Orders à ce moment-là via un query.</p>
                    <p>On a un query par tour de boucle !</p>
                    <p>Le lazy loading est une technique dans laquelle les données associées à une entité ne sont chargées depuis la base de données que lorsque vous accédez explicitement à ces données.</p>
                    <h4>Eager Loading :</h4>
<pre><code>IQueryable custs = from c in context.Customers.Include("Orders")
                              where c.Country == "UK" && c.City == "London"
                              orderby c.CustomerID
                              select c;

foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>Les orders sont tout de suite chargés en mémoire.</p>
                    <p>Pas de query à chaque tour de boucle !</p>
                    <p>L'eager loading consiste à charger immédiatement toutes les données associées à une entité au moment où l'entité principale est chargée.</p>
                    <h4>Opérations : update :</h4>
<pre><code>Employee emp = (from e in context.Employees
                          where e.EmployeeID == 9
                          select e).Single&lt;Employee&gt;();
                        
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : update sur association :</h4>
<pre><code>Order order = (from o in context.Orders
                         where o.EmployeeID == 5
                         orderby o.orderDate descending
                         select o).First&lt;Order&gt;();

Employee emp = (from e in context.Employees
                          where e.EmployeeID == 9
                          select e).Single&lt;Employee&gt;();
  
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : delete (via DbSet) :</h4>
<pre><code>// get the order details for order 10248
IQueryable&lt;Order_Detail&gt; ods = from o in context.Order_Details
                                     where o.OrderID == 10248
                                    select o;

// delete the first order detail
context.Order_Details.DelegateObject(obj.First());

// save the changes
context.SaveChanges();</code></pre>
                    <p><span class="html">DeleteObject</span> est une ancienne méthode utilisée en Entity Framework 4 et 5. En Entity Framework 6, il y a la méthode <span class="html">Remove</span>.</p>
                    <h4>delete et objets associés :</h4>
                    <p>Delete d'une commande (Order) :</p>
                    <ul>
                        <li>
                            <p>Si le détail d'une commande n'est pas détruit (order_details) &#8594; risque de violation de clé étrangère.</p>
                        </li>
                        <li>
                            <p>Solution 1 : delete manuel &#8594; suppression du détail de la commande avant de supprimer la commande.</p>
                        </li>
                        <li>
                            <p>Solution 2 : delete cascade &#8594; à configurer dans le model.</p>
                        </li>
                    </ul>
                    <h4>Optimistic lock :</h4>
                    <p>Par défaut, la stratégie "optimistic lock" est appliquée.</p>
                    <h4>Pattern Repository :</h4>
                    <p>Le modèle de conception Repository est un motif de conception (design pattern) fréquemment utilisé pour abstraire la logique d'accès aux données. Ce motif  est particulièrement utile dans le contexte des applications C# et de l'accès aux bases de données.</p>
                    <p>Il permet la séparation de la couche DATA et BUSINESS et permet d'éviter le code redondant.</p>
<pre><code>public interface IRepository&lt;T&gt;
{
    void Insert(T entity);
    void Delete(T entity);
    IQueryable&lt;T&gt; SearchFor(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    // insertOrUpdate
    bool Save(T entity, Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    IQueryable&lt;T&gt; GetAll();
    T GetById(int id);
}</code></pre>
                    <p>L'interface <span class="em">IRepository&lt;T&gt;</span> définit génrélament les opérations CRUD de base pour une entité spécifique <span class="em">T</span>. Elle fournit un contrat standard que les classes concrètes implémentent pour interagir avec une source de données (par exemple, une base de données).</p>
<pre><code>public class BaseRepository&lt;TEntity&gt; : IRepository&lt;TEntity&gt; where TEntity : class
{
    private readonly DbContext _dbContext;

    public BaseRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public void Insert(TEntity entity) {
        // ...
    }
}</code></pre>
                    <p>Avec la généricité, il y a quelques changements. Comme par exemple :</p>
<pre><code>_dbContext.CouseSet.Add(course);
&#8594;
_dbContext.Set&lt;TEntity&gt;().Add(entity);</code></pre>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>