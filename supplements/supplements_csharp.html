<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>C# et .NET - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_sdk">Installation du SDK</a></li>
                        <li><a href="#premier_projet">Création du premier projet</a></li>
                        <li><a href="#premiere_instruction">Anatomie d'une instruction C#</a></li>
                        <li><a href="#variables_constantes">Les variables et constantes</a></li>
                        <li><a href="#types_en_details">Les types en détails</a></li>
                        <li><a href="#operateurs">Les opérateurs</a></li>
                        <li><a href="#conversion_entre_types">La conversion entre types</a></li>
                        <li><a href="#if">L'instruction de test (if)</a></li>
                        <li><a href="#operateurs_booleens">Les opératuers booléens</a></li>
                        <li><a href="#tableaux_listes">Les tableaux et les listes</a></li>
                        <li><a href="#boucles">Les boucles</a></li>
                        <li><a href="#gestion_erreurs">La gestion des erreurs</a></li>
                        <li><a href="#conclusion_1">Conclusion n° 1</a></li>
                        <li><a href="#explications_technologies_.NET">Explications sur les technologies .NET</a></li>
                        <li><a href="#poo">La programmation orientée objet</a></li>
                        <li><a href="#linq">LINQ</a></li>
                        <li><a href="#linq_to_objects">LINQ To Objects</a></li>
                        <li><a href="#intro_blazor">Introduction à Blazor</a></li>
                        <li><a href="#entity_framework_blazor">Entity Framework dans Blazor</a></li>
                        <li><a href="#blazor_.NET_8">Blazor en .NET 8</a></li>
                        <li><a href="#ASP.NET_creation_api_web_c#_minimal_apis">ASP.NET : Création d'API Web avec C# et Minimal APIs</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage C# et le framework .NET :</h1>
                    <p>D'après Christophe Mommer, développeur C# ayant écrit des livres dessus : <q>Un développeur C#/.NET n'st pas expert sur toutes les technologies .NET !</q>.</p>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage C# (prononcé C Sharp) est un langage de programmation <span class="em">fortement typé</span>, <span class="em">orienté objet</span> et <span class="em">multi-plateforme</span>.</p>
                    <p><span class="em">Fortement typé</span> : chaque élément appartient à un type <span class="em">tout au
                            long de sa vie</span>. Par exemple, si on déclare une variable pour y stocker un entier, on ne
                        pourra JAMAIS y stocker une chaîne de caractères ou une date.</p>
                    <p><span class="em">Orienté objet</span> : approche du développement informatique où l'on peut créer des
                        objets pour y stocker diverses informations.</p>
                    <p><span class="em">Multi-plateforme</span> : le code C# permet de réaliser des applications sur
                        Windows; Mac, téléphone mobile, Web, ... et même votre télévision Samsung !</p>
                    <p>Le C# est <span class="em">compilé</span> par un compilateur qui transforme le code C# en code <span
                            class="em">IL</span> (Intermediate Language).</p>
                    <p>Ce dernier est ensuite interprété par une machine virtuelle (le <span class="em">CLR</span>) qui le
                        transforme en instruction machine.</p>
                    <p>Le gros avantage d'un langage compilé : vérification du code à la compilation.</p>
                    <p>Le compositeur est votre MEILLEUR ami (et il optimise votre code).</p>
                    <p>Le langage de programmation contient un ensemble d'instructions de programmation (comme les
                        conditions, boucles, etc.).</p>
                    <p>Il est fourni avec un framework, .NET, qui contint une collection d'outils prêts à l'emploi.</p>
                    <p>Il existe une version dédiée à Windows (.NET Framework 4.8) et une version multi-plateforme (.NET).
                    </p>
                </article>
                <article>
                    <h2 id="installation_sdk">Installation du SDK :</h2>
                    <p>Le framework .NET 8 s'installe sur tous les systèmes d'exploitation récents (Windows 10/11, Mac OS,
                        Linux).</p>
                    <ol>
                        <li>
                            <p>Se rendre à l'URL <a href="https://dotnet.microsoft/com/download"
                                    target="_blank">https://dotnet.microsoft/com/download</a>.</p>
                        </li>
                        <li>
                            <p>Télécharger la dernière version du SDK .NET (et non .NET Core ni .NET Framewrok).</p>
                        </li>
                        <li>
                            <p>Exécuter l'assistant d'installation.</p>
                        </li>
                        <li>
                            <p>Vérifier que l'installation s'est bien passée en tapant dans une invite de commande :</p>
                            <pre><code>dotnet --version</code></pre>
                        </li>
                    </ol>
                    <p>Le SDK (Software Development Kit) installé contient le compilateur et le runtime.</p>
                    <p>Pour coder, il est possible d'utiliser :</p>
                    <ul>
                        <li>
                            <p>Un éditeur de texte (non recommandé)</p>
                        </li>
                        <li>
                            <p>Visual Studio 2022 (Windows et Mac)</p>
                        </li>
                        <li>
                            <p>Visual Studio Code (Windows, Mac & Linux)</p>
                        </li>
                        <li>
                            <p>Rider (Windows, Mac & Linux)</p>
                        </li>
                    </ul>
                    <p>Visual Studio Code est un éditeur de code <span class="em">gratuit</span> et <span
                            class="em">multi-plateforme</span> suffisant pour notre apprentissage.</p>
                    <p>Se rendre à l'adresse <a href="https://code.visualstudio.com/"
                            target="_blank">https://code.visualstudio.com/</a> pour télécharger la dernière version sable
                        correspondant à votre système d'exploitation.</p>
                    <p>Pour avoir tout le confort de travail, il faut configurer VS Code :</p>
                    <ol>
                        <li>
                            <p>Installation de l'extension <span class="em">OmniSharp</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">Bracket Pair Colorizer</span></p>
                        </li>
                        <li>
                            <p>Installation de l'extension <span class="em">VS Sharper for C#</span></p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premier_projet">Création du premier projet :</h2>
                    <p>Un projet C# contient le code nécessaire pour créer une application.</p>
                    <p>Pour apprendre, nous allons commencer par créer une application <span class="em">Console</span>.</p>
                    <ol>
                        <li>
                            <p>Ouvrir VS Code dans un dossier défini.</p>
                        </li>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Écrire la commande :</p>
                            <pre><code>dotnet new console -n MonPremierProjet</code></pre>
                        </li>
                    </ol>
                    <p>Lorsque le code est prêt, un programme C# est exécutable.</p>
                    <p>Dans notre cas, nous avons une application console, son exécution se passe donc dans un terminal.</p>
                    <ol>
                        <li>
                            <p>Ouvrir le terminal de VS Code.</p>
                        </li>
                        <li>
                            <p>Au niveau du répertoire où se situe le fichier <span
                                    class="em">MonPremierProjet.csproj</span>, écrire la commande :</p>
                            <pre><code>dotnet run</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="premiere_instruction">Anatomie d'une instruction C# :</h2>
                    <p>L'extension d'un fichier C# est "<span class="em">.cs</span>".</p>
                    <p>La ligne est une instruction C# :</p>
                    <pre><code>Console.WriteLine("Hello, World!");</code></pre>
                    <p>Décomposons cette instruction :</p>
                    <ul>
                        <li>
                            <p><span class="em">Console</span> : objet à utiliser</p>
                        </li>
                        <li>
                            <p><span class="em">.</span> : accesseur à un élément de l'objet le précédant</p>
                        </li>
                        <li>
                            <p><span class="em">WriteLine</span> : méthode d'un objet</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : parenthèses pour passage de paramètres</p>
                        </li>
                        <li>
                            <p><span class="em">"Hello, World!"</span> : valeur du paramètre</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : point-virgule en fin d'instruction</p>
                        </li>
                    </ul>
                    <p>Le commentaire commence par <span class="em">//</span> comme dans l'exemple ci-dessous :</p>
<pre><code>// See https://aka.ms/new-console-template for more information</code></pre>
                    <p>Le commentaire permet d'écrire du texte libre à côté du code source (pour donner une indication quelconque).</p>
                    <p>Exercice : Écrire l'instruction C#, à la ligne de la première, permettant d'afficher "J'apprends le C#" :</p>
<pre><code>Console.WriteLine("J'apprends le C#");</code></pre>
                    <p>En C#, le placement des accolades pour définir le corps des fonctions (méthodes) est une une question de style de codage. Il existe deux approches principales : avec les accolades à la ligne ou sur la même ligne que la déclaration de la fonction.</p>
                    <ol>
                        <li>
                            <p>Accolades à la ligne (Allman Style) :</p>
<pre><code>public void Exemple()
{
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                        <li>
                            <p>Accolades sur la même ligne (K&R Style) :</p>
<pre><code>public void Exemple() {
    // Corps de la fonction
    Console.WriteLine("Hello, World!");
}</code></pre>
                        </li>
                    </ol>
                    <p>Les deux styles sont acceptés par le compilateur C# et sont largement une question de préférence personnelle ou de convention d'équipe. Certains développeurs préfèrent l'un sur l'autre pour des raisons de lisibilité, de style, ou même d'adhésion à des normes de codage spécifiques.</p>
                    <p>Dans la suite du cours, on utilisera la première méthode car Visual Studio 2022 l'utilise, mais il est essentiel de choisir un style cohérent au sein d'un projet ou d'une équipe pour maintenir la lisibilité et la cohérence du code.</p>
                </article>
                <article>
                    <h2 id="variables">Les variables et constantes :</h2>
                    <p>Une variable est une donnée que l'on souhaite stocker pour travailler, dont le contenu peut changer.</p>
                    <p>En C#; une variable est <span class="em">fortement typée</span>, c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer.</p>
                    <p>La syntaxe pour déclare une variable est :</p>
<pre><code>TYPE NOM + VALEUR;</code></pre>
                    <p>Quelques-uns des types les plus courants :</p>
                    <ul>
                        <li>
                            <p><span class="em">Entier</span> &#8594; déclaration avec le mot clé "int".</p>
                            <ul>
                                <li>
                                    <p>La valeur est directement écrite en chiffres.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Chaîne de caractères</span> &#8594; déclaration avec le mot clé "string".</p>
                            <ul>
                                <li>
                                    <p>La valeur est écrite entre guillemets.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">Booléen</span> &#8594; déclaration avec le mot clé "bool".</p>
                            <ul>
                                <li>
                                    <p>Peut seulement valor "true" (vrai) ou "false" (faux).</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>Le nom d'une variable ne peut pas contenir d'espace. Voici quelques exemples de déclaration de variables :</p>
<pre><code>int age = 29;
string prenom = "Driss";
bool estVivant = true;</code></pre>
                    <p>Dans VS Code, ne prêter pas attention au soulignage. Il 'agit d'un avertissement du compilateur comme quoi une variable est déclarée mais non utilisée.</p>
                    <p>Il existe une syntaxe appelée "typage implicite" permettant d'utiliser un mot clé commun (<span class="em">var</span>) pour que le compilateur devine le type en fonction de la valeur.</p>
<pre><code>var NOM = VALEUR</code></pre>
                    <p>Attention, en l'absence de valeur, le comilateur ne peut pas déduire le type, et il est donc illicite de faire uen instruction <span class="html">var NOM</span>.</p>
<pre><code>var taille = 172;
var nom = "Vandenheede";
var faux = false;</code></pre>
                    <p>La syntaxe pour affecter une variable est :</p>
<pre><code>NOM = VALEUR;</code></pre>
                    <p>Cela <span class="em">impose</span> que la variable ait été déclarée au préalable, sinon cela ne fonctionnera pas.</p>
                    <p>Ainsi, il est possible de chnager une valeur d'une variable après sa création.</p>
<pre><code>taille = 200;</code></pre>
                    <p>Une constante est une donnée que l'on souhaite stocker pour travailler, dont le contenu ne changera jamais.</p>
                    <p>En C#, une constante est <span class="em">fortement typée</span> c'est-à-dire que son type est défini à sa déclaration et ne pourra pas changer, tout comme sa valeur.</p>
                    <p>La syntaxe pour déclarer une constante est :</p>
<pre><code>const TYPE NOM = VALEUR;</code></pre>
                    <p>Attention, le mot clé "<span class="em">const</span>" est réservé au langage C# et ne peut pas être utilisé comme nom pour une variable ou une constante.</p>
                    <p>Voici quelques exemples :</p>
<pre><code>const int valeur = 42;
const string pays = "Belgique";
const bool vrai = true;</code></pre>
                    <p>Une variable peut aussi être affectée par une valeur renvoyée par une fonction.</p>
                    <p>Par exemple, la fonction <span class="html">Console.ReadLine();</span> attends la saisie de l'utilisateur (finalisée par l'appui sur entrée) ey renvoie cette valeur.</p>
                    <p>Ainsi, on peut récupérer la valeur dans une variable en définissant l'affectation de la valeur comme étant l'appel de la fonction :</p>
<pre><code>var saisie = Console.ReadLine();</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et de lui dire "Bonjour prénom".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="html">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire la valeur.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string saisie = Console.ReadLine();
Console.WriteLine("Bonjour");
Console.WriteLine(saisie);</code></pre>
                </article>
                <article>
                    <h2 id="types_en_details">Les types en détails :</h2>
                    <p>Bien que le langage se réserve des mots-clés pour les types, ceux-ci sont définis au sein du framework .NET.</p>
                    <p>Par exemple, il y a beaucoup de types différents pour représenter un chiffre, selon sa taille, le fait qu'il puisse être négatif ou non, ainsi que s'il peut avoir une virgule ou pas !</p>
                    <p>Voici une table de référence des types numériques :</p>
                    <table class="tableBalises">
                       <thead>
                        <tr>
                            <th>Type en c#</th>
                            <th>Type système</th>
                            <th>Suffixe</th>
                            <th>Taille mémoire</th>
                            <th>Plage</th>
                        </tr>
                       </thead>
                       <tbody>
                        <tr>
                            <th colspan="5">Types entiers signés</th>
                        </tr>
                        <tr>
                            <td>sbyte</td>
                            <td>System.Sbyte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>-2<sup>7</sup> à 2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td>short</td>
                            <td>System.Int16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>-2<sup>15</sup> à 2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td>int</td>
                            <td>System.Int32</td>
                            <td></td>
                            <td>32 bits</td>
                            <td>-2<sup>31</sup> à 2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td>long</td>
                            <td>System.Int64</td>
                            <td>L</td>
                            <td>64 bits</td>
                            <td>-2<sup>63</sup> à 2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types entiers non signés</th>
                        </tr>
                        <tr>
                            <td>byte</td>
                            <td>System.Byte</td>
                            <td></td>
                            <td>8 bits</td>
                            <td>0 à 2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ushort</td>
                            <td>System.UInt16</td>
                            <td></td>
                            <td>16 bits</td>
                            <td>0 à 2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td>uint</td>
                            <td>System.UInt32</td>
                            <td>U</td>
                            <td>32 bits</td>
                            <td>0 à 2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td>ulong</td>
                            <td>System.UInt64</td>
                            <td>UL</td>
                            <td>64 bits</td>
                            <td>0 à 2<sup>64</sup>-1</td>
                        </tr>
                        <tr>
                            <th colspan="5">Types réels</th>
                        </tr>
                        <tr>
                            <td>float</td>
                            <td>System.Single</td>
                            <td>F</td>
                            <td>32 bits</td>
                            <td>&#117; -10<sup>45</sup> à 10<sup>38</sup></td>
                        </tr>
                        <tr>
                            <td>double</td>
                            <td>System.Double</td>
                            <td>D</td>
                            <td>64 bits</td>
                            <td>&#117; -10<sup>324</sup> à &#117; 10<sup>308</sup></td>
                        </tr>
                        <tr>
                            <td>decimal</td>
                            <td>System.Decimal</td>
                            <td>M</td>
                            <td>128 bits</td>
                            <td>&#117; -10<sup>28</sup> à &#117; 10<sup>28</sup></td>
                        </tr>
                       </tbody>
                    </table>
                    <p>Les types entiers signés est utilisé lorsque la valeur peut être positif ou négatif.</p>
                    <p>Les types entiers non signés sont l'inverse des types entiers signés dont la valeur minimale est 0.</p>
                    <p>Les types réels est lorsque la valeur est avec une virgule.</p>
                    <p>Quelques détails supplémentaires :</p>
                    <ul>
                        <li>
                            <p>Le type <span class="html">float</span> ou <span class="html">double</span> est recommandé pour les <span class="em">calculs mathématiques</span> (hautre précision) alors que <span class="em">decimal</span> est recommandé pour les <span class="em">calculs financiers</span>.</p>
                        </li>
                        <li>
                            <p>Depuis C# 7, il est possible d'utiliser un séparateur pour les gros chiffres :</p>
<pre><code>int unMilliard = 1_000_000_000;</code></pre>
                        </li>
                        <li>
                            <p>Le suffixe n'est obligatoire que ds'il existe une ambigüité :</p>
<pre><code>var jeVeuxUnLong = 16UL // ici, par défaut, le type aurait été int</code></pre>
                        </li>
                    </ul>
                    <p>Nous avons déjà travaillé avec les chaînes de caractères :</p>
                    <p>Pour en définir une, il suffit de mettre la valeur entre guillemets :</p>
<pre><code>string prenom = "Driss";</code></pre>
                    <p>Mais qui dit "chaîne" dit "ensemble", ainsi, il existe un type pour un caractère unique.</p>
                    <p>Pour en définir un, il suffit de mettre la valeur entre apostrophes :</p>
<pre><code>char a = 'a';</code></pre>
                    <p>Attention, définir plusieurs caractères entre apostrophes, sauf exceptions ci-après, provoquera une erreur de compilation.</p>
                    <p>Certains caractères particuliers et nécessite un traitement particulier.</p>
                    <p>Le caractère ("\") est utilisé pour les définir.</p>
                    <p>Par exemple : le fait qu'une chaîne de caracyères soit entourées par des guillemets, comment est-ce que je peux avoir des guillemets dans ma chaîne ? Ou stocker le caractère apostrophe ?</p>
                    <p>Voici un tableau de références des caractères spéciaux :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Car</th>
                                <th>Signification</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>\'</td>
                                <td>Apostrophe (dans un char)</td>
<pre><code>char apostrophe = '\'';</code></pre>
                            </tr>
                            <tr>
                                <td>\"</td>
                                <td>Guillemet (dans un string)</td>
<pre><code>string jacquesADit = "Jacques a dit : \"Debout !\"";</code></pre>
                            </tr>
                            <tr>
                                <td>\\</td>
                                <td>Antislash</td>
<pre><code>string cheminWindows = "C:\\docs\\fichier.txt";</code></pre>
                            </tr>
                            <tr>
                                <td>\0</td>
                                <td>Null</td>
                            </tr>
                            <tr>
                                <td>\a</td>
                                <td>Alerte (bip sonore)</td>
                            </tr>
                            <tr>
                                <td>\b</td>
                                <td>Retour arrière</td>
                            </tr>
                            <tr>
                                <td>\f</td>
                                <td>Saut de page</td>
                            </tr>
                            <tr>
                                <td>\n</td>
                                <td>Nouvelle ligne</td>
                            </tr>
                            <tr>
                                <td>\r</td>
                                <td>Retour chariot (entrée)</td>
                            </tr>
                            <tr>
                                <td>\t</td>
                                <td>Tabulation (découplage vers la droite)</td>
                            </tr>
                            <tr>
                                <td>\v</td>
                                <td>Tabulation verticale</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>L'antislash peut aussi être utilisé pour représenter directement un caractère de la table Unicode : <a href="https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)" target="_blank">https://fr.wikipedia.org/wiki/Table_des_caractères_Unicode_(0000-0FFF)</a>.</p>
<pre><code>char copyright = '\u00A9';</code></pre>
                    <p>La manipulation des chaînes de caractères offre des facilités d'échappement grâce à un syntaxe particulière.</p>
                    <p>Le caractère @ avant les guillemets d'ouverture permet de ne pas avoir à échapper les antislashs (mais empêcje l'utilisation des caractères spéciaux) :</p>
<pre><code>string cheminWindowsSimple = @"C:\docs\fichier.txt";</code></pre>
                    <p>Dans ce cas, èle guillemet dans la chaîne doit être doublé :</p>
<pre><code>string jacquesADit2 = @"Jacques a dit : ""Assis !""";</code></pre>
                    <p>Lorsqu'on utilise deux chaînes, il est possible de "mettre l'une dans l'autre" grâce à un procédé particulier : l'interpolation.</p>
                    <p>Le caractère "1" permet d'insérer une valeur entre accolades au sein d'une chaîne (généralement une variable) :</p>
<pre><code>string prenom = "Driss";
string bonjour = $"Bonjour {prenom}";</code></pre>
                    <p>Dans ce cas, la variable bonjour contiendra "Bonjour Driss".</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser l'interpolation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>Les types vus jsuqu'à présent supportent l'utilisation d'opérateurs (comme l'addition ou la soustraction pour deux valeurs numériques).</p>
                    <p>Pour ce faire, on utilisera les caractères suivants :</p>
                    <ul>
                        <li>
                            <p>"+" pour l'addition</p>
                            <li>
                                <p>"-" pour la soustraction</p>
                            </li>
                            <li>
                                <p>"*" pour la multiplication</p>
                            </li>
                            <li>
                                <p>"/" pour la division</p>
                            </li>
                            <li>
                                <p>"%" pour le modulo (reste de la division entière)</p>
                            </li>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de manipuler les opérateurs avec les types numériques.</p>
                    <p>Pour bien commencer :</p>
                    <ul>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Créer deux variables contenant 9 et 2.</p>
                        </li>
                        <li>
                            <p>Faire la totalité des opérateurs mathématiques sur les numériques et constater les résultats !</p>
                        </li>
                    </ul>
                    <p>9 + 2 = 11 // aucun commentaire</p>
                    <p>9 - 2 = 7 // aucun commentaire</p>
                    <p>9 * 2 = 18 // aucun commentaire</p>
                    <p>9 / 2 = 4</p>
                    <ul>
                        <li>
                            <p>Nous divisons un entier par un entier, le résultat doit être entier. Nous avons ici le quotient d'une division Euclidienne. Le reste est calculé par la fonction modulo.</p>
                        </li>
                    </ul>
                    <p>9 % 2 = 1</p>
                    <ul>
                        <li>
                            <p>C'est le reste correspondant à notre division Euclidienne ci-dessus.</p>
                        </li>
                    </ul>
                    <p>Dans le cas des chaînes de caractères, un opérateur a été implémenté afin de réaliser une concaténation.</p>
                    <p>Pour ce faire, on utilisera le caractère "+" afin de concaténer deux chaînes :</p>
<pre><code>string bonjourChaine = "Bonjour " + "Driss";</code></pre>
                    <p>Cela a tout son intérêt lorsqu'on utilise des variables :</p>
<pre><code>string bonjour = "Bonjour ";
string prenom = "Driss";

string bonjourComplet = bonjour + prenom;</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables et <span class="em">utiliser la concaténation</span> pour construire la phrase finale.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
string age = Console.ReadLine();

Console.WriteLine("Bonjour " + prenom + ", vous avez " + age + " ans");</code></pre>
                    <p>Rappel : un booléen est une valeur valant vrai (true) ou faux (false).</p>
                    <p>Ainsi, pour savoir si quelque chose est vrai ou faux, il faut une comparaison. Par exemple, on peut tester l'égalité grâce à l'opérateur "==" (attention, double égal) :</p>
<pre><code>int a1 = 42;
int a2 = 43;
bool egaux = a1 == a2; // La variable "egaux" vaudra "false" ici.</code></pre>
                    <p>La différence se teste avec l'opérateur "!=" :</p>
<pre><code>bool different = a1 != a2; // La variable "different" vaudra "true" ici.</code></pre>
                    <p>On peut utiliser également des opérateurs mathématiques traditionnels :</p>
                    <ul>
                        <li>
                            <p>Supérieur à : utilisation du caractère "&gt;"</p>
                        </li>
                        <li>
                            <p>Supérieur ou égal à : utilisation du caractère "&gt;="</p>
                        </li>
                        <li>
                            <p>Inférieur à : utilisation du caractère "&lt;"</p>
                        </li>
                        <li>
                            <p>Inférieur ou égal à : utilisation du caractère "&lt;="</p>
                        </li>
                    </ul>
<pre><code>int a1 = 42;
int a2 = 43;
bool a1PlusGrand = a1 &gt; 10; // Vaudra "true"
bool a2InfOuEgal = a2 &lt;= 100; // Vaudra "true"</code></pre>
                </article>
                <article>
                    <h2 id="conversion_entre_types">La conversion entre types :</h2>
                    <p>Rappel : le langage C# est fortement type, il n'est pas possible de changer le type d'une variable déjà déclarée.</p>
                    <p>Il arrive que l'on ait besoin de convertir une variable d'un type A vers un type B, par exemple, transformer une chaîne de caractères en entier.</p>
                    <p>Il existe de nombreuses façons de créer une variable d'un aure type à partir d'une variable déjà définie.</p>
                    <p>Un des besoins les plus courants est d'obtenir une chaîne de caractères depuis un type quelconque.</p>
                    <p>Nous verrons pourquoi lorsque nous ferons le moddule sur la programmation orientée objet, mais chaque élément C# poss!de une méthode particulière : <span class="html">ToString()</span>.</p>
                    <p>Ainsi, il est possible de transformer un entier en chaîne comme ceci :</p>
<pre><code>int valeurEntiere = 42;
string entierChaine = valeurEntiere.ToString();</code></pre>
                    <p>Lorsqu'on récupère une saisie d'un utilisateur, nous obtenons une valeur de type de chaîne de caractères.</p>
                    <p>Néanmoins, pour certaines opérations (comparaison avec un autre entier, addition...), il faut convertir cette valeur vers un entier.</p>
                    <p>Il y a plusieurs façons de faire cette opération.</p>
                    <p>Une classe très pratique, <span class="html">Convert</span>, nous permet de transformer une valeur vers n'importe quel autre type, sous réserve que cela soit possible :</p>
<pre><code>string valeurChaine = "29";
int vingtNeuf = Convert.ToInt32(valeurChaine);</code></pre>
                    <p>La classe <span class="html">Convert</span> est très pratique, mais beaucoup de types exposent aussi une méthode appelée <span class="html">Parse</span>, comme par exemple :</p>
<pre><code>string saisie = Console.ReadLine();
int saisieEntier = int.Parse(saisie);</code></pre>
                    <p>Attention, au niveau de connaissance actuel, les deux alternatives peuvent être utilisées indistinctement.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.WriteLine</span> pour afficher une valeur : (note : la valeur entre parenthèses peut être une variable ou une constante).</p>
                        </li>
                        <li>
                            <p>Utiliser la méthode <span class="html">Console.ReadLine();</span> pour lire les valeurs.</p>
                        </li>
                        <li>
                            <p>Stocker le prénom et l'âge dans des variables (<span class="html">string</span> pour le prénom et <span class="html">int</span> pour l'âge) et utiliser l'interpolation pour construire la phrase attendue.</p>
                        </li>
                    </ol>
<pre><code>Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");</code></pre>
                </article>
                <article>
                    <h2 id="if">L'instruction de test (if) :</h2>
                    <p>Un booléen seul ne présente pas grand intérêt s'il n'est pas testé pour une branche de code.</p>
                    <p>À cet effet, le langage C# propose une instruction pour tester un booléen l'instruction "<span class="em">if</span>".</p>
                    <p>Cette instruction a la syntaxe suivante :</p>
<pre><code>if (booléen)  // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}</code></pre>
                    <p>Lorsqu'on teste une condition, il y a deux possibilités : vrai ou faux.</p>
                    <p>Le bloc défini après l'instruction ne sera exécuté que si la condition renvoie vrai.</p>
                    <p>On peut définir l'autre alternative grâce au mot-clé "<span class="html">else</span>".</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer si le booléen testé initialement vaut "<span class="em">false</span>".
}</code></pre>
                    <p>Il existe également le mot-clé "<span class="html">else if</span>" pour tester un autre booléen. Voici sa syntaxe :</p>
<pre><code>if (booléen) // On teste la valeur booléenne entre parenthèses.
{
    // On définit entre accolades le code à effectuer si le booléen vaut "<span class="em">true</span>".
}
else if (autreBooléen) // On teste la valeur booléenne entre parenthèses. Ça signifie "sinon si".
{
    // On définit entre accolades le code à effectuer si l'autre booléen vaut "<span class="em">true</span>".
}
else // On teste utiliser le mot-clé <span class="html">else</span> pour dire "sinon".
{
    // On définit entre accolades le code à effectuer tous les autres booléens testés initialement valent "<span class="em">false</span>".
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander le nom de l'utilisateur et son âge de lui dire "Bonjour prénom, vous avez âge ans".</p>
                    <p>Puis d'écrire si la personne est majeure ou mineure (l'âge de la majorité sera défini en constante).</p>
                    <p>Quelques indicatons :</p>
                    <ul>
                        <li>
                            <p>utiliser <span class="html">if</span> et <span class="html">else</span> afin d'afficher uniquement la phrase correspondante.</p>
                        </li>
                        <li>
                            <p>Le test entre les deux valeurs peut être fait directement entre les parenthèses du "<span class="em">if</span>".</p>
                        </li>
                    </ul>
<pre><code>const int majorite = 18;
Console.WriteLine("Veuillez saisir votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez saisir votre âge");
int age = int.Parse(Console.ReadLine());

Console.WriteLine($"Bonjour {prenom}, vous avez {age} ans");

if (age &gt;= majorite)
{
    Console.WriteLine("Vous êtes majeur");
}
else
{
    Console.WriteLine("Vous êtes mineur");
}</code></pre>
                    <p>On peut utiliser l'instruction <span class="em">switch</span> pour sélectionner l'un des nombreux blocs de code à exécuter. Voici sa syntaxe :</p>
<pre><code>switch (expression)
{
    case x:
        // bloc de code exécuté si "expression == x" est <span class="em">true</span>.
        break;
    case y:
        // bloc de code exécuté si "expression == y" est <span class="em">true</span>.
        break;
    default:
        // bloc de code exécuté par défaut s'il n'y a pas de correspondance de <span class="em">case</span>.
        break;
}</code></pre>
                </article>
                <article>
                    <h2 id="operateurs_booleens">Les opérateurs booléens :</h2>
                    <p>Un booléen peut s'inverser grâce au caractère "<span class="html">!</span>" :</p>
<pre><code>bool estFaux = !true;</code></pre>
                    <p>Bien qu'un booléen ne puisse prendre que deux valeurs (vrai ou faux), la logique répond à l'algèbre de Boole.</p>
                    <p>Ainsi, il existe trois opérateurs en algèbre booléen :</p>
                    <ul>
                        <li>
                            <p>Le<span class="em">ET</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU</span></p>
                        </li>
                        <li>
                            <p>Le <span class="em">OU EXCLUSIF</span></p>
                        </li>
                    </ul>
                    <p>Ces opérateurs prennent deux booléens pour en former un seul.</p>
                    <p>Les tales de résultats de ces opérateurs sont les suivantes :</p>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>ET</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">ET</span> est le "<span class="html">&</span>"."</p>
<pre><code>etVrai = true & true;
bool etFaux = true & false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>FALSE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU</span> est le "<span class="html">|</span>".</p>
<pre><code>bool ouVrai = false | true;
bool ouFaux = false | false;</code></pre>
                    <table class="tableBalises">
                        <tbody>
                            <tr>
                                <td>OU EXCLUSIF</td>
                                <td>TRUE</td>
                                <td>FALSE</td>
                            </tr>
                            
                            <tr>
                                <td>FALSE</td>
                                <td class="red">FALSE</td>
                                <td class="green">TRUE</td>
                            </tr>
                            <tr>
                                <td>TRUE</td>
                                <td class="green">TRUE</td>
                                <td class="red">FALSE</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En C#, le caractère pour faire un <span class="em">OU EXCLUSIF</span> est le "<span class="html">^</span>".</p>
<pre><code>bool ouExVrai = true ^ false;
bool ouExFaux = true ^ true;</code></pre>
                    <p>L'opérateur <span class="em">&</span> ou <span class="em">|</span> seul implique que chacune des valeurs sera testée.</p>
                    <p>Lorsqu'on double l'opérateur (donc <span class="em">&&</span> ou <span class="em">||</span>), l'exécution s'arrêtera dès lors qu'une valeur rend la condition fausse.</p>
                    <p>Par exemple :</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true & vrai == true)
{

}</code></pre>
                    <p>Les deux tests seront effectués.</p>
                    <p>Alors que...</p>
<pre><code>const bool vrai = true;
const bool faux = false;

if (faux == true && vrai == true)
{

}</code></pre>
                    <p>Seulement le premier sera effectué.</p>
                    <h3>Exercice :</h3>
                    <p>Cet exercice est le début de l'implémentation de votre premier projet qui sera un jeu exécutable.</p>
                    <p>Ce jeu, c'est le nombre mystère : le joueur doit deviner le nombre caché en entrant une valeur.</p>
                    <p>Il s'agit ici d'implémenter la logique initiale :</p>
                    <ul>
                        <li>
                            <p>Créer un nouveau projet dédié (appelons le <span class="em">NombreMystere</span>).</p>
                        </li>
                        <li>
                            <p>Définir le nombre mystère en tant que constante.</p>
                        </li>
                        <li>
                            <p>Demander à l'utilisateur de deviner le nombre mystère.</p>
                        </li>
                        <li>
                            <p>Vérifier la valeur avec celle effective :</p>
                            <ul>
                                <li>
                                    <p>Si c'est plus grand, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est plus petit, l'indiquer et lui dire qu'il a perdu.</p>
                                </li>
                                <li>
                                    <p>Si c'est le bon nombre , lui dire qu'il a gagné.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>BONUS : demander en préambule le prénom du joueur pour le conserver, cela nous sera utile par la suite.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
int nbSaisi = int.Parse(Console.ReadLine());

if (nbSaisi == nbMystere)
{
    Console.WriteLine("Vous avez gagné !");
}
else
{
    if (nbSaisi &gt; nbMystere)
    {
        Console.WriteLine("Le nombre mystère est plus petit");
    }
    else
    {
        Console.WriteLine("Le nombre mystère est plus grand");
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="tableaux_listes">Les tableaux et les listes :</h2>
                    <p>Une collection est un ensemble de valeurs réunies.</p>
                    <p>Il existe un grand nombre de collections C#.</p>
                    <p>La première collection qu'on va étudier est la plus simple : le tableau.</p>
                    <p>Un tableau est un ensemble défini d'avance d'éléments du même type, c'est-à-dire qu'on ne pourra pas avoir un tableau qui mélange des chaînes de caractères et des entiers.</p>
                    <p>La syntaxe pour déclarer un tableau est d'utiliser des crochets ("[" et "]") après le type :</p>
<pre><code>string[] tableauDeStrings = new string[10];</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans le tableau.</p>
                        </li>
                        <li>
                            <p><span class="em">[]</span> : doubles crochets vides pour la déclaration du type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer le tableau en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">[10]</span> : doubles crochets avec la taille pour l'affectation de la valeur.</p>
                        </li>
                    </ul>
                    <p>Comme on vient de le voir, un tableau doit être déclaré avec une taille initiale.</p>
                    <p>L'avantage de cette approche est qu'on est très précis sur la mémoire que l'on occupe.</p>
                    <p>L'inconvénient est que le tableau n'est pas facilement redimensionnable.</p>
                    <p>Pour accéder à un élément du tableau (en lecture comme en écriture), on utilisera un index, qui commence à O pour la 1<sup>ère</sup> position, que l'on placera entre les crochets après le nom de la variable :</p>
<pre><code>tableauDeStrings[0] = "toto";
string toto = tableauDeStrings[0];</code></pre>
                    <p>Il est possible de définir les valeurs initiales du tableau en utilisant une syntaxe particulière :</p>
<pre><code>TYPE[] NOM = new TYPE[x] { VALEUR1, VALEUR2, ..., VALEURX };</code></pre>
<pre><code>int[] unACinq = new int[5] { 1, 2, 3, 4, 5 };</code></pre>
                    <p>La force du tableau est sa faible empreinte mémoire, il a une faiblesse indéniable qui est la difficulté de gérer sa taille facilement.</p>
                    <p>Bien heureusement, le framework .NET nous offre une autre type de collection : la liste.</p>
                    <p>De façon sous-jacente, la liste utilise un tableau, mais propose des facilités, car la taille est gérée de façon automatique.</p>
                    <p>Pour utiliser une liste, il faut écrire le code suivant :</p>
<pre><code>List&lt;TYPE&gt; NOM = new List&lt;TYPE&gt;();</code></pre>
                    <p>La syntaxe est très particulière, car elle fait appel à deux notions que nous n'avons encore vues : la construction d'objet et les génériques.</p>
                    <p>Ces notions seront vues en détail plus tard afin de bien comprendre.</p>
                    <p>Par exemple, pour créer une liste de chaîne de caractères :</p>
<pre><code>List&lt;string&gt; chaines = new List&lt;string&gt;();</code></pre>
                    <p>Décortiquons la ligne ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">string</span> : type d'éléments dans la liste.</p>
                        </li>
                        <li>
                            <p><span class="em">&lt;&gt;</span> : utilisation des chevrons pour encadrer le type.</p>
                        </li>
                        <li>
                            <p><span class="em">new</span> : utilisation du mot-clé "<span class="html">new</span>" pour créer la liste en mémoire.</p>
                        </li>
                        <li>
                            <p><span class="em">List&lt;string&gt;</span> : reprise du type complet après le mot-clé "<span class="html">new</span>".</p>
                        </li>
                        <li>
                            <p><span class="em">()</span> : double parenthèses comme l'appel d'une fonction.</p>
                        </li>
                    </ul>
                    <p>La liste offre une fonction permettant de facilement ajouter un élément, la fonction <span class="html">Add</span>.</p>
<pre><code>chaines.Add("une valeur");</code></pre>
                    <p>La liste peut s'utiliser comme un tableau à l'aide des index (en mettant le chiffre dans les croches après le nom de la variable).</p>
<pre><code>string valeurListe = chaines[0];</code></pre>
                    <p>Attention, comme le tableau, accéder à un index invalide provoquera un plantage du programme.</p>
                </article>
                <article>
                    <h2 id="boucles">Les boucles :</h2>
                    <p>Il peut arriver qu'il est nécessaire de répéter une action un certain nombre de fois.</p>
                    <p>Par exemple, dans notre jeu, la partie s'arrête dès le premier essai.</p>
                    <p>Or, on souhaiterait peut-être donner plusieurs chances au joueur.</p>
                    <p>Pour ça, il faut utiliser une boucle. On peut créer une boucle :</p>
                    <ul>
                        <li>
                            <p>Qui s'arrête sur la base d'une condition.</p>
                        </li>
                        <li>
                            <p>Qui effectue un nombre de tours défini d'avance.</p>
                        </li>
                        <li>
                            <p>Qui parcourt toutes valeurs d'une collection.</p>
                        </li>
                    </ul>
                    <p>La boucle "for" est une boucle qui prend 3 éléments en considération :</p>
                    <ul>
                        <li>
                            <p>Un état de départ.</p>
                        </li>
                        <li>
                            <P>Une condition de sortie.</P>
                        </li>
                        <li>
                            <p>Une fonction à exécuter à chaque pas.</p>
                        </li>
                    </ul>
                    <p>Elle est généralement utilisée pour faire un nombre défini d'avance de tours.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>for (ÉTAT DE DÉPART ; CONDITION DE SORTIE ; FONCTION)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
<pre><code>for (int i = 0; i &lt; 10; i++)
{
    // Comme le "if", on mettra entre accolades le code à effectuer entre chaque tour de boucle.
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">for</span> : mot-clé "for" de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">int i = 0</span> : état de départ.</p>
                        </li>
                        <li>
                            <p><span class="em">;</span> : attention, séparation par un ";".</p>
                        </li>
                        <li>
                            <p><span class="em">i &lt; 10</span> : condition de sortie.</p>
                        </li>
                        <li>
                            <p><span class="em">i++</span> : fonction à chaque tour de boucle. Ici, c'est une post-incrémentation, c'est-à-dire que ça augmente de 1 la valeur de i.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice simple est de demander à un utilisateur de saisir 3 choses puis de les afficher sur chaque ligne.</p>
                    <p>Pour bien commencer :</p>
                    <ol>
                        <li>
                            <p>Créer une nouvelle application console dédiée (<span class="em">dotnet new console</span>).</p>
                        </li>
                        <li>
                            <p>Utiliser un tableau pour stocker les nombres.</p>
                        </li>
                        <li>
                            <p>Utiliser la boucle "<span class="html">for</span>" afin d'afficher les éléments. Indice : l'index se trouve dans la boucle et change à chaque tour.</p>
                        </li>
                    </ol>
<pre><code>string[] valeurs = new string[3];

for (int i = 0; i &lt; 3; i++)
{
    Console.WriteLine($"Veuillez saisir la valeur {i + 1}");
    valeurs[i] = Console.ReadLine();
}

for(int i = 0; i &lt; 3; i++)
{
    Console.WriteLine(valeurs[i]);
}</code></pre>
                    <p>La boucle "while" est une boucle qui considère une condition pour s'exécuter.</p>
                    <p>Tant que la conditon ne renvoie pas "false", la boucle dera des tours sans s'arrêter.</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre><code>while (condition)
{
    // Comme le "for", on mettra entre accolades le code à effecteuer entre chaque tour de boucle.
}</code></pre>
                    <p>Attention, le compilateur ne vous préviendra pas si votre boucle est infinie !</p>
<pre><code>int entier = 0;
while (entier &lt; 10)
{
    entier++;
}</code></pre>
                    <p>Décortiquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions entre accolades sera exécuté tant que la condition ne sera pas égale à "false".</p>
                        </li>
                        <li>
                            <p><span class="em">entier &lt; 10</span> : condition qui sera évaluée à chaque tour.</p>
                        </li>
                    </ul>
                    <p>Il existe également le mot clé "<span class="html">do ... while</span>" dont voici la syntaxe :</p>
<pre><code>int entier = 0;
do {
    Console.WriteLine("entier = {0}", entier);
    entier++;
} while (entier &lt; 10);</code></pre>
                    <p>Ça permet d'exécuter au moins une fois le code entre accolades avant de tester la condition.</p>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur n'a qu'une seule tentative et doit relancer l'application.</p>
                    <p>Il faut transformer le jeu pour que le joueur puisse jouer jusqu'à ce qu'il ait gagné.</p>
                    <p>&#8597; une boucle "<span class="html">while</span>" pour faire que le joueur puisse jouer tant qu'il n'a pas gagné.</p>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;

while (!gagne)
{
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");
    int nbSaisi = int.Parse(Console.ReadLine());

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            Console.WriteLine("Le nombre mystère est plus petit");
        }
        else
        {
            Console.WriteLine("Le nombre mystère est plus grand");
        }
    }
}</code></pre>
                    <p>Bien qu'il soit possible de parcourir une collection en entier grâce aux boucles "<span class="html">for</span>" et "<span class="html">while</span>", il exitste une boucle particulière dédiée à cela.</p>
                    <p>La boucle "<span class="html">foreach</span>" permet de prendre chacun des éléments d'une collection, un par un, afin d'effectuer une action.</p>
                    <p>La syntaxe est la suivante :</p>
<pre><code>foreach (TYPE NOM in COLLECTION)
{

}</code></pre>
<pre><code>foreach(int entier in unACinq)
{

}</code></pre>
                    <p>Disséquons le code ci-dessus :</p>
                    <ul>
                        <li>
                            <p>Le bloc d'instructions sera exécuté pour chaque élément de la collection parcourue.</p>
                        </li>
                        <li>
                            <p><span class="em">int</span> : type de la variable qui sera déclarée localement.</p>
                        </li>
                        <li>
                            <p><span class="em">entier</span> : nom de la variable qui sera disponible dans le bloc de la boucle.</p>
                        </li>
                        <li>
                            <p><span class="em">unACinq</span> : collection à parcourir.</p>
                        </li>
                    </ul>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur doit remonter dans l'historique du terminal afin de savoir quels chiffres il a déjà joués.</p>
                    <p>Nous allons améliorer l'interface graphique du jeu :</p>
                    <ol>
                        <li>
                            <p>En stockant dans une collection la liste des chiffres déjà joués.</p>
                        </li>
                        <li>
                            <p>En nettoyant la console grâce à <span class="html">Console.Clear()</span> entre chaque tour de jeu.</p>
                        </li>
                        <li>
                            <p>En affichant en début de tour la liste des chiffres déjà joués (utiliser la boucle "<span class="html">foreach</span>").</p>
                        </li>
                    </ol>
<pre><code>const int nbMystere = 7;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    Console.WriteLine("Veuillez entrer un nombre entre 1 et 10");

    int nbSaisi = int.Parse(Console.ReadLine());
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>      
                </article>
                <article>
                    <h2 id="gestion_erreurs">La gestion des erreurs :</h2>
                    <p>Lorsqu'un programme C# rencontre une erreur à l'exécution, l'application cesse de fonctionner si cette erreur n'est pas gérée.</p>
                    <p>Cela s'appelle une <span class="em">exception</span>.</p>
                    <p>Par exemple, le code suivant provoquera une erreur à l'exécution si l'utilisateur ne saisit pas un chiffre valide :</p>
<pre><code>string saisie = Console.ReadLine();
int saisiEntier = int.Parse(saisie);</code></pre>
                    <p>Il est heureusement possible de gérer les erreurs en utilisant un mécanisme particulier : try-catch.</p>
                    <p>Ce mécanisme est défini comme suit :</p>
<pre><code>try
{
    // Bloc contenant le code à "essayer".
}
catch
{
    // Bloc contenant le code en cas d'erreur.
}
finally
{
    // Bloc contenant le code à exécuter s'il y a une erreur attrapée ou pas. 
}</code></pre>
                    <h3>Exercice :</h3>
                    <p>Le but de cet exercice est d'améliorer notre jeu du nombre mystère.</p>
                    <p>Jusqu'à présent, le joueur peut saisir une valeur différente d'un entier et faire planter l'application.</p>
                    <p>Nous allons améliorer le comportement du jeu :</p>
                    <ul>
                        <li>
                            <p>Si l'utilisateur saisit un chiffre, continuer le déroulé classique du jeu.</p>
                        </li>
                        <li>
                            <p>Si l'utilisateur saisit une autre valeur, afficher un message sur la console lui demandant de corriger sa saisie avant de continuer.</p>
                        </li>
                    </ul>
<pre><code>const int nbMystere = 7;
const int nbMin = 1;
const int nbMax = 10;

Console.WriteLine("Bienvenue dans le jeu \"Nombre mystère\"");
Console.WriteLine("Veuillez entrer votre prénom");
string prenom = Console.ReadLine();

bool gagne = false;
List&lt;int&gt; nombresJoues  new List&lt;int&gt;();
string indication = "";

while (!gagne)
{
    Console.Clear();
    Console.WriteLine(indication);
    Console.Write("Nombres déjà joués : ");
    foreach (int nb in nombresJoues)
    {
        Console.Write($" {nb} ");
    }
    Console.WriteLine();
    int nbSaisi = 0;
    while (nbSaisi &lt; nbMin || nbSaisi &gt; nbMax)
    {
        Console.WriteLine($"Veuillez entrer un nombre entre {nbMin} et {nbMax}");
        try
        {
            nbSaisi = int.Parse(Console.ReadLine());
        }
        catch
        {
            nbSaisi = 0;
        }
    }
    
    nombresJoues.Add(nbSaisi);

    if (nbSaisi == nbMystere)
    {
        gagne = true;
        Console.WriteLine("Vous avez gagné !");
    }
    else
    {
        if (nbSaisi &gt; nbMystere)
        {
            indication  = "Le nombre mystère est plus petit";
        }
        else
        {
            indication = "Le nombre mystère est plus grand";
        }
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="conclusion">Conclusion n°1 :</h2>
                    <p>Le contenu jusqu'à présent a été dense, et avant de poursuivre, il faut vous <span class="em">assurer</span> que vous maîtrisez les points suivants :</p>
                    <ol>
                        <li>
                            <p>La différence entre une variable et une constante.</p>
                        </li>
                        <li>
                            <p>Le typage en C#.</p>
                        </li>
                        <li>
                            <p>Les opérations sur les numériques, chaînes de caractères et booléens.</p>
                        </li>
                        <li>
                            <p>Les tests avec <span class="html">if</span> et <span class="html">else</span>.</p>
                        </li>
                        <li>
                            <p>La connaissance élémentaire des collections basiques (tableau et liste).</p>
                        </li>
                        <li>
                            <p>Les boucles <span class="html">for</span>, <span class="html">while</span> et <span class="html">foreach</span>.</p>
                        </li>
                        <li>
                            <p>La gestion des erreurs avec <span class="em">try.catch</span>.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="explications_technologies_" class="NET">Explications sur les technologies .NET :</h2>
                    <p>.NET a fortement évolué ces dernières années, avec l'arrivée de nouvelles solutions et de nouveaux frameworks.</p>
                    <p>Les nouveaux arrivants, les recruteurs et même quelques habitués ont perdus leurs repères.</p>
                    <p>À l'origine, quand .NET est sorti, c'était sous la forme de .NET Framework : une solution de développement sous Windows, exclusivement.</p>
                    <p>Il y avait 3 solutions : des librairies (faire des DLL), des applications graphiques (tout d'abord WinForms, puis plus tard WPF) et du web (ASP.NET WebForms, puis ASP.NET MVC).</p>
                    <p>Il y a eu des problèmes : .NET a été ré-implémenté en open-souce sous le nom Mono, notamment pour ASP.NET. Linux est majoritaire sur les serveurs, et ASP.NET n'était pas compatible.</p>
                    <p>Avec l'arrivée de Windows 10, Microsoft investit sur un nouveau CLR &#894; CoreCLR.</p>
                    <p>Suite à cela, .NET est open-source avec la création de .NET Core 1.0.</p>
                    <p>Mais .NET Framework existe tourjous. .NET Core et .NET Framework partagent un sous-ensemble commun (en dehors du langage).</p>
                    <p>Microsoft a créé un standard, .NET Standard, qui est la définition d'un sous-ensemble du framework comme un standard, accessible aussi bien en .NET Core qu'en .NET Framework (il y a eu 9 versions, en fonction des plateformes et des versions du framework...).</p>
                    <p>Pour résumer, .NET Core est la version open-source multi-plateforme, .NET Framework est la version Windows et .NET Standard est la définition de ce qui est commun entre les différentes versions .NET.</p>
                    <p>Afin de supprimer les incohérences, Microsoft annonce un nouveau .NET, qui se base sur .NET Core, et qui doit devenir "la seule façon de faire .NET".</p>
                    <p>On commence à la version 5, car .NET Core est en 3.1 et .NET Framework en 4.8.</p>
                    <p>Avec .NET on peut faire du web (ASP.NET, Blazor), du Machine Learning (ML.NET), de l'IOT (Runtimes optimisés), des apps Windows (WinForms, WPF, WinUI), des jeux vidéos (Unity) et du mobile (Xamarin, MAUI).</p>
                    <p>Il existes différents frameworks.</p>
                    <p>ASP.NET est dorénavant disponible :</p>
                    <ol>
                        <li>
                            <p>Razor Pages, pour faire des applications "classiques" (comme PHP, mais avec C#).</p>
                        </li>
                        <li>
                            <p>MVC, pareil que ci-dessus, mais avec le pattern du même nom.</p>
                        </li>
                        <li>
                            <p>WebAPI, pour faire des APIs (existe en MVC et Minimal APIs).</p>
                        </li>
                        <li>
                            <p>Blazor, pour faire des SPA (existe en version Serveur et WebAssembly).</p>
                        </li>
                    </ol>
                    <p>Xamarin : Approche historique &#8594; C# compilé en natif.</p>
                    <p>Xamarin Forms : Surcouche graphique pour des composants unifiés.</p>
                    <p>MAUI : Réécriture de Xamarin pour standardiisation et offrir plus de destination.</p>
                    <p>Pour les applications Windows, il y a WinForms (Approche historique, toujours valide), WPF (Propulsé avec Windows Vista) et WinUI (Successeur d'UWP, exclusivement pour Win 10/11 (store)).</p>
                </article>
                <article>
                    <h2 id="poo">La programmation orientée objet :</h2>
                    <p>Pour rappel, la Programmation Orientée Objet est un moyen de structurer et d'organiser le code de manière logique.</p>
                    <p>Une classe est la description de comment est représenté un objet.</p>
                    <p>Un objet est une instance de la classe, c'est-à-dire son utilisation réelle.</p>
                    <p>Une méthode est une action qu'il est possible de réaliser sur l'objet.</p>
                    <p>L'encapsultaion des données est le fait de restreindre l'accès direct aux méthodes et données d'un objet à l'intérieur de celui-ci. Ses avantages sont :</p>
                    <ul>
                        <li>
                            <p>Contrôle d'accès aux données</p>
                        </li>
                        <li>
                            <p>Flexibilité en cas de modifications</p>
                            <li>
                                <p>Sécurité de l'intégrité des données</p>
                            </li>
                        </li>
                    </ul>
                    <p>Il y a différents niveaux d'accessibilité :</p>
                    <ul>
                        <li>
                            <p><span class="html">public</span> : Les membres sont accessibles de n'importe où dans le code, sans aucune restriction.</p>
                        </li>
                        <li>
                            <p><span class="html">private</span> : Les membres ne sont accessibles que depuis la classe où ils sont déclarés.</p>
                        </li>
                        <li>
                            <p><span class="html">protected</span> Les membres sont accessibles au sein de leur classe et par les classes dérivées.</p>
                        </li>
                        <li>
                            <p><span class="html">internal</span> : Les membres sont accessibles au sein de l'assembly (exe ou dll) où ils sont déclarés.</p>
                        </li>
                        <li>
                            <p><span class="html">protected internal</span> : Les membres sont accessibles au sein de l'assembly (exe ou dll) où ils sont déclarés et également par les classes dérivées.</p>
                        </li>
                        <li>
                            <p><span class="html">private protected</span> Les membres sont accessibles au sein de leur classe et par les classes dérivées, mais uniquement si les classes dérivées sont dans le même assembly.</p>
                        </li>
                    </ul>
                    <p>À noter qu'en l'absence du mot clé d'accessibilité, le membre est considéré comme "private" par défaut.</p>
                    <p>Les conventions C# :</p>
                    <ul>
                        <li>
                            <p>Nom des champs &#8594; _champ</p>
                        </li>
                        <li>
                            <p>Méthode &#8594; Commence par une lettre majuscule</p>
                            <ul>
                                <li>
                                    <p>Attention Main</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>C# utilise des propriétés plutôt que getter/setter.</p>
                            <ul>
                                <li>
                                    <p>Propriété en Majuscule !</p>
                                </li>
                            </ul>
<pre><code>private readonly DateTime _dateDeNaissance;
public DateTime DateDeNaissance
{
    get { return _dateDeNaissance; }
}</code></pre>
                        </li>
                        <li>
                            <p>Propriéts simples auto-implémentées :</p>
<pre><code>public DateDeNaissance { get; set; }</code></pre> 
                        </li>
                    </ul>
                    <p>Exemple :</p>
<pre><code>public class Machine
{
    #region Attributs
    private double _capacite;
    #endregion

    #region Propriétés
    public string Marque { get; set; }
    public string Modele { get; private set; }
    public string NumeroSerie { get; init; }
    public double Capacite
    {
        get { return _capacite; }
        set {
            if (value &lt; 0 || value &gt; 10)
            {
                // déclencher une exception
            }
            _capacite = value;
        }
    }
    #endregion

    #region Constructeurs
    public Machine()
    {
        // Faire quelque chose
    }

    public Machine (string marque, string modele)
    {
        Marque = marque;
        Modele = modele;
    }

    public Machine (string marque, string modele, double capacite)
    {
        Marque = marque;
        Modele = modele;
        Capacite = capacite;
    }
    #endregion

    #region méthodes
    private void VerifierEtatMachine()
    {
        // Faire quelque chose
    }

    private void Nettoyer()
    {
        // Faire quelque chose
    }

    public void Allumer()
    {
        VerifierEtatMachine();
        Nettoyer();
    }
    #endregion
}</code></pre>
                    <p>Avec l'arrivée de .NET 8, il est maintenant possible de déclarer ce qu'on appelle "<span class="em">constructeur primaire</span>" afin de simplifier les déclarations :</p>
<pre><code>public class Machine(string marque, string modele)
{
    public string Marque { get; } = marque;
    public string Modele { get; } = modele;
}</code></pre>
                    <p>On peut créer des objets de la classe Machine comme ceci :</p>
<pre><code>Machine tassimo = new Machine();
tassimo.Marque = "Tassimo";
// ou
Machine tassimo = new Machine { Marque = "Tassimo", NumeroSerie = "AB12" };
// ou encore
machine tassimo = new Machine("Tassimo", "AB12");
Machine tassimo = new Machine("Tassimo", "AB12", 3.2);</code></pre>
                    <p>Le package est une organisation physique et logique et le namespace est une organisation logique.</p>
                    <p>C# utilise un mécanisme d'annotations qui est notamment utilisé pour la sérialisation. Les annotations sont placées entre []. Par exemple : [Serializable].</p>
                    <p>Les interfaces commencent par un "I" (ex : IList, IDictionnary). <span class="em">Implements</span> et <span class="em">Extends</span> se traduisent tous les deux par le caractère "<span class="em">:</span>".</p>
                    <p>Les collections disposent d'une classe de base qui correspond au nom de l'interface sans le "I" (ex : List, Dictionnary, ...).</p>
                    <p>Lors l'héritage en Java, toutes les méthodes sont "virtual", c'est-à-dire qu'elles peuvent être redéfinies dans les classes enfants et que le type de l'objet est recherché à l'exécution.</p>
                    <p>Lors de l'héritage en C#, par défaut les méthodes ne sont pas "virtual", c'est-à-dire que le type de l'objet à l'exécution sera la classe la plus haute dans la hiérarchie.</p>
                    <p>Si on veut le même comportement qu'en Java, virtual (parent) et override (enfant).</p>
                    <p>Comme en Java, C# possède un Iterator : <span class="html">IEnumerator</span>. La proriété GetEnulmerator sur les listes, dictionnaires, ...</p>
                    <p>Pour boucler l'itérateur, il existe la méthode <span class="html">it.MoveNext()</span> (hashNext + next en Java)</p>
                    <p>Pour trouver l'objet courant, il y a la propriété <span class="html">it.Current</span>.</p>
                    <p>Prenons l'exemple de la Machine pour comprendre les notions d'héritage et d'interface :</p>
<pre><code>public interface IMachine
{
    void Allumer();
    void Eteindre();
    void Demarrer(Dosette dosette);
    void Interrompre()
    {
        // Faire quelque chose
    }
}

public abstract class Machine : IMachine
{
    public string Marque { get; init; }
    public string Modele { get; init; }
    public string Capacite { get; init; }

    public virtual void Allumer()
    {
        // Faire quelque chose
    }
    public virtual void Eteindre()
    {
        // Faire quelque chose
    }
    public abstract void Demarrer(Dosette dosette);
}

public class Tassimo : Machine
{
    public Tassimo(string marque, string modele, double capacite)
    {
        Marque = marque;
        Modele = modele;
        Capacite = capacite;
    }

    private void VerifierEtatMachine() { }
    private void VerifierCodeBarre() { }
    private void Nettoyer() { }
    public void Interrompre() { }

    public override void Allumer() { }
    public override void Eteindre() { }
    public override void Demarrer(Dosette dosette)
    {
        // Faire quelque chose
    }
}</code></pre>
                    <p>Il existe égalemnt des méthodes communes qu'il faut redéfinir dans les classes comme la méthode "<span class="em">ToString()</span>" car sans ça la ligne suivante va afficher dans la console : <span class="em">Machine : MonProjet.Machine</span> :</p>
<pre><code>Machine m = new Machine("Tassimo", "AB12", 3.2);
Console.WriteLine($"Machine : { m.ToString() }");</code></pre>
                    <p>On pourra la redéfinir comme ceci :</p>
<pre><code>public class Machine
{
    public override string ToString()
    {
        return $"{marque} {Modele} ({Capacite} litres)";
    }

    public override bool Equals(object? obj) {
        if (obj is Machine m)
        {
            return Marque == m.Marque && Modele == m.Modele && Capacite == m.Capacite;
        }
        return false;
    }

    public override int GetHashCode()
    {
        int hash = 17;
        hash = hash * 23 + (Marque?.GetHashCode() ?? 0);
        hash = hash * 23 + (Modele?.GetHashCode() ?? 0);
        hash = hash * 23 + Capacite.GetHashCode();
        return hash;
    }

    public override void Dispose()
    {
        // Faire quelque chose
    } 
}</code></pre>
                    <p>Un record se déclare comme ceci :</p>
<pre><code>public record Machine(string Marque, string Modele);</code></pre>
                    <p>On peut les appeler comme ceci :</p>
<pre><code>Machien t = new Machine("Tassimo", "AB12);
Machine t2 = new Machine("Tassimo", "AB12");
t.Equals(t2); // true

Machine t3 = t with { Modele = "AB12" };</code></pre>
                </article>
                <article>
                    <h2 id="linq">LINQ :</h2>
                    <h3>Introduction à LINQ :</h3>
                    <p>LINQ (<span class="em">Langauage Integrated Query</span>) est une innovation de la version 3.5 du .NET Framework qui permet de rapprocher le monde des objets et le monde des données.</p>
                    <p>Le Framework .NET 4.0, quant à lui, a implémenté une nouvelle couche à LINQ. Cette nouvelle couche appelée <span class="em">PLINQ</span>, pour "<span class="em">Parallel LINQ</span>", est un complément à "<span class="em">LINQ To Objects</span>" qui implémente un jeu complet de méthodes afin de combiner la simplicité et la lisibilité de la syntaxe LINQ et la puissance de la programmation parrallèle.</p>
                    <p>Dans de nombreux scénarios, <span class="em">PLINQ</span> peut ainsi augmenter considérablement la vitesse des requêtes "<span class="em">LINQ To Objects</span>", sur de gros volumes de données, en utilisant plus efficacement tous les coeurs disponibles sur l'ordinateur hôte.</p>
                    <p>Cette performance accrue apporte une puissance de calcul haute performance sur le Bureau.</p>
                    <p>Cependant, l'utilisation de <span class="em">PLINQ</span> pour des petits volumes de données est déconseillée en raison des ressources mises en place pour la gestion parallèle qui, au final, risquerait d'alourdir votre application.</p>
                    <p>Traditionnellement, lorsque nous souhaitons réaliser des requêtes sur des données, ces dernières étaient exprimées sous forme de chaînes de caractères sans possibilité de vérification à la compilation et sans prise en charge par "l'IntelliSense".</p>
                    <p>En outre, nous devions apprendre des langages complémentaires en fonction des sources de données (XPath, SQL, TSQL, PL/SQL, ...).</p>
                    <p>Avec LINQ, toute requête prendra la forme d'une construction de langage de premier ordre (C# ou VB). De plus, nous pourrons écrire ces requêtes en utilisant des mots clés du langage et des opérateurs familiers.</p>
                    <p>LINQ a été prévu pour travailler pour travailler avec différentes sources de données :</p>
                    <ul>
                        <li>
                            <p>Collections d'objets fortement typées (<span class="em">LINQ To Objects</span>)</p>
                        </li>
                        <li>
                            <p>Fichiers XML (<span class="em">LINQ To XML</span>)</p>
                        </li>
                        <li>
                            <p>Bases de données SQL Server (<span class="em">LINQ To SQL</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET (<span class="em">LINQ To DataSet</span>)</p>
                        </li>
                        <li>
                            <p>Groupes de données ADO.NET Entities Framework (<span class="html">LINQ To Entities</span>)</p>
                        </li>
                    </ul>
                    <h3>Le mot clé "var" :</h3>
                    <p>Ce mot clé est probablement le plus important qu'à apporter LINQ et, bien que nécessaire, le plus controversé aussi.</p>
                    <p>En effet, C# et VB (en mode "Strict") étant des langages "fortement typé", chaque variable doit être déclarée avec un type avant d'être instanciée. Or, le mot clé "var" permet de déclarer des variables dont le type sera implicitement donné par le compilateur lors de la compilation.</p>
                    <p class="em">Si le mot clé "var" est utilisé, la variable doit être instanciée lors de sa déclaration.</p>
<pre><code>static void Main(string[] args)
{
    int i = 5;
    var s = "Hello World !";
    var o = new object();
    
    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>Bien que l'utilisation du mot clé "var" soit permise, il n'en reste que son utilisation abusive risque de nuire à la compréhension du code. Sans oublier que cela implique que nous laisserons le compilateur choisir implicitement, pour nous, le type de la variable.</p>
                    <p>Ce qui en soit pourra poser des problèmes dans le cadre des valeurs littérales et dans le cadre du polymorphisme pour ne citer qu'eux.</p>
<pre><code>static void Main(string[] args)
{
    var i = 5;
    var s = "Hello World !";
    var o = new object();

    Console.WriteLine("{0} {1} {2}", i, s, o);
    Console.ReadLine();
}</code></pre>
                    <p>i sera de type "System.Int32".</p>
                    <p class="em">Par conséquent, lorsque nous connaissons le type à utiliser, nous devrons utiliser ce type plutôt que "var".</p>
                    <h3>Les types anonymes :</h3>
                    <p>Mais, alors pourquoi avoir ajoutée un type "fourre tout" dans un environnement "fortement typé" ?</p>
                    <p>Car LINQ étant un langage puissant, et il se peut que la requête retourne un type qui ne sera connu que lors de la compilation. Ces types sont appelés "Type anonyme".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
}</code></pre>
                    <p>On peut remarquer que, dans LINQ, la convention de nommage des propriétés d'une classe suit généralement les conventions de nommage des propriétés en C#. Selon la convention de style courante en C#, les noms des propriétés commencent par une majuscule (PascalCase).</p>
<pre><code>static void Main(string[] args)
{
    List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
    Contacts.AddRange(new Contact[] {
        new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be"},
        new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be"}
    });

    // On ne prend que le Nom et l'Email du Contatct en créant implicitement un nouveau type.
    // Ce "nouveau type" est un type anonyme.
    var InfosDeContactsChoisies = from Contact c in Contacts
                                  select new { Nom = c.Nom, Email = c.Email };
    
    foreach (var Infos in InfosDeContactsChoisies)
    {
        Console.WriteLine("{0} {1}", Infos.Name, Infos.Email);
    }

    Console.ReadLine();
}</code></pre>
                    <h3>Les expressions "LAMBDA" :</h3>
                    <p>Une expression "LAMBDA" est une fonction anonyme qui peut contenir des expressions et des instructions, cette expression pourra être utilisée pour créer des délégués (delegate) ou des types d'arborescence d'expression.</p>
                    <p>Toutes ces expressions utilisent l'opérateur LAMDBA "=&gt;" qui se lit "conduit à".</p>
<pre><code>class Program
{
   delegate int del(int i);
   
   static void Main(string[] args)
   {
    del Mydelegate = x =&gt; x * x;
    int j = Mydelegate(5);

    Console.WriteLine(j);
    Console.ReadLine();
   }
}</code></pre>
                    <p class="em">Dans l'exemple, nous lirons "x conduit à x fois x".</p>
                    <p>Le côté gauche de l'expression spécifie les paramètres en entrée (le cas échéant) et le côté droit contient le bloc d'expression ou d'instructions.</p>
                    <p>Une expression LAMBDA avec une expression sur le côté est appelée "<span class="em">lambda-expression</span>.</p>
                    <p>Les "lambda-expression" sont utilisées dans la construction d'arborescences d'expression, elle retourne le résultat de l'expression et prend la forme suivante : (Paramètres d'entrée) =&gt; expression.</p>
                    <p>Les parenthèses sont facultatives uniquement dans le cas où nous n'avons qu'un seul paramètre.</p>
                    <p>Dans le cas contraire, elles sont obligatoires :</p>
<pre><code>class Program
{
    delegate long Addition(int x, int y);

    static void Main(string[] args)
    {
        Addition MonAddition = (x, y) =&gt; (long)x + y;

        long j = MonAddition(5, 7);

        Console.WriteLine(j);
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si l'expression ne reçoit aucun paramètre, nous le signalerons par des parenthèses vides.</p>
<pre><code>class Program
{
    delegate bool del();

    static void Main(string[] args)
    {
        del Mydelegate = () =&gt; UneMethode();

        Console.WriteLine(MyDelegate());
        Console.ReadLine();
    }

    static bool UneMethode()
    {
        bool Result = true;
        // ... traitement
        return Result;
    }
}</code></pre>
                    <p class="em">Nous remarquons aussi dans cet exemple que le corps d'une expression "LAMBDA" peut se composer d'un appel de méthode.</p>
                    <p>Il existe un autre type d'expression "LAMBDA", celle qui ont à droite un bloc d'instruction.</p>
                    <p>Elles sont appelées "lambda-instruction". Une "lambda-instruction" est similaire à la "lambda-expression", sauf que les instructions sont mises entre accolades.</p>
                    <p>Bien que le corps d'une "lambda-instruction" puisse contenir une infinité d'instructions; dans la pratique ce nombre est généralement de 2 ou 3.</p>
<pre><code>class Program
{
    delegate void del(string s);

    static void Main(string[] args)
    {
        del MyDelegate = n =&gt; {
            string s = string.Format("Hello {0}!!", n);
            Console.WriteLine(s);
        };

        MyDelegate("Michael");

        Console.ReadLine();
    }
}</code></pre>
                    <p>Nous verrons plus tard que de nombreux "opérateurs de requêtes standard" comportent un paramètre d'entrée dont le type, "Func&lt;T, Result&gt;", fait partie de la famile des délégués génériques.</p>
                    <p>Nous verrons ces opérateurs de requêtes standard dans la partie "LINQ To Object".</p>
<pre><code>public delegate TResult Func&lt;TArg0, TResult&gt;(TArg0 Arg0);</code></pre>
                    <p>Décortiquons la syntaxe ci-dessus :</p>
                    <ul>
                        <li>
                            <p><span class="em">TResult</span> : Type de retour.</p>
                        </li>
                        <li>
                            <p><span class="em">TArg0</span> : Type du paramètre.</p>
                        </li>
                    </ul>
                    <p>Ces délégués génériques sont très utiles pour encapsuler des expressions définies par l'utilisateur appliquées à chaque élément dans un ensemble de données.</p>
                    <p>Nous pourrions instancier ce type de délégués comme suit :</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Func&lt;int, bool&gt; EstImpaire = x =&gt; x % 2 == 1;

        Console.WriteLine(EstImpaire(5));
        Console.WriteLine(EstImpaire(4));

        Console.ReadLine();
    }
}</code></pre>
                    <p>Lorsque nous écrivons des expressions "LAMBDA", nous n'aurons généralement pas à spécifier les types de paramètres d'entrées. En effet, le compilateur pourra déduire leur type en fonction du corps du lambda, du type de délégué sous-jacent ainsi que d'autres facteurs décrits dans la spécification du langage C#.</p>
                    <p>Ce qui signifie que nous aurons accès à leurs méthodes et leurs propriétés.</p>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        del Contains = (s1, s2) =&gt; s1.ToUpper().Contains(s2.ToUpper());

        string content = "lu";

        Console.WriteLine(Contains("Hello", content));
        Console.WriteLine(Contains("Aluminium", content));

        Console.ReadLine();
    }
}</code></pre>
                    <h3>Les méthodes d'extension :</h3>
                    <p>Lorsque LINQ est arrivé, il a apporté bon nombre de nouvelles fonctionnalités aux objets du Framework .NET. Les plus communes sont les "opérateurs de requêtes standard LINQ" qui ajoute des fonctionnalités de requête aux types "IEnumerable" et "IEnumerable&lt;&gt;".</p>
                    <p>Ces types d'objets ont donc vu leur nombre de fonctionnalités augmenté mais "Microsoft" n'a pas modifié leur type d'origine. Ils ont utilisé le principe de méthodes d'extension.</p>
                    <p>Ces dernières vont nous permettent d'ajouter des méthodes à des types existants sans créer un type dérivé ou sans devoir modifier et recompiler le type d'origine.</p>
                    <p>Nous allons les définir comme méthodes statiques mais nous appellerons en utilisant la syntaxe de méthode d'instance.</p>
                    <p>Leur paramètre spécifie les types sur lesquels la méthode fonctionne et ce paramètre sera précédé par le modificateur "this".</p>
                    <p class="em">Leurs types héritant du type sur lequel nous avons ajouter une méthode d'extension, hériteront également de la méthode d'extension.</p>
                    <p>Ajoutons la méthode "CompteMot" au type "string".</p>
<pre><code>public static class MesExtensions
{
    public static int CompteMot(this string s)
    {
        return s.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

class Program
{
    delegate bool del(string s1, string s2);

    static void Main(string[] args)
    {
        string s = "Il fait très beau aujourd'hui";

        Console.WriteLine(s.CompteMot());
        Console.ReadLine();
    }
}</code></pre>
                    <p>Si un ou plusieurs paramètres sont nécessaires nous devons simplement les mettre à la suite du premier paramète.</p>
<pre><code>public static long Addition(this int i, params int[] ints)
{
    long result = i;

    foreach (int n in ints)
    {
        result += n;
    }

    return result;
}</code></pre>
<pre><code>class Program
{
    delegate bool del(string s1, string s2);

    static void Main(String[] args)
    {
        int x = 7;

        Console.WriteLine(x.Addition(8, 5, 63, 9, 4));
        Console.ReadLine();
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_objects">LINQ To Objects :</h2>
                    <h3>Introduction à LINQ To Objects :</h3>
                    <p><span class="em">LINQ To Objects</span> fait référence à l'utilisation directe de requêtes LINQ, avec n'importe quelle collection "IEnumerable" et "IEnumerable&lt;T&gt;" telles que "List&lt;T&gt;", "Array" ou "Dictionary&lt;Tkey, Tvalue&gt;" définies par l'utilisateur ou retournées par une API du Framework .NET.</p>
                    <p>Auparavant, nous devions écrire des boucles complexes pour spécifier comment récupérer des données d'une collection. Maintenant grâce à LINQ, nous pourrons écrire du code déclaratif qui décrira exactement ce que nous voudrons.</p>
                    <p>Ces requêtes offrent trois principaux avantages par rapport aux boucles :</p>
                    <ul>
                        <li>
                            <p>Elles sont plus concises et lisibles.</p>
                        </li>
                        <li>
                            <p>Elles fournissent des fonctions puissantes de filtrage, de classement et de regroupement avec un minimum de code.</p>
                        </li>
                        <li>
                            <p>Elles peuvent être appliquées à d'autres sources de données avec peu ou pas de changement.</p>
                        </li>
                    </ul>
                    <p>En gros, plus l'opération sur les données à d'autres sources de données avec peu ou pas de changement.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom, c.Nom
                                                    select c;</code></pre>
                    <h3>LINQ &#8594; Query ou pas ! :</h3>
                    <p><span class="em">LINQ</span> étant l'abréviation de "<span class="em">Language Integrated Query</span>", nous pourrions penser qu'il se limite à l'interrogation de données. Mais en réalité, son utilisation peut aller bien au-delà.</p>
<pre><code>string[] ValuesAsStrings = { "110", "987", "205", "341" };
int[] ints = ValuesAsStrings.Select(s =&gt; Int32.Parse(s)).ToArray();

foreach (int i in ints)
{
    Console.WriteLine(i);
}

Console.ReadLine();</code></pre>
                    <p class="em">La conversion de ce tableau de "string" en "int" pourrait être plus simple ?</p>
                    <h3>IEnumerable&lt;T&gt; et séquence :</h3>
                    <p>Cette interface a été implémentée par les tableaux et les classes de collections génériques de C# 2.0. Elle permet, de par son fonctionnement, d'énumérer les éléments d'une collection.</p>
                    <p>Une séquence est un terme logique d'une collection implémentant l'interface "IEnumerable&lt;T&gt;". En d'autres termes, si nous avions une variable de type "IEnumerable&lt;string&gt;", nous pourrons dire que nous avons une séquence de "string".</p>
                    <p>Nous allons voir, par la suite que la plupart des "Opérateurs de requête standard" sont prototypées de façon à retourner une séquence (IEnumerable&lt;T&gt;).</p>
                    <h3>Opérateurs de requête standard :</h3>
                    <p>Les "opérateurs de requête standard" sont les méthodes qui composent le modèle LINQ.</p>
                    <p>Ka plupart de ses méthodes fonctionnent sur des séquences et fournissent des fonctions de requête, notamment le filtrage (Where), la projection (Select), l'agrégation (Sum), le tri (Orderby), etc.</p>
                    <p>Elles sont définies, dans la classe "Enumerable", comme méthodes d'extension à l'interface "IEnumerable", cela implique qu'elles peuvent être appelées sur n'importe quelle collection générique comme méthode d'instance.</p>
                    <p>Ces opérateurs sont regroupés par fonctionnalité :</p>
                    <ul>
                        <li>
                            <p>Agrégation</p>
                        </li>
                        <li>
                            <p>Concaténation</p>
                        </li>
                        <li>
                            <p>Conversion</p>
                        </li>
                        <li>
                            <p>Égalité</p>
                        </li>
                        <li>
                            <p>Élément</p>
                        </li>
                        <li>
                            <p>Ensemble</p>
                        </li>
                        <li>
                            <p>Filtrage</p>
                        </li>
                        <li>
                            <p>Génération</p>
                        </li>
                        <li>
                            <p>Jointure</p>
                        </li>
                        <li>
                            <p>Partitionnement</p>
                        </li>
                        <li>
                            <p>Projection</p>
                        </li>
                        <li>
                            <p>Quantificateur</p>
                        </li>
                        <li>
                            <p>Regroupement</p>
                        </li>
                        <li>
                            <p>Tri</p>
                        </li>
                    </ul>
                    <p class="em">En annexe, vous trouverez la liste complète de ces opérateurs (.NET 3.5) par ordre alphabérique.</p>
                    <h3>Modes d'exécutions :</h3>
                    <p>Les opérateurs de requêtes standard se divisent en 2 modes d'exécution : immédiat et différé.</p>
                    <p>L'exécution immédiate signifie que la source de données est lue et que l'opérateur est effectuée au point où la requête est déclarée dans le code. Ce mode d'exécution vise tous les opérateurs de requête standard qui retournent un résultat unique et non énumérable comme les opérateurs d'agrégation, d'élément, etc.</p>
                    <p>L'exécution différée signifie que l'opération n'est pas effectuée au point où la requête est déclarée dans le code mais qu'elle le sera uniquement que lorsque la variable de requête est énumérée (boucle foreach par exemple).</p>
                    <p>Cela signifie que les résultats de l'exécution de la requête dépendent du contenu de la source de données lorsque la requête est exécutée plutôt que lorsqu'elle est définie. Si la variable de requête est énumérée plusieurs fois, les résultats peuvent s'avérer différents chaque fois. Presque tous les opérateurs de requête standard dont le type de retour est IEnumerable&lt;T&gt; s'exécutent de manière différée.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Certains des opérateurs de requêtes standard, les plus courants, possèdent une syntaxe de mots clé du langage C# qui leur permet d'être appelés dans le cadre d'une expression de requête.</p>
                    <p>Par défaut, pour utiliser LINQ, nous devrions appeler ces opérateurs qui sont des méthodes. L'expression de requête nous offre une forme plus lisible que son équivalent fondé sur des méthodes.</p>
                    <p>Les clausses de requêtes sont traduites en appels de méthodes lors de la compilation.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from Contact c in Contacts
                                                    where c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1)
                                                    orderby c.Prenom,c.Nom
                                                    select c;</code></pre>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
                                                    .Where(c =&gt; c.Email.Substring(0, c.Email.IndexOf('@')).Length == (c.Nom.Length + c.Prenom.Length + 1))
                                                    .OrderBy(c =&gt; c.Prenom)
                                                    .ThenBy(c =&gt; c.Nom);</code></pre>
                    <p>Une expression de requête doit commencer par une clause "from" et doit se terminer par une clause "select" ou "group". Entre la première clause from et la dernière clause select ou group, elle peut contenir une ou plusieurs clauses facultatives : where, orderby, join, let et même d'autres clauses from supplémentaires.</p>
                    <p>Nous pourrons également utiliser le mot clé "into" pour que le résultat d'une clause "join" ou "group" puisse servir de source pour des clauses de requête supplémentaires dans la même expression de requête.</p>
                    <h3>Support de l'expression de requête :</h3>
                    <p>Liste des Opérateurs supportant l'expression de requête en C# :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Opérateur</th>
                                <th>Syntaxe d'expression de requête</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Cast</td>
                                <td>'from <span class="em">int</span> n in numbers' explicitement typé</td>
                            </tr>
                            <tr>
                                <td>GroupBy</td>
                                <td>'group ... by' ou 'group ... by ... into ...'</td>
                            </tr>
                            <tr>
                                <td>GroupJoin</td>
                                <td>'join ... in ... on ... equals ... into ...'</td>
                            </tr>
                            <tr>
                                <td>Join</td>
                                <td>'join ... in ... on ... equals ...'</td>
                            </tr>
                            <tr>
                                <td>OrderBy</td>
                                <td>'order by ...'</td>
                            </tr>
                            <tr>
                                <td>OrderByDescending</td>
                                <td>'orderby ... descending'</td>
                            </tr>
                            <tr>
                                <td>Select</td>
                                <td>'select'</td>
                            </tr>
                            <tr>
                                <td>SelectMany</td>
                                <td>Plusieurs clauses 'from'</td>
                            </tr>
                            <tr>
                                <td>ThenBy</td>
                                <td>'orderby ..., ...'</td>
                            </tr>
                            <tr>
                                <td>ThenByDescending</td>
                                <td>'orderby ..., ... descending'</td>
                            </tr>
                            <tr>
                                <td>Where</td>
                                <td>'where'</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Les opérateurs courants :</h3>
                    <p>Nous allons à présent faire le tour des opérateurs les plus souvent utilisés en LINQ. Les exemples qui vont suivre seront exécutés sur une liste générique de "Contact".</p>
<pre><code>public class Contact
{
    public string Nom { get; set; }
    public string Prenom { get; set; }
    public string Email { get; set; }
    public int AnneeDeNaissance { get; set; }
}

List&lt;Contact&gt; Contacts = new List&lt;Contact&gt;();
Contacts.AddRange(new Contact[] {
    new Contact() { Nom = "Person", Prenom="Michael", Email="michael.person@cognitic.be", AnneeDeNaissance = 1982 },
    new Contact() { Nom = "Morre", Prenom="Thierry", Email="thierry.morre@cognitic.be", AnneeDeNaissance = 1974 },
    new Contact() { Nom = "Dupuis", Prenom="Thierry", Email="thierry.depuis@cognitic.be", AnneeDeNaissance = 1988 },
    new Contact() { Nom = "Faulkner", Prenom="Stéphane", Email="stephane.faulkner@cognitic.be", AnneeDeNaissance = 1969 },
    new Contact() { Nom = "Selleck", Prenom="Tom", Email="tom.selleck@imdb.com", AnneeDeNaissance = 1945 },
    new Contact() { Nom = "Anderson", Prenom="Richard Dean", Email="richard.dean.anderson@imdb.com", AnneeDeNaissance = 1950 },
    new Contact() { Nom = "Bullock", Prenom="Sandra", Email="sandra.bullock@imdb.com", AnneeDeNaissance = 1964 },
    new Contact() { Nom = "Peppard", Prenom="George", Email="peppard.george@ateam.com", AnneeDeNaissance = 1928 },
    new Contact() { Nom = "Estevez", Prenom="Emilio", Email="emilio.estevez@breakfirstclub.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Moore", Prenom="Demo", Email="demi.moore@imdb.com", AnneeDeNaissance = 1962 },
    new Contact() { Nom = "Willis", Prenom="Bruce", Email="bruce.willis@diehard.com", AnneeDeNaissance = 1955 },

});</code></pre>
                    <p>Voici les opérateurs que nous allons voir :</p>
                    <ul>
                        <li>
                            <p>Opérateurs "Cast&lt;T&gt;" & "OfType&lt;T&gt;"</p>
                        </li>
                        <li>
                            <p>Opérateur "Where"</p>
                        </li>
                        <li>
                            <p>Opérateur "Select"</p>
                        </li>
                        <li>
                            <p>Opérateur "Distinct"</p>
                        </li>
                        <li>
                            <p>Opérateur "SingleOrDefault"</p>
                        </li>
                        <li>
                            <p>Opérateur "FirstOrDefault"</p>
                        </li>
                        <li>
                            <p>Opéreateurs "OrderBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "ThenBy[Descending]"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Count" & "LongCount"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Min" & "Max"</p>
                        </li>
                        <li>
                            <p>Opérateurs "Sum" & "Average"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupBy"</p>
                        </li>
                        <li>
                            <p>Opérateur "Join"</p>
                        </li>
                        <li>
                            <p>Opérateur "GroupJoin"</p>
                        </li>
                    </ul>
                    <p class="html">Dans certains cas, les oéprateurs ont des surcharges. Pour ne pas rallonger inutilement ce cours, je me contenterai des prototypes de base.</p>
                    <p class="html">Vous trouverez l'ensemble des surcharges sur le site "MSDN" ou dans la classe "Enumerable".</p>
                    <p class="em">J'ajouterai la requête sous forme d'"expression de requête", lorsque l'opérateur supportera cette syntaxe.</p>
                    <h3>Opérateurs "Cast&lt;T&gt;" & "TypeOf&lt;T&gt;" :</h3>
                    <p>La grande majorité des opérateurs de requête LINQ ne peut être utilisée que sur des collections qui implémentent l'interface "IEnumerable&lt;T&gt;"/ Or, aucune des collections présente dans l'espace de nom "System.Collections", telles que Array, ArrayList ou HashTable, n'implémentent cette interface."</p>
                    <p>Mais alors comment utiliser LINQ avec ces collections ?</p>
                    <p>En regardant de plus près la classe "Enumerable" qui implémente les méthodes d'extension de LINQ. Nous retrouvons deux méthodes qui ne sont pas des méthodes d'extension sur l'interface "IEnumerable&lt;T&gt;" mais sur "IEnumerable".</p>
                    <p>Ces deux opérateurs sont là pour transformer une collection "IEnumerable" en une séquence "IEnumerable&lt;T&gt;".</p>
                    <p>Cependant, ces opérateurs sont quelque pei différents l'un de l'autre.</p>
                    <h4>Cast&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet oéprateur va tenter de convertir tous les éléments de la collection en une séquence de type 'T'. Si celle-ci n'y parvient pas, elle lèvera une exception.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.Cast&lt;Contact&gt;();</code></pre>
                    <p>Cet opérateur supporte la syntaxe d'expresion de requête. En spécifiant explicitement le type à utiliser.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = from Contact c in MyArrayList
                                    select c;</code></pre>
                    <h4>OfType&lt;T&gt; :</h4>
<pre><code>public static IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt;(this IEnumerable source);</code></pre>
                    <p>Cet opérateur, quant à lui, va filtrer en fonction de leur capacité à être castées dans le type spécifié.</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

IEnumerable&lt;Contact&gt; Result = MyArrayList.OfType&lt;Contact&gt;();</code></pre>
                    <p>Cet opératue n'étant pas supporter par l'expression de requête, voici comment spécifier que l'on utilise "OfType&lt;T&gt;" plutôt que "Cast&lt;T&gt;".</p>
<pre><code>// Transforme List&lt;Contact&gt; (IEnumerable&lt;T&gt;) en ArrayList (IEnumerable)
ArrayList MyArrayList = new ArrayList(Contacts.ToArray());

// Attention 2 requêtes LINQ imbriquées
IEnumerable&lt;Contact&gt; Result = from c in MyArrayList.OfType&lt;Contact&gt;()
                                    select c;</code></pre>
                    <h4>Préférons "OfType&lt;T&gt;" à "Cast&lt;T&gt;" :</h4>
                    <p>Bien que ces deux opérateurs soient utilisables sur une collection héritée (System.Collection), "Cast&lt;T&gt;" nécessite que tous les éléments aient le type attendu.</p>
                    <p>Pour éviter de générer des excceptions en cas d'incompatibilité de types, préférons-lui l'opérateur "OfType&lt;T&gt;". Par son intermédiaire, seuls les objets pouvant être castés dans le type attendu seront stockés dans la séquence.</p>
                    <p>Les autres seront purement et simplement ignoré.</p>
                    <h3>Opérateur "Where" :</h3>
<pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>L'opérateur "Where" est utilisé pour filtrer une séquence.</p>
                    <p class="em">Cet opérateur utilise le "delegate" générique "Func&lt;T, bool&gt;" vu dans le chapitre précédent.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Where(c =&gt; c.AnneeDeNaissance &gt;= 1950);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    where c.AnneeDeNaissance &gt;= 1950
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", c.Nom, c.Prenom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateur "Select" :</h3>
<pre><code>public static IEnumerable&lt;TR&gt; Select&lt;T, TR&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TR&gt; selector);</code></pre>
                    <p>L'opérateur "Select" est utilisé pour retourner une séquence d'éléments sélectionnés dans la séquence d'entrée ou à partir d'une portion de la séquence d'entrée.</p>
                    <p>Dans les requêtes LINQ basées sur les appels de méthodes, l'opérateur "Select" est facultatif et sert principalement à sélectionner une portion, en termes de Propriétés, des objets en entrée et de créer de nouveaux types d'objets (types anomymes).</p>
                    <p>Dans les expressions de requête, que l'on crée un type anonyme ou non, celui-ci est obligatoire.</p>
<pre><code>// Sélectionne tous les contacts et retourne une séquence de type "Contact"
IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                         select c;</code></pre>
                    <h4>Création d'un type anonyme :</h4>
                    <p>Pour créer un type anonyme, nous devons joindre à notre select le mot clé "new".</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Nom = c.Nom, Courriel = c.Email });

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <h4>Expresion de requête :</h4>
<pre><code>var QueryResult = from c in Contacts
                             select new { Nom = c.Nom, Courriel = c.Email };

foreach (var c in QueryResult)
{
    Console.WriteLine("{0} : {1}", c.Nom, c.Courriel);
}</code></pre>
                    <p class="em">Création à la volée de propriétés.</p>
                    <h3>Opérateur "Distinct" :</h3>
<pre><code>public static IEnumerable&lt;T&gt; Distinct&lt;T&gt;§(this IEnumerable&lt;T&gt; source);</code></pre>
                    <p>L'opérateur "Ditinct" permet de supprimer les doublons dans une séquence.</p>
<pre><code>var QueryResult = Contacts.Select(c =&gt; new { Prenom = c.Prenom }).Distinct();

foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>var QueryResult = (from c in Contacts
                             select new { Prenom = c.Prenom }).Distinct();
                            
foreach (var c in QueryResult)
{
    Console.WriteLine("{0}", c.Prenom);
}</code></pre>
                    <p class="html">Le distinct se fait sur la valeur de l'ensemble des propriétés.</p>
                    <h3>Opérateur "SingleOrDefault" :</h3>
                    <p>L'opérateur "SingleOrDefault" retourne un élément unique d'une séquence de type 'T', si la valeur est introuvable, il retourne la valeur de "default(T)".</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre"))
    .SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h4>Utilisation avec une expression de requête :</h4>
<pre><code>Contact QueryResult = (from c in Contacts
                                 where c.Prenom.Equals("Thierry") && c.Nom.Equals("Morre")
                                 select c).SingleOrDefault();

Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <p>Cependant, si la requête retourne plus d'un élément, l'opérateur "SingleOrDefault" lèvera une exception.</p>
                    <p class="em">Dans ce cas de figure et afin d'éviter l'erreur, il est conseillé d'utiliser "FirstOrDefault".</p>
                    <h3>Opérateur "FirstOrDefault" :</h3>
<pre><code>public static TSource FirstOrDefault&lt;TSource&gt;(this Ienumerable&lt;TSource&gt; source);</code></pre>
                    <p>L'opérateur "FirstOrDefault" retourne le premier élément d'une séquence de type 'T' ou la valeur de "default(T)" dans le cas ou aucune valeur ne serait trouvée.</p>
<pre><code>Contact QueryResult = Contacts
    .Where(c =&gt; c.Prenom.Equals("Thierry"))
    .FirstOrDefault();

if (QueryResult != null)
    Console.WriteLine("{0} {1}", QueryResult.Nom, QueryResult.Prenom);</code></pre>
                    <h3>Opérateurs "OrderBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; OrderBy&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; OrderByDescending&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "OrderBy" trie par ordre croissant les éléments d'une séquence sur base d'une clé (propriété). Pour un ordre décroissant, nous devrions utiliser "OrderByDescending". Si nous sous souhaitons trier sur base de plusieurs clés, ces opérateurs doivent être les premiers à être utiliser.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.OrderBy(c =&gt; c.AnneeDeNaissance);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;T&gt; QueryResult = from c in Contacts
                                              orderby c.AnneeDeNaissance
                                              select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "ThenBy[Descending]" :</h3>
<pre><code>public static IOrderedEnumerable&lt;T&gt; ThenBy&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);
public static IOrderedEnumerable&lt;T&gt; ThenByDescending&lt;T, TKey&gt;(this IOrderedEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; keySelector);</code></pre>
                    <p>Les opérateurs "ThenBy" (Croissant) et "ThenByDescending" (Décroissant) permet de trier une séquence sur plusieurs clés (propriétés). Nous pouvons avoir autant de clé "ThenBy" ou "ThenByDescending" que nous voulons. Cependant, ceux-ci ne sont utilisables que si un des opérateurs "OrderBy" ou "OrderByDescending' a été déclaré en premier lieu.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts
    .OrderBy(c =&gt; c.AnneeDeNaissance)
    .ThenByDescending(c =&gt; c.Nom);

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    orderby c.AnneeDeNaissance, c.Nom descending
                                                    select c;

foreach (Contact c in QueryResult)
{
    Console.WriteLine("{0} {1}", c.Nom, c.AnneeDeNaissance);
}</code></pre>
                    <h3>Opérateurs "Count" & "LongCount" :</h3>
<pre><code>public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static int Count&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source);
public static long LongCount&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</code></pre>
                    <p>Ces deux opérateurs comptent le nombre d'éléments dans une collection. Leur différence se situe dans leur type de retour. Ceux-ci peuvent être accompagné d'une expression booléenne qui va permettre de filtrer le nombre d'éléments à compter.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne le nombre de l'ensemble des éléments
Console.WriteLine(string.Format("Nombre total : {0}", ints.Count()));
// retourne le nombre des éléments pairs
Console.WriteLine(string.Format("Nombre d'éléments pairs : {0}", ints.Count(i =&gt; i % 2 == 0)));</code></pre>
                    <h3>Opérateurs "Min" & "Max" :</h3>
                    <p>Comme l'indique leurs noms, les opérateurs "Min" et "Max" retournent respectivement la valeur minimale et maximale d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// retourne la plus petite valeur
Console.WriteLine(string.Format("Minimum : {0}", ints.Min()));
// Retourne la plus grande valeur
Console.WriteLine(string.Format("Maximum : {0}", ints.Max()));
// Retourne l'année de naissance du contact le plus vieux
int AnneeDeNaissance = Contacts.Min(c =&gt; c.AnneeDeNaissance);
Console.WriteLine("Le contatct le plus vieux est né en {0}", AnneeDeNaissance);</code></pre>
                    <p class="html">Voir les différentes surcharges dans la classe "Enumerable".</p>
                    <h3>Opérateurs "Sum" & "Average" :</h3>
                    <p>Les opérateurs "Sum" et "Average" retournent respectivement la somme et la moyenne d'une collection.</p>
<pre><code>int[] ints = new int[] { 5, 4, 7, 52, 36, 59, 24, 1 };
// Retourne la somme
Console.WriteLine(string.Format("Somme : {0}", ints.Sum()));
// Retourne la moyenne
Console.WriteLine(string.Format("Moyenne : {0}", ints.Average(i =&gt; (float)i)));
// Retourne l'âge moyen des contacts
Console.WriteLine("L'âge moyen de nos contacts est de {0} ans", DateTime.Now.Year - (int)Contacts.Average(c =&gt; c.AnneeDeNaissance));</code></pre>
                    <h3>Opérateur "GroupBy" :</h3>
<pre><code>public static IEnumerable&lt,IGrouping&lt;TKey, TSource&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector);</code></pre>
                    <p>L'opérateur "GroupBy" est un peu différent des autres, par défaut celui-ci travaille avec l'interface "IGrouping&lt;TKey, TElement&gt;" qui hérite de "IEnumerable&lt;T&gt;" et intégrant une propriété "Key".</p>
<pre><code>public interface IGrouping&lt;out TKey, out TElement&gt; : IEnumerable&lt;TElement&gt;,, IEnumerable
{
    TKey Key { get; }
}</code></pre>
                    <p>Ce qui donne ceci :</p>
<pre><code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = Contacts
    .GroupBy(c =&gt; c.Email.Substring(c.Email.IndexOf('@') + 1));

foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</code></pre>
                    <p class="html">Il existe plusieurs surcharges, ici c'est la plus utilisée qui est vue.</p>
                    <p>De plus, dans le cadre de l'expression régulière, "GroupBy" ne peut être utilisé avec l'opérateur "Select" excepté dans le cadre du "group ... by ... into ...".</p>
                    <h4>Expression de requête :</h4>
<pre><code></code>IEnumerable&lt;IGrouping&lt;string, Contact&gt;&gt; QueryResult = from c in Contacts
                                                                                    group c by c.Email.Substring(c.Email.IndexOf('@') + 1);
                                                            
foreach (IGrouping&lt;string, Contact&gt; g in QueryResult)
{
    Console.WriteLine("{0} : {1}", g.Key, g.Count());
    foreach (Contact c in g)
    {
        Console.WriteLine("{0}", c.Email);
    }
    Console.WriteLine();
}</pre>
                    <p class="em">Notons l'absence de l'opérateur "Select" dans la requête.</p>
                    <p>Dans ce cas, comment utiliser l'opérateur "GroupBy" avec les types anonymes ?</p>
<pre><code>var QueryResult = Contacts
    .Select(c =&gt; new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
    .GroupBy(c =&gt; c.Email.Substring(c.Email.indexOf('@') + 1));

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">En utilisant l'opérateur "Select" avant le "GroupBy"...</p>
                    <h4>Expression de requête :</h4>
<pre><code>var QueryResult = from c2 in (from c in Contacts
                                        select new { Email = c.Email, FullName = string.Format("{0} {1}", c.Nom, c.Prenom) })
                             group c2 by c2.Email.Substring(c2.Email.indexOf('@') + 1);

foreach (var group in QueryResult)
{
    Console.WriteLine("{0} : {1}", group.Key, group.Count());
    foreach (var element in QueryResult)
    {
        Console.WriteLine("{0}", element.FullName);
    }
    Console.ReadLine();
}</code></pre>
                    <p class="em">... qui se traduira par une sous-requête dans l'expression de requête.</p>
                    <h3>Opérateur "Join" :</h3>
                    <p>L'opérateur "Join" est utile pour associer des séquences différentes sur base de valeurs pouvant être comparée pour définir une égalité.</p>
                    <p>La jointure est une opération importante dans les requêtes qui ciblent les sources de données dont les relations ne peuvent pas être suivies directement. Dans la programmation orientée objet, cela pourrait signifier <span class="em">une corrélation entre objets qui n'est pas modélisée</span>.</p>
                    <p class="html">Cette corrélation est fortement utilisée en "LINQ To SQL" & "LINQ To Entities".</p>
                    <p>Quand on parle de jointures, il y en a trois qui reviennent régulièrement :</p>
                    <img src="../images/join_linq.png" alt="">
                    <p>Croisée (Cross Join), Interne (Inner Join), Externe (Outer Join - Left, Right & full). Celles-ci peuvent peuvent être basées sur une équalité "Equi Join" et ou non "Non Equi Join".</p>
                    <p>L'opérateur "Join" en LINQ ne reprend qu'une seule forme de jointure ("Inner Join" basée sur une égalité). Cependant, nous allons voir comment réaliser les autres jointures en utilisant LINQ.</p>
                    <p>Pour les "Cross Join" ou les "Non Equi Join", nous ne pourrons pas utiliser l'opérateur "Join". Cependant, nous pourrons contourner le problème par l'utilisation de plusieurs clauses "from" et l'utilisation de clauses "where".</p>
                    <p>Afin de comprendre les jointures en LINQ, nous allons ajouter une nouvelle classe "RDV" et de nouvelles données (Liste "RendezVous") à notre environnement.</p>
<pre><code>public class RDV
{
    public string Email { get; set; }
    public DateTime Date { get; set; }
}</code></pre>
<pre><code>List&lt;RDV&gt; RendezVous = new List&lt;RDV&gt;();
RendezVous.AddRange(new RDV[] {
    new RDV() { Email = "stephane.faulkner@cognitic.be", Date = new DateTime(2012, 5, 12) },
    new RDV() { Email = "peppard.george@ateam.com", Date = new DateTime(2011, 8, 14) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 19) },
    new RDV() { Email = "bruce.willis@diehard.com", Date = new DateTime(2012, 6, 20) },
    new RDV() { Email = "michael.person@cognitic.be", Date = new DateTime(2012, 4, 19) },
});</code></pre>
<pre><code>public static IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; resultSelector);</code></pre>
                    <h4>Inner Join :</h4>
                    <p>Obtenir l'email, le nom, le prénom du contact et la date de tous les rendez-vous.</p>
<pre><code>var QueryResult = Contacts.Join(RendezVous,
                                           c =&gt; c.Email,
                                           rdv =&gt; rdv.Email,
                                           (c, rdv) =&gt; new {
                                            Email = c.Email,
                                            Nom = c.Nom,
                                            Prenom = c.Prenom,
                                            DateRDV = rdv.Date});

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <h5>Expression de requête :</h5>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.Email equals rdv.Email
                             select new {
                                Email = c.Email,
                                Prenom = c.Prenom,
                                DateRDV = rdv.Date
                             };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} : {2}", jointure.Nom, jointure.Prenom, jointure.DateRDV);
}</code></pre>
                    <p>L'utilisation des types anonymes n'est pas obligatoire dans le cadre des jointures, son emploi résulte en effet de ce que nous allons sélectionner.</p>
                    <p>Exemple : Obtenir les contacts ayant pris rendez-vous.</p>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = Contacts.Join(RendezVous,
                                                                 c =&gt; c.Email,
                                                                 rdv =&gt; rdv.Email,
                                                                 (c, rdv) =&gt; c);</code></pre>
                    <h4>Expression de requête :</h4>
<pre><code>IEnumerable&lt;Contact&gt; QueryResult = from c in Contacts
                                                    join rdv in RendezVous on c.Email equals rdv.Email
                                                    select c;</code></pre>
                    <p class="em">Nous obtenons bien une séquence de Contacts.</p>
                    <h3>Opérateur "GroupJoin" :</h3>
<pre><code>public static IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(this IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector);</code></pre>
                    <p>L'opérateur "GroupJoin" travaille de manière comparable à l'opérateur "Join, à ceci près que l'opérateur "Join" ne passe qu'un seul élémént de la séquence interne à la fonction "resultSelector".</p>
                    <p>Cela signifie que si plusieurs éléments de la séquence intérieur (inner) correspondent à un élément de la séquence extérieur (outer), nous aurons plusieurs lignes dans notre "result set".</p>
                    <p>L'opérateur "GroupJoin" va, quant à lui, produire une structure de donnée hiérarchique. Il va associé pour chaque élément de la séquence extérieur les éléments de la séquence intérieure qui le concerne.</p>
                    <p>Si aucun élément de la séquence intérieur n'existe, il retournera une séquence vide.</p>
                    <p>Il s'apparente donc à une Jointure externe gauche ("Left Join").</p>
                    <p>Exemple :</p>
                    <p>Pour tous contacts, obtenir les noms, prénoms et date de rendez-vous éventuels.</p>
<pre><code>var QueryResult = Contacts.GroupJoin(RendezVous,
                                                c =&gt; c.Email,
                                                rdv =&gt; rdv.Email,
                                                (c, rdvs) =&gt; new {
                                                    Email = c.Email,
                                                    Prenom = c.Prenom,
                                                    RendezVous = rdvs
                                                });

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h4>Expression de requête :</h4>
                    <p>Dans le cadre de l'expression de requêtes, nous devons ajouter l'expression "into" à notre jointure.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on c.EDmail equals rdv.Email into grdvs
                             select new { Nom = c.Nom, Prenom = c.Prenom, RendezVous = grdvs };

foreach (var jointure in QueryResult)
{
    Console.WriteLine("{0} {1} :", jointure.Nom, jointure.Prenom);
    if (jointure.RendezVous.Cont() &gt; 0)
    {
        foreach (RDV rdv in jointure.RendezVous)
        {
            Console.WriteLine("{0}", rdv.Date);
        }
    }
    else
    {
        Console.WriteLine("Aucun");
    }
    Console.WriteLine();
}</code></pre>
                    <h3>Utilisation de clés composites :</h3>
                    <p>Dans le cadre de jointures, nous sommes parfois amené à gérer les clés étrangères utilisant plusieurs champs (clé composite) et "LINQ" n'échappe à la règle. Afin de résoudre ce "problème" nous devrons utiliser les classes anonymes.</p>
<pre><code>var QueryResult = from c in Contacts
                             join rdv in RendezVous on new { c.ID, c.Email } equals new { rdv.ID, rdv.Email }
                            select new { c.Nom, c.Prenom, rdv.Date };

var QueryResult2 = Contacts.Join(RendezVous,
                                c =&gt; new { c.ID, c.Email },
                                rdv =&gt; new { rdv.ID, rdv.Email },
                                (c, rdv) =&gt; new { c.Nom, c.Prenom, rdv.Date });

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                    <h3>Multiple clause "from" :</h3>
                    <p>Nous venons de voir que les jointures en "LINQ" sont des jointures internes basées sur une égalité. Comment, dans ce cas, faire une jointure croisée ("Cross Join") ou une "Non Equi Join" ?</p>
                    <p>Elles ne sont possibles que dans le cadre des expressions de requêtes en utilisant plusieurs clauses "from".</p>
                    <h4>Exemple de "Cross Join" :</h4>
<pre><code>var QueryResult = from c in Contacts
                             from rdv in RendezVous
                             select new { c.Nom, c.Prenom, rdv.Date };

foreach (var r in QueryResult)
{
    Console.WriteLine("{0} - {1} - {2}", r.Nom, r.Prenom, r.Date.ToShortDateString());
}</code></pre>
                </article>
                <article>
                    <h2 id="linq_to_entities">LINQ Providers :</h2>
                    <p>Dans LINQ, le concept de "<span class="html">DataContext</span>" est souvent associé aux fournisseurs LINQ, qui sont des implémentations spécifiques de LUNQ pour différentes sources de données. Un "<span class="html">DataContext</span>" est une classe qui représente la connexion à la source de données et fournit un moyen de récupérer et de manipuler les données.</p>
                    <img src="../images/linq_providers.gif" alt="">
                    <p>Chaque fournisseur LINQ a sa propre implémentation de "<span class="html">DataContext</span>" qui est spécifique à la source de données qu'il cible. je vais expliquer cela en relation avec deux fournisseurs LINQ populaires : LINQ To SQL et LINQ To Entities.</p>
                    <h3>LINQ To SQL :</h3>
                    <p>Dans LINQ To SQL, le "<span class="em">DataContext</span>" est une classe générée automatiquement par le concepteur LINQ To SQL dans Visual Studio. Cette classe est spécifique à une base de données SQL Server particulière. Elle contient des propriétés pour accéder aux tables de la base de données sous forme de séquences d'objets, et elle gère également le suivi des modifications et l'envoi des modifications à la base de données.</p>
                    <h3>LINQ To Entities (Entity Framework) :</h3>
                    <p>Dans LINQ To Entities, qui fait partie du framework Entity Framework, le concept équivalent au "<span class="em">DataContext</span>" est généralement représenté par la classe "<span class="em">DbContext</span>". La classe "<span class="em">DbContext</span>" est responsable de la connexion à la base de données, du suivi des entités, et de la gestion des opérations CRUD (Create, Read, Update, Delete).</p>
<pre><code>// crate the ObjectContext
NorthwindEntities context = new NorthwindEntities();

// retrieve customer LAZY K
Customer cust = (from c in context.Customers
                where c.CustoùerID == "LAZY K"
                select c).Single&lt;Customer&gt;();

// Update the contact name
cust.ContactName = "Ned Plimpton";

// save the changes
try {
    context.SaveChanges();
} catch (OptimisticConcurrencyException) {
    context.Refresh(RefreshMode.ClientWIns, context.Customers);
    context.SaveChanges();
}</code></pre>
                    <p>En résumé, le "<span class="em">DataContext</span>" (ou "<span class="em">DbContext</span>" dans le cas d'Entity Framework) est une composante clé des fournisseurs LINQ. Il facilite l'accès à la source de données, la manipulation des données et la gestion des transactions, offrant ainsi une abstraction orientée objet pour interagir avec la bse de données.</p>
                    <p>On peut installer Entity Framework avac la commande suivante :</p>
<pre><code>Install-Package EntityFramework</code></pre>
                    <p>On peut configurer une chaîne de connexion dans le fichier de configration de votre application ("<span class="em">app.config</span>" ou "<span class="em">web.config</span>").</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion" connectionString="votre_chaine_de_connexion" providerName="System.Data.EntityClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>Cette chaîne de connexion doit spécifier le type de base de données que vous utilisez et les détails de connexion. Comme par exemple :</p>
<pre><code>&lt;connectionStrings&gt;
    &lt;add name="MaConnexion"  connectionString="Server=nom_du_serveur;Database=nom_de_la_base_de_donnees;User Id=nom_utilisateur;Password=mot_de_passe;" providerName="MySql.Data.MySqlClient" /&gt;
&lt;/connectionStrings&gt;</code></pre>
                    <p>POCO (Plain Old CLR Objects) fait référence à des objets simples sans dépendance à une infrastructure particulière, ce qui permet une plus grande flexibilité.</p>
                    <p>Les collections générées par "<span class="html">DbSet</span>" dans Entity Framework représentent les ensembles d'entités associées à une table dans la base données. Vous pouvez utiliser ces collections pour effectuer des oéprations CRUD sans avoir à manipuler explicitement les requêtes SQL.</p>
                    <ul>
                        <li>
                            <p>context.Customers.Remove(cust)</p>
                        </li>
                        <li>
                            <p>context.Customers.Add(cust)</p>
                        </li>
                        <li>
                            <p>cust.name = "mise à jour du nom"</p>
                        </li>
                    </ul>
                    <p>Les clefs étrangères créent des associations. Les clefs étrangères créent des propriétés de navigation.</p>
                    <h4>Opérations : Insert objets associés :</h4>
<pre><code>// create the new order
// Clef étrangère
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the order to the customer
cust.Orders.Add(ord);

// add the new Customer
context.Customers.AddObject(cust);

// save the changes
// L'objet or sera persisté.
context.SaveChanges();</code></pre>
                    <p>Dans l'autre sens :</p>
<pre><code>// create the new order
Order ord = new Order
{
    CustomerID = "LAWN",
    ...
    ShipCountry = "USA"
};

// attach the customer to the order
ord.Customer = cust;

// add the new Customer
context.Orders.AddObject(ord);

// save the changes
// L'objet cust sera persisté.
context.SaveChanges();</code></pre>
                    <h4>Opérations : Requêtes :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.City = "London"
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("Customer: {0}", cust.CompanyName);
}</code></pre>
                    <p><span class="em">IQueryable</span> étend <span class="em">IEnumerable</span> &#8594; avantage performance filtre effectué côté base de données.</p>
                    <h4>Lazy Loading : par défaut :</h4>
<pre><code>// create the ObjectContext
NorthwindEntities context = new NorthwindEntities();

IQueryable&lt;Customer&gt; custs = from c in context.Customers
                                   where c.Country == "UK" && c.City == "London"
                                   orderby c.CustomerID
                                   select c;
                                
foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>On va chercher les Orders à ce moment-là via un query.</p>
                    <p>On a un query par tour de boucle !</p>
                    <p>Le lazy loading est une technique dans laquelle les données associées à une entité ne sont chargées depuis la base de données que lorsque vous accédez explicitement à ces données.</p>
                    <h4>Eager Loading :</h4>
<pre><code>IQueryable custs = from c in context.Customers.Include("Orders")
                              where c.Country == "UK" && c.City == "London"
                              orderby c.CustomerID
                              select c;

foreach (Customer cust in custs) {
    Console.WriteLine("{0} - {1}", cust.CompanyName, cust.ContactName);
    Order firstOrder = cust.Orders.First();
    Console.WriteLine(" {0}", firstOrder.OrderID);
}</code></pre>
                    <p>Les orders sont tout de suite chargés en mémoire.</p>
                    <p>Pas de query à chaque tour de boucle !</p>
                    <p>L'eager loading consiste à charger immédiatement toutes les données associées à une entité au moment où l'entité principale est chargée.</p>
                    <h4>Opérations : update :</h4>
<pre><code>Employee emp = (from e in context.Employees
                          where e.EmployeeID == 9
                          select e).Single&lt;Employee&gt;();
                        
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : update sur association :</h4>
<pre><code>Order order = (from o in context.Orders
                         where o.EmployeeID == 5
                         orderby o.orderDate descending
                         select o).First&lt;Order&gt;();

Employee emp = (from e in context.Employees
               where e.EmployeeID == 9
               select e).Single&lt;Employee&gt;();
  
// Now we will assign the new employee to the order.
order.Employee = emp;

context.SaveChanges();</code></pre>
                    <h4>Opérations : delete (via DbSet) :</h4>
<pre><code>// get the order details for order 10248
IQueryable&lt;Order_Detail&gt; ods = from o in context.Order_Details
                                     where o.OrderID == 10248
                                    select o;

// delete the first order detail
context.Order_Details.DelegateObject(obj.First());

// save the changes
context.SaveChanges();</code></pre>
                    <p><span class="html">DeleteObject</span> est une ancienne méthode utilisée en Entity Framework 4 et 5. En Entity Framework 6, il y a la méthode <span class="html">Remove</span>.</p>
                    <h4>delete et objets associés :</h4>
                    <p>Delete d'une commande (Order) :</p>
                    <ul>
                        <li>
                            <p>Si le détail d'une commande n'est pas détruit (order_details) &#8594; risque de violation de clé étrangère.</p>
                        </li>
                        <li>
                            <p>Solution 1 : delete manuel &#8594; suppression du détail de la commande avant de supprimer la commande.</p>
                        </li>
                        <li>
                            <p>Solution 2 : delete cascade &#8594; à configurer dans le model.</p>
                        </li>
                    </ul>
                    <h4>Optimistic lock :</h4>
                    <p>Par défaut, la stratégie "optimistic lock" est appliquée.</p>
                    <h4>Pattern Repository :</h4>
                    <p>Le modèle de conception Repository est un motif de conception (design pattern) fréquemment utilisé pour abstraire la logique d'accès aux données. Ce motif  est particulièrement utile dans le contexte des applications C# et de l'accès aux bases de données.</p>
                    <p>Il permet la séparation de la couche DATA et BUSINESS et permet d'éviter le code redondant.</p>
<pre><code>public interface IRepository&lt;T&gt;
{
    void Insert(T entity);
    void Delete(T entity);
    IQueryable&lt;T&gt; SearchFor(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    // insertOrUpdate
    bool Save(T entity, Expression&lt;Func&lt;T, bool&gt;&gt; predicate);
    IQueryable&lt;T&gt; GetAll();
    T GetById(int id);
}</code></pre>
                    <p>L'interface <span class="em">IRepository&lt;T&gt;</span> définit génrélament les opérations CRUD de base pour une entité spécifique <span class="em">T</span>. Elle fournit un contrat standard que les classes concrètes implémentent pour interagir avec une source de données (par exemple, une base de données).</p>
<pre><code>public class BaseRepository&lt;TEntity&gt; : IRepository&lt;TEntity&gt; where TEntity : class
{
    private readonly DbContext _dbContext;

    public BaseRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public void Insert(TEntity entity) {
        // ...
    }
}</code></pre>
                    <p>Avec la généricité, il y a quelques changements. Comme par exemple :</p>
<pre><code>_dbContext.CouseSet.Add(course);
&#8594;
_dbContext.Set&lt;TEntity&gt;().Add(entity);</code></pre>
                </article>
                <article>
                    <h2 id="intro_blazor">Introduction à Blazor :</h2>
                    <h3>Qu'est-ce que Blazor ?</h3>
                    <p>Blazor est une technologie Microsoft basée sur ASP.NET Core permettant de réaliser des applications Web dynamique.</p>
                    <p>Il rentre en concurrence directe avec des frameworks JavaScript comme Angular, Vue ou encore React.</p>
                    <p>Il nous permet d'écrire du C# de bout en bout, même pour réagir aux événements web !</p>
                    <h3>Blazor Server VS WebAssembly :</h3>
                    <h4>Blazor Server :</h4>
                    <img src="../images/blazor_server.png" alt="">
                    <p>Le code s'exécute sur le serveur.</p>
                    <p>Les événements sont envoyés par un pont SignalR.</p>
                    <h4>Blazor Client (ou WebAssembly) :</h4>
                    <img src="../images/blazor_webassembly.png" alt="">
                    <p>Le code et un runtime .NET sont téléchargés sur le poste client.</p>
                    <p>Tout fonctionne dans le navigateur en contexte WebAssembly.</p>
                    <h4>Serveur ou Client ?</h4>
                    <p>Pas de réponse universelle !</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Server</th>
                                <th>WebAssembly</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p>Client léger</p>
                                        </li>
                                        <li>
                                            <p>Sollicitation du serveur</p>
                                        </li>
                                        <li>
                                            <p>Code sécurisé</p>
                                        </li>
                                        <li>
                                            <p>Outils 100% adaptés</p>
                                        </li>
                                        <li>
                                            <p>API totale</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <p>100% chez le client</p>
                                        </li>
                                        <li>
                                            <p>Mode déconnecté</p>
                                        </li>
                                        <li>
                                            <p>Hébergement simplifié</p>
                                        </li>
                                        <li>
                                            <p>Autre technologie d'API</p>
                                        </li>
                                        <li>
                                            <p>Beaucoup d'utilisateurs</p>
                                        </li>
                                        <li>
                                            <p>Possibilité de PWA</p>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Création d'un premier projet en Blazor :</h3>
                    <p>La plupart des développeurs C# développent avec Visual Studio 2022. Quand on clique sur "Créer un projet", on sélectionne "Application Blazor".</p>
                    <p>Après avoir entrer un nom de projet, on doit sélectionner la version de .NET (moi, j'ai mis .NET 8). On doit choisir entre "Application serveur Blazor" et "Blazor WebAssembly App".</p>
                    <p>Il faut bien décocher le "HTTPS".</p>
                    <p>On peut faire la même chose en ligne de commande. Donc, dans le dossier "MyApp", on peut lancer une invite de commandes (Powershell ou Shell) et exécuter la commande suivante :</p>
<pre><code>dotnet --version</code></pre>
                    <p>Ctte commande permet d'afficher la version du runtime et non du SDK. Ensuite, on crée le projet "Blazor Server App" sans le "HTTPS" avec la commande suivante :</p>
<pre><code>dotnet new blazorserver --no-https</code></pre>
                    <h3>Présentation des fichiers :</h3>
                    <p>Pour lancer le projet en lignes de commandes, il faut entrer cette instruction :</p>
<pre><code>dotnet run</code></pre>
                    <p><span class="em">Program.cs</span> est une application Console qui va lancer un serveur qui va répondre aux requêtes HTTP.</p>
                    <h3>Le routeur Blazor :</h3>
                    <p>Dans le fichier <span class="em">_Imports.razor</span>, on va définir toutes les instructions <span class="html">using</span> en préfixant bien par un '@'. C'est la même chose que le fichier <span class="em">_Imports.cs</span> dans ASP.NET Core.</p>
                    <p><span class="html">@page "/"</span> : ça permet de dire que ce fichier sera exécuter sur l'url "/".</p>
                    <h3>Qu'est-ce qu'un composant Blazor ?</h3>
                    <p>Le Layout se trouve dans le dossier "Shared" qui est un dossier contenant des composants visibles pour tous les autres composants.</p>
                    <h3>Les parmètres de route :</h3>
                    <p>On peut rajouter une deuxième instruction "<span class="html">@page</span>". Comme par exemple : @page "/counter/{value:int}". On doit rajouter l'annotation <span class="em">[Parameter]</span> à la propriété "<span class="em">public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }</span>.</p>
                    <p>Donc, le fichier Counter.razor devient :</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;

@code {
    private int currentCount = 0;

    [Parameter]
    public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

    private void IncrementCount()
    {
        currentCount++;
    }
}</code></pre>
                    <h3>Séparation de la vue du code :</h3>
                    <p>Certains développeurs, comme moi, préfèrent avoir deux fichiers : le comportement et la vue. On peut utiliser le concept de classes partielles. On va créér une nouvelle classe "Counter.razor.cs".</p>
                    <p>Pour que ça fonctionne correctement, dans cette nouvelle classe, il faut rajouter le mot-clé "<span class="html">partial</span>" dans le nom de la classe.</p>
                    <p>Ensuite, on doit copier tout ce qu'il y a dans le "<span class="html">@code</span>" dans la nouvelle classe.</p>
                    <p>Voici le code dans le fichier "Counter.razor" :</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;</code></pre>
                    <p>Dans le fichier "Counter.razor.cs", voici le code :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace MyApp.Pages
{

    public partial class Counter
    {
        private int currentCount = 0;

        [Parameter]
        public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

        private void IncrementCount()
        {
            currentCount++;
        }
    }
}</code></pre>
                    <p>Moi, au lieu d'avoir une classe partielle, je prèfère avoir une notion d'héritage avec une classe "CounterBase" qui hérite de "ComponentBase". Donc, le fichier "Counter.razor.cs" devient :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace MyApp.Pages
{

    public class CounterBase : ComponentBase
    {
        protected int currentCount = 0;

        [Parameter]
        public int Value { get =&gt; currentCount; set =&gt; currentCount = value; }

        protected void IncrementCount()
        {
            currentCount++;
        }
    }
}</code></pre>
                    <p>Dans le fichier "Counter.razor", on devra ajouter l'instruction "<span class="html">@inherits</span>" pour préciser que la classe partielle qui représente ce composant Blazor hérite de ma classe "CounterBase" que j'ai créée.</p>
<pre><code>@page "/counter"
@page "/counter/{value:int}"
@inherits CounterBase

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count : @currentCount&lt;/p&gt;

&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;</code></pre>
                    <h3>Premier exercice :</h3>
                    <p>On instancie tout notre jeu du nombre mystère dans la fonction <span class="html">protected override void OnInitialized() =&gt; base.OnInitialized();</span></p>
                    <p>Pour les nombres aléatoires, on utilise la classe <span class="html">Random</span>. Comme par exemple, <span class="em">var random = new Random();</span></p>
                    <p>Créons un projet "NombreMagique" sans "HTTPS". Sur le dossier "Pages", créons un nouveau composant Razor "NombreMagique".</p>
                    <p>Pas oublié de rajouter un nouveau lien dans la barre de navigation.</p>
                    <p>Dans le fichier "NombreMagique.razor.cs", voici le code :</p>
<pre><code>using Microsoft.AspNetCore.Components;
using System;
using System.Collections.generic;
using System.Linq;
using System.Threading.Tasks;

namespace NombreMagique.Pages
{

    public class NombreMagiqueBase : ComponentBase
    {
        protected const int NbLifesMax = 5;
        protected const int NbMax = 20;

        protected int value;

        protected int nbMagique;
        protected int nbRemainingLifes;
        protected bool? gameWon;

        protected override void OnInitialized()
        {
            ReinitGame();
            base.OnInitialized();
        }

        protected void ReinitGame()
        {
            var random = new Random();

            nbMagique = random.Next(NbMax);
            nbRemainingLifes = NbLifesMax;
            gameWon = null;
            value = 0;
        }

        protected void TestNumber()
        {
            if (value == nbMagique)
            {
                gameWon = true;
            }
            else
            {
                nbRemainingLifes--;
                if (nbRemainingLifes == 0)
                {
                    gameWon = false;
                }
            }
        }
    }
}</code></pre>
                    <p>Dans le fichier "NombreMagique.razor", on écrit :</p>
<pre><code>@inherits NombreMagiqueBase


@page "/nombre"

&lt;h3&gt;Nombre magique&lt;/h3&gt;
@if (gameWon.HasValue)
{
    if (gameWon.Value)
    {
        &lt;h2&gt;Gagn&eacute;!&lt;/h2&gt;
    }
    else
    {
        &lt;h2&gt;Perdu&lt;/h2&gt;
    }
    &lt;button class="btn btn-primary" onclick="() =&gt; ReinitGame()"&gt;Rejouer&lt;/button&gt;
}
else {
    &lt;div&gt;
        &lt;h4&gt;Devinez le nombre compris entre 0 et @NbMax&lt;/h4&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type="number" @bind="value"&gt;
        &lt;button class="btn btn-primary" @onclick="() =&gt; TestNumber()"&gt;Tester&lt;/button&gt;
    &lt;/div&gt;
    &lt;div&gt;
        @for (int i = 0; i &lt; nbRemainingLifes; i++)
        {
            &lt;span&gt;&amp;hearts;&amp;nbsp;&lt;/span&gt;
        }
    &lt;/div&gt;
}</code></pre>
                    <p>Dans le dossier "Properties", il faut supprimer le "profiles" de "IISExpress" du fichier "lauchSettings.json", ainsi que le "listSettings".</p>
                    <p>Dans Blazor, "<span class="html">@bind</span>" et "<span class="html">@bind-Value</span>" sont deux façons d'effectuer la liaison de données bidirectionnelle. Cependant, il existe quelques différences subtiles entre les deux.</p>
                    <ol>
                        <li>
                            <p>@bind :</p>
                            <ul>
                                <li>
                                    <p>"<span class="em">@bind</span>" est une syntaxe concise qui combine la liaison en lecture seule ("<span class="em">@bind="propriete"</span>") et la liaison en écriture ("<span class="em">@oninput="e =&gt; propriete = e.Value")</span>).</p>
                                </li>
                                <li>
                                    <p>Il est souvent utilisé dans des éléments d'entrée de formulaire tels que "<span class="em">&lt;input&gt;</span>", "<span class="em">&lt;select&gt;</span>" et "<span class="em">&lt;textarea&gt;</span>".</p>
                                </li>
                                <li>
                                    <p>La syntaxe "<span class="em">@bind</span> se charge à la fois de la mise à jour de la valeur de la propriété lorsqu'un utilisateur interagit avec l'élément d'entrée lorsque la propriété change dans le code.</p>
                                </li>
                            </ul>
                            <p>Exemple :</p>
<pre><code>&lt;input type="text" @bind="Nom" /&gt;</code></pre>
                        </li>
                        <li>
                            <p>@bind-Value :</p>
                            <ul>
                                <li>
                                    <p>"<span class="em">@bind-Value</span>" est utilisé dans des contextes où vous souhaitez explicitement la propriété liée de l'élément.</p>
                                </li>
                                <li>
                                    <p>Il est souvent utilisé avec des composants personnalisés où la propriété à lier peut être déterminée dynamiquement.</p>
                                </li>
                                <li>
                                    <p>Vous devez spécifier la propriété explicitement, par exemple, <span class="em">@bind-Value="model.Nom"</span>.</p>
                                </li>
                            </ul>
                            <p>Exemple :</p>
<pre><code>&lt;MonComposant @bind-Value="model.Nom /&gt;</code></pre>
                        </li>
                    </ol>
                    <p>En résumé, <span class="em">@bind</span> est plsu concis et pratique pour les cas d'utilisation courants où vous liez directement une propriété à la valeur d'un élément d'entrée, tandis que <span class="em">@bind-Value</span> offre une flexibilité accrue en permettant de spécifier explicitement la propriété liée à la valeur. Vous pouvez choisir celui qui convient le mieux à votre scénario d'utilisation.</p>
                </article>
                <article>
                    <h2 id="entity_framework_blazor">Entity Framework dans Blazor :</h2>
                    <h3>Configuration :</h3>
                    <p>Avant de faire quoi que ce soit, il faut télécharger et installer les logiciels suivants : <a href="https://www.microsoft.com/fr-be/sql-server/sql-server-downloads" target="_blank">SQL Server</a> et <a href="https://learn.microsoft.com/fr-fr/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16#download-ssms" target="_blank">SQL Server Management Studio (SSMS)</a>.</p>
                    <p>Dans SSMS, il faut se connecter au SQL Server local installé précédemment. Ensuite, il suffit créer une nouvelle base de données (par exemple : "MyApplicationDb").</p>
                    <p>Ensuite, Dans Visual Studio 2022, en ouvrant la fenêtre de l'explorateur de serveurs, il faut "ajouter une connexion" et remplir les champs "Souce de données" par "Microsoft SQL Server (SqlClient)", "Nom du serveur" par ".\" et "Sélectionner ou entrer un nom de base de données" par "MyApplicationDb".</p>
                    <p>Enfin, dans la solution, en gérant les paquets NuGet, on va vérifier si les paquets "<span class="em">Micosft.EntityFrameworkCore</span>", "<span class="em">Microsoft.EntityFrameworkCore.Tools</span>" et "<span class="em">Micosft.EntityFrameworkCore.SqlServer</span>" sont bien installés, sinon on installe ceux qui manquent en sélectionnant bien la dernière version stable.</p>
                    <p>Dans le projet, créez un nouveau dossier "Data" s'il n'existe pas et dedans créez une nouvelle classe "<span class="em">MyDbContext</span>" :</p>
<pre><code>using Micorsoft.EntityFrameworkCore;

namespace MyApplication.Data
{

    public class MyDbContext : DbContext
    {

        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options)
        {

        }

    }

}</code></pre>
                    <p>Dans appsettings.json, il faut rajouter la "ConnectionStrings" qu'on trouve dans les propriétés de la connexion qu'on a créée précédemment :</p>
<pre><code>{
    "ConnectionStrings": {
      "Default": "Data Source=.\\;Initial Catalog=MyApplicationDb;Integrated Security=True;Encrypt=False"
    },
    "Logging": {
      "LogLevel": {
        "Default": "Information",
        "Microsoft.AspNetCore": "Warning"
      }
    },
    "AllowedHosts": "*"
}</code></pre>
                    <p>Enfin, dans le programme principal, qui a normalement pour nom "Program.cs", il faut rajouter quelques lignes :</p>
<pre><code>using MyApplication.Components;
using MyApplication.Data;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
var connectionString = builder.Configuration.GetConnectionString("Default") ?? throw new NullReferenceException("No connection string in config !");
// Add services to the container.
builder.Services.AddRazorComponents().AddInteractiveServerComponents();

builder.Services.AddDbContextFactory&lt;MyDbContext&gt;((DbContextOptionsBuilder options) => options.UseSqlServer(connectionString));

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
}

app.UseStaticFiles();
app.UseAntiforgery();

app.MapRazorComponents&lt;App&gt;().AddInteractiveServerRenderMode();

app.Run();</code></pre>
                    <h3>Création des entitiés :</h3>
                    <p>Dans le dossier "Data", créez un dossier "Models" et créez un nouvelle classe (par exemple : "Customer.cs") :</p>
<pre><code>using System.ComponentModel.DataAnnotations;

namespace MyApplication.Data.Models
{
    public class Customer
    {
        [Key]
        public int Id { get; set; }
        public string Name { get; set; }
        public int Age { get; set; }
        public DateTime CreatedDate { get; set; }
    }
}</code></pre>
                    <p>Ensuite, dans notre DbContext, on peut créez des <span class="html">DbSet</span> :</p>
<pre><code>using MyAplication.Data.Models;
using Microsoft.EntityFrameworkCore;

namespace MyApplication.Data
{

    public class MyDbContext : DbContext
    {

        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options)
        {

        }

        public DbSet&lt;Customer&gt; Customers { get; set; }
    }

}</code></pre>
                    <h3>Les migrations :</h3>
                    <p>D'après l'article sur <a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli" target="_blank">la vue d'ensemble des migrtions</a> :</p>
                    <blockquote>
                        <p>Dans la pratique, les modèles de données des projets évoluent au fur et à mesure que des fonctionnalités sont implémentées : de nouvelles entités et propriétés sont ajoutées et supprimées, et les schémas de la base de données doivent être modifiés en conséquence pour rester synchronisés avec l'application. La fonctionnalité de migration dans Entity Framework Core permet de mettre à jour de manière incrémentielle le schéma de la base de données pour qu'il reste synchronisé avec le moèle de données de l'application tout en conservant les données existantes dans la base de données.</p>
                        <p>Dans les grandes lignes, les mogrations fonctionnent de la façon suivante :</p>
                        <ul>
                            <li>
                                <p>Lors de l'introduction d'une modification du modèle de données, le développeur utilise des outils Entity Framework Core afin d'ajouter une migration correspondante décrivant les mises à jour nécessiares pour préserver la synchronisation du schéma de la base de données. Entity Framework Core compare le modèle actuel à un instantané de l'ancien modèle pour déterminer les différences et génère des fichiers sources de migration. Ces fichiers peuvent, comme n'importe quel fichier source, faire l'objet d'un suivi dans le contrôle de code source du projet.</p>
                            </li>
                            <li>
                                <p>Une fois générée, la nouvelle migration peut être appliquée à une base de données de différentes façons. Entity Framework Core enregistre toutes les migrations appliquées dans une table d'historique spéciale, ce qui lui permet de savoir quelles migrations ont été appliquées.</p>
                            </li>
                        </ul>
                    </blockquote>
                    <p>Dans l'onglet "Outils", sélectionnez "Gestionnaire de package NuGet" et ensuite "Console du Gestionnaire de package".</p>
                    <p>Tapez la commande suivante :</p>
<pre><code>Add-Migration "Added_Customer_Table"</code></pre>
                    <p>Entity Framework Core créera un répertoire nommé "<span class="em">Migrations</span>" dans votre projet et générera des fichiers. Il est judicieux d'inspecter précisément les fichiers en question, et éventuellement de les modifier, mais nous allons nous en passer pour l'instant.</p>
                    <p>Voici le fichier généré par la commande pour les customers :</p>
<pre><code>using System;
using Micorsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MyApplication.Migrations
{

    public partial class Added_Customer_Table : Migration
    {
        
        protected override void Up(migrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Customers",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int", nullable: false)
                         .Annotation("SqlServer:Identity", "1, 1"),
                    Name = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
                    Age = table.Column&lt;int&gt;(type: "int", nullable: false),
                    CreatedDate = table.Column&lt;DateTime&gt;(type: "datetime2", nullable: false) 
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Customers", x =&gt; x.Id);
                });
        }
    }

    protected override Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Customers");
    }
}</code></pre>
                    <p>Une fois la migration créée, il faut mettre à jour la base de données avec la commande :</p>
<pre><code>Update-Database</code></pre>
                    <p>S'il y a pas eu d'erreurs, on devrait retrouver deux tables dans notre base de données : la table par défaut "<span class="em">dbo._EFMigrationHistory</span>" et la table "dbo.Customers".</p>
                    <h3>Les relations :</h3>
                    <p>On va créer une nouvelle classe dans "Models" : "Order.cs".</p>
<pre><code>using System.ComponentModel.DataAnnotations;

    namespace MyApplication.Data.Models
    {
        public class Order
        {
            [Key]
            public int Id { get; set; }
            public string ItemDescription { get; set; }
            public int Quantity { get; set; }

            public Customer Customer { get; set; }
        }
    }</code></pre>
                    <p>Dans le DbContext, pas oublier de rajouter un nouveau <span class="em">DbSet</span>, d'ajouter une nouvelle migration "Added_Orders_Table" et de mettre à jour la base de données.</p>
<pre><code>using System;
using Micorsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MyApplication.Migrations
{

    public partial class Added_Orders_Table : Migration
    {
        
        protected override void Up(migrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Orders",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int", nullable: false)
                         .Annotation("SqlServer:Identity", "1, 1"),
                    ItemDescription = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
                    Quantity = table.Column&lt;int&gt;(type: "int", nullable: false),
                    CustomerId = table.Column&lt;int&gt;(type: "int", nullable: false) 
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Orders", x =&gt; x.Id);
                    table.ForeignKey(
                        name: "FK_Orders_Customers_customerId",
                        column: x =&gt; x.CustomerId,
                        principalTable: "Customers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            
            migrationBuilder.CreateIndex(
                name: "IX_Orders_customerId",
                table: "Orders",
                column: "CustomerId");
        }
    }

    protected override Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Orders");
    }
}</code></pre>
                    <p>Pour ajouter une contrainte d'unicité (unique en SQL) sur la propriété "Name", il faut rajouter, dans la partie "constraints" des migrations, la ligne suivante :</p>
<pre><code>table.UniqueConstraint("UQ_VotreTable_Name", x =&gt; x.Name);</code></pre>
                    <p>Pour ajouter une contrainte précisant les valeurs spécifiques que peut prendre une propriété (par exemple : la propriété "Sexe" peut prendre "M", "F" ou "X" comme valeur), rajoutez toujours dans "constraints" la ligne suivante :</p>
<pre><code>table.CheckConstraint("CK_VotreTable_Sexe", "Sexe IN ('M', 'F', 'X')");</code></pre>
                    <h3>Créer un service pour interagir avec le contexte (CRUD) :</h3>
                    <p>Dans le projet, on crée un nouveau répertoire "Services" et créons la classe "CustomerService.cs" dedans.</p>
<pre><code>using MyApplication.Data;
using MyApplication.Data.Models;
using Microsoft.EntityFrameworkCore;

namespace MyApplication.Service
{

    public class CustomerService
    {
        private IDbContextFactory&lt;MyDbContext&gt; _dbContextFactory;

        public CustomerService(IDbContextFactory&lt;MyDbContext&gt; dbContextFactory)
        {
            _dbContextFactory = dbContextFactory;
        }

        public void AddCustomer(Customer customer)
        {
            using (var context = _dbContext.CreateDbContext())
            {
                context.Customers.Add(customer);
                context.SaveChanges();
            }
        }

        public Customer GetCustomerByName(string name)
        {
            using (var context = _dbContextFactory.CreateDbContext())
            {
                var customer = context.Customers.SingleOrDefault(x =&gt; x.Name == name);
                return customer;
            }
        }

        public void UpdateCustomerByName(string name, int age)
        {
            var customer = GetCustomerByName(name);
            if (customer == null)
            {
                throw new Exception("Customer does not exist. Cannot update");
            }
            customer.Age = age;
            using (var context = _dbContextFactory.CreateDbContext())
            {
                context.Customers.Update(customer);
                context.SaveChanges();
            }
        }

        public void RemoveCustomerByName(string name)
        {
            var customer = GetCustomerByName(name);
            if (customer == null)
            {
                throw new Exception("Customer does not exist. Cannot delete");
            }

            using (var context = _dbContextFactory.CreateDbContext())
            {
                context.Customers.Remove(customer);
                context.SaveChanges();
            }
        }

    }
}</code></pre>
                    <p>Dans le "Program.cs", n'oubliez pas de rajouter les lignes suivantes à la bonne place avant l'ajout du DbContextFactory :</p>
<pre><code>using MyApplication.Services;
builder.Services.AddTransient&lt;CustomerService&gt;();</code></pre>
                    <p>Dans le fichier "Index.razor" du dossier "Pages", on va créer un formulaire pour insérer un nouveau "Customer" dans la base de données :</p>
<pre><code>@page "/"
@using MyApplication.Services
@using MyAplication.Data.Models
@inject CustomerService customerService

&lt;PageTitle&gt;Index&lt;/PageTitle&gt;

&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.

&lt;SurveyPrompt Title="How is Blazor working for you?" /&gt;

&lt;EditForm Model="@customer" OnValidSubmit="HandleSubmit"&gt;
    &lt;label for="NameInput"&gt;Name&lt;/label&gt;
    &lt;InputText id="NameInput" @bind-Value="@customer.Name"&gt;&lt;/InputText&gt;
    &lt;label for="AgeInput"&gt;Age&lt;/label&gt;
    &lt;InputNumber id="AgeInput" @bind-Value="@customer.Age"&gt;&lt;/InputNumber&gt;
    &lt;button type="submit" class="btn btn-primary"&gt;Create&lt;/button&gt;
&lt;/EditForm&gt;

@code {
    Customer customer = new Customer();

    public void HandleSubmit(EditContext editContext)
    {
        var newCustomer = (Customer)editContext.Model;
        newCustomer.CreatedDate = DateTime.Now;
        customerService.AddCustomer(newCustomer);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="blazor_.NET_8">Blazor en .NET 8 :</h2>
                    <p>Dans ce cours, on va apprendre à développer des applications Web et Mobiles avec Blazor.</p>
                    <p>Les prérequis pour faire du Blazor sont les fondamentaux de C# et les fondamentaux HTML/CSS. Des notions MAUI sont un plus.</p>
                    <h3>Qu'est-ce que Blazor ?</h3>
                    <p>Pour rappel, Blazor est la technologie ASP.NET de Microsoft pour réaliser des applications graphiques riches et interactives.</p>
                    <p>Blazor permet de réaliser des applications web, mais pas que ! Il est possible d'utiliser Blazor dans des applications natives (mobile ou desktop).</p>
                    <p>L'avantage principal de la technologie : on utilise C# de bout en bout (pas de JavaScript nécessaire !!!).</p>
                    <h3>Les variantes de Blazor : WebApp, WASM & Hybrid :</h3>
                    <h4>Blazor WebApp - Server :</h4>
                    <p>Avant Blazor en .NET 8, on avait Blazor Server qui était une application ASP.NET s'exécutant sur le serveur. Donc, avec tout le potentiel de .NET côté serveur ! Du côté client, on avait un petit client en JavaScript qui ouvrait un pont WebSocket avec le serveur pour lui demander d'exécuter certaines interactions et de récupérer les modifications de DOM à appliquer sur la partie graphique. On avait pas la possibilité de dire tel composant n'a pas d'interactivité pas dynamiquement riche donc on peut le rendre de façon statique du côté serveur vu que l'utilisateur ne va pas réagir avec ce composant-là. Donc, toute l'application était connectée en permanence à ce pont en WebSocket.</p>
                    <p>Le moteur s'exécute sur le serveur et renvoie aux clients des instructions pour mettre à jour le DOM.</p>
                    <p>Le client maintient un lien avec le serveur par le biais d'un pont WebSocket si l'interactivité est nécessaire.</p>
                    <p>On a un équivalent en JavaScript avec les React Component Server.</p>
                    <h4>Blazor Web App - WebAssembly :</h4>
                    <p>Il y a deux modes de fonctionnement. Nous avons la possibilité en Blazor de créer une application WebAssembly autonome, c'est-à-dire qu'on va créer une application statique au sens qu'elle n'a pas de lien avec un serveur comme on créerait une application Angular, React ou autres.</p>
                    <p>Le runtime .NET (spécifique) ainsi que l'application est téléchargé sur le poste du client.</p>
                    <p>100% du code est exécuté sur le poste client.</p>
                    <h4>Blazor Hybrid :</h4>
                    <p>Les composants Blazor fonctionnent dans un composant natif (navigateur/webview) de la plateforme cible.</p>
                    <p>Cette dernière expose des accès à certaines APIs natives.</p>
                    <h4>Blazor WebApp :</h4>
                    <p>Depuis .NET 8, Blazor pour le web a été unifié dans un seul template : Blazor WebApp !</p>
                    <p>Le mode de rendu (Server, WebAssembly ou automatique) se définit par composant.</p>
                    <h4>Server ou WASM :</h4>
                    <p>Si on part sur une application Web... Pas de réponses universelles !</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Server</th>
                                <th>WASM</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p>Client léger</p>
                                        </li>
                                        <li>
                                            <p>Tout est sur le serveur</p>
                                        </li>
                                        <li>
                                            <p>Sécurisé</p>
                                        </li>
                                        <li>
                                            <p>100% de l'expérience dev</p>
                                        </li>
                                        <li>
                                            <p>100% du framework .NET</p>
                                        </li>
                                        <li>
                                            <p>Performant</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <p>100% sur le poste client</p>
                                        </li>
                                        <li>
                                            <p>Mode déconnecté</p>
                                        </li>
                                        <li>
                                            <p>hébergement simplifié</p>
                                        </li>
                                        <li>
                                            <p>Supporte la charge</p>
                                        </li>
                                        <li>
                                            <p>Transformable en PWA</p>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Créer un projet Blazor avec VS 2022 :</h3>
                    <p>Nous allons créer un projet Blazor Web App dans Visual Studio. On peut toujours faire du WebAssembly dans la Web App. Attention, de bien choisir le type de projet pour que ça reste en .NET 8.</p>
                    <p>Donnons-lui un nom (par exemple : MyAppBlazor) et on choisit bien .NET 8 sans configuration le HTTPS. Le type d'interactivité passe maintenant en auto, c'est-à-dire la combinaison entre Server et WebAssembly.</p>
                    <p>En choisissant le mode automatique, on a deux projets : MyAppBlazor et MyAppBlazor.Client.</p>
                    <h3>Créer un projet Blazor avec le CLI :</h3>
                    <p>Pour ceux qui veulent pas utiliser VS 2022, on utilisera le CLI (l'abréviation pour "lignes de commande"). La commande suivante va nous permettre d'afficher la totalité des templates existants sur notre machine nous permettant de créer une nouvelle application :</p>
<pre><code>dotnet new list</code></pre>
                    <p>Dans cette liste qui est assez grande, vont nous intéresser certains templates. En l'occurence, Application .NET MAUI Blazor va nous permettre de créer une application Blazor Hybrid. Attention de ne pas se servir des trois templates suivants : blazorserver, blazorserver-empty ou encore blazorwasm-empty car les versions de .NET utilisées sont les versions de .NET 7 ou moins.</p>
                    <p>blazorwasm est toujours valable en .NET 8 et permet de faire une WebAssembly. Ici, dans ce cours, on utilisera le nouveau template Blazor Web App : blazor.</p>
                    <p>Pour faire le même projet que dans Visual Studio 2022 en lignes de commande :</p>
<pre><code>dotnet new blazor -int Auto --no-https</code></pre>
                    <h3>Composant statique et streaming :</h3>
                    <p>On parle ici de Server Side Rendering (SSR) et de Stream Rendering.</p>
                    <p>Les composants qui nécessitent une interactivité doivent être placés dans MyAppBlazor.Client. Donc, les composants statiques sont dans MyAppBlazor et les composants dynamiques dans MyAppBlazor.Client.</p>
                    <p>C'est MyAppBlazor qui se lance au démarrage et non MyAppBlazor.Client. Le code HTML est dans le fichier App.razor.</p>
                    <p>Dans la page Weather se trouvant dans MyAppBlazor, on a rajouté un attribut : <span class="html">@attribute[StrealRendering(true)</span>.</p>
                    <h3>Composant interactif :</h3>
                    <p>Dans la page Counter se trouvant dans MyAppBlazor.Client, on a rajouté un attribut : <span class="html">@attribute [RenderModelInteractiveAuto]</span>. Depuis un certain temps, Microsoft a abandonné cet attribut et on utilisera l'instruction <span class="html">@rendermode InteractiveAuto</span> à la place.</p>
                    <p>Blazor met toujours un élément <span class="html">@code</span>, mais moi je préfère séparer le HTML du code C# de l'élément <span class="em">@code</span> en extrayant le bloc vers le code-behind. Ça créra un nouveau fichier Counter.razor.cs qui contient la classe partial.</p>
                    <h3>Blazor Hybrid avec MAUI :</h3>
                    <p>On va créer un nouveau projet dans notre application. Cette fois-ci, ce sera un projet Blazor Hybrid avec .NET MAUI Blazor : MyAppBlazor.Mobile. Si vous avez une erreur dans Visual Studio 2022 lors de la création de ce projet, il faut vérifier dans Visual Studio Installer qu'on a bien coché "Développement .NET Multi-Platform App UI et exécutez la commande suivante dans un terminal qui va installer tous les packages liés à MAUI :</p>
<pre><code>dotnet workload install maui</code></pre>
                    <p>On a le MauiProgram.cs qui ressemble au Program.cs. MauiProgram.cs et CreateMauiApp() sont des points d'entrée que va utiliser le framework MAUI. Mais pour qu'une application MAUI fonctionne, on a un <span class="em">MauiBlazorWebView</span>. MainPage.xaml (XAML est un langage de balisage inspiré de XML) est la page principale de notre application Blazor Hybrid.</p>
                    <h3>Librairie de composants Blazor :</h3>
                    <p>Ce qu'on va faire prochainement dans Visual Studio 2022, on peut utiliser la commande suivante à la place :</p>
<pre><code>dotnet new razorclasslib</code></pre>
                    <p>Donc soit on fait cette commande soit on ajoute un nouveau projet dans notre application : Bibliothèque de classes Razor. On va l'appeler "MyAppBlazor.Components" et on va supprimer les fichiers "Component1.razor" et "Example.JsInterop.cs" ainsi que les fichiers dans le dossier wwwroot.</p>
                    <p>Le fichier "<span class="em">_Imports.razor</span>" contient une collection <span class="em">@using</span> qui sont implicitement à chacun des composants pour éviter de faire les différents <span class="em">@using</span>.</p>
                    <p>On crée le fichier "Home.razor" dans le projet "MyAppBlazor.Components" avec le contenu suivant :</p>
<pre><code>&lt;h1&gt;Hello, world!&lt;/h1&gt;

Welcome to your new app.</code></pre>
                    <p>Dans les projets, on oublie de rajouter une référence vers le projet "MyAppBlazor.Components".</p>
                    <p>Dans le fichier "Index.razor" du projet "MyAppBlazor.Mobile", on modifie pour que ça donne ceci :</p>
<pre><code>@page "/"

&lt;Home&gt;&lt;/Home&gt;</code></pre>
                    <p>Dans le fichier "_Imports.razor", on rajoute la ligne suivante :</p>
<pre><code>@using MyAppBlazor.Components</code></pre>
                    <p>Dans le fichier "Home.razor" du projet "MyAppBlazor", on le modifiera avec le code ci-dessous :</p>
<pre><code>@page "/"

&lt;PageTitle&gt;Home&lt;/PageTitle&gt;

&lt;MyAppBlazor.Components.Home /&gt;</code></pre>
                    <p>Ensuite, on va rajouter un projet "MyAppBlazor.Models". On va supprimer le fichier "Class1.cs" et on va créer le fichier "WeatherForecast.cs" avec le contenu suivant :</p>
<pre><code>namespace MyAppBlazor.Models;

public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    public string Summary { get; set; }
}</code></pre>
                    <p>On va rajouter la référence dans le projet Hybrid vers le Models, ainsi que la référence dans le projet Blazor Web App. Dans le fichier "_Impors.razor", on oublie pas de rajouter le using suivant :</p>
<pre><code>@using MyAppBlazor.Models</code></pre>
                    <p>On va supprimer le dossier "Data" du projet "MyAppBlazor.Mobile" et on va créer un projet "MyAppBlazor.Services" en supprimant le fichier "Class1.cs". On fait une référence le projet Models et on va créer le fichier "WeatherForecastService.cs" avec le contenu suivant :</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyAppBlazor.Services;

public class WeatherForecastService
{
    public async Task&lt;WeatherForecast[]&gt; GetForecasts()
    {
        await Task.Delay(1000);
        var DateOnly startDate = DateOnly.FromDateTime(DateTime.Now);
        var string[]? summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Hot", "Sweltering" "Scoching" };
        return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summmary = summaries(Random.Shared.Next(summaries.Length))
        }).ToArray();
    }
}</code></pre>
                    <p>On rajoute une référence vers le Service que je viens de créer au projet Mobile et, dans le fichier "MauiProgram.cs", on utilise le bon using dans la ligne suivante :</p>
<pre><code>builder.Services.AddSingleton&lt;WeatherForecastService&gt;();</code></pre>
                    <p>Dans le fichier "_Imports.razor" du projet Mobile, il faut vérifier que les using suivants y sont sinon rajoutez-les :</p>
<pre><code>@using MyAppBlazor.Components
@using MyAppBlazor.Models
@using MyAppBlazor.Services</code></pre>
                    <p>Dans le fichier "FetchData.razor" du projet Mobile, on va modifier la méthode "OnInitializedAsync()" comme ceci :</p>
<pre><code>@inject WeatherForecastService ForecastService
    
protected override async Task OnInitializedAsync()
{
    await Task.Delay(2000);
    forecasts = await ForecastService.GetForecasts();
}</code></pre>
                    <p>N'oubliez pas de rajouter la ligne suivante dans le "Program.cs" du projet "MyAppBlazor" :</p>
<pre><code>builder.Services.AddScoped&lt;WeatherForecastService&gt;();</code></pre>
                    <h3>Créer un composant routable :</h3>
                    <p>Tout doit passer par la notion de routeur qui se trouve dans le fichier "Routes.razor" du projet "MyAppBlazor" :</p>
<pre><code>&lt;Router AppAssembly="@typeof(Program).Assembly" AdditionalAssemblies="new[] { typeof(Client._Imports).Assembly }"&gt;
    &lt;Found Context="routerData"&gt;
        &lt;RouteView RouteData="@routeData" DefaultLayout="@typeof(Layaout.MainLayout)" /&gt;
        &lt;FocusOnNavigate RouteData="@routeData" Selector="h1" /&gt;
    &lt;/Found&gt;
&lt;/Router&gt;</code></pre>
                    <h3>Blazor Web App - Interactivité serveur :</h3>
                    <p>Créons un nouveau projet "MyAppBlazor.Server" avec le type d'interactivité en "Server" et le lieu d'interactivité en "Global" tout en supprimant la partie "HTTPS".</p>
                    <h3>Blazor WASM autonome :</h3>
                    <p>Créons un nouveau projet WebAssembly "MyAppBlazor.WASM" tout en supprimant comme d'habitude le "HTTPS".</p>
                    <h3>Exercice pratique :</h3>
                    <p>Créons un petit jeu qui s'appelle "le nombre magique". Pour cela, on crée une solution "NombreMagique" avec quatre projets à l'intérieur : "NombreMagique.Components" (librairie), "NombreMagique.Hybrid" (MAUI), "NombreMagique.Server" (en "Global") et "NombreMagique.WASM".</p>
                    <p>On a des fichiers images qu'il faut copier dans le "wwwroot" des divers projets. On a un fichier "script.html" qu'il faudra modifier pour les divers projets :</p>
<pre><code>&lt;!-- Dans la balise &lt;head&gt; --&gt;
&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous"&gt;

&lt;body class="d-flex align-items-center justify-content-center"&gt;
    &lt;div class="bg-image"&gt;&lt;/div&gt;

    &lt;!-- JEU --&gt;
    &lt;div class="content"&gt;
        &lt;div class="row"&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-2 mb-3 mb-md-0 d-flex align-items-center justify-content-center"&gt;
                &lt;img src="images/etoile.png" class="rotating" height="128" /&gt;
            &lt;/div&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-8 d-flex align-items-center justify-content-center flex-column"&gt;

                &lt;h1&gt;Le nombre magique&lt;/h1&gt;

                &lt;h4&gt;Tentez de deviner un nombre entre 1 et 20&lt;/h4&gt;
                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        &lt;input type="number"/&gt;
                    &lt;/div&gt;
                    &lt;div class="col"&gt;
                        &lt;a class="btn bth-success btn-valid"&gt;
                            Go
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row mt-4"&gt;
                    &lt;!-- À UTILISER POUR AFFICHER LES VIES --&gt;
                    &lt;div class="col-auto"&gt;
                        &lt;img src="/images/life.png" height="32" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;!-- À AFFICHER À LA FIN DU JEU --&gt;
                &lt;a class="btn btn-primary btn-valid"&gt;
                    Rejouer
                &lt;/a&gt;
            &lt;/div&gt;
            &lt;div class="col-xs-12 col-sm-12 col-md-12 mt-3 mt-md-0 d-flex align-items-center justify-content-center"&gt;
                &lt;img src="images/etoile.png" class="rotating" height=128" /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;!-- Avant la fermeture de &lt;body&gt; --&gt;
&lt; script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hc4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+014" crossorgin="anonymous"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
                    <p>On doit modifier le fichier "App.razor" du projet "NombreMagique.Server" :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;base href="/" /&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous"&gt;
    &lt;HeadOutlet @rendermode="@renderMode.InteractiveServer" ./&gt;
&lt;/head&gt;

&lt;body class="d-flex align-items-center justify-content-center"&gt;
    &lt;div class="bg-image"&gt;&lt;/div&gt;
    &lt;Routes @rendermode="@RenderMode.InteravtiveServer" /&gt;
    &lt;script src="_framework/lblazor.web.js"&gt;&lt;/script&gt;
    &lt; script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hc4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+014" crossorgin="anonymous"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
                    <p>On oublie pas de supprimer les composants de base fournis dans le projet "NombreMagique.Components" et on crée dedansd le fichier "Game.razor" :</p>
<pre><code> &lt;!-- JEU --&gt;
&lt;div class="content"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-2 mb-3 mb-md-0 d-flex align-items-center justify-content-center"&gt;
            &lt;img src="images/etoile.png" class="rotating" height="128" /&gt;
        &lt;/div&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-8 d-flex align-items-center justify-content-center flex-column"&gt;

            &lt;h1&gt;Le nombre magique&lt;/h1&gt;
            @if (gameWon is null)
            {
                &lt;h4&gt;Tentez de deviner un nombre entre 1 et 20&lt;/h4&gt;

                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        @if (!string.IsNullOrEmpty(indice))
                        {
                            @indice
                        }
                        else
                        {
                            &lt;text&gt;&amp;nbsp;&lt;/text&gt;
                        }
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class="row"&gt;
                    &lt;div class="col"&gt;
                        &lt;input type="number" min="@NbMin" max="@NbMax" @bind="value" /&gt;
                    &lt;/div&gt;
                    &lt;div class="col"&gt;
                        &lt;a class="btn bth-success btn-valid" @onclick="CheckNumber"&gt;
                            Go
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row mt-4"&gt;
                    &lt;!-- À UTILISER POUR AFFICHER LES VIES --&gt;
                    @for (int i = 0; i &lt; nbRemainingLifes; i++)
                    {
                        &lt;div class="col-auto"&gt;
                            &lt;img src="/images/life.png" height="32" /&gt;
                        &lt;/div&gt;
                    }
                &lt;/div&gt;
            }
            else
            {
                @if (gameWon.Value)
                {
                    &lt;h3&gt;C'est gagné !&lt;/h3&gt;
                }
                else
                {
                    &lt;h3&gt;C'est perdu ! Le nombre magique était @nbMagic&lt;/h3&gt;
                }
                &lt;!-- À AFFICHER À LA FIN DU JEU --&gt;
                &lt;a class="btn btn-primary btn-valid" @onclick="InitGame"&gt;
                    Rejouer
                &lt;/a&gt;
            }
        &lt;/div&gt;
        &lt;div class="col-xs-12 col-sm-12 col-md-12 mt-3 mt-md-0 d-flex align-items-center justify-content-center"&gt;
            &lt;img src="images/etoile.png" class="rotating" height=128" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    <p>Dans le fichier "Game.razor.cs", on a le code-behind qui va nous permettre d'interagir avec notre jeu :</p>
<pre><code>// &lt;auto-generated/&gt;
namespace NombreMagique.Components;

public partial class Game
{
    private const int Lifes = 5;
    private const int NbMin = 1;
    private const int NbMax = 20;

    private int nbMagic;
    private bool? gameWon;
    private int nbRemainingLifes;
    private int? value;
    private string indice;

    protected override void OnInitizlized()
    {
        InitGame();
    }

    private void InitGame()
    {
        gameWon = null;
        nbMagic = Random.Shared.Next(NbMin, nbMax + 1);
        nbRemainingLifes = Lifes;
        value = null;
        indice = null;
    }

    private void CheckNumber()
    {
        if (value == nbMagic)
        {
            gameWon = true;
            indice = null;
            return;
        }
        nbRemainingLifes--;
        if (nbRemainingLifes &lt;= 0)
        {
            gameWon = false;
            indice = null;
            return;
        }
        if (value &gt; nbMagic) indice = "Le nombre magique est plus petit";
        else if (value &lt; nbMagic) indice = "Le nombre magique est plus grand";
    }
}</code></pre>
                    <p>On oublie d'ajouter la dépendance du Components sur le Server et de modifier le fichier "Home.razor" :</p>
<pre><code>@page "/"

&lt;NombreMagique.Components.Game /&gt;</code></pre>
                    <p>Ensuite, supprimons le dossier "Data" ainsi que les fichiers d'exemples dans le projet "NombreMagique.Hybrid" tout en ajoutant une dépendance vers le projet Components et modifions le fichier "Index.razor" :</p>
<pre><code>@page "/"

&lt;NombreMagique.Components.Game /&gt;</code></pre>
                    <p>Dans le dossier "Shared" du projet Hybrid, je n'ai ni besoin du "MainLayout.razor" ni du "NavMenu.razor" car on va déplacer le "MainLayout.razor" du projet Server. Et je nettoie la notion de Singleton dans le "MauiProgram.cs" qui n'a palus de sens ici.</p>
                    <p>On supprime le fichier CSS et on modifie le fichier "index.html" des projets Hybrid et WASM en ajoutant les liens Bootstrap et la "Bg-Image". Supprimons le loading du WASM.</p>
                </article>
                <article>
                    <h2 id="ASP.NET_creation_api_web_c#_minimal_apis">ASP.NET : Création d'API Web avec C# et Minimal APIs :</h2>
                    <h3>Prérequis :</h3>
                    <ul>
                        <li>
                            <p>Connaître les fondamentaux du langage C#</p>
                        </li>
                        <li>
                            <p>Avoir installé le SDK .NET 6+</p>
                        </li>
                        <li>
                            <p>Avoir un environnement de développement (Visual Studio Code, Visual Studio, Rider, etc.)</p>
                        </li>
                        <li>
                            <p>Être motivé !</p>
                        </li>
                    </ul>
                    <h3>Introduction :</h3>
                    <p>API veut dire Application Porgammong Interface.</p>
                    <p>Le rôle d'une API est d'exposer du comportement métier à d'autres applications.</p>
                    <p>La communication d'une API peut se faire :</p>
                    <ul>
                        <li>
                            <p>En XML</p>
                        </li>
                        <li>
                            <p>En JSON (recommandé)</p>
                        </li>
                        <li>
                            <p>En gRPC (ultra performant)</p>
                        </li>
                    </ul>
                    <p>En .NET, il est possible de faire des APIs de deux façons :</p>
                    <ul>
                        <li>
                            <p>Avec les minimals APIs (plus rapide & performant)</p>
                        </li>
                        <li>
                            <p>Avec le pattern MVC</p>
                        </li>
                    </ul>
                    <p>Dans ce cours, nous verrons les deux façons de procéder, de telle sorte que vous puissiez faire votre choix, mais nous mettrons le focus sur la partie minimal APIs, car c'est l'approche moderne recommandée.</p>
                    <h3>REST :</h3>
                    <p>Les APIs respectent la philosophie REST (Representational State Transfer).</p>
                    <p>On va utiliser des verbes HTTP pour indiquer l'intention :</p>
                    <ul>
                        <li>
                            <p><span class="html">GET</span> &#8594; lecture</p>
                        </li>
                        <li>
                            <p><span class="html">POST</span> &#8594; création</p>
                        </li>
                        <li>
                            <p><span class="html">PUT/PATCH</span> &#8594; mise à jour</p>
                        </li>
                        <li>
                            <p><span class="html">DELETE</span> &#8594; suppression</p>
                        </li>
                    </ul>
                    <p>On va utiliser les codes HTTP pour indiquer le résultat :</p>
                    <ul>
                        <li>
                            <p><span class="html">2xx</span> &#8594; résultat positif</p>
                        </li>
                        <li>
                            <p><span class="html">3xx</span> &#8594; ressource déplacée</p>
                        </li>
                        <li>
                            <p><span class="html">4xx</span> &#8594; erreur dans la requête</p>
                        </li>
                        <li>
                            <p><span class="html">5xx</span> &#8594; erreur sur le serveur</p>
                        </li>
                    </ul>
                    <h3>Création du projet :</h3>
                    <p>Dans PowerShell, on lance la commande suivante pour créer un projet Console que j'ai nommé "MinimalApis" :</p>
<pre><code>dotnet new console</code></pre>
                    <p>On va modifier le fichier "MinimalApis.csproj" :</p>
<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
        &lt;ImplicitUsings&gt;enable&lt;ImplicitUsings&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;

&lt;/Project&gt;</code></pre>
                    <p>On va recharger les projets et modifier le fichier "Program.cs" :</p>
<pre><code>var builder = WebApplication.CreateBuilder();

var app = builder.Build();

app.MapGet("/hello", () =&gt; "Hello World !");

app.Run();</code></pre>
                    <p>Quand on lance le projet et qu'on accède à l'URL "/hello", la page va afficher "Hello World !".</p>
                    <h3>Les autres verbes HTTP :</h3>
                    <p>Il existe également les méthodes <span class="html">MapDelete()</span>, <span class="html">MapPost()</span>, <span class="html">MapPut()</span> et <span class="html">MapPatch()</span>.</p>
                    <p>Pour utiliser plusieurs verbes HTTP pour une seule URL, on utilisera la méthode <span class="html">MapMehods()</span> :</p>
<pre><code>app.MapMethods("/methods", new[] { "GET", "POST" }, () =&gt; "Hello methods");</code></pre>
                    <p>Pour faire des requêtes via une URL, on va installer le logiciel "Postman". On va désactiver la certification SSL.</p>
                    <h3>Gestion des objets et des routes :</h3>
                    <p>On va créer un nouveau record "Article" :</p>
<pre><code>namespace MinimalApis
{
    public record Article(int Id, string Title);
}</code></pre>
                    <p>On peut envoyer un nouvel article en GET via l'url "/article" avec la ligne suivante : </p>
<pre><code>app.MapGet("/article", () =&gt; new Article(1, "Marteau"));</code></pre>
                    <p>Pour récupérer l'article avec un tel id en GET, on doit faire :</p>
<pre><code>app.MapGet("/articles/{id}", (int id) =&gt; new Article(id, "Marteau"));</code></pre>
                    <h3>Gestion des résultats :</h3>
                    <p>On va créer une liste d'articles pour chercher le bon article selon l'id :</p>
<pre><code>var list = List&lt;Article&gt;
{
    new Article(1, "Marteau"),
    new Article(2, "Scie")
};

aap.MapGet("/articles/{id:int}", (int id) =&gt;
{
    var article = list.Find(a =&gt; a.Id == id);
    if (article is not null) return Results.Ok(article);

    return Results.notFound();
});</code></pre>
                    <h3>Gestion de paramètres entrants (route, requête, etc.) :</h3>
                    <p>On peut utiliser l'annotation <span class="html">FromRoute</span> pour bien préciser que le paramètre de la lambda est lié au paramètre dans la route :</p>
<pre><code>app.MapGet("/personne/{nom}", (
    [FromRoute(Name = "nom")] string nomPersonne,
    [FromQuery(Name = "prenom")] string? prenomPersonne,
    [FromHeader(Name = "Accept-Encoding")] string encoding) =&gt; Results.Ok($"{nomPersonne} {prenomPersonne} {encoding}"));</code></pre>
                    <p>L'annotation <span class="html">FromQuery</span> permet de donner un nom plus explicite pour le paramètre de l'URL.</p>
                    <p>L'annotation <span class="html">FromHeader</span> permet de récupérer une valeur depuis le Header de la réponse HTTP.</p>
                    <h3>Gestion des paramètres spéciaux :</h3>
                    <p>Créons une nouvelle classe "Personne" :</p>
<pre><code>namespace MinimalApis
{
    public class Personne
    {
        public string Nom { get; set; }
        public string Prenom { get; set; }

        public static bool TryParse(string value, out Personne? person)
        {
            try
            {
                var data = value.Split(' ');
                person = new Personne
                {
                    Nom = data[0],
                    Prenom = data[1]
                };
                return true;
            }
            catch (Exception)
            {
                person = null;
                return false;
            }
        }

        public static async ValueTask&lt;Personne&gt; BindAsync(HttpContext context, ParameterInfo parameterInfo)
        {
            try
            {
                using var streamReader = new StreamReader(context.Request.Body);
                var body = await streamReader.readToEndAsync();
                var data = body.Split(' ');
                var person = new Personne
                {
                    Nom = data[0],
                    Prenom = data[1]
                };
                return person;
            }
            catch (Exception)
            {
                return null;
            }
        }
    }
}</code></pre>
                    <p>Dans le "Program.cs", on peut envoyer en GET la personne :</p>
<pre><code>app.MapGet("/personne/identite", (Personne p) =&gt; Results.Ok(p)); <span class="em">// appelle la méthode TryParse()</span>

app.MapPost("/personne/identite", (Personne p) =&gt; Results.Ok(p)); <span class="em">// appelle la méthide BindAsync()</span></code></pre>
                    <h3>Gestion des services :</h3>
                    <p>On va créer une classe "ArticleService" :</p>
<pre><code>namespace MinimalApis
{
    public class ArticleService
    {
        private List&lt;Article&gt; list = new List&lt;Article&gt;
        {
            new Article(1, "Marteau"),
            new Article(2, "Scie")
        };

        public List&lt;Article&gt; GetAll() =&gt; list;

        public Article Add(string title)
        {
            var article = new Article(list.Max(a =&gt; a.Id) + 1, title);
            list.Add(article);
            return article;
        }
    }
}</code></pre>
                    <p>On va ajouter ce service en Singleton dans le builder du programme principal :</p>
<pre><code>builder.Services.AddSingleton&lt;ArticleService&gt;();

app.MapPost("/articles", (Article a, ArticleService service) =&gt;
{
    var result = service.Add(a.Title);
    return Results.Ok(result);
});</code></pre>
                    <p>On peut également utiliser l'annotation "<span class="html">FromServices</span>".</p>
                    <h3>Exercice pratique :</h3>
                    <p>le but du TP est de réaliser un exercice en totale autonomie de A à Z.</p>
                    <p>Ce TP vous fera implémenter une API de gestion des tâches (TodoList).</p>
                    <p>Pour réaliser ce TP dans les meilleures conditions, voici quelques instructions destinées à vous guider :</p>
                    <ol>
                        <li>
                            <p>Créer un projet</p>
                        </li>
                        <li>
                            <p>Créer un record pour héberger les données d'un Todo (titre, startDate, endDate)</p>
                        </li>
                        <li>
                            <p>Créer un service pour gérer les Todo (singleton)</p>
                        </li>
                    </ol>
                    <p>Dans PowerShell, on commence par la commande :</p>
<pre><code>dotnet new console -n TodoListApi</code></pre>
                    <p>On passe par le Sdk.Web et on crée le builder. On crée une classe Model "Todo" :</p>
<pre><code>namespace TodoListApi
{
    public record Todo(int Id, string Title, DateTime StartDate, DateTime? EndTime = null);
}</code></pre>
                    <p>Ensuite, on va créer le "TodoService" :</p>
<pre><code>namespace TodoListApi
{
    public class TodoService
    {
        private List&lt;Todo&gt; list = new();

        public List&lt;Todo&gt; GetAll() =&gt; list;

        public Todo? GetById(int id) =&gt; list.Find(t =&gt; t.Id = id);

        public bool Delete(int id)
        {
            var todo = GetById(id);
            if (todo is not null)
            {
                list.Remove(todo);
                return true;
            }
            return false;
        }

        public Todo Add(string title)
        {
            var id = list.Count &gt; 0 ? list.Max(t =&gt; t.Id) + 1 : 1;
            var todo = new Todo(
                id,
                title,
                DateTime.Now
            );
            list.Add(todo);
            return todo;
        }

        public void Update(int id, Todo item)
        {
            Delete(id);
            list.Add(new Todo(id, item.Title, item.StartDate, item.EndDate));
        }
    }
}</code></pre>
                    <p>Modifions le fichier "Program.cs" :</p>
<pre><code>using Microsoft.AspNetCore.Mvc;
using TodoListApi;

var builder = WebApplication.CreateBuilder();

builder.Services.AddSingleton&lt;TodoService&gt;();

var app = builder.Build();

app.MapGet("todos", ([FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.GetAll());
});

app.MapGet("todos/{id:int}", ([FromRoute] int id, [FromServices] TodoService service) =&gt;
{
    var toto = service.GetById(id);

    if (todo is null) return Results.NotFound();
    return Results.Ok(todo);
});

app.MapGet("todos/active", ([FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.GetAll().Where(t =&gt; t.EndDate is null));
});

app.MapPost("todos", ([FromBody] string todo, [FromServices] TodoService service) =&gt;
{
    return Results.Ok(service.Add(todo));
});

app.MapDelete("todos/{id:int}", ([FromRoute] int id, [FromServices] TodoService service) =&gt;
{
    var result = service.Delete(id);
    if (result)
    {
        return Results.NoContent();
    }
    return Results.NotFound();
});

app.MapUpdate("todos/{id:int}", ([FromRoute] int id, [FromBody] Todo item, [FromServices] TodoService service) =&gt;
{
    service.Update(id, item);
    return Results.NoContent();
});

app.Run();</code></pre>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>