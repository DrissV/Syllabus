<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Vue.js - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction"></a>Introduction</li>
                        <li><a href="#installation">L'installation</a></li>
                        <li><a href="#syntaxe">La syntaxe</a></li>
                        <li><a href="#exercice_todolist">Exercice de la Todolist</a></li>
                        <li><a href="#proprietes_calculees">Les propriétés calculées</a></li>
                        <li><a href="#composants">Les composants</a></li>
                        <li><a href="#cycle_vie_composants">Le cycle de vie des composants</a></li>
                        <li><a href="#observateurs">Les observateurs</a></li>
                        <li><a href="#quiz">Le TP du Quiz</a></li>
                        <li><a href="#composition_option">Composition ou Option</a></li>
                        <li><a href="#comprendre_reactivite">Comprendre la réactivité</a></li>
                        <li><a href="#transition">Transition</a></li>
                        <li><a href="#provide_inject">Provide et Inject</a></li>
                        <li><a href="#composants_elements_speciaux">Composants &amp; Éléments spéciaux</a></li>
                        <li><a href="#gerer_CSS_vuejs">Gérer le CSS avec Vue.js</a></li>
                        <li><a href="#vue_router">Vue Router</a></li>
                        <li><a href="#tester_composants">Tester ses composants</a></li>
                        <li><a href="#gerer_etat_Pinia">Gérer l'état avec Pinia</a></li>
                        <li><a href="#TypeScript_Vuejs">TypeScript avec Vue.js</a></li>
                        <li><a href="#Nuxt">Nuxt</a></li>
                        <li><a href="#Tanstack_Vue_Query">Tansack Vue Query</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                        <li><a href="https://vuejs.org/">Documentation officielle de Vue.js</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Vue.js :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Vue.js est un framework JavaScript progressif utilisé pour construire des interfaces utilisateur. Il se distingue par sa facilité d'utilisation, sa flexibilité et sa performance. Vue.js est conçu comme une amélioration de l'HTML permettant de créer des interfaces réactives plus simplement à l'aide d'attributs spéciaux.</p>
                    <p>Dans ce cours, nous allons commencer par découvrir les bases du framework (la syntaxe, la réactivité, ...). Puis, après quelques exercices, on étudiera plus en profondeur le fonctionnement interne de Vue.js pour comprendre ses subtilités et découvrir des cas d'utilisations plus spécifiques.</p>
                    <p>Enfin, on finira en étudiant l'écosystème autour de Vue.js pour découvrir les librairies intéressantes.</p>
                    <h3>Pourquoi un framework ?</h3>
                    <p>Quand on crée une interface complexe, il est souvent difficile de maintenir l'interface (le DOM) synchronisé avec l'état système.</p>
                    <p>Vue.js utilise un système de template qui va permettre de décrire la structure HTML attendue. Cette structure se mettra à jour automatiquement lorsque l'état change.</p>
                    <h3>Pourquoi Vue.js ?</h3>
                    <p>Il existe aujourd'hui plusieurs framework et on peut se demander pourquoi utiliser Vue.js plutôt qu'un autre framework.</p>
                    <ul>
                        <li>
                            <p><span class="em">Simple à prendre en main</span>, son approche pensée comme de l'HTML améliorée permet une prise en main rapide.</p>
                        </li>
                        <li>
                            <p><span class="em">Gestion des transitions</span>, Vue.js intègre un système de transition qui permet de gérer facilement l'appartition et la disparition d'élément.</p>
                        </li>
                        <li>
                            <p>Un <span class="em">écosystème</span> conséquent permet de trouver de nombreuses librairies pour accélérer le développement.</p>
                        </li>
                        <li>
                            <p>De <span class="em">bonnes performances</span> obtenues grâce à l'utilisation d'un compiler.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="installation">L'nstallation de Vue.js :</h2>
                    <p>Dans cette partie, nous allons voir comment initialiser un projet en utilisant le framework Vue.js. Pour commencer à travailler, plusieurs solutions s'offrent à vous :</p>
                    <ul>
                        <li>
                            <p>En ligne à l'aide du <a href="https://play.vuejs.org/#eNo9jcEKwjAMhl/lt5fpQYfXUQfefAMvvRQbddC1pUuHUPrudg4HIcmXjyRZXEM4zYlEJ+T0iEPgXjn6BB8Zhp46WUZWDjCa9f6w9kAkTtH9CRinV4fmRtZ63H20Ztesqiylphqy3R5UYBqD1UyVAPk+9zkvV1CKbCv9poMLiTEfR2/IXpSoXomqZLtti/IFwVtA9A==" target="_blank">playground Vue.js</a>.</p>
                        </li>
                        <li>
                            <p>En ligne via <a href="https://vite.new/vue" target="_blank">StackBlitz</a>.</p>
                        </li>
                        <li>
                            <p>En créant un projet en local à l'aide du kit de démarrage offert par vue (<span class="html">npm create vue@latest</span>).</p>
                        </li>
                    </ul>
                    <p>Après avoir ouvert le dossier contenant votre projet dans VSCode, on doit installer les dépendances avec la commande :</p>
<pre><code>npm install</code></pre>
                    <p>Dans VSCode, on peut installer l'extension "Vue - Officiel" pour avoir la coloration syntaxique de Vue.js.</p>
                    <p>Pour démarrer le projet, on fait :</p>
<pre><code>npm run dev</code></pre>
                    <p>On doit pas relancer la commande précédente à chaque fois qu'on modifie un fichier dans notre projet.</p>
                    <p>Dans un fichier Vue, dont l'extension est "<span class="em">.vue</span>", on a une balise <span class="html">&lt;template&gt;</span> contenant le contenu HTML de notre composant.</p>
                    <p>Dans ce fichier, on a également une balise <span class="html">&lt;script&gt;</span> avec l'attribut <span class="html">setup</span> contenant le JS de notre composant.</p>
                    <p>Enfin, dans ce même fichier, on a une balise <span class="html">&lt;style&gt;</span> contenant le style de notre composant. On peut lui rajouter l'attribut <span class="html">scoped</span> pour que ce style soit uniquement pour ce composant.</p>
                    <p>Par exemple, le fichier `App.vue` :</p>
<pre><code>&lt;template&gt;
    &lt;h1&gt;Bonjour {{ firstName }}&lt;/h1&gt;
    &lt;p&gt;Comment allez-vous ?&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
    const firstName = "Driss";
&lt;/script&gt;

&lt;style&gt;
    h1 {
        color: red;
    }
&lt;/style&gt;</code></pre>
                </article>
                <article>
                    <h2 id="syntaxe">La syntaxe Vue.js :</h2>
                    <p>Dans cette partie, nous allons découvrir la syntaxe permettant de décrire la structure HTML générée par Vue.js. <a href="https://vuejs.org/guide/essentials/template-syntax.html" target="_blank">Pour plus de détails sur les éléments de syntaxes détaillés ci-dessous, vous pouvez utiliser la documentation.</a></p>
                    <p>Ensuite, nous allons voir comment créer des variables réactives à l'aide de <a href="https://vuejs.org/guide/essentials/reactivity-fundamentals.html" target="_blank">la fonction ref()</a>.</p>
                    <p>N.B : la fonction <span class="html">v-hide</span> n'est pas accessible nativement, elle nécessite l'installation d'un package supplémentaire (<span class="em">@ventralnet/v-hide</span>).</p>
                    <p>Pour mieux comprendre la syntaxe, on va faire l'exemple du compteur :</p>
<pre><code>&lt;template&gt;
    &lt;p :id="`p-${count}`" :class="{active: count &gt; 5}"&gt;Compteur : {{ count }}&lt;/p&gt;
    &lt;div v-show="count &gt;= 5"&gt;Bravo, vous avez cliqué plus de 5 fois !&lt;/div&gt;
    &lt;button @click="increment"&gt;Incrémenter&lt;/button&gt;
    &lt;button :style="{color: 'red'}" @click="decrement"&gt;Décrémenter&lt;/button&gt;
    &lt;hr&gt;
    &lt;button @click="sortMovies"&gt;Réorganiser&lt;/button&gt;

    &lt;form action="" @submit.prevent="addMovie"&gt;
        &lt;label for="newMovie"&gt;Nouveau film&lt;/label&gt;
        &lt;input type="text" id="newMovie" v-model="movieName"&gt;
        &lt;button&gt;Ajouter&lt;/button&gt;
        {{ movieName }}
    &lt;/form&gt;

    &lt;button @click.prevent="randomAge"&gt;Change âge&lt;/button&gt;
    
    &lt;ul&gt;
        &lt;li v-for="movie in movies" :key="movie"&gt;
            {{ movie }} &lt;button @click="deleteMovie(movie)"&gt;Supprimer&lt;/button&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';

    const count = ref(0);

    const movies = ref([
        'Matrix',
        'Lilo &amp; Stitch',
        'Titanic'
    ]);

    const movieName = '';

    const person = ref({
        firstname: 'John',
        lastname: 'Doe',
        age; 20
    });
    
    const increment = (event) =&gt; {
        count.value++;
    };
    
    const decrement = () =&gt; {
        count.value--;
    };

    const deleteMovie = (movie) =&gt; {
        movies.value = movies.value.filter(m =&gt; m !== movie);
    };

    const sortMovies = () =&gt; {
        movies.value.sort((a, b) =&gt; a &gt; b ? 1 : -1);
    };

    const addMovie = () =&gt; {
        movies.value.push(movieName.value);
        movieName.value = '';
    };

    const randomAge = () =&gt; {
        person.value.age = Math.round(Math.random() * 100);
    };
&lt;/script&gt;

&lt;style&gt;
    .active {
        color: red;
    }
&lt;/style&gt;</code></pre>
                    <p><span class="html">v-if</span> supprime l'élément du DOM par rapport à <span class="html">v-show</span> (inverse du <span class="html">v-hide</span>).</p>
                </article>
                <article>
                    <h2 id="exercice_todolist">Exercice de la Todolist :</h2>
                    <p>Afin d'assoir les notions vues jusqu'à maintenant, je vous propose un petit TP (Travaux Pratiques) qui permettra de les pratiquer.</p>
                    <h3>Objectifs :</h3>
                    <p>Pour ce premier TP, votre objectif est de créer un petit système de tâches à faire.</p>
                    <ul>
                        <li>
                            <p>On affiche un message s'il n'y a pas de tâches à faire.</p>
                        </li>
                        <li>
                            <p>Un champ texte accompagné d'un bouton "Ajouter" sera présent au-dessus de la liste et permettra d'ajouter une nouvelle tâche.</p>
                        </li>
                        <li>
                            <p>Pour chaque tâche, une case à cocher permettra de maruqer la tâche comme faite.</p>
                        </li>
                        <li>
                            <p>Une tâche terminée sera barrée (à l'aide de CSS).</p>
                        </li>
                        <li>
                            <p>Les tâches à faire seront toujours affichées en premier.</p>
                        </li>
                        <li>
                            <p>Une case, en bas de liste, permettra de masquer les tâches terminées.</p>
                        </li>
                    </ul>
                    <p>Les tâches respecteront le format suivant :</p>
<pre><code>[
    { "title": "Acheter la propriété 'Rue de la Paix'", "completed": false, "date": 20240730 },
    { "title": "Construire un hôtel sur 'Avenue Foch'", "completed": false, "date": 20240730 },
    { "title": "Éviter la case prison", "completed": false, "date": 20240730 }
]</code></pre>
                    <p>Voici la correction qui se trouve dans le fichier `App.vue` :</p>
<pre><code>&lt;template&gt;
    &lt;form action="" @submit.prevent="addTodo"&gt;
        &lt;fieldset role="group"&gt;
            &lt;input type="text" placeholder="Tâche à effectuer" v-model="newTodo"&gt;
            &lt;button :disabled="newTodo.length === 0"&gt;Ajouter&lt;/button&gt;
        &lt;/fieldset&gt;
    &lt;/form&gt;
    &lt;p v-if="todo.length === 0"&gt;Vous n'avez pas de tâches à faire !&lt;/p&gt;
    &lt;div v-else&gt;
        &lt;ul&gt;
            &lt;li v-for="todo in sortedTodos()" :key="todo.key" :class="{completed: todo.completed}"&gt;
                &lt;label&gt;
                    &lt;input type="checkbox" v-model="todo.completed"&gt;
                    {{ todo.title }}
                &lt;/label&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;label&gt;
            &lt;input type="checkbox" v-model="hideCompleted"&gt;
            Masquer les tâches complétées
        &lt;/label&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';

    const newTodo = ref('');

    const hideCompleted = ref(false);

    const todos = ref([]);

    const addTodo = () =&gt; {
        todos.value.push({
            title: newTodo.value,
            completed: false,
            date: Date.now()
        });
        newTodo.value = '';
    };

    const sortedTodos = () =&gt; {
        const sortedTodos = todos.value.toSorted((a, b) =&gt; a.completed &gt; b.completed ? 1 : -1);
        if (hideCompleted.value) {
            return sortedTodos.filter(t =&gt; !t.completed);
        }
        return sortedTodos;
    };
&lt;/script&gt;

&lt;style&gt;
    .completed {
        opacity: .5;
        text-decoration: line-throught;
    }
&lt;/style&gt;</code></pre>
                </article>
                <article>
                    <h2 id="proprietes_calculees">Les propriétés calculées :</h2>
                    <p>Précédemment, on a vu le concept de <span class="html">ref()</span> qui sont des variables réactives qui peuvent être observée par Vue.js pour synchroniser la structure du DOM. On aura parfois besoin de dériver une valeur à partir d'une ref. On pourra dans ce cas-là utiliser la méthode <span class="html">computed()</span> qui permet de générer une nouvelle valeur réactive qui évoluera quand la variable interne utilisée change.</p>
<pre><code>import { ref, computed } from 'vue';
const count = ref(0);
const double = computed(() =&gt; count.value * 2);</code></pre>
                    <p>Dans ce cas-là, la variable <span class="em">double</span> peut être utilisée dans la partie <span class="html">&lt;template&gt;</span> et se mettra à jour dès que la valeur de <span class="em">count</span> changera.</p>
                    <p>Dans l'exemple de notre Todolist, on peut utiliser la méthode <span class="html">computed()</span> pour la constante <span class="em">sortedTodos</span> comme ceci :</p>
<pre><code>const sortedTodos = computed(() =&gt; {
    const sortedTodos = todos.value.toSorted((a, b) =&gt; a.completed &gt; b.completed ? 1 : -1);
    if (hideCompleted.value) {
        return sortedTodos.filter(t =&gt; !t.completed);
    }
    return sortedTodos;
});</code></pre>
                    <p>Dans cet exemple, on peut rajouter la propriété calculée <span class="em">remainingTodos</span> qui retourne le nombre de tâches encore à faire et l'afficher dans le template :</p>
<pre><code>const remainingTodos = computed(() =&gt; {
    return todos.value.filter(t =&gt; !t.completed).length;
});</code></pre>
<pre><code>&lt;p v-if="remainingTodos &gt; 0"&gt;
    {{ remainingTodos }} tâche{{ remainingTodos &gt; 's' ? '' }} à faire
&lt;/p&gt;</code></pre>
                </article>
                <article>
                    <h2 id="composants">Les composants :</h2>
                    <p>Jusqu'à maintenant, nous avons écrit l'ensemble de la logique de notre application dans un seul et unique fichier `<span class="em">App.vue</span>`. Mais, ce qui va être particulièrement intéressant avec Vue.js c'est sa capacité à créer des composants qui vont avoir leur propre logique et que l'on va pouvoir réutiliser.</p>
                    <p>Pour plus d'informations, vous pouvez consulter <a href="https://vuejs.org/guide/essentials/component-basics.html" target="_blank">la documentation sur les composants</a>.</p>
                    <p>On peut séparer notre application sur la Todolist en plusieurs fichiers, dont le fichier `<span class="em">Checkbox.vue</span>` qui pourrait, comme son nom l'indique, afficher une case à cocher :</p>
<pre><code>&lt;template&gt;
    &lt;label&gt;
        &lt;input type="checkbox" v-model="model"&gt;
        {{ label }}
    &lt;/label&gt;
&lt;/template&gt;

&lt;script setup&gt;
    const model = defineModel();

    defineProps({
        label: String
    });

    const emits = defineEmits(['check', 'uncheck']);

    const onChange = (event) =&gt; {
        if (event.currentTarget.checked) {
            emits('check', event.currentTarget);
        } else {
            emits('uncheck', event.currentTarget);
        }
    }
&lt;/script&gt;</code></pre>
                    <p>Et ainsi, dans notre vue, on va ajouter ce nouveau composant en modifiant notre code au bon endroit :</p>
<pre><code>&lt;template&gt;
    &lt;Checkbox :label="todo.title" v-model="todo.completed"/&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import Checkbox from './Checkbox.vue';
&lt;/script&gt;</code></pre>
                    <p>Pour parler d'héritage, c'est-à-dire pour passer des propriéts d'un composant parent à un ou des composants enfants, on va créer un nouveau composant dans le fichier `<span class="em">Button.vue</span>` :</p>
<pre><code>&lt;template&gt;
    &lt;button class="secondary"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
&lt;/template&gt;</code></pre>
                    <p>La balise <span class="html">&lt;slot&gt;</span> permet de récupérer le contenu entre la balise ouvrante et la balise fermante de notre composant comme ceci :</p>
<pre><code>&lt;template&gt;
    &lt;Button&gt;
        &lt;strong&gt;Demo&lt;/strong&gt; de bouton
    &lt;/Button&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import Button from './Button.vue';
&lt;/script&gt;</code></pre>
                    <p>On peut avoir plusieurs balises <span class="html">&lt;slot&gt;</span> dans un composant. Pour illustrer ceci, on va créer un composant `<span class="em">Layout.vue</span>` qui crée la structure de notre page de manière générale :</p>
<pre><code>&lt;template&gt;
    &lt;div class="layout"&gt;
        &lt;header v-if="$slots.header"&gt;
            &lt;slot name="header"&gt;&lt;/slot&gt;
        &lt;/header&gt;
        &lt;aside&gt;
            &lt;slot name="aside"&gt;&lt;/slot&gt;
        &lt;/aside&gt;
        &lt;main&gt;
            &lt;slot name="main"&gt;&lt;/slot&gt;
        &lt;/main&gt;
        &lt;footer&gt;
            &lt;slot name="footer"&gt;&lt;/slot&gt;
        &lt;/footer&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
    .layout {
        display: grid;
        grid-template-columns: 200px 1fr;
    }
    
    .layout &gt; * {
        border: 1px solid red;
    }

    .layout header,
    .layout footer {
        grid-column: 1 / -1;
    }
&lt;/style&gt;</code></pre>
                    <p>Dans notre fichier par défaut, `<span class="em">App.vue</span>`, on va importer notre composant comme ceci :</p>
<pre><code>&lt;template&gt;
    &lt;Layout&gt;
        &lt;template #header&gt;
            En-tête
        &lt;/template&gt;
        &lt;template #aside&gt;
            Sidebar
        &lt;/template&gt;
        &lt;template #main&gt;
            Main
        &lt;/template&gt;
        &lt;template #footer&gt;
            Footer
        &lt;/template&gt;
    &lt;/Layout&gt;
&lt;/template&gt;</code></pre>
                </article>
                <article>
                    <h2 id="cycle_vie_composants">Le cycle de vie des composants :</h2>
                    <p>Dans cette partie, nous allons découvrir <a href="https://vuejs.org/guide/essentials/lifecycle.html" target="_blank">le cycle de vie des composants</a> et comment on peut utiliser les fonctions associées pour venir rajouter de la logique à certains moments clefs.</p>
                    <p>Toujours dans notre exemple de Todolist, on va utiliser des méthodes du cycle de vie comme <span class="html">onMounted()</span> et <span class="html">onUnmounted()</span> :</p>
<pre><code>const todos = ref();

onMounted(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/todos')
    .then(r =&gt; r.json())
    .then(v =&gt; todos.value = v.map(todo =&gt; ({ ...todo, date: todo.id })));
});</code></pre>
                </article>
                <article>
                    <h2 id="observateurs">Les observateurs :</h2>
                    <p><a href="https://vuejs.org/guide/essentials/watchers.html" target="_blank">Les watchers</a> permettent d'observer manuellement une valeur réactive pour déclencher un comportement spécial lors du changement.</p>
<pre><code>const count = ref(0);

watch(count, (newValue, oldValue) =&gt; {
    // Sera appelé lorsque la valeur de count change
});</code></pre>
                    <p>Il est aussi possible d'utiliser la fonction <span class="html">watchEffect()</span> qui sera capable d'observer automatiquement ses dépendances pour se redéclencher automatiquement lorsqu'une valeur change.</p>
<pre><code>const count = ref(0);

watchEffect(() =&gt; {
    console.log(count.value); // Détecte que l'on dépend de count
});</code></pre>
                    <p>La fonction <span class="html">watch()</span> contient un troisième paramètre qui est facultatif qui permet de dire si c'est immédiat ou pas (par défaut, c'est à <span class="em">false</span>) :</p>
<pre><code>&lt;template&gt;
    &lt;input type="text" v-model="name"&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref, watch } from 'vue';

    const name = ref('');

    watch(name, (newValue, oldValue) =&gt; {
        document.title = newValue;
    }, { immediate: true });
&lt;/script&gt;</code></pre>
                    <p>Comme cette partie est assez courte, on va parler de compositions avec l'exemple d'une fonction <span class="em">useTimer()</span> qui va se trouver dans le fichier `<span class="em">src/composable/useTimer.js</span>` :</p>
<pre><code>import { onMounted, onUnmounted, ref } from 'vue';

export function useTimer (initial = 0) {
    const time = ref(initial);

    let timer;
    
    onMounted(() =&gt; {
        timer = setInterval(() =&gt; {
            time.value++;
        }, 1_000);
    });

    onMounted(() =&gt; {
        clearInterval(timer);
    });

    return {
        time,
        reset() {
            clearInterval(timer);
            timer = setInterval(() =&gt; {
                time.value++;
            }, 1_000);
            time.value = 0;
        }
    };
};</code></pre>
<pre><code>&lt;template&gt;
    &lt;input type="text" v-model="page.title"&gt;
    Temps écoulé : {{ time }}
    &lt;button @click="reset"&gt;Reset&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref, watch, watchEffect } from 'vue';
    import { useTimer } from './composable/useTimer.js';

    const { time, reset } = useTimer();
    
    const page = ref({
        title: ''
    });

    watchEffect(() =&gt; {
        document.title = page.value.title;
    });
&lt;/script&gt;</code></pre>
                </article>
                <article>
                    <h2 id="Quiz">Le TP du Quiz :</h2>
                    <p>Maintenant que l'on a vu pas mal de nouvelles notions, je vous propose de les mettre en pratique à travers la création d'un système de Quiz. Voici un exemple de JSON pour vous exercer :</p>
<pre><code>{
    "title": "Questionnaire sur les Films et Séries",
    "minimum_score": 4,
    "success_message": "Félicitations! Vous êtes un véritable cinéphile!",
    "failure_message": "Dommage! Vous devriez regarder plus de films et séries.",
    "questions": [
        {
            "question": "Dans quel film trouve-t-on le personnage de Jack Dawson?",
            "choices": ["Titanic", "Le Seigneur des Anneaux", "Inception", "Avatar"],
            "correct_answer": "Titanic"
        },
        {
            "question": "Quelle série met en scène le personnage de Walter White?",
            "choices": [
                "Breaking Bad",
                "Stranger Things",
                "Game of Thrones",
                "The Walking Dead"
            ],
            "correct_answer": "Breaking Bad"
        },
        {
            "question": "Dans quel film Harry Potter rencontre-t-il pour la première fois Lord Voldemort?",
            "choices": [
                "Harry Potter à l'école des sorciers",
                "Harry Potter et la Chambre des secrets",
                "Harry Potter et le Prisonnier d'Azkaban",
                "Harry Potter et la Coupe de feu"
            ],
            "correct_answer": "Harry Potter à l'école des sorciers"
        },
        {
            "question": "Quel est le nom de l'intelligence artificielle dans '2001: L'Odyssée de l'espace'?",
            "choices": ["HAL 9000", "Siri", "Cortana", "Jarvis"],
            "correct_answer": "HAL 9000"
        },
        {
            "question": "Qui joue le rôle principal dans la série 'Sherlock' de la BBC?",
            "choices": [
                "Benedict Cumberbatch",
                "David Tennant",
                "Matt Smith",
                "Tom Hiddleston"
            ],
            "correct_answer": "Benedict Cumberbatch"
        }
    ]
}</code></pre>
                    <p>Quand on va commencer à créer une application avec Vue.js, la première chose que vous devez faire c'est d'essayer de commencer à décomposer et réfléchir aux composants que vous aurez besoin.</p>
                    <p>Pour l'exercice du Quiz, en plus de l'application dans `<span class="em">App.vue</span>`, j'aurais mis les composants Quiz, Progress, Question et Radio, mais ça peut changer au fil du développement.</p>
                    <p>Le code JSON ci-dessus va être dans le fichier `<span class="em">quiz.json</span>` dans le dossier <span class="em">public</span> de notre projet.</p>
                    <p>Pour pas que ma page ait un style dégeulasse, je vais utiliser Pico mais vous pouvez utiliser n'importe quel framework CSS et je rajoute dans mon fichier `<span class="em">index.html</span>` :</p>
<pre><code>&lt;link rel="stylesheet" href="https://cdn.jsdeliver.net/npm/@picocss/pico@2/css/pico.pumpkin.min.css"&gt;</code></pre>
                    <p>Dans mon application, la première étape est de charger les données du fichier JSON avec la méthode <span class="html">onMounted()</span> avec un <span class="html">fetch</span> :</p>
<pre><code>&lt;template&gt;
    &lt;div class="container"&gt;
        &lt;div v-if="state === 'error'"&gt;
            Impossible de charger le quiz
        &lt;/div&gt;
        &lt;div :aria-busy="state === 'loading'"&gt;
            {{ quizz }}
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { onMounted, ref } from 'vue';

    const quiz = ref(null);

    const state = ref('loading');

    onMounted(() =&gt; {
        fetch('/quiz.json')
            .then(r =&gt; {
                if (r.ok) {
                    return r.json();
                }
                throw new Error('Impossible de récupérer le json');
            })
            .then(data =&gt; {
                quiz.value = data;
                state.value = 'idle';
            })
            .catch(e =&gt; {
                state.value = 'error';
            });
    });
&lt;/script&gt;

&lt;style&gt;
    .container {
        margin-top: 2rem;
    }
&lt;/style&gt;</code></pre>
                    <p>C'est parti pour créer notre premier composant : `<span class="em">components/Quiz.vue</span>` :</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;{{ quiz.title }}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';

    const props = defineProps({
        quiz: Object
    });

    const step = ref(0);
&lt;/script&gt;</code></pre>
                    <p>Dans notre App, on oublie pas de l'importer et de modifier le code en conséquence :</p>
<pre><code>&lt;Quiz :quiz="quiz" v-if="quiz"/&gt;

import Quiz from './components/Quiz.vue';</code></pre>
                    <p>Ensuite, comme on a besoin d'une barre de progression, on va créer le composant <span class="em">Progress</span> :</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        Étape {{ value + 1 }}/{{ max + 1 }}
        &lt;progress :value="value" :max="max"&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
    defineProps({
        value: Number,
        max: Number
    });
&lt;/script&gt;</code></pre>
                    <p>Également, on oublie pas de l'importer dans notre composant <span class="em">Quiz</span> :</p>
<pre><code>&lt;Progress :value="step" :max="quiz.questions.length - 1"/&gt;

import Progress from './Progress.vue';</code></pre>
                    <p>Ensuite, on va créer le composant `<span class="em">Question.vue</span>` et on n'oublie pas de l'importer dans notre `<span class="em">Quiz.vue</span>` :</p>
<pre><code>&lt;template&gt;
    &lt;div class="question"&gt;
        &lt;h3&gt;{{ question.question }}&lt;/h3&gt;
        &lt;ul&gt;
            &lt;li v-for="(choice, index) in question.choices" :key="choice"&gt;
                &lt;label :for="`answer${index}`"&gt;
                    &lt;input type="radio" name="answer" :id="`answer${index}`" :value="choice" v-model="answer" :disabled="hasAnswer"&gt;
                    {{ choice }}
                &lt;/label&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;button :disabled="!hasAnswer" @click="emits('answer', answer)"&gt;Question suivante&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { computed, ref } from 'vue';

    const props = defineProps({
        question: Object
    });

    const emits = defineEmits(['answer']);

    const answer = ref(null);

    const hasAnswer = computed(() =&gt; answer.value !== null);
&lt;/script&gt;

&lt;style&gt;
    .question {
        padding-top: 2rem;
    }

    .question button {
        margin-left: auto;
        display: block;
    }
&lt;/style&gt;</code></pre>
<pre><code>&lt;Question :key="question.question" :question="question" v-if="state === 'question'" @answer="addAnswer"/&gt;

import Question from './Question.vue';

const question = computed(() =&gt; props.quiz.questions[step.value]);

const state = ref('question');

const answers = ref(props.quiz.questions.map(() =&gt; null));

const addAnswer = (answer) =&gt; {
    answers.value[choice.value] = answer;
    if (step.value === props.quiz.questions.length - 1) {
        state.value = 'recap';
    } else {
        step.value++;
    }
};</code></pre>
                    <p>On va créer un nouveau composant <span class="em">Recap.vue</span> qui va afficher le score final quand la constante <span class="em">state</span> de <span class="em">Quiz.vue</span> a la valeur <span class="em">recap</span> :</p>
<pre><code>&lt;template&gt;
    &lt;h1&gt;Recap&lt;/h1&gt;
    &lt;p&gt;{{ hasWon ? quiz.success_message : quiz.failure_message }}&lt;/p&gt;
    &lt;p&gt;Score : {{ score }}/{{ quiz.questions.length }}&lt;/p&gt;
&lt;/template&gt;
&lt;script setup&gt;
    import { computed } from 'vue';

    const props = defineProps({
        quiz: Object,
        answers: Array
    });

    const score = computed(() =&gt; {
        return props.quiz.questions.reduce ((acc, question, k) =&gt; {
            if (question.correct_answer === props.answers[k]) {
                return acc + 1;
            }
            return acc;
        }, 0);
    });

    const hasWon = computed(() =&gt; score.value &gt;= props.quiz.minimum_score);
&lt;/script&gt;</code></pre>
<pre><code>&lt;Recap v-if="state === 'recap'" :answers="answers" :quiz="quiz"/&gt;</code></pre>
                    <p>Pour ne pas afficher les choix tout le temps dans le même ordre, on peut créer une liste aléatoire de choix qui permet à chaque fois qu'on rafraîchit la page d'avoir les choix mélangés.</p>
                    <p>Si on veut utiliser la méthode pour mélanger un tableau dans plusieurs composants, on peut l'exporter dans un nouveau fichier : <span class="em">functions/array.js</span> qui, comme son nom l'indique, contiendra toutes les méthodes qu'on veut utiliser sur des tableaux :</p>
<pre><code>export function shuffleArray(arr) {
    return arr.map(item =&gt; ({value: item, sort: Math.random()}))
        .sort((a, b) =&gt; a.sort - b.sort)
        .map(item =&gt; item.value);
};</code></pre>
<pre><code>import { shuffleArray } from '@/functions/array.js;

const renderChoices = computed(() =&gt; shuffleArray(props.question.choices));</code></pre>
                    <p>Comme il y a déjà beaucoup de code dans notre composant <span class="em">Question</span>, on va créer un nouveau composant `<span class="em">Answer.vue</span>` que l'on va importer dedans :</p>
<pre><code>&lt;template&gt;
    &lt;label :for="id" :class="classes"&gt;
        &lt;input type="radio" :disabled="disabled" :id="id" name="answer" v-model="model" :value="value"&gt;
        {{ value }}
    &lt;/label&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { computed } from 'vue';

    const props = defineProps({
        id: String,
        disabled: Boolean,
        value: String,
        correctAnswer: String
    });

    const model = defineModel();

    const classes = computed(() =&gt; ({
        disabled: props.disabled,
        right: props.disabled &amp;&amp; props.value === props.correctAnswer,
        wrong: props.disabled &amp;&amp; props.value !== props.correctAnswer &amp;&amp; model.value === props.value
    }));
&lt;/script&gt;

&lt;style&gt;
    .disabled {
        opacity: .5;
    }

    .right {
        opacity: 1;
        color: green;
    }

    .wrong {
        opacity: 1;
        color: red;
    }
&lt;/style&gt;</code></pre>
<pre><code>&lt;Answer :id="`answer${index}`" :disabled="hasAnswer" :value="choice" v-model="answer" :correctAnswer="question.correct_answer"/&gt;

import Answer from './Answer.vue';</code></pre>
                    <p>Si on veut rajouter un timer pour dire que si l'on ne répond pas à une question en temps voulu on passe directement à la question suivante. Donc, on va supprimer le bouton "Question suivante" dans le composant <span class="em">Question</span> et on y rajoute le timer :</p>
<pre><code>import { onMounted, onUnmounted } from 'vue';
    
let timer;

onMounted(() =&gt; {
    timer = setTimeout(() =&gt; {
        emits('answer', answer.value);
    }, 3_000);
});

onUnmounted(() =&gt; {
    clearTimeout(timer);
});</code></pre>
                    <p>On va rajouter un événement <span class="em">@change="onChange"</span> dans le input :</p>
<pre><code>const emits = defineEmits(['change']);

const onChange = (event) =&gt; {
    emits('change', event);
};</code></pre>
                    <p>Enfin, dans le composant <span class="em">Question</span>, on va ajouter l'événement <span class="html">@change="onAnswer"</span> :</p>
<pre><code>const onAnswer = () =&gt; {
    clearTimeout(timer);
    timer = setTimeout(() =&gt; {
        emits('answer', answer.value);
    }, 1_5OO);
};

onMounted(() =&gt; {
    timer = setTimeout(() =&gt; {
        answer.value = '';
        onAnswer();
    }, 3_000);
});</code></pre>
                </article>
                <article>
                    <h2 id="composition_option">Composition ou Option :</h2>
                    <p>Si vous avez fait un tour sur la documentation, vous avezz dû remarquer la présence d'un bouton permettant de changer le format de code. Mais à quoi correspond ces formats ?</p>
                    <h3>L'API option :</h3>
                    <p>Depuis le début de ce cours, on a utilisé l'API Composition mais il existe une autre approche qui utilise un objet d'option.</p>
<pre><code>&lt;script&gt;
    export default {
        data() {
            return {
                author: {
                    name: 'John Doe',
                    books: [
                        'Vue 2 - Advanced Guide',
                        'Vue 3 - Basic Guide',
                        'Vue 4 - The Mystery'
                    ]
                }
            };
        },
        computed: {
            // a computed getter
            publishedBooks() {
                // `this` points to the component instance
                return this.author.books.length;
            }
        }
    };
&lt;/script&gt;</code></pre>
                    <p>Cette manière d'écrire les composants est héritée de la version 2 de Vue.js mais n'est pas conseillée si vous commencez un nouveau projet. Elle avait comme principal inconvénient de rendre difficile la réutilisation de logique.</p>
                    <h3>Le setup :</h3>
                    <p>Pour pallier au problème de réutilisation, l'API composition a été introduite lors de la version 3 et utilisait une option <span class="html">setup</span>.</p>
<pre><code>&lt;script&gt;
    export default {
        setup() {
            const author = ref({
                name: 'John Doe',
                books: [
                    'Vue 2 - Advanced Guide',
                    'Vue 3 - Basic Guide',
                    'Vue 4 - The Mystery'
                ]
            });
            const publishedBooks = computed(() =&gt; author.value.books.length);
            return {
                author,
                publishedBooks
            };
        };
    };
&lt;/script&gt;</code></pre>
                    <p>Pour simplifier la syntaxe, l'attribut <span class="html">setup</span> a été introduit pour simplifier encore plus la syntaxe.</p>
<pre><code>&lt;script setup&gt;
    const author = ref({
        name: 'John Doe',
        books: [
            'Vue 2 - Advanced Guide',
            'Vue 3 - Basic Guide',
            'Vue 4 - The Mystery'
        ]
    });
    const publishedBooks = computed(() =&gt; author.value.books.length);
&lt;/script&gt;</code></pre>
                    <p>C'est cette syntaxe que l'on utilisera aujourd'hui par défaut lorsque l'on travaille avec Vue.</p>
                </article>
                <article>
                    <h2 id="comprendre_reactivite">Comprendre la réactivité :</h2>
                    <p>Dans cette partie, nous allons explorer plus en profondeur le fonctionnement de la réactivité pour comprendre comment Vue.js gère la synchronisation entre le DOM et l'état. Nous allons pour cela explorer le code généré lorsque l'on construit le projet.</p>
                    <h3>unref() :</h3>
                    <p>Lorsqu'on avait vu la partie template, on a remarqy" qu'il n'était pas nécessaire d'écrire le <span class="html">.value</span> lorsqu'on fait référence à une ref. En analysant le code compilé, on remarque que Vue.js utilise systèmatiquement <span class="html">unref()</span> lors de l'accès aux variables de premier niveau. Cette méthode permet d'accéder à la propriété <span class="html">value</span> est une ref.</p>
                    <p>Ainsi <span class="em">&lt;h1gt;{{ msg }}&gt;</span> devient :</p>
<pre><code>createElementVNode("h1", null, toDisplayString(unref(msg)), 1);</code></pre>
                    <h3>VirtualDOM :</h3>
                    <p>Le second point est l'utilisation du virtual DOM. Un composant est une fonction qui va renvoyer un objet représentant la structure attendue. Cette structure est appelée du virtual DOM. Lorsque l'état change, la fonction est ré-exécutée pour renvoyer une nouvelle structure virtual DOM. En comparant cette structure à la précédente, Vue.js sera capable de déterminer les changeements à faire au niveau du DOM réel.</p>
                    <h3>Watchers :</h3>
                    <p>Maintenant, si on regarde le code d'un composant compilé, voici ce que l'on obtient :</p>
<pre><code>const __sfc__ = {
    __name: 'App',
    setup(__props) {

        const msg = ref('hello');

        return (_ctx, _cache) =&gt; {
            return (_openBlock(), _createElementBlock(_Fragment, null, [
                _createElementVNode("h1", null, _toDisplayString(msg.value), 1 /* TEXT */),
                _withDirectives(_createElementVNode("input", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event =&gt; ((msg).value = $event))
                }, null, 512, /* NEED_PATCH */), [
                    [_vModelText, msg.value]
                ])
            ], 64 /* STABLE_FRAGMENT */));
        };
    }
};</code></pre>
                    <p>La fonction qui génère le Virtual DOM va agir comme un <span class="html">watchEffect()</span> et Vue.js détectera automatiquement de quelle variable dynamique la fonction dépend. Lorsque la valeur d'une de ces variables change, Vue.js saura qu'il doit générer une nouvelle version du Virtual DOM.</p>
                    <p>Dans le fichier de config de notre projet, `<span class="em">vite.config.js</span>`, on va rajouter une section <span class="html">build</span> :</p>
<pre><code>build: {
    minify: false,
},</code></pre>
                    <p>Ensuite, on lance la commande suivante : <span class="html">npm run build</span>. On peut ainsi ouvrir, dans le dossier `<span class="em">dist</span>`, notre fichier JavaScript qui contient le code compilé.</p>
                </article>
                <article>
                    <h2 id="transition">Transition :</h2>
                    <p>Dans cette partie, nous allons voir comment gérer les animations dans le cadre de nos composants et nous allons découvrir le composant <a href="https://vuejs.org/guide/built-ins/transition.html" target="_blank">Transition</a> et <a href="https://vuejs.org/guide/built-ins/transition-group.html" target="_blank">TransitionGroup</a>.</p>
<pre><code>&lt;template&gt;
    &lt;button @click="toggleSpoiler"&gt;Afficher / Masquer le spoiler&lt;/button&gt;
    &lt;Transition name="fadeslide"&gt;
        &lt;div v-if="showSpoiler" class="spoiler"&gt;
            À la fin de la série, Marc Curningan meurt !
        &lt;/div&gt;
    &lt;/Transition&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';

    const showSpoiler = ref(false);

    const toggleSpoiler = () =&gt; showSpoiler.value = !showSpoiler.value;
&lt;/script&gt;

&lt;style&gt;
    .spoiler {
        padding: 1rem;
        border: 1px solid #ffffff58;
        transition: .5s;
    }

    .fadeslide-enter-from {
        opacity: 0;
        transform: translateX(10px);
    }

    .fadeslide-leave-to {
        opacity: 0;
        transform: translateX(-10px);
    }
&lt;/style&gt;</code></pre>
                    <p>Si vous avez besoin plusieurs fois de cette transition <span class="em">fadeslide</span>, on peut créer un composant `<span class="em">FadeSlideTransition.vue</span>` :</p>
<pre><code>&lt;template&gt;
    &lt;Transition name="fadeslide" mode="out-in" appear&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/Transition&gt;
&lt;/template&gt;

&lt;style&gt;
    .fadeslide-enter-active,
    .fadeslide-leave-active {
        transition: .5;
    }

    .fadeslide-enter-from {
        opacity: 0;
        transform: translateX(10px);
    }

    .fadeslide-leave-to {
        opacity: 0;
        transform: translateX(-10px);
    }
&lt;/style&gt;</code></pre>
                    <p>Pour l'exemple du <span class="html">TransitionGroup</span>, on va se créer une liste de films comme ceci :</p>
<pre><code>&lt;template&gt;
    &lt;form role="group" @submit.prevent="addMovie"&gt;
        &lt;input type="text" v-model="movie"&gt;
        &lt;button :disabled="movie.length === 0"&gt;Ajouter&lt;/button&gt;
    &lt;/form&gt;
    &lt;TransitionGroup name="list" tag="ul"&gt;
        &lt;li v-for="movie in movies" :key="movie"&gt;
            {{ movie }}
            &lt;button class="secondary" @click="removeMovie(movie)"&gt;x&lt;/button&gt;
        &lt;/li&gt;
    &lt;/TransitionGroup&gt;
    &lt;button @click="randomize"&gt;Réorganiser&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';
    import { shuffleArray } from '@/functions/array.js;

    const movies = ref([
        'Les Évadés',
        'Le Parrain',
        'The Dark Knight : Le Chevalier Noir',
        'Pulp Fiction',
        'Forrest Gump',
        'Inception'
    ]);

    const movie = ref('');

    const addMovie = () =&gt; {
        movies.value = [movie.value, ...movies.value];
        movie.value = '';
    };

    const removeMovie = (movie) =&gt; {
        movies.value = movies.value.filter(m =&gt; m !== movie);
    };

    const randomize = () =&gt; {
        movies.value = shuffleArray(movies.value);
    };
&lt;/script&gt;

&lt;style&gt;
    .list-move,
    .list-enter-active,
    .list-leave-active {
        transition: all 0.5s ease;
    }

    .list-leave-active {
        position: absolute;
    }

    .list-enter-from,
    .list-leave-to {
        opacity: 0;
        transform: translateX(30px);
    }
&lt;/style&gt;</code></pre>
                </article>
                <article>
                    <h2 id="provide_inject">Provide et Inject :</h2>
                    <p>Provide et Inject sont des fonctionnalités offertes par Vue.js qui permettent de partager des données entre un composant parent et ses descendants, sans avoir besoin de passer ces données explicitement à travers chaque composant intermédiaire. Cela peut grandement simplifier la gestion des états et la communication entre composants dans une application Vue complexe.</p>
                    <p>Le mécanisme fonctionne de la manière suivante : le composant parent utilise la propriété provide pour fournir des données, tandis que les composants descendants utilisent la propriété <span class="html">inject</span> pour recevoir ces données.</p>
                    <p>Par exemple, on peut parler du système de "dark mode", c'est-à-dire que si la page est blanche l'écriture est en noire et si la page est noire l'écriture est en blanc. On va créer le composant `<span class="em">DarkMode.vue</span>` :</p>
<pre><code>&lt;template&gt;
    &lt;slot&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { provide, ref, readonly } from 'vue';

    const darkMode = ref(true);

    provide('darkMode', {
        darkMode: readonly(darkMode),
        toggleDarkMode: () =&gt; {
            darkMode.value = !darkMode.value;
        }
    });
&lt;/script&gt;</code></pre>
                    <p>Dans notre composant <span class="em">Button.vue</span>, on peut injecter le "darkMode" :</p>
<pre><code>&lt;script setup&gt;
    const darkMode = inject('darkMode');
&lt;/script&gt;</code></pre>
                    <p>Dans notre composant <span class="em">App.vue</span>, on peut encapsuler notre composant enfant de la balise <span class="html">&lt;DarkMode&gt;</span> :</p>
<pre><code>&lt;template&gt;
    &lt;DarkMode&gt;
        &lt;Sidebar /&gt;
    &lt;/DarkMode&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import DarkMode from './components/DarkMode.vue';

    provide('darkMode', false);
&lt;/script&gt;</code></pre>
                    <p>Grâce à cela, dans notre composant <span class="em">Button.vue</span>, on peut lui rajouter une classe CSS <span class="em">dark</span> :</p>
<pre><code>const classes = computed(() =&gt; ({
    btn: true,
    dark: props.dark || unref(darkMode),
}));</code></pre>
                    <p>Dans notre composant <span class="em">Sidebar</span>, on peut modifier notre composant <span class="em">Button</span> pour pouvoir activer ou désactiver le darkMode :</p>
<pre><code>&lt;template&gt;
    &lt;Button @click="toggleDarkMode"&gt;Bonjour&lt;/Button&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { inject } from 'vue';
    import Button from './components/Button.vue';

    const { toggleDarkMode } = inject('darkMode');
&lt;/script&gt;</code></pre>
                </article>
                <article>
                    <h2 id="composants_elements_speciaux">Composants &amp; Éléments spéciaux :</h2>
                    <p>Dans cette partie, je vous propose de découvrir quelques composants et éléments spéciaux dans Vue.js comme les composants l'élément <span class="html">template</span>, l'élément <span class="html">component</span>, le composant <span class="html">KeepAlive</span>, le composant <span class="html">Teleport</span> et le composant Sync (ou plus précisément <span class="html">Suspense</span>) qui, lui, est en développement.</p>
                    <p>Dans une balise <span class="html">&lt;template&gt;</span>, on peut en imbriquer une ou plusieurs autres balises identiques :</p>
<pre><code>&lt;template&gt;
    &lt;h1&gt;Démonstration des composants&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Ducimus repudiandae vel fuga, corporis nemo accusantium odio repellat delectus assumenda est non quam dignissimos quidem, incidunt porro quos! Nemo, distinctio recusandae.&lt;/p&gt;
    &lt;label&gt;
        &lt;input type="checkbox" v-model="showCount"&gt;
        Afficher le compteur
    &lt;/label&gt;
    &lt;ul&gt;
        &lt;template v-for="item of items"&gt;
            &lt;li v-if="item % 2 === 0"&gt;
                {{ item }}
            &lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { ref } from 'vue';

    const items = [1, 2, 3, 4];

    const showCount = ref(false);
&lt;/script&gt;</code></pre>
                    <p>L'élément <span class="html">&lt;component&gt;</span> permet, comme son nom l'indique, de générer un composant dynamiquement.</p>
<pre><code>&lt;template&gt;
    &lt;h1&gt;Démonstration des composants&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Ducimus repudiandae vel fuga, corporis nemo accusantium odio repellat delectus assumenda est non quam dignissimos quidem, incidunt porro quos! Nemo, distinctio recusandae.&lt;/p&gt;
    &lt;label&gt;
        &lt;input type="checkbox" v-model="showCount"&gt;
        Afficher le compteur
    &lt;/label&gt;
    &lt;component :is="componentToShow" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
    import { computed, ref } from 'vue';
    import Compteur from './Compteur.vue';
    import Placeholder from './Placeholder.vue';

    const items = [1, 2, 3, 4];

    const componentToShow = computed(() =&gt; {
        if (showCount) {
            return Compteur;
        } else {
            return Placeholder;
        }
    });

    const showCount = ref(false);
&lt;/script&gt;</code></pre>
                    <p>Le composant <span class="html">KeepAlive</span> va vous permettre de garder des composants actifs lorsqu'ils sont démontés avec un <span class="html">v-if</span> ou lorsqu'on utilise l'élément <span class="html">component</span>.</p>
                    <p>Par exemple, dans notre code juste en haut, le compteur est remis à 0 chaque fois que le composant <span class="em">Compteur</span> est démonté car l'état n'est pas sauvegardé. Pour le garder, on va entourer l'élément <span class="html">&lt;component&gt;</span> par le composant <span class="html">&lt;KeepAlive&gt;</span> :</p>
<pre><code>&lt;KeepAlive&gt;
    &lt;component :is="componentToShow" /&gt;
&lt;/KeepAlive&gt;</code></pre>
                    <p>Attention, on notera que ce <span class="html">KeepAlive</span> va avoir un effet sur le comportement des composants enfants. En effet, les composants ne vont plus être considérés comme démontés ou montés, c'est-à-dire que, si vous utilisez le <span class="html">onMounted()</span> et le <span class="html">onUnmounted()</span> pour venir greffer des choses liées au DOM, ça peut poser un problème. À la place, vous aurez deux hooks que vous pourrez utilisez : <span class="html">onActivated()</span> et <span class="html">onDesactivated()</span>.</p>
                    <p>Le composant <span class="html">&lt;Teleport&gt;</span>, comme son nom l'indique, va permettre de téléporter un élément particulier. Par exemple, une boîte de dialogue qui sera plus dans l'élément initial mais téléporter ailleurs : dans le body.</p>
<pre><code>&lt;p&gt;
    &lt;button @click="increment"&gt;Incrémenter&lt;/button&gt;
    &lt;Teleport to="body"&gt;
        &lt;dialog open&gt;
            Lorem ipsum dolor sit, amet consectetur adipisicing elit. Officiis eligendi blanditiis officia voluptates incidunt molestias necessitatibus ut quo, error ea fugit, adipisci harum, aperiam tempore iusto. Earum inventore voluptatum aliquid corporis molestiae laborum cumque suscipit consequuntur dolores omnis sunt iste, itaque, vitae minus quis aperiam labore soluta, necessitatibus nemo. Debitis.
        &lt;/dialog&gt;
    &lt;/Teleport&gt;
&lt;/p&gt;</code></pre>
                </article>
                <article>
                    <h2 id="gerer_CSS_vuejs">Gérer le CSS avec Vue.js :</h2>
                    <p>Dans cette partie, je vous propose de découvrir comment gérer les styles au niveau de vos composants Vue.js. Par défaut, lorsque le code est compilé, le CSS dans les balises <span class="html">&lt;style&gt;</span> va être placé dans un fichier CSS séparé. Dans ces conditions, il est important de faire en sorte que les classes que l'on utilise soient uniques, mais Vue.js offre des mécaniques qui vont nous permettre de gérer automatiquement l'isolation des styles.</p>
                    <h3>Style "scoped" :</h3>
                    <p>La première mécanique est la mise en place d'un attribut <span class="html">scoped</span> au niveau de notre balise style. Cet attribut va permettre de rajouter une condition lorsque les sélecteurs CSS vont être générés.</p>
<pre><code>&lt;style scoped&gt;
    .container {}
&lt;/style&gt;</code></pre>
                    <p>Une fois compilé le sélecteur deviendra :</p>
<pre><code>.container[v-data-a6737]</code></pre>
                    <p>Vue.js va rajouter un attribut sur l'ensemble des éléments injectés dans le DOM. Cet attribut permettra au sélecteur CSS de n'impacter que les éléments qui correspondent à ce composant directement.</p>
                    <p>Vous pouvez contrôler la portée d'un sélecteur à l'aide de la pseudo-classe <span class="html">:deep()</span> :</p>
<pre><code>&lt;style scoped&gt;
    .container p {} /* deviendra ".container p[data-v-a6737]" */
    .container :deep(p) {} /* deviendra ".container[data-v-a6737] p" */
&lt;/style&gt;</code></pre>
                    <p>Pour plus d'informations, vous pouvez vous rendre sur <a href="https://vuejs.org/api/sfc-css-features.html#scoped-css" target="_blank">la page de la documentation</a>.</p>
                    <h3>Module CSS :</h3>
                    <p>Afin de limiter la portée des sélecteurs CSS, il est aussi possible d'utiliser le système de <a href="https://github.com/css-modules/css-modules" target="_blank">module CSS</a>.</p>
<pre><code>&lt;template&gt;

&lt;/template&gt;
    &lt;p :class="$style.red"&gt;This should be red&lt;/p&gt;
&lt;style module&gt;
    .red {
        color: red;
    }
&lt;/style&gt;</code></pre>
                    <h3>Style dynamique :</h3>
                    <p>Si votre style dépend d'une variable d'un composant, vous avez la possibilité d'utiliser <span class="html">v-bind</span> au niveau de la partie style.</p>
<pre><code>&lt;script setup&gt;
    import { ref } from 'vue';

    const theme = ref({
        color: 'red',
    });
&lt;/script&gt;

&lt;template&gt;
    &lt;p&gt;Bonjour&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
    p {
        color: v-bind('theme.color');
    }
&lt;/style&gt;</code></pre>
                    <p>Vue.js va générer une variable CSS qui sera changée lorsque la valeur à l'intérieur de la <span class="html">ref</span> change.</p>
                    <p>Il existe également le <span class="html">:global(sélecteur)</span> et le <span class="html">slotted(sélecteur)</span>. On peut aussi insérer du SASS, c'est-à-dire du scss :</p>
<pre><code>&lt;style scoped lang="scss"&gt;
    @use 'sass:color';

    .text {
        color: color.scale(#FF0000, $alpha: -40%);
    }
&lt;/style&gt;</code></pre>
                </article>
                <article>
                    <h2 id="vue_router">Vue Router :</h2>
                    <p><a href="https://router.vuejs.org/" target="_blank">Vue Router</a> est la bibliothèque officielle de routage pour Vue.js, essentielle pour créer des applications monopages (ou SPAs pour Single Page Applications). Elle permet de définir les routes de notre application, de gérer la navigation et de rendre des composants en fonction de l'URL. Grâce à Vue Router, on peut facilement mettre en place des fonctionnalités de navigation avancées, comme les routes imbriquées, la navigation dynamique et les transitions entre les vues.</p>
                    <p>Pour utiliser Vue Router, on va installer sa dépendance avec la commande :</p>
<pre><code>npm install vue-router</code></pre>
                    <p>Ensuite, dans notre composant <span class="em">Header</span>, on va remplacer nos balises <span class="em">a</span> par un composant nommé <span class="html">RouterLink</span> :</p>
<pre><code>&lt;RouterLink to="/"&gt;Mon site&lt;/RouterLink&gt;</code></pre>
                    <p>Dans notre composant <span class="em">App</span>, on va rajouter un composant <span class="html">&lt;RouterView/&gt;</span>. Pour gérer les différentes routes, on va créer un nouveau fichier nommé <span class="em">routed.js</span> :</p>
<pre><code>import BlogPage from './pages/BlogPage.vue';
import ContactPage from './pages/ContactPage.vue';
import HomePage from './pages/HomePage.vue';
import SinglePage from './pages/SinglePage.vue';

export const routes = [
    { path: '/', component: HomePage },
    { path: '/blog', component: BlogPage },
    { path: '/contact', component: ContactPage },
    { path : '/blog/:id', component: SinglePage },
];</code></pre>
                    <p>Dans notre fichier <span class="em">main.js</span>, on va créer le routeur :</p>
<pre><code>import { createApp } from 'vue';
import App from './App.vue';
import { createRoute, createWebHistory } from 'vue-router';
import { routes } from './routes.js';

const router = createRouter({
    history: createWebHistory(),
    routes
});

const app = createApp(App);
app.use(router);
app.mount('#app');</code></pre>
                    <p>Ainsi, on ne peut plus récupérer l'id via les props, mais on va utiliser le hook <span class="html">useRoute()</span> dans le composant :</p>
<pre><code>/*
const props = defineProps({
    id: String
});
*/
const route = useRoute();
console.log(route.params.id);</code></pre>
                    <p>Mais il y a une solution pour quand même passer l'id dans les props :</p>
<pre><code>{ path: '/blog/:id', component: SinglePage, props: true },</code></pre>
                    <p>On peut également une mettre une expression régulière sur les paramètres de l'URL afin que l'utilisateur ne rentre pas n'importe quoi dans l'URL :</p>
<pre><code>{ path: '/blog/:id(\\d+)', component: SinglePage, props: true },</code></pre>
                    <p>On peut aussi avoir une route qui capture toutes les URLS qui ne sont pas dans les choix précédents :</p>
<pre><code>{ path: ':pathMatch(.*)*', component: NotFoundPage },</code></pre>
                    <p>Enfin, on peut ajouter un nom à une route :</p>
<pre><code>{ path: '/blog/:id(\\d+)', component: SinglePage, props: true, name: 'posts.show' },</code></pre>
<pre><code>&lt;RouterLink :to="{name: 'posts.index'}"&gt;Blog&lt;/RouterLink&gt;</code></pre>
                    <p>On peut créer un layout pour plusieurs composants enfants ayant le même début de route :</p>
<pre><code>{ path: '/blog', component: BlogLayout, children: [
    { path: '', component: BlogPage, name: 'posts.index' },
    { path: ':id(\\d+)', component: SinglePage, props: true, name: 'posts.show' },
] },</code></pre>
                </article>
                <article>
                    <h2 id="tester_composants">Tester ses composants :</h2>
                    <p>Dans cette partie, je vous propose de découvrir comment tester vos composants Vue.js. Pour cela, on va se reposer sur plusieurs librairies :</p>
                    <ul>
                        <li>
                            <p><a href="https://vitest.dev/" target="_blank">Vitest</a> pour lancer les tests.</p>
                        </li>
                        <li>
                            <p><a href="https://test-utils.vuejs.org/" target="_blank">Vue test utils</a> qui offre des méthodes utiles pour tester des composants.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="gerer_etat_Pinia">Gérer l'état avec Pinia :</h2>
                    <p>Aujourd'hui, nous allons explorer ensemble <a href="https://pinia.vuejs.org/" target="_blank">Pinia</a>, un gestionnaire d'État global pour Vue.js. Même si vous pouvez créer des valeurs réactives globales en utilisant les fonctionnalités de base de Vue, Pinia offre plusieurs avantages qui peuvent simplifier votre travail et améliorer la structure de votre application.</p>
                    <h3>Les avantages :</h3>
                    <p>Pinia offre plusieurs avantages par rapport à une simple variable réactive :</p>
                    <ul>
                        <li>
                            <p>La possibilité d'inspecter l'état et de le modifier à travers <a href="https://devtools.vuejs.org/" target="_blank">l'extension Vue.js</a>.</p>
                        </li>
                        <li>
                            <p>Le support de <a href="https://pinia.vuejs.org/cookbook/hot-module-replacement.html" target="_blank">rechargement à chaud</a>.</p>
                        </li>
                        <li>
                            <p>Des <a href="https://pinia.vuejs.org/cookbook/testing.html" target="_blank">outils de tests</a>.</p>
                        </li>
                        <li>
                            <p>L'intégration dans Nuxt.js pour le rendu côté serveur.</p>
                        </li>
                    </ul>
                    <p>Au-delà de ces avantages, ce qu'offre surtout Pinia, c'est une manière d'organiser les stores bien spécifiques avec la possibilité de rajouter des extensions (comme par exemple le stockage local afin de persister l'état lors du rechargment). C'est particulièrement intéressant lorsque vous travaillez en équipe car ça permet d'avoir une organisation prédéfinie et connue.</p>
                    <h3>Pas systématique :</h3>
                    <p>Si vous n'êtes pas intéressé par le rendu côté serveur et que vous avez un cas plutôt simple, il n'est pas forcément nécessaire d'utiliser Pinia dans votre application point, même si la librairie est relativement légère, elle apporte un poids supplémentaire qui n'est pas forcément pertinent.</p>
                </article>
                <article>
                    <h2 id="TypeScript_Vuejs">TypeScript avec Vue.js :</h2>
                    <p>Dans cette partie, nous allons voir comment utiliser TypeScript dans le cadre d'un projet Vue.js. La vérification du code et la validation des composants Vue.js nécessitera l'utilisation de <a href="https://www.npmjs.com/package/vue-tsc" target="_blank">vue-tsc</a>. La méthode la plus simple est d'initialiser le projet avec le support de TypeScript dès la création du projet.</p>
<pre><code>npm create vite@latest my-vue-app -- --template vue-ts</code></pre>
                    <p>Il sera possible ensuite de préciser le langage à utiliser dans nos composants à l'aide de l'attribut <span class="html">lang</span>.</p>
<pre><code>&lt;script lang="ts" setup&gt;

&lt;/script&gt;</code></pre>
                    <p>L'utilisation de TypeScript va changer la manière de déclarer les propriétés et les événements des composants.</p>
<pre><code>&lt;script lang="ts" setup&gt;
    const props = defineProps&lt;{
        prefix: string
    }&gt;();

    const emit = defineEmits&lt;{
        change: [id: number] // named tuple syntax
        update: [value: string]
    }&gt;();

    const model = defineModel&lt;string&gt;();
&lt;/script&gt;</code></pre>
                    <p>Pour plus d'information sur les spécificités de TypeScript dans le cadre de Vue.js, n'hésitez pas à <a href="https://vuejs.org/guide/typescript/overview.html#using-vue-with-typescript" target="_blank">vous rendre sur la documentation</a>.</p>
                </article>
                <article>
                    <h2 id="Nuxt">Nuxt :</h2>
                    <p><a href="https://nuxt.com/" target="_blank">Nuxt</a> est un framework open source qui permet de créer des applications plus facilement en utilisant des composants Vue.js. Son principal objectif est de fournir une structure de projet prête à l'emploi avec le support du rendu côté serveur afin d'améliorer l'expérience utilisateur et le référencement de site développés avec Vue.js.</p>
                    <h3>Avantages :</h3>
                    <p>Nuxt offre deux avantages principaux :</p>
                    <p>Une <span class="em">structure imposée</span> qui permet de se concentrer sur le code. Il intègre vue-router mais vous n'aurez pas à définir les routes vous même. La position est le nom des fichiers vue permet à Nuxt de <a href="https://nuxt.com/docs/getting-started/views" target="_blank">générer les routes</a> pour vous.</p>
                    <p>Le rendu <span class="em">côté serveur</span> permet à Nuxt d'utiliser vos composants vue pour générer le code HTML des pages qui composent votre site. Cela permet aux visiteurs de ne pas avoir à attendre le JavaScript pour voir la page s'afficher, mais permet aussi aux moteurs de recherche de pouvoir référencer votre site convenablement. Si avez besoin de plus d'information sur les différents modes de rendu, je vous renvoie vers cette <a href="https://grafikart.fr/tutoriels/render-ssr-csr-2012"> vidéo qui explique la différence entre le rendu côté client et le rendu côté serveur</a>.</p>
                    <h3>Plusieurs modes de rendu :</h3>
                    <p>Avec Nuxt, il est donc possible de générer des pages HTML qui vont être renvoyées à l'utilisateur. Ce rendu HTML peut être fait de plusieurs manières et il est impératif de les comprendre pour bénéficier au maximum des avantages de Nuxt.</p>
                    <h4>Le rendu côté serveur (SSR) :</h4>
                    <p>Le rendu Serveur est la méthode par défaut utilisé pour rendre les pages via Nuxt. Lorsqu'un utilisateur accède à une page, le serveur exécute le code du composant et génère l'HTML pour cette page. Le rendu est ensuite envoyé au client, qui affiche simplement l'affichage HTML. Cette approche est intéressante pour des contenus dynamiques qui changent souvent mais apporte plusieurs inconvénients :</p>
                    <ul>
                        <li>
                            <p><span class="em">Surcharge du serveur</span> : Si votre application web est très populaire ou si vous avez des pages complexes à rendre, cela pourrait entraîner une surcharge du serveur.</p>
                        </li>
                        <li>
                            <p><span class="em">Temps d'attente plus longs</span> : Les pages prennent un peu plus de temps à charger puisqu'elles doivent être rendues côté serveur.</p>
                        </li>
                    </ul>
                    <h4>Le rendu statique :</h4>
                    <p>Le pré-rendu consiste à rendre les pages à la compilation, en génération les versions HTML à l'avance qui peuvent ensuite être distribuées simplement. Cela permet de remédier aux deux problèmes vus plus haut mais ne fonctionne que pour des pages dont le contenu ne change jamais.</p>
                    <h4>Le rendu sur demande :</h4>
                    <p>Ce type de rendu est un mélange entre les deux types de rendu précédents. Le principe est alors de distribuer aux utilisateurs une version pré-générée de la page mais de rendre en tâche de fond une nouvelle version de la page si la durée de la mise en mémoire est écoulée. Cette approche permet d'avoir la rapidité de rendu statique tout en ayant des données qui s'actualisent à un intervalle de temps prédéfini.</p>
                    <p>Il est possible de passer d'un mode de rendu à l'autre au cas par cas à l'aide de la configuration <span class="html">nuxt.config.ts</span>.</p>
<pre><code>export default defineNuxtConfig({
    routeRules: {
        // La page d'accueil est préchargée lors de la compilation.
        '/': { prerender: true },
        // La page produits est générée à la demande, se revalide en arrière-plan et reste dans le cache jusqu'à ce que les données API aient changé.
        '/products': { swr: true },
        // Les pages de produit sont générées à la demande, se revalident en arrière-plan et restent dans le cache pendant 1 heure (3600 secondes).
        '/products/**': { swr: 3600 },
        // La page blog est générée à la demande, se revalide en arrière-plan et reste dans le cache sur les serveurs CDN pendant 1 heure (3600 secondes).
        '/blog': { isr: 3600 },
        // Les pages de billet du blog sont générées à la demande une seule fois jusqu'à la prochaine mise à jour, restent dans le cache sur les serveurs CDN.
        '/blog/**': { isr: true },
        // La page d'interface administrative est affichée uniquement côté client.
        '/admin/**': { ssr: false },
        // Ajoutez des en-têtes CORS aux routes API.
        '/api/**': { cors: true },
        // Redirige les anciennes URLs vers de nouvelles URLs.
        '/old-page': { redirect: '/new-page' }
    }
});</code></pre>
                    <p>Pour plus d'information sur les méthodes de rendu, vous pouvez vous rendre sur <a href="https://nuxt.com/docs/guide/concepts/rendering#route-rules" target="_blank">la page Rendering Modes de la documentation</a>.</p>
                </article>
                <article>
                    <h2 id="Tanstack_Vue_Query">Tanstack Vue Query :</h2>
                    <p>Dans cette partie, je vous propose de découvrir une librairie incontournable lorsqu'il s'agit de récupérer des données tiers avec Vue.js : <a href="https://tanstack.com/query/latest/docs/framework/vue/overview" target="_blank">TanStack Query</a>.</p>
                    <h3>Pourquoi cette librairie ?</h3>
                    <p>Dans la plupart des cas, une application front-end va avoir besoin de récupérer des données depuis un serveur et de les afficher à l'utilisateur mais plusieurs pages peuvent avoir des mêmes données et gérer cela via un état global peut s'avérer complexe. TanStack Query approte un système de cache global qui permet de garder en mémoire les résultats d'une requête pour l'afficher instantanément à l'utilisateur lors de visites successives :</p>
                    <ul>
                        <li>
                            <p>Lors du premier chargement d'une ressource, les données sont mises en mémoire et associées à une clef.</p>
                        </li>
                        <li>
                            <p>Si la même requête est chargée, les données en cache sont utilisées pendant que TanStack Query demande les nouvelles données au serveur.</p>
                        </li>
                        <li>
                            <p>Lorsque les nouvelles données arrivent, le cache est remplacé et la page est mise à jour.</p>
                        </li>
                    </ul>
                    <p>Il est important de noter que TanStack Query n'a pas d'opinion sur comment vous récupérez les données. C'est à vous d'implémenter cette partie-là. La librairie ne se charge que de la mise en cache et de proposer une fonction composable utile.</p>
                    <h3>Utilisation :</h3>
                    <p>Pour commencer à utiliser TanStack Query, on l'ajoute aux dépendances du projet.</p>
<pre><code>$ npm i @tanstack/vue-query
# or
$ bun add @tanstack/vue-query</code></pre>
                    <p>Puis, on l'ajoute comme plugin à notre projet Vue.js :</p>
<pre><code>import { VueQueryPlugin } from '@tanstack/vue-query';

app.use(VueQueryPlugin);</code></pre>
                    <p>Une fois chargé, on pourra utiliser la fonction composable <span class="html">useQuery()</span> pour gérer le chargement de nos contenus.</p>
<pre><code>&lt;script setup&gt;
    import { useQuery } from '@tanstack/vue-query';

    const {data, isLoading, isFetching, isError, error} = useQuery({
        queryKey: ['posts'],
        queryFn: () =&gt; getPosts({page: 1})
    });
&lt;/script&gt;</code></pre>
                    <p>La clef permet de retrouver la requête plus tard pour pouvoir invalider le cache ou le mettre à jour. Par défaut, une requête est considérée comme "périmée" dès sa récupération mais il est possible de modifier ce comportement à l'aide du paramètre <span class="html">staleTime</span>.</p>
<pre><code>const {data, isLoading, isFetching, isError, error} = useQuery({
    queryKey: ['posts'],
    queryFn: () =&gt; getPosts({page: 1}),
    staleTime: 30_000, // Temps avant que le cache soit considéré comme périmé (0 par défaut)
    gcTime: 60_000, // Durée de vie du cache (5 min par défaut)
});</code></pre>
                    <p>Pourquoi ces propriétés ?</p>
                    <ul>
                        <li>
                            <p>Un cache <span class="em">périmé</span> est utilisé pendant que les nouvelles données sont récupérées, l'utilisateur voit les anciennes données pendant le chargement des nouvelles données.</p>
                        </li>
                        <li>
                            <p>Un cache <span class="em">supprimé</span> fait que l'utilisateur ne voit plus le contenu lors du second affichage d'une requête.</p>
                        </li>
                    </ul>
                    <h3>Mutation :</h3>
                    <p>Lorsque l'on souhaitera mettre à jour des données il sera possible d'utiliser la fonction composable <span class="html">useMutation()</span>.</p>
<pre><code>&lt;script setup&gt;
    import { useMutation } from '@tanstack/vue-query';

    const { isLoading, isError, error, isSuccess, mutate } = useMutation({
        mutationFn: (data) =&gt; updatePost(props.id, data),
    });

    const handleSubmit = (e) =&gt; {
        mutate(new FormData(e.target));
    };
&lt;/script&gt;

&lt;template&gt;
    &lt;form @submit.prevent="handleSubmit"&gt;
        &lt;!-- ... --&gt;
        &lt;button type="submit"&gt;Mettre à jour l'article&lt;/button&gt;
    &lt;/form&gt;
&lt;/template&gt;</code></pre>
                    <p>Contrairement aux requêtes, une mutation ne s'exécute pas au montage du composant mais seulement lorsque la méthode <span class="html">mutate</span> ou <span class="html">mutateAsync</span> est appelée. Il n'y a pas non plus de mise en cache.</p>
                    <h3>Invalidation :</h3>
                    <p>Le problème de la mise en cache est que les données peuvent changer lorsque l'utilisateur effectue certaines opérateurs (traitement de formulaire par exemple). Dans ce cas-là, il est possible d'<a href="https://tanstack.com/query/latest/docs/reference/QueryClient/#queryclientinvalidatequeries" target="_blank">invalider manuellement le cache depuis le client</a>.</p>
<pre><code>import { useQueryClient } from '@tanstack/vue-query';

const queryClient = useQueryClient();

const handleSubmit = async () =&gt; {
    // Mis à jour des données sur le serveur.
    await updatePost(new FormData(e.target));
    // On invalide les données concernant les articles.
    await queryClient.invalidateQueries(
        {
            queryKey: ['posts'],
        }
    );
};</code></pre>
                    <p>Il est aussi possible de venir modifier les données dans le cache pour un retour instantané aurpès de l'utilisateur. L'inconvénient est qu'il faut s'assurer de le faire pour toutes les requêtes qui peuvent contenir les données.</p>
<pre><code>import { useQueryClient } from '@tanstack/vue-query';

const queryClient = useQueryClient();

const handleSubmit = async () =&gt; {
    // Mis à jour des données sur le serveur.
    await updatePost(new FormData(e.target));
    // On invalide les données concernant les articles.
    await queryClient.setQueryData(['posts'], (oldData) =&gt; {
        // Gén§re les nouvelles données et les retourne.
        return newData;
    });
};</code></pre>
                    <h3>Pagination infinie :</h3>
                    <p>Enfin, une dernière fonctionnalité intéressante de TanStack Query est la possibilité de mettre en place facilement une pagination infinie grâce à la fonction <span class="html">useInfiniteQuery()</span>.</p>
<pre><code>&lt;script&gt;
    const {
        fetchNextPage,
        hasNextPage,
        isLoading,
        isFetching,
        hasNextPage,
        // Data contient l'ensemble des pages.
        data,
    } = useInfiniteQuery({
        queryKey: ['posts'],
        initialPageParam: 1,
        queryFn; ({ pageParam }) =&gt; getPosts({page: pageParam}),
        // Doit renvoyer bull s'il n'y a pas de page suivante.
        getNextPageParam: (lastPage, pages) =&gt; pages.length + 1;
    });

    // On peut récupérer les articles sous forme de liste à plat.
    const posts = computed(() =&gt; data.value?.pages.flat());
&lt;/script&gt;

&lt;template&gt;
    &lt;main&gt;
        &lt;;Spinner v-if="isLoading"/&gt;
        &lt;div class="posts" v-else&gt;
            &lt;PostCard v-for="post in posts" :key="post.id" :post="post"/&gt;
        &lt;/div&gt;
        &lt;button @click="fetchNextPage" :disabled="isFetching" v-if="hasNextPage"&gt;Page suivante&lt;/button&gt;
    &lt;/main&gt;
&lt;/template&gt;</code></pre>
                    <p></p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>