<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SQL 2ème année - IANARCH - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3schools.com/js/default.asp" target="_blank">Tutoriel JavaScript de W3Schools</a></li>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article id="partie_3">
                    <h2 id="partie_sql_2">Partie SQL 2ème année :</h2>
                    <h3 id="algebre_relationnelle">L'algèbre relationnelle :</h3>
                    <p>La première façon de manipuler de telles bases de données est d'utiliser un langage algébrique basé sur plusieurs opérateurs. Ci-dessous, sont proposés cinq opérateurs de base, suivi de quatre autres (qui ne sont pas indispensables car ils peuvent s'écrire au moyen des cinq premiers, mais augmentent le confort de manipulation).</p>
                    <h4 id="operateurs_base">Opérateurs de base :</h4>
                    <ol>
                        <li>
                            <h5 id="union">Union :</h5>
                            <p>L'union de deux tables R et S, que l'on notera R &#8746; S, est l'union au sens ensembliste des tuples des deux tables. Pour que le résultat soit encore une table, il faut que R et S comportent le même nombre de colonnes, et que si les colonnes ont des noms d'attributs, ces noms soient identiques et que les colonnes qui se correspondent dans les deux tables aient des domaines (ou au moins compatibles).</p>
                        </li>
                        <li>
                            <h5 id="difference">Différence :</h5>
                            <p>Il s'agit ici de la différence au sens ensembliste de tuples de deux tables. Les mêmes restrictions s'appliquent que pour l'union. On notera R - S ou R \ S.</p>
                        </li>
                        <li>
                            <h5 id="produit_cartesien">Produit cartésien :</h5>
                            <p>Si R est une table comportant r colonnes et S une table comportant s colonnes, leur produit cartésien RxS est une table comportant r+s colonnes héritant leurs noms d'attributs de ceux de R et S, et contenant pour tuples tous les tuples que l'on peut obtenir en juxtaposant un tuple de R et un tuple de S. Si R contient n tuples et que S en contient p, RxS en contiendra nxp. Si des attributs de R et S ont même noms, on les distinguera en mentionnant la table d'origine : R.i, S.i.</p>
                        </li>
                        <li>
                            <h5 id="projection">Projection :</h5>
                            <p>Si i,j,...,k sont des numéros de colonnes ou des noms d'attributs d'une table R, l'opérateur unaire de projection sur i,j,...,k est défini comme suit : la table &#960;<sub>i,j,...,k</sub> (R) est obtenue à partir de R en ne conservant que les colonnes i,j,...,k, et bien sûr en supprimant du résultats les éventuels tuples qui seraient identiques à d'autres.</p>
                        </li>
                        <li>
                            <h5 id="selection">Sélection :</h5>
                            <p>Soit R une table, et F une formule logique constituée :</p>
                            <ul>
                                <li>de numéros ou noms d'attributs</li>
                                <li>de constantes</li>
                                <li>d'opérateurs arithmétiques ou autres s'appliquant aux constantes et aux domaines des attributs</li>
                                <li>d'opérateurs de relation (=, &lt;, &gt;, etc.)</li>
                                <li>d'opérateurs logiques : NOT, AND, OR.</li>
                            </ul>
                            <p>Alors l'opérateur de sélection est définies comme suit : la table &#963;<sub>F</sub>(R) est la table comportant les mêmes attributs que R, et contenant les tuples de R qui satisfont à la condition F (c'est-à-dire qui donnent la valeur TRUE à F si on y remplace les nomms d'attributs par les valeurs prises par ces attributs dans le tupke concerné).</p>
                        </li>
                    </ol>
                    <h4 id="operateurs_additionnels">Opérateurs additionnels :</h4>
                    <ol>
                        <li>
                            <h5 id="intersection">Intersection :</h5>
                            <p>L'intersection R &#8745; S est définiede façon similaire à l'union. Rappelons que : R &#8745; S = R - (R - S).</p>
                        </li>
                        <li>
                            <h5 id="quotient">Quotient :</h5>
                            <p>Soient R et S deux tables contenant respectivement r et s colonnes, avec s &lt; r. Supposons en outre que les noms d'attributs de S forment un sous-ensemble de ceux de R et queS ne soit pas vide. On définira le quotient R : S comme étant la table comportant r-s attributs (ayant pour noms ceux de la table R qui sont absents de la table S), et contenant comme tuples t ceux pour lesquels, pour tout tuple u de S, la combinaison "tu" soit dans R.</p>
                            <p>On peut définir cet opérateur à partir des cinq premiers de la façon suivante : si i,j,...,k sont les attributs présents dans R mais absents de S, on a :</p>
                            <p>R : S = &#960;<sub>i,j,...,k</sub> (R) - &#960;<sub>i,j,...,k</sub> (R) x S) - R).</p>
                        </li>
                        <li>
                            <h5 id="jointure">Jointure :</h5>
                            <p>Si i est un attribut de R et j un attribut de S, la jointure R JOIN<sub>i=j</sub> S est la table obtenue en prenant  le produit cartésien de R et S, dont ne conserve que les tuples pour lesquels les valeurs de l'attribut R.i et de l'attribut S.j sont égales. On peut de même définir des jointures basées sur d'autres opérateurs de relation (par exemple : R JOIN<sub>i&lt;j</sub> S) ou sur des conditions combinées (par exemple : R JOIN<sub>(i=j and k&#8800;l)</sub> S).</p>
                            <p>Le cas où l'opérateur d'égalité "=" est le seul présent est appelé "équijointure".</p>
                        </li>
                        <li>
                            <h5 id="jointure_naturelle">Jointure naturelle :</h5>
                            <p>La jointure naturelle de deux tables R et S comportant un ou plusieurs attributs identiqes (mêmes noms et mêmes domaines) est la table R JOIN S obtenue en effectuant tout d'abord une équijointure selon les attributs provenant de S qui sont des duplicatas d'attributs provenant de R.</p>
                        </li>
                    </ol>
                    <p class="souligne">Exemples :</p>
                    <table class="tableBalises">
                        <caption>R</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                                <td>325</td>
                            </tr>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                                <td>360</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>322</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>312</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Oslo</td>
                                <td>319</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>D</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dutoit</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>S</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                                <td>325</td>
                            </tr>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                                <td>588</td>
                            </tr>
                            <tr>
                                <td>Janssens</td>
                                <td>Prague</td>
                                <td>322</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>T</caption>
                        <thead>
                            <tr>
                            <th>Nom</th>
                            <th>Rembours</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Janssens</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>Albrecht</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Fanuel</td>
                                <td>3</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>R&#8746;S</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                                <td>325</td>
                            </tr>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                                <td>360</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>322</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>312</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Oslo</td>
                                <td>319</td>
                            </tr>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                                <td>588</td>
                            </tr>
                            <tr>
                                <td>Janssens</td>
                                <td>Prague</td>
                                <td>322</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>R-S</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                                <td>360</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>322</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>312</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Oslo</td>
                                <td>319</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>R x T</caption>
                        <thead>
                            <tr>
                                <th>R.Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                                <th>T.Nom</th>
                                <th>Rembours</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>Dufour</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>Dutoit</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>Janssens</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>Albrecht</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>Fanuel</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                                <td>325</td>
                                <td>Dufour</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                                <td>...</td>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Oslo</td>
                                <td>319</td>
                                <td>Fanuel</td>
                                <td>3</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>R JOIN T</caption>
                        <thead>
                            <th>Nom</th>
                            <th>Destination</th>
                            <th>Code-dépl</th>
                            <th>Rembours</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                                <td>321</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                                <td>325</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>322</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                                <td>312</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Oslo</td>
                                <td>319</td>
                                <td>4</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>&#960;<sub>Nom,Destination</sub>(R)</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Destination</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>Paris</td>
                            </tr>
                            <tr>
                                <td>Dufour</td>
                                <td>Milan</td>
                            </tr>
                            <tr>
                                <td>Durand</td>
                                <td>Paris</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Paris</td>
                            </tr>
                            <tr>
                                <td>Dutoit</td>
                                <td>Oslo</td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="tableBalises">
                        <caption>&#963;<sub>Rembours&lt;3</sub>(T)</caption>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <th>Rembours</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Dufour</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Janssens</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>Albrecht</td>
                                <td>2</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4 id="analyse_relationnelle">L'analyse relationnelle :</h4>
                    <p>Les notations ensemblistes permettent d'atteindre les mêmes résultats. Ainsi, pour les exemples qui précèdent, on pourrait utiliser les notations équivalentes suivantes :</p>
                    <p>R &#8746; S = { t | t &#8714; R ou t &#8714; S }</p>
                    <p>R - S = { t | t &#8714; R et t &#8713; S }</p>
                    <p>R x T = { (R.Nom, Destination, Code-dépl, T.Nom, Rembours) | (R.Nom, Destination, Code-dépl) &#8714; R et (Nom, Rembours) &#8714; T }</p>
                    <p>R JOIN T = { (Nom, Destination, Code-dépl, Rembours) | (Nom, Destination, Code-dépl) &#8714; R et (Nom, Rembours) &#8714; T }</p>
                    <p>ou encore</p>
                    <p>R JOIN T = { (Nom, Destination, Code-dépl, Rembours) | (R.Nom, Destination, Code-dépl) &#8714; R et (T.Nom, Rembours) &#8714; T et R.Nom = T.Nom;</p>
                    <p>&#960;<sub>Nom,Destination</sub>(R) = { (Nom, Destination) | &#8707; Code-dépl : (Nom,Destination,Code-dépl) &#8714; R }</p>
                    <p>&#963;<sub>Rembours&lt;3</sub>(T) = { (Nom, Rembours) &#8714; T | Rembours &lt; 3 }</p>
                    <p>Ces notations ensemblistes ont directement inspiré le langage SQL, comme le montrent les exemples suivants :</p>
                    <p>R JOIN T s'obtient par l'instruction</p>
<pre class="taille60"><code>SELECT R.Nom, Destination, Code-dépl, Rembours
FROM R, T
WHERE R.Nom = T.nom;</code></pre>
                    <p>&#963<sub>Rembours&lt;3</sub>(T) s'obtient par l'instruction</p>
<pre class="taille60"><code>SELECT Nom, Rembours
FROM T
WHERE Rembours &lt; 3;</code></pre>
                    <h3 id="coalesce">Coalesce :</h3>
                    <p>Dans une requête, il est possible d'utiliser l'expression <span class="html">COALESCE</span> pour remplacer une valeur NULL par une valeur conventionnelle (par exemple la valeur 0 ou la chaîne vide).La particularité de cette fonction est d'accepter autant de paramètres que l'on veut. Elle renvoie la première expression évaluable (donc différente de NULL) dans l'ordre d'écriture (de gauche à droite).</p>
                    <p>Sa syntaxe est la suivante :</p>
<pre class="taille60"><code>COALESCE (expression1 [, expression2 [, expression3 [ ... ] ] ])</code></pre>
                    <p class="souligne">Exemple :</p>
<pre class="taille60"><code>SELECT au_id, au_fname, au_lname, COALESCE (country, state, 'état et pays inconnus')
FROM authors;</code></pre>
                    <p>Pour chaque auteur, cette requête affichera quatre champs. Les trois premiers champs seront l'id, le prénom et le nom de l'auteur. Si son pays est différent de NULL, le quatrième champ sera son pays. Si son pays est NULL mais que son état est différent de NULL, alors le quatrième champ sera son état. Si son pays et son état sont NULL, alors le quatrième champ sera la chaîne de caractères 'état et pays inconnus'.</p>
                    <h3 id="union_intersection_difference">Union, Intersection, Différence :</h3>
<pre class="taille60"><code>SELECT [ ALL | DISTINCT ]
    * | expression [ [ AS ] nom_d_affichage ] [, ...]
    [ FROM éléments_from [, ...] ]
    [ WHERE condition ]
    [ GROUP BY expression [, ...] ]
    [ HAVING condition [, ...] ]
    <span class="em">[ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]</span>
    [ ORDER BY order_expression [ ASC | DESC ] [, ...] ]</code></pre>
                    <ul>
                        <li>
                            <p>L'opérateur <span class="html">UNION</span> calcule l'union ensembliste des lignes renvoyées par les instructions <span class="em">SELECT</span> impliquées. Une ligne est dans l'union de deux ensembles de résultats si elle apparaît dans au moins un des ensembles. Les deux instructions <span class="em">SELECT</span> qui représentent les opérandes directes de l'UNION doivent produire le même nombre de colonnes et les colonnes correspondantes doivent être d'un type de données compatible.</p>
                            <p>Sauf lorsque l'option <span class="html">ALL</span> est spécifiée, il n'y a pas de doublons dans le résultat de <span class="em">UNION</span> <span class="em">ALL</span> empêche l'élimination des lignes dupliquées. <span class="em">UNION ALL</span> est donc significativement plus rapide qu'<span class="em">UNION</span>, et sera préféré.</p>
                            <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">UNION</span>, ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses impose un comportement différent.</p>
                        </li>
                        <li>
                            <p>L'opérateur <span class="html">INTERSECT</span> calcule l'intersection des lignes renvoyées par les deux instructions <span class="em">SELECT</span> impliquées. Une ligne est dans l'intersection des deux ensembles de résultats si elle apparaît dans chacun des des ensembles.</p>
                            <p>Le résultat d'<span class="em">INTERSECT</span> ne contient aucune ligne dupliquée sauf si l'option <span class="html">ALL</span> est spécifiée. Dans ce cas, une ligne dupliquée m fois dans la table gauche et n fois dans la table droite apparaît <span class="em">min(m, n)</span> fois dans l'ensemble de résultats.</p>
                            <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">INTERSECT</span>, ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses impose un comportement différent. <span class="em">INTERSECT</span> a une priorité supérieur à celle d'<span class="em">UNION</span>. C'est-à-dire que <span class="em">A UNION B INTERSECT C</span> est lu comme <span class="em">A UNION (B INTERSECT C)</span>.</p>
                        </li>
                        <li>
                            <p>L'opérateur <span class="html">EXCEPT</span> calcule l'ensemble des lignes qui appartiennent au résultat de l'instruction <span class="em">SELECT</span> de hauche pas à celui de droite.</p>
                            <p>Le résultat d'<span class="em">EXCEPT</span> ne contient aucune ligne dupliquée sauf si l'option <span class="html">ALL</span> est spécifiée. Dans ce cas, une ligne dupliquée m fois dans la table gauche et n fois dans la table droite apparaît <span class="em">max(m-n, 0)</span> foi dans l'ensemble de résultats.</p>
                            <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">EXCEPT</span>n ils sont évalués de gauche à droite, sauf si l'utilisation de paenthèses impose un comportement différent. <span class="em">EXCEPT</span> a la même priorité qu'<span class="em">UNION</span>.</p>
                        </li>
                    </ul>
                    <p class="souligne">Exemples :</p>
                    <ol>
                        <li>
                            <p>Quelles sont les villes où l'on peut trouver un auteur et/ou un éditeur ?</p>
<pre class="taille60"><code>(SELECT DISTINCT city FROM authors) UNION (SELECT DISTINCT city FROM publishers);</code></pre>
                        </li>
                        <li>
                            <p>Pour chaque éditeur, donnez son nom et le nombre de livres de psychologie qu'il a édité. Classez le tout par ordre décroissant de nombre de livres.</p>
<pre class="taille60"><code>(
    SELECT P.pub_name, COUNT (title_id)
    FROM publishers P, titles T
    WHERE p.pub_id = t.pub_id
    AND type = 'psychology'
    GROUP BY P.pub_name
) UNION (
    SELECT pub_name, 0
    FROM publishers
    WHERE pub_id NOT IN (
        SELECT pub_id
        FROM titles
        WHERE type = 'psychology'
    )
)
ORDER BY DESC;</code></pre>
                        </li>
                    </ol>
                    <h3 id="outer_join">OUTER JOIN (Jointures externes) :</h3>
<pre class="taille60"><code>SELECT [ ALL | DISTINCT ]
    * | expression [ [ AS ] nom_d_affichage ] [, ...]
    [ FROM éléments_from [, ...] ]
    [ WHERE condition ]
    [ GROUP BY expression [, ...] ]
    [ HAVING condition [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]
    [ ORDER BY order_expression [ ASC | DESC ] [, ...] ]</code></pre>
                    <ul>
                        <li>
                            <p>avec <span class="em">éléments_from</span> qui peut être :</p>
<pre class="taille60"><code>nom_table [ * ] [ [ AS ] alias [ ( alias_colonne [, ...] ) ] ]
[,éléments_from]
<span class="em">éléments_from [ NATURAL ] type_jointure éléments_from [ ON condition_jointure
| USING ( colonne_jointure [, ...] ) ]</span></code></pre>
                        </li>
                        <li>
                            <p>avec <span class="em">type_jointure</span> qui peut être :</p>
                            <ul>
                                <li><span class="html">[ INNER ] JOIN</span> : équivalent à la jointure habituelle où la condition de jointure est exprimée dans la partie <span class="em">WHERE</span> du <span class="em">SELECT</span>.</li>
                                <li><span class="html">LEFT [ OUTER ] JOIN</span> : tous les tuples de la table de gauche font partie du résultat; ils sont joints à la table de droite quand c'est possible de par la condition de jointure. Sinon les colonnes correspondantes à la table de droite sont remplies de NULL.</li>
                                <li><span class="html">RIGHT [ OUTER ] JOIN</span> : identique à <span class="em">LEFT [ OUTER ] JOIN</span> mais en inversant les tables de gauche et de droite.</li>
                                <li><span class="html">FULL [ OUTER ] JOIN</span> : tous les tuples de la table de gauche et de droite font partie du résultat, joints quand c'est possible sinon les colonnes manquanes sont remplies de NULL.</li>
                            </ul>
                            <p>Une condition de jointure doit être choisie entre :</p>
                            <ul>
                                <li><span class="html">ON condition_jointure</span> permet d'exprimer une condition de jointure sous un fore similaire à la condition du <span class="em">WHERE</span>.</li>
                                <li><span class="html">USING ( a, b, ... )</span> est un raccourci pour <span class="em">ON table_gauche.a = table_droite.a AND table_gauche.b = table_droute.b</span>.</li>
                                <li><span class="html">NATURAL</span> est un raccourci pour une liste <span class="em">USING</span> qui mentionne toutes les colonnes de même nom dans les deux tables.</li>
                            </ul>
                        </li>
                    </ul>
                    <h3 id="normalisation">Normalisation :</h3>
                    <p>Maintenant que l'on est capable de créer une table, il faut décider où placer les données. Il faut donc trouver une combinaison de tables possédant des relations entre elles et permettant d'exploiter les données. Ceci s'appelle un schéma.</p>
                    <p>Pour tout jeu de données, il existe une multiyude de schémas possibles permettant de les organiser. Cependant, de part la nature même du modèle relationnel, certains schémas s'avèrent meilleurs que d'autres. Par exemple, certains schémas évitent de dupliquer des données, enlevant ainsi un risque d'incohérence (la même donnée qui devrait être dupliquée à l'identique finit par avoir des valeurs différentes). On dit qu'un schéma est normalisé à une certaine forme lorsqu'il respecte les critères de cette forme. La normalisation est l'acte consistant à transformer un schéma pour atteindre une forme normalisée. Dans le cadre de ce cours, nous verrons uniquement les trois premiers niveaux.</p>
                    <h4 id="1FN">1FN - première forme normale :</h4>
                    <p>Relation dont tous les attributs :</p>
                    <ul>
                        <li>contiennent une valeur atomique (les valeurs ne peuvent pas être divisées en plusieurs sous-valeurs dépendant également individuellement de la clé primaire).</li>
                        <li>contiennent des valeurs non répétitives (le cas contraire consiste à mettre une liste dans un seul attribut).</li>
                        <li>sont constants dans le temps (utiliser par exemple la date de naissance plutôt que l'âge).</li>
                    </ul>
                    <p>Le non respect de deux premières conditions de la 1FN rend la recherche parmi les données plus lente parce qu'il faut analyser le contenu des attributs. La troisième condition quant à elle évite qu'on doive régulièrement mettre à jour les données.</p>
                    <h4 id="2FN">2FN - deuxième forme normale :</h4>
                    <p>Respecte la deuxième forme normale, la relation respectant la première forme normale et dont :</p>
                    <ul>
                        <li>Tous les attributs non-clés sont totalement dépendants fonctionnellement de la totalité de la clé primaire.</li>
                    </ul>
                    <p>Le non respect de la 2FN entraîne une redondance des données qui encombrent alors inutilement la mémoire et l'espace disque.</p>
                    <h4 id="3FN">3FN - troisième forme normale :</h4>
                    <p>Respecte la troisième forme normale, la relation respectant la seconde forme normale et dont :</p>
                    <ul>
                        <li>Tout attribut n'appartenant pas à une clé ne dépend pas d'un attribut non clé.</li>
                    </ul>
                    <p>Le non respect de la 3FN peut également entraîner une redondance des données.</p>
                    <h3 id="denormalisation">Dénormalisation :</h3>
                    <p>La normalisation permet de garantir la cohérence des données et permet d'éviter des problèmes inutiles. On cherchera donc en général à normaliser son schéma complètement. Il peut cependant y avoir des exceptions pour lesquelles on dénormalisera le schéma :</p>
                    <ul>
                        <li>On pourrait avoir dans un schéma unique des tables appartenant logiquement à des schémas séparés. L'exemple typique est la table d'archivage ou d'audit qui duplique l'information se trouvant dans les autres tables en les mettant complètement à plat (un tuple contient toute l'information sans devoir effectuer une jointure avec une autre table). Cette table n'est évidemment pas du tout normalisée de par sa nature même.</li>
                        <li>La normalisation force à multiplier les tables, ce qui impose une pénalité à l'exécution. Pour résoudre les problèmes de performance <span class="em">uniquement</span>, on accepte d'enlever la normalisation. Cependant, il existe quand même une technique permettant de s'assurer de la consistance des données, confer <span class="em">TRIGGER</span> plus loin.</li>
                    </ul>
                    <p class="souligne">Exemple :</p>
                    <p>Dans la base de données pub2, il y a un champ total_sales dans la table titles : ce champ ne dépend pas uniquement de la clé primaire de titles, il dépend aussi directement du contenu de la table salesdetail. Cependant, c'est une information dont on a fréquemment besoin dans le cadre de l'application utilisant pubs2, et pour garder de bonnes performances ce champ est dénormalisé. Comme il est dénormalisé, il y a un risque qu'il ne soit pas synchronisé correctement par rapport à la valeur réelle qu'il doit prendre.</p>
                    <h3 id="drop_table">DROP TABLE :</h3>
<pre class="taille60"><code>DROP TABLE nom;</code></pre>
                    <h3 id="alter_table">ALTER TABLE :</h3>
<pre class="taille60"><code>ALTER TABLE nom [ * ]
action [, ... ]
ALTER TABLE nom [ * ]
RENAME [ COLUMN ] colonne TO nouvelle_colonne
ALTER TABLE nom
RENAME TO nouveau_nom</code></pre>
                    <ul>
                        <li>
                            <p><span class="em">action</span> peut être :</p>
<pre class="taille60"><code>ADD [ COLUMN ] colonne type [ contrainte_colonne [ ... ] ]
DROP [ COLUMN ] colonne
ALTER [ COLUMN ] colonne [ SET DATA ] TYPE type [ USING expression ]
ALTER [ COLUMN ] colonne SET DEFAULT expression
ALTER [ COLUMN ] colonne DROP DEFAULT
ALTER [ COLUMN ] colonne { SET | DROP } NOT NULL
ADD contrainte_table
DROP CONSTRAINT nom_contrainte</code></pre>
                        </li>
                    </ul>
                    <p class="souligne">Exemples :</p>
                    <ol>
                        <li>
                            <p>Ajouter une colonne de type VARCHAR à une table :</p>
<pre class="taille60"><code>ALTER TABLE publishers
ADD COLUMN continent VARCHAR (30);</code></pre>
                        </li>
                        <li>
                            <p>Changer le type de la colonne :</p>
<pre class="taille60"><code>ALTER TABLE publishers
ALTER COLUMN continent
TYPE VARCHAR (20);</code></pre>
                        </li>
                        <li>
                            <p>Supprimer la colonne :</p>
<pre class="taille60"><code>ALTER TABLE publishers
DROP COLUMN continent;</code></pre>
                        </li>
                    </ol>
                    <h3 id="sequences">Séquences :</h3>
<pre class="taille60"><code>CREATE SEQUENCE nom [ INCREMENT [ BY ] incrément ]
    [ MINVALUE valeurmin | NO MINVALUE ]
    [ MAXVALUE valeurmax | NO MAXVALUE ]
    [ START [ WITH ] début ]</code></pre>
                    <ul>
                        <li><span class="em">CREATE SEQUENCE</span> crée un nouveau générateur de séquence de nombres. Cela implique la création et l'initialisation d'une nouvelle table à une seule ligne nommée <span class="em">nom</span>.</li>
                    </ul>
                    <p>La séquence est surtout utile pour laisser la base de données générer elle-même des identifiants uniques pour les tuples. Pour réaliser cela, il faut créer une séquence d'un certain nom (par exemple <span class="em">'ABC'</span>) et dire que la valeur par défaut de la colonne est <span class="em">nextval ('ABC')</span>.</p>
                    <p>En PostgreSQL, on utilisera donc une séquence pour générer des clefs primaires automatiquement. D'autres bases de données utilisent d'autres approches pour générer des clefs primires automatiquement. On parle parfois d'<span class="em">AUTO-INCREMENT</span> ou d'<span class="em">IDENTITY</span>. Dans ce cas, lors de l'insertion d'un nouveau tuple, on ne spécifie pas de valeur pour la clef primaire. Par contre, on pourra vouloir directement récupérer sa valeur via la partie <span class="em">RETURNING</span> de l'<span class="em">INSERT</span>.</p>
                    <h3 id="serial">Serial :</h3>
                    <p>Une séquence est implicitement créée lorsque l'on déclare la création d'une table avec une colonne de type <span class="html">SERIAL</span>. La colonne se transformera en type INTEGER mais sa valeur par défaut suivra l'ordre d'une séquence.</p>
                    <p>Exemple :</p>
<pre class="taille60"><code>CREATE TABLE nom_de_table (
    nom_de_colonne SERIAL
);</code></pre>
                    <p>Cette dernière instruction est équivalente à :</p>
<pre class="taille60"><code>CREATE SEQUENCE nom_de_table_nom_de_colonne_seq;
CREATE TABLE nom_de_table (
    nom_de_colonne integer DEFAULT nextval('nom_de_table_nom_de_colonne_seq') NOT NULL
);</code></pre>
                    <p>Dans la plupart des cas, vous voudrez aussi aujouter une contrainte <span class="em">PRIMARY KEY</span> pour préciser que cet attribut est la clé primaire, mais ce n'est pas automatique.</p>
                    <h3 id="gestion_base_donnees">Gestion d'une base de données :</h3>
                    <p>À ce stade, nous sommes capables de créer les tables d'une base de données, d'y mettre des données et de l'interroger. Cela ne couvre cependant par tous les besoins d'une base de données en situation réelle. Dans la suite, on va aborder des besoins fréquents.</p>
                    <ol type="a">
                        <li>
                            <h4 id="sql_procedural">SQL Procédural :</h4>
                            <p>Au-delà de fournir des instructions SQL manipulant le schéma et les tuples d'une base de données, on peut aussi vouloir donner plus d'intelligence au serveur.</p>
                            <ul>
                                <li>Comme le serveur est le dernier intervenant avant le stockage physique des données, c'est un bon candidat pour valider la cohérence des données avant d'écrire n'importe quoi. Ceci est d'ailleurs déjà l'intention des contraintes d'intégrité. Mais au-delà de ces contraintes, il existera toujours des cas particuliers qu'elles ne peuvent pas valider. Par exemple, on pourrait vouloir vérifier qu'un numéro de carte de banque respecte la validation numérique qu'elle est sensée avoir (les deux derniers chiffres sont le modulo 97 du restant).</li>
                                <li>Le serveur est aussi un bon candidat pour gérer automatiquement la cohérence des données dénormalisées. Il pourra s'assurer que ces données seront mises à jour correctement automatiquement dès que nécessaire. Par exemple, dans pubs2, le champ total_sales de la table titles correspond à un calcul sur les ventes de ce livre. On pourra configurer le serveur pour effectuer la mise à jour de ce champ dès qu'une nouvelle vente est insérée.</li>
                                <li>On pourra aussi vouloir abstraire de la complexité sous-jacente des données en fournissant des fonctions de haut niveau. Par exemple, à la place de laisser un client manipuler différentes tables pour réaliser une opération complexe, le serveur fournira une fonction qui se charge de réaliser l'intégralité de la tâche. Si le schéma de la base de données change, c'est uniquement les fonctions du serveur qui devront être mises à jour, le client pourra rester inchangé.</li>
                            </ul>
                            <p>Il faut donc un langage de programmation complet (au sens de Turing : <a href="http://fr.wikipedia.org/wiki/Turing-complet" target="_blank">http://fr.wikipedia.org/wiki/Turing-complet</a>) pour réaliser toute cette intelligence. Les systèmes de base de données modernes (dont fait partie PostgreSQL) permettent même de choisir le langage de programmation que l'on soihaite. Historiquement, on utilisait des langages procéduraux qui sont des extensions du SQL de base. Comme ces langages datent des années 70, les concepts présents dans les langages modernes n'en font pas partie. En particulier, il n'y a pas de notion d'objets. Dans le cadre de cours, nous utiliserons PL/pgSQL. Cette section introduit brièvement ce langage, veuillez-cous référer à la documentation en ligne de PostgreSQL pour plus de détails (<a href="http://docs.postgresqlfr.org/" target="_blank">http://docs.postgresqlfr.org/</a>).</p>
                            <ol type="i">
                                <li>
                                    <h5 id="create_function">CREATE FUNCTION : </h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
    corpsFonction
$$ LANGUAGE plpgsql;</code></pre>
                                    <p>Définit une fonction qui prend X paramètres qui sont de type <span class="em">type1, type2, ..., typeX</span> et qui retourne une valeur de type <span class="em">typeOut</span>. <span class="em">corpsFonction</span> contient la définition de la fonction, voir ci-dessous. Une fonction ainsi créée fait partie intégrante de la base de données, c'est pourquoi on l'appelle parfois "procédure stockée". La commande <span class="html">DROP FUNCTION nomFonction</span> permet d'effacer la fonction.</p>
                                    <p>Attention, les délimitateurs <span class="html">$$</span> et l'instruction <span class="html">LANGUAGE plpgsql</span> font partie intégrante de la définition de la fonction.</p>
                                    <p>Une fois définie, une fonction se comporte comme une expression. Ainsi, on utilisera la commande <span class="em">SELECT nomFonction (param1, param2, ..., paramX)</span> pour afficher le résultat de son exécution.</p>
                                </li>
                                <li>
                                    <h5 id="declare">DECLARE :</h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
<span class="em">DECLARE
    nomParam1 ALIAS FOR $1 ;
    nomParam2 ALIAS FOR $2 ;
    ...
    nomParamX ALIAS FOR $X ;
    nomVar1 typeVar1;
    nomVar2 typeVar2;
    ...
    nomVarY typeVarY;
BEGIN
    corpsDeclare ;
END ;</span>
$$ LANGUAGE plpgsql;</code></pre>
                                    <p><span class="html">DECLARE</span> définit les variables internes à la fonction. <span class="html">ALIAS FOR</span> permet de donner un nom explicite a un paramètre particulier. Pour des variables locales, il faut d'abord donner leur nom suivi de leur type.</p>
                                </li>
                                <li>
                                    <h5 id="affectation">Affectation :</h5>
<pre class="taille60"><code class="em">variable := expression;</code></pre>
                                </li>
                                <li>
                                    <h5 id="commentaire">Commentaire :</h5>
<pre class="taille60"><code>-- tout ce qui suit -- est ignoré jusqu'à la fin de la ligne</code></pre>
                                </li>
                                <li>
                                    <h5 id="structures_controle">Structures de contrôle :</h5>
<pre class="taille60"><code class="em">RETURN expression;</code></pre>
                                    <p>Termine l'exécution de la fonction en renvoyant la valeur calculée par expression.</p>
<pre class="taille60"><code class="em">IF ... THEN ... END IF ;
IF ... THEN ... ELSE ... END IF ;
IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF ;
FOR record IN instructionSelect LOOP ... END LOOP ;</code></pre>
                                    <p><span class="em">record</span> doit être une variable de type <span class="em">RECORD</span>. L'instruction <span class="html">FOR</span> fera un parcours successif des tuples retournées par l'instruction <span class="em">SELECT</span>. On pourra accéder aux différents champs du tuple en cours par <span class="em">record.nomChamp</span>.</p>
                                    <p class="souligne">Exemple :</p>
<pre class="taille60"><code>CREATE FUNCTION compteSalesDetailQty() RETURNS INTEGER AS $$
DECLARE
    i integer := 0;
    record RECORD;
BEGIN
    FOR record IN SELECT * FROM Salesdetail LOOP
        i := i + record.qty;
    END LOOP;
    RETURN i;
    END;
$$ LANGUAGE plpgsql;

SELECT compteSalesDetailQty();</code></pre>
                                    <p>Ceci est équivalent à :</p>
<pre class="taille60"><code>SELECT SUM (qty) FROM Salesdetail;</code></pre>
                                    <p class="em"><span class="souligne">Remarque importante :</span> il n'y a aucune valeur ajoutée à implémenter soi-même ce qui devrait en fait être une requête SQL. Le code ne sera jamais aussi performant que la requête équivalente. Cela prend toujours plus de temps d'écrire une implémentation plutôt que d'écrire la requête, et le risque d'erreur est olus élevé. Dans le cadre de ce cours, ceci est donc considéré comme une faute et sanctionné comme tel.</p>
                                </li>
                                <li>
                                    <h5 id="exceptions">Exceptions :</h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
DECLARE
    ...
BEGIN
corpsDeclare ;
<span class="em">EXCEPTION
WHEN condition [ OR condition ... ] THEN
    instructions_gestion_erreurs
[ WHEN condition [ OR condition ... ] THEN
    instructions_gestion_erreurs
... ]</span>
END ;</code></pre>
                                    <p>Si une exception est levée pendant l'exécution de <span class="em">corpsDeclare</span>, la partie <span class="html">EXCEPTION</span> l'attrapera. Pour lever une exception manuellement, il faut utiliser l'instruction <span class="html">RAISE EXCEPTION nom_exception</span> (confer la documentation de PostgreSQL pour la liste des <span class="em">nom_exception</span> possibles et leur signification).</p>
                                    <p class="souligne">Exemple :</p>
<pre class="taille60"><code>BEGIN
    y := x / 0;
EXCEPTION
WHEN division_by_zero THEN -- ignore l'erreur
END;</code></pre>
                                </li>
                                <li>
                                    <h5>Exemple :</h5>
                                    <p>Écrire une fonction qui effectue une vente, en créant tous les tuples nécessaires dans toutes les tables.</p>
<pre class="taille60"><code>CREATE FUNCTION sell (VARCHAR (6), CHARACTER (4), VARCHAR (20), SMALLINT)
RETURNS BOOLEAN AS $$
DECLARE
    v_title_id ALIAS FOR $1;
    v_stor_id ALIAS FOR $2;
    v_ord_num ALIAS FOR $3;
    v_qty ALIAS FOR $4;
    price INTEGER;
BEGIN
    SELECT price FROM titles WHERE title_id = v_title_id INTO price;
    IF price IS NULL THEN
        RETURN false;
    ELSE
        INSERT INTO sales VALUES (v_stor_id, v_ord_num);
        INSERT INTO salesdetail VALUES (v_stor_id, v_ord_num, v_title_id, v_qty),
        UPDATE titles
        SET total_sales = ((SELECT total_sales
                                            FROM titles WHERE title_id = v_title_id)
                                        + v_qty)
        WHERE title_id = v_title_id;
        RETURN true;
    END IF;
END;
$$ LANGUAGE plpgsql;</code></pre>
                                </li>
                                <li>
                                    <h5 id="procedure_stockee_renvoyant_tableau">Procédure stockée renvoyant un tableau :</h5>
                                    <p>Une procédure stockée peut renvoyer un tableau. Elle s'utilise alors comme une table dans la commande SELECT :</p>
<pre class="taille60"><code>CREATE OR REPLACE FUNCTION listeAuthorsLivres () RETURNS <span class="em">SETOF RECORD</span> AS $$
DECLARE
    sep VARCHAR;
    texte VARCHAR;
    sortie RECORD;
    author RECORD;
    title RECORD;
BEGIN
    FOR author IN SELECT * FROM authors LOOP
        texte := '';
        sep := '';
        FOR title IN SELECT * FROM titles t, titleauthor ta WHERE t.title_id = ta.title_id AND ta.au_id = author.au_id LOOP
            texte := texte || sep || title.title;
            sep := ', ';
        END LOOP;
        <span class="em">SELECT author.au_fname, author.au_lname, texte INTO sortie;
        RETURN NEXT sortie;</span>
    END LOOP;
    RETURN;
END;
$$ LANGUAGE 'plpgsql';</code></pre>
                                    <p>Notez le type de retour <span class="html">:SETOF</span> signifie plusieurs lignes tandis que <span class="html">RECORD</span> signifie plusieurs colonnes. L'affectation à une variable de type <span class="em">RECORD</span> se fait par la commande <span class="em">SELECT valeur1, ... valeurX INTO record</span>. L'ajout d'une ligne en  retour de l'appel de la procédure stockée se fait par la commande <span class="html">RETURN NEXT</span>. La commande <span class="html">RETURN</span> simple se contenant alors de terminer l'exécution de la procédure stockée. L'appel de la procédure ci-dessous se fait par un <span class="em">SELECT</span>, mais il faut préciser la structure des colonnes ainsi que leurs noms :</p>
<pre class="taille60"><code>SELECT * FROM listeAuthorsLivres() t (fname VARCHAR (20), lname VARCHAR (40), title VARCHAR);</code></pre>
                                    <p>Comme il n'est pas très pratique d'embarquer la définition des colonnes dans le <span class="em">SELECT</span>, il est possible d'utiliser un type personnaisé pour que ceci se fasse au niveau de la procédure stockée. Dans ce cas, l'appel à la procédure stcokée devient identique au <span class="em">SELECT</span> habituel.</p>
<pre class="taille60"><code>CREATE TYPE <span class="em">listesAuthorsLivresReturn</span> AS (fname VARCHAR (20), lname VARCHAR (40), titles VARCHAR);

CREATE OR REPLACE FUNCTION listeAuthors() RETURNS SETOF <span class="em">listesAuthorsLivresReturn</span> AS $$
DECLARE
    sep VARCHAR;
    texte VARCHAR;
    sortie RECORD;
    author RECORD;
    title RECORD;
BEGIN
    FOR author IN SELECT * FROM authors LOOP
        texte := '';
        sep := '';
        FOR title IN SELECT * FROM titles t, titleauthor ta WHERE t.title_id = ta.title_id AND ta.au_id = author.au_id LOOP
            texte := texte || sep || title.title;
            sep := ', ';
        END LOOP;
        SELECT author.au_fname, author.au_lname, texte INTO sortie;
        RETURN NEXT sortie;
    END LOOP;
    RETURN;
END;
$$ LANGUAGE 'plpgsql';

SELECT * FROM listeAuthorsLivres();</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="automatisation_trigger">Automatisation : TRIGGER :</h4>
                            <p>Revenons à la problématique de la dénormalisation. Pour fixer les idées, nous regardons le problème particulier du champ total_sales de la table titles qui est en fait la somme de toutes les ventes de ce livre. Ce champ n'est pas en 3ème forme normale" : il dépend en effet d'autre chose qu'uniquement sa clé primaire puisqu'il dépend du contenu de la table Salesdetail.</p>
                            <p>Sa présence est justifiée dans la base de données pour des raisons de performance : si cette information est fréquemment demandée, il sera beaucoup plus rapide qu'il soit précalculée dans la bae de données plutôt que de devoir refaire ce calcul à chaque fois.</p>
                            <p>Mais il y a donc un risque de désynchronisation dès qu'il se passe quelque chose avec une vente de ce livre (ajout, suppression ou modification). Les bases de données offrent un mécanisme pour être sûr de garder cette synchronisation : les triggers. Un trigger est placé sur une table pour réagir en cas d'ajout, de suppression ou de modification. Dès qu'un de ces événements arrive, le trigger exécute une procédure stockée qui met à jour les données devant rester  synchronisées.</p>
                            <ol type="i">
                                <li>
                                    <h5 id="cas_typique_utilisation_trigger">Cas typique d'utilisation :</h5>
<pre class="taille60"><code>CREATE TRIGGER nom AFTER { INSERT | UPDATE | DELETE } ON table FOR EACH ROW EXECUTE PROCEDURE nomfonc;</code></pre>
                                    <p>La procédure <span class="em">nomfunc</span> doit être préalablement créée grâce à la commande <span class="html">CREATE FUNCTION</span>. Elle ne doit recevoir aucun paramètre mais retourner obligatoirement un type <span class="html">TRIGGER</span>. Cependant, la valeur de retour de ce paramètre sera ignorée avec la commande <span class="html">CREATE TRIGGER</span> ci-dessus. La procédure pourra donc se contenter de <span class="html">RETURN NULL</span>.</p>
                                    <p>À chaque insertion (<span class="html">INSERT</span>), mise à jour (<span class="html">UPDATE</span>) ou effacement (<span class="html">DELETE</span>), la procédure <span class="em">nomfonc</span> sera appelée pour chaque tuple inséré, modifié ou supprimé.  De plus, deux variables seront automatiquement disponibles lors de son exécution :</p>
                                    <ul>
                                        <li><span class="html">OLD</span> est un <span class="em">RECORD</span> contenant les anciennes valeurs du tuple modifié par un <span class="em">UPDATE</span>, effacé pour un <span class="em">DELETE</span> ou <span class="em">NULL</span> pour un <span class="em">INSERT</span>.</li>
                                        <li><span class="html">NEW</span> est un <span class="em">RECORD</span> contenant la nouvelle valeur du tuple dans la <span class="em">TABLE</span> pour un <span class="em">INSERT</span> ou un <span class="em">UPDATE</span>, ou <span class="em">NULL</span> pour un <span class="em">DELETE</span>.</li>
                                    </ul>
                                    <p class="souligne">Exemple :</p>
                                    <p>Cet exemple crée un trigger pour mettre le champ total_sales de la table titles automatiquement à jour lors de l'ajout d'un tuple dans sales_detail :</p>
<pre class="taille60"><code>CREATE OR REPLACE FUNCTION total_sales() RETURNS TRIGGER AS $$
DECLARE
    total INTEGER
BEGIN
    SELECT SUM (sd.qty) FROM salesdetail sd WHERE sd.title_id = NEW.title_id INTO total;
    UPDATE titles SET total_sales = total WHERE title_id = NEW.title_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER sales-detail_trigger AFTER INSERT OR SALESDETAIL FOR EACH ROW
EXECUTE PROCEDURE total_sales();</code></pre>
                                </li>
                                <li>
                                    <h5 id="reference_complete_create_trigger">Référence complète de CREATE TRIGGER :</h5>
<pre class="taille60"><code>CREATE TRIGGER nom { BEFORE | AFTER } { evenement [ OR ... ] }
ON table [ FOR [ EACH ] { ROW | STATEMENT } ]
EXECUTE PROCEDURE nomfonc ( arguments )</code></pre>
                                    <ul>
                                        <li>
                                            <p><span class="html">CREATE TRIGGER</span> crée un nouveau déclencheur. Le déclencheur est associé à la table spécifiée et exécute la fonction <span class="em">nomfonc</span> lorsqu'un de ces trois événements survient : <span class="html">INSERT</span>, <span class="html">UPDATE</span> ou <span class="html">DELETE</span>.</p>
                                            <p>L'appel du déclencheur peut avoir lieu avant que l'opération ne soit tentée sur une ligne (avant la vérification des contraintes et la tentative d'<span class="em">INSERT</span>, <span class="em">UPDATE</span> ou <span class="em">DELETE</span>) ou une fois que l'opération est terminée (après la vérification des contraintes et la fin de la commande <span class="em">INSERT</span>, <span class="em">UPDATE</span> ou <span class="em">DELETE</span>). SI le déclencheur est lancé avant l'événement, le déclencheur peut ignorer l'opération sur la ligne courante ou modifier la ligneen cours d'insertion (uniquement pour les opérations <span class="em">INSERT</span> et <span class="em">UPDATE</span>). Si le déclencheur est activé après l'événement, toute modification, dont la dernière insertion, mise à jour ou suppression, est "visible" par le déclencheur.</p>
                                            <p>Un déclencheur marqué <span class="html">FOR EACH ROW</span> est appelé pour chaque ligne que l'opération modifie. Par exemple, un <span class="em">DELETE</span> affectant dix lignes entraîne dix appels distincts de tout déclencheur <span class="html">ON DELETE</span> sur la relation cible, une fois par ligne supprimée. Au contraire, un déclencheur marqué <span class="html">FOR EACH STATEMENT</span> ne s'exécute qu'une fois pour une opération donnée, quelque soit le nombre de lignes modifiées (en particulier, une opération qui ne modifie aucune ligne résulte toujours en l'exécution des déclencheurs <span class="em">FOR EACH STATEMENT</span> applicables).</p>
                                            <p>Si plusieurs déclencheurs du même genre sont définis pour le même événement, ils sont déclenchés suivant l'ordre alphabétique de leur nom.</p>
                                            <p><span class="em">SELECT</span> ne modifie aucune ligne; la création de déclencheurs sur <span class="em">SELECT</span> n'est pas possible.</p>
                                            <p><span class="em">nomfonc</span> est le nom d'une fonction qui a été créée préalablement. Cette fonction n'a aucun paramètre et doit retourner un type <span class="em">TRIGGER</span>. Lorsque la fonction est appelée avant l'événement <span class="em">et</span> tuple par tuple (<span class="html">BEFORE</span> et <span class="html">FOR EACH ROW</span>), elle a l'occasion d'annuler l'opération ou de modifier le tuple (ce dernier cas n'est possible que pour <span class="em">INSERT</span> et <span class="em">UPDATE</span>).</p>
                                            <ul>
                                                <li>Pour modifier le tuple inséré ou modifié, il faut retourner une variable de type <span class="html">TRIGGER</span> contenant les nouvelles données à utiliser.</li>
                                                <li>Pour laisser l'opération s'exécuter normalement, il faut soit retourner <span class="em">NEW</span> pour les événements <span class="em">INSERT</span> et <span class="em">UPDATE</span>, soit retourner <span class="html">OLD</span> pour l'événement <span class="em">DELETE</span>.</li>
                                                <li>
                                                    <p>Pour annuler l'opération, il faut retourner <span class="em">NULL</span>. <span class="em">ATTENTION, CECI EST GÉNÉRALEMENT UNE ERREUR :</span></p>
                                                    <ul>
                                                        <li class="em">Cette technique est dangereuse car par exemple un <span class="em">INSERT</span> peut sembler avoir réussi alors que le trigger l'a silencieusement annulé. Lorsque ce problème surgit, il est excessivelent difficile d'en trouver l'origine et donc de la corriger.</li>
                                                        <li class="em">Nous verrons plus tard la mécanique permettant d'annuler une opération correctement.</li>
                                                        <li class="em">Il est donc <span class="souligne">interdit</span> dans le cadre de ce cours d'utiliser un trigger <span class="html">ON BEFORE</span> qui retourne <span class="html">NULL</span>.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                            <p>Dans le cas d'un <span class="em">TRIGGER</span> appelé après l'opération (<span class="html">AFTER</span>) ou bien d'un <span class="em">TRIGGER</span> de niveau instruction (<span class="html">FOR EACH STATEMENT</span>), le retour de la fonction est ignoré et peut aussi bien être <span class="em">NULL</span>. On peut cependant toujours annuler complètement l'opération en envoyant une erreur.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5 id="procedure_trigger_plpgsql">Procédure trigger en PL/pgSQL :</h5>
                                    <p>Une procédure trigger est créée grâce à la commande <span class="html">CREATE FUNCTION</span> utilisée comme fonction sans arguments ayant un type de retour <span class="em">TRIGGER</span>. Notez que la fonction doit être déclarée avec aucun argument même si elle s'attend à recevoir les arguments spécifiés dans <span class="html">CREATE TRIGGER</span> -- les arguments trigger sont passés via <span class="html">TG_ARGV</span>, comme décrit plus loin.</p>
                                    <p>Quand une fonction PL/pgSQL est appelée en tant que trigger, plusieurs variables spéciales sont créées automatiquement de plus haut niveau. Ce sont :</p>
                                    <ul>
                                        <li><span class="html">NEW</span> : Type de données <span class="em">RECORD</span>; variable contenant la nouvelle ligne de base de donénes pour les opérations <span class="em">INSERT</span>/<span class="em">UPDATE</span> dans les triggers de niveau ligne. Cette variable est <span class="em">NULL</span> dans un trigger de niveau instruction et pour les opérations <span class="em">DELETE</span>.</li>
                                        <li><span class="html">OLD</span> : Type de données <span class="em">RECORD</span>; variable contenant l'ancienne ligne de base de données pour les opérations <span class="em">UPDATE</span>/<span class="em">DELETE</span> dans les triggers de niveau ligne. Cette variable est <span class="em">NULL</span> dans les triggers de niveau instruction et pour les opérations <span class="em">INSERT</span>.</li>
                                        <li><span class="html">TG_NAME</span> :  Type de données <span class="em">name</span>; variable qui contient le nom du trigger réellement lancé.</li>
                                        <li><span class="html">TG_WHEN</span> : Type de données <span class="em">text</span>; une chaîne, soit <span class="html">BEFORE</span> ou <span class="html">AFTER</span>, selon la définition du trigger.</li>
                                        <li><span class="html">TG_LEVEL</span> : Type de données <span class="em">text</span>; une chaîne, soit <span class="html">BEFORE</span> ou <span class="html">AFTER</span>, selon la définition du trigger.</li>
                                        <li><span class="html">TG_OP</span> : Type de données <span class="em">text</span>; une chaîne, <span class="html">INSERT</span>, <span class="html">UPDATE</span>, <span class="html">DELETE</span> ou <span class="html">TRUCATE</span> indiquant pour quelle opération le trigger a été lancé.</li>
                                        <li><span class="html">TG_RELID</span> : Type de données <span class="em">oid</span>; l'<span class="html">ID</span> de l'obje de la table qui a causé le déclenchement du trigger.</li>
                                        <li><span class="html">TG_TABLE_NAME</span> : Type de données <span class="em">name</span>; le nom de la table qui a déclenché le trigger.</li>
                                        <li><span class="html">TG_NARGS</span> : Type de données <span class="em">integer</span>; le nombre d'arguments donnés à la procédure trigger dans l'instruction <span class="html">CREATE TRIGGER</span>.</li>
                                        <li><span class="html">TG_ARGV[]</span> : Type de données <span class="em">text</span>; les arguments de l'instruction <span class="html">CREATE TRIGGER</span>. L'index débute à 0. Les indices invalides (inférieurs à 0 ou suppérieurs ou égaux à tg_nargs) auront une valeur <span class="em">NULL</span>.</li>
                                    </ul>
                                    <p class="souligne">Exemple :</p>
                                    <p>Une procédure d'audit par trigger en PL/pgSQL. Cet exemple de trigger nous assure que toute insertion, modification ou suppression d'une ligne dans la table <span class="em">emp</span> est enregistrée dans la table <span class="em">emp_audit</span>. L'heure et le nom de l'utilisateur sont conservés dans la ligne avec le type d'opération réalisé.</p>
<pre class="taille60"><code>CREATE TABLE emp
(
    nom_employe TEXT NOT NULL,
    salaire INTEGER,
);

CREATE TABLE emp_audit
(
    operation CHAR (1) NOT NULL,
    tampon TIMESTAMP NOT NULL,
    id_utilisateur TEXT NOT NULL,
    nom_employe TEXT NOT NULL,
    salaire INTEGER,
);

CREATE FUNCTION audit_employe() RETURNS TRIGGER AS $$
BEGIN
    --
    -- Ajoute une ligne dans emp_audit pour réfléter l'opération réalisée sur emp,
    -- utilise la variable spéciale TG_OP pour cette opération.
    --
    IF (TG_OP = 'DELETE') THEN
        INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
    END IF;
    RETURN NULL; -- le résultat est ignoré car il s'agit d'un trigger AFTER
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW EXECUTE PROCEDURE audit_employe();</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="utilisateurs">Utilisateurs :</h4>
                            <p>La base de données gère aussi les utilisateurs. Ainsi, sur un serveur unique, il est possible de créer plusieurs bases de données, et d'attribuer des droits d'accès et d'écriture différents en fonction des utilisateurs.</p>
                            <ol type="i">
                                <li>
                                    <h5 id="create_user">CREATE USER :</h5>
<pre class="taille60"><code>CREATE USER nom [ [ WITH ] option [ ... ] ];</code></pre>
                                    <ul>
                                        <li>
                                            <p>où <span class="html">option</span> peut être :</p>
<pre class="taille60"><code>SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| CREATEUSER | NOCREATEUSER
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| CONNECTION LIMIT limite_connexion
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'motdepasse'
| VALID UNTIL 'dateheure'
| IN ROLE nomrole [, ...]
| IN GROUP nomrole [, ...]
| ROLE nomrole [, ...]
| ADMIN nomrole [, ...]
| USER nomrole [, ...]
| SYSID uid</code></pre>
                                        </li>
                                    </ul>
                                    <p>Comme on le constate, il est possible de spécifier toutes sortes de droits globaux au niveau du serveur. Typiquement on se contentera de créer un utilisateur comme ceci pour un utilisateur non administrateur de la base de données :</p>
<pre class="taille60"><code>CREATE USER nom PASSWORD 'motdepasse';</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="grant_revoke">GRANT / REVOKE :</h4>
                            <p><span class="html">GRANT</span> accorde des droits à un utilisateur, <span class="html">REVOKE</span> en supprime. Il existe de nombreuses variantes de ces instructions, nous en présentons ici une seule, veuillez consulter la documentation en ligne pour plus d'informations :</p>
<pre class="taille60"><code>GRANT { { SELECT | INSERT | UPDATE | DELETE }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] nomtable [, ...]
    TO { nomrole | PUBLIC } [, ...]
    REVOKE [ GRANT OPTION FOR ]
    { { SELECT | INSERT | UPDATE | DELETE }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] nom_table [, ...]
    FROM { nom_role | PUBLIC } [, ...]</code></pre>
                            <ol type="i">
                                <li>
                                    <h5>Exemple :</h5>
                                    <p>Georges est l'employé qui enregistre les ventes sur pubs2. Il n'a donc besoin d'insérer des tuples que dans les tables sales et salesdetail. Il doit par contre être capable de consulter le contenu de toutes les tables.</p>
<pre class="taille60"><code>CREATE USER georges PASSWORD 'jaimelipl';
GRANT CONNECT ON DATABASE pubs2 TO georges;
GRANT SELECT ON sales, salesdetail, titles, publishers, store, titleauthors TO georges;
GRANT INSERT ON TABLE sales, salesdetail TO georges;</code></pre>
                                    <p>Si pubs3 utilisait un schéma, il aurait fallu également donner les droits d'utilisation du schéma :</p>
<pre class="taille60"><code>GRANT USAGE ON SCHEMA pubs2 TO georges;</code></pre>
                                </li>
                                <li>
                                    <h5 id="cas_particulier_serial">Cas particulier des SERIAL :</h5>
                                    <p>Lorsqu'on veut donner les droits d'insert sur une table contenant un serial, il faut également donner les droits sur les séquences implicitement créées :</p>
<pre class="taille60"><code>GRANT USAGE, SELECT ON SEQUENCE id_seq TO georges;</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="simplification_requetes_view">Simplification des requêtes : VIEW :</h4>
<pre class="taille60"><code>CREATE VIEW nom [ ( nom_colonne [, ...] ) ] AS requête;

DROP VIEW nom;</code></pre>
                            <p>Un autre inconvénient de la normalisation est la décomposition des données en de multiples tables. Lors d'un <span class="em">SELECT</span>, il faudra donc effectuer la jointure de toutes les tables permettant d'accéder aux données dont on a besoin. Dans les situations complexes, cela force les requêtes à être artificiellement compliquées et nuit fortement à leur lisibilité. SQL propose une solution très élégante à ce problème : les vues (<span class="html">VIEW</span>). Une vue est une table virtuelle (car inexistante physiquement dans la base de données) correspondant au résultat d'un <span class="em">SELECT</span>. Cette table est elle-même utilisable en consultation pour tout autre <span class="em">SELECT</span> au même titre qu'une table physique réelle.</p>
                            <p>Les vues permettent aussi de changer le schéma d'une base de données plus facilement. En effet, tout code qui utilise l'ancien schéma pourra rester inchangé si l'on crée des vues le respectant.</p>
                            <p>Finalement, les vues permettent de gérer la visibilité des données en configurant la base de données pour empêcher l'accès direct aux tables mais en permettant celui aux vues juste nécessaires à l'utilisateur.</p>
                            <ol type="i">
                                <li>
                                    <h5>Exemples :</h5>
<pre class="taille60"><code>CREATE VIEW LivresDePsychologiePasChers (numéro, titre, editeur, prix)
AS SELECT T.title_id, T.title, P.pub_name, T.price
FROM titles T, publishers P
WHERE T.pub_id = P.pub_id
    AND T.type = 'psychology'
    AND T.price &lt; 20;

SELECT titre, prix
FROM LivresDePsychologiePasChers
WHERE editeur = 'New Age Books';</code></pre>
                                    <p>Cette instruction est traduite par SQL en :</p>
<pre class="taille60"><code>SELECT T.title, t.price
FROM titles T, Publishers P
WHERE T.pub_id = P.pub_id
AND T.type = 'psychology'
AND T.price &lt; 20
AND P.pub_name = 'New Age Books';

CREATE VIEW TotalVenteParMagasin (stor_id, stor_name, total_qty, total_price)
AS SELECT St.stor_id, St.stor_name, SUM (SD.qty), SUM (SD.qty * T.price)
FROM Stores St, Salesdetail SD, Titles T
WHERE St.stor_id = SD.stor_id AND SD.title_id = T.title_id
GROUP BY St.stor_id, St.stor_name;

CREATE VIEW TotalVenteParMagasinBis
AS SELECT stor_id, total_qty
FROM TotalVenteParMagasin
WHERE total_qty &gt; 5000;</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="performance_index">Performance : INDEX :</h4>
                            <p>Admettons que notre commerce devient aussi prolifique que celui d'Amazon, et que pubs2 soit rempli de millions de livres différents. Seulement les utilisateurs se plaignent des mauvaises performances de notre application et commencent à partir à la concurrence. Quand on observe de plus près qu'il se passe, on se rend compte que ces utilisateurs recherchent des livres principalement sur base de leur type (par exemple tous les livres de psychologie) et qu'avec le temps on a maintenant des milliers de type différents. À chacune de ces requêtes, notre serveur doit donc parcourir l'intégralité de la table titles afin de trouver ceux correspondant au type recherché.</p>
                            <p>Le même problème pourrait apparaître pour trouver un title_id particulier lors d'une jounture, cependant là on n'observe pas de ralentissement du serveur. La raison est qu'à chaque clef primaire le serveur crée automatiquement un index sur cette clef afin d'accélérer les jointures. Mais on garde la possibilité de créer des index supplémentaires si on en a besoin.</p>
<pre class="taille60"><code>CREATE [ UNIQUE ] INDEX nom ON table [ USING méthode ]
( { colonne | ( expression ) } [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [,
...] );</code></pre>
                            <ul>
                                <li>
                                    <p><span class="html">CREATE INDEX</span> construit un index <span class="em">nom</span> sur la table spécifiée. Les index sont principalement utilisés pour améliorer les performances de la base de données (bien qu'une utilisation inappropriée puise produire l'effet inverse).</p>
                                    <p>Les champs clé pour l'index sont spécifiés à l'aide de noms des colonnes ou par des expressions écrites entre parenthèses. Plusieurs champs peuvent être spécifiés si la méthode d'indexation supporte les index multi-colonnes.</p>
                                    <p>Un champ d'index peut être une expression calculée à partir des valeurs d'une ou plusieurs colonnes de la ligne de table. Cette fonctinnalité peut être utilisée pour obtenir un accès rapide à des données obtenues par transformation des données basiques. Par exemple, un index calculé sur <span class="em">upper(col)</span> autorise clause <span class="em">WHERE upper(col) = 'JIM'</span> à utiliser un index.</p>
                                    <p>PostgreSQL<sup>TM</sup> fournit les méthodes d'indexation <span class="em">B-tree</span> (NDT : arbres balancés), <span class="em">hash</span> (NDT : hachage), <span class="em">GiST</span> (NDT : arbres de recherche généralisés) et <span class="em">GIN</span>.</p>
                                </li>
                                <li><span class="html">UNIQUE</span> : Le système vérifie la présence de valeurs dupliquées dans la table à la création de l'index (si des données existent déjà) et à chaque fois qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour qui résultent en des entrées dupliquées engendrent une erreur.</li>
                                <li><span class="html">nom</span> : Le nom de l'index à créer. On pourra supprimer l'index par la commande <span class="html">DROP INDEX nom</span>.</li>
                                <li><span class="html">table</span> : Le nom de la table.</li>
                                <li><span class="html">méthode</span> : Le nom de la méthode à utiliser pour l'index. Les choix sont <span class="html">btree</span>, <span class="html">hash</span>, <span class="html">gist</span> et <span class="html">gin</span>. La méthode par défaut est <span class="html">btree</span>.</li>
                                <li><span class="html">colonne</span> : Le nom d'une colonne de la table.</li>
                                <li><span class="html">expression</span> : Une expression basée sur une ou plusieurs colonnes de la table. L'expression doit habituellement être écrite entre parenthèses, comme la synytaxe le précise. Néanmoins, les parenthèses peuvent être omises si l'expression a la forme d'un appel de fonction.</li>
                                <li><span class="html">ASC</span> : Spécifie un ordre de tri ascendant (valeur par défaut).</li>
                                <li><span class="html">DESC</span> : Spécifie un ordre de tri descendant.</li>
                                <li><span class="html">NULLS FIRST</span> : Spécifie que les valeurs <span class="em">NULL</span> sont présentées avant les valeurs non NULL. Ceci est la valeur par défaut quand <span class="em">DESC</span> est indiqué.</li>
                                <li><span class="html">NULLS LAST</span> : Spécifie que les valeurs <span class="em">NULL</span> sont présentées après les valeurs non NULL. Ceci est la valeur par défaut quand <span class="em">ASC</span> est indiqué.</li>
                            </ul>
                            <ol type="i">
                                <li>
                                    <p>Créer un index sur le champ type de la table titles.</p>
<pre class="taille60"><code>CREATE INDEX titles_type
ON titles
USING btree(type);</code></pre>
                                </li>
                            </ol>
                        </li>
                    </ol>
                    <h3 id="concurrence">Concurrence :</h3>
                    <p>En situation réelle, les bases de données sont consultées et modifiées simultanément par un grand nombre d'utilisateurs. Par exemple, un site d'enchères devra répondre simultanément à toutes les requêtes de tous les utilisaateurs qui le consultent à un instant donné. Il devra prendre en compte correctement une enchère par un utilisateur et ce même si un autre utilisateur essaie simultanément de faire la même chose. On appelle concurrence le fait qu'une donnée unique soit accédée ou modifiée simultanément par plusieurs incstances (ici des personnes différentes). La concurrence introduit une complexité supplémentaire aux opérations que l'on effectue. Par exemple, si l'enchère permet un achat immédiat (au-delà d'un certain montant, l'objet est automatiquement gagné par l'enchéreur et celle-ci se conclut donc immédiatement), que se passe-t-il si deux utilisateurs effectuent cette opération simultanément ?</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Utilisateur A</th>
                                <th>Utilisateur B</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sélectionne achat immédiat</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>Sélectionne achat immédiat</td>
                            </tr>
                            <tr>
                                <td>
                                    <p>Le système vérifie que l'enchère est toujours ouverte</p>
                                    <p>&#8594; OUI</p>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>
                                    <p>Le système vérifie que l'enchère est toujours ouverte</p>
                                    <p>&#8594; OUI</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>Le système clôture l'enchère et marque que l'acheteur est A</p>
                                    <p>Le système notifie A qu'il a gagné l'enchère</p>
                                    <p>Le vendeur est notifié qu'il a vendu l'objet à A</p>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>
                                    <p>Le système clôture l'enchère et marque que l'acheteur est B</p>
                                    <p>Le système notifie B qu'il a gagné l'enchère</p>
                                    <p>Le vendeur est notifié qu'il a vendu l'objet à B</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Les deux utilisateurs penseront avoir gagné l'enchère ! Comme il n'y a qu'un seul champ acheteur le système écrira donc d'abord A et puis B, mais cela aurait aussi bien pu être B et puis A. Dans les deux cas, l'information de la première vente est écrasée et donc perdue. Le vendeur est notifié deux fois de la vente de son objet. Il doit choisir à qui envoyer son objet, mais ne sait pas qui est mis comme acheteur dans la base de données (A qui a écrasé B ou l'inverse).</p>
                    <p>Il va sans dire que cette situation n'est pas admissible et il faut donc une gestion explicite de la concurrence.</p>
                    <ol type="a">
                        <li>
                            <h4 id="acid">ACID :</h4>
                            <p>Les bases de données fournissent un mécanisme permettant de gérer la concurrence : les transactions. Une transaction est une séquence d'opérations qui fait passer une base de données d'un état A cohérent à un état B cohérent. Les transactions respectent les propriétés <span class="em">ACID : Atomique, Cohérent, Isolé et Durable</span>.</p>
                            <ul>
                                <li><span class="html">Atomique</span> : l'ensemble des opérations sera réalisé complètement ou pas du tout. Une transaction termine soit par une opération de réussite (<span class="html">commit</span>) ou par une opération d'échec (<span class="html">rollback</span>). Lors d'un commit, toutes les opérations sont effectuées. Lors d'un rollback, aucune de ces opérations n'est effectué : c'est exactement comme si la transaction n'avait jamais eu lieu.</li>
                                <li><span class="html">Cohérent</span> : le résultat de l'exécution d'une transaction doit être cohérent, même si chaque opération de la transaction exécutée séparément ne donne pas un résultat cohérent. Un résultat incohérent entraînera l'échec et l'annulation des opérations de la transaction.</li>
                                <li><span class="html">Isolé</span> : lorsque deux transactions A et B sont exécutées en même temps, les modifications effectuées par A ne sont pas visibles par B tant que la transaction A n'est pas terminée et validée (commit).</li>
                                <li><span class="html">Durable</span> : une transaction terminée ne peut pas être annulée ou recouverte. Lorsque deux transactions sont exécutées en même temps, le résultat de la première transaction ne pourra pas être recouvert par la deuxième. Toute tentative de recouvrement entraînera l'annulation des opérations de la transaction fautive.</li>
                            </ul>
                            <p>Reprenons l'exemple de l'enchère, et plaçons l'opération d'achat immédiat au sein d'une transaction ACID.</p>
                            <ul>
                                <li>La transaction commence lorsqu'un utilisateur sélectionne l'option achat immédiat et se termine lorsque l'enchère est clôturée et les parties notifiées correctement. L'atomicité garantit que tout ceci se fait complètement, ou pas du tout.</li>
                                <li>Lorsque l'enchère est clôturée, l'acheteur doit être notifié et le vendeur doit être notifié de cet acheteur. La cohérence garantit que ces différentes opérations seront cohérentes entre elles.</li>
                                <li>Admettons que l'acheteur A et B commencent leur transaction simultanément. L'isolation garantit que ce qui se passe dans la transaction A n'influencera pas ce qui se passe dans la transaction B. En d'autres mots, quand A marque l'enchère comme étant clôturée, B ne le voit pas du tout ! C'est seulement quand A termine sa transaction que cette modification devient visible pour B. Mais alors le système se rendra compte par la cohérence qu'il y a un problème de concurrence entre les deux transactions et annulera celle de B. De par l'atomicité, la transaction B sera complètement annulée comme si elle n'avait jamais eu lieu.</li>
                                <li>Une fois que A termine sa transaction (commit), alors cette enchère est marquée durablement dans la base de données. Par exemple, il n'y aura plus jamais de cas où cette enchère sera encore considérée ouverte.</li>
                            </ul>
                        </li>
                        <li>
                            <h4 id="transaction_sql">Transaction en SQL :</h4>
                            <ul>
                                <li><span class="html">START TRANSACTION</span> débute une transaction.</li>
                                <li><span class="html">COMMIT</span> valide la transaction en cours.</li>
                                <li><span class="html">ROLLBACK</span> annule la transaction en cours.</li>
                            </ul>
                            <p>Attention, un bloc de transaction ne correspond pas à un bloc d'exécution de l'application. En particulier, il ne faut pas confondre ce comportement avec une méthode Java où le fait de return quitte immédiatement la méthode. La paire <span class="html">START TRANSACTION ... COMMIT</span> ne forme donc pas un bloc d'exécution terminé immédiatement si l'on rencontre un <span class="html">ROLLBACK</span> au milieu !</p>
                            <p>En réalité, les requêtes SQL se passent <span class="souligne">toujours</span> dans le contexte d'une transaction. Ceci semble contradictoire avec tout ce que l'on fat jusqu'ici : on n'a jamais utilisé <span class="em">START TRANSACTION</span> et <span class="em">COMMIT</span>, et pourtant les données ont manifestement été mises à jours et on a bien obtenu des réponses à nos requêtes. En réalité en dehors d'une transaction explicite, toutes les requêtes SQL sont implicitement exécutées dans leur propre transaction qui est directement <span class="em">COMMIT</span>. C'est exactement comme si chacune de ces instructions était précédée par <span class="em">START TRANSACTION</span> et suivie par <span class="em">COMMIT</span>. On appelle cela l'auto-commit.</p>
                            <p>On utilisera une transaction explicite dans les situations suivantes :</p>
                            <ul>
                                <li>On a besoin d'effectuer plusieurs opérations  successices, qui ont des dépendances entre elles. Le cas le plus fréquent est quand on doit mettre plusieurs tuples à jour dans plusieurs tables et que ces modifications doivent toutes être effectuées pour garder la cohérence globale. Un autre exemple est quand on effectue des vérifications sur le contenu de la base de données avant d'effectuer une mise à jour. Par exemple, on vérifie qu'il reste un livre en stock avant de le vendre à un client. C'est l'atomicité de la transaction qui permet d'effectuer cela d'une manière cohérente.</li>
                                <li>La création d'une transaction requiert du travail de la part du serveur. Si l'on exécute beaucoup d'instructions SQL (qui peuvent être indépendantes), on gagnera grandement en temps d'exécution si l'on exécute le tout dans une unique transaction explicite. Pour rappel, en l'absence de transaction explicite, l'auto-commit créera une transaction implicite pour chacune des instructions SQL, consommant inutilement les ressources du serveur.</li>
                            </ul>
                            <ol type="i">
                                <li>
                                    <h5 id="transactions_plpgsql">Transactions en PL/pgSQL :</h5>
                                    <p>N'oublions pas qu'il faut faire la distinction entre le pur SQL et le SQL procédural. Avec PostgreSQL, la gestion des transactions est différente entre les deux. En PL/pgSQL :</p>
                                    <ul>
                                        <li>Une procédure stockée est en effet toujours exécutée au sein d'une unique transaction. Si elle est appelée en dehors d'une transaction explicite, c'est le mécanisme d'auto-commit qui en crée une implicitement.</li>
                                        <li><span class="em">START TRANSACTION ... COMMIT</span> n'a donc pas d'effet en PL/pgSQL.</li>
                                        <li>Si la procédure stockée lance une exception, alors la transaction dans laquelle est exécutée effectue un <span class="em">ROLLBACK</span>.</li>
                                        <li>Si la procédure stockée fini son exécution normalement, alors la transaction dans laquelle est exécutée continue normalement jusqu'à un éventuel <span class="em">COMMIT</span> ou <span class="em">ROLLBACK</span> futur.</li>
                                        <li>Si la procédure est exécutée en mode auto-commit et si elle termine normalement alors elle est directement suivie d'un <span class="em">COMMIT</span>.</li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Voici une procédure stockée chargée de gérer complètement une vente. Notez l'usage de la transaction afin de garantir que les différentes étapes de la vente seront bien effectuées correctement.</p>
<pre class="taille60"><code>CREARE FUNCTION sell (VARCHAR (6), CHARACTER (4), VARCHAR (20), SMALLINT) RETURNS BOOLEAN AS $$
DECLARE
    v_title_id ALIAS FOR $1;
    v_stor_id ALIAS FOR $2;
    v_ord_num ALIAS FOR $3;
    v_qty ALIAS FOR $4;
    price INTEGER;
BEGIN
    price := (SELECT prices FROM titles WHERE title_id = v_title_id);
    IF price IS NULL THEN
        RAISE no_data;
    ELSE
        INSERT INTO sales VALUES (v_stor_id, v_ord_num);
        INSERT INTO salesdetail VALUES (v_stor_id, v_ord_num, v_title_id, v_qty);
        UPDATE titles
            SET total_sales = ((
                SELECT total_sales
                FROM titles
                WHERE title_id = v_title_id 
            ) + v_qty)
            WHERE title_id = v_title_id;
        RETURN true;
    END IF;
END;
$$ LANGUAGE plpgsql;</code></pre>
                                </li>
                                <li>
                                    <h5 id="transaction_trigger">Transaction et trigger :</h5>
                                    <p>Lorsqu'une opération résulte en l'exécution d'un (ou plusieurs) triggers, ceux-ci sont exécutés dans la même transaction que l'opération. En particulier, si la procédure trigger jette une exception, c'est toute la transaction qui est annulée comprenant donc aussi l'opération. Ceci permet de programmer des contraintes d'intégrité plus intelligentes que ce qui est normalement permis : à l'insertion ou la modification le trigger valide les données et jette une exception si elles ne sont pas acceptables.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4 id="mvcc">MVCC :</h4>
                            <p>PostgreSQL (ainsi que de nombreuses autres bases de données) réalise le mécanisme de transaction par la technique de MultiVersion Concurrency Control (MVCC) :</p>
                            <ul>
                                <li>Chaque requête ne voit que les transactions terminées avant qu'elle n'ait commencé.</li>
                                <li>À chaque transaction est associé un compteur unique (timestamp) permettant de les ordonner dans le temps.</li>
                                <li>Chaque tuple est annoté par deux méta-informations : un compteur de transaction de création et un compteur de transaction d'expiration.</li>
                                <li>
                                    <p>Au démarrage d'une requête, PostgreSQL retient :</p>
                                    <ul>
                                        <li>Le compteur de cette transaction</li>
                                        <li>Tous les compteurs des transactions en cours d'exécution</li>
                                    </ul>
                                </li>
                                <li>Dans une transaction couvrant plusieurs instructions SQL, les instructions précédentes de la transaction sont visibles au sein même de la transaction.</li>
                                <li>Lorsqu'il y a insertion ou modification d'un tuple dans une transaction, le tuple original reste dans la table. Un tuple supplémentaire est ajoyté, annoté en création par le compteur de la transaction.</li>
                                <li>Lorsqu'il y a suppression d'un tuple dans une transaction, le tuple original est annoté en expiration par le compteur de la transaction.</li>
                                <li>
                                    <p>Les tuples visibles au sein d'une transaction doivent être annotés en création par un compteur de transaction tel que :</p>
                                    <ul>
                                        <li>Cette transaction a été commitée.</li>
                                        <li>
                                            <p>Ce compteur est inférieur au compteur de la transaction en cours.</p>
                                            <p>et</p>
                                            <p>Ce compteur ne faisait pas partie d'une autre transaction en cours au démarrage de celle-ci.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Les tuples visibles au sein d'une transaction doivent aussi être annotés en expiration par un compteur de transaction tel que :</p>
                                    <ul>
                                        <li>Il est vide ou annulé.</li>
                                        <li>
                                            <p>Ce compteur est supérieur au compteur de la transaction en cours.</p>
                                            <p>ou</p>
                                            <p>Ce compteur faisait partie d'une autre transaction en cours au démarrage de celle-ci.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <p>Ainsi, la base de donées est capable d'exécuter les transactions en parallèle plutôt que séquentiellement. Pour chaque transaction, à tout instrant le système posède suffisament d'informations pour pouvoir inférer quels sont les tuples logiquement visibles au sein de cette transaction. À chaque requête, la base de données effectue un parcours séquentiel de la table et en fonction des annotations et des critères ci-dessus décide si le tuple est visible ou non.</p>
                            <p>Il existe un inconvénient à cette technique : phyiquement le système n'est capable que d'ajouter de l'information, jamais de la supprimer. Et chaque modification ajoute un tuple supplémentaire plutôt que d'écraser l'ancien. Ce n'est qu'une question de temps avant que la base de données grandisse au-delà de la taille disque disponibke. Il existe donc une commande permettant de nettoyer les tuples périmés afin de récupérer leur espace physique. C'est la commande <span class="html">VACUUM</span> qui s'en charge. PostgreSQL est aussi capable de déterminer automatiquement quand cette commande devrait être utilisée et de le faire sans intervention extérieure.</p>
                            <p>La technique MVCC est affinée en différents niveaux de performances et de garanties. En général, plus on demande des garanties sur la transaction, moin son a un niveau élevé de performance et inversement.</p>
                        </li>
                    </ol>
<pre class="taille60"><code>START TRANSACTION [ mode_transaction [, ...] ]</code></pre>
                    <ul>
                        <li>
                            <p>où <span class="em">mode_transaction</span> fait partie de :</p>
<pre class="taille60"><code>ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ
| READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY</code></pre>
                            <p>Les caractéristiques de transition disponibles sont le niveau d'isolation et le mode d'accès de la transaction (lecture/écriture ou lecture seule).</p>
                            <p>Le niveau d'isolation détermine les données que la transaction peut voir quand d'autres transactions fonctionnent concurrentiellement :</p>
                            <ul>
                                <li><span class="html">READ COMMITTED</span> : Une instruction ne peut voir que les lignes validées avant qu'elle ne commence. C'est la valeur par défaut.</li>
                                <li><span class="html">SERIALIZABLE</span> : Toute instruction de la transaction en cours ne peut voir que les lignes validées avant que la première requête ou instruction de modification de données soit exécutée dans cette transaction.</li>
                            </ul>
                            <p>Le standard SQL définit deux niveaux supplémentaires, <span class="html">READ UNCOMMITTED</span> et <span class="html">REPEATABLE READ</span>. Dans PostgreSQL<sup>TM</sup>, <span class="em">READ UNCOMMITTED</span> est traité comme <span class="em">READ COMMITTED</span> alors que <span class="em">REPEATABLE READ</span> est traité comme <span class="em">SERIALIZABLE</span>.</p>
                            <p>La méthode d'accès de la transaction détermine si elle est en lecture/écriture ou en lecture seule. Lecture/écriture est la valeur par défaut. Quand une transaction est en lecture seule, les commandes SQL modifiant le contenu de la base de données sont interdites.</p>
                        </li>
                    </ul>
                    <h3 id="sql_embarque">SQL embarqué :</h3>
                    <p>Nous sommes donc maintenant capables de créer une base de données, d'y insérer/modifier/supprimer des données, d'automatiser la mise à jour de certains champs, de créer des vues, de gérer la concurrence, etc. Il ne reste donc maintenant plus qu'à écrire l'application qui va avec ces données ! Alors que la base de données est installée sur un serveur joignable par Internet, l'applicaion elle-même s'exécute généralement chez le client. Cette application se doit d'avoir une belle interface utilisateur, de gérer des aspects supplémentaires que juste les données, etc. C'est pourquoi on écrira cette application dans un langage de programation adapté à cette tâche. Nou utiliserons Java ici. Quand le programme Java aura besoin d'interagir avec la base de données, on y embarquera les commandes SQL correspondantes. On appelle donc cela le SQL embarqué (embedded SQL en anglais).</p>
                    <ol type="a">
                        <li>
                            <h4 id="jdbc">JDBC :</h4>
                            <p>Le module Java gérant le SQL embarqué s'appelle JDBC et est inclus en standard avec Java. JDBC est en fait le portage d'ODBC qui est la technologie à l'origine du SQL embarqué. Cette technologie date du début des années 1990, et, à l'époque, ses créateurs comptaient encore à partir de 1, alors que tout bon informaticien moderne se foit de compter à partir de zéro. Cet avis n'engage que l'auteur de ce texte ! Par héritage du pasé, JDBC requiert donc aussi de compter à prtir de 1 !</p>
                        </li>
                        <li>
                            <h4 id="driver">Driver :</h4>
                            <p>Le modèle JDBC requiert un driver pour fonctionner avec une base de données. Dans le cas de PostgreSQL, ce driver est disponible à l'adresse : <a href="http://jdbc.postgresql.org/download.html" target="_blank">http://jdbc.postgresql.org/download.html</a>.</p>
                            <p>Ce driver doit être placé dans le Build Path du projet Java qui l'utilise. Dans Eclipse, il fautplacerle jar (par exemple, postgresql-8.4-701.jdbc4jar) dans un répertoire du projet, cliquez-droit dessus et sélectionnez <span class="em">BuildPath/Add to Build Path</span>. Ceci permet à votre application d'accéder à ce driver pendant la compimation et son exécution.</p>
                            <p>En plus, il faut dire à l'application de charger ce driver en mémoire, ce qui se fait par cette commande :</p>
<pre class="taille60"><code>Class.forName("org.postgresql.Driver");</code></pre>
                        </li>
                        <li>
                            <h4 id="connection">Connection :</h4>
                            <p>Une fois le driver chargé, il faut établir une connexion avec la base de données :</p>
<pre class="taille60"><code>String url="jdbc:postgresql://postgresql.ipl/be/pubs2?user=public&password=public";
Connection conn = DriverManager.getConnection(url);</code></pre>
                            <p>L'URL est composé de :</p>
                            <ul>
                                <li><span class="html">jdbc:postgresql</span> : signale que driver utiliser.</li>
                                <li><span class="html">//postgresql.ipl.be</span> : URL du serveur, peut se terminer par <span class="html">:port</span> pour préciser un numéro de port.</li>
                                <li><span class="html">/pubs2</span> : nom de la base de données.</li>
                                <li><span class="html">?user=public</span> : nom de l'utilisateur à connecter.</li>
                                <li><span class="html">&password=public</span> : mot de passe.</li>
                            </ul>
                            <p>Notez que <a href="https://en.wikipedia.org/wiki/Percent-encoding" target="_blank">le format d'encodage des caractères spéciaux des URLs</a> est d'application. Vous trouverez d'autres méthodes statiques dans la classe DriverManager qui ne requièrent pas d'encoder le login et le mot de passe.</p>
                            <p>Sur base d'une connexion, on pourra envoyer autant de commandes SQL qu'on le souhaite, et recevoir tout autant de résultats. Chaque connexion prend un certain temps à s'établir et occupe de la ressource auprès du client et du serveur. On veuillera donc à n'ouvrir une connexion qu'en cas de réel besoin. En général, on aura deux stratégies viables :</p>
                            <ul>
                                <li>Pour une application mono-utilisateur, l'application ouvre une connexion au démarrage et la garde active pendant toute sa durée de vie. Toutes les opérations DB passent par cette connexion.</li>
                                <li>Pour une application multi-utilisateur (typiquement une application Web), plusierus connexions sont ouvertes et fermées suivant les besoins en cours. Ainsi, quand moins d'utilisateurs sont actifs, les connexions sont fermées. Quand plus d'utilisateurs sont actifs, des connexions sont ouvertes en plus. En général, on utilise une librairie pour effectuer cette maintenance de connexions.</li>
                            </ul>
                            <p>Pour fermer manuellement une connexion, il faut appeler la méthode <span class="em">close</span> :</p>
<pre class="taille60"><code>conn.close();</code></pre>
                        </li>
                        <li>
                            <h4 id="statement">Statement :</h4>
                            <p>À partir d'une connexion, on peut créer un <span class="em">Statement</span> : une instruction SQL.</p>
<pre class="taille60"><code>try {
    st.execute("DELETE FROM Store;");
} catch (SQLException e) {
    e.printStackTrace();
}</code></pre>
                            <p>La méthode <span class="html">execute(String sql)</span> se charge d'exécuter cette instruction. Cette métode déclare lancer l'exception <span class="html">SQLException</span> que l'on est obligé d'attraper. En fait, toutes les méthodes de JDBC qui interagissent avec le serveur sont susceptibles de lancer cette exception. On se retrouve donc assez rapidement à devoir écrire des blocs <span class="html">try {} catch</span> en de multiples endroits, ce qui rend le code plutôt difficile à lire.</p>
                        </li>
                        <li>
                            <h4 id="resultset">ResultSet :</h4>
                            <p>En plus d'envoyer des instructions SQL, on a besoin de récupérer le résultat obtenu. Ceci se fait grâce aux <span class="html">ResultSet</span> :</p>
<pre class="taille60"><code>ResultSet rs = null;
try {
    Statement st = conn.createStatement(),
    try (ResulSet rs = st.executeQuery("SELECT au_fname, au_lname " + "FROM Authors;")) {
        while (rs.next()) {
            String r = rs.getString(1) +  " " + rs.getString(2);
            System.out.println(r);
        }
    }
} catch (SQLException e) {
    e.printStackTrace();
}</code></pre>
                            <p>La méthode <span class="html">executeQuery</span> d'un <span class="em">Statement</span> est similaire à la méthode <span class="em">execute</span> (elle exécute une commande SQL), mais en plus elle retourne un <span class="em">ResultSet</span> permettant d'accéder au résultat de la query.</p>
                            <p>Le <span class="em">ResultSet</span> est un curseur sur les résultats, similaire à un <span class="em">Iterator</span> Java. La méthode <span class="html">next()</span> permet de déplacer ce curseur vers l'avant; elle retourne <span class="em">false</span> quand on est arrivé à la fin des tuples, <span class="em">true</span> sinon. Il y a toute une série de getters permettant de récupérer les différents champs du tuple ponté par le curseur. Chacun de ces getters retourne un type Java particulier;  il faut choisir le getter qui a un sens par rapport au type du champ dans la base de données. Le paramètre des getters spécifie quel champ doit être retourné; comme dit précédemment, le premier champ est le numéro 1.</p>
                            <p>Un <span class="em">ResultSet</span> doit être fermé pour relâcher les ressources JDBC le concernant. La bonne pratique consiste à utiliser un <span class="em">try</span> d'allocation de ressource : la variable déclarée dans la parenthèse suivant le <span class="em">try</span> sera automatiquement clôturée à la fin de ce dernier. Ainsi, la base de données et le driver JDBC sont mis au courant que le curseur du <span class="em">ResultSet</span> peut disparaître et éviter ainsi une fuite de mémoire.</p>
                        </li>
                        <li>
                            <h4 id="preparedstatement">PreparedStatement :</h4>
                            <p>On a fréquemment besoin de paramétrer les requêtes en fonction de données provenant de l'application elle-même, par exemple en fonction d'une entrée de l'utilisateur. Il serait alors tentant d'utiliserun <span class="em">Statement</span> en construisant à l'exécution la chaîne de caractères spécifiant la requête SQL :</p>
<pre class="taille60"><code>public void showNames (String state) {
    try {
        Statement st = conn.createStatement(),
        try (ResulSet rs = st.executeQuery("SELECT au_fname, au_lname " + "FROM Authors " + "WHERE state = '" + state + "';")) {
            while (rs.next()) {
                String r = rs.getString(1) +  " " + rs.getString(2);
                System.out.println(r);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}</code></pre>
                            <p>Cette manière de faire est en fait très dangereuse ! Imaginons que le paramètre state provient d'une interface utilisateur permettant à l'utilisateur d'y mettre tout ce qu'il veut. S'il rentre :</p>
<pre class="taille60"><code>XX'; DROP TABLE SalesDetail; SELECT 'a'  'a</code></pre>
                            <p>La query devient :</p>
<pre class="taille60"><code>SELECT au_fname, au_lname FROM Authors WHERE state = 'XX'; DROP TABLE SalesDetail; SELECT 'a', 'a';</code></pre>
                            <p>Nous venons juste de perdre la table <span class="em">SalesDetail</span>. La query quant à elle retourne le tuple ('a', 'a') et le programme continue de s'exécuter comme si de rien n'était.</p>
                            <p>Il ne faut surtout pas croire que c'est un cas hypothétique et tordu qui n'arrive pas en réalité : ceci s'appelle une attaque par injection de SQL et est probablement le numéro un des failles de sécurité des sites web !</p>
                            <p>Pour éviter ce genre de problème, il faut utiliser <span class="html">PreparedStatement</span> à la place de <span class="em">Statement</span> :</p>
<pre class="taille60"><code>public void showNames (String state) {
    try {
        PreparedStatement st = conn.prepareStatement("SELECT au_fname, au_lname " + "FROM Authors " + "WHERE state = ?;");
        st.setString(1, state);
        try (ResultSet rs = st.executeQuery()) {
            while (rs.next()) {
                String r = rs.getString(1) +  " " + rs.getString(2);
                System.out.println(r);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}</code></pre>
                            <p>La méthode <span class="html">prepareStatement</span> prend une instruction SQL paramétrée par zéro, un ou plusieurs <span class="html">?</span>. Chaque <span class="em">?</span> représente une place logique à remplir plus tard. C'est le <span class="em">PreparedStatement</span> qui se charge de ce remplissage, d'une manière qui est garantie correcte. Par exemple, pourun champ textuel, il ne faudra pas placer d'apostrophes autours du <span class="em">?</span>, c'est le <span class="em">prepareStatement</span> qui se chargera de le faire.</p>
                            <p>Un <span class="em">PreparedStatement</span> ainsi créé peut être configuré à tout moment à l'aide de setters. Tout comme pour les <span class="em">ResulSet</span>, les setters existent sous différentes formes portant sur des types Java différents qu'il faut choisir en accord avec le type du champ correspondant de la base de données. Le premier paramètre du setter est le numéro du <span class="em">?</span> qu'il faut remplir, en comptant de nouveau à partir de 1. Le second paramètre est la valeur à place. Une fois que tous les <span class="em">?</span> ont été settés, <span class="em">executeQuery()</span> retourne le <span class="em">ResultSet</span> correspondant.</p>
                            <p>Avec cette technique, on évite tous les problèmes d'injection de SQL. Ainsi, dans l'exemple ci-desssus, le <span class="em">PreparedStatement</span> recherchera juste un état dont le nom est bien toute la chaîne "<span class="em">XX'; DROP TABLE SalesDetail; SELECT 'a', 'a</span>".</p>
                            <p>Un <span class="em">PreparedStatement</span> peut être utilisé plusieurs fois dans des requêtes successives paramétrées indépendamment les unes des autres. Ceci permet de mieux factoriser son code et a aussi l'avantage d'être plus performant. En effet, chaque instruction SQL doit être traduite par la base de données. Avec un <span class="em">PreparedStatement</span>, la base de données traduit l'instruction (incomplète) une et une seule fois.À l'exécution du <span class="em">PreparedStatement</span>, la base de données n'aura qu'à compléter les parties manquantes de l'instruction pour pouvoir l'exécuter.</p>
                            <p class="em">Remarque importe : Puisque les PreparedStatement sont plus efficaces et plus sûrs que les Statement simples, il faudra toujours les préférer. Dans le cadre de ce cours, l'utilisation d'un Statement est donc considérée comme une faute, et sanctionné comme tel.</p>
                        </li>
                        <li>
                            <h4 id="integration_java_db">Intégration entre Java et une base de données :</h4>
                            <p>Comme nous l'avons vu, il est possible de stocker des procédures au niveau de la base de données et d'utiliser des triggers pour les appeler automatiquement. Alternativement, on pourrait réaliser une fonctionnalité similaire e Java : répérer les requêtes qui exigent des mises à jour supplémentaires et alors appeler la méthode Java qui effectue cette dernière. On a donc une frontière qui se supperpose entre les deux mondes.</p>
                            <img src="../images/integration_Java_db.PNG" alt="Intégration entre Java et une base de données">
                            <p>Pour la partie commune, il y a des raisons diverses pour préférer Java à SQL ou inversement.</p>
                            <ul>
                                <li>D'un point de vue monétaire, les grands vendeurs de base de données pousseront toujours à préférer SQL. Non seulement parce que cela fait partie de leur coeur de métier, mais surtout parce que cela lie fortement le logiciel avec leur produit et empêche ainsi de migrer vers la concurrence. En effet, tous les vendeurs proposent des extensions de SQL qui leur sont spécifiques, et dès que l'on commence à leur exploiter il devient difficile voire impossible de porter la base de données vers un autre produit. Si l'on veut éviter ce piège, il devient important de se limiter au strict minimum de SQL possible en favorisant au plus Java. Souvent, en entreprise, ceci est une décision stratégique sur laquelle le développeur n'aura pas d'influence. Les petites entreprises préfèrent en général ne pas se lier à un vendeur pour limiter leurs coûts, tandis que les grosses entreprises préfèrent se lier à Oracle ou à Microsoft afin de bénéficier d'un support préférentiel.</li>
                                <li>D'un point de vue pragmatique, on peut s'interroger sur la nécessité de reproduire en Java des fonctionnalités déjà existantes en SQL. Surtout que ces fonctionnalités SQL sont sûrement des solutions beaucoup plus matures et optimisées. Ainsi, ce courant de pensée pousse à utiliser la base de données dans toutes ses possibilités. La partie Java doit être la moins concernée possible par le stockage des données, c'est la base de données qui a cette responsabilité.</li>
                                <li>L'inconvénient de l'approche précédente est que maintenant le code gérant le stockage des données est en petite partie en Java et en grande partie en SQL. Le développeur doit avoir une bonne maîtrise technique des deux langages pour avoir une chance d'y résoudre un bug. Il lui faudra deux débuggeurs dans deux environnements de développement différents. Pire, le mécanisme des triggers s'exécute automatiquement et modifie des données "en cachette" du code que l'on pense en train de débugger. Il devient difficile de prédire le comportement de l'application. Il faut donc être excessivement attentif à d'abord trouver les triggers concernés et ensuite à bien voir quand et comment ils seront exécutés. Si par contre on se restreint au Java, on n'a plus qu'un seul environnement de développement et il n'y a plus de triggers mais bien des méthodes qui s'appellent entre elles. Il devient plus simple de comprendre le comportement de l'application et donc d'y résoudre les éventuels problèmes.</li>
                            </ul>
                            <p>Le choix d'une approche ou d'une autre dépend donc d'abord de la présence ou pas d'une politique d'entreprise à ce niveau. En son absence, il est souvent préférable de limiter autant que possible l'usage du SQL. Ainsi, on se garde la possibilité de migrer vers un autre système et on limite la connaissance technique nécessaire à la compréhension et maintenance de l'application. On diminue aussi le travail effectué par le serveur et on augmente donc ses performances. On perd évidemment l'avantage des services avancés que la base de données est capable de fournir.</p>
                            <p>Dans le cadre de ce cours, nous nous concentrons en priorité sur l'approche maximisant l'usage du SQL puisqu'après tout c'est le thème même de ce cours. Dans la suite, nous décriron une partie des bonnes pratiques de développement.</p>
                        </li>
                        <li>
                            <h4 id="bonne_pratique_jdbc_general">Bonne pratique JDBC en général :</h4>
                            <p>En gardant à l'esprit que le code SQL est dépendant de la base de données, on a un intérêt fort à isoler autant que possible toute la partie du code Java qui interagit avec JDBC. Ainsi, on aura un seul endroit à mettre à jour en cas de migration. Il y a des raisons supplémentaires (architecture, modularisation, pattern) pour vouloir isoler cette partie au sein de l'application, vous verrez cela dans d'autres cours. La bonne pratique consistera donc à :</p>
                            <ul>
                                <li>Créer un package qui contiendra toute la partie de l'application Java interagissant directement avec la base de données.</li>
                                <li>Au sein de ce package, créer une classe de gestion de la connexion JDBC. Au démarrage de l'application, cette classe sera instanciée et elle établira alors la connexion physique avec la basede données.</li>
                                <li>Au sein de ce package, créer des classes gérant un ensemble de requêtes. Sans vouloir aller trop loin sur la manière d'écrire ces classes, une première approche consiste à regrouper des requêtes logiquement proches ensembles. Ainsi, on regroupera au sein d'une classe toutes les requêtes concernant la gestion d'une authentification d'une personne par exemple. On peut évidemment utiliser des sous-packages pour continuer à organiser ces classes.</li>
                                <li>Lorsqu'une classe qui gère des requêtes est instanciée, elle crée autant de <span class="em">PreparedStatement</span> que nécessaire. Lorsque desméthodes sont appelées sur cette instance, ces méthodes n'utilisent que des <span class="em">PreparedStatement</span> pour communiquer avec la base de données.</li>
                                <li>Utiliser des <span class="em">try</span> avec ressource pour s'assurer que les <span class="em">ResultSet</span> sont bien fermés correctement.</li>
                                <li>Fermer la connexion lorsque l'application se termine.</li>
                            </ul>
                        </li>
                        <li>
                            <h4 id="bonne_pratique_jdbc_minimise_usage_sql">Bonne pratique JDBC lorsque l'on minimise l'usage du SQL :</h4>
                            <p>Dans cette approche, on essaie de dépendre du minimum possible de SQL. Comme la création de la base de données s'effectue une et une suele fois, on créera un script SQL (un simple fichier texte de commandes SQL) pour la création de la base de données. On se passera complètement des triggers et des procédures stockées : si ce mécanisme est nécessaire au fonctionnement de l'application, il faudra reproduire son équivalent en Java. On gardera par contre les index pour des raisons de performance. On évitera tout ce qui est spécifique à la base de données, comme les index auto-générés et les fonctionalités non standard. On pourra se contenter d'un seul rôle (public) sachant que c'est au niveau du code Java que la sécurité d'accès à la base de données sera implémentée.</p>
                            <ul>
                                <li>Au niveau du code Java, les requêtes seront des commandes <span class="em">SELECT</span>, <span class="em">UPDATE</span>, <span class="em">DELETE</span> explicites.</li>
                            </ul>
                        </li>
                        <li>
                            <h4 id="bone_pratique_jdbc_maximise_usage_sql">Bonne pratique JDBC lorsque l'on maximise l'usage du SQL :</h4>
                            <p>Dans cette approche, on va s'abstraire autant que possible au niveau du Java du SQL sous-jacent. Ceci permettra de faire évaluer la base de données en minimisant l'impact sur la partie Java :</p>
                            <ul>
                                <li>Éviter les requêtes portant directement sur des tables. À la place, écrire des procédures stockées au niveau du serveur et n'utiliser que cela au niveau du client.</li>
                                <li>Si le schéma de la base de données change, utiliser les vues pour garder constant les données retournées au client. Par exemple, si on ajoute une colonne à la table titles, créer une vue qui ignore cette colonne.</li>
                            </ul>
                            <p>De plus, on peut utiliser les fonctionnalités de la base de données pour amener plus de garanties de correction :</p>
                            <ul>
                                <li>Utiliser des séquences afin de générer automatiquement des identifiants unique pour les tuples (des clefs primaires). Comme c'est le serveur qui gère cela, on a la garantie qu'il n'y aura jamais de collision de clefs primaires (deux clients pourraient souhaiter s'approprier la même clef au même moment).</li>
                                <li>Créer des triggers pour gérer automatiquement la bonne cohérence des données.</li>
                                <li>Créer des utilisateurs dans la base de données correspondant au rôle logique dont a besoin l'application. Par exemple, une application de consultation uniquement se connectera au serveur en spécifiant un utilisateur possédant un utilisateur possédant uniquementle droit d'effectuer des <span class="em">SELECT</span>. Par contre, l'application d'administration se connectera avec un utilisateur administrateur de la base données.</li>
                            </ul>
                        </li>
                        <li>
                            <h4>Exemple :</h4>
<pre class="taille60"><code>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class ProgrammePrincipal {

    private String url = "jdbc:postgresql://postgres.ipl.be/pubs2" + "?user=public&password=public";
    private PreparedStatement listeAuteurs;
    private PreparedStatement listeAuteursAvecNom;
    private Connection conn = null;

    public ProgrammePrincipal() {
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            System.out.println("Driver PostgreSQL manquant !");
            System.exit(1);
        }
        try {
            conn = DriverManager.getConnection(url);
        } catch (SQLException e) {
            System.out.println("Impossible de joindre le serveur !");
            System.exit(1);
        }
        try {
            listeAuteurs = conn.prepareStatement("SELECT au_fname, au_lastname" + " FROM Authors;");
            listeAuteursAvecNom = conn.prepareStatement("SELECT au_lname" + " FROM Authors" + " WHERE au_fname LIKE ?;");
        } catch (SQLException e) {
            System.out.println("Erreur avec les requêtesSQL !");
            System.exit(1);
        }
    }

    private void listeAuteursAvecNom(String name) {
        try {
            listeAuteursAvecNom.setString(1, name);
            try (ResultSet rs = listeAuteursAvecNom.executeQuery()) {
                while (rs.next()) {
                    System.out.println("Prénom "+ rs.getString(1));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void listeAuteurs () {
        try {
            try (ResulSet rs = listeAuteurs.executeQuery()) {
                while (rs.next()) {
                    System.out.println("Nom " + rs.getString(1) + " Prénom " + rs.getString(2));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        ProgrammePrincipal pp = new ProgrammePrincipal();
        System.out.println("Liste des auteurs");
        pp.listeAuteurs();
        System.out.println("Liste des auteurs dont le nom est Sheryl");
        pp.listeAuteursAvecNom("Sheryl");
        pp.close();
    }

}</code></pre>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
    </body>
</html>