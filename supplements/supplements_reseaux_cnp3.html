<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>CNP3 - Réseaux - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements_reseaux.html">Retour au sommaire</a></li>
                        <li><a href="#preface">Préface</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Réseaux informatiques : principes, protocoles et pratiques version 0.25 :</h1>
                    <p>Ce texte est traduit du livre "Computer Networking : Principles, Protocols and Practice Release 0.25" et écrit par Olivier Bonaventure.</p>
                    <p><a href="../files/cnp3.pdf">Le texte original se trouve ici sous forme PDF et en anglais.</a></p>
                    <img src="../images/cnp3.jpg" alt="">
                </article>
                <article>
                    <h2 id="preface">Chapitre 1 : Préface :</h2>
                    <p>Ce manuel est né d'une frustration de son auteur principal. De nombreux auteurs ont choisi d'écrire un manuel parce qu'il n'y a pas de manuels dans leur domaine ou parce qu'ils ne sont pas satisfaits des manuels existants. Cette frustration a produit plusieurs excellents manuels dans la communauté des réseaux. À une époque où les manuels de réseaux étaient principalement théoriques, Douglas Corner a choisi d'écrire un manuel entièrement axé sur la suite de protocoles TCP/IP [Comer1988], un choix difficile à l'époque. Plus tard, il a étendu son manuel en décrivant une implémentation complète de TCP/IP, ajoutent des considérations pratiques aux descriptions théoriques de [Comer1988]. Richard Stevens a abordé Internet comme un explorateur et a expliqué le fonctionnement des protocoles en examinant tous les paquets échangés sur le fil [Stevens1994]. Jim Kurose et Keith Ross ont réinventé les manuels de réseaux en partant des applications utilisées par les étudiants et ont ensuite expliqué les protocoles Internet en supprimant une couche après l'autre [KuroseRoss09].</p>
                    <p>Les frustrations qui ont motivé ce livre sont différentes. Lorsque j'ai commencé à enseigner les réseaux à la fin des années 1990, les étudiants étaient déno des utilisateurs d'Internet, mais leur utilisation était limitée. Les étudiants utilisaient encore des manuels de référence et passaient du temps à la bibliothèques. Les étudiants d'aujourd'hui sont complètement différents. Ce sont des utilisateurs du web avides et expérimentés qui trouvent beaucoup d'informations sur le web. C'est une attitude positive car ils sont probablement plus curieux que leurs prédécesseurs. Grâce aux informations disponibles sur Internet, ils peuvent vérifier ou obtenir des informations supplémentaires sur les sujets expliqués par leurs professeurs. Cette abondance d'informations crée plusieurs défis pour un enseignant. Jusqu'à la fin du XIXe siècle, un enseignant par définition plus compétent que ses étudiants et il était très difficile pour les étudiants de vérifier les leçons données par leurs enseignants. Aujourd'hui, étant donné la quantité d'informations disponibles au bout des doigts de chaque étudiant via Internet, la vérification d'une leçon ou l'obtention de plus d'informations sur un sujet donné est parfois à quelques clics seulement. Des sites web tels que Wikipédia fournissent beaucoup d'informations sur divers sujets et les étudiants les consultent souvent. Malheureusement, l'organisation des informations sur ces sites web n'est pas adaptée pour permettre aux étudiants d'apprendre à partir d'eux. De plus, il existe de grandes différences dans la qualité et la profondeur des informations disponibles pour différents sujets.</p>
                    <p>La deuxième raison est que la communauté du réseau informatique est un participant fort dans le mouvement open-source. Aujourd'hui, il existe des implémentations open-source de haute qualité et largement utilisées pour la plupart des protocoles réseau. Cela inclut les implémentations TCP/IP qui font partie de Linux, FreeBSD ou la pile uIP fonctionnant sur des contrôleurs 8 bits, mais aussi des serveurs tels que Bind, Unbound, Apache ou Sendmail, ainsi que des implémentations de procoles de routage tels que XORP ou Quagga. De plus, les documents qui définissent presque tous les protocoles Internet ont été développés au sein de l'Internet Engineering Task Force (IETF) en utilisant un processus ouvert. L'IETF publie ses spécifications de protocole dans les RFC disponibles publiquement et les nouvelles propositions sont décrites dans les projets Internet.</p>
                    <p>Cet ouvrage pédagogique vise à combler le fossé entre les implémentations open source et les spécifications open source des réseaux en fournissant un description détaillée mais pédagogique des principes clés qui guident le fonctionnement d'Internet. Le livre est publié sous une licence Creative Commons. Cette licence open source est motivée par deux raisons. La première est que nous espérons que cela permettra à de nombreux étudiants d'utiliser le livre pour apprendre les réseaux informatiques. La seconde est que j'espère que d'autres enseignants le réutiliseront, l'adapteront et l'amélioreront. Le temps dira s'il est possible de construire une communauté de contributeurs pour améliorer et développer davantage le livre. En tant que point de départ, la première édition contient tout le matériel pour un semestre de premier cycle supérieur ou de cours de réseau des cycles supérieurs.</p>
                    <p>À l'heure actuelle où ces lignes sont écrites, la plupart du texte a été rédigé par Olivier Bonaventure. Laurent Vanbever, Virginie Van den Schriek, Damien Saucez et Mickael Hoerdt ont contribué aux exercices. Pierre Reinbold a conçu les icônes utilisées pour représenter les commutateurs et Nipaul Long a redessiné de nombreuses figures au format SVG. Stéphane Bortzmeyer a envoyé de nombreuses suggestions et corrections au texte. Des informations supplémentaires sur le manuel sont disponsibles sur le site <a href="http://inl.info.ucl.ac.be/CNP3" target="_blank">http://inl.info.ucl.ac.be/CNP3</a>.</p>
                    <h3>1.1. À propos de l'auteur :</h3>
                    <p>Olivier Bonaventure est actuellement professeur à l'Univesité Catholique de Louvain (Belgique) où il dirige le laboratoire IP Networking et est vice-président de l'ICTEAM Institute. Sa recherche est axée sur les protocoles Internet depuis plus de vingt ans. Avec ses doctorants, il a développé des techniques d'ingénierie de trafic, effectué divers types de mesures Internet, amélioré les performances des protocoles de routage tels que BGP est IS-IS et participé au développement de nouveaux protocoles Internet, notamment shim6, LISP et Multipath TCP. Il contribue fréquemment à la normalisation au sein de l'IETF. Il était membre du commité de rédaction de la revue IEEE/ACM Transactions on Networking et est directeur de ACM SIGCOMM.</p>
                </article>
                <article>
                    <h2 id="introduction">Chapitre 2 : Introduction :</h2>
                    <h3>2.1. Introduction :</h3>
                    <p>Lorsque les premiers ordinateurs ont été construits pendant la Seconde Guerre mondiale, ils étaient coûteux et isolés. Cependant, après environ 20 ans, à mesure que leurs prix diminuaient progressivement, les premières expériences ont commencé à connecter des ordinateurs entre eux. Au début des années 1960, des chercheurs tels que Paul Baran, Donald Davies ou Joseph Licklider ont publié indépendamment les premiers articles décrivant l'idée de construire des réseaux informatiques [Baran] [Licklider1963]. Étant donné le coût des ordinateurs, le partage sur une longue distance était une idée intéressante. Aux États-Unis, l'ARPANET a démarré en 1960 et s'est poursuivi jusqu'au milieu des années 1980 [LCCD09]. En France, Louis Pouzin a développé le réseau Cyclades [Pouzin1975]. De nombreux autres réseaux de recherche ont été construits au cours des années 1970 [Moore]. En même temps, l'industrie des télécommunications et des ordinateurs s'est intéressée aux réseaux informatiques. L'industrie des télécommunications a misé sur le X25. L'industrie informatique a adopté une approche complètement différente en concevant des réseaux locaux (LAN). De nombreuses technologies LAN telles qu'Ethernet ou Token Ring ont été conçues à cette époque. Au cours des années 1980, la nécessité d'interconnecter de plus en plus d'ordinateurs a conduit la plupart des vendeurs d'ordinateurs à développer leur propre suite de protocoles de réseau. Xerox a développé [XNS], DEC a choisi DECNet [Malamud1991], IBM a développé SNA [McFadyen1976], Microsoft a introduit NetBIOS [Winston2003], Apple a misé sur Appletalk [SAO1990]. Dans la communauté de recherche, l'ARPANET a été mise hors service et remplacée par TCP/IP [LCCD09] et l'implémentation de référence a été développée à l'intérieur de BSD Unix [McKusick1999]. Les universités qui utilisaient déjà Unix ont ainsi pu adopter facilement TCP/IP et les vendeurs de stations de travail Unix tels que Sun ou Silicon Graphics ont inclus TCP/IP dans leur variante d'Unix. En parallèle, l'ISO, avec le soutien des gouvernements, a travaillé sur le développement d'une suite ouverte de protocoles réseau ("Open" dans les termes de l'ISO était en contraste avec les suites de protocoles propriétaires dont les spécifications n'étaient pas toujours disponibles publiquement. Le gouvernement américain a même ordonnée l'utilisation des protocoles OSI (voir RFC 1169), mais cela n'a pas suffi à encourager tous les utilisateurs à passer à la suite de protocoles OSI qui était considérée par beaucoup comme trop complexe par rapport à d'autres suites de protocoles.). Au final, TCP/IP est devenu la norme de facto qui n'est pas seulement utilisée au sein de la communauté de recherche. Au cours des années 1990 et du début des années 2000, la croissance de l'utilisation TCP/IP a continué, et aujourd'hui, les protocoles propriétaires sont rarement utilisés. Comme le montre la figure ci-dessous, qui fournit une estimation du nombre d'hôtes connectés à Internet, Internet a connu une forte croissance au cours des 20 dernières années.</p>
                    <p>Les estimations récentes du nombre de machines connectées à Internet montrent une croissance continue depuis plus de 20 ans. Cependant, bien que le nombre de machines connectées à Internet soit élevé, il devrait être comparé au nombre de téléphones mobiles en utilisation aujourd'hui. De plus en plus de ces téléphones mobiles seront connectés à Internet. De plus, grâce à la disponibilité des implémentations de TCP/IP nécessitant des ressources limitées telles que uIP [Dunkels2003], nous pouvons nous attendre à voir une croissance des appareils intégrés compatibles avec TCP/IP.</p>
                    <p>Avant d'examiner les services fournis par les réseaux informatiques, il est utile de se mettre d'acoord sur certains termes largement utilisés dans la littérature sur les réseaux. Tout d'abord, les réseaux informatiques sont souvent classés en fonction de la zone géographique qu'ils couvrent :</p>
                    <ul>
                        <li>
                            <p><span class="html">LAN</span> (Local Area Network) : un réseau local interconnecte généralement des hôtes qui sont quelques kilomètres ou peut-être quelques dizaines de kilomètres de distance.</p>
                        </li>
                        <li>
                            <p><span class="html">MAN</span> (Metropolitan Area Network) : un réseau métropolitain interconnecte généralement des appareils qui sont jusqu'à quelques centaines de kilomètre de distance.</p>
                            <figure>
                                <img src="../images/estimation_nombre_hotes_sur_internet.png" alt="">
                                <figcaption>Figure 2.1 : Estimation du nombre d'hôtes sur Internet</figcaption>
                            </figure>
                            <figure>
                                <img src="../images/estimation_nombre_telephones_mobiles.png" alt="">
                                <figcaption>Figure 2.2 : Estimation du nombre de téléphones mobiles</figcaption>
                            </figure>
                        </li>
                        <li>
                            <p><span class="html">WAN</span> (Wide Area Network) : un réseau étendu interconnecte des hôtes qui peuvent être situés n'importe où sur Terre.</p>
                            <p>Dans ce livre, nous nous concentrons sur les réseaux utilisés sur Terre. Ces réseaux incluent parfois des liaisons satellites. En plus des technologies de réseau utilisées sur Terre, les chercheurs développent des techniques de mise en réseau qui pourraient être utilisées entre des noeuds situés sur des planètes différentes. Un tel Internet interplanétaire nécessite des techniques différentes de celles discutées dans ce livre. Pour plus d'informations sur ce techniques, consultez la RFC 4838 et les références qui y sont mentionnées.</p>
                        </li>
                    </ul>
                    <p>Une autre classification des réseaux informatiques est basée sur leur topologie physique. Dans les figures suivantes, les liens physiques sont représentés par des lignes tandis que les boîtes montrent des ordinateurs ou d'autres types d'équipements de réseau.</p>
                    <p>Les réseaux informatiques sont utilisés pour permettre à plusieurs hôtes d'échanger des informations entre eux. Pour permettre à n'importe quel hôte d'envoyer des messages à n'importe quel autre hôte du réseau, la solution la plus simple est de les organiser en maillage complet, avec un lien direct et dédié entre chaque paire d'hôtes. Cette topologie physique est parfois utilisée, en particulier lorsqu'une haute performance et une grande redondance sont requises pour un petit nombre d'hôtes. Cependant, elle présente deux inconvénients majeurs :</p>
                    <ul>
                        <li>
                            <p>pour un réseau contenant n hôtes, chaque hôte doit avoir n-1 interfaces physiques. En pratique, le nombre d'interfaces physiques sur un noeud limitera la taille d'un réseau en maillage complet qui peut être construit.</p>
                        </li>
                        <li>
                            <p>pour un réseau contenant n hôtes, (n<sup>2</sup>-n)/2 liens nécessaires. Ceci est possible lorsqu'il y a quelques noeuds dans la même pièce, mais rarement lorsqu'ils sont situés à plusieurs kilomètres de distance.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/reseau_en_maillage_complet.PNG" alt="">
                        <figcaption>Figure 2.3 : Un réseau en maillage complet</figcaption>
                    </figure>
                    <p>La deuxième organisation physique possible, qui est également utilisée à l'intérieur des ordinateurs pour connecter différentes cartes d'utilisation, est le bus. Dans un réseau de bus, tous les hôtes sont cconnectés à un support partagé, généralement un câble, via une seule interface. Lorsqu'un hôte envoie un signal électrique sur le bus, le signal est reçu par tous les hôtes connectés au bus. Un inconvénient des réseaux en bus est que si le bus est physiquement coupé, le réseau est divisé en deux réseaux isolés. Pour cette raison, les réseaux en bus sont parfois considérés comme difficiles à exploiter et à entretenir, surtout lorsque le câble est long et qu'il y a de nombreux endroits où il peut se rompre. Une telle topologie en bus a été utilisée dans les premiers réseaux Ethernet.</p>
                    <figure>
                        <img src="../images/reseau_en_bus.PNG" alt="">
                        <figcaption>Figure 2.4 : Un réseau organisé en bus</figcaption>
                    </figure>
                    <p>Une troisième organisation d'un réseau informatique est une topologie en étoile. Dans de telles topologies, les hôtes disposent d'une seule interface physique et il y a un lien physique entre chaque hôte et le centre de l'étoile. Le noeud au centre de l'étoile peut être soit un équipement qui amplifie un signal électrique, soit un appareil actif, tel qu'un équipement qui comprend le format des messages échangés à travers le réseau. Bien sûr, la défaillance du noeud central implique la défaillance du réseau. Cependant, si un lien physique échoue (par exemple, parce que le câble a été coupé), alors un seul noeud est déconnecté du réseau. En pratique, les réseaux en forme d'étoile sont plus faciles à exploiter et à entretenir que les réseaux en forme de bus. De nombreux administrateurs réseau apprécient également le fait qu'ils peuvent contrôler le réseau à partir d'un point central. Administré à partir d'une interface Web ou via une connexion de type console, le centre de l'étoile est un point de contrôle utile (activation ou désactivation d'appareils) et un excellent point d'observation (statiques d'utilisation).</p>
                    <figure>
                        <img src="../images/reseau_en_etoile.PNG" alt="">
                        <figcaption>Figure 2.5 : Un réseau organisé en étoile</figcaption>
                    </figure>
                    <p>Une quatrième organisation physique d'un réseau est la topologie en anneau. Comme pour l'organisation en bus, chaque hôte a une seule interface physique qui le relie à l'anneau. Tout signal envoyé par un hôte sur l'anneau sera reçu par tous les hôtes connectés à l'anneau. Du point de vue de la redondance, un seul anneau n'est pas la meilleure solution, car le signal ne se déplace que dans une seule direction sur l'anneau. Ainsi, si l'un des liens qui composent l'anneau est coupé, l'ensemble du réseau tombe en panne. En pratique, de tels anneaux ont été utilisés dans des réseaux locaux, mais sont maintenant souvent remplacés par des réseaux en étoile. Dans les réseaux métropolitains, les anneaux sont souvent utilisés pour interconnecter plusieurs sites. Dans ce cas, deux liens parallèles, composés de câbles différents, sont souvent utilisés par la redondance. Avec un tel anneau double, lorsque l'un des anneaux échoue, tout le trafic peut être rapidement basculé vers l'autre anneau.</p>
                    <figure>
                        <img src="../images/reseau_en_anneau.PNG" alt="">
                        <figcaption>Figure 2.6 : Un réseau organisé en anneau</figcaption>
                    </figure>
                    <p>Une cinquième organisation physique d'un réseau est l'arborescence. De tels réseaux sont généralement utilisés lorsqu'un grand nombre de clients doivent être connectés de manière très rentable. Les réseaux de télévision par câble sont souvent organisés en arborescence.</p>
                    <figure>
                        <img src="../images/reseau_en_arbre.PNG" alt="">
                        <figcaption>Figure 2.7 : Un réseau organisé en arbre</figcaption>
                    </figure>
                    <p>En pratique, la plupart des réseaux réels combinent une partie de ces topologies. Par exemple, un réseau de campus peut être organisé en anneau entre les bâtiments clés, tandis que les bâtiments plus petits sont rattachés en tant qu'arbre ou étoile aux bâtiments importants. Ou un réseau ISP peut avoir un maillage complet d'appareils dans le coeur de son réseau, et des arbres pour connecter les utilisateurs distants.</p>
                    <p>Tout au long de ce livre, notre objectif sera de comprendre les protocoles et les mécanismes nécessaires pour un réseau tel que celui-illustré ci-dessous.</p>
                    <figure>
                        <img src="../images/inter-reseau_simple.PNG" alt="">
                        <figcaption>Figure 2.8 : Un inter-réseau simple</figcaption>
                    </figure>
                    <p>La figure ci-dessus illustre un inter-réseau, c'est-à-dire un réseau interconnecte d'autres réseaux. Chaque réseau est représenté par une ellipse contenant quelques appareils. Nous expliquerons tout au long du livre les différents types d'appareils et leurs rôles respectifs permettant à tous les hôtes d'échanger des informations. En outre, nous discuterons de la manière dont les réseaux sont interconnectés et des règles qui régissent ces interconnexions. Nous analyserons également comment les topologies en bus, en anneau et en maillage sont utilisées pour construire des réseaux réels.</p>
                    <p>Le dernier point de terminolgie que nous devons aborder est les modes de transmission. Lorsque nous échangeons des informations à travers un réseau, nous distinguons trois modes de transmission. Dans la transmission TV et radio, la diffusion (<span class="html">broadcast</span>) est souvent utilisée pour indiquer une technologie qui envoie un signal vidéo ou radio à tous les récepteurs dans une zone géographique donnée. La diffusion est parfois utilisée dans les réseaux informatiques, mais uniquement dans les réseaux locaux où le nombre de destinataires est limité.</p>
                    <p>Le premier et le mode de transmission le plus répondu s'appelle <span class="html">unicast</span>. Dans le mode de transmission unicast, l'information est envoyée par un émetteur à un récepteur. La plupart des applications Internet d'aujourd'hui reposent sur le mode de transmission unicast. L'exemple ci-dessous montre un réseau avec deux types d'appareils : des hôtes (dessinés comme des ordinateurs) et des noeuds intermédiaires (dessinés comme des cubes). Les hôtes échangent des informations via les noeuds intermédiaires. Dans l'exemple ci-dessous, lorsque l'hôte S utilise unicast pour envoyer des informations, il les envoie via trois noeuds intermédiaires. Chacun de ces noeuds reçoit l'information de son noeud ou hôte en amont, la traite et la transmet à son noeud ou hôte en aval. Cela s'appelle <span class="em">store and forward</span> et nous verrons plus tard que ce concept est clé dans les réseaux informatiques.</p>
                    <figure>
                        <img src="../images/transmission_unicast.PNG" alt="">
                        <figcaption>Figure 2.9 : transmission unicast</figcaption>
                    </figure>
                    <p>Un deuxième mode de transmission est le mode de transmission <span class="html">multicast</span>. Ce mode est utilisé lorsque la même information doit être envoyée à un ensemble de destinataires. Il a d'abord été utilisé dans les réseaux locaux (LAN), mais est devenu plus tard pris en charge dans les réseaux étendus. Lorsqu'un expéditeur utilise le multicast pour envoyer des informations à N destinataires, l'expéditeur envoie une seule copie des informations et les noeuds du réseau dupliquent ces informations chaque fois que cela est nécessaire, de sorte qu'elles puissent atteindre tous les destinataires appartenant au groupe de destination.</p>
                    <p>Pour comprendre l'importance de la transmission en mode multicast, considérons la source S qui envoie les mêmes informations aux destinations A, C et E. Avec le mode unicast, les mêmes informations passent trois fois sur les noeuds intermédiaires 1 et 2 et deux fois sur le noeud 4. C'est une perte de ressources pour les noeuds intermédiaires et les liens entre eux. Avec la transmission en mode multicast, l'hôte S envoie les informations au noeud 1 qui le transmet en aval au noeud 2. Ce noeud crée une copie des informations reçues en envoie une copie directement à l'hôte E et l'autre en aval vers le noeud 4. À la reception des informations, le noeud 4 produit une copie et envoie une copie à la fois au noeud A et une autre au noeud C. Grâce à la transmission en mode multicast, les mêmes informations peuvent atteindre un grand nombre de destinataires tout en étant envoyées une seule fois sur chaque lien.</p>
                    <figure>
                        <img src="../images/transmission_multicast.PNG" alt="">
                        <figcaption>Figure 2.10 : transmission multicast</figcaption>
                    </figure>
                    <p>Le dernier mode de transmission est le mode de transmission <span class="html">anycast</span>. Il a été initialement défini dans le RFC 1542. Dans ce mode de transmission, un ensemble de récepteurs est identifié. Lorsqu'une source envoie des informations à cet ensemble de récepteurs, le réseau s'assyre que les informations sont délivrées à un récepteur qui appartient à cet ensemble. En général, le récepteur le plus proche de la source est celui qui reçoit les informations envoyées par cette source particulière. Le mode de transmission anycast est utile pour assurer la redondance, car lorsque l'un des récepteurs échoue, le réseau s'assure que les informations seront délivrées à un autre récepteur appartenant au même groupe. Cependant, en pratique, la prise en charge du mode de transmission anycast peut être difficile.</p>
                    <figure>
                        <img src="../images/transmission_anycast.PNG" alt="">
                        <figcaption>Figure 2.11 : transmission anycast</figcaption>
                    </figure>
                    <p>Dans l'exemple ci-dessus, les trois hôtes marqués d'un astérisque (*) font partie du même groupe anycast. Lorsque l'hôte S envoie des informations à ce groupe anycast, le réseau s'assure qu'elles parviendront à l'un des membres du groupe anycast. Les lignes en pointillés montrent une livraison possible via les noeuds 1, 2 et 4. Une transmission anycast ultérieure de l'hôte S vers le même groupe anycast pourrait atteindre l'hôte attaché au noeud intermédiaire 3, comme indiqué par la ligne pleine. Une transmission anycast atteint un membre du groupe anycast choisi par le réseau en fonction des conditions actuelles du réseau.</p>
                    <h3>2.2. Services et protocoles :</h3>
                    <p>Un aspect important à comprendre avant d'étudier les réseaux informatiques est la différence entre un service et un protocole.</p>
                    <p>Pour comprendre la différence entre les deux, il est utile de commencer par des exemples du monde réel. La Poste traditionnelle fournit un service dans lequel un facteur livre des lettres aux destinataires. La Poste définit précisément quels types de lettres (taille, poids, etc.) peuvent être livrés en utilisant le service du courrier standard. De plus, le format de l'enveloppe est spécifié (position des adresses de l'expéditeur et du destinataire, position du timbre). Qyelqu'un qui veut envoyer une lettre doit soit la déposer dans un bureau de poste ou dans l'une des boîtes aux lettres dédiées. La lettre sera ensuite collectée et livrée à son destinataire final. Notez que pour le service régulier, La Poste ne garantit généralement pas la livraison de chaque lettre particulière, certaines lettres peuvent être perdues et d'autres peuvent être livrées à la mauvaise boîte aux lettres. Si une lettre est importante, l'expéditeur peut utiliser le service recommandé pour s'assurer que la lettre sera livrée à son destinataire. Certains services de La Poste proposent également un service avec accusé de réception ou un service de courrier express qui est plus rapide que le service régulier.</p>
                    <p>Dans les réseaux informatiques, la notion de service est définie de manière plus formelle dans [X2000]. Elle peut être mieux comprise en considérant un réseau informatique, quelle que soit sa taille ou sa complexité, comme une boîte noire qui fournit un service aux utilisateurs, comme le montre la figure ci-dessous. Ces utilisateurs pourraient être des utilisateurs humains ou des processus s'exécutant sur un système informatique.</p>
                    <p>De nombreux utilisateurs peuvent être connectés au même fournisseur de services. Par l'intermédiaire de ce fournisseur, chaque utilisateur doit être en mesure d'échanger des messages avec n'importe quel autre utilisateur. Pour pouvoir livrer ces messages, le fournisseur de services doit être en mesure d'identifier de manière univoque chaque utilisateur. Dans les réseaux informatiques, chaque utilisateur est identifié par une adresse unique, nous discuterons plus tard de la façon dont ces adresses sont construites et utilisées. À ce stade, et lors de la considération de la transmission en unicast, la principale caractéristique de ces adresses est qu'elles sont uniques. Deux utilisateurs différents connectés au réseau ne peuvent pas utiliser la même adresse.</p>
                    <figure>
                        <img src="../images/utilisateurs_fournisseur_services.PNG" alt="">
                        <figcaption>Figure 2.12 : utilisateurs et fournisseur de services</figcaption>
                    </figure>
                    <p>Tout au long de ce livre, nous définirons un service comme un ensemble de capacités fournies par un système (et ses éléments sous-jacents) à son utilisateur. Un utilisateur interagit avec un service via un point d'accès au service. Notez que, comme indiqué dans la figure ci-dessus, les utilisateurs interagissent avec un seul fournisseur de services. En pratique, le fournisseur de services est réparti sur plusieurs hôtes, mais ce sont des détails d'implémentation qui ne sont pas importants à ce stade. Ces interactions entre un utilisateur et un fournisseur de services sont exprimées dans [X200] en utilisant des primitives, comme le montre la figure ci-dessous. Ces primitives sont une représentation abstraite des interactions entre un utilisateur et un fournisseur de services. En pratique, ces interactions pourraient être implémentées sous forme d'appels système, par exemple.</p>
                    <figure>
                        <img src="../images/quatre_types_primitives.PNG" alt="">
                        <figcaption>Figure 2.13 : les quatre types de primitives</figcaption>
                    </figure>
                    <p>Les quatres types de primitives sont définis :</p>
                    <ul>
                        <li>
                            <p><span class="html">X.request</span> : Ce type de primitive correspond à une demande émise par un utilisateur à un fournisseur de service.</p>
                        </li>
                        <li>
                            <p><span class="html">X.indication</span> : Ce type de primitive est généré par le fournisseur de réseau et livré à un utilisateur (souventt lié à une primitive <span class="em">X.request</span> antérieure et distante).</p>
                        </li>
                        <li>
                            <p><span class="html">X.response</span> : Ce type de primitive est généré par un utilisateur pour répondre à une primitive <span class="em">X.indication</span> antérieure.</p>
                        </li>
                        <li>
                            <p><span class="html">X.confirm</span> : Ce type de primitive est livré par le fournisseur de service pour confirmer à un utilisateur q'une primitive <span class="em">X.request</span> précédente a été traitée avec succès.</p>
                        </li>
                    </ul>
                    <p>Les primitives peuvent être combinées pour modéliser différents types de services. Le service le plus simple dans les réseaux informatiques est appelé <span class="html">le service sans connexion</span>. Ce service est appelé sans connexion car il n'est pas nécessaire de créer une connexion avant de transmettre des données contrairement au service orienté connexion. Ce service peut être modélisé en utilisant deux primitives :</p>
                    <ul>
                        <li>
                            <p><span class="html">Data.request(source, destination, SDU)</span> : Cette primitive est émise par un utilisateur qui spécifie, en tant que paramètres, son adresse source, l'adresse du destinataire du message et le message lui-même. Nous utiliserons <span class="html">l'unité de données de service (SDU ou Service Data Unit)</span> pour nommer le message échangé de manière transparente entre deux utilisateurs d'un service.</p>
                        </li>
                        <li>
                            <p><span class="html">Data.indication(source, destination, SDU)</span> : Cette primitive est délivrée par un fournisseur de service à un utilisateur. Elle contient comme paramètres une unité de données de service (SDU) ainsi que les adresses des utilisateurs émetteur et destinataire.</p>
                        </li>
                    </ul>
                    <p>Lorsqu'on discute du service fourni dans un réseau informatique, il est souvent utile de pouvoir décrire graphiquement les interactions entre les utilisateurs et le fournisseur. Une représentation fréquemment utilisée est le diagramme de séquence temporelle. Dans ce chapitre et tout au long du livre, nous utiliserons souvent des diagrammes tels que celui présenté ci-dessous. Un diagramme de séquence temporelle décrit les interactions entre deux utilisateurs et un fournisseur de services. Par convention, les utilisateurs sont représentés dans les parties gauche et droite du diagramme tandis que le fournisseur de services occupe le milieu du diagramme. Dans un tel diagramme de séquence temporelle, le temps d'écoule de haut en bas du diagramme. Chaque primitive est représentée par une flèche horizontale simple, à laquelle le nom de la primitive est attaché. Les lignes en pointillé sont utilisées pour représenter la relation possible entre deux (ou plusieurs) primitives. Un tel diagramme fournit des informations sur l'ordre des différentes primitives, mais la distance entre deux primitives ne représente pas une quantité de temps précise.</p>
                    <p>La figure ci-dessous fournit une représentation du service sans connexion sous forme de <span class="html">diagramme de séquence temporelle</span>. L'utilisateur à gauche, ayant l'adresse S, émet une primitive <span class="em">Data.request</span> contenant la SDU <span class="em">M</span> qui doit être livré par le fournisseur de services à la destination  <span class="em">D</span>. La ligne en pointillé entre les deux primitives indique que la primitive <span class="em">Data.indication</span> qui est délivrée à l'utilisateur de droite correspond à la primitive <span class="em">Data.request</span> envoyée par l'utilisateur de gauche.</p>
                    <figure>
                        <img src="../images/service_sans_connection_simple.PNG" alt="">
                        <figcaption>Figure 2.14 : Un service sans connexion simple</figcaption>
                    </figure>
                    <p>Il existe plusieurs implémentations possibles du service sans connexion, que nous étudierons plus tard dans ce livre. Avant d'examiner ces réalisations, il est utile de discuter des caractéristiques possibles du service sans connexion. Un <span class="html">service sans connection fiable</span> est un service dans lequel le fournisseur de service garantit que tous les SDU soumis dans les <span class="em">Data.requests</span> par un utilisateur seront finalement livrés à leur destination. Un tel service serait très utile pour les utilisateurs, mais garantir une livraison parfaite est difficile en pratique. Pour cette raison, les réseaux informatiques prennent généralement en charge un <span class="html">service sans connexion non fiable</span>.</p>
                    <p>Un <span class="em">service sans connexion peu fiable</span> peut présenter différents types de problèmes par rapport à un <span class="em">service sans connexion fiable</span>. Tout d'abord, un <span class="em">service sans connexion peu fiable</span> ne garantit pas la livraison de toutes les unités de donénes de service (SDU). Cela peut être exprimé graphiquement en utilisant le diagramme de séquence temporelle ci-dessous.</p>
                    <p>En pratique, un <span class="em">service sans connexion peu fiable</span> livrera généralement une partie des SDU. Cependant, comme la livraison des SDU n'est pas garantie, l'utilisateur doit être capable de la perte de tout SDU.</p>
                    <figure>
                        <img src="../images/service_sans_connection_peu_fiable_perdre_SDU.PNG" alt="">
                        <figcaption>Figure 2.15 : Un service sans connexion peut perdre des SDU</figcaption>
                    </figure>
                    <p>Une seconde imperfection qui peut affecter un service non fiable sans connexion est qu'il peut dupliquer des SDU. Certains founisseurs de services sans connexion peu fiables peuvent livrer une SDU envoyée par un utilisateur deux fois ou même plus. Cela est illustré par le diagramme de séquence temporelle ci-dessous.</p>
                    <figure>
                        <img src="../images/service_sans_connection_peu_fiable_dupliquer_SDU.PNG" alt="">
                        <figcaption>Figure 2.16 : Un service sans connection peu fiable peut dupliquer des SDU</figcaption>
                    </figure>
                    <p>Enfin, certains fournisseurs de services sans connexion peu fiables peuvent livrer à une destination un SDU différent de celui qui a été fourni dans le <span class="em">Data.request</span>. Cela est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/service_sans_connection_peu_fiable_livrer_SDU_erronees.PNG" alt="">
                        <figcaption>Figure 2.17 : Un service sans connection peu fiable peut livrer des SDU erronnées</figcaption>
                    </figure>
                    <p>Lorsqu'un utilisateur interagit avec un fournisseur de service, il doit connaître précisément les limitations du service sous-jacent afin de pouvoir surmonter tout problème qui pourrait survenir. Cela nécessite une définition précise des caractéristiques du service sous-jacent.</p>
                    <p>Une autre caractéristique importante du service sans connexion est de savoir s'il préserve l'ordre des SDU envoyés par un utilisateur. Du point de vue de l'utilisateur, c'est souvent une caractéristique souhaitable. Cela est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/service_sans_connection_preserve_ordre_SDU_envoyees.PNG" alt="">
                        <figcaption>Figure 2.18 : Un service sans connexion qui préserve l'ordre des SDU envoyées par un utilisateur donné</figcaption>
                    </figure>
                    <p>Cependant, de nombreux services sans connexion, en particulier les services non fiables, ne garantissent pas qu'ils préserveront toujours l'ordre des SDU envoyés par chaque utilisateur. Cela est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/service_sans_connection_preserve_pas_ordre_SDU_envoyees.PNG" alt="">
                        <figcaption>Figure 2.19 : Un service sans connexion qui ne préserve pas l'ordre des SDU envoyées par un utilisateur donné</figcaption>
                    </figure>
                    <p>Le service sans connexion est largement utilisé dans les réseaux informatiques, comme nous le verrons plus tard dans ce livre. Plusieurs variantes de ce service de base ont été proposées. L'une d'entre elles est le <span class="html">service sans connexion confirmé</span>. Ce service utilise une primitive <span class="em">Data.confirm</span> en plus des primitives <span class="em">Data.request</span> et <span class="em">Data.indication</span> classiques. Cette primitive est émise par le fournisseur de services pour confirmer à un utilisateur la livraison d'un SDU précédemment envoyé à son destinataire. Notez que, comme le service enregistré de la poste, <span class="em">Data.confirm</span> indique uniquement que le SDU a été livré à l'utilisateur de destination. La primitive <span class="em">Data.confirm</span> ne permet pas de savoir si le SDU a été traité par l'utilisateur de destination. Ce service sans connexion confirmé est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/service_sans_connection_confirme.PNG" alt="">
                        <figcaption>Figure 2.20 : Un service sans connexion confirmé</figcaption>
                    </figure>
                    <p>Une invocation du <span class="html">service orienté-connexion</span> est divisée en trois phases. La première phase est l'établissement d'une <span class="html">connexion</span>. Une <span class="em">connexion</span> est une association temporaire entre deux utilisateurs via un fournisseur de service. Plusieurs connexions peuvent exister en même temps entre une paire d'utilisateurs. Une fois établie, la connexion est utilisée pour transférer des SDU. Les connexions fournissent généralement un flux bidirectionnel permettant l'échange de SDU entre les deux utilisateurs associés par la connexion. Ce flux est utilisé pour transférer des données pendant la deuxième phase de la connexion appelée phase de <span class="html">transfert de données</span>. La troisième phase est la <span class="html">terminaison de la connexion</span>. Une fois que les utilisateurs ont fini d'échanger des SDU, ils demandent au fournisseur de service de terminer la connexion. Comme nous le veroons plus tard, il y a également des cas où le fournisseur de service peut avoir besoin de terminer une connexion lui-même.</p>
                    <p>La mise en place d'une connexion peut être modélisée en utilisant quatre primitives : <span class="em">Connect.request</span>, <span class="em">Connect.indication</span>, <span class="em">Connect.response</span> et <span class="em">Connect.confirm</span>. La primitive <span class="em">Connect.request</span> est utilisée pour demander l'établissement d'une connexion. Le paramètre principal de cette primitive est l'adresse de l'utilisateur de destination. Le fournisseur de service délivre une primitive <span class="em">Connect.indication</span> pour informer l'utilisateur de destination de la tentative de connexion. S'il accepte d'établir une connexion, il répond avec une primitive <span class="em">Connect.response</span>. À ce stade, la connexion est considérée comme ouverte et l'utilisateur de destination peut commencer à envoyer des SDU sur la connexion. Le fournisseur de service traite la <span class="em">Connect.response</span> et délivrera une primitive <span class="em">Connect.confirm</span> à l'utilisateur qui a initié la connexion. La livraison de cette primitive met fin à la phase d'établissement de la connexion. À ce stade, la connexion est considérée comme ouverte et les deux utilisateurs peuvent envoyer des SDU. L'établissement réussi d'une connexion est illustré ci-dessous.</p>
                    <figure>
                        <img src="../images/etablissement_connexion.PNG" alt="">
                        <figcaption>Figure 2.21 : L'établissement de la connexion</figcaption>
                    </figure>
                    <p>L'exemple ci-dessus montre l'établissement réussi d'une connexion. Cependant, en pratique, toutes les connexions ne sont pas établies avec succès. Une raison est que l'utilisateur de destination peut ne pas être d'accord, pour des raisons de politique ou de performance, pour établir une connexion avec l'utilisateur initiateur à ce moment. Dans ce cas, l'utilisateur de destination répond à la primitive <span class="em">Connect.indication</span> par une primitive <span class="html">Disconnect.request</span> qui contient un paramètre pour indiquer la raison pour laquelle la connexion a été refusée. Le fournisseur de service délivrera alors une primitive <span class="html">Disconnect.indication</span> pour informer l'utilisateur initiateur. Une deuxième raison est lorsque le fournisseur de service est incapable d'atteindre l'utilisateur de destination. Cela peut arriver parce que l'utilisateur de destination n'est pas actuellement connecté au réseau ou en raison de la congestion. Dans ces cas, le fournisseur de service répond à la primitive <span class="em">Connect.request</span> avec une primitive <span class="em">Disconnect.indication</span> dont le paramètre de raison contient des informations supplémentaires sur l'échec de la connexion.</p>
                    <figure>
                        <img src="../images/types_rejet_tentative_etablissement_connexion.PNG" alt="">
                        <figcaption>Figure 2.22 : Deux types de rejet pour une tentative d'établissement de connexion</figcaption>
                    </figure>
                    <p>Une fois que la connexion est établie, le fournisseur de services fournit deux flux de données aux utilisateurs communicants. Le premier flux de données peut être utilisé par l'utilisateur initiant pour envoyer des SDU. Le deuxième flux de donénes permet à l'utilisateur répondant d'envoyer des SDU à l'utilisateur initiant. Les flux de données peuvent être organisés de différentes manières. Une première organisation est le transfert en mode message. Avec le transfert en mode message, le fournisseur de services garantit qu'un seul et unique <span class="em">Data.indication</span> sera livré au point final du flux de données pour chaque primitive <span class="em">Data.request</span> émise par l'autre point final. Le transfert en mode message est illustré dans la figure ci-dessous. Le principal avantage du mode de transfert de message est que le destinataire reçoit exactement les SDU qui ont été envoyés par l'autre utilisateur. Si chaque SDU contient une commande, l'utilisateur qui reçoit peut traiter chaque commande dès qu'il reçoit un SDU.</p>
                    <figure>
                        <img src="../images/transfert_mode_message_service_oriente_connexion.PNG" alt="">
                        <figcaption>Figure 2.23 : Transfert en mode message dans un service orienté connexion</figcaption>
                    </figure>
                    <p>Malheureusement, le transfert en mode message n'est pas largement utilisé sur Internet. Sur Internet, le service orienté connexion le plus populaire transfère des SDU en mode flux. Avec le mode flux, le fournisseur de services fournit un flux de bytes qui relie les deux utilisateurs en communication. L'utilisateur émetteur envoie des bytes en utilisant des primitives de requête de données (<span class="em">Data.request</span>) qui contiennent des séquences de bytes en tant que SDU. Le fournissur de sercices délivre des SDU contenant des bytes consécutifs à l'utilisateur récepteur en utilisant des primitives d'indication de données (<span class="em">Data.indication</span>). Le fournisseur de services garantit que tous les bytes envoyés à une extrémité du flux sont livrés correctement dans le même ordre à l'autre extrémité. Cependant, le fournisseur de services n'essaie pas de préserver les limites des SDU. Il n'y a aucune relation imposée par le fournisseur de services entre le nombre de primitives <span class="em">Data.request</span> et le nombre de primitives <span class="em">Data.indication</span>. Le mode flux est illustré dans la figure ci-dessous. En pratique, une conséquence de l'utilisation du mode flux est que si les utilisateurs veulent échanger des SDU structurés, ils devront fournir les mécanismes qui permettent à l'utilisateur récepteur de séparer les SDU successifs dans le flux de bytes qu'il reçoit. Comme nous le verrons dans le prochain chapitre, les protocoles de la couche d'application utilisent souvent des délimiteurs spécifiques tels que le caractère de fin de ligne pour délimiter des SDU dans un flux de bytes.</p>
                    <figure>
                        <img src="../images/transfert_mode_flux_service_oriente_connexion.PNG" alt="">
                        <figcaption>Figure 2.24 : Transfert en mode flux dans un service orienté connexion</figcaption>
                    </figure>
                    <p>La troisième phase d'une connexion est lorsqu'elle doit être libérée. Comme une connxion implique trois parties (deux utilisateurs et un fournisseur de service), l'une d'entre elles peut demander la résiliation de la connexion. Habituellement, les connexions sont terminées à la demande d'un utilisateur une fois le transfert de données terminé. Cependant, parfois le fournisseur de service peut être obligé de mettre fin à une connexion. Cela peut être dû à un manque de ressources à l'intérieur du fournisseur de service ou parce que l'un des utilisateurs n'est plus accessible via le réseau. Dans ce cas, le fournisseur de service émettra des primitives <span class="em">Disconnect.indication</span> à tous les deux utilisateurs. Ces primitives contiendront, en paramètre, des informations sur la raison de la résiliation de la connexion. Malheureusement, comme illustré dans la figure ci-dessous, lorsqu'un fournisseur de service est contraint de mettre fin à une connexion, il ne peut garantir que toutes les SDU envoyées par chaque utilisateur ont été livrées à l'autre utilisateur. Cette libération de connexion est dite abrupte car elle peut causer des pertes de données.</p>
                    <figure>
                        <img src="../images/liberation_abrupte_connexion_initiee_fournisseur_service.PNG" alt="">
                        <figcaption>Figure 2.25 : Libération abrupte de connexion initiée par le fournisseur de service</figcaption>
                    </figure>
                    <p>Une libération de connexion abrupte peut également être déclenchée par l'un des utilisateurs. Si un utilisateur a besoin, pour une raison quelconque, de mettre fin rapidement à une connexion, il peut émettre une primitive <span class="em">Disconnect.request</span> et demander une libération abrupte. Le fournisseur de service traitera la demande, arrêtera les deux flux de données et livrera la primitive <span class="em">Disconnect.indication</span> à l'utilisateur distant dès que possible. Comme illustré dans la figure ci-dessous, cette libération de connexion abrupte peut entraîner des pertes de SDU.</p>
                    <figure>
                        <img src="../images/liberation_abrupte_connexion_initiee_utilisateur.PNG" alt="">
                        <figcaption>Figure 2.26 : Libération abrupte de connexion initiée par un utilisateur</figcaption>
                    </figure>
                    <p>Pour assurer une livraison fiable des SDU envoyés par chaque utilisateur sur une connexion, nous devons considérer les deux flux qui composent une connexion comme indépendants. Un utilisateur devrait être en mesure de libérer le flux qu'il utilise pour envoyer des SDU une fois qu'il a envoyé tous les SDU qu'il avait prévu d'envoyer sur cette connexion, mais continuer à recevoir des SDU sur le flux opposé. Cette libération de connexion gracieuse est généralement effectuée comme indiqué dans la figure ci-dessous. Un utilisateur émet une primitive <span class="em">Disconnect.request</span> à son fournisseur une fois qu'il a émis toutes ses primitives <span class="em">Data.request</span>. Le fournisseur de service attendra que toutes les primitives <Span class="em">Data.indication</Span> aient été livrées à l'utilisateur destinataire avant d'émettre la primitive <span class="em">Disconnect.indication</span>. Cette primitive informe l'utilisateur destinataire qu'il ne recevra plus de SDU sur cette connexion, mais il peut toujours émettre des primitives <span class="em">Data.request</span> sur le flux dans la direction opposée. Une fois que l'utilisateur a émis toutes ses primitives <span class="em">Data.request</span>, il émet une primitive <span class="em">Disconnect.request</span> pour demander la terminaison du flux restant. Le fournisseur de service traitera la demande et livrera la <span class="em">Disconnect.indication</span> correspondante à l'autre utilisateur une fois qu'il aura livré toutes les primitives <span class="em">Data.indication</span> en attente. À ce stade, toutes les données ont été libérés avec succès et la connexion est complètement fermée.</p>
                    <figure>
                        <img src="../images/liberation_gracieuse_connexion.PNG" alt="">
                        <figcaption>Figure 2.27 : Libération gracieuse de connexion</figcaption>
                    </figure>
                    <hr>
                    <p>Note : Fiabilité du service orienté connexion :</p>
                    <p>Un point important à noter concernant le service orienté connexion est sa fiabilité. Un service orienté connexion ne peut garantir la bonne livraison de toutes les unités de données de service (SDU) que si la connexion est relâchée de manière contrôlée. Cela implique que tant que la connexion est active, il n'y aucune garantie de la livraison effective des SDU échangées car la connexion peut être libérée de manière abrupte à tout moment.</p>
                    <hr>
                    <h3>2.3 Les modèles de référence :</h3>
                    <p>Face à la complexité croissante des réseaux informatiques, au cours des années 1970, les chercheurs en réseau ont proposé différents modèles de référence pour faciliter la description des protocoles et des services de réseau. Parmi ceux-ci, le modèle de référence de l'Interconnexion de Systèmes Ouverts (ISO) [Zimmermann80] a été probablement le plus influent. Il a servi de base aux travaux de normalisation effectués au sein de l'ISO pour développer des normes mondiales de réseau informatique. Le modèle de référence que nous utilisons dans ce livre peut être considéré comme une version simplifiée du modèle de référence OSI. Une discussion historique intéressante sur le débat OSI-TCP/IP peut être trouvée dans [Russel06].</p>
                    <h4>2.3.1 Les cinq couches du modèle de référence :</h4>
                    <p>Notre modèle de référence est divisé en cinq couches, comme le montre la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/cinq_couches_modele_reference.PNG" alt="">
                        <figcaption>Figure 2.28 : Les cinq couches du modèle de référence</figcaption>
                    </figure>
                    <p>En commençant par la base, la première couche est <span class="html">la couche physique</span>. Deux appareils communicants sont reliés par un support physique. Ce support physique est utilisé pour transférer un signal électrique ou optique entre deux appareils directement connectés. Plusieurs types de supports physiques sont utilisés en pratique :</p>
                    <ul>
                        <li>
                            <p><span class="html">câble électrique</span> : Les informations peuvent être transmises sur différents types de câbles électriques. Les plus courants sont les paires torsadées utilisées dans le réseau téléphonique, mais également dans les réseaux de télévision par câble, mais ne sont plus utilisés dans les réseaux d'entreprise. Certaines technologies de réseau fonctionnent sur le câble électrique classique.</p>
                        </li>
                        <li>
                            <p><span class="html">fibre optique</span> : Les fibres optiques sont fréquemment utilisées dans les réseaux publics et d'entreprise lorsque la distance entre les appareils de communication est supérieure à un kilomètre. Il existe deux principaux types de fibres optiques : <span class="html">multimode</span> et <span class="html">monomode</span>. Le multimode est beaucoup moins cher que la fibre monomode car une LED peut être utilisée pour envoyer un signal sur une fibre multimode tandis qu'une fibre monomode doit être pilotée par un laser. En raison des différents modes de propagation de la lumière, les fibres monomodes sont limitées à des distances de quelques kilomètres tandis que les fibres multimodes peuvent être utilisées sur des distances supérieures à plusieurs dizaines de kilomètres. Dans les deux cas, des répéteurs peuvent être utilisées pour régénérer le signal optique à une extrémité d'une fibre pour l'envoyer sur une autre fibre.</p>
                        </li>
                        <li>
                            <p><span class="html">sans fil</span> : Dans ce cas, un signal radio est utilisé pour coder les informations échangées entre les appareils de communication. De nombreuses techniques de modulation sont utilisées pour envoyer des informations sur un canal sans fil et il y a beaucoup d'innovation dans ce domaine avec de nouvelles techniques apparaissant chaque année. Bien que la plupart des réseaux sans fil reposent sur des signaux radio, certains utilisent un laser qui envoie des impulsions lumineuses à un détecteur distant. Ces techniques optiques permettent de créer des liaisons point à point tandis que les techniques basées sur la radio, en fonction de la directionnalité des antennes, peuvent être utilisées pour construire des réseaux contenant des appareils répartis sur une petite zone géographique.</p>
                        </li>
                    </ul>
                    <p>Un point important à noter à propos de la couche physique est le service qu'elle fournit. Ce service est généralement un service orienté connexion peu fiable qui permet aux utilisateurs de la couche physique d'échanger des bits. L'unité de transfert d'information dans la couche physique est le bit. Le service de la couche physique est peu fiable parce que :</p>
                    <ul>
                        <li>
                            <p>la couche physique peut changer, par exemple en raison d'interférences électromagnétiques, la valeur d'un bit en cours de transmission</p>
                        </li>
                        <li>
                            <p>la couche physique peut livrer plus de bits au récepteur que les bits envoyés par l'émetteur</p>
                        </li>
                        <li>
                            <p>la couche physique peut livrer moins de bits au récepteur que les bits envoyés par l'émetteur</p>
                        </li>
                    </ul>
                    <p>Les deux derniers points peuvent sembler étranges à première vue. Lorsque deux périphériques sont connectés via un câble, comment est-il possible que des bits soient créés ou perdus sur ce câble ?</p>
                    <p>Cela est principalement dû au fait que les appareils communicants utilisent leur propre horloge pour transmettre des bits à une vitesse de transmission donnée. Considérons un émetteur ayant une horloge qui bat un million de fois par seconde et envoie un bit à chaque battement. Chaque microseconde, l'émetteur envoie un signal électrique ou optique qui code un bit. Le débit binaire de l'émetteur est donc de 1 Mbps. Si l'horloge du récepteur bat exactement 5 fois chaque microseconde, il délivrera également 1 Mbps à son utilisateur. Cependant, si l'horloge du récepteur est légèrement plus rapide (ou plus lente), il délivrera légèrement plus (ou moins) d'un million de bits chaque seconde. Cela explique pourquoi la couche physique peut perdre ou créer des bits. Il est très difficile en pratique d'avoir des horloges parfaitement synchronisées fonctionnant à haute fréquence. Cependant, certaines couches physiques introduisent une boucle de rétroaction qui permet à l'horloge du récepteur de se synchroniser automatiquement à l'horloge de l'émetteur. Cependant, toutes les couches physiques n'incluent pas ce type de synchronisation.</p>
                    <hr>
                    <p>Note : Débit binaire :</p>
                    <p>Dans les réseaux informatiques, le débit binaire de la couche physique est toujours exprimé en bits par seconde. Un Mbps est évalement à un million de bits par seconde et un Gbps est équivalent à un milliard de bits par seconde. Cela contraste avec les spécifications de mémoire qui sont habituellement exprimées en octets (8 bits), Kilo-octets (1024 octets) ou Méga-octets (1048576 octets). Ainsi, transférer un MByte à travers une liaison de 1 mbps prend 8,39 secondes.</p>
                    <table role="presentation">
                        <thead>
                            <tr>
                                <th>Débit binaire</th>
                                <th>Bits par seconde</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1 Kbps</td>
                                <td>10<sup>3</sup></td>
                            </tr>
                            <tr>
                                <td>1 Mbps</td>
                                <td>10<sup>6</sup></td>
                            </tr>
                            <tr>
                                <td>1 Gbps</td>
                                <td>10<sup>9</sup></td>
                            </tr>
                            <tr>
                                <td>1 Tbps</td>
                                <td>10<sup>12</sup></td>
                            </tr>
                        </tbody>
                    </table>
                    <hr>
                    <figure>
                        <img src="../images/couche_physique.PNG" alt="">
                        <figcaption>Figure 2.29 : La couche physique</figcaption>
                    </figure>
                    <p>La couche physique permet ainsi à deux ou plusieurs entités directement connectées au même support de transmission d'échanger des bits. Pouvoir échanger des bits est important car pratiquement toutes les informations peuvent être encodées sous forme de séquences de bits. Les ingénieurs électriciens ont l'habitude de traiter des flux de bits, mais les informaticiens préfèrent généralement traiter des concepts de plus haut niveau. Un problème similaire se pose avec le stockage de fichiers. Les dispositifs de stockage tels que les disques durs stockent également des flux de bits. Il existe des dispositifs matériels qui traitent le flux de bits produit par un disque dur, mais les informaticiens ont conçu des systèmes de fichiers pour permettre aux applications d'accéder facilement à ces dispositifs de stockage. Ces syst!mes de fichiers sont généralement également divisés en plusieurs couches. Les disques durs stockent des secteurs de 512 octets ou plus. Les systèmes de ficheirs Unix regroupent des secteurs en blocs plus larges qui peuvent contenir des données ou des inodes représentant la structure du système de fichiers. Enfin, les applications manipulent des fichiers et des répertoires qui sont traduits en blocs, en secteurs et finalement en bits par le système d'exploitation.</p>
                    <p>Les réseaux informatiques utilisent une approche similaire. Chaque couche fournit un service qui est construit au-dessus de la couche sous-jacente et est plus proche des besoins des applications.</p>
                    <p><span class="html">La couche liaison de données</span> repose sur le service fourni par la couche physique sous-jacente. La couche liaison de donénes permet à deux hôtes directement connectés par la couche physique d'échanger des informations. L'unité d'information échangée entre deux entités dans la couche liaison de données est une trame. Une trame est une séquence finie de bits. Certaines couches liaison de données fournissent un service orienté connexion tandis que d'autres fournissent un service sans connexion. Certaines couches liaison de données garantissent la livraison fiable des informations tandis que d'autres ne garantissent pas la livraison correcte de l'information.</p>
                    <p>Un point important à noter à propos de la couche liaison de données est que bien que la figure ci-dessous indique que deux entités de la couche liaison de données échangent directement des trames, en réalité c'est légèrement différent. Lorsque l'entité de la couche liaison de données à gauche doit transmettre une trame, elle émet autant de primitives <span class="em">Data.request</span> à la couche physique sous-jacente qu'il y a de bits dans la trame. La couche physique convertira alors la séquence de bits en un signal électromagnétique ou optique qui sera envoyé sur le support physique. La couche physique du côté droit de la figure décodera le signal reçu, récupérera les bits et émettra les primitives <span class="em">Data.indication</span> correspondantes à son entité de la couche liaison de données. S'il n'y a pas d'erreurs de transmission, cette entité recevra la trame envoyée précédemment.</p>
                    <figure>
                        <img src="../images/couche_liaison_donnees.PNG" alt="">
                        <figcaption>Figure 2.30 : La couche liaison de données</figcaption>
                    </figure>
                    <p>La couche liaison de données permet à des hôtes directement connectés d'échanger de l'information, mais il est souvent nécessaire d'échanger de l'information entre des hôtes qui ne sont pas connectés au même support physique. C'est la tâche de la <span class="html">couche réseau</span>. La couche réseau est construire au-dessus de la couche liaison de données. Les entités de la couche réseau échangent des <span class="html">paquets</span>. Un paquet est une séquence finie d'octets transportée par la couche liaison de données à l'intérieur d'une ou plusieurs trames. Un paquet contient généralement des informations sur son origine et sa destination, et passe habituellement par plusieurs appareils intermédiaires appelés routeurs en chemin de son origine à sa destination.</p>
                    <figure>
                        <img src="../images/couche_reseau.PNG" alt="">
                        <figcaption>Figure 2.31 : La couche réseau</figcaption>
                    </figure>
                    <p>La plupart des implémentations de la couche réseau, y compris Internet, ne fournissent pas de service fiable. Cependant, de nombreuses applications ont besoin d'échanger des informations de manière fiable, et l'utilisation directe du service de la couche réseau serait très difficile pour elles. Assurer la livraison fiable des données produites par les applications est la tâhce de la <span class="html">couche transport</span>. Les entités de la couche transport échangent des <span class="html">segments</span>. Un segment est une séquence finie d'octets qui sont transportés à l'intérieur d'un ou plusieurs paquets. Une entité de la couche transport émet des segments (ou parfois une partie de segments) en tant que demande de données (<span class="em">Data.request</span>) à l'entité de la couche réseau sous-jacente.</p>
                    <figure>
                        <img src="../images/couche_transport.PNG" alt="">
                        <figcaption>Figure 2.32 : le réseau transport</figcaption>
                    </figure>
                    <p>Il existe différents types de couches transport. Les couches transport les plus couramment utilisées sur Internet sont <span class="html">TCP</span>, qui fournit un service de transport orienté connexion fiable pour un flux de données en octetsn, et <span class="html">UDP</span>, qui founit un service de transprot non fiable sans connexion.</p>
                    <p>La couche supérieure de notre architecture est la <span class="html">couche application</span>. Cette couche comprend tous les mécanismes et structures de données nécessaires pour les applications. Nous utiliserons <span class="html">l'unité de données de l'application (UDA ou ADU pour "Application Data Unit")</span> pour indiquer les données échangées entre deux entités de la couche application.</p>
                    <figure>
                        <img src="../images/couche_application.PNG" alt="">
                        <figcaption>Figure 2.33 : La couche application</figcaption>
                    </figure>
                    <h4>2.3.2 Le modèle de référence TCP/IP :</h4>
                    <p>En contraste avec OSI, la communauté TCP/IP n'a pas fait beaucoup d'efforts pour définir un modèle de référence détaillé; en fait, les objectifs de l'architecture Internet ont été documentés après que TCP/IP ait été déployé [Clark88]. RFC 1122, qui définit les exigences pour les hôtes Internet, mentionne quatre couches différentes. En commençant par le haut, ce sont :</p>
                    <ul>
                        <li>
                            <p>une couche Application</p>
                        </li>
                        <li>
                            <p>une couche Transport</p>
                        </li>
                        <li>
                            <p>une couche Internet qui est équivalente à la couche réseau de notre modèle de référence</p>
                        </li>
                        <li>
                            <p>une couche Liaison qui combine les fonctionnalités des courches physique et de liaison de données de notre modèle de référence à cinq couches.</p>
                        </li>
                    </ul>
                    <p>Outre cette différence dans les couches inférieures, le modèle de référence TCP/IP est très proche des cinq couches que nous utilons tout au long de ce document.</p>
                    <h4>2.3.3 Le modèle de référence OSI :</h4>
                    <p>En comparaison avec le modèle de référence à cinq couches expliqué ci-dessus, le modèle de référence OSI défini dans [X200] est divisé en sept couches. Les quatre couches inférieures sont similaires aux quatre couches inférieures décrites ci-dessus. Le modèle de référence OSI a affiné la couche application en la divisant en trois couches :</p>
                    <ul>
                        <li>
                            <p><span class="html">La couche Session</span> contient les protocoles et mécanismes nécessaires pour organiser et synchroniser le dialogue et gérer l'échange de données entre les entités de la couche Présentation. Alors que l'une des fonctions principales de la couche transport est de faire face à l'instabilité de la couche réseau, l'objectif de la couche session est de masquer les éventuelles défaillances des connexions de niveau transport vers la couche supérieure. Pour cela, la couche session fournit des services permettant d'établir une connexion de session, de soutenir un échange de données ordonné (y compris des mécanismes permettant de récupérer d'une libération abrupte d'une connexion de transport sous-jacente) et de libérer la connexion de manière ordonnée.</p>
                        </li>
                        <li>
                            <p><span class="html">La couche Présentation</span> a été conçue pour faire face aux différentes façons de représenter l'information sur les ordinateurs. Il existe de nombreuses différences dans la façon dont les ordinateurs stockent l'information. Certains ordinateurs stockent les entiers sous forme de champs de 32 bits, d'autres utilisent des champs de 64 bits et le même problème se pose avec les nombres à virgule flottante. Pour les informations textuelles, cela est encore plus complexe avec les nombreux codes de caractères différents qui ont été utilisés. La situation est encore plus complexe lorsqu'on considère l'échange d'informations structurées telles que les enregistrements de base de données. Pour résoudre ce problème, la couche présentation prévoit une représentation commune des données transférées. La notation <span class="em">ASN.1</span> a été conçue pour la couche présentation et est encore utilisée aujourd'hui par certains protocoles.</p>
                        </li>
                        <li>
                            <p><span class="html">La couche Application</span> qui contient les mécanismes qui ne rentrent ni dans la couche présentation, ni dans la couche session. La couche application OSI était elle-même subdivisée en plusieurs éléments de service génériques.</p>
                        </li>
                    </ul>
                    <hr>
                    <p>Note : Où sont les couches manquantes dans le modèle de référence TCP/IP ?</p>
                    <p>Le modèle de référence TCP/IP place les couches présentation et session implicitement dans la couche application. Les principales motivations pour simplifier les couches supérieures das le modèle de référence TCP/IP étaient pragmatiques. La plupart des applications Internet ont commencé comme des prototypes qui ont évolué et ont ensuite été standardisés. Beaucoup de ces applications ont supposé qu'elles seraient utilisées pour échanger des informations écrites en anglais américain et pour lesquelles le code de caractères US-ASCII sur 7 bits était suffisant. C'était le cas pour le courrier électronique, mais comme nous le verrons dans le prochain chapitre, le courrier électronique a pu évoluer pour prendre en charge différentes codifications de caractères. Certaines applications considéraient explicitement les différentes représentations de données. Par exemple, <span class="em">ftp</span> contenait des mécanismes pour convertir un fichier d'un format à un autre et le langage HTML a été défini pour représenter des pages Web. D'autre part, de nombreuses spécifications ISO ont été développées par des comités composés de personnes qui n'ont pas toutes participé à des implémentations réelles. ISO a consacré beaucoup d'efforts à l'analyse des exigebces et à la définition d'une solution qui répond à toutes ces exigences. Malheureusement, certaines des spécifications étaient si complexes qu'il était difficile de les implémenter complètement et les organismes de normalisation ont défini des profils recommandés qui contenanient les ensembles d'options implémentés...</p>
                    <hr>
                    <figure>
                        <img src="../images/sept_couches_modele_reference_OSI.PNG" alt="">
                        <figcaption>Figure 2.34 : Les sept couches du modèle de référence OSI</figcaption>
                    </figure>
                    <h3>2.4 Organisation du livre :</h3>
                    <p>Ce document est organisé selon le modèle de référence TCP/IP et suit une approche descendante (top-down). La plupart des manuels classiques de réseau choisissent une approche ascendante (bottom-up), c'est-à-dire qu'ils expliquent d'abord tous les détails électriques et optiques de la couche physique avant de passer à la couche liaison de données. Cette approche a bien fonctionné pendant la première période de l'informatique en réseau et jusqu'à la fin des années 1990. À cette époque, la plupart des étudiants n'étaient pas utilisateurs de réseaux informatiques et il était utile d'expliquer les réseaux informatiques en construisant les protocoles correpondants à partir des plus simples, dans la couche physique, jusqu'à la couche application. Aujourd'hui, tous les étudiants sont des utilisateurs actifs d'application. Aujourd'hui, tous les étudiants sont des utilisateurs actifs d'applicatiion Internet et commencer à apprendre la réseautique en examinant des bits n'est pas très motivant. À partir de [KuroseRoss09], de nombreux manuels et enseignants ont choisi une approche descendante. Cette approche commence par des applications telles que le courrier électronique et le Web que les étudiants connaissent déjà et explore les différentes couches, en commençant par la couche application. Cette approche fonctionne assez bien avec les étudiants d'aujourd'hui. L'approche traditionnelle ascendante pourrait en fait être considérée comme une approche d'ingénierie car elle part du réseau le plus simple qui permet l'échange de bits et explique comment combiner différents protocoles et mécanismes pour construire les applications les plus complexes. L'approche descendante, en revanche, pourrait être considérée comme une approche scientifique. Comme les biologistes, elle part d'un système existant (construit par l'homme) et l'explore couche par couche.</p>
                    <p>En plus de l'organisation top-down versus bottom-up, les livres sur les réseaux informatiques peuvent soit viser à couvrir en profondeur un petit nombre de sujets, soit à avoir une couverture limitée d'un large éventail de sujets. Couvrir un large éventail de sujets est intéressant pour les cours d'introduction ou pour les étudiants qui n'ont pas besoin d'une connaissance détaillée des réseaux informatiques. Cela permet aux étudiants d'apprendre un peu de tout, puis de partir de cette connaissance de base plus tard s'ils ont besoin de comprendre les réseaux informatiques plus en détail. Ce livre a choisi de couvrir en détail un plus petit nombre de jets que d'autres manuels. Cela est motivé par le fait que les réseaux informatiques doivent souvent être poussés à leurs limites. Comprendre les détails des principaux protocoles de mise en réseau est important pour pouvoir comprendre pleinement le comportement d'un réseau ou l'étendre pour fournir des services innovants. Une citation populaire dit que le diable se cache dans les détails. Cette situation reflète très bien le fonctionnement de nombreux protocoles de réseau, où le changement d'un seul bit peut avoir des conséquences énormes. Dans les réseaux informatiques, comprendre tous les détails est parfois nécessaire.</p>
                    <p>Le livre est organisé comme suit : nous décrivons d'abord la couche application dans le chapitre "La couche application". Étant donné le grand nombre d'applications basées sur Internet, il est bien sûr impossible de les couvrir toutes en détail. Nous nous concentrons plutôt sur trois types d'applications basées sur Internet. Nous étudions d'abord le système de noms de domaine (DNS) puis expliquons certains des protocoles impliqués dans l'échange de courrier électronique. La discussion de la couche application se termine par une description des protocoles clés du World Wide Web.</p>
                    <p>Toutes ces applications reposent sur la couche transport qui est expliquée dans le chapitre "chapter-transport". Il s'agit d'une couche clé dans les réseaux d'aujourd'hui car elle contient tous les mécanismes nécessaires pour assurer une transmission fiable des données sur un réseau non fiable. Nous couvrons la couche transport en développant d'abord un protocole simple de couche transport fiable, puis expliquons les détails des protocoles TCP et UDP utilisés dans les réseaux TCP/IP.</p>
                    <p>Après la couche transport, nous analysons la couche réseau dans le chapitre "La couche réseau". C'est également une couche très importante car elle est responsable de la livraison de paquets de n'importe quelle source vers n'importe quelle destination via des routeurs intermédiaires. Dans la couche réseau, nous décrivons les deux organisations possibles de la couche réseau et les protocoles de routage basés sur les états de lien et les vecteurs de distance. Ensuite, nous expliquons en détail les protocoles IPv4, IPv6, RIP, OSPF et BGP qui sont effectivement utilisés dans l'Internet d'aujourd'hui.</p>
                    <p>Le dernier chapitre du livre est consacré à la couche liaison de données. Dans le chapitre "La couche liaison de données et les réseaux locaux", nous commençons par expliquer les principes de la couche liaison de données sur des liens point-à-point. Ensuite, nous nous concentrons sur les réseaux locaux. Nous considérons à la fois les techniques opportunistes et déterministes. Nous expliquons ensuite en détail deux types de LAN importants d'un point de vue de déploiement aujourdhui : <span class="html">Ethernet</span> et <span class="html">Wifi</span>.</p>
                </article>
                <article>
                    <h2 id="couche_application">Partie 2 : La couche application :</h2>
                    <h3>3.1 La couche application :</h3>
                    <p>La couche application est la couche la plus importante et la plus visible des réseaux informatiques. Les applications résident dans cette couche et les utilisateurs humains interagissent via ces applications à travers le réseau.</p>
                    <p>Dans ce chapitre, nous décrivons d'abord brièvement les principes principaux de la couche application et nous nous concentrons sur les deux modèles d'application les plus importants : les modèles client-serveur et pair-à-pair. Ensuite, nous examinons en détail deux familles de protocoles qui se sont révélées très utiles sur Internet : le courrier électronique et les protocoles qui permettent l'accès aux informations sur le World Wide Web. Nous décrivons également le système de noms de domaine qui permet aux humains d'utiliser des noms convivaux alors que les hôtes utilisent des adresses IP longues de 32 bits ou 128 bits.</p>
                    <h3>3.2 Principes :</h3>
                    <p>Il y a deux modèles importants utilisés pour organiser une application en réseau. Le premier et le plus ancien modèle est le modèle client-serveur. Dans ce modèle, un serveur fournit des services aux clients qui échangent des informations avec lui. Ce modèle est hautement asymétrique : les clients envoient des requêtes et les serveurs effectuent des actions et renvoient des réponses. Il est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/modele_client_serveur.PNG" alt="">
                        <figcaption>Figure 3.1 : Le modèle client-serveur</figcaption>
                    </figure>
                    <p>Le modèle client-serveur était le premier modèle utilisé pour développer des applications en réseau. Ce modèle découle naturellement des ordinateurs centraux et des mini-ordinateurs qui étaient les seuls ordinateurs en réseau utilisés jusqu'aux années 1980. Un mini-ordinateur est un système multi-utilisateur utilisé par des dizaines ou plus d'utilisateurs en même temps. Chaque utilisateur interagit avec le mini-ordinateur en utilisant un terminal. Ces terminaux, composés principalement d'un écran, d'un clavier et d'un câble directement connecté au mini-ordinateur.</p>
                    <p>Il existe différents types de serveurs ainsi que différents types de clients. Un serveur web fournit des informations en réponse à la requête envoyée par ses clients. Un serveur d'impression imprime des documents envoyés sous forme de requêtes par le client. Un serveur de messagerie transférera les messages électroniques envoyés sous forme de requêtes à leur destinataire, tanid qu'un serveur de musique fournira la musique demandée par le client. Du point de vue du développeur d'application, les applications cliente et serveur échangent directement des messages (les flèches horizontales étiquetées Requêtes et Réponses dans la figure ci-dessus), mais en pratique, ces messages sont échangés grpace aux couches sous-jacentes (les flèches verticales dans la figure ci-dessus). Dans ce chapitre, nous nous concentrons sur ces échanges horizontaux de messages.</p>
                    <p>Les applications en réseau n'échangent pas des messages aléatoires. Pour s'assurer que le serveur est capable de comprendre les requêtes envoyées par un client, et aussi que le client est capable de comprendre les réponses envoyées par le serveur, ils doivent tous deux convenir d'un ensemble de règles syntaxiques et sémantiques. Ces règles définissent le format des messages échangés ainsi que leur ordre. Cet ensemble de règles est appelé un protocole de niveau application.</p>
                    <p>Un <span class="html">protocole de niveau d'application</span> est similaire à une conversation structurée entre des êtres humains. Supposons qu'Alice souhauite connaître l'heure actuelle mais n'a pas de montre. Si Bob passe à proximité, la conversation suivante pourrait avoir lieu :</p>
                    <ul>
                        <li>
                            <p>Alice : Bonjour</p>
                        </li>
                        <li>
                            <p>Bob : Bonjour</p>
                        </li>
                        <li>
                            <p>Alice : Quelle heure est-il ?</p>
                        </li>
                        <li>
                            <p>Bob : 11h55</p>
                        </li>
                        <li>
                            <p>Alice : Merci</p>
                        </li>
                        <li>
                            <p>Bob : De rien</p>
                        </li>
                    </ul>
                    <p>Une telle conversation réussit si Alice et Bob parlent la même langue. Si Alice rencontre Tchang qui ne parle que chinois, elle ne pourra pas lui demander l'heure actuelle. Une conversation entre humains peut être plus complexe. Par exemple, supposons que Bob est un garde de sécurité dont la responsabilité est de n'autoriser que les agents secrets de confiance à entrer dans une salle de réunion. Si tous les agents connaissent un mot de passe secret, la conversation entre Bob et Trudy pourrait être la suivante :</p>
                    <ul>
                        <li>
                            <p>Bob : Quel est le mot de passe secret ?</p>
                        </li>
                        <li>
                            <p>Trudy : 1234</p>
                        </li>
                        <li>
                            <p>Bob : C'est le mot de passe correct, bienvenue</p>
                        </li>
                    </ul>
                    <p>Si Alice veut entrer dans la salle de réunion mais ne connaît pas le mot de passe, sa conversation pourrait être la suivante :</p>
                    <ul>
                        <li>
                            <p>Bob : Quel est le mot de passe secret ?</p>
                        </li>
                        <li>
                            <p>Alice : 3.1415</p>
                        </li>
                        <li>
                            <p>Bob : Ce n'est pas le mot de passe correct</p>
                        </li>
                    </ul>
                    <p>Les conversations humaines peuvent être très formelles, par exemple lorsque les soldats communiquent avec leur hiérarchie, ou informelles comme lorsqu'ils discutent entre amis. Les ordinateurs qui communiquent sont plus semblables à des soldats et nécessitent des règles bien définies pour assurer un échange d'informations réussi. Il existe deux types de règles qui définissent comment les informations peuvent être échangées entre les ordinateurs :</p>
                    <ul>
                        <li>
                            <p>Les règles syntaxiques précisent le format des messages échangés entre les ordinateurs. Comme les ordinateurs ne traitent que des bits, ces règles spécifient comment l'information est encodée en chaînes de bits.</p>
                        </li>
                        <li>
                            <p>Pour de nombreuses applications, le flux d'informations doit être structuré et il existe des relations de prééminence entre les différents types d'informations échangées. Dans l'exemple de l'heure donné précédemment, Alice doit saluer Bob avant de lui demander l'heure. Alice ne demanderait pas l'heure d'abord et ne saluerait Bob qu'ensuite. De telles relations de prééminence existent également dans les applications réseau. Par exemple, un serveur doit recevoir un nom d'utilisateur et un mot de passe valide avant d'accepter des commandes plus complexes de ses clients.</p>
                        </li>
                    </ul>
                    <p>Commençons par discuter des règles syntaxiques. Nous expliquerons plus tard comment le flux d'informations peut être organisé en analysant des applications réseau réelles.</p>
                    <p>Les protocoles de la couche application échangent deux types de messages. Certains protocoles tels que ceux utilisés pour prendre en charge l'échange de courrier électronique échangenet des messages exprimés sous forme de chaînes ou de lignes de caractères. Comme la couche de transport permet aux hôtes d'échanger des octets, ils doivent convenir d'une représentation commune des caractères. La première et la plus simple méthode pour encoder les caractères est d'utiliser la table ASCII. La RFC 20 fournit la table ASCII qui est utilisée par de nombreux protocoles sur Internet. Par exemple, la table définit les représentations binaires suivantes :</p>
                    <ul>
                        <li>
                            <p>A : 1000011b</p>
                        </li>
                        <li>
                            <p>0 : 0110000b</p>
                        </li>
                        <li>
                            <p>z : 1111010b</p>
                        </li>
                        <li>
                            <p>@ : 1000000b</p>
                        </li>
                        <li>
                            <p>space : 0100000b</p>
                        </li>
                    </ul>
                    <p>En outre, la table ASCII définit également plusieurs caractères non imprimables ou caractères de contrôle. Ces caractères ont été conçus pour permettre à une application de contrôler une imprimante ou un terminal. Ces caractères de contrôle comprennent CR et LF, qui sont sont utilisés pour terminer une ligne, et le caractère Bell qui provoque l'émission d'un son par le terminal.</p>
                    <ul>
                        <li>
                            <p>Retour chariot (CR pour carriage return) : 000AA0Ab</p>
                        </li>
                        <li>
                            <p>Avance de ligne (LF pour line feed) : 0001010b</p>
                        </li>
                        <li>
                            <p>Bell : 0000111b</p>
                        </li>
                    </ul>
                    <p>Les caractères ASCII sont encodés sur sept bits, mais transmis sous forme d'un octet de huit bits dont le bit de poids élevé est généralement fixé à 0. Les octets sont toujours transmis en commmençant par le bit de poids élevé ou le bit le plus significatif.</p>
                    <p>La plupart des applications échangent des chaînes de caractères composées d'un nombre fixe ou variable de caractères. Une solution courante pour définir les chaînes de caractères acceptables consiste à les définir comme une grammaire utilisant une forme de Backus-Naur (BNF) telle que la BNF augmentée définie dans le RFC 5234. Une BNF est un ensemble de règles de production qui génèrent toutes les chaînes de caractères valides. Par exemple, considérez une application en réseau qui utilise deux commandes, où l'utilisateur peut fournir un nom d'utilisateur et un mot de passe. La BNF pour cette application pourrait être définie comme indiqu" dans la figure-dessous.</p>
                    <figure>
                        <img src="../images/specification_BNF_simple.PNG" alt="">
                        <figcaption>Figure 3.2 : Une spécification BNF simple</figcaption>
                    </figure>
                    <p>L'exemple ci-dessus définit plusieurs terminaux et deux commandes : <span class="em">usercommand</span> et <span class="em">passwordcommand</span>. Le terminal <span class="em">ALPHA</span> contient toutes les lettres en majuscules et minuscules. Dans la règle <span class="em">ALPHA</span>, <span class="em">%x41</span> correspond au code de caractère ASCII <span class="em">41</span> en hexadécimal, c'est-à-dire le <span class="em">A</span> majuscule. Les terminaux <span class="em">CR</span> et <span class="em">LF</span> correspondent aux caractères de contrôle de retour de cariot et de saut de ligne. La règle <span class="em">CRLF</span> concatène ces deux terminaux pour correspondre à la fin de ligne standard. Le terminal <span class="Em">DIGIT</span> contient tous les chiffres. Le terminal <span class="em">SP</span> correspond aux caractères d'espacement. La commande <span class="em">usercommand</span> est composée de deux chaînes séparées par un espace blanc. Dans les règles <span class="em">ABNF</span> qui définissent les messages utilisés par les applications Internet, les commandes sont insensibles à la casse. La règle "user" correspond à toutes les cas possibles des lettres qui composent le mot entre crochets, par exemple user, uSeR, USER, usER, ... Un nom d'utilisateur contient au moins une lettre et jusqu'à 8 lettres. Les noms d'utilisateur sont sensibles à la casse car ils ne sont pas définis comme une chaîne entre crochets. La règle de mot de passe indique qu'un mot de passe commence par une lettre et peut contenir n'importe quel nombre de lettres ou de chiffres. Les caractères d'espacement et de contrôle ne peuvent pas apparaître dans un mot de passe défini par la règle ci-dessus.</p>
                    <p>En plus des chaînes de caractères, certaines applications ont également besoin d'échanger des champs de 16 ou 32 bits tels que des entiers. Une solution naïve aurait été d'envoyer le champ de 16 ou 32 bits tel qu'il est encodé dans la mémoire de l'hôte. Malheureusement, il existe différentes méthodes pour stocker les champs de 16 ou 32 bits en mémoire. Certains porcesseurs stockent le byte le plus significatif d'un champ de 16 bits à la première adresse du champ, tandis que d'autres stockent le byte le moins significatif à cet emplacement. Lorsque des applications en réseau s'exécutant sur des processeurs différents échangent des champs de 16 bits, il existe deux possibilités pour les transférer via le service de transport :</p>
                    <ul>
                        <li>
                            <p>envoyer le byte le plus significatif suivi du byte le moins significatif</p>
                        </li>
                        <li>
                            <p>envoyer le byte le moins significatif suivi du byte le plus significatif</p>
                        </li>
                    </ul>
                    <p>La première possibilité a été appelée <span class="html">big-endian</span> dans une note écrite par Cohen [Cohen1980], tandis que la seconde a été appelée <span class="html">little-endian</span>. Les fournisseurs de processeurs qui utilisaient <span class="em">big-endian</span> en mémoire ont insisté sur l'utilisation de l'encodage <span class="em">big-endian</span> dans les applications en réseau, tandis que les fournisseurs de processeurs qui utilisaient <span class="em">little-endian</span> ont recommandé l'inverse. Plusieurs études ont été rédigées sur les mérites relatifs de chaque type d'encodage, mais la discussion est devenue presque une question religieuse [Cohen1980]. Finalement, Internet a choisi l'encodage <span class="em">big-endian</span>, c'est-à-dire que les champs multi-octets sont toujours transmis en envoyant le byte le plus significatif en premier, le RFC 791 fait référence à cet encodage comme étant <span class="html">l'ordre des octets du réseau</span>. La plupart des bibliothèques utilisées pour écrire des applications en réseau contiennent des fonctions permettant de convertir les champs multi-octets de la mémoire à l'ordre des octets du réseau et vice versa.</p>
                    <p>Par exemple, les fonctions de la bibliothèque standard C <span class="html">htonl(3)</span> et <span class="html">ntohl(3)</span> permettent de convertir un entier non signé de 32 bits de l'ordre d'octets utilisé par le processeur à l'ordre d'octets du réseau (resp. de l'ordre d'octets du réseau à l'ordre d'octets du processeur). Des fonctions similaires existent dans d'autres langages de programmation.</p>
                    <p>En plus des mots de 16 et 32 bits, certaines applications ont besoin d'échanger des structures de données contenant des champs de bits de différentes longueurs. Par exemple, un message peut être composé d'un champ de 16 bits suivi de huit indicateurs, chacun sur un seul bit, d'un champ de 24 bits et de deux octets de 8 bits. Les spécifications des protocoles Internet définiront un tel message en utilisant une représentation telle que celle ci-dessous. Dans cette représentation, chaque ligne correpond à 32 bits et les lignes verticales sont utilisées pour délimiter les champs. Les nombres au-dessus des lignes indiquent les positions des bits dans le mot de 32 bits, avec le bit de poids fort à la position 0.</p>
                    <figure>
                        <img src="../images/format_message.PNG" alt="">
                        <figcaption>Figure 3.3 : Format message</figcaption>
                    </figure>
                    <p>Le message mentionné ci-dessus sera transmis en commençant par le premier mot de 32 bits dans l'ordre des octets du réseau. Le premier champ est encodé sur 16 bits. Il est suivi de huit indicateurs à un bit (A-H), d'un champ de 24 bits dont l'octet de poids fort est représenté sur la première ligne et les deux octets de poids faible apparaissent sur la deuxième ligne, suivis de deux champs d'un octet chacun. Cette représentation ASCII est fréquemment utilisée lors de la définition de protocoles binaires. Nous l'utiliserons pour tous les protocoles binaires discutés dans ce livre.</p>
                    <p>Nous discuterons de plusieurs exemples de protocoles au niveau de l'application dans ce chapitre.</p>
                    <h4>3.2.1 Le modèle pair-à-pair :</h4>
                    <p>Le modèle pair-à-pair est apparu au cours des dix dernières années en tant qu'architecture possible pour les applications en réseau. Dans le modèle client-serveur traditionnel, les hôtes agissent soit en tant que serveurs, soit en tant que clients et un serveur sert un grand nombre de clients. Dans le modèle pair-à-pair, tous les hôtes agissent à la fois en tant que serveurs et clients et jouent les deux rôles. Le modèle pair-à-pair a été utilisé pour développer diverses applications en réseau, allant de la téléphonie Internet au partage de fichiers ou aux systèmes de fichiers à l'échelle d'Internet. Une description détaillée des applications pair-à-pair peut être trouvée dans [BYL2008]. Des enquêtes sur les protocoles et les applications pair-à-pair peuvent être trouvées dans [AS2004] et [LCP2005].</p>
                    <h3>3.3 Les services de transport :</h3>
                    <p>Les applications en réseau sont construites sur le service de transport. Comme expliqué dans le chapitre précédent, il existe deux types principaux de services de transport :</p>
                    <ul>
                        <li>
                            <p>le service de datagramme ou sans connexion</p>
                        </li>
                        <li>
                            <p>le service orienté connexion ou de flux d'octets</p>
                        </li>
                    </ul>
                    <p>Le service sans connexion permet aux appplications d'échanger facilement des messages ou des unités de donénes de service. Sur Internet, ce service est fourni par le protocole UDP qui sera expliqué dans le prochain chapitre. Le service de transport sans connexion sur Internet est peu fiable, mais est capable de détecter les erreurs de transmission. Cela implique qu'une application ne recevra pas une unité de données de service qui a été corrompue en raison d'erreurs de transmission.</p>
                    <p>Le service de transport sans connexion permet aux applications réseau d'échanger des messages. Plusieurs applications réseau peuvent être en cours d'exécution en même temps sur un seul hôte. Chacune de ces applications doit être en mesure d'échanger des SDU avec des applications distantes. Pour permettre ces échanges de SDU, chaque application réseau s'exécutant sur un hôte est identifiée par les informations suivantes :</p>
                    <ul>
                        <li>
                            <p>l'<span class="html">hôte</span> sur lequel l'application s'exécute</p>
                        </li>
                        <li>
                            <p>le <span class="html">numéro de port</span> sur lequel l'application écoute les SDU</p>
                        </li>
                    </ul>
                    <p>Sur Internet, le numéro de port est un entier et l'hôte est identifé par son adresse réseau. Comme nous le verrons dans le chapitre sur la couche réseau, il existe deux types d'adresses Internet :</p>
                    <ul>
                        <li>
                            <p>les adresses <span class="html">IP version 4</span> qui sont larges de 32 bits</p>
                        </li>
                        <li>
                            <p>les adresses <span class="html">IP version 6</span> qui sont larges de 128 bits</p>
                        </li>
                    </ul>
                    <p>IPv4 est représenté habituellement en utilisant une représentation décimale pointée où chaque nombre décimal correspond à un octet de l'adresse, par exemple <span class="em">203.0.113.56</span>. Les adresses IPv6 sont généralement représentées sous forme de nombres hexadécimaux séparés par des deux-points, par exemple <span class="em">2011:db8:3080:2:217:f2ff:fed6:65c0</span>. AUjourd'hui, la plupart des hôtes Internet ont une adresse IPv4. Une petite fraction d'entre eux a également une adresse IPv6. À l'avenir, nous pouvons nous attendre à ce que de plus en plus d'hôtes aient des adresses IPv6 et que certains d'entre eux n'aient plus d'adresse IPv4. Un hôte qui n'a qu'une adresse IPv6. La figure ci-dessous illustre deux hôtes qui utilisent le service de datagramme fourni par UCP sur des hôtes qui utilisent des adresses IPv4.</p>
                    <figure>
                        <img src="../images/service_sans_connexion_datagramme.PNG" alt="">
                        <figcaption>Figure 3.4 : Le service sans connexion ou datagramme</figcaption>
                    </figure>
                    <p>Le deuxième service de transport est le service orienté connexion. Sur Internet, ce service est souvent appelé le <span class="html">service de flux de bytes</span> car il crée un flux de bytes fiable entre les deux applications qui sont liées par une connexion de transport. Comme le service datagramme, les applications réseau qui utilisent le service de flux de bytes sont identifiées par l'hôte sur lequel elles s'exécutent et un numéro de port. Ces hôtes peuvent être identifés par une adresse IPv4, une adresse IPv6 ou un nom. La figure ci-dessous illustre deux applications qui utilisent le service de flux de bytes fourni par le protocole TCP sur des hôtes IPv6. Le service de flux de bytes fourni par TCP est fiable et bidirectionnel.</p>
                    <h3>3.4 Protocoles de niveau applicatif :</h3>
                    <p>De nombreux protocoles ont été définis pour les applications réseau. Dans cette section, nous décrivons certaines des applications importantes utilisées sur Internet. Nous expliquons d'abord le <span class="html">système de noms de domaine (DNS pour Domain Name System)</span> qui permet aux hôtes d'être identifiés par des noms convivaux pour les humains au lieu des adresses IPv4 ou IPv6 utilisées par le réseau. Ensuite, nous décrivons le fonctionnement du courrier électronique, l'une des premières applications phares sur l'INternet mondial, et les protocoles utilisés sur le World Wide Web.</p>
                    <h4>3.4.1 Le DNS :</h4>
                    <p>Au début de l'Internet, il y avait seulement quelques hôtes (principalement des mini-ordinateurs) connectés au réseau. Les applications les plus populaires étaient la connexion à distance et le transfert de fichiers. En 1983, il y avait déjà cinq cents hôtes connectés à l'Internet. Chacun de ces hôtes était identifié par une adresse IPv4 unique. Forcer les utilisateurs à se souvenir des adresses IPv4 des hôtes distants qu'ils voulaient utiliser n'était pas convivial pour les utilisateurs. Les utilisateurs préfèrent se souvenir des noms et les utiliser en cas de besoin. Utiliser des noms comme alias pour les adresses est une technique courante en informatique. Elle simplifie le développement des applications et permet au développeur d'ignorer les détails de bas niveau. Par exemple, en utilisant un langage de programmation plutôt qu'enécrivant du code machine, un développeur peut écrire des logiciels sans savoir si les variables qu'il utilise sont stockées dans la mémoire ou dans les registres.</p>
                    <p>En raison du fait que les noms sont à un niveau supérieur aux adresses, ils permettent (aussi bien dans l'exemple de la programmation que sur Internet) de considérer les adresses comme de simples identifiants techniques, qui peuvent être modifiés à volonté. Seuls les noms sont stables. Sur l'Internet d'aujourd'hui, où le fait de passer à un autre fournisseur d'accès Internet signifie changer ses adresses IP, la convivialité des noms de domaine est moins importante (les utilisateurs ne les saisissent pas souvent), mais leur stabilité reste une propriété très importante, peut-être leur propriété la plus importante.</p>
                    <p>La première solution qui a permis aux applications d'utiliser des noms était le fichier <span class="em">hosts.txt</span>. Ce fichier est similaire à la table des symboles que l'on trouve dans le code compilé. Il contient la correspondance entre le nom de chaque hôte Internet et son adresse IP associée. Il était géré par SRI International, qui coordonnait le <span class="html">Centre d'information réseau (NIC pour Network Information Center)</span>. Lorsq'un nouvel hôte était connecté au réseau, l'administrateur système devait enregistrer son nom et son adresse IP auprès du NIC. Le NIC mettait à jour le fichier hosts.txt sur son serveur. Tous les hôtes Internet récupéraient régulièrement le fichier hosts.txt mis à jour à partir du serveur maintenu par SRI. Ce fichier était stocké à un emplacement bien connu sur chaque hôte Internet (voir RFC 952) et les applications réseau pouvaient l'utiliser pour trouver l'adresse IP correspondant à un nom.</p>
                    <p>Le fichier hosts.txt n'est plus maintenu. Une capture historique récupérée le 15 avril 1984 est disponible sur <a href="http://ftp.univie.ac.at/netinfo/netinfo/hosts.txt" target="_blank">http://ftp.univie.ac.at/netinfo/netinfo/hosts.txt</a>.</p>
                    <p>Un fichier hosts.txt peut être utilisé lorsqu'il y a jusqu'à quelques centaines d'hôtes sur le réseau. Cependant, il n'est clairement pas adapté à un réseau contenant des milliers ou des millions d'hôtes. Un problème clé dans un grand réseau est de définir un schéma de nommage approprié. L'ARPANet utilisait initialement un espace de noms plat, c'est-à-dire que chaque hôte se voyait attribuer un nom unique. Pour limiter les collisions entre les noms, ces derniers contenaient généralement le nom de l'institution et un suffixe pour identifier l'hôte à l'intérieur de l'institution (une sorte de système de nommage hiérarchique du pauvre). Sur l'ARPANet, peu d'institutions avaient plusieurs hôtes connectés au réseau.</p>
                    <p>Cependant, les limites d'un schéma de nomenclature plat sont devenues évidentes avant la fin de l'ARPANet et le RFC 819 a proposé un schéma de nomenclature hiérachique. Bien que le RFC 819 ait discuté de la possibilité d'organiser les noms en tant que graphe orienté, Internet a finalemnt opté pour une structure en arborescence capable de contenir tous les noms. Dans cette arborescence, les domaines de premier niveau sont ceux qui sont directement attachés à la racine. Le premier domaine de premier niveau était <span class="em">.arpa</span> (voir <a href="http://www.donelan.com/dnstimeline.html" target="_blank">http://www.donelan.com/dnstimeline.html</a> pour une chronologie des développements liés à DNS). Ce nom de niveau supérieur a été initialement ajouté comme suffixe aux noms des hôtes attachés à l'ARPANet et listés dans le fichier hosts.txt. EN 1984, les noms de domaine génériques de premier niveau <span class="em">.gov</span>, <span class="em">.edu</span>, <span class="em">.com</span>, <span class="em">.mil</span> et <span class="em">.org</span> ont été ajoutés et le RFC 1032 a proposé l'utilisation des codes de pays <span class="em">ISO-3166</span> à deux lettres comme noms de domaine de premier niveau. Comme ISO-3166 définit un code à deux lettres pour chaque pays reconnu par les Nations unies, cela a permis à tous les pays d'avoir automatiquement un domaine de premier niveau. Ces domaines <span class="em">.be</span> pour la Belgique, <span class="em">.fr</span> pour la France, <span class="Em">.us</span> pour les États-Unis, <span class="em">.ie</span> pour l'Irlande ou <span class="em">.tv</span> pour Tuvalu, un groupe de petites îles dans le Pacifique et <span class="em">.tm</span> pour le Turkménistan. Aujourd'hui, l'ensemble des noms ou de domaine de premier est géré par la <span class="html">Corporation pour l'attribution des noms et des numéros sur Internet (ICANN pour "Internet Corporation for Assigned Names and Numbers")</span>. Récemment, l'ICANN a ajouté une douzaine de domaines de premier niveau génériques qui ne sont pas liés à un pays et le domaine de premier niveau <span class="em">.cat</span> a été enregistré pour la langue catalane. Des discussions sont en cours au sein de l'ICANN pour augmenter le nombre de domaines de premier niveau.</p>
                    <p>Chaque domaine de premier niveau est géré par une organisation qui décide de la manière dont les noms de sous-domaines peuvent être enregistrés. La plupart des noms de domaine de premier niveau utilisent un système du premier arrivé, premier servi et permettent à quiconque d'enregistrer des noms de domaine, mais il y a des exceptions. Par exemple, <span class="em">.gov</span> est réservé au gouvernement américain, <span class="em">.int</span> est réservé aux organisations internationales et les noms en <span class="em">.ca</span> sont principalement réservés aux entreprises ou aux utilisateurs présents au Canada.</p>
                    <figure>
                        <img src="../images/arbre_noms_domaine.PNG" alt="">
                        <figcaption>Figure 3.6 : L'arbre des noms de domaine</figcaption>
                    </figure>
                    <p>RFC 1035 a recommandé la BNF suivante pour les noms de domaine complets, afin de permettre aux noms d'hôtes d'avoir une syntaxe qui fonctionne avec toutes les applications (les noms de domaine eux-mêmes ont une syntaxe beacuoup plus riche).</p>
                    <figure>
                        <img src="../images/BNF_noms_domaine_complets.PNG" alt="">
                        <figcaption>Figure 3.7 : BNF des noms de domaine complets</figcaption>
                    </figure>
                    <p>Cette grammaire spécifie qu'un nom d'hôte est une liste ordonnée d'étiquettes spéparées par le caractère point (.). Chaque étiquette peut contenir des lettres, des chiffres et le caractère tiret (-). Cette spécification a évolué ultérieurement pour prendre en charge des noms de domaine écrits en utilisant d'autres jeux de caractères que l'us-ASCII RFC 5890. Cette extension est importante pour prendre en charge des langues autres que l'anglais, mais une discussion détaillée sort du cadre de ce document. Les noms de domaine complets sont lus de gauche à droite. La première étiquette est un nom d'hôte ou un nom de domaine suivi de la hiérarchie des domaines et se terminant implicitement à droite par la racine. Le nom de domaine de premier niveau doit être l'un des TLD enregistrés. La liste officielle des noms de domaine de premier niveau est gérée par le terme : `IANA` à l'adresse <a href="http://data.iana.org/TLD/tlds-alpha-by-domain.txt" target="_blank">http://data.iana.org/TLD/tlds-alpha-by-domain.txt</a>. Des informations supplémentaires sur ces domaines peuvent être trouvées à l'adresse <a href="http://en.wikipedia.org/wiki/List_of_Internet_top-level_domains" target="_blank">http://en.wikipedia.org/wiki/List_of_Internet_top-level_domains</a>. Par exemple, dans la figure ci-dessus, <a href="http://www.whitehouse.gov/" target="_blank">http://www.whitehouse.gov/</a> correspond à un hôte nommé <span class="em">www</span> du domaine <span class="em">whitehouse</span> qui appartient au domaine de premier niveau <span class="em">gov</span>. <span class="em">info.ucl.ac.be</span> correspond au domaine <span class="em">info</span> à l'intérieur du domaine <span class="em">ucl</span> qui est inclus dans le sous-domaine <span class="em">ac</span> du domaine de premier niveau <span class="em">be</span>.</p>
                    <p>Le schéma de nommage hiérarchique est un élément clé du système de noms de domaine (DNS). Le DNS est une base de données distribuée qui contient des correspondances entre des noms de domaine complets et des adresses IP. Le DNS utilise le modèle client-serveur. Les clients sont des hôtes qui ont besoin de récupérer la correspondance pour un nom donné. Chaque serveur de noms stocke une partie de la base de données distribuée et répond aux requêtes envoyées par les clients. Il y a au moins un serveur de noms qui est responsable de chaque domaine. Dans la figure ci-dessous, les domaines sont représentés par des cercles et il y a trois hôtes dans le domaine <span class="em">dom</span> (<span class="em">h1</span>, <span class="em">h2</span> et <span class="em">h3</span>) et trois hôtes dans le domaine <span class="em">a.sdom.dom</span>. Comme le montre la figure ci-dessous, un sous-domaine peut contenir à la fois des noms d'hôtes et des sous-domaines.</p>
                    <figure>
                        <img src="../images/arbre_simple_noms_domaine.PNG" alt="">
                        <figcaption>Figure 3.8 : Un arbre simple de noms de domaine</figcaption>
                    </figure>
                    <p>Un serveur de noms qui est responsable du domaine <span class="em">dom</span> peut répondre directement aux requêtes suivantes :</p>
                    <ul>
                        <li>
                            <p>l'adresse IP de tout hôte résidant directement dans le domaine <span class="em">dom</span> (par exemple, <span class="em">h2.dom</span> dans la figure ci-dessus)</p>
                        </li>
                        <li>
                            <p>le(s) serveur(s) de noms qui sont responsables de tout sous-domaine direct du domaine <span class="em">dom</span> (c'est-à-dire <span class="em">sdom1.dom</span> et <span class="em">sdom2.dom</span> dans la figure ci-dessus, mais pas <span class="em">z.sdom1.dom</span>)</p>
                        </li>
                    </ul>
                    <p>Pour récupérer la correspondance pour l'hôte <span class="em">h2.dom</span>, un client envoie sa requête au serveur de noms qui est responsable du domaine <span class="em">.dom</span>. Le serveur de noms répond directement à la requête. Pour récupérer une correspondance pour <span class="em">h3.a.sdom1.dom</span>, un client DNS envoie d'abord une requête au serveur de noms qui est responsable du domaine <span class="em">.dom</span>. Ce serveur de noms renvoie le serveur de noms qui est responsable du domaine <span class="em">sdom1.dom</span>. Ce serveur de noms peut maintenant être contacté pour obtenir le serveur de noms qui est responsable du domaine <span class="em">a.sdom1.dom</span>. Ce serveur de noms peut être contacté pour récupérer la correspondance pour le nom <span class="em">h3.a.sdom1.dom</span>. Grâce à cette organisation des serveurs de noms, il est possible pour un client DNS d'obtenir la correspondance de n'importe quel hôte à l'intérieur du domaine <span class="em">.dom</span> ou de l'un de ses sous-domaines. Pour garantir qu'un client DNS sera en mesure de résoudre n'importe quel nom de domaine pleinement qualifié, il existe des serveurs de noms spéciaux qui sont responsables de la racine de la hiérarchie des noms de domaine. Ces serveurs de noms sont appelés serveurs de noms racine. Il existe actuellement une douzaine de serveurs de noms racine. En pratique, certains de ces serveurs de noms racine sont eux-mêmes mis en oeuvre sous la forme d'un ensemble de serveurs physiques distincts. Voir <a href="http://www.root-servers.org/" target="_blank">http://www.root-servers.org/</a> pour plus d'informations sur l'emplacement physique de ces serveurs.</p>
                    <p>Chaque serveur de noms racine maintient la liste de tous les serveurs de noms qui sont responsables de chacun des noms de domaines de premier niveau et de leurs adresses IP. Une copie des informations maintenues par chaque serveur de noms racine est disponible sur <a href="http://www.internic.net/zones/root.zone" target="_blank">http://www.internic.net/zones/root.zone</a>. Jusqu'en février 2008, les serveurs DNS racine n'avaient que des adresses IPv4. Les adresses IPv6 ont ét ajoutées lentement aux serveurs DNS racine pour éviter de créer des problèmes comme discuté dans <a href="http://www.icann.org/en/committees/security/sac018.pdf" target="_blank">http://www.icann.org/en/committees/security/sac018.pdf</a>. En 2010, plusieurs serveurs DNS racine ne sont toujours pas accessibles en utilisant IPv6. Tous les serveurs de noms racine sont synchronisés et fournissent les mêmes réponses. En interrogeant l'un des serveurs de noms racine, un client DNS peut obtenir le serveur de noms qui est responsable de n'importe quel nom de domaine de premier niveau. À partir de ce serveur de noms, il est possible de résoudre n'importe quel nom de domaine.</p>
                    <p>Pour être capable de contacter les serveurs de noms racine, chaque client DNS doit connaître leurs adresses IP. Cela implique que les clients DNS doivent maintenir une liste à jour des adresses IP des serveurs de noms racine. La liste actuelle des adresses IP des serveurs de noms racine est maintenant <a href="http://www.internic.net/zones/named.root" target="_blank">http://www.internic.net/zones/named.root</a>. Ces adresses IP sont stables et les serveurs de noms racine changent rarement leurs adresses IP. Les résolveurs DNS doivent cependant maintenir une copie à jour de ce fichier. Sans cette liste, il est impossible de contacter les serveurs de noms racine. Forcer tous les hôtes Internet à maintenir la version la plus récente de cette liste serait difficile d'un point de vue opérationnel. Pour résoudre ce problème, les concepteurs du DNS ont introduit un type spécial de serveur DNS : les résolveurs DNS. Un résolveur est un serveur qui fournit le service de résolution de noms pour un ensemble de clients. Un réseau contient généralment quelques résolveurs. Chaque hôte de ces réseaux est configuré pour envoyer toutes ses requêtes DNS via l'un de ses résolveurs locaux. Ces requêtes sont appelées des requêtes récursives car le résolveur doit faire une récursion à travers la hiérarchie des serveurs de noms pour obtenir la réponse.</p>
                    <p>Les résolveurs DNS présentent plusieurs avantages par rapport à laisser chaque hôte Internet interroger directement les serveurs de noms. Tout d'abord, les hôtes Internet classiques n'ont pas besoin de maintenir une liste à jour des adresses IP des serveurs racine. Deuxièmement, les hôtes Internet classiques n'ont pas besoin d'envoyer des requêtes à des serveurs de noms partout sur Internet. De plus, étant donné qu'un résolveur DNS sert un grand nombre d'hôtes, il peut mettre en cache les réponses reçues. Cela permet au résolveur de renvoyer rapidement les réponses pour les requêtes DNS populaires et réduit la charge sur tous les serveurs DNS [JSBM2002].</p>
                    <p>Le dernier composant du système de noms de domaine est le protocole DNS. Le protocole DNS s'exécute au-dessus des services de datagramme et de flux de données. En pratique, le service de datagramme est utilisé lorsque des requêtes et des réponses courtes sont échangées, et le service de flux de données est utilisé lorsque des réponses plus longues sont attendues. Dans cette section, nous ne discuterons que de l'utilsation du protocole DNS au-dessus du service de datagramme. C'est l'utilisation la plus fréquente du DNS.</p>
                    <p>Les messages DNS sont composés de cinq parties appelées sections dans la RFC 1035. Les trois premières sections sont obligatoires et les deux dernières sont optionnelles. La première section d'un message DNS est son en-tête. Elle contient des informations sur le type de message et le contenu des autres sections. La deuxième section contient la question envoyée au serveur de noms ou au résolveur. La troisième section contient la réponse à la question. Lorsqu'un client envoie une requête DNS, la section Réponse est vide. La quatrième section, nommée Autorité, contient des informations sur les serveurs pouvant fournir une réponse autoritative si nécessaire. La dernière section contient des informations supplémentaires fournies par le résolveur ou le serveur mais qui n'ont pas été demandées dans la question.</p>
                    <p>L'en-tête des messages DNS est composé de 12 octets et sa structure est illustrée dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/entete_DNS.PNG" alt="">
                        <figcaption>Figure 3.9 : En-tête DNS</figcaption>
                    </figure>
                    <p>L'<span class="html">identifiant (ID)</span> est une valeur aléatoire de 16 bits choisie par le client. Lorsqu'un client envoie une requête à un serveur DNS, il se souvient de la requête et de son identifiant. Lorsqu'un serveur renvoie une réponse, il renvoie dans le champ <span class="em">ID</span> l'identifiant choisi par le client. Grâce à cet identifiant, le client peut faire correspondre la réponse reçue à la question qu'il a envoyée.</p>
                    <p>Le drapeau <span class="html">QR</span> est mis à <span class="em">0</span> dans les requêtes DNS et <span class="em">1</span> dans les réponses DNS. L'<span class="html">Opcode</span> est utilisé pour spécifier le type de requête. Par exemple, une <span class="em">requête standard</span> est lorsque le client envoie un <span class="em">nom</span> et que le serveur renvoie les <span class="em">données</span> correspondantes, et une demande de mise à jour est lorsque le client envoie un <span class="em">nom</span> et de nouvelles <span class="em">données</span> et que le serveur met ensuite à jour sa base de données.</p>
                    <p>Le bit <span class="html">AA</span> est mis lorsque le serveur qui a envoyé la réponse a <span class="em">l'autorité</span> pour le nom de domaine trouvé  dans la section de question. Dans les déploiempents DNS originaux, deux types de serveurs étaient considérés : les serveurs <span class="html">autoritaires</span> et les serveurs <span class="html">non-autoritaires</span>. Les serveurs <span class="em">autoritaires</span> sont gérés par les administrateurs système responsables d'un domaine donné. Ils stockent toujours les infomations les plus récentes sur un domaine. Les serveurs <span class="em">non-autoritaires</span> sont des serveurs ou des résolveurs qui stockent des informations DNS sur des domaines externes sans être gérés par les propriétaires d'un domaine. Ils peuvent donc founir des réponses qui sont obsolètes. Du point de vue de la sécurité, le bit <span class="em">autoritaire</span> n'est pas une indication absolue de la validité d'une réponse. La sécurisation du système de noms de domaine est un problème complexe qui n'a été résolu de manière satisfaisante que récemment par l'utilisation de signatures cryptographiqes dans les extensions DNSSEC à DNS décrites dans la RFC 4933. Cependant, ces extensions sont hors du champ d'application de ce chapitre.</p>
                    <p>Le bit <span class="html">RD (recursion desired)</span> est positionné par un client lorsqu'il envoie une requête à un résolveur. Une telle requête est dite <span class="html">récursive</span> car le résolveur effectuera une recherche récursive dans la hiérarchie DNS pour récupérer la réponse au nom du client. Dans le passé, tous les résolveurs étaient configurés pour effectuer des requêtes récursives au nom de n'importe quel hôte Internet. Cependant, cela expose les résolveurs à plusieurs risques de sécurité. Le plus simple est que le résolveur pourrait être surchargé en ayant trop de requêtes récursives à traiter. Au moment de la rédaction de ce texte, la plupart des résolveurs n'autorisent que les requêtes récursives des clients appartenant à leur entreprise ou réseau, et rejettent toutes les autres requêtes récursives. Certains résolveurs DNS permettent à n'importe quel hôte d'envoyer des requêtes. <span class="em">OpenDNS</span> et <span class="em">GoogleDNS</span> sont des exemples de résolveurs ouverts. Le bit <span class="html">RA</span> indique si le serveur prend en charge la récursivité. Le code de réponse <span class="html">RCODE</span> est utilisé pour distinguer différents types d'erreurs. Voir RFC 1035 plus plus de détails. Les quatres derniers champs indiquent la taille des sections <span class="html">Question</span>, <span class="html">Réponse</span>, <span class="html">AUtoritaire</span> et <span class="html">Aditionnelle</span> du message DNS.</p>
                    <p>Les quatre dernières sections du message DNS contiennent des <span class="html">enregistrements de ressources (RR pour Ressouce Records)</span>. Tous les RR ont le même format de niveau supérieur dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/enregistrements_ressources_DNS.PNG" alt="">
                        <figcaption>Figure 3.10 : Enregistrements de ressources DNS</figcaption>
                    </figure>
                    <p>Dans un enregistrement de ressources DNS (RR), le champ "<span class="html">Name</span>" indique le nom du noeud auquel cet enregistrement de ressources se rapporte. Les deux octets du champ "<span class="html">Type</span>" indiquent le type d'enregistrement de ressources. Le champ "<span class="html">Class</span>" était utilisé pour prendre en charge l'utilisation du DNS dans d'autres environnements que l'Internet.</p>
                    <p>Le champ "<span class="html">TTL (Time to Live)</span>" indique la durée de vie de l'<span class="em">enregistrement de ressources</span> en secondes. Ce champ est défini par le serveur qui renvoie une réponse et indique pendant combien de temps un client ou un résolveur peut stocker l'<span class="em">enregistrement de ressources</span> dans son cache. Un <span class="em">TTL</span> long indique un <span class="em">RR</span> stable. Cetaines entreprises utilisent des valeurs <span class="em">TTL</span> courtes pour les hôtes mobiles et également pour les serveurs populaires. Par exemple, une entreprise d'hébergement web qui veut répartir la charge sur un pool de vent serveurs peut configurer ses serveurs de noms pour renvoyer des réponses différentes à différents clients. Si chaque réponse a un petit <span class="em">TTL</span>, les clients seront obligés d'envoyer régulièrement des requêtes DNS. Le serveur de noms répondra à ces requêtes en fournissant l'adresse du serveur le moins chargé.</p>
                    <p>Le champ "<span class="html">RDLength</span>" est la longueur du champ "<span class="html">RData</span>" qui contient les informations du type spécifié dans le champ "<span class="html">Type</span>".</p>
                    <p>Plusieurs types de RR DNS sont utilisés en pratique. Le type <span class="html">A</span> est utilisé pour coder l'adresse IPv4 correspondant au nom spécifié. Le type <span class="html">AAAA</span> est utilisé pour coder l'adresse IPv6 correspondant au nom spécifié. Un enregistrement <span class="html">NS</span> contient le nom de serveur DNS qui est responsable d'un domaine donné. Par exemple, une requête pour l'enregistrement <span class="em">A</span> associé au nom <a href="http://www.ietf.org/" target="_blank">http://www.ietf.org/</a> retourne la réponse suivante.</p>
                    <p>Cette réponse contient plusieurs informations. Tout d'abord, le nom <a href="http://www.ietf.org/" target="_blank">http://www.ietf.org/</a> est associé à l'adresse IP <span class="em">64.170.98.32</span>. Deuxièmement, le domaine <span class="em">ietf.org</span> est géré par six szeveurs DNS différents. Trois de ces serveurs DNS sont accessibles via IPv4 et IPv6. Deux d'entre eux ne sont pas accesibles via IPv6 et <span class="em">ns0.ietf.org</span> n'est accessible que via IPv6. Une requête pour l'enregistrement <span class="em">AAAA</span> associé à <a href="http://www.ietf.org/" target="_target">http://www.ietf.org/</a> renvoie <span class="Em">2001:1890:1112:1::20</span> ainsi que les mêmes sections d'autorité et d'informations supplémentaires.</p>
                    <p>Les <span class="html">CNAME</span> (ou noms canoniques) sont utilisés pour définir des alias. Par exemple, <span class="em">www.example.com/</span> pourrait être un <span class="em">CNAME</span> pour <span class="em">pc12.example.com</span> qui est le nom réel du serveur sur lequel le serveur web pour <span class="em">www.example.com</span> s'exécute.</p>
                    <hr>
                    <p>Note : DNS inversé et in-addr.arpa :</p>
                    <figure>
                        <img src="../images/requete_enregistrement_A_ietf_org.PNG" alt="">
                        <figcaption>Figure 3.11 : Requête pour l'enregistrement A de www.ietf.org</figcaption>
                    </figure>
                    <p>Le DNS est principalement utilisé pour trouver l'adresse IP qui correspond à un nom donné. Cependant, il est parfois utile d'obtenir le nom qui correspond à une adresse IP. Cela est fait en utilisant le <span class="html">RR PTR (pointeur)</span>. La partie <span class="html">RData</span> d'un <span class="em">RR PTR</span> contient le nom tandis que la partie <span class="em">Name</span> du <span class="em">RR</span> contient l'adresse IP encodée dans le domaine <span class="em">in-addr.arpa</span>. Les adresses IPv4 sont encodées dans <span class="em">in-addr.arpa</span> en inversant les quatre chiffres qui composent la représentation décimale pointée de l'adresse. Par exemple, considérons l'adresse IPv4 <span class="em">192.0.2.11</span>. Le nom d'hôte associé à cette adresse peut être trouvé en demandant le <span class="em">RR PTR</span> qui correspond à <span class="em">11.2.0.192.in-addr.arpa</span>. Une solution similaire est utilisée pour prendre en charge les adresses IPv6, voir RFC 3596.</p>
                    <hr>
                    <p>Un point important à noter concernant le système de noms de domaine est son extensibilité.</p>
                    <h4>3.4.2 Courrier électronique :</h4>
                    <p>Le courrier életronique, ou e-mail, est une application très populaire dans les réseaux infomatiques tels que l'Internet. L'e-mail est apparu au début des années 197° et permet aux utilisateurs d"échanger des messages basés sur du texte. Initialement, il était principalement utilisé pour échanger des messahes courts, mais au fil des ans son utilisation s'est développée. Il est maintenant utilisé non seulement pour échanger des petits messages, mais aussi des messages longs qui peuvent être composés de plusieurs parties comme nous le verrons plus tard.</p>
                    <p>Avant d'examiner les détails de l'e-mail Internet, considérons un scénario simple illustré dans la figure ci-dessous, où Alice envoie un e-mail à Bob. Alice prépare son e-mail en utilisant un <span class="html">client e-mail</span> et l'envoie à son <span class="html">serveur e-mail</span>. Le serveur e-mail d'Alice extrait l'adresse de Bob de l'e-mail et délivre le message au serveur de Bob. Bon récupère le message d'Alice sur son serveur et le lit en utilisant son client e-mail préféré ou via son interface webmail.</p>
                    <figure>
                        <img src="../images/architecture_simplifiee_email_internet.PNG" alt="">
                        <figcaption>Figure 3.12 : Architecture simplifiée de l'e-mail Internet</figcaption>
                    </figure>
                    <p>Le système de messagerie électronique que nous considérons dans ce livre est composé de quatre éléments :</p>
                    <ul>
                        <li>
                            <p>un format de message, qui définit comment les messages électroniques valides sont encodés</p>
                        </li>
                        <li>
                            <p>des protocoles, qui permettent aux hôtes et serveurs d'échanger des messages électroniques</p>
                        </li>
                        <li>
                            <p>des logiciels clients, qui permettent aux utilisateurs de créer et lire facilement des messages électroniques</p>
                        </li>
                        <li>
                            <p>des logiciels, qui permettent aux serveurs déchanger efficacement des messages électroniques</p>
                        </li>
                    </ul>
                    <p>Nous allons d'abord discuter du format des messages électriniques, suivi des protocoles utilisés sur l'Internet actuel pour échanger et récupérer les e-mails. D'autres systèmes de messagerie électronique ont été développés dans le passé [Bush1993] [Genilloud1990] [GC2000], mais aujourd'hui la plupart des solutions de messagerie électronique ont migré vers l'e-mail sur Internet. Des informations sur les logiciels utilisés pour composer et livrer des e-mails peuvent être trouvées sur Wikipédia, entre autres, pour les clients de messagerie et les serveurs de messagerie. Des informations plus détaillées sur l'ensemble de l'architecture de messagerie Internet peuvent être toruvées dans la RFC 5598.</p>
                    <p>Les messages éctroniques, comme le courrier postal, sont composés de deux parties :</p>
                    <ul>
                        <li>
                            <p>l'<span class="html">en-teête</span> qui joue le même rôle que l'en-tête d'une lettre dans le courrier régulier. Il contient des métadonnées sur le message.</p>
                        </li>
                        <li>
                            <p>le <span class="html">corps</span> qui contient le message lui-même.</p>
                        </li>
                    </ul>
                    <p>Les messages éclectroniques sont entièrement composés de lignes de caractères ASCII. Chaque ligne peut contenir jusqu'à 998 caractères et est terminée par les caractères de contrôle <span class="em">CR</span> et <span class="em">LF</span> RFC 5322. Les lignes qui composent l'en-tête apparaissent avant le corps du message. Une ligne vide, contenant uniquement les caractères <span class="em">CR</span> et <span class="em">LF</span>, marque la fin de l'en-tête. Cela est illustré dans la figure ci-dessous.</p>
                    <figure>
                        <img src="../images/structure_messages_email.PNG" alt="">
                        <figcaption>Figure 3.13 : La structure des messages électroniques</figcaption>
                    </figure>
                    <p>L'en-tête d'un e-mail contient plusieurs lignes qui commencent toutes par mot-clé suivi d'un deux-points et d'informations supplémentaires. Le format des messages électroniques et les différents types de lignes d'en-tête sont définis dans la norme RFC 5322. Deux de ces lignes d'en-tête sont obligatoires et doivent apparaître dans tous les messages électroniques :</p>
                    <ul>
                        <li>
                            <p><span class="html">L'adresse de l'expéditeur</span> : Cette ligne d'en-tête commence par <span class="html">From :</span>. Elle contient le nom (optionnel) de lexpéditeur suivi de son adresse électronique entre chevrons. Les adresses adresses électroniques sont toujours composées d'un nom d'utilisateur suivi du signe <span class="html">@</span> et d'un nom de domaine.</p>
                        </li>
                        <li>
                            <p><span class="html">La date</span> : Cette ligne d'en-tête commence par <span class="html">Date :</span>. La norme RFC 5322 définit précisément le format utilisé pour encoder une date.</p>
                        </li>
                    </ul>
                    <p>D'autres lignes d'en-tête apparaissent dans la plupart des messages électroniques. La ligne d'en-tête "<span class="html">Subject :</span>" permet à l'expéditeur d'indiquer le sujet traité dans l'e-mail. Trois types de lignes d'en-tête peuvent être utilisés pour spécifier les destinataires d'un message :</p>
                    <ul>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">To :</span>" contient les adresses électroniques des desyonataires principaix du message. Il peut être surprenant que la ligne d'en-tête "<span class="em">To :</span>" ne soit pas obligatoire dans un message électronique. Bien que la plupart des messages électroniques contiennent cette ligne d'en-tête, un e-mail qui ne contient pas de ligne d'en-tête "<span class="em">To :</span>" et qui utilise plutôt la ligne d'en-tête "<span class="html">bcc :</span>" pour spécifier le destinataire est également valide. Plusieurs adresses peuvent être séparées par des virgules.</p>
                        </li>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">cc :</span>" est utilisée par l'expéditeur pour fournir une liste d'adresses électroniques qui doivent recevoir une copie carbone du message. Plusieurs adresses peuvent être listées dans cette ligne d'en-tête, séparées par des virgules. Tous les destinataires du message électronique reçoivent les lignes d'en-tête "<span class="em">To :</span>" et "<span class="em">cc :</span>".</p>
                        </li>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">bcc :</span>" est utilisée par l'expéditeur pour fournit une liste d'adresses e-mail séparées par des virgules qui doivent recevoir une copie carbone invisible du message. La ligne d'en-tête "<span class="em">bcc :</span>" n'est pas livrée aux destinataires du message électronique.</p>
                        </li>
                    </ul>
                    <p>Voici ci-dessous un simple message électronique contenant les en-têtes <span class="html">From:</span>, <span class="html">To:</span>, <span class="html">Subject:</span> et <span class="html">Date:</span>, ainsi que lignes de corps de message.</p>
<pre class="taille60"><code lang="en">From: Bob Smith <Bob@machine.example>
To: Alice Doe <alice@example.net>, Alice Smith <Alice@machine.example> Subject: Hello
Date: Mon, 8 Mar 2010 19:55:06 -0600

This is the "Hello world" of email messages.
This is the second line of the body</code></pre>
                    <p>Notez la ligne vide après l'en-tête "<span class="html">Date :</span>"; cette ligne vide ne contient que les caractères CR et LF et marque la limite entre l'en-tête et le corps du message.</p>
                    <p>Plusieurs autres en-têtes facultatifs sont définis dans la RFC 5322 et ailleurs. La liste de toutes les lignes d'en-tête  de courrier électronique standard peut être trouvée à l'adresse suivante :<a href="http://www.iana.org/assignments/message-headers/message-header-index.html" target="_blank">http://www.iana.org/assignments/message-headers/message-header-index.html</a>. En outre, de nombreux clients de messagerie électronique et serveurs définissent leurs propres en-têtes commençant par <span class="html">X-</span>. Plusieurs des en-têtes facultatifs définis dans la RFC 5322 méritent d'être discutés ici :</p>
                    <ul>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">Message-Id</span>" est utilisée pour associer un identifiant "unique" à chaque e-mail. Les identifiants d'e-mail sont généralement structurés comme <span class="em">string@domain</span> où <span class="em">string</span> est une chaîne de caractères unique ou un numéro de séquence choisi par l'expéditeur de l'e-mail et <span class="em">domain</span> est le nom de domaine de l'expéditeur. Étant donné que les noms de domaines sont uniques, un hôte peut générer des identifiants de message globalement uniques en concaténant un identifiant loclament unique avec son nom de domaine.</p>
                        </li>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">In-reply-to :</span>" est utilisée lorsqu'un message a été créé en réponse à un message précédent. Dans ce cas, la fin de la ligne "<span class="em">In-reply-to :</span>" contient lidentifiant du message original.</p>
                        </li>
                        <li>
                            <p>La ligne d'en-tête "<span class="html">Received :</span>" est utilisée lorsqu'un message électronique est traité par plusieurs serveurs avant d'atteindre sa destination. Chaque serveur de messagerie intermédiaire ajoute une ligne d'en-tête "<span class="em">Received :</span>" . Ces lignes d'en-tête sont utiles pour déboguer les problèmes de distribution des messages électronisques.</p>
                        </li>
                    </ul>
                    <p>La figure ci-dessous montre les lignes d'en-tête d'un message électronique. Le message a été envoyé depuis un hôte nommé wira.firstpr.com.au et a été reçu par smtp3.sgsi.ucl.ac.be. Les lignes "<span class="em">Received :</span>" ont été enveloppées pour faciliter la lecture.</p>
                    <figure>
                        <img src="../images/received_message-id_email_message.PNG" alt="">
                    </figure>
                    
                </article>
            <!-- fin de section -->
            </section>
        </main>
    </body>
</html>