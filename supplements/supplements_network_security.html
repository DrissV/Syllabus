<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Network Security - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>

        <div id="menu">
            <nav role="navigation" aria-label="Menu secondaire">
                <ol>
                    <li><a href="supplements_ITSCM.html">Retour au sommaire</a></li>
                    <li><a href="#installation">Installation</a></li>
                    <li><a href="#modele_OSI">Modèle OSI</a></li>
                    <li><a href="#protocoles_TCP_IP">Protocoles TCP/IP</a></li>
                    <li><a href="#architecture_normes_protocoles">Architecture, normes (standards) et protocoles</a></li>
                    <li><a href="#exercices_analyse_paquets_trames_L2_L3">Exercices : Analyse de paquets et trames - Layer 2 &amp; Layer 3</a></li>
                    <li><a href="#TCP">TCP</a></li>
                    <li><a href="#exercices_network_security">Exercices de Network Security</a></li>
                    <li><a href="#labo1">Labo 1 : construction d'un petit réseau</a></li>
                    <li><a href="#labo2">Labo 2 : construction et sécurisation d'un réseau de taille moyenne</a></li>
                </ol>
            </nav>
            
            <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
            <aside id="aside" role="complementary">
                <p>Liens utiles :</p>
                <ul>
                    <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    <li><a href="../files/NS_cheat_sheets/cisco-ios-versions.pdf" target="_blank">Cisco IOS versions (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/03_Core_Network_Design_v2.pdf" target="_blank">Core Network Design (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/03_Introduction_to_OSPF_v2.pdf" target="_blank">Introduction to OSPF (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/ospf.pdf" target="_blank">OSPF (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/ipv6.pdf" target="_blank">IPv6 (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/common-ports.pdf" target="_blank">Common ports (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/first-hop-redundancy.pdf" target="_blank">First hop redundancy (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/ip-access-lists.pdf" target="_blank">IP access lists (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/physical-terminations.pdf" target="_blank">Physical terminations (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/spanning-tree.pdf" target="_blank">Spanning-tree (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/netmasks.pdf" target="_blank">Netmasks (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/subnetting.pdf" target="_blank">Subnetting (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/vlans.pdf" target="_blank">VLANs (en PDF)</a></li>
                    <li><a href="../files/NS_cheat_sheets/layer-3_exercises.pdf" target="_blank">Layer 3 exercises (en PDF)</a></li>
                </ul>
            </aside>
        </div>
        
        <main id="container" role="main" tabindex="-1">
            <section id="mainSection">
                <article>
                    <h1>Network Security :</h1>
                    <p>Les objectifs du cours sont :</p>
                    <ul>
                        <li>
                            <p>Disposer d'une première approche des concepts techniques pour comprendre la sécurité des réseaux.</p>
                        </li>
                        <li>
                            <p>Comprendre quels sont les mécanismes qui permettent de sécuriser un réseau (garantir la fiabilité et la confidentialité des données grâce à différentes solutions sécurisantes).</p>
                        </li>
                        <li>
                            <p>Pouvoir évaluer les risques internes et externes liés à l'utilisation des réseaux informatiques.</p>
                        </li>
                    </ul>
                    <p>La structure du cours est :</p>
                    <ol>
                        <li>
                            <p>Théorie : comprendre l'architecture des réseaux (architectures, normes et protocoles) et comprendre les attaques réseau.</p>
                        </li>
                        <li>
                            <p>Pratique (Labo) : mise en place et sécurisation des réseaux.</p>
                        </li>
                    </ol>
                    <p>Pour l'examen, l'évaluation se compose de 40% de théorie QCM, 20% pour les trois laboratoires et 40% d'oral.</p>
                </article>
                <article>
                    <h2 id="installation">Installation :</h2>
                    <p>Pour ce cours, il faut installer <a href="https://www.gns3.com/" target="_blank">GNS3</a>, <a href="https://putty.org/index.html" target="_blank">PuTTY</a> et <a href="https://www.wireshark.org/" target="_blank">Wireshark</a>.</p>
                    <p>Pour mettre à jour PowerShell 5 vers PowerShell 7 sous Windows :</p>
                    <ol>
                        <li>
                            <p>Ouvrez PowerShell 5 en mode administrateur.</p>
                        </li>
                        <li>
                            <p>Forcez l'utilisation de TLS 1.2 (nécessaire pour télécharger depuis GitHub) :</p>
<pre><code>[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12</code></pre>
                        </li>
                        <li>
                            <p>Téléchargez l'installateur MSI de PowerShell 7 :</p>
<pre><code>$msi = "https://github.com/PowerShell/PowerShell/releases/latest/download/PowerShell-7.4.5-win-x64.msi"
Invoke-WebRequest $msi -OutFile "$env:TEMP\pwsh.msi"</code></pre>
                        </li>
                        <li>
                            <p>Installez PowerShell 7 silencieusement :</p>
<pre><code>msiexec /i "$env:TEMP\pwsh.msi" /quiet /norestart</code></pre>
                        </li>
                        <li>
                            <p>Lancez PowerShell 7 :</p>
<pre><code>pwsh</code></pre>
                        </li>
                        <li>
                            <p>Vérifiez la version :</p>
<pre><code>pwsh --version</code></pre>
                        </li>
                    </ol>
                    <p>Pour installer GNS3 correctement sur Windows, il y a deux façons de le faire :</p>
                    <ul>
                        <li>
                            <p>Téléchargez et installez <a href="https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion" target="_blank">VMware Workstation</a> ou <a href="https://www.virtualbox.org/" target="_blank">VirtualBox</a>.</p>
                        </li>
                        <li>
                            <p>Installez <a href="https://www.gns3.com/software/download-vm" target="_blank">GNS3 VM</a> et prenez la version de VMware même si vous utilisez VirtualBox.</p>
                        </li>
                        <li>
                            <p>Décompressez l'archive ZIP et lancez le fichier contenu dans le dossier dézippé dans VirtualBox ou VMWare.</p>
                            <p>Dans VirtualBox ou VMWare, sélectionne la "GNS3 VM" et va dans "Configuration &#8594; Réseau" pour cocher "Activer la carte réseau" en mode d'accès réseau NAT.</p>
                            <p>On peut ajouter une deuxième carte réseau, optionnelle mais recommandée avec l'Adapter 2 en mode "Host-only Adapter". Cela améliore la communication avec l'hôte.</p>
                            <p>On doit aussi mettre minimum 4096 MB de mémoire et minimum 2 processeurs.</p>
                            <p>Vous pouvez essayer de lancer la VM pour vérifier que tout fonctionne.</p>
                            <img src="../images/VT-x_error.jpg" alt="">
                            <p>Si vous rencontrez cette erreur lors du lancement de votre machine virtuelle, ça signifie que Hyper-V monopolise la virtualisation et donc GNS3 ne peut plus l'utiliser. Pour désactiver Hyper-V sous Windows, on peut taper la commande suivante dans un terminal en mode administrateur et redémarrer l'ordinateur :</p>
    <pre><code>bcdedit /set hypervisorlaunchtype off</code></pre>
                            <p>Pour vérifier si Hyper-V tourne ou pas, toujours en mode administrateur, on a la commande :</p>
    <pre><code>systeminfo | find "Hyper-V"</code></pre>
                            <p>Si vous voulez réactiver Hyper-V sous Windows, toujours en mode administrateur et redémarrer après avoir fait la prochaine commande :</p>
    <pre><code>bcdedit /set hypervisorlaunchtype auto</code></pre>
                            <p>Hyper-V "monopolise" la virtualisation parce qu'il remplace complètement le gestionnaire de virtualisation matériel de Windows. C'est un hyperviseur de type 1, exactement comme VMWare ESXi ou Proxmox.</p>
                            <p>C'est-à-dire que, quand Hyper-V est activé, Windows ne tourne plus directement sur le matériel, mais Hyper-V démarre en premier, Windows devient une VM spéciale appelée "partition parente" et Hyper-V obtient 100% du contrôle du CPU, de la RAM et surtout de Intel VT-x / AMD-V.</p>
                            <p>Donc, les autres hyperviseurs n'y ont plus accès car les instructions de virtualisation matérielle (VT-x / VT-d / AMD-V) ne peuvent être utilisées que par un seul hyperviseur à la fois.</p>
                        </li>
                        <li>
                            <p>Installez <a href="https://gns3.com/software/download" target="_blank">GNS3</a>.</p>
                        </li>
                        <li>
                            <p>Dans l'onglet "Edit &gt; Preferences &gt; GNS3 VM", cochez "Enable the GNS3 VM", sélectionnez "VirtualBox" dans "Virtualization engine" et sélectionnez la VM dans "VM name" dans "Settings".</p>
                        </li>
                        <li>
                            <p>Installez les <a href="https://www.gns3.com/marketplace/appliances/iou-l2" target="_blank">images IOU Cisco L2</a> et les <a href="https://www.gns3.com/marketplace/appliances/cisco-iou-l3" target="_blank">images IOU Cisco L3</a>.</p>
                            <p>Ou encore installez un <a href="https://github.com/hegdepavankumar/Cisco-Images-for-GNS3-and-EVE-NG?tab=readme-ov-file" target="_blank">pack d'images IOU sur GitHub</a>.</p>
                            <p>Ou encore via le <a href="https://drive.labhub.eu.org/0:/addons/iol/bin/" target="_blank">LabHub</a>.</p>
                        </li>
                    </ul>
                    <p>Pour utiliser Cisco IOU sous Windows, il faut avoir la GNS3 VM car IOU ne tourne pas directement sous Windows.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p><span class="em">scp</span> est un outil OpenSSH (Secure Copy Protocol), historiquement disponible sous Linux / Mac OS. Windows ne l'a pas intégré avant très récemment.</p>
                    </div>
                    <p>Voici le fichier `<span class="em">CiscoIOUKeygen3f.py</span>` qu'il faudra copier avec <span class="em">scp</span> :</p>
<pre><code>#!/usr/bin/python3
print("*********************************************************************")
print("Cisco IOU License Generator - Kal 2011, python port of 2006 C version")
import os
import socket
import hashlib
import struct
# get the host id and host name to calculate the hostkey
hostid = os.popen("hostid").read().strip()
hostname = socket.gethostname()
ioukey = int(hostid,16)
for x in hostname:
 ioukey = ioukey + ord(x)
print("hostid = " + hostid +", hostname = "+ hostname + ", ioukey = " + hex(ioukey)[2:])
# create the license using md5sum
iouPad1 = b'\x4B\x58\x21\x81\x56\x7B\x0D\xF3\x21\x43\x9B\x7E\xAC\x1D\xE6\x8A'
iouPad2 = b'\x80' + 39 * b'\0'
md5input = iouPad1 + iouPad2 + struct.pack('!i', ioukey) + iouPad1
iouLicense = hashlib.md5(md5input).hexdigest()[:16]

print("\nAdd the following text to ~/.iourc :")
print("[license]\n" + hostname + " = " + iouLicense + ";\n")
with open("iourc.txt", "wt") as out_file:
   out_file.write("[license]\n" + hostname + " = " + iouLicense + ";\n")
print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAlready copy to the file iourc.txt\n ")

print("You can disable the phone home feature with something like:")
print(" echo '127.0.0.127 xml.cisco.com' &gt;&gt; /etc/hosts\n")</code></pre>
                    <p>Ce script calcule une licence IOU ("Cisco IOU License"). En résumé, le script calcule une clé de licence à partir de l'<span class="em">hostid</span> et du <span class="em">hostname</span> de la machine, en combinant ces valeurs avec des constantes (pads) puis en prenant les 16 premiers caractères du MD5 du bloc construit. Il affiche la ligne de licence à ajouter dans <span class="em">~/.iourc</span> et la copie aussi dans <span class="em">iourc.txt</span>. Enfin, il propose une méthode pour bloquer le "phone home" en modifiant <span class="em">/etc/hosts</span>.</p>
                    <p>Voici les prochaines étapes à réaliser :</p>
                    <ol>
                        <li>
                            <p>Dans PowerShell 7, copiez ce fichier depuis Windows vers la GNS3 VM avec <span class="em">scp</span> :</p>
<pre><code> scp "C:\Users\driss\Desktop\Network Security\ImagesIOU\CiscoIOUKeygen3f.py" gns3@192.168.56.102:/home/gns3/</code></pre>
                            <div class="important">
                                <img src="../images/important.png" alt="Important" class="float_left">
                                <p>Il faudra penser à modifier dans la commande précédente le chemin vers le fichier Python et l'adresse IP de la GNS3 VM.</p>
                                <p>Le mot de passe par défaut de la GNS3 est <span class="em">gns3</span>.</p>
                            </div>
                        </li>
                        <li>
                            <p>Connectez-vous à la GNS3 :</p>
<pre><code>ssh gns3@192.168.56.102</code></pre>
                        </li>
                        <li>
                            <p>Ouvrez le shell dans la GNS3 VM et allez dans le bon répertoire :</p>
<pre><code>cd /home/gns3</code></pre>
                        </li>
                        <li>
                            <p>Lancez le script Python :</p>
<pre><code>python3 CiscoIOUKeygen3f.py</code></pre>
                        </li>
                        <li>
                            <p>Éditez le fichier `<span class="em">.iourc</span>` :</p>
<pre><code>nano /home/gns3/.iourc</code></pre>
                            <p>Voici le contenu à mettre dans le fichier :</p>
<pre><code>[license]
GNS3 VM = 73677fd3b0a13ad0;</code></pre>
                            <p>Remplacez bien la clé par celle générée sur ta VM.</p>
                            <p>Pour sauvegarder dans Nano, on doit faire <span class="em">CTRL + O</span> &#8594; Entrée et <span class="em">CTRL +X</span> pour quitter.</p>
                        </li>
                        <li>
                            <p>Dans l'onglet "Edit &gt; Preferences &gt; IOS on UNIX", copiez-y la licence IOU.</p>
                        </li>
                        <li>
                            <p>Dans mon répertoire `<span class="em">C:\Users\driss\Desktop\Network Security\ImagesIOU</span>`, j'ai mis toutes les images <span class="em">.bin</span> téléchargées. Voici ma liste de fichiers <span class="em">.bin</span> :</p>
<pre><code>i86bi-linux-l2-adventerprisek9-15.1a.bin
i86bi-linux-l2-adventerprisek9-15.2d.bin
i86bi-linux-l2-adventerprisek9-15.6.0.9S.bin
i86bi-linux-l3-adventerprisek9-15.4.1T.bin
i86bi-linux-l3-adventerprisek9-15.4.2T4.bin</code></pre>
                            <p>Pour l'instant, ce sont des images IOU L2 (switch) et des images IOU L3 (routeur).</p>
                        </li>
                        <li>
                            <p>Dans l'onglet "Edit &gt; Preferences &gt; IOS on UNIX &gt; IOU Devices", choisissez "New".</p>
                            <p>Choisissez "Run this IOU device on the GNS3 VM".</p>
                            <p>On "browse" le fichier <span class="em">.bin</span> de l'image L2 ou L3 dans la "New Image" avec un nom pour chaque image, comme par exemple "Cisco L2 15.1a".</p>
                            <p>N'oublie pas d'appliquer tous les changements.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="modele_OSI">Modèle OSI - 7 couches :</h2>
                    <p>Le modèle OSI (Open Systems Interconnection) est un cadre de référence conceptuel qui permet de comprendre et de normaliser les communications entre différents systèmes informatiques.</p>
                    <p>Ce modèle est organisé en sept couches, chacune ayant un rôle précis dans le processus de transmission et de réception des données sur un réseau.</p>
                    <p>Chaque couche fournit un ensemble de fonctions à la couche supérieure et, à son tour, s'appuie sur les fonctions fournies par la couche inférieure.</p>
                    <p>Bien que les messages ne puissent passer verticalement à travers la pile d'une couche à l'autre, d'un point de vue logique, chaque couche communique directement avec sa couche homologue sur d'autres noeuds.</p>
                    <p>Les sept couches du modèle OSI sont :</p>
                    <ol>
                        <li>
                            <p>Physique : transmission de bits sur le matériel physique.</p>
                        </li>
                        <li>
                            <p>Liaison de données : encadrement/encapsulation des unités d'information et contrôle des erreurs.</p>
                        </li>
                        <li>
                            <p>Réseau : livraison de paquets, y compris le rouage.</p>
                        </li>
                        <li>
                            <p>Transport : fourniture d'une livraison fiable ou non fiable de bout en bout.</p>
                        </li>
                        <li>
                            <p>Session : établissement et maintien de sessions.</p>
                        </li>
                        <li>
                            <p>Présentation : formatage des données et cryptage.</p>
                        </li>
                        <li>
                            <p>Application : les applications réseau telles que l'émulation de terminal (Telnet) et le transfert de fichiers (FTP), HTTP.</p>
                        </li>
                    </ol>
                    <h3>OSI - Couche physique (couche 1) :</h3>
                    <p><span class="em">Rôle</span> : La couche physique est responsable de la transmission réelle des bits sur le réseau via des câbles, signaux radio, fibre optique, etc.</p>
                    <p><span class="em">Processus</span> : Les trames sont converties en signaux électriques, optiques, ou radiofréquences, qui sont ensuite transmis sur le support physique. La couche physique assure la transmission des bits entre les deux dispositifs connectés.</p>
                    <p><span class="em">Exemples</span> : Ethernet, câbles réseau, fibre optique.</p>
                    <h3>OSI - Couche liaison de données (couche 2) :</h3>
                    <p><span class="em">Rôle</span> : Cette couche assure la communication directe entre deux dispositifs sur le même réseau local.</p>
                    <p><span class="em">Processus</span> : Les paquets sont encapsulés dans des <span class="em">trames</span> et reçoivent une adresse MAC source et une adresse MAC de destination. Les trames sont ensuite envoyées sur le réseau physique, en passant par des switchs et autres dispositifs de réseau.</p>
                    <h3>OSI - Couche réseau (couche 3) :</h3>
                    <p><span class="em">Rôle</span> : La couche réseau détermine le meilleur chemin pour acheminer les paquets de données à travers le réseau. Elle gère le routage et l'adressage.</p>
                    <p><span class="em">Processus</span> : Chaque segment est encapsulé dans un paquet avec une adresse IP source et une adresse IP de destination. Cette couche utilise des routeurs pour diriger chaque paquet vers sa destination finale.</p>
                    <h3>OSI - Couche transport (couche 4) :</h3>
                    <p><span class="em">Rôle</span> : La couche transport assure la livraison fiable des données en gérant la segmentation et le réassemblage.</p>
                    <p><span class="em">Processus</span> : Les données sont segmentées en plus petits morceaux pour faciliter leur transmission. La couche transporte les segments et assure que chaque segment arrive bien au récepteur. Le protocole TCP (Transmission Control Protocol) assure une livraison fiable (vérification de l'ordre des segments et des erreurs), tandis que UDP (User Datagram Protocol) offre une livraison plus rapide mais moins fiable.</p>
                    <h3>OSI - Couche session (couche 5) :</h3>
                    <p><span class="em">Rôle</span> : La couche session gère et synchronise les dialogues entre les applications des deux ordinateurs.</p>
                    <p><span class="em">Processus</span> : Une "session" ou connexion est établie entre les ordinateurs émetteur et récepteur pour organiser et maintenir la communication. Cette couche assure que les données (application) sont envoyées dans le bon ordre.</p>
                    <h3>OSI - Couche présentation (couche 6) :</h3>
                    <p><span class="em">Rôle</span> : Cette couche traduit les données entre le format de l'application et le format utilisé pour la transmission. Elle peut également chiffrer et compresser les données.</p>
                    <p><span class="em">Processus</span> : Les données sont converties (par exemple en ASCII, si nécessaire) et peuvent être compressées ou chiffrées. Ensuite, elles sont transmises à la couche session.</p>
                    <h3>OSI - Couche application (couche 7) :</h3>
                    <p><span class="em">Rôle</span> : C'est la couche la plus proche de l'utilisateur. Elle permet aux applications (navigateurs, logiciels de messagerie, etc.) de communiquer avec le réseau.</p>
                    <p><span class="em">Processus</span> : Les données sont converties (par exemple en ASCII, si nécessaire) et peuvent être compressées ou chiffrées à la couche session.</p>
                    <h3>OSI - Communication entre couches :</h3>
                    <img src="../images/modele_OSI.PNG" alt="">
                    <img src="../images/modele_OSI_2.PNG" alt="">
                    <h3>OSI - Encapsulation :</h3>
                    <img src="../images/encapsulation_modele_OSI.PNG" alt="">
                    <h3>Le modèle TCP/IP :</h3>
                    <p>Il est conçu pour être pratique et largement utilisé dans les réseaux actuels, notamment l'Internet.</p>
                    <p>Il est également connu sous le nom de "suite de protocoles Internet".</p>
                    <p>Il est composé de quatre couches :</p>
                    <ol>
                        <li>
                            <p>Accès réseau.</p>
                        </li>
                        <li>
                            <p>Internet.</p>
                        </li>
                        <li>
                            <p>Transport.</p>
                        </li>
                        <li>
                            <p>Application.</p>
                        </li>
                    </ol>
                    <h3>Correspondance entre OSI et TCP/IP :</h3>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Modèle OSI (7 couches)</th>
                                <th>Modèle TCP/IP (4 couches)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Application</td>
                                <td rowspan="3">Application</td>
                            </tr>
                            <tr>
                                <td>Présentation</td>
                            </tr>
                            <tr>
                                <td>Session</td>
                            </tr>
                            <tr>
                                <td>Transport</td>
                                <td>Transport</td>
                            </tr>
                            <tr>
                                <td>Réseau</td>
                                <td>Internet (Réseau)</td>
                            </tr>
                            <tr>
                                <td>Liaison de données</td>
                                <td rowspan="2">Accès réseau</td>
                            </tr>
                            <tr>
                                <td>Physique</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Conclusion :</h3>
                    <p>Le modèle OSI est une référence essentielle pour les réseaux.</p>
                    <p>Comprendre le modèle OSI aide à identifier et résourdre des problèmes réseau.</p>
                    <p>Bien que OSI ne soit pas directement utilisé, il reste un outil pédagogique clé.</p>
                    <p>OSI est un modèle théorique, tandis que TCP/IP est un modèle pratique.</p>
                    <p>TCP/IP regroupe certaines couches du modèle OSI pour plus de simplicité.</p>
                    <p>Les deux modèles sont complémentaires et restent des outils essentiels pour comprendre et concevoir des réseaux.</p>
                </article>
                <article>
                    <h2 id="protocoles_TCP_IP">Protocoles TCP/IP :</h2>
                    <p>Les protocoles TCP/IP sont :</p>
                    <ul>
                        <li>
                            <p>Interfaces d'interconnexion (Couche OSI 2).</p>
                        </li>
                        <li>
                            <p>Les protocoles d'interconnexion (Couche OSI 3).</p>
                        </li>
                        <li>
                            <p>Les protocoles de transport (Couche OSI 4).</p>
                        </li>
                        <li>
                            <p>Structure d'application TCP/IP (Couche 4 TCP/IP).</p>
                        </li>
                        <li>
                            <p>Analyse des paquets TCP/IP.</p>
                        </li>
                    </ul>
                    <p>Les interfaces d'interconnexion sont :</p>
                    <ul>
                        <li>
                            <p>Couche liaison de données.</p>
                        </li>
                        <li>
                            <p>Structure de la trame Ethernet.</p>
                        </li>
                        <li>
                            <p>Commutateur Ethernet.</p>
                        </li>
                    </ul>
                    <h3>Couche liaison de données :</h3>
                    <p>Les objectifs et le rôle de la couche liaison de données sont :</p>
                    <ul>
                        <li>
                            <p>Diviser les données en trames.</p>
                        </li>
                        <li>
                            <p>Fournir une communication directe, fiable, et sécurisée entre deux dispositifs sur le même réseau.</p>
                        </li>
                        <li>
                            <p>Assurer une connexion sans erreur pour la transmission des trames.</p>
                        </li>
                    </ul>
                    <p>Les fonctionnalités principales sont :</p>
                    <ul>
                        <li>
                            <p><span class="em">Encapsulation en trames</span> : diviser les données en trames pour une gestion facile.</p>
                        </li>
                        <li>
                            <p><span class="em">Contrôle d'erreur</span> : détecter et corriger les erreurs de transmission.</p>
                        </li>
                        <li>
                            <p><span class="em">Contrôle de flux</span> : éviter la surcharge des dispositifs en régulant l'envoi de trames.</p>
                        </li>
                        <li>
                            <p><span class="em">Accès au média</span> : gère qui envoie les données à quel moment, afin d'éviter les collisions.</p>
                        </li>
                    </ul>
                    <p>La couche liaison de données est divisée en deux sous-couches :</p>
                    <ol>
                        <li>
                            <h4>Sous-couche de contrôle de liaison logique (LLC - Logical Link Control) :</h4>
                            <p>Les fonctions de la sous-couche LLC sont :</p>
                            <ul>
                                <li>
                                    <p>Diviser les données en trames.</p>
                                </li>
                                <li>
                                    <p>Fournir une communication directe, fiable, et sécurisée entre deux dispositifs sur le même réseau.</p>
                                </li>
                                <li>
                                    <p>Assurer une connexion sans erreur pour la transmission des trames.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Sous-couche de contrôle d'accès au média (MAC - Media Access Control) :</h4>
                            <p>Les fonctions de la sous-couche MAC sont :</p>
                            <ul>
                                <li>
                                    <p>Gère l'accès au média physique et identifie les dispositifs via leur adresse MAC.</p>
                                </li>
                                <li>
                                    <p>Gère les collisions sur les réseaux partagés.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h4>Adresse MAC :</h4>
                    <p>C'est l'identifiant unique pour chaque interface réseau.</p>
                    <p>Elle est formée de 48 bits, souvent représentée en hexadécimal (par exemple : 00-14-22-01-23-45).</p>
                    <p>Elle est utilisée par la sous-couche MAC pour identifier les dispositifs au sein d'un même réseau.</p>
                    <h4>Contrôle d'erreur et de flux :</h4>
                    <p>Le contrôle d'erreur utilise des techniques comme le CRC (Cyclic Redundancy Check) pour détecter les erreurs dans les trames.</p>
                    <p>Le contrôle de flux utilise des protocoles pour réguler le volume des données envoyées, assurant que le récepteur puisse traiter les trames sans surcharge.</p>
                    <h4>Introduction à Ethernet :</h4>
                    <p>Qu'est-ce qu'Ethernet ?</p>
                    <p>C'est une norme de communication pour les réseaux locaux (LAN).</p>
                    <p>Cela définit le format des trames utilisées pour transférer les données. Ça définit la manière dont les données sont encapsulées au niveau Layer 2 (Data Link).</p>
                    <p>La trame Ethernet est utilisée pour encapsuler les données et les transmettre sur le réseau local.</p>
                    <h5>Formats de trames Ethernet :</h5>
                    <p>La norme Ethernet définit trois formats principaux :</p>
                    <ul>
                        <li>
                            <p>Ethernet II (IEEE 802.3). Le plus courant dans les réseaux IP modernes.</p>
                        </li>
                        <li>
                            <p>IEEE 802.2 LLC.</p>
                        </li>
                        <li>
                            <p>IEEE 802.2 LLC SNAP.</p>
                        </li>
                    </ul>
                    <p class="em">Chaque format diffère surtout par l'interprétation du champ après les adresses MAC.</p>
                    <h5>Structure générale d'une trame Ethernet :</h5>
                    <p>La trame Ethernet est composée de :</p>
                    <ol>
                        <li>
                            <p>Préambule/(+SOF)(8 octets - non visible lors de capture - récupéré/enlevé par la couche 1).</p>
                        </li>
                        <li>
                            <p>Adresse destination (6 octets).</p>
                        </li>
                        <li>
                            <p>Adresse source (6 octets).</p>
                        </li>
                        <li>
                            <p>Type/Longueur (2 octets).</p>
                        </li>
                        <li>
                            <p>Données (46 à 1500 octets).</p>
                        </li>
                        <li>
                            <p>Contrôle d'erreur (4 octets - non visible lors de capture - récupéré/enlevé par la couche 1).</p>
                        </li>
                    </ol>
                    <img src="../images/trame_EthernetII.PNG" alt="">
                    <p>Avantages : simple et directement compatible avec IP, ARP, IPv6.</p>
                    <p>Utilisation : majoritaire aujourd'hui (&gt; 95% des trames observées en réseau).</p>
                    <h5>Exemples de trame Ethernet II :</h5>
                    <p>Les exemples de types de trame les plus rencontrés sont :</p>
                    <ul>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x0800</span> &#8594; IPv4.</p>
                        </li>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x0806</span> &#8594; ARP.</p>
                        </li>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x86DD</span> &#8594; IPv6.</p>
                        </li>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x8100</span> &#8594; IEEE 802.1Q VLAN tagging.</p>
                        </li>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x88CC</span> &#8594; LLDP (Link Layer Discovery Protocol).</p>
                        </li>
                        <li>
                            <p>Champ <span class="em">EtherType = 0x8847</span> &#8594; MPLS (Unicast).</p>
                        </li>
                    </ul>
                    <p><span class="em">Remarque</span> : Si le champ <span class="em">type/longueur &gt; 1500</span>, le champ est <span class="em">EtherType</span> sinon le champ est <span class="em">Longueur</span>.</p>
                    <h4>Le format IEEE 802.2 LLC (Logical Link Control) :</h4>
                    <p>Structure :</p>
                    <ul>
                        <li>
                            <p>Destination MAC (6 octets).</p>
                        </li>
                        <li>
                            <p>Source MAC (6 octets).</p>
                        </li>
                        <li>
                            <p>Longueur (2 octets) &#8594;  indique la taille du payload (&lt; 1500).</p>
                        </li>
                        <li>
                            <p><span class="em">LLC Header</span> :</p>
                            <ul>
                                <li>
                                    <p>DSAP (1 octet).</p>
                                </li>
                                <li>
                                    <p>SSAP (1 octet).</p>
                                </li>
                                <li>
                                    <p>Control Field (1 octet).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Payload (data).</p>
                        </li>
                    </ul>
                    <p><span class="em">DSAP et SSAP identifient le protocole de couche supérieure.</span> Exemple :</p>
                    <ul>
                        <li>
                            <p>0x06 : IP.</p>
                        </li>
                        <li>
                            <p>0xE0 : NetBIOS.</p>
                        </li>
                        <li>
                            <p>Limites : espace d'adressage restreint &#8594; apparition du SNAP.</p>
                        </li>
                    </ul>
                    <img src="../images/trame_IEEE_LLC.PNG" alt="">
                    <p>Utilisation : Token Ring, FDDI, NetBIOS, anciens LAN, encapsulation Wi-Fi (en interne).</p>
                    <h4>Le format IEEE 802.2 LLC SNAP :</h4>
                    <p>C'est l'extension du LLC qui permet d'utiliser un <span class="em">Org Code + EtherType</span> après le LLC.</p>
                    <p>Structure :</p>
                    <ul>
                        <li>
                            <p>Destination MAC (6 octets).</p>
                        </li>
                        <li>
                            <p>Source MAC (6 octets).</p>
                        </li>
                        <li>
                            <p>Longueur (2 octets) &#8594; indique la taille du payload (&lt; 1500).</p>
                        </li>
                        <li>
                            <p>LLC Header (3 octets) &#8594; DSAP = 0xAA, SSAP = 0xAA, Control = 0x03.</p>
                        </li>
                        <li>
                            <p>SNAP Header (5 octets) :</p>
                            <ul>
                                <li>
                                    <p>OUI - Organisation Unique Identifier (3 octets).</p>
                                </li>
                                <li>
                                    <p>EtherType - Source Service Access Point (2 octets).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Payload (data) + FCS (Frame Check Sequence).</p>
                        </li>
                    </ul>
                    <img src="../images/trame_IEEE_SNAP.PNG" alt="">
                    <p>Avantages : compatible avec les EtherType d'Ethernet II &#8594; (P_ID = Protocol ID = EtherType).</p>
                    <p>Utilisation : IP sur Wi-Fi, PVST+, 802.1D, AppleTalk, certains VLAN.</p>
                    <h4>Commutateurs Ethernet (switching) - Introduction :</h4>
                    <p>C'est quoi la commutation ?</p>
                    <p>La commutation est la fonction clé du réseau de niveau 2.</p>
                    <p>Son rôle principal est d'acheminer les trames Ethernet au sein d'un LAN.</p>
                    <p>C'est basé sur les adresses MAC et les switchs Ethernet sont les appareils concernés.</p>
                    <div>
                        <img src="../images/commutateurs_Ethernet.PNG" alt="" class="float_right">
                        <ul>
                            <li>
                                <p>Performance.</p>
                            </li>
                            <li>
                                <p>Isolation des collisions.</p>
                            </li>
                            <li>
                                <p>Segmentation logique.</p>
                            </li>
                        </ul>
                    </div>
                    <h4>Fonctionnement général d'un switch :</h4>
                    <div>
                        <img src="../images/fonctionnement_general_switch.PNG" alt="" class="float_right">
                        <p>Le switch reçoit une trame à destination d'un PC.</p>
                        <p>Le switch lit l'<span class="em">adresse MAC de destination</span>.</p>
                        <p>Il recherche dans sa <span class="em">table CAM / MAC</span>.</p>
                        <p>Il y a <span class="em">trois actions possibles</span> :</p>
                        <ul>
                            <li>
                                <p><span class="em">Forward</span> &#8594; envoie sur un port spécifique.</p>
                            </li>
                            <li>
                                <p><span class="em">Flood</span> &#8594; si MAC inconnue, envoie sur tous les ports (sauf celui d'entrée).</p>
                            </li>
                            <li>
                                <p><span class="em">Filter</span> &#8594; si source = destination sur le même port.</p>
                            </li>
                        </ul>
                    </div>
                    <h4>La table MAC (CAM TABLE / TCAM TABLE) :</h4>
                    <div>
                        <img src="../images/table_MAC.PNG" alt="" class="float_right">
                        <p>C'est une structure interne qui associe <span class="em">adresse MAC &#8594; Port</span>.</p>
                        <p>C'est une construction automatique grâce à :</p>
                        <ul>
                            <li>
                                <p>Apprentissage des adresses MAC source.</p>
                            </li>
                            <li>
                                <p>Entrées dynamiques (expiration typique : 300 secondes).</p>
                            </li>
                        </ul>
                        <p>Ce sont des entrées statiques (configurées manuellement).</p>
                    </div>
                    <h4>VLANs et commutation :</h4>
                    <div>
                        <img src="../images/VLANS_commutation.PNG" alt="" class="float_right">
                        <p>Un LAN regroupe deux ou plusieurs équipements dans un réseau.</p>
                        <p>Un VLAN est un LAN Virtuel : un sous-groupe dans un LAN.</p>
                        <p>Les VLANs permettent aux administrateurs réseau de séparer facilement un réseau commuté unique en plusieurs groupes afin de répondre aux exigences fonctionnelles et de sécurité de leurs systèmes.</p>
                    </div>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Fonctionnalités</th>
                                <th>LAN</th>
                                <th>VLAN</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Latence</td>
                                <td>Grande</td>
                                <td>Faible</td>
                            </tr>
                            <tr>
                                <td>Network Segmentation</td>
                                <td>Ne permet pas</td>
                                <td>Permet la segmentation</td>
                            </tr>
                            <tr>
                                <td>Broadcast Traffic</td>
                                <td>Sujet à la congestion du trafic</td>
                                <td>Réduit la congestion</td>
                            </tr>
                            <tr>
                                <td>Management</td>
                                <td>Simple (1 seul réseau)</td>
                                <td>Avancé (multiples réseaux)</td>
                            </tr>
                            <tr>
                                <td>Isolation</td>
                                <td>Manque d'isolation</td>
                                <td>Isolation entre plusieurs VLAN</td>
                            </tr>
                            <tr>
                                <td>Sécurité</td>
                                <td>Basique (basé sur les mesures externes au LAN)</td>
                                <td>Offre un contrôle de sécurité granulaire</td>
                            </tr>
                            <tr>
                                <td>Flexibilité</td>
                                <td>Limitée à l'infrastructure physique</td>
                                <td>Aucune modification de l'infrastructure nécessaire</td>
                            </tr>
                            <tr>
                                <td>Allocation des ressources</td>
                                <td>Inefficace</td>
                                <td>Améliore l'efficacité des ressources et du réseau</td>
                            </tr>
                            <tr>
                                <td>Domaine de défaillance*</td>
                                <td>Simple</td>
                                <td>Multiple</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4>Types de VLANs : port-based VLAN et tagged VLAN :</h4>
                    <div>
                        <img src="../images/types_VLANs.PNG" alt="" class="float_right">
                        <p>Pour que plusieurs VLANs puissent communiquer entre eux, un routeur est nécessaire.</p>
                        <p>Les routeurs entre les VLANs filtrent le trafic de diffusion, renforcent la sécurité du réseau, effectuent la synthèse des adresses et atténuent la congestion du réseau.</p>
                        <p>Il existe deux types de VLANs :</p>
                        <ul>
                            <li>
                                <p>Les port-based VLANs (untagged).</p>
                            </li>
                            <li>
                                <p>Les tagged VLANs.</p>
                            </li>
                        </ul>
                    </div>
                    <h5>Port-based VLAN (untagged) :</h5>
                    <p>Les VLANs non balisés sont basés sur les ports physiques d'un switch (appelés ports d'accès).</p>
                    <p>Aucune information supplémentaire n'est ajoutée à la trame Ethernet. Au lieu de cela, chaque port du commutateur est défini comme appartenant à un VLAN spécifique.</p>
                    <p>Cette approche divise un seul commutateur physique en plusieurs commutateurs logiques.</p>
                    <p>Si un périphérique est connecté à un port dans un seul VLAN, alors le port doit être non balisé.</p>
                    <img src="../images/port_based_VLAN.PNG" alt="">
                    <h5>Tagged VLAN :</h5>
                    <div>
                        <img src="../images/tagged_VLAN.PNG" alt="" class="float_right">
                        <p>Les VLANs non balisés sont basés sur les ports physiques d'un switch (appelés ports d'accès).</p>
                        <p>Aucune information supplémentaire n'est ajoutée à la trame Ethernet. Au lieu de cela, chaque port du commutateur est défini comme appartenant à un VLAN spécifique.</p>
                        <p>Cette approche divise un seul commutateur physique en plusieurs commutateurs logiques.</p>
                        <p>Si un périphérique est connecté à un port dans un seul VLAN, alors le port doit être non balisé.</p>
                    </div>
                    <h4>Switch et VLAN tagging (le format de trame DOT1Q (802.1Q)) :</h4>
                    <p>En fonctionnement normal, le switch se contente de relayer la trame Ethernet telle quelle.</p>
                    <p>Mais, dans certains cas, le switch peut modifier le header de la trame notamment pour ajouter des champs 802.1Q (VLAN Tagging).</p>
                    <p>Bien entendu, chaque changement de l'en-tête nécessite le recalcul du champ FCS.</p>
                    <p>Pour marquer le VLAN, le switch modifie la trame pour y insérer le marquage 802.1Q.</p>
                    <img src="../images/trame_EthernetII_802.1Q.PNG" alt="">
                    <ul>
                        <li>
                            <p class="em">802.1Q Tag (4 octets) = TPID (2) + TCI (2)</p>
                        </li>
                        <li>
                            <p><span class="em">TPID</span> - Tag Protocol Identifier (16 bits) :</p>
                            <ul>
                                <li>
                                    <p>Valeur : <span class="em">0x8100</span>.</p>
                                </li>
                                <li>
                                    <p>Signifie que cette trame est une trame 802.1Q (tag VLAN).</p>
                                </li>
                                <li>
                                    <p>Remplace temporairement l'EtherType original, repoussé après le tag.</p>
                                </li>
                                <li>
                                    <p>Permet au switch de savoir que la trame contient un tag VLAN.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">TCI</span> - Tag Control Information (16 bits) :</p>
                            <ul>
                                <li>
                                    <p>TCI = Priority (3 bits) | DEI (1 bit) | VLAN ID (12 bits).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">PCP</span> : Priority Code Point (3 bits) :</p>
                            <ul>
                                <li>
                                    <p>Champ de priorité selon IEEE 802.1p (QoS layer 2).</p>
                                </li>
                                <li>
                                    <p>Valeur de 0 à 7.</p>
                                </li>
                                <li>
                                    <p>Permet le marquage de priorité sur le trafic (control, voice, video, best effort, etc.).</p>
                                </li>
                                <li>
                                    <p>Exemples :</p>
                                    <ul>
                                        <li>
                                            <p>7 = Network control.</p>
                                        </li>
                                        <li>
                                            <p>5 = Voice.</p>
                                        </li>
                                        <li>
                                            <p>0 = Best effort.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">DEI</span> - Drop Eligible Indicator (1 bit) :</p>
                            <ul>
                                <li>
                                    <p>Anciennement appelé CFI (Canonical Format Indicator).</p>
                                </li>
                                <li>
                                    <p>Permet d'indiquer qu'une trame peut être supprimé en cas de congestion.</p>
                                    <ul>
                                        <li>
                                            <p>0 = Non eligible.</p>
                                        </li>
                                        <li>
                                            <p>1 = Eligible for drop.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Utile dans les architectures utilisant la congestion management / QoS.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <div>
                        <img src="../images/VLAN_tagging.PNG" alt="" class="float_right">
                        <p>VLAN ID (12 bits) :</p>
                        <ul>
                            <li>
                                <p>Identifiant de VLAN sur 12 bits &#8594; 4096 valeurs théoriques.</p>
                            </li>
                            <li>
                                <p>VLAN valides : 1 à 4094.</p>
                            </li>
                            <li>
                                <p>VLAN 0 : utilisé pour QoS sans changement de VLAN.</p>
                            </li>
                            <li>
                                <p>VLAN 4095 : réservé.</p>
                            </li>
                            <li>
                                <p>La plupart du temps c'est ce champ qui nous intéresse.</p>
                            </li>
                            <li>
                                <p>Exemple :</p>
                                <ul>
                                    <li>
                                        <p>PCP = 3 &#8594; 011 (binaire).</p>
                                    </li>
                                    <li>
                                        <p>DEI = 0.</p>
                                    </li>
                                    <li>
                                        <p>VLAN ID = 0xA01 = 2561.</p>
                                    </li>
                                    <li>
                                        <p>EtherType = 0x800 (IPv4).</p>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <h4>Résumé : VLANs et switching :</h4>
                    <div>
                        <img src="../images/VLANs_switching.PNG" alt="" class="float_right">
                        <ul>
                            <li>
                                <p>VLAN = segmentation logique au niveau 2.</p>
                            </li>
                            <li>
                                <p>VLAN nécessite la modification de l'en-tête Ethernet.</p>
                            </li>
                            <li>
                                <p>Types de ports :</p>
                                <ul>
                                    <li>
                                        <p>Access : 1 VLAN.</p>
                                    </li>
                                    <li>
                                        <p>Trunk : plusieurs VLAN (802.1Q).</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>Le switching peut être :</p>
                                <ul>
                                    <li>
                                        <p>Inter-VLAN (nécessite le routage L3).</p>
                                    </li>
                                    <li>
                                        <p>Intra-VLAN (L2 pur).</p>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <h4>Introduction aux private VLANs (PVLANs) :</h4>
                    <p>Les objectifs des PVLANs sont :</p>
                    <ul>
                        <li>
                            <p>Renforcer l'isolation au sein d'un même VLAN.</p>
                        </li>
                        <li>
                            <p>Fonction avancée utilisée principalement dans les datacenters.</p>
                        </li>
                        <li>
                            <p>Permet de contrôler quelles machines peuvent communiquer entre elles.</p>
                        </li>
                        <li>
                            <p>Éviter la prolifération des VLANs (scalabilité).</p>
                        </li>
                    </ul>
                    <h5>Pourquoi les private VLANs ?</h5>
                    <p>Les problèmes dans un VLAN classique sont :</p>
                    <ul>
                        <li>
                            <p>Tous les hôtes peuvent se parler (risque de pivot/propagation).</p>
                        </li>
                        <li>
                            <p>Particulièrement dangereux pour :</p>
                            <ul>
                                <li>
                                    <p>Hébergeurs mutualisés.</p>
                                </li>
                                <li>
                                    <p>Environnements cloud/virtualisation.</p>
                                </li>
                                <li>
                                    <p>Racks "shared hosting".</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>&#8594; PVLAN = isolation granulaire dans un même segment L2.</p>
                    <h5>Types de ports dans un PVLAN :</h5>
                    <div>
                        <img src="../images/types_ports_PVLAN.PNG" alt="" class="float_right">
                        <ol>
                            <li>
                                <p>Primary VLAN :</p>
                                <ul>
                                    <li>
                                        <p>VLAN parent - Transporte le trafic général.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>Secondary VLANs (deux types de secondary VLANs) :</p>
                                <ul>
                                    <li>
                                        <p>Isolated VLAN (isolé) :</p>
                                        <ul>
                                            <li>
                                                <p>Hôtes totalement isolés les uns des autres.</p>
                                            </li>
                                            <li>
                                                <p>Peuvent parler uniquement au port promiscuous.</p>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <p>Community VLAN (communauté) :</p>
                                        <ul>
                                            <li>
                                                <p>Hôtes peuvent communiquer entre eux.</p>
                                            </li>
                                            <li>
                                                <p>Mais pas avec les autres communautés.</p>
                                            </li>
                                            <li>
                                                <p>Toujours accès au promiscuous.</p>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                    <h6>Types de ports : comportement :</h6>
                    <ul>
                        <li>
                            <p>Promiscuous port :</p>
                            <ul>
                                <li>
                                    <p>Accès total vers tous les VLANs secondaires.</p>
                                </li>
                                <li>
                                    <p>Typiquement le port du routeur, firewall, ou default gateway.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Isolated port :</p>
                            <ul>
                                <li>
                                    <p>Aucune communication entre ports isolated.</p>
                                </li>
                                <li>
                                    <p>Communication uniquement vers promiscuous.</p>
                                </li>
                                <li>
                                    <p>Cas typique : clients hébergés isolés.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Community port :</p>
                            <ul>
                                <li>
                                    <p>Communication interne dans la communauté.</p>
                                </li>
                                <li>
                                    <p>Pas vers autres communautés.</p>
                                </li>
                                <li>
                                    <p>Permet isolation horizontale.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h6>Types de ports : cas d'usage et limites :</h6>
                    <p>Cas d'usage typique :</p>
                    <ul>
                        <li>
                            <p>Hébergement mutualisé (chaque VM isolée).</p>
                        </li>
                        <li>
                            <p>Datacenters cloud : isolation sans explosion du nombre de VLAN.</p>
                        </li>
                        <li>
                            <p>Multi-tenancy dans un réseau SDN, ACI, NSX.</p>
                        </li>
                        <li>
                            <p>Environnements DMZ : séparation Web/DB/App dans le même L2.</p>
                        </li>
                    </ul>
                    <p>Limites :</p>
                    <ul>
                        <li>
                            <p>Pas supporté par tous les switchs.</p>
                        </li>
                        <li>
                            <p>Complexité de troubleshooting.</p>
                        </li>
                        <li>
                            <p>Ne protège pas contre :</p>
                            <ul>
                                <li>
                                    <p>Attaques L3/L4.</p>
                                </li>
                                <li>
                                    <p>Vulnérabilités applicatives.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h4>Spanning Tree Protocol (STP) :</h4>
                    <div>
                        <img src="../images/spanning_tree_protocol.PNG" alt="" class="float_right">
                        <p>STP = protocole de couche 2 (IEEE 802.1D).</p>
                        <p><span class="em">Objectif</span> : éviter les boucles réseau dans un environnement commuté.</p>
                        <p>Les boucles L2 provoquent :</p>
                        <ul>
                            <li>
                                <p>Tempêtes de broadcast.</p>
                            </li>
                            <li>
                                <p>Multiplication de trames.</p>
                            </li>
                            <li>
                                <p>Table MAC instable.</p>
                            </li>
                        </ul>
                        <p>STP garantit un chemin unique actif entre deux switchs.</p>
                        <p>Les problèmes des boucles en L2 sont :</p>
                        <ul>
                            <li>
                                <p>Ethernet ne possède <span class="em">pas de TTL</span> &#8594; risque de boucles infinies.</p>
                            </li>
                            <li>
                                <p>Une trame peut circuler à l'infini dans un réseau bouclé.</p>
                            </li>
                            <li>
                                <p>Les broadcast/multicast se multiplient.</p>
                            </li>
                            <li>
                                <p>Le réseau devient inutilisable.</p>
                            </li>
                        </ul>
                        <p>Solution : STP désactive certains ports pour créer un <span class="em">arbre logique sans boucle</span>.</p>
                    </div>
                    <h5>Sans STP - Problème des boucles :</h5>
                    <p class="em">Instabilité de la table CAM :</p>
                    <p>Le switch apprend les adresses MAC selon l'interface qui a vu la trame. En présence d'une boucle, <span class="em">la même MAC arrive sur plusieurs ports</span>.</p>
                    <p>Résultat :</p>
                    <ul>
                        <li>
                            <p><span class="em">Flapping de MAC</span> (MAC address flapping).</p>
                        </li>
                        <li>
                            <p>Entrées MAC mises à jour en permanence.</p>
                        </li>
                        <li>
                            <p>Switching imprévisible.</p>
                        </li>
                        <li>
                            <p>Performance catastrophe.</p>
                        </li>
                    </ul>
                    <img src="../images/sans_STP_probleme_boucles.PNG" alt="">
                    <h6>Tempêtes de broadcast (Broadcast Storm) :</h6>
                    <p>Symptômes :</p>
                    <ul>
                        <li>
                            <p>Perte de connectivité.</p>
                        </li>
                        <li>
                            <p>Latence extrême.</p>
                        </li>
                        <li>
                            <p>CPU à 100 % sur les switchs.</p>
                        </li>
                        <li>
                            <p>Impossible de faire du SSH/console/gestion SNMP.</p>
                        </li>
                        <li>
                            <p>Déconnexion de tous les hôtes.</p>
                        </li>
                    </ul>
                    <p>Pourquoi ? <span class="em">Une trame broadcast se répète de manière exponentielle dans la boucle.</span></p>
                    <img src="../images/broadcast_storm.PNG" alt="">
                    <p class="em">Les trames de broadcast circulent indéfinement dans le réseau causant ainsi la paralysie de tous les switchs.</p>
                    <h5>Fonctionnement général du STP :</h5>
                    <p>STP opère en quatre étapes :</p>
                    <ol>
                        <li>
                            <p>Élection du Root Bridge.</p>
                        </li>
                        <li>
                            <p>Calcul du <span class="em">**chemin le plus court**</span> pour tous les switchs.</p>
                        </li>
                        <li>
                            <p>Sélection des ports :</p>
                            <ul>
                                <li>
                                    <p>Root Port.</p>
                                </li>
                                <li>
                                    <p>Designated Port.</p>
                                </li>
                                <li>
                                    <p>Non-Designated Port (bloqué).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Mise en place de l'arbre sans boucle.</p>
                        </li>
                    </ol>
                    <p>Élection du Root Bridgeed Port :</p>
                    <ul>
                        <li>
                            <p>Le Root Bridge est <span class="em">le switch central</span> de l'arbre.</p>
                        </li>
                        <li>
                            <p>Basé sur le <span class="em">Bridge ID</span> :</p>
                            <ul>
                                <li>
                                    <p>Priority (modulable).</p>
                                </li>
                                <li>
                                    <p>MAC Address.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Le switch avec le <span class="em">**plus petit Bridge ID**</span> = Root Bridge.</p>
                        </li>
                        <li>
                            <p><span class="em">**Best practice :**</span> Définir manuellement le Root Bridge sur un switch central.</p>
                        </li>
                    </ul>
                    <p>Les rôles de ports STP sont :</p>
                    <ul>
                        <li>
                            <p><span class="em">Root Port (RP)</span> : Port le plus proche du Root Bridge.</p>
                        </li>
                        <li>
                            <p><span class="em">Designated Port (DP)</span> : Port désigné pour transférer le trafic vers un segment.</p>
                        </li>
                        <li>
                            <p><span class="em">Blocked/Alternate Port</span> : Empêche la boucle, reste en standby.</p>
                        </li>
                    </ul>
                    <p>Ces rôles changent dynamiquement selon la topologie.</p>
                    <p>Un port STP peut être dans l'un des états suivants :</p>
                    <ul>
                        <li>
                            <p><span class="em">Disabled</span> : Port inactif.</p>
                        </li>
                        <li>
                            <p><span class="em">Blocking</span> : Évite les boucles.</p>
                        </li>
                        <li>
                            <p><span class="em">Listening</span> : Analyse des BPDU.</p>
                        </li>
                        <li>
                            <p><span class="em">Learning</span> : Apprentissage MAC.</p>
                        </li>
                        <li>
                            <p><span class="em">Forwarding</span> : Port actif.</p>
                        </li>
                    </ul>
                    <p>Durée de convergence classique : ~30 à 50 secondes.</p>
                    <h5>STP - BPDU (Bridge Protocol Data Unit) :</h5>
                    <p>Les switchs échangent des BPDU pour :</p>
                    <ul>
                        <li>
                            <p>Élire le Root Bridge.</p>
                        </li>
                        <li>
                            <p>Maintenir la topologie.</p>
                        </li>
                        <li>
                            <p>Détecter les changements.</p>
                        </li>
                    </ul>
                    <p>Les variantes modernes du STP sont :</p>
                    <ul>
                        <li>
                            <p><span class="em">RSTP</span> (Rapid STP) - <span class="em">802.1w</span> :</p>
                            <ul>
                                <li>
                                    <p>Convergence rapide (&lt; 3 secondes).</p>
                                </li>
                                <li>
                                    <p>États simplifiés.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p><span class="em">MSTP (802.1s)</span> : Plusieurs instances STP pour plusieurs VLAN.</p>
                        </li>
                        <li>
                            <p><span class="em">PVST /PVST+</span> (Cisco) : 1 instance STP par VLAN.</p>
                        </li>
                    </ul>
                    <h4>Sécurité de la couche 2 (attaques &amp; contre-mesures) :</h4>
                    <h5>Introduction à la sécurité L2 :</h5>
                    <p>La couche 2 (L2) est critique : commutation, VLAN, adressage MAC.</p>
                    <ul>
                        <li>
                            <p>Souvent négligée &#8594; surface d'attaque réelle.</p>
                        </li>
                        <li>
                            <p>Attaques &#8594; impact : interception, déni de service, détournement de trafic.</p>
                        </li>
                        <li>
                            <p>Objectif : comprendre les attaques et les contre-mesures.</p>
                        </li>
                    </ul>
                    <h5>Pourquoi la couche 2 est vulnérable ?</h5>
                    <ul>
                        <li>
                            <p>Switchs supposent des utilisateurs "de confiance".</p>
                        </li>
                        <li>
                            <p>Protocole Ethernet &#8594; pas d'authentification.</p>
                        </li>
                        <li>
                            <p>Protocoles L2 souvent en clair.</p>
                        </li>
                        <li>
                            <p>Conception historique pour réseaux "localement sécurisés".</p>
                        </li>
                    </ul>
                    <h5>Typologie des attaques L2 :</h5>
                    <ul>
                        <li>
                            <p>MAC Flooding.</p>
                        </li>
                        <li>
                            <p>ARP Spoofing / ARP Poisoning.</p>
                        </li>
                        <li>
                            <p>DHCP Spoofing / DHCP Starvation.</p>
                        </li>
                        <li>
                            <p>Attaques STP (Spanning-Tree).</p>
                        </li>
                        <li>
                            <p>VLAN Hopping.</p>
                        </li>
                        <li>
                            <p>CDP/LLDP exploitation.</p>
                        </li>
                        <li>
                            <p>Attaques sur port security.</p>
                        </li>
                    </ul>
                    <p class="em">MAC Flooding :</p>
                    <ul>
                        <li>
                            <p><span class="em">Principe</span> : Saturer la table CAM avec de fausses adresses MAC. Le switch passe en mode "fail-open". Diffuse le trafic &#8594; interception.</p>
                        </li>
                        <li>
                            <p><span class="em">Impact</span> : perte de performance, sniffing.</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : Port Security (limiter MAC par port). Storm Control. Surveillance CAM (SNMP, logs, syslog).</p>
                        </li>
                    </ul>
                    <p class="em">ARP Spoofing / Poisoning :</p>
                    <ul>
                        <li>
                            <p><span class="em">Principe</span> : L'attaquant envoie de fausses réponses ARP. Redirection du trafic. MITM. Usurpation IP...</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : Dynamic ARP Inspection (DAI). DHCP Snooping (base de confiance pour DAI). ARP static pour équipements critiques. Monitoring ARP anomalies.</p>
                        </li>
                    </ul>
                    <p class="em">DHCP Starvation &amp; Spoofing :</p>
                    <ul>
                        <li>
                            <p><span class="em">Principe</span> : DHCP Starvation : épuisement du pool IP. DHCP Spoofing : l'attaquant se fait passer pour serveur DHCP.</p>
                        </li>
                        <li>
                            <p><span class="em">Impact</span> : Starvation (DOS - utilisateurs ne peuvent plus obtenir d'IP (utiliser le réseau)). Spoofing &#8594; MITM.</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : DHCP Snoofing (trusted/untrusted ports). Rate-limit sur requêtes DHCP. Isolation des ports utilisateurs, Port-security.</p>
                        </li>
                    </ul>
                    <p class="em">Attaques STP (Spanning-Tree) :</p>
                    <ul>
                        <li>
                            <p><span class="em">Principe</span> : L'attaquant se fait élire root bridge en envoyant des BPDU forgées.</p>
                        </li>
                        <li>
                            <p><span class="em">Impact</span> : Redirection de trafic - instabilité du réseau.</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : BPDU Guard. Root Guard. BPDU Filter. PortFast...</p>
                        </li>
                    </ul>
                    <p class="em">VLAN Hopping (Double Tagging) :</p>
                    <ul>
                        <li>
                            <p><span class="em">Principe</span> : Manipuler les tags 802.1Q pour sortir de son VLAN. Double-tagging. Attaques sur ports trunk.</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : Désactiver DTP. Forcer les ports en access/trunk. Ne jamais mettre VLAN natif = VLAN 1. Isoler VLAN de management.</p>
                        </li>
                    </ul>
                    <p class="em">CDP / LLDP Exploitation :</p>
                    <ul>
                        <li>
                            <p><span class="em">Problème</span> : Ces protocoles divulguent : Version OS. Topologie. VLAN. Capacités.</p>
                        </li>
                        <li>
                            <p><span class="em">Contre-mesures</span> : Désactiver CDP/LLDP sur ports utilisateurs. Limiter à infrastructure. Surveiller via IDS des paquets CDP falsifiés.</p>
                        </li>
                    </ul>
                    <h5>Meilleures pratiques globales L2 :</h5>
                    <ul>
                        <li>
                            <p>Désactiver ports inutilisés.</p>
                        </li>
                        <li>
                            <p>Appliquer Port-Security et des ACL sur ports d'accès.</p>
                        </li>
                        <li>
                            <p>Désactiver services inutiles (CDP, DTP...).</p>
                        </li>
                        <li>
                            <p>Activer les protections (DAI, IP Source Guard, DHCP Snooping).</p>
                        </li>
                        <li>
                            <p>Surveiller logs, syslog, SNMP traps (on verra plus loin dans le cours).</p>
                        </li>
                        <li>
                            <p>Mettre le management hors VLAN 1. Désactiver le VLAN 1.</p>
                        </li>
                        <li>
                            <p>Séparer VLAN utilisateurs / serveurs / admin. Architecture Zone-Based.</p>
                        </li>
                        <li>
                            <p>Private VLAN (PVLAN) (data centers).</p>
                        </li>
                        <li>
                            <p>ACL L2 sur switchs (VACL).</p>
                        </li>
                        <li>
                            <p>Filtrage du trafic (inter-VLAN).</p>
                        </li>
                        <li>
                            <p class="em">Sécurisation des protocoles de gestion (on verra plus loin dans le cours).</p>
                        </li>
                    </ul>
                    <h5>Conclusion : sécurité de la couche 2 :</h5>
                    <ul>
                        <li>
                            <p>La couche 2 est un maillon faible si non protégée.</p>
                        </li>
                        <li>
                            <p>Les attaques sont souvent simples mais très efficaces.</p>
                        </li>
                        <li>
                            <p>Les contre-mesures existent : activer, tester, monitorer.</p>
                        </li>
                        <li>
                            <p>Sécuriser L2 est fondamental avant L3 et au-delà.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="protocole_IP">Protocole IP :</h2>
                    <h3>Introduction :</h3>
                    <p class="em">L'IP est le coeur de la suite TCP/IP.</p>
                    <p>Son rôle est de fournir un <span class="em">service de livraison de paquets</span> entre hôtes sur des réseaux interconnectés.</p>
                    <p>Ses caractéristiques principales sont :</p>
                    <ul>
                        <li>
                            <p>Service <span class="em">non fiable</span> (best effort).</p>
                        </li>
                        <li>
                            <p>Sans connexion.</p>
                        </li>
                        <li>
                            <p>Livraison d'unités de données appelées <span class="em">datagrammes</span>.</p>
                        </li>
                        <li>
                            <p>Routage de paquets à travers plusieurs réseaux.</p>
                        </li>
                    </ul>
                    <p>L'IP assure :</p>
                    <ul>
                        <li>
                            <p>le <span class="em">transfert</span> des datagrammes entre machines source et destination;</p>
                        </li>
                        <li>
                            <p>l'<span class="em">adressage logique</span> via les adresses IP;</p>
                        </li>
                        <li>
                            <p>le <span class="em">routage</span> entre réseaux hétérogènes interconnectés.</p>
                        </li>
                    </ul>
                    <p class="em">L'IP n'assure PAS :</p>
                    <ul>
                        <li>
                            <p>la fiabilité;</p>
                        </li>
                        <li>
                            <p>le contrôle de flux;</p>
                        </li>
                        <li>
                            <p>la détection/correction d'erreurs (sauf si le checksum d'en-tête).</p>
                        </li>
                    </ul>
                    <p>Ces responsabilités sont prises en charge par les couches supérieures.</p>
                    <h3>Encapsulation IP :</h3>
                    <p>L'IP reçoit des données de la couche transport (TCP, UDP) et les encapsule dans un <span class="em">datagramme</span>.</p>
                    <p class="em">Datagramme = En-tête IP + Données</p>
                    <p class="em">Encapsulation dans l'ordre :</p>
                    <ol>
                        <li>
                            <p>Données de la couche application</p>
                        </li>
                        <li>
                            <p>Segment TCP / Message UDP</p>
                        </li>
                        <li>
                            <p>Datagramme IP</p>
                        </li>
                        <li>
                            <p>Trame (Ethernet, Token Ring...)</p>
                        </li>
                    </ol>
                    <p>Chaque couche ajoute son propre en-tête.</p>
                    <h3>Structure du datagramme IP :</h3>
                    <img src="" alt="">
                    <p>Un <span class="em">datagramme IP</span> contient :</p>
                    <ul>
                        <li>
                            <p>Version (4 bits) :</p>
                            <ul>
                                <li>
                                    <p>Indique la version du protocole IP utilisée.</p>
                                </li>
                                <li>
                                    <p><span class="em">4</span> = IPv4.</p>
                                </li>
                                <li>
                                    <p><span class="em">6</span> = IPv6.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Header Length (<span class="em">IHL</span>) (4 bits) :</p>
                            <ul>
                                <li>
                                    <p>Taille de l'en-tête IP en mots de 32 bits (4 octets).</p>
                                </li>
                                <li>
                                    <p>Minimum = 5 (20 octets), Maximum = 15 (60 octets).</p>
                                </li>
                                <li>
                                    <p>Sert à identifier où commencent les données (couche supérieure TCP, UDP, ...).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Type of Service (<span class="em">TOS</span>) (8 bits) :</p>
                            <ul>
                                <li>
                                    <p>Initialement destiné à indiquer la priorité du paquet.</p>
                                </li>
                                <li>
                                    <p>Aujourd'hui utilisé comme :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">DSCP</span> (Differentiated Services Code - 6 bits) pour la qualité de service (QoS).</p>
                                        </li>
                                        <li>
                                            <p><span class="em">ECN</span> (Explicit Congestion Notification - 2 bits) pour signaler la congestion sans perte de paquets.</p>
                                        </li>
                                        <li>
                                            <p class="em">Exemples : trafic voix, vidéo, best-effort.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Total Length (16 bits) :</p>
                            <ul>
                                <li>
                                    <p>Taille totale du datagramme en octets.</p>
                                </li>
                                <li>
                                    <p>en-tête + données : valeur max = 65535 octets.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Identification (16 bits) :</p>
                            <ul>
                                <li>
                                    <p>Numéro unique attribué à chaque datagramme.</p>
                                </li>
                                <li>
                                    <p>Utilisé lors de la <span class="em">fragmentation</span>.</p>
                                </li>
                                <li>
                                    <p>Tous les fragments d'un même datagramme partagent le même identifiant afin que la destination puisse les réassembler.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Flags (3 bits) : Contrôlent la fragmentation.</p>
                            <ul>
                                <li>
                                    <p><span class="em">bit 0 : réservé</span>, toujours 0</p>
                                </li>
                                <li>
                                    <p class="em">bit 1 : DF (Don't Fragment) :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">1</span> = ne pas fragmenter</p>
                                        </li>
                                        <li>
                                            <p><span class="em">0</span> = fragmentation autorisée</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p class="em">bit 2 : MF (More Fragments) :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">1</span> = suite de fragments</p>
                                        </li>
                                        <li>
                                            <p><span class="em">0</span> = dernier fragment</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Fragment Offset (13 bits) :</p>
                            <ul>
                                <li>
                                    <p>Indique la position du fragment dans le datagramme original.</p>
                                </li>
                                <li>
                                    <p>Exprimée en <span class="em">unités de 8 octets (64 bits)</span>.</p>
                                </li>
                                <li>
                                    <p>Permet l'ordre correct des fragments.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Time To Live (TTL) (8 bits) :</p>
                            <ul>
                                <li>
                                    <p>Nombre maximal de "sauts" (routeurs) que le paquet peut traverser.</p>
                                </li>
                                <li>
                                    <p>Décrémenté à chaque saut de routeur.</p>
                                </li>
                                <li>
                                    <p>Si TTL = 0 &#8594; le routeur détruit le paquet et envoie ICMP Time Exceeded.</p>
                                </li>
                                <li>
                                    <p>Préserve le réseau des boucles infinies.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Protocol (8 bits) :</p>
                            <ul>
                                <li>
                                    <p>Indique le protocole de la couche supérieure encapsulé dans l'IP.</p>
                                </li>
                                <li>
                                    <p>Exemples (RFC 790) :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">6</span> &#8594; TCP</p>
                                        </li>
                                        <li>
                                            <p><span class="em">17</span> &#8594; UDP</p>
                                        </li>
                                        <li>
                                            <p><span class="em">1</span> &#8594; ICMP</p>
                                        </li>
                                        <li>
                                            <p><span class="em">47</span> &#8594; GRE</p>
                                        </li>
                                        <li>
                                            <p><span class="em">50/51</span> &#8594; IPsec ESP/AH</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Permet au destinataire de savoir comment interpréter les données.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Header Checksum (16 bits) :</p>
                            <ul>
                                <li>
                                    <p>Checksum calculé uniquement sur l'en-tête IP, pas sur les données.</p>
                                </li>
                                <li>
                                    <p>Il permet :</p>
                                    <ul>
                                        <li>
                                            <p>de vérifier l'<span class="em">intégrité de l'en-tête</span></p>
                                        </li>
                                        <li>
                                            <p>aux routeurs de recalculer le checksum à chaque modification du TTL</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Source IP (32 bits) :</p>
                            <ul>
                                <li>
                                    <p>Adresse IPv4 de l'expéditeur.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Destination IP (32 bits) :</p>
                            <ul>
                                <li>
                                    <p>Adresse IPv4 du destinataire.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Les options IP :</p>
                            <ul>
                                <li>
                                    <p>Champ <span class="em">facultatif</span> et <span class="em">rarement utilisé</span> dans les réseaux modernes.</p>
                                </li>
                                <li>
                                    <p>Exemples historiques : Record Route, Security, Timestamp, Loose/Strict Source Routing</p>
                                </li>
                                <li>
                                    <p>Les options augmentent la valeur de l'en-tête &#8594; IHL &gt; 5.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Padding (!!! Car la longueur du champ Option est <span class="em">variable</span> !!!) :</p>
                            <ul>
                                <li>
                                    <p>Bourrage utilisé pour compléter l'en-tête jusqu'à un multiple de 32 bits.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="architecture_normes_protocoles">Architecture, normes (standards) et protocoles :</h2>
                    <h3>Le modèle de référence OSI :</h3>
                    <p>OSI signifie "Open Systems Interconnection" (interconnexion de systèmes ouverts), le terme "Open Systems" faisant référence aux spécifications entourant la structure du modèle ainsi qu'à sa mise à disposition publique non propriétaire.</p>
                    <p>Tout le monde peut construire les logiciels et le matériel nécessaires pour communiquer au sein de la structure OSI.</p>
                    <p>Le modèle de référence OSI est un cadre conceptuel qui permet de comprendre et de normaliser les communications entre différents systèmes informatiques.</p>
                    <p>Le modèle de référence OSI définit un modèle de communication de données à sept couches ayant chacune un rôle précis, avec le transport physique à la couche inférieure et les protocoles d'application à la couche supérieure.</p>
                    <p>Ce modèle, illustré à la figure 1-1, est largement adopté comme base de compréhension du fonctionnement d'une pile de protocoles de réseau et comme référence pour l'élaboration de protocoles d'applications réseau.</p>
                    <figure>
                        <img src="../images/modele_OSI.PNG" alt="">
                        <figcaption>Figure 1-1 : Le modèle OSI.</figcaption>
                    </figure>
                    <p>Chaque couche fournit un ensemble de fonctions à la couche supérieure et, à son tour, s'appuie sur les fonctions fournies par la couche inférieure. Bien que les messages ne puissent passer verticalement à travers la pile d'une couche à l'autre, d'un point de vue logique, chaque couche communique directement avec sa couche homologue sur d'autres noeuds.</p>
                    <figure>
                        <img src="../images/modele_OSI_2.PNG" alt="">
                        <figcaption>Figure 1-2 : Relations détaillées entre les couches.</figcaption>
                    </figure>
                    <p>Les sept couches OSI utilisent diverses formes d'informations de contrôle pour communiquer avec leurs couches homologues dans d'autres systèmes informatiques et avec les couches adjacentes au sein du même système.</p>
                    <p>Ces informations de contrôle consistent en des demandes et instructions spécifiques échangées entre les couches OSI. Les informations de contrôle prennent généralement l'une des deux formes suivantes :</p>
                    <ul>
                        <li>
                            <p>Les en-têtes : ajoutés à l'avant des données transmises par les couches supérieures.</p>
                        </li>
                        <li>
                            <p>Les données : ajoutées à l'arrière des données transmises par les couches supérieures.</p>
                        </li>
                    </ul>
                    <p>Les en-têtes et les données sont des concepts relatifs, qui dépendent de la couche qui analyse l'unité d'information à ce moment-là.</p>
                    <p>Par exemple, au niveau du réseau, une unité d'information se compose d'un en-tête de couche 3 et de données, appelées charge utile. Cependant au niveau de la couche liaison de données (couche 2), toutes les informations transmises par la couche réseau (l'en-tête de la couche 3 et les données) sont traitées simplement comme des données. En d'autres termes, la partie données d'une unité d'information à une couche OSI donnée peut potentiellement contenir des en-têtes et des données de toutes les couches supérieures. C'est ce qu'on appelle l'encapsulation.</p>
                    <p>La figure 1-3 montre l'en-tête et les données d'une couche qui sont encapsulées dans l'en-tête de la couche immédiatement inférieure.</p>
                    <figure>
                        <img src="../images/encapsulation_modele_OSI.PNG" alt="">
                        <figcaption>Figure 1-3 : Encapsulation des unités d'information à travers les couches OSI.</figcaption>
                    </figure>
                    <p>Les sept couches sont les suivantes :</p>
                    <ul>
                        <li>
                            <p><span class="em">Couche 7 - Application</span> : La couche application joue essentiellement le rôle d'interface avec l'utilisateur final. C'est la couche où se produit l'interaction entre les applications réseau telles que le courrier électronique, le transfert de fichiers (FTP), le web (HTTP), l'émulation de terminal, etc.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 6 - Présentation</span> : La couche Présentation est responsable du formatage des données et de cryptage entre applications, c'est-à-dire la traduction des formats de communication (syntaxe) entre les applications, parmi les formats, on trouve HTML, MIME, ASCII, EBCDIC...</p>
                            <p>Un autre exemple des actions qui se produisent dans cette couche est le cryptage et le décryptage des données dans Pretty Good Privacy (PGP).</p>
                            <p><span class="em">Rôle</span> : La couche présentation traduit les données pour les présenter.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 5 - Session</span> : La couche session est responsable de l'établissement et du maintien de sessions entre applications réseau. Exemple : lorsqu'un utilisateur télécharge un fichier volumineux en utilisant le protocole HTTP, et qu'au cours du téléchargement une erreur de communication se produit, c'est cette couche qui permet la reprise du téléchargement au point où le téléchargement s'est arrêté évitant ainsi de recommencer le téléchargement depuis le début.</p>
                            <p><span class="em">Rôle</span> : La couche session gère et synchronise les dialogues entre les applications des deux ordinateurs.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 4 - Transport</span> : La couche transport est responsable du mécanisme de transport logique, qui comprend des fonctions de gestion de flux et de la fourniture d'une livraison fiable et non fiable de bout en bout (entre les hôtes). On trouve à cette couche les protocoles TCP et UDP.</p>
                            <p>TCP (protocole de contrôle de transmission) a un mécanisme qui fournit un niveau de contrôle d'erreur et de fiabilité (par le biais de numéros de séquence). Contrairement à TCP, le protocole de datagramme utilisateur (UDP) est un protocole non fiable ne disposant pas de la surcharge supplémentaire qui assure le contrôle des erreurs et la fiabilité comme TCP.</p>
                            <p><span class="em">Processus</span> : Les données sont segmentées pour faciliter leur transmission.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 3 - Réseau</span> : La couche réseau définit l'adressage logique des interfaces, les décisions de routage sont prises en fonction de l'emplacement de l'adresse de protocole Internet (IP) en question. Par exemple, les adresses IP établissent des topologies logiques distinctes, appelées sous-réseaux. En appliquant cette définition à l'environnement d'une station de travail, la station de travail détermine l'emplacement d'une station de travail, la station de travail détermine qui lui est associé par l'intermédiaire de la couche réseau. Les fonctions de livraison de paquets et de routage sont également définies / implémentées par l'intermédiaire de la couche réseau.</p>
                            <p><span class="em">Rôle</span> : La couche réseau détermine le meilleur chemin pour acheminer les paquets de données à travers le réseau. Il gère le routage et l'adressage.</p>
                            <p><span class="em">Processus</span> : Chaque segment est encapsulé dans un paquet avec une adresse IP source et une adresse IP destination.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 2 - Liaison de données</span> : La couche liaison de données fournit l'encapsulation en trame, le contrôle du flux et des erreurs au niveau de l'interface réseau utilisée. Une caractéristique importante de cette couche est que les informations qui lui sont appliquées sont utilisées par les équipements pour déterminer si le paquet doit être traité par cette couche (c'est-à-dire passer à la couche 3 ou être rejeté). Dans le cas des interfaces de type Ethernet, la couche liaison de données attribue également une adresse de contrôle d'accès au média (MAC : Medium Access Control).</p>
                            <p>Par exemple, sur un segment de réseau local Ethernet, toutes les trames sont diffusées et reçues par chaque équipement du segment. Seul l'appareil dont l'adresse MAC est contenue dans la trame de cette couche sur la trame; tous les autres ne le font pas. Il est important de noter ici que les interfaces série ne nécessitent pas d'adresses de station uniques de la couche 2, telles que les adresses MAC, à moins qu'il ne soit nécessaire d'identifier l'extrémité réceptrice dans un réseau multipoint. Sur les réseaux qui ne sont pas conformes aux normes IEEE 802 mais au modèle de référence OSI, l'adresse de noeud est appelée adresse de contrôle de liaison de données (DLC : Data Link Control Address). Par exemple, dans Frame Relay, cette adresse de couche 2 est connue sous le nom d'identifiant de connexion de liaison de données (DLCI : Data Link Connection Identifier).</p>
                            <p><span class="em">Rôle</span> : Cette couche assure la communication directe, fiable et sécurisée entre deux dispositifs sur le même réseau local. Elle assure une connexion sans erreur pour la transmission des trames.</p>
                            <p><span class="em">Processus</span> : Les paquets sont encapsulés dans des trames et reçoivent une adresse MAC source et destination pour pouvoir être envoyés.</p>
                        </li>
                        <li>
                            <p><span class="em">Couche 1 - Physique</span> : La couche physique est la couche la plus basse du modèle de référence OSI. Elle est la plus proche du support physique du réseau. Cette couche est chargée de définir les informations relatives au matériel physique, telles que les spécifications électriques, mécaniques et fonctionnelles pour connecter et transmettre les signaux entre deux systèmes. La couche physique se compose de trois domaines principaux : les supports de transmission (câbles, fibres optiques, ...), les connecteurs (RJ45, SFP, BNC...) et le codage (NRZ, NRZI, MLT-3, HDB3, Manchester, Manchester Différentiel...).</p>
                            <p><span class="em">Rôle</span> : La couche physique est responsable de la transmission réelle des bits sur le réseau via des câbles, signaux radio, fibre optique, etc.</p>
                            <p><span class="em">Processus</span> : Les trames sont converties en signaux électriques, optiques, ou radio fréquences, qui sont ensuite transmis sur le support physique.</p>
                        </li>
                    </ul>
                    <p>Comprendre le modèle OSI aide à identifier et résoudre des problèmes réseau. Il reste un outil pédagogique.</p>
                    <h4>Le modèle OSI comparé au modèle TCP/IP :</h4>
                    <p>Le modèle TCP/IP est un modèle pratique qui répond à des problèmes de communication spécifiques et repose sur des protocoles normalisés. En revanche, le modèle OSI est un cadre complet, indépendant des protocoles, conçu pour englober diverses méthodes de communication en réseau.</p>
                    <p>Le modèle TCP/IP (Transmission Control Protocol/Internet Protocol) comporte cinq couches :</p>
                    <ul>
                        <li>
                            <p>Couche application.</p>
                        </li>
                        <li>
                            <p>Couche transport.</p>
                        </li>
                        <li>
                            <p>Couche d'accès au réseau.</p>
                        </li>
                        <li>
                            <p>Couche d'interface réseau.</p>
                        </li>
                        <li>
                            <p>Couche physique (matérielle).</p>
                        </li>
                    </ul>
                    <p>Ce modèle peut sembler radicalement différent du modèle OSI, principalement parce que certaines fonctions sont englobées dans une seule couche : la couche application.</p>
                    <p>Le modèle TCP/IP fournit aux utilisateurs les normes physiques, les fonctions de transport, l'interface réseau et les fonctions d'interconnexion qui correspondent aux quatre premières couches du modèle OSI. En d'autres termes, les fonctions réalisées dans les couches Application, Présentation et Session du modèle OSI sont toutes réalisées dans la couche application du modèle TCP/IP.</p>
                    <p>La figure 1-4 montre la correspondance entre les couches du modèle OSI et celles du modèle TCP/IP.</p>
                    <img src="../images/modele_OSI_TCP_IP.PNG" alt="">
                    <p>OSI est un modèle théorique tandis que TCP/IP est un modèle pratique.</p>
                    <p>TCP/IP regroupe ceryaines couches du modèle OSI pour plus de simplicité.</p>
                    <p>Les deux modèles sont complémentaires.</p>
                    <h3>Les interfaces d'interconnexion (liaisons de données (couche 2)) :</h3>
                    <p>TCP/IP, en tant que suite de protocoles Internet, peut fonctionner sur un grand nombre de réseaux physiques.</p>
                    <p>TCP/IP s'appuie sur des protocoles et des interfaces qui permettent au trafic de circuler sur différents types de réseaux physiques. Le plus courant et le plus largement utilisé de ces protocoles est, bien entendu "Ethernet".</p>
                    <p>Dans ce chapitre, nous allons voir le standard "Ethernet" et la norme IEEE 802.3. Bien entendu, il existe un grand nombre de protocoles de couche 2, mais la couverture de tous ces protocoles dépasse le cadre de ce cours. Cependant, voici une liste non exhaustive de ces protocoles :</p>
                    <ul>
                        <li>
                            <p>ARCnet</p>
                        </li>
                        <li>
                            <p>Asynchronous Transfer Mode (ATM)</p>
                        </li>
                        <li>
                            <p>Econet</p>
                        </li>
                        <li>
                            <p>Fiber Distributed Data Interface (FDDI)</p>
                        </li>
                        <li>
                            <p>Frame relay</p>
                        </li>
                        <li>
                            <p>High-Level Data Link Control (HDLC)</p>
                        </li>
                        <li>
                            <p>LattisNet</p>
                        </li>
                        <li>
                            <p>Link Access Procedure for D channel (LAPD)</p>
                        </li>
                        <li>
                            <p>Serial Line Internet Protocol (SLIP)</p>
                        </li>
                        <li>
                            <p>Token Ring</p>
                        </li>
                        <li>
                            <p>Point-to-point protocol (PPP)</p>
                        </li>
                        <li>
                            <p>...</p>
                        </li>
                    </ul>
                    <p>La plupart de ces protocoles sont devenus obsolètes dû à l'adoption massive du standard "Ethernet".</p>
                    <h4>Formats de trame :</h4>
                    <p>La trame Ethernet est utilisée pour encapsuler les données et les transmettre sur le réseau local.</p>
                    <p>La trame Ethernet est composée de :</p>
                    <ul>
                        <li>
                            <p>Préambule (+ SOF) (8 octets - non visibles lors de la capture - récupéré / enlevé par la couche 1)</p>
                        </li>
                        <li>
                            <p>Adresse destination (6 octets)</p>
                        </li>
                        <li>
                            <p>Adresse source (6 octets)</p>
                        </li>
                        <li>
                            <p>Type/Longueur (2 octets)</p>
                        </li>
                        <li>
                            <p>Données (46 à 1500 octets)</p>
                        </li>
                        <li>
                            <p>Contrôle d'erreur (4 octets - non visibles lors de la capture - récupéré / enlevé par la couche 1)</p>
                        </li>
                    </ul>
                    <p><span class="em">Avantages</span> : simple et directement compatible avec IP, ARP et IPv6.</p>
                    <p>Il existe deux formats : <span class="em">Ethernet</span> et <span class="em">IEEE 802.2</span>. Ces deux formats de trame (ou normes) peuvent être utilisés sur le même média physique (câble coaxial Ethernet, paires torsadées, fibres optiques...).</p>
                    <ul>
                        <li>
                            <p>La norme publiée en 1978 par Xerox Corporation, Intel Corporation et Digital Equipment  Corporation, généralement appelée Ethernet (ou DIX Ethernet) et plus tard standardisé sous la norme 802.3.</p>
                        </li>
                        <li>
                            <p>La norme internationale IEEE 802.2 qui ajoute des services de qualités à la sous-couche supérieure de la norme 802.3 aussi connue sous le nom de la "norme 802.3 LLC".</p>
                        </li>
                    </ul>
                    <p>Voici une description du format de trame décrit par la spécification originale Ethernet Version II telle que publiée par DEC, Intel et Xerox. Comme la spécification 802.3, la spécification de la version II définit un en-tête de liaison de données composé de 14 octets (6 + 6 + 2) d'informations, mais la spécification de la version II ne spécifie pas d'en-tête LLC.</p>
                    <p>Les champs Préambule et FCS (Frame Check Sequence) ont été supprimés car ils sont traités au niveau de la couche 1 par les pilotes des périphériques. La figure 2-1 montre le format de la trame Ethernet II.</p>
                    <p><span class="em">Décalage 0-5 : l'adresse de destination :</span> Les six premiers octets d'une trame Ethernet constituent l'adresse de destination. L'adresse de destination indique à quel adaptateur la trame de données est envoyée. Une adresse de destination composée uniquement de 1 indique un message de diffusion qui est lu par tous les adaptateurs Ethernet qui reçoivent la trame. Les trois premiers octets de l'adresse de destination sont attribués par l'IEEE au fournisseur de l'adaptateur et sont spécifiques à ce dernier. Voir la page Adresse MAC pour plus d'informations. Le format de l'adresse de destination est identique dans toutes les implémentations d'Ethernet.</p>
                    <p><span class="em">Décalage 6-11 : l'adresse source :</span> Les six octets suivants d'une trame Ethernet constituent l'adresse source. L'adresse source indique de quel adaptateur provient le message. Comme pour l'adresse de destination, les trois premiers octets indiquent le fournisseur de la carte.</p>
                    <p><span class="em">Décalage 12-13 : l'Ethertype :</span> L'adresse source est suivie d'un champ de 2 octets appelé Ethertype. L'Ethertype est analogue aux SAP de la trame 802.3 en ce sens qu'il spécifie la mémoire tampon dans laquelle placer cette trame.</p>
                    <p><span class="em">Données = 46-1500 octets :</span> L'Ethertype est suivi de 46 à 1500 octets de données, généralement constitués d'en-têtes de couche supérieure tels que TCP/IP ou IPX, puis des données de l'utilisateur proprement dites.</p>
                    <figure>
                        <img src="../images/trame_EthernetII.PNG" alt="">
                        <figcaption>Figure 2-1 : Trame Ethernet II</figcaption>
                    </figure>
                    <p>Exemple de types de trames les plus rencontrés :</p>
                    <ul>
                        <li>
                            <p>champ Ethertype = 0x800 &#8594; IPv4</p>
                        </li>
                        <li>
                            <p>champ EtherType = 0x806 &#8594; ARP</p>
                        </li>
                        <li>
                            <p>champ Ethertype = 0x86DD &#8594; IPv6</p>
                        </li>
                        <li>
                            <p>champ Ethertype = 0x8100 &#8594; IEEE 802.1Q VLAN tagging</p>
                        </li>
                        <li>
                            <p>champ Ethertype = 0x88CC &#8594; LLDP (Link Layer Discovery Protocol)</p>
                        </li>
                    </ul>
                    <p>La norme IEEE 802.2 insère trois champs pour le contrôle de liaison logique, après le champ EtherTypes/longueur. La figure 2-2 montre le format d'une trame 802.2 LLC.</p>
                    <figure>
                        <img src="../images/trame_IEEE_LLC.PNG" alt="">
                        <figcaption>Figure 2-2 : Format d'une trame IEEE 802.2 LLC.</figcaption>
                    </figure>
                    <p>La différence entre les deux normes réside dans l'utilisation de l'un des champs de l'en-tête, qui contient un numéro de type de protocole pour Ethernet et la longueur des données de la trame pour l'IEEE 802.3.</p>
                    <p>Le champ "type" dans Ethernet est utilisé pour distinguer les différents protocoles encapsulés dans la trame et permet leur coexistence sur le même média physique.</p>
                    <p>La longueur maximale d'une trame Ethernet est de 1526 octets. Cela signifie que la longueur du champ de données peut atteindre 1500 octets.</p>
                    <p>La longueur des données (du champ "Data") pour IEEE 802.3 est également limitée à 1500 octets pour les réseaux 10 Mbps, mais elle est différente pour les autres vitesses de transmission.</p>
                    <p>La valeur du champ "type/longueur" est utilisée pour différencier les trames :</p>
                    <ul>
                        <li>
                            <p>Si la valeur est inférieure ou égale à 1500, le champ signifie "longueur" (indique la longueur des données), et la trame est donc IEEE 802.3.</p>
                        </li>
                        <li>
                            <p>Si la valeur est supérieure à 1500, le champ signifie "type" (indique le numéro de type "EtherType" de protocole transporté dans la partie "data" de la trame) et la trame est donc Ethernet II.</p>
                        </li>
                    </ul>
                    <p>Par conséquent, la couche physique Ethernet et la couche physique IEEE 802.3 sont compatibles. Cependant, la couche liaison de données Ethernet et la couche de liaison de données IEEE 802.3/802.2 sont incompatibles.</p>
                    <p>La couche de contrôle de liaison logique (LLC : Logical Link Control) 802.2 au-dessus de l'IEEE 802.3 utilise un concept connu sous le nom de point d'accès au service de liaison (LSAP : Link Service Access Point), qui utilise un en-tête DSAP et SSAP de 3 octets. DSAP et SSAP signifient point d'accès au service de la destination et de la source.</p>
                    <p>Les numéros de ces champs sont attribués par un comité de l'IEEE.</p>
                    <p>Dans la trame IEEE 802.3, le type de protocole qu'elle transporte est indiqué dans l'en-tête 802.2 LLC.</p>
                    <p>En raison du nombre croissant d'applications utilisant l'IEEE 802 comme couches de protocole inférieures, une extension a été apportée au protocole IEEE 802.2 sous la forme du protocole d'accès au sous-réseau (SNAP : Subnetwork Access Protocol) (voir figure 2-3).</p>
                    <img src="../images/trame_IEEE_SNAP.PNG" alt="">
                    <p>Il s'agit d'une extension de l'en-tête LSAP de la figure 2-2, et son utilisation est indiquée par la valeur 170 dans les champs SSAP et DSAP de la trame LSAP (figure 2-3).</p>
                    <h5>Commutateur Ethernet :</h5>
                    <p>Les objectifs de la commutation sont :</p>
                    <ul>
                        <li>
                            <p>performance</p>
                        </li>
                        <li>
                            <p>isolation des collisions</p>
                        </li>
                        <li>
                            <p>segmentation logique</p>
                        </li>
                    </ul>
                    <p>Les commutateurs Ethernet relient plusieurs appareils entre eux en les câblant physiquement au même commutateur ou à des appareils connectés à un autre commutateur relié au même réseau. Ces câbles comprennent les câbles coaxiaux, les câbles à fibres optiques et les câbles Ethernet à paires torsadées.</p>
                    <p>Lorsqu'un appareil est connecté à un port, le commutateur Ethernet gère le flux de données entre cet appareil et les autres appareils. Le processus de commutation dirige les données entrantes et sortantes vers le bon port du commutateur en fonction du port de l'appareil émetteur et des adresses MAC de l'émetteur et du destinataire. Les adresses MAC de l'expéditeur et du destinataire sont incluses dans les données envoyées dans une trame Ethernet.</p>
                    <p>Chaque appareil compatible Ethernet possède une adresse physique codée en dur, appelée adresse MAC, cette adresse physique est utilisée par le commutateur pour identifier l'appareil de manière unique.</p>
                    <p>Lorsqu'un comutateur reçoit une trame Ethernet, il enregistre l'adresse MAC de l'appareil émetteur et le port auquel il est connecté dans une table locale appelée table d'adresses MAC (MAC Address Table). Le processus de commutation vérifie ensuite la table d'adresses MAC pour voir si l'adresse MAC de destination est connectée au même commutateur. Si c'est le cas, le commutateur transmet la trame au port de destination connu. Dans le cas contraire, le commutateur diffuse la trame à tous les ports et attend une réponse.</p>
                    <p>Si le commutateur est connecté directement à l'appareil de destination, celui-ci accepte la trame de données, répond et la transmission est terminée. Si l'appareil est connecté à un autre commutateur, le commutateur suivant répète le processus de recherche et de transmission jusqu'à ce que la trame atteigne la destination prévue.</p>
                    <p>On dit que les commutateurs agissent au niveau de la couche 2, cela veut dire qu'ils sont capables de modifier la trame Ethernet pour ajouter ou modifier l'un ou l'autre champ de la trame Ethernet. La figure 2-5 montre une insertion du marquage 802.1Q (VLAN Tagging).</p>
                    <img src="../images/trame_EthernetII_802.1Q.PNG" alt="">
                </article>
                <article>
                    <h2 id="exercices_analyse_paquets_trames_L2_L3">Exercices : Analyse de paquets et trames - Layer 2 &amp; Layer 3 :</h2>
                    <h3>Installation de Scapy :</h3>
                    <p>Pour cette partie du cours, il faut installer et télécharger <a href="https://www.python.org/downloads/" target="_blank">Python</a>.</p>
                    <p>N'oubliez pas de cocher <q class="em">Add Python to PATH</q> pendant l'installation. Vous pouvez vérifier l'installation :</p>
<pre><code>python --version</code></pre>
<pre><code>pip --version</code></pre>
                    <p>Le dossier `<span class="em">C:\Users\driss\AppData\Roaming\Python\Python313\Scripts\</span>` est important car il contient <span class="em">pip</span>, <span class="em">scapy</span>, et autres scripts Python. Ce dossier doit être <span class="em">ajouté au PATH</span> si ce n'est pas fait automatiquement.</p>
                    <p>Avant d'installer les bibliothèques nécessaires, il est recommandé de mettre à jour <span class="em">pip</span> :</p>
<pre><code>python -m pip install --upgrade pip</code></pre>
                    <p>Dans un terminal (PowerShell ou CMD), on installe Scapy avec la commande suivante :</p>
<pre><code>pip install scapy</code></pre>
                    <p>Pour vérifier l'installation :</p>
<pre><code>python
&gt;&gt;&gt; from scapy.all import *
&gt;&gt;&gt; ls()</code></pre>
                    <p>Pour envoyer/sniffer des paquets, il faut lancer le terminal <span class="em">en administrateur</span> et installer <a href="https://npcap.com/#download" target="_blank">Npcap</a> (mode WinPcap compatible).</p>
                    <p>Pour permettre l'export graphique des paquets (fonction <span class="em">canvas_dump()</span>), il est également nécessaire d'installer la librairie <span class="em">PyX</span> :</p>
<pre><code>pip install pyx</code></pre>
                    <p><span class="em">IPython</span> est utilisé pour bénéficier d'un shell interactif amélioré, particulièrement adapté à l'utilisation de Scapy. Voici la commande pour installer <span class="em">IPython</span> :</p>
<pre><code>pip install ipython</code></pre>
                    <p>Il faut télécharger et installer <a href="https://miktex.org/download" target="_blank">MiKTeX</a> et accepter l'installation automatique des packages LaTeX.</p>
                    <p>N'oubliez pas de vérifier que le dossier binaire `<span class="em">C:\Users\driss\AppData\Local\Programs\MiKTeX\miktex\bin\x64\</span>` soit bien ajouté dans les variables d'environnement.</p>
                    <p>Pour vérifier que l'installation de MiKTeX a bien fonctionnée, il faut taper la commande suivante :</p>
<pre><code>pdflatex --version</code></pre>
                    <p>Cet outil est utile pour générer des PDF (par exemple : <span class="em">canvas_dump().writePDFfile()</span> dans Scapy).</p>
                    <h3>Commandes et fonctions Scapy les plus utilisées :</h3>
                    <h4>Construction des couches :</h4>
<pre><code>Ether() # Couche Ethernet (L2)
IP() # Couche IP (L3)
ICMP() # Protocole ICMP (ping)
TCP() # Protocole TCP
UDP() # Protocole UDP
Raw() # Données brutes</code></pre>
                    <p>Par exemple :</p>
<pre><code>paquet = Ether() / IP(dst="8.8.8.8") / ICMP()</code></pre>
                    <h4>Exploration et aide :</h4>
<pre><code>ls() # Liste les champs d'une couche
lsc() # Liste les commandes Scapy disponibles
help(IP) # Aide détaillée sur IP
explore() # Explorer les couches (layers) et les contributions (contribs)</code></pre>
                    <p>Par exemple, la commande <span class="em">ls(IP())</span> affiche tous les champs (fields) de la couche IP avec :</p>
                    <ul>
                        <li>
                            <p>leur nom,</p>
                        </li>
                        <li>
                            <p>leur type,</p>
                        </li>
                        <li>
                            <p>leur valeur par défaut.</p>
                        </li>
                    </ul>
                    <p>En gros, <q>À quoi ressemble un paquet IP et quels paramètres je peux modifier ?</q></p>
                    <p>La commande <span class="em">lsc()</span> (List Scapy Commands) :</p>
                    <ul>
                        <li>
                            <p>affiche la liste des fonctions/commandes disponibles,</p>
                        </li>
                        <li>
                            <p>est une aide rapide textuelle,</p>
                        </li>
                        <li>
                            <p>ne lance aucune interface, aucun menu interactif.</p>
                        </li>
                    </ul>
                    <p>La commande <span class="em">explore()</span> permet une exploration interactive des protocoles :</p>
                    <ul>
                        <li>
                            <p>lance une interface interactive (menus),</p>
                        </li>
                        <li>
                            <p>permet de naviguer dans les couches et champs des paquets,</p>
                        </li>
                        <li>
                            <p>très utile pour apprendre la structure de protocoles.</p>
                        </li>
                    </ul>
                    <h4>Envoi et réception :</h4>
<pre><code>send(paquet) # Envoi sans attendre de réponse
sr(paquet) # Envoi + réponses multiples
sr1(paquet) # Envoi + une seule réponse</code></pre>
                    <h4>Analyse et affichage :</h4>
<pre><code>paquet.show() # Affichage détaillé
paquet.summary() # Résumé court
hexdump(paquet) # Contenu hexadécimal</code></pre>
                    <h4>Export :</h4>
<pre><code>c = paquet.canvas_dump()
c.writePDFfile("paquet.pdf")</code></pre>
                    <h4>Exemple :</h4>
<pre><code>from scapy.all import *

# Construction du paquet DNS
dns_packet = (
    IP(dst="8.8.8.8") /
    UDP(sport=RandShort(), dport=53) /
    DNS(
        rd=1, # Recursion Desired
        qd=DNSQR(qname="www.ephec.be", qtype="A")
    )
)

# Envoi du paquet et réception de la réponse
response = sr1(dns_packet, verbose=0, timeout=2)

# Affichage du paquet et de la réponse
dns_packet.show()
if response :
    response.show()
else :
    print("Aucune réponse DNS reçue")

# c = dns_packet.canvas_dump()
# c.writePDFfile("dns_packet.pdf")</code></pre>
                    <p>Que fait le code précédent ?</p>
                    <ul>
                        <li>
                            <p>Il fabrique une requête DNS.</p>
                        </li>
                        <li>
                            <p>Il l'envoie au serveur DNS 8.8.8.8 (Google).</p>
                        </li>
                        <li>
                            <p>Il demande l'adresse IPv4 (A) du domaine www.ephec.be.</p>
                        </li>
                        <li>
                            <p>Il attend la réponse DNS.</p>
                        </li>
                    </ul>
                    <p>En clair, c'est un équivalent de <span class="em">nslookup www.ephec.be 8.8.8.8</span>.</p>
                    <h3>Questions :</h3>
                    <ol>
                        <li>
                            <p>À partir de la trame Ethernet fournie, identifiez l'adresse MAC source et destination. Indiquez s'il s'agit d'un trafic unicast, multicast ou broadcast et justifiez.</p>
                            <img src="../images/trame_Ethernet(1).PNG" alt="">
                            <p>Dans une trame Ethernet, les six premiers octets sont l'adresse MAC de destination et les six octets suivants l'adresse MAC source.</p>
                            <p>On détermine le type à partir de l'adresse MAC de destination :</p>
                            <ul>
                                <li>
                                    <h3>Unicast :</h3>
                                    <p>Premier octet &#8594; bit de poids faible = 0</p>
                                    <p>Exemple : 00:1A:2B:3C:4D:5E</p>
                                </li>
                                <li>
                                    <h3>Multicast :</h3>
                                    <p>Bit de poids faible du premier octet = 1</p>
                                    <p>Exemple : 01:00:5E:xx:xx:xx (IPv4 multicast)</p>
                                </li>
                                <li>
                                    <h3>Broadcast :</h3>
                                    <p>FF:FF:FF:FF:FF:FF</p>
                                </li>
                            </ul>
                            <p>En résumé, le bit I/G (Individual/Group) du premier octet de l'adresse MAC de destination indique si l'adresse est individuelle (unicast) ou de groupe (multicast/broadcast).</p>
                        </li>
                        <li>
                            <p>Analysez deux trames différentes et déterminez laquelle utilise Ethernet II et laquelle utilise IEEE 802.3 avec LLC. Quels champs permettent de les différencier ?</p>
                            <img src="../images/trame_Ethernet(2).PNG" alt="">
                            <p>Le champ situé après les adresses MAC fait la différence :</p>
                            <ul>
                                <li>
                                    <h3>Ethernet II :</h3>
                                    <p>Champ = Type (EtherType) &gt;= <span class="em">0x600</span> (1536)</p>
                                    <p>Exemples : <span class="em">0x0800</span> (IPv4), <span class="em">0x0806</span> (ARP)</p>
                                </li>
                                <li>
                                    <h3>IEEE 802.3 + LLC :</h3>
                                    <p>Champ = Longueur &lt;= 1500</p>
                                    <p>Suivi d'un en-tête LLC (DSAP, SSAP, Control)</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Sur la trame VLAN 802.1Q, identifiez le VLAN ID, le champ PCP et le champ DEI. Quelle est la signification de ces champs ?</p>
                            <p>Après l'adresse MAC source, on trouve un <span class="em">tag VLAN (4 octets)</span>.</p>
                            <h3>Champs :</h3>
                            <ul>
                                <li>
                                    <p><span class="em">TPID</span> : <span class="em">0x8100</span> (indique présence VLAN)</p>
                                </li>
                                <li>
                                    <p><span class="em">TCI</span> (Tag Control Information) :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">PCP (3bits)</span> (Priority Code Point) : Priorité QoS (0-7).</p>
                                        </li>
                                        <li>
                                            <p><span class="em">DEI (1 bit)</span> (Drop Eligible Indicator) : indique qu'une trame peut être supprimée en cas de congestion.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">VLAN ID (12 bits)</span> : Identifiant du VLAN (1 à 4094).</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Pourquoi certaines trames observées sur un lien trunk ne contiennent-elles pas de tag VLAN ? Quel risque de sécurité cela peut-il introduire ?</p>
                            <p>Parce que les trames appartiennent au <span class="em">VLAN natif</span> et le choix de configuration (compatibilité avec équipements anciens).</p>
                            <p>Les risques de sécurité sont  la mauvaise isolation des domaines de diffusion et le <span class="em">VLAN hopping</span> (injection de trames non taguées permettant un accès non autorisé à un autre VLAN).</p>
                            <p>Bonne pratique : VLAN natif inutilisé + tagging systématique.</p>
                        </li>
                        <li>
                            <p>Identifiez des paquets IP fragmentés. Relevez l'identification, les flags et le fragment offset. Combien de fragments composent le paquet original ?</p>
                            <img src="../images/trame_Ethernet(3).PNG" alt="">
                            <h3>Champs à observer (en-tête IPv4) :</h3>
                            <ul>
                                <li>
                                    <p><span class="em">Identification</span> : identique pour tous les fragments.</p>
                                </li>
                                <li>
                                    <p><span class="em">Flags</span> :</p>
                                    <ul>
                                        <li>
                                            <p>MF (More Fragments) = 1 &#8594; autres fragments suivent.</p>
                                        </li>
                                        <li>
                                            <p>DF = 0 (sinon pas de fragmentation).</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Fragment Offset</span> : Position du fragment (en multiples de 8 octets).</p>
                                </li>
                            </ul>
                            <h3>Nombre de fragments :</h3>
                            <ul>
                                <li>
                                    <p>Dernier fragment : MF = 0.</p>
                                </li>
                                <li>
                                    <p>Nombre total = nombre de fragments observés avec même <span class="em">Identification</span>.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Analysez une trame utilisant LLC/SNAP. Identifiez les champs DSAP, SSAP et Control. Quel protocole de couche supérieure est encapsulé ?</p>
                            <h3>Champs LLC :</h3>
                            <ul>
                                <li>
                                    <p><span class="em">DSAP</span> : Destination Service Access Point.</p>
                                </li>
                                <li>
                                    <p><span class="em">SSAP</span> : Source Service Access Point.</p>
                                </li>
                                <li>
                                    <p><span class="em">Control</span> : type de trame (souvent <span class="em">0x03</span> &#8594; U-frame).</p>
                                </li>
                            </ul>
                            <h3>SNAP (si DSAP = SSAP = <span class="em">0xAA</span>) :</h3>
                            <ul>
                                <li>
                                    <p><span class="em">OUI</span> (3 octets).</p>
                                </li>
                                <li>
                                    <p><span class="em">PID</span> (2 octets) &#8594; équivalent EtherType.</p>
                                </li>
                            </ul>
                            <p>Exemple : PID <span class="em">0x0800</span> &#8594; IPv4.</p>
                        </li>
                        <li>
                            <p>À partir d'un paquet IPv4, identifiez tous les champs de l'en-tête IP et calculez la taille réelle des données transportées.</p>
                            <h3>Champs de l'en-tête IP :</h3>
                            <ul>
                                <li>
                                    <p>Version</p>
                                </li>
                                <li>
                                    <p>IHL (Internet Header Length)</p>
                                </li>
                                <li>
                                    <p>DSCP /ECN</p>
                                </li>
                                <li>
                                    <p>Total Length</p>
                                </li>
                                <li>
                                    <p>Identification</p>
                                </li>
                                <li>
                                    <p>Flags</p>
                                </li>
                                <li>
                                    <p>Fragment Offset</p>
                                </li>
                                <li>
                                    <p>TTL</p>
                                </li>
                                <li>
                                    <p>Protocol (TCP=6, UDP=17, ICMP=1)</p>
                                </li>
                                <li>
                                    <p>Header Checksum</p>
                                </li>
                                <li>
                                    <p>IP source</p>
                                </li>
                                <li>
                                    <p>IP destination</p>
                                </li>
                                <li>
                                    <p>Options (si IHL &gt; 5)</p>
                                </li>
                            </ul>
                            <h3>Taille réelle des données :</h3>
                            <p>Données = Total Length - (IHL * 4)</p>
                        </li>
                        <li>
                            <p>Analysez la valeur du TTL sur plusieurs paquets consécutifs. Que pouvez-vous déduire sur le chemin réseau parcouru ?</p>
                            <p>TTL diminue de <span class="em">1 à chaque routeur</span>.</p>
                            <p>Les valeurs initiales courantes sont :</p>
                            <ul>
                                <li>
                                    <p>Linux/Unix : 64</p>
                                </li>
                                <li>
                                    <p>Windows : 128</p>
                                </li>
                                <li>
                                    <p>Cisco : 255</p>
                                </li>
                            </ul>
                            <h3>Déduction :</h3>
                            <ul>
                                <li>
                                    <p>Différence entre TTL initial supposé et TTL observé &#8776; <span class="em">nombre de sauts</span>.</p>
                                </li>
                                <li>
                                    <p>Permet d'estimer la distance réseau (comme traceroute).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>À partir d'échanges ICMP, distinguez les messages de type Query et Error.</p>
                            <h3>ICMP Query (requête/réponse) :</h3>
                            <ul>
                                <li>
                                    <p>Echo Request (Type 8)</p>
                                </li>
                                <li>
                                    <p>Echo Reply (Type 0)</p>
                                </li>
                                <li>
                                    <p>Timestamp</p>
                                </li>
                                <li>
                                    <p>Address Mask</p>
                                </li>
                            </ul>
                            <p>&#8594; Outils de diagnostic (ping).</p>
                            <h3>ICMP Error :</h3>
                            <ul>
                                <li>
                                    <p>Destination Unreachable (Type 3)</p>
                                </li>
                                <li>
                                    <p>Time Exceeded (Type 11)</p>
                                </li>
                                <li>
                                    <p>Redirect</p>
                                </li>
                                <li>
                                    <p>Parameter Problem</p>
                                </li>
                            </ul>
                            <p>&#8594; Signalent une anomalie réseau.</p>
                        </li>
                        <li>
                            <p>Analysez un échange ARP. Pourquoi la requête est-elle envoyée en broadcast et la réponse en unicast ?</p>
                            <h3>Requête ARP :</h3>
                            <ul>
                                <li>
                                    <p>Destination MAC : <span class="em">FF:FF:FF:FF:FF:FF</span></p>
                                </li>
                                <li>
                                    <p>Pourquoi ? &#8594; L'émetteur ne connaît pas l'adresse MAC du destinataire.</p>
                                </li>
                            </ul>
                            <h3>Réponse ARP :</h3>
                            <ul>
                                <li>
                                    <p>Envoyée en <span class="em">unicast</span>.</p>
                                </li>
                                <li>
                                    <p>Le demandeur est maintenant connu.</p>
                                </li>
                            </ul>
                            <p>&#8594; Optimisation du trafic et efficacité réseau.</p>
                        </li>
                        <li>
                            <p>À partir d'un paquet complet, identifiez toutes les couches d'encapsulation présentes (L2 à L4). Expliquez l'ordre d'encapsulation.</p>
                            <p>Exemple typique :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Ethernet (L2)</span> : MAC source/destination</p>
                                </li>
                                <li>
                                    <p><span class="em">VLAN 802.1Q (optionnel)</span></p>
                                </li>
                                <li>
                                    <p><span class="em">IP (L3)</span> : Adressage logique, routage</p>
                                </li>
                                <li>
                                    <p><span class="em">TCP / UDP / ICMP (L4)</span> : Ports, fiabilité, contrôle</p>
                                </li>
                            </ol>
                            <h3>Ordre d'encapsulation :</h3>
<pre><code>Données applicatives
&#8594; L4 (TCP/UDP)
&#8594; L3 (IP)
&#8594; L2 (Ethernet)
&#8594; Bits sur le média</code></pre>
                            <p>Chaque couche encapsule la précédente en ajoutant son propre en-tête (et parfois un trailer).</p>
                        </li>
                    </ol>
                    <h3>Exemple de trame Ethernet :</h3>
                    <img src="../images/exemple_trame_Ethernet.PNG" alt="">
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Champ</th>
                                <th>Octets</th>
                                <th>Adresse MAC</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>MAC destination</td>
                                <td>00104b30c440</td>
                                <td>00:10:4B:30:C4:4A</td>
                            </tr>
                            <tr>
                                <td>MAC source</td>
                                <td>00a0cc30c8db</td>
                                <td>00:A0:CC:30:C8:DB</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Premier octet de l'adresse MAC de destination : 00 &#8594; 00000000</p>
                    <p>Bit I/G (LSB) = 0</p>
                    <p>&#9989; Trafic Unicast.</p>
                    <p>Champ après les adresses MAC : 0800</p>
                    <ul>
                        <li>
                            <p>Valeur hexadécimale : 0x0800</p>
                        </li>
                        <li>
                            <p>0x0800 = IPv4</p>
                        </li>
                        <li>
                            <p>&gt;= 0x0600 (1536)</p>
                        </li>
                    </ul>
                    <p>&#9989; Il s'agit d'une trame Ethernet II.</p>
                    <p>Début de l'en-tête IP : <span class="em">450005dc4c1d20002001b010a0063020a000108</span></p>
                    <h4>Champs IPv4 :</h4>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Champ</th>
                                <th>Valeur</th>
                                <th>Interprétation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Version</td>
                                <td>4</td>
                                <td>IPv4</td>
                            </tr>
                            <tr>
                                <td>IHL</td>
                                <td>5</td>
                                <td>20 octets</td>
                            </tr>
                            <tr>
                                <td>Type de service (ToS)</td>
                                <td>00</td>
                            </tr>
                            <tr>
                                <td>Total Length</td>
                                <td>0x05dc</td>
                                <td>1500 octets</td>
                            </tr>
                            <tr>
                                <td>Identification</td>
                                <td>0x4c1d</td>
                                <td>ID du paquet</td>
                            </tr>
                            <tr>
                                <td>Flags</td>
                                <td>001</td>
                                <td>DF=1,MF=0</td>
                            </tr>
                            <tr>
                                <td>Fragment Offset</td>
                                <td>0</td>
                                <td>Pas de fragmentation</td>
                            </tr>
                            <tr>
                                <td>TTL</td>
                                <td>0x20</td>
                                <td>32</td>
                            </tr>
                            <tr>
                                <td>Protocol</td>
                                <td>0x01</td>
                                <td>ICMP</td>
                            </tr>
                            <tr>
                                <td>IP source</td>
                                <td>0a.00.63.02</td>
                                <td>10.0.99.2</td>
                            </tr>
                            <tr>
                                <td>IP destination</td>
                                <td>0a.00.01.08</td>
                                <td>10.0.1.8</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>&#10060; Aucune fragmentation.</p>
                    <ul>
                        <li>
                            <p>DF=1 &#8594; fragmentation interdite</p>
                        </li>
                        <li>
                            <p>MF=0</p>
                        </li>
                        <li>
                            <p>Offset=0</p>
                        </li>
                    </ul>
                    <p>Taille réelle des données : Données  Total Length - (IHL * 4) = 1500 - 20 = 1480 octets</p>
                    <h4>Analyse Layer 4 - ICMP :</h4>
                    <ul>
                        <li>
                            <p>Protocole=1 &#8794; ICMP</p>
                        </li>
                        <li>
                            <p>Payload lisible : séquence ASCII répétée (abcdef...)</p>
                        </li>
                    </ul>
                    <p>&#8594; Très typique d'un ICMP Echo Request/Reply (ping)</p>
                    <h4>Analyse du TTL - Déduction réseau :</h4>
                    <ul>
                        <li>
                            <p>TTL observé : 32</p>
                        </li>
                        <li>
                            <p>Valeurs initiales probables :</p>
                            <ul>
                                <li>
                                    <p>Linux/Unix &#8594; 64</p>
                                </li>
                                <li>
                                    <p>Windows &#8594; 128</p>
                                </li>
                            </ul>
                            <p>&#8594; Si origine Linux : 64 - 32 = ~32 routeurs.</p>
                            <p>&#8594; Paquet ayant traversé un nombre significatif de sauts (ou TTL volontairement fixé bas pour tests).</p>
                            <h4>Résumé des couches d'encapsulation :</h4>
                            <p>Ethernet II</p>
                            <p>&#8594; IPv4</p>
                            <p>&#8594; ICMP</p>
                            <p>&#8594; Données (payload ASCII)</p>
                            <h4>Ordre d'encapsulation :</h4>
                            <p>Données applicatives</p>
                            <p>&#8594; ICMP (L4)</p>
                            <p>&#8594; IP (L3)</p>
                            <p>&#8594; Ethernet (L2)</p>
                        </li>
                    </ul>
                    <h3>Exercice Scapy :</h3>
                    <p>À partir d'une <span class="em">trame réseau capturée à l'aide de Wireshark</span>, comme par exemple la trame ci-dessous, vous devez reconstruire le paquet équivalent en utilisant la librairie <span class="em">Scapy (Python)</span>.</p>
                    <img src="../images/trame_Ethernet(3).PNG" alt="">
                    <p>La trame observée correspond à une <span class="em">trame Ethernet</span> transportant un paquet <span class="em">IPv4</span> contenant un message <span class="em">ICMP Echo Request</span> avec une charge utile ASCII. Les différents champs des couches Ethernet, IP et ICMP (adresses, identifiant, TTL, type, code, etc.) doivent être identifiés à partir de la capture Wireshark.</p>
                    <p>À l'aide de Scapy, écrivez un script Python construisant le paquet <span class="em">couche par couche</span> (<span class="em">Ether()</span>, <span class="em">IP()</span>, <span class="em">ICMP()</span>) et y ajoutant la charge utile observée.</p>
                    <p>Le paquet reconstruit devra être affiché avec <span class="em">show()</span> et exporté sous forme graphique au format <span class="em">PDF</span> à l'aide de <span class="em">canvas_dump()</span>.</p>
                    <p>Les valeurs utilisées doivent correspondre fidèlement à celles observées dont la capture initiale.</p>
                    <p>Voici la solution dans le fichier `<span class="em">test_trame1.py</span>` :</p>
<pre><code>from scapy.all import *

# Construction du paquet
L2 = Ether(dst="00:10:4b:30:c4:4a", src="00:a0:cc:30:c8:db")
L3 = IP(src="10.0.99.2", dst="10.0.0.1", id=0x4c1d,ttl=32)
L4 = ICMP()

data = b"abcdefghijklmnopqrstuvwxyz" * 50  # payload

paquet = L2 / L3 / L4 / data

# Envoi du paquet et réception de la réponse
response = sr1(paquet, verbose=0, timeout=2)

# Affichage du paquet et de la réponse
paquet.show()
if response :
    response.show()
else :
    print("Aucune réponse reçue")

c = paquet.canvas_dump()
c.writePDFfile("test_trame1.pdf")</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>En ASCII, chaque caractère est associé à un <span class="em">nombre</span>. Tout repose sur la <span class="em">table ASCII</span>. L'astuce mnémotechnique très utile en réseau est de savoir que les minuscules ASCII commencent à <span class="em">0x61</span> et les majuscules à <span class="em">0x41</span>.</p>
                        <p>On peut vérifier rapidement en Python (ou Scapy) avec <span class="em">chr(0x61)</span> qui donne <span class="em">'a'</span> ou inversement avec <span class="em">hex(ord('a'))</span> qui donne <span class="em">'0x61'</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="TCP">TCP :</h2>
                    <h3>En-tête TCP :</h3>
                    <p>La représentation visuelle/pédagogique de l'en-tête de TCP ci-dessous met l'accent sur la taille des champs et la compréhension globale. Elle est surtout utilisée pour les cours, les slides et les explications théoriques. C'est plus intuitif et moins précis au niveau binaire.</p>
                    <img src="../images/TCP_HEADER1.png" alt="">
                    <p>Ou alors la représentation bit à bit ci-dessous qui montre exactement la position de chaque bit, l'ordre des flags (URG, ACK, PSH, RST, SYN, FIN) et le Data Offset (taille de l'en-tête). Cette seconde représentation est utilisée pour l'implémentation en C, l'analyse de paquets (Wireshark) et les examens plus techniques. C'est plus technique mais plus proche de la réalité en mémoire.</p>
                    <img src="../images/TCP_HEADER2.png" alt="">
                    <p>Voici les indicateurs (flags) TCP dans l'ordre exact où ils apparaissent dans l'en-tête (bit à bit) :</p>
                    <ul>
                        <li>
                            <h4>URG (Urgent) :</h4>
                            <p>L'indicateur <span class="em">URG</span> signale la présence de données urgentes dans le segment TCP. Lorsqu'il est activé, le champ <span class="em">Urgent Pointer</span> est valide et indique la fin des données urgentes. Cet indicateur est aujourd'hui rarement utilisé.</p>
                        </li>
                        <li>
                            <h4>ACK (Acknowledgment) :</h4>
                            <p>L'indicateur <span class="em">ACK</span> confirme la bonne réception des données. Lorsqu'il est positionné, le champ d'accusé de réception est valide et contient le numéro du prochain octet attendu. Après l'établissement de la connexion, ce flag est généralement activé dans la majorité des segments TCP.</p>
                        </li>
                        <li>
                            <h4>PSH (Push) :</h4>
                            <p>L'indicateur <span class="em">PSH</span> demande au récepteur de transmettre immédiatement les données à l'application, sans attendre que le tampon soit rempli. Il est principalement utilisé par des applications interactives telles que <span class="em">SSH</span> ou <span class="em">Telnet</span>.</p>
                        </li>
                        <li>
                            <h4>RST (Reset) :</h4>
                            <p>L'indicateur <span class="em">RST</span> provoque une réinitialisation immédiate de la connexion TCP. Il est utilisé en cas d'erreur, de tentative de connexion vers un port fermé ou lorsqu'une connexion est jugée invalide. Cette fermeture est brutale et ne suit pas la procédure normale FIN/ACK.</p>
                        </li>
                        <li>
                            <h4>SYN (Synchronize) :</h4>
                            <p>L'indicateur <span class="em">SYN</span> est utilisé pour initier une connexion TCP. Il permet la synchronisation des numéros de séquence entre les deux hôtes et intervient lors de la phase d'établissement de la connexion, notamment dans le <span class="em">three-way handshake</span>.</p>
                        </li>
                        <li>
                            <h4>FIN (Finish) :</h4>
                            <p>L'indicateur <span class="em">FIN</span> indique qu'un hôte n'a plus de données à transmettre et souhaite fermer la connexion de manière ordonnée. Chaque sens de communication étant indépendant, chaque hôte doit envoyer son propre segment FIN pour mettre fin complètement à la connexion TCP.</p>
                        </li>
                    </ul>
                    <h3>Communication TCP :</h3>
                    <p>Pour mettre fin à une connexion, l'indicateur de contrôle FIN (Finish) doit être défini dans l'en-tête de segment. Pour mettre fin à chaque session TCP unidirectionnelle, on utilise un échange en deux étapes, constitué d'un segment FIN et d'un segment ACK. Par conséquent, pour mettre fin à une seule conversation TCP, quatre échanges sont nécessaires pour mettre fin aux deux sessions (voir la figure 1 ci-dessous).</p>
                    <figure>
                        <img src="../images/etablissement_fermeture_connexion_TCP.PNG" alt="">
                        <figcaption>Figure 1 : Établissement et fermeture d'une connexion TCP (TCP Three-Way Handshake).</figcaption>
                    </figure>
                    <p><span class="em">Remarque</span> : les termes client et serveur sont utilisés ici pour simplifier l'explication, mais le processus d'interruption peut être initié par n'importe lequel des deux hôtes ayant une session ouverte.</p>
                    <p>Voici les différentes étapes du TCP Three-Way Handshake :</p>
                    <ol>
                        <li>
                            <p>Quand le client n'a plus de données à envoyer dans le flux, il envoie un segment dont l'indicateur FIN est défini.</p>
                        </li>
                        <li>
                            <p>Le serveur envoie un segment ACK pour informer de la bonne réception du segment FIN, afin de fermer la session du client au serveur.</p>
                        </li>
                        <li>
                            <p>Le serveur envoie un segment FIN au client pour mettre fin à la session du serveur au client.</p>
                        </li>
                        <li>
                            <p>Le client répond à l'aide d'un segment ACK pour accuser réception du segment FIN envoyé par le serveur.</p>
                        </li>
                    </ol>
                    <p>Quand le client n'a plus aucune donnée à transférer, il définit l'indicateur FIN dans l'en-tête d'un segment. Ensuite, le serveur de la connexion envoie un segment normal contenant des données dont l'indicateur ACK est défini en utilisant le numéro d'accusé de réception, confirmant ainsi que tous les octets de données ont été reçus. Quand la réception de tous les segments a été confirmée, la session est fermée.</p>
                    <p>La session dans l'autre sens est fermée selon le même processus. Le récepteur indique qu'il n'y a plus de données à envoyer en définissant l'indicateur FIN dans l'en-tête d'un segment envoyé à la source. Un accusé de réception confirme que tous les octets de données ont été reçus et que cette session, à son tour, se ferme.</p>
                    <p>Voir les figures 2 et 3 ci-dessous pour observer les indicateurs de contrôle FIN et ACK définis dans l'en-tête de segment, permettant ainsi l'interruption d'une session HTTP.</p>
                    <figure>
                        <img src="../images/interruption_session_TCP_FIN.png" alt="">
                        <figcaption>Figure 2 : Interruption de session TCP (FIN).</figcaption>
                    </figure>
                    <p>Un analyseur de protocole affiche les détails de la trame 16 (requête FIN TCP).</p>
                    <figure>
                        <img src="../images/interruption_session_TCP_ACK.png" alt="">
                        <figcaption>Figure 3 : Interruption de session TCP (ACK)</figcaption>
                    </figure>
                    <p>Un analyseur de protocole affiche les détails de la trame 17 (réponse ACK TCP).</p>
                    <p>Il est également possible de fermer la connexion à l'aide d'une connexion en trois étapes. Quand le client n'a plus de données à envoyer, il envoie un segment FIN au serveur. Si le serveur n'a plus de données à envoyer, il peut répondre en définissant les indicateurs FIN et ACK simultanément et en combinant ainsi deux étapes en une. Le client répond par un segment ACK.</p>
                    <h3>Contrôle de flux :</h3>
                    <img src="../images/controle_flux_TCP.png" alt="">
                    <p>Ce schéma illustre le mécanisme de <span class="em">contrôle de flux</span> de TCP, utilisant ce qu'on appelle une <span class="em">fenêtre glissante (sliding window)</span>.</p>
                    <p>Il montre comment un récepteur utilise le champ "Window" (WIN) pour indiquer au moteur d'envoi la quantité de données qu'il peut encore accepter dans son tampon (buffer) afin d'éviter d'être submergé.</p>
                    <p>Voici l'explication étape par étape du diagramme :</p>
                    <ol>
                        <li>
                            <h4>Envoi initial (2K) :</h4>
                            <ul>
                                <li>
                                    <p>L'application de l'expéditeur (Sender) écrit <span class="em">2 Ko</span> de données.</p>
                                </li>
                                <li>
                                    <p>Le paquet est envoyé avec un numéro de séquence <span class="em">SEQ = 0</span>.</p>
                                </li>
                                <li>
                                    <p>À la réception, le tampon du destinataire (Receiver Buffer), d'une taille de <span class="em">4 Ko</span>, est à moitié rempli (2 Ko occupés, 2 Ko libres).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Premier Accusé de réception (ACK) :</h4>
                            <ul>
                                <li>
                                    <p>Le récepteur répond avec <span class="em">ACK = 2048</span>, confirmant qu'il a bien reçu les 2048 octets (2 Ko) et qu'il attend l'octet suivant à partir de 2048.</p>
                                </li>
                                <li>
                                    <p>Il précise <span class="em">WIN = 2048</span>, indiquant qu'il lui reste exactement <span class="em">2 Ko d'espace libre</span> dans son tampon.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Deuxième envoi et saturation (Application writes 3K) :</h4>
                            <ul>
                                <li>
                                    <p>L'expéditeur tente d'écrire <span class="em">3 Ko</span>, mais comme la fenêtre annoncée précédemment n'était que de <span class="em">2 Ko</span>, il n'envoie qu'un segment de <span class="em">2 Ko</span> avec <span class="em">SEQ = 2048</span>.</p>
                                </li>
                                <li>
                                    <p>Une fois ces 2 Ko reçus, le tampon du récepteur est <span class="em">full (plein)</span> (4 Ko / 4 Ko).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Blocage de l'expéditeur (Sender Blocked) :</h4>
                            <ul>
                                <li>
                                    <p>Le récepteur envoie un <span class="em">ACK = 4096</span>, confirmant qu'il a bien reçu les 4 Ko au total.</p>
                                </li>
                                <li>
                                    <p>Il annonce une fenêtre <span class="em">WIN = 0</span>, ce qui signifie : <q>J'ai tout reçu, mais je n'ai plus de place. Arrête d'envoyer !</q>.</p>
                                </li>
                                <li>
                                    <p>L'expéditeur est alors bloqué et ne peut plus transmettre de données.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Libération d'espace (System reads 2K) :</h4>
                            <ul>
                                <li>
                                    <p>L'application côté récepteur lit <span class="em">2 Ko</span> de données depuis la mémoire tampon, ce qui libère de l'espace.</p>
                                </li>
                                <li>
                                    <p>Le récepteur envoie alors un nouvel accusé de réception (<span class="em">ACK = 4096</span>) avec une mise à jour de la fenêtre : <span class="em">WIN = 2048</span>.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Reprise de la transmission :</h4>
                            <ul>
                                <li>
                                    <p>L'expéditeur voit qu'il y a de nouveau de la place. Il est autorisé à transmettre ("Sender clear to transmit").</p>
                                </li>
                                <li>
                                    <p>Il envoie le reliquat des données (le <span class="em">1 Ko restant</span> des 3 Ko initialement prévus) avec <span class="em">SEQ = 4096</span>.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p><span class="em">En résumé,</span> ce schéma démontre que TCP adapte dynamiquement le débit de l'expéditeur en fonction de la capacité de traitement et de stockage du récepteur, garantissant ainsi qu'aucune donnée n'est perdue par débordement de tampon.</p>
                    <p>À la suite de ce qui est présenté sur l'image, le dialogue se poursuit pour finaliser l'envoi des données et mettre à jour l'état du tampon. Voici la suite logique de l'échange :</p>
                    <ul>
                        <li>
                            <p><span class="em">Réception du segment de 1 Ko</span> : Le récepteur reçoit le paquet de <span class="em">1 Ko</span> envoyé avec <span class="em">SEQ = 4096</span>.</p>
                        </li>
                        <li>
                            <p><span class="em">Mise à jour du tampon</span> : Le tampon du récepteur, qui avait <span class="em">2 Ko</span> de libre, contient désormais <span class="em">3 Ko de données</span> (les <span class="em">2 Ko</span> restants de l'étape précédente + le nouveau <span class="em">1 Ko</span>). Il reste donc <span class="em">1 Ko d'espace libre</span>.</p>
                        </li>
                        <li>
                            <p><span class="em">Envoi d'un nouvel ACK</span> : Le récepteur envoie un accusé de réception pour confirmer la réception totale : <span class="em">ACK = 5120</span> (4096 + 1024).</p>
                        </li>
                        <li>
                            <p><span class="em">Annonce de la fenêtre (Window)</span> : Dans ce message, il indique <span class="em">WIN = 1024</span>, signifiant à l'expéditeur qu'il ne peut envoyer qu'un maximum de <span class="em">1 Ko</span> supplémentaire pour le moment.</p>
                        </li>
                        <li>
                            <p><span class="em">Libération continue</span> : Le dialogue continue ainsi jusqu'à ce que l'application cliente ait lu toutes les données du tampon ou que l'expéditeur n'ait plus rien à transmettre.</p>
                        </li>
                    </ul>
                    <h3>Application d'inscription et gestion d'étudiants en C :</h3>
                    <p>Cette application implémente un service client-serveur permettant l'inscription et la gestion d'étudiants à distance, en utilisant un protocole personnalisé reposant sur TCP, avec stockage des informations dans un fichier côté serveur.</p>
                    <p>Voici les différents fichiers de l'application :</p>
                    <ul>
                        <li>
                            <p>Le fichier `<span class="em">server.c</span>` est :</p>
<pre><code>#include "csock.h"
#include "myprotocol.h"
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;

typedef struct {
	int id;
	char nom[32];
	char prenom[32];
} etudiant_st;

struct liste {
	etudiant_st etudiant;
	struct liste *suivant;
};

typedef struct liste liste_etudiant;

liste_etudiant *tete_liste = NULL;

/* affiche la description of de tous les options supporté */

/* affiche la description of de tous les options supporté */
void usage (FILE *fp, const char *path) {
    /* prendre uniquement la derniere portion du chemin de fichier */
    const char *basename = strrchr(path, '/');
    basename = basename ? basename + 1 : path;

    fprintf (fp, "usage: %s [OPTION]\n", basename);
    fprintf (fp, "  -h, --help\t\t\tafficher cette aide et quitter.\n");
    fprintf (fp, "  -t, --transport [PROTOCOL]\tutiliser le protocol de transport (tcp ou udp).\n");
    fprintf (fp, "  -p, --port=STRING\t\tLe numero de port ou le nom du service à utilisé'.\n");
    fprintf (fp, " \nexemple :\n\t%s -t tcp -p 5656\n\t%s -t udp -p myprotocol\n", basename, basename);
}

liste_etudiant *initialisation() {
    FILE *fich;
    char nom[32], prenom[32];
    int id;

    liste_etudiant *liste = malloc(sizeof(*liste));

    if (liste == NULL) {
        exit(EXIT_FAILURE);
    }

    fich = fopen("etudiants.txt", "r");
 
    if (fich == NULL) {
        printf("Erreur lors de l'ouverture du fichier etudiants");
        exit(1);
    }

    // lire les données à partie de fichier
    fscanf(fich, "%d %s %s\n", &id, nom, prenom);

    liste->etudiant.id = id;
    strcpy(liste-&gt;etudiant.nom, nom);
    strcpy(liste-&gt;etudiant.prenom, prenom);
    liste-&gt;suivant = NULL;

    tete_liste = liste;

    // tant que la fin du fichier n'est atteint lire les données
    // et stocker dans la liste
    while (!feof(fich)){
        liste->suivant = malloc(sizeof(*liste));
        liste = liste-&gt;suivant;

     	fscanf(fich, "%d %s %s\n", &id, nom, prenom);
    	liste-&gt;etudiant.id = id;
    	strcpy(liste-&gt;etudiant.nom, nom);
    	strcpy(liste-&gt;etudiant.prenom, prenom);
    	liste-&gt;suivant = NULL;
 
 	    // afficher les données chargées
    	//printf("ID : %d\tNom : %s\tPrenom : %s\n", id, nom, prenom);
    }
 
    fclose(fich);
 
    return tete_liste;
}

void ajouter_etudiant_s(int sock, message_t message_client) {
	int id;
	char nom[32];
	char prenom[32];

	liste_etudiant *liste;
	liste = tete_liste;

    sscanf(message_client.data, "%d %s %s", &id, nom, prenom);

	/* Aller à la fin de la liste des etudiant */
	while(liste-&gt;suivant != NULL) {
        	liste = liste-&gt;suivant;
    }

    liste-&gt;suivant = malloc(sizeof(liste_etudiant));
    liste = liste-&gt;suivant;
    liste-&gt;etudiant.id = id;
    strcpy(liste-&gt;etudiant.nom, nom);
    strcpy(liste-&gt;etudiant.prenom, prenom);
    liste-&gt;suivant = NULL;

    printf("Etudiant Ajouter :\n\tID : %d\tNom : %s\t\tPrenom : %s\n", liste-&gt;etudiant.id, liste-&gt;etudiant.nom, liste-&gt;etudiant.prenom);

    
	/* remplir la memoire occupé par message.data de O /
	memset(message.data, 'O', sizeof(char) * DATA_SIZE);
	
	/* ici j'aurai pu envoyer au client un message OK
	message.header.message_type = OK;
	// sprintf(buffer, "%d %s", message.header.message_type, message.data);
	send(sock, (const char *) &message, MESSAGE_SIZE, 0); */
}

void supprimer_etudiant_s(int sock, message_t message) {
	int id;
	int trouve = 0;

	liste_etudiant *liste, *courant, *precedent; 
	liste = courant = tete_liste;

 	sscanf(message.data, "%d", &id);
	printf("Recherche de l'etudiant avec l'ID : %d\n", id);

    // tant que la fin de liste n'est pas atteint
    // et stocker dans la liste
    liste = liste-&gt;suivant;
    while (courant != NULL && !trouve) {
    	if (courant->etudiant.id == id) {
          trouve = 1;
        } else {
        	precedent = courant;
        	courant = liste;
        	liste = liste-&gt;suivant;
        }
    }
    if (trouve) {
		printf("Etudiant trouvé (et supprimé) : \n\t%d\n\t%s\n\t%s\n", courant-&gt;etudiant.id, courant-&gt;etudiant.nom, courant-&gt;etudiant.prenom);
    	precedent-&gt;suivant = courant-&gt;suivant;
    	free(courant);
    } else {
    	printf("Etudiant (ID : %d) non trouvé !\n", id);
    }
}

void envoyer_etudiant(int sock, message_t message_client) {
	int id;

	message_t my_message;
	char nom[32], prenom[32];

	int trouve = 0;

	sscanf(message_client.data,"%d", &id);
	liste_etudiant *liste; 
	liste = tete_liste;

	while (liste != NULL && !trouve) {
    	if (liste-&gt;etudiant.id == id) {
          trouve = 1;
        } else {
        	liste = liste-&gt;suivant;
        }
    }
    
    if (trouve) {
		printf("Etudiant trouvé.\n");
		printf("Envoi vers le client :  \n\t%d\n\t%s\n\t%s\n", liste-&gt;etudiant.id, liste-&gt;etudiant.nom, liste-&gt;etudiant.prenom);
    	
		/* remplir la memoire occupé par message.data de S */
		memset(my_message.data, 'E', sizeof(char) * DATA_SIZE);
	
		/* ecrire les données dans message.data 
     	* l'espace restant est rempli de 'E' */
		sprintf(my_message.data, "%d %s %s ", liste-&gt;etudiant.id, liste-&gt;etudiant.nom, liste-&gt;etudiant.prenom);
		my_message.header.message_type = OK;
		send(sock, (const char *) &my_message, MESSAGE_SIZE, 0);   
    } else {
		my_message.header.message_type = INVALID_OPTION;
		send(sock, (const char *) &my_message, MESSAGE_SIZE, 0);   
    }
}

void envoyer_etudiants_liste(int sock, message_t message_client) {
	char bourage = 'A';
	message_t message;
	message.header.message_type = OK;
	
	liste_etudiant *liste; 
	liste = tete_liste;

	printf("Envoi de la liste des étudiants \n");

	while (liste != NULL) {
    	memset(message.data,bourage,DATA_SIZE);
    	sprintf(message.data, "%d %s %s \n", liste-&gt;etudiant.id, liste-&gt;etudiant.nom, liste-&gt;etudiant.prenom);

		printf("\tétudiants : %s\n",message.data);
		send(sock , (const char *) &message, MESSAGE_SIZE, 0 );
        liste = liste-&gt;suivant;
        bourage++; 
    }

	message.header.message_type = DONE;

	send(sock, (const char *) &message, MESSAGE_SIZE, 0);
}

void terminer_s(int sock) {
	printf("Fermeture de la connexion\n");
	close(sock);
}

int main(int argc, char *argv[]) {
	/*char service[32] = "5656"; 	/* n° de port par défaut */
	char service[32] = "myprotocol"; 	/* au lieu du n° de port on utilise le nom du service -> /etc/service */
	char transport[32] = "tcp"; 	/* n° de port par défaut */
	int mysock;			/* socket passive pour le serveur */
	int client_sock;			/* socket de communication (active) */
	struct sockaddr_in sin;		/* structure décrivant la socket active */
	int lsin = sizeof(sin);

	char buffer[100]; 			/* buffer pour accueillir les caractères */
	int operation;
    message_t message;
    int opt;

	liste_etudiant *tete_liste, *liste_etud; 

    /* Traitement des paramettres de la ligne de commande */
    struct option longopts[] = {
        { "help", no_argument, NULL, 'h' },
        { "transport", optional_argument, NULL, 't' },
        { "service", required_argument, NULL, 'p' },
        { 0 }
    };

	/* boucle infinie, jusqu'a la fin du parsing des options */
    while (1) {
        opt = getopt_long (argc, argv, "ht::p:", longopts, 0);

        if (opt == -1) {
            /* -1 indique q'il n y plus d'options */
            break;
        }

        switch (opt) {
        case 'h':
            usage(stderr, argv[0]);
            return 0;
            break;
        case 't':
            printf ("Protocole de transport : '%s'\n", optarg);
            strcpy(transport, optarg);
            break;
        case 'p':
            printf ("Service : '%s'\n", optarg);
            strcpy (service, optarg);
            break;
        case '?':
            /* '?' indique d'un option a été malformé: Option inconnu */
            usage (stderr, argv[0]);
            return 1;
        default:
            break;
        }
    }

	tete_liste = initialisation();
	liste_etud = tete_liste;
	
	while(liste_etud != NULL) {
    	printf("ID : %d --- Nom : %s  --- Prenom : %s\n", liste_etud-&gt;etudiant.id, liste_etud-&gt;etudiant.nom, liste_etud-&gt;etudiant.prenom);
    	liste_etud = liste_etud-&gt;suivant;
	}

	mysock = server_socket(service, "tcp", 5);
	puts("Attente de la connexion cliente...\n");

	/* attente de la connexion d'un client et création de la socket de communication 'client' */
	client_sock = accept(mysock, (struct sockaddr *) &sin, &lsin);
	
	/* Affichage de l'adresse IP du client */
	printf("Connexion depuis: %s\n", inet_ntoa(sin.sin_addr));
		/* fermeture de la socket */
	close(mysock);

	do {
		printf("Attente de requettes clients ... \n");

		read(client_sock, (const char *) &message, MESSAGE_SIZE);
		
		operation = message.header.message_type;

		switch(operation) {
			case ADD_STUDENT :
				ajouter_etudiant_s(client_sock, message);
				break;
			case DEL_STUDENT :
				supprimer_etudiant_s(client_sock, message);
				break;
			case GET_STUDENT :
				envoyer_etudiant(client_sock, message);
				break;
			case GET_STUDENT_LIST :
				envoyer_etudiants_liste(client_sock, message);
				break;
			case BYE :
				terminer_s(client_sock);
				break;
			default  :
				printf("erreur operation %d n'est pas valide\n", operation);
				break;
		}
	} while(operation != BYE && client_sock != 0);


	// printf("buffer de fen2 = %s\n", buffer);
	/* write(partenaire, caractere, sizeof(caractere)); */

	return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">client.c</span>` est :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;
#include "csock.h"
#include "myprotocol.h"

void usage (FILE *fp, const char *path) {
    /* prendre uniquement la derniere portion du chemin de fichier */
    const char *basename = strrchr(path, '/');
    basename = basename ? basename + 1 : path;

    fprintf (fp, "usage: %s [OPTION]\n", basename);
    fprintf (fp, "  -h, --help\t\t\tafficher cette aide et quitter.\n");
    fprintf (fp, "  -s, --server [STRING]\tl'adresse IP ou le nom du serveur.\n");
    fprintf (fp, "  -t, --transport [STRING]\tutiliser le protocol de transport (tcp ou udp).\n");
    fprintf (fp, "  -p, --port=STRING\t\tLe numero de port ou le nom du service à utilisé'.\n");
    fprintf (fp, " \nexemple :\n\t%s -s localhost -t tcp -p 5656\n\t%s -s 192.168.1.1 -t udp -p myprotocol\n", basename, basename);
}

void affiche_menu(){
	printf("===============================================================================\n");
	printf("Veuillez faire votre choix\n");
	printf("-------------------------------------------------------------------------------\n");
	printf("\t%d : pour initialiser la connexion avec le serveur.\n", INITIALIZE);
	printf("\t%d : pour ajouter un etudiant.\n", ADD_STUDENT);
	printf("\t%d : pour supprimer un etudiant.\n", DEL_STUDENT);
	printf("\t%d : pour afficher un etudiant.\n", GET_STUDENT);
	printf("\t%d : pour afficher tous les etudiants.\n", GET_STUDENT_LIST);
	printf("\t%d : pour Terminer.\n", BYE);
	printf("===============================================================================\n");
	printf("Votre choix : ");
}

void ajouter_etudiant_c(int sock) {
	int id;
	char nom[32];
	char prenom[32];
	message_t message;
	char buffer[MESSAGE_SIZE];
	printf("Veuillez donner l'ID de l'etudiant : ");
	scanf("%d", &id);
	printf("Veuillez donner le nom  de l'etudiant : ");
	scanf("%s", nom);
	printf("Veuillez donner le prenom de l'etudiant : ");
	scanf("%s", prenom);

	/* remplir la memoire occupée par message.data de A */
	memset(message.data, 'A', sizeof(char) * DATA_SIZE);
	
	/* ecrire les données dans message.data 
     * l'espace restant est rempli de 'A' */

	sprintf(message.data, "%d %s %s", id, nom, prenom);
	
	message.header.message_type = ADD_STUDENT;
	// sprintf(buffer,"%d %s", message.header.message_type, message.data);
	send(sock, (const char *) &message, MESSAGE_SIZE, 0);
}

void supprimer_etudiant_c(int sock) {
	int id;
	message_t message;
	char buffer[MESSAGE_SIZE];
	printf("Veuillez donner l'ID de l'etudiant à supprimer : ");
	scanf("%d", &id);

	/* remplir la memoire occupé par message.data de S */
	memset(message.data, 'S', sizeof(char) * DATA_SIZE);
	
	/* ecrire les données dans message.data 
     * l'espace restant est rempli de 'S' */

	sprintf(message.data, "%d", id);
	message.header.message_type = DEL_STUDENT;
	//sprintf(buffer, "%d %s", message.header.message_type, message.data);
	send(sock, (const char *) &message, MESSAGE_SIZE, 0 );
}

void afficher_etudiant_c(int sock) {
	int id;
	message_t message;
	char nom[32], prenom[32];
	char buffer[MESSAGE_SIZE];
	printf("Veuillez donner l'ID de l'etudiant à afficher : ");
	scanf("%d", &id);
	
	/* remplir la memoire occupé par message.data de S */
	memset(message.data, 'P', sizeof(char) * DATA_SIZE);
	
	/* ecrire les données dans message.data 
     * l'espace restant est rempli de 'S' */
	sprintf(message.data, "%d", id);
	message.header.message_type = GET_STUDENT;

	send(sock, (const char *) &message, MESSAGE_SIZE, 0);
	
	read(sock, (const char *) &message, MESSAGE_SIZE, 0);
	
	if (message.header.message_type == OK) {
		printf("Etudiant reçu :=:\t %s \n", message.data);
    } else {
		printf("Etudiant non trouvé!");
    }
}

void afficher_etudiants_liste_c(int sock) {
	message_t message;
	message.header.message_type = GET_STUDENT_LIST;
	
	/* envoyer la demande */
	send(sock, (const char *) &message, MESSAGE_SIZE, 0);
	
	/* reception de la liste */
	read(sock, (const char *) &message, MESSAGE_SIZE, 0);
	printf("Liste des étudiants reçu : \n");
	while (message.header.message_type != DONE) {
		printf("\tétudiant :%s \n", message.data);
		read(sock , (const char *) &message, MESSAGE_SIZE, 0);
	}
}

void terminer_c(int sock) {
	message_t message;
	message.header.message_type = BYE;
	send(sock, (const char *) &message, MESSAGE_SIZE, 0);
	printf("Fermeture de la connexion\n");
	close(sock);
}

int main(int argc,char *argv[]) {
	char service[32] = "5656"; 	/* n° de port par défaut */
	char transport[32] = "tcp"; 	/* n° de port par défaut */
	char server_address[32] = "localhost"; 	/* l'adresse du serveur */
	int choix;
	int sock = 0;

	int opt;

    /* Traitement des paramettres de la ligne de commande */
    struct option longopts[] = {
        { "help", no_argument, NULL, 'h' },
        { "server", optional_argument, NULL, 's' },
        { "transport", optional_argument, NULL, 't' },
        { "service", required_argument, NULL, 'p' },
        { 0 }
    };

	/* boucle infinie, jusqu'a la fin du parsing des options */
    while (1) {
        opt = getopt_long (argc, argv, "h:s:t:p:", longopts, 0);

        if (opt == -1) {
            /* -1 indique q'il n y plus d'options */
            break;
        }

        switch (opt) {
        case 'h':
            usage(stderr, argv[0]);
            return 0;
            break;
        case 's':
            printf ("Adresse Serveur : '%s'\n", optarg);
            strcpy(server_address, optarg);
            break;
        case 't':
            printf ("Protocole de transport : '%s'\n", optarg);
            strcpy(transport, optarg);
            break;
        case 'p':
            printf ("Service : '%s'\n", optarg);
            strcpy (service, optarg);
            break;
        case '?':
            /* '?' indique d'un option a été malformé: Option inconnu */
            usage (stderr, argv[0]);
            return 1;
        default:
            break;
        }
    }


	printf("DATASIZE = %d\n, MESSAGE_SIZE = %d\n", DATA_SIZE, MESSAGE_SIZE);
	//ajouter_etudiant(sock);

	do {
		affiche_menu();

		scanf("%d", &choix);

		switch(choix) {
			case INITIALIZE :
				if (sock == 0) {
					sock = client_socket(server_address,service,transport);
                } else {
					printf("connexion deja établi\n");
                }
				break;
			case ADD_STUDENT :
				if (sock != 0) {
					ajouter_etudiant_c(sock);
                } else {
					printf("pas de connexion avec le serveur\n");
                }
				break;
			case DEL_STUDENT :
				if (sock != 0) {
					supprimer_etudiant_c(sock);
                } else {
					printf("pas de connexion avec le serveur\n");
                }
				break;
			case GET_STUDENT :
				if (sock != 0) {
					afficher_etudiant_c(sock);
                } else {
					printf("pas de connexion avec le serveur\n");
                }
				break;
			case GET_STUDENT_LIST :
				if (sock != 0) {
					afficher_etudiants_liste_c(sock);
                } else {
					printf("pas de connexion avec le serveur\n");
                }
				break;
			case BYE :
				terminer_c(sock);
				break;
			default  :
				printf("erreur de saisi %d n'est pas valide\n", choix);
				break;
		}
	} while(choix != BYE);
	
	return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">etudiants.txt</span>` est :</p>
<pre><code>10 DEHERDT Gabiel
22 BAH Amadou
30 GEIST Lucas
20 KAMMEGNE Henri
28 PADOAN Carine
32 ARHBAL Nadia
54 AZGHAY Redouan
25 BOUTAGOUMANT Soufian
52 BOUZAMBOU Aädel
48 MITELLO Vincent
41 KAYUMBA Eric
14 ZEGGERS François
61 SENHAJI Mohamed
18 EL-KADOURY Abdelghani
47 VANDENHEEDE Driss</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">myprotocol.h</span>` est :</p>
<pre><code>/*********************************************************************************
*                               myprotocol.h                                     *
**********************************************************************************
* Auteur : Pierre Muhirwa                                                        *
* description : illustration de protocoles  
* 	Fichier d'entête contenant les types de données et de messages utilisés  *
* 	lors des échanges de données entre le serveur et le(s) clients           *
**********************************************************************************/

#ifndef _MYPROTOCOL_H
#define _MYPROTOCOL_H

/* la taille du payload */
#define DATA_SIZE 256

/* Les types de messages echangés entre les programmes client/serveur */
#define INITIALIZE 1  /* initialiser la connexion */
#define	ADD_STUDENT 2 /* inscrire un etudiant       */
#define	DEL_STUDENT 3 /* supprimer un etudiant    */
#define GET_STUDENT 4 /* envoyer un etudiant vers le client  */
#define GET_STUDENT_LIST 5 /* envoyer la liste de tous les etudiants */
#define OK 6
#define DONE 7
#define INVALID_OPTION 8
#define BYE 9

/* structure implementant l'entete de notre protocole */
typedef struct {
	uint8_t message_type;
	uint8_t message_length;
	uint8_t flags;
} header_t;

/* structure implementant le message (PDU) */
typedef struct {
	header_t header; /* l'entete de notre protocole */
	char data[DATA_SIZE]; /*le payload de notre protocole */
} message_t;

#define MESSAGE_SIZE sizeof(message_t)

#endif</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">csock.h</span>` est :</p>
<pre><code>/**************************************************************************
 * csock.h : Fichier en tete pour les fonctions utilisant les sockets     *
 * Auteur : Muhirwa Pierre                                                *
 **************************************************************************/

#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#ifndef INADDR_NONE
#define INADDR_NONE	0xffffffff
#endif

void error_socket(const char *format, ...);
int create_socket(const char *service, const char *transport, struct sockaddr_in *sin);
int client_socket(const char *host,const char *service, const char *transport);
int server_socket(const char *service, const char *transport, int lqueue);</code></pre>
                            <p>Le fichier `<span class="em">csock.c</span>` est :</p>
<pre><code>/**************************************************************************
 * csock.c : Fichier source pour les fonctions utilisant les sockets     *
 * Auteur : Muhirwa Pierre                                                *
 **************************************************************************/

#include "csock.h"

extern int errno;

void error_socket(const char *format, ...) {
	va_list args;
	va_start(args, format);
	vfprintf(stderr, format, args);
	va_end(args);
	exit(1);
}

int create_socket(const char *service, const char *transport, struct sockaddr_in *sin) {
	/* structure permettant de récupérer les informations numériques à partir
	   des nom de service(n° port) et de protocole transport (n° protocole)  */

	struct servent *iservice;
	struct protoent *itransport;
	int s, type, proto;

	/* initialisation de la structure socket   */
	memset(sin,0,sizeof(*sin));	/* mise à zéro */
	sin-&gt;sin_family = AF_INET;	/* Famille internet */

	/* Recherche du numéro de port */
	sin-&gt;sin_port = htons(atoi(service));

	/* Si le service n'était pas un numéro on le recherche dens /etc/services */
	if (!sin-&gt;sin_port) {
		iservice = getservbyname(service, transport);
		if (!iservice) {
			error_socket("Service non enregistré: %s\n", service);
        }
		sin-&gt;sin_port = iservice-&gt;s_port;
	}

	/* recherche du numéro de protocole */
	itransport = getprotobyname(transport);
	if (!itransport) {
		error_socket("Protocole non enregistré: %s\n", transport);
    }
	proto = itransport-&gt;p_proto;

	if (!strcmp(transport, "udp")) {
		type = SOCK_DGRAM; /* protocole UDP */
    } else {
		type = SOCK_STREAM; /* protocole TCP  */
    }

	/* creation de la socket */
	s = socket(AF_INET, type, proto);
	if (s &lt; 0) {
		error_socket("Création de socket impossible: %s", strerror(errno));
    }

	return s;
}

/**
 * Fonction qui crée une socket client : etablit une connexion avec le serveur
 * @param : 
 *	- host : une chaine de caractere qui conntien l'adresse du serveur.
 *	- service : le nom du service ou le numero de port 
 *		sous forme de chaine de caractere.
 *	- transport : protocole de transport utilisé "tcp" ou "udp".
 *	
 * @see : 
 	 - create_socket() : utilise cette fonction pour creer la socket
 * @return : la socket client (s)
 */

int client_socket(const char *host, const char *service, const char *transport) {
	/* structure décrivant la socket */
	struct sockaddr_in sin;
	struct hostent *ihost;

	int s;

	/* création de la socket  */
	s = create_socket(service, transport, &sin);

	/* recherche de l'adresse IP de host */
	sin.sin_addr.s_addr = inet_addr(host);
	/* si l'hôte n'est pas une adresse IP mais un nom, on recherche dans (/etc/host, dns )   */
	if (sin.sin_addr.s_addr == INADDR_NONE) {
		ihost = gethostbyname(host);
		if (!ihost) {
			error_socket("Hôte inconnu : %s\n", host);
        }
		memcpy(&sin.sin_addr, ihost-&gt;h_addr, ihost-&gt;h_length);
	}
	/* connexion de la socket   */
	if (connect(s, (struct sockaddr *) &sin, sizeof(sin)) &lt; 0) {
		error_socket("Impossible de se connecter à %s[%s]: %s", host, service,strerror(errno));
    }
	return s;
}


/**
 * Fonction qui crée une socket client : etablit une connexion avec le serveur
 * @param : 
 *	- host : une chaine de caractere qui conntien l'adresse du serveur.
 *	- service : le nom du service ou le numero de port 
 *		sous forme de chaine de caractere.
 *	- transport : protocole de transport utilisé "tcp" ou "udp".
 *	
 * @see : 
 	 - create_socket() : utilise cette fonction pour creer la socket
 * @return : la socket client (s)
 */

int server_socket(const char *service, const char *transport, int lqueue){
	/* structure décrivant la socket */
	struct sockaddr_in sin;

	int s;

	/* création de la socket */
	s = create_socket(service, transport, &sin);

	sin.sin_addr.s_addr = INADDR_ANY;

	/* Allocation du numéro de port */
	if (bind(s, (struct sockaddr *) &sin, sizeof(sin)) &lt; 0) {
		error_socket("Impossible de lier la socket à %s: %s\n", service, strerror(errno));
    }

	/* Placer la socket en mode passif si transport != "udp" */
	if (strcmp(transport, "udp") && listen(s, lqueue) &lt; 0)  {
		error_socket("Mode passif impossible sur %s: %s\n", service,strerror(errno));
    }
	return s;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">RFCXXXXX_MyProtocol.txt</span>` est :</p>
<pre><code>Network Working Group                                     P. Muhirwa
Request for Comments: MYPROTO-01                         (Example)
Category: Informational                                   Jan 2026

                MyProtocol - Simple Client/Server Protocol
                -------------------------------------------

Status of This Memo

   This document is an informational RFC-like specification that
   describes "MyProtocol", a simple application-layer protocol
   used to illustrate client/server exchanges.

   Distribution of this memo is unlimited.

1.  Introduction

   MyProtocol is a lightweight application protocol designed for
   educational purposes. It illustrates basic concepts such as
   protocol headers, message types, payloads, and request/response
   interactions between a client and a server.

   The protocol operates over a reliable transport (e.g. TCP) and
   uses a fixed-size Protocol Data Unit (PDU).

2.  Terminology

   The key words "MUST", "MUST NOT", "SHOULD", and "MAY" in this
   document are to be interpreted as described in RFC 2119.

   Client:
      An application initiating requests.

   Server:
      An application responding to client requests.

   PDU:
      Protocol Data Unit, represented by the message_t structure.

3.  Protocol Overview

   Communication is performed using messages composed of:
     - a fixed-size header
     - a fixed-size payload (data)

   All messages exchanged between the client and server share the
   same format. The semantics of the message are determined by the
   "message_type" field in the header.

4.  Message Format

   Each message (PDU) is defined as follows:

       0                   1                   2
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      +---------------+---------------+---------------+
      | message_type  | msg_length    | flags         |
      +---------------+---------------+---------------+
      |                                               |
      |               data (payload)                  |
      |                 256 bytes                     |
      |                                               |
      +-----------------------------------------------+

   Total message size: sizeof(message_t)

5.  Header Fields

5.1 message_type (1 byte)

   Indicates the type of message being exchanged.
   This field defines the operation to be performed or the meaning
   of the message.

5.2 message_length (1 byte)

   Indicates the length of meaningful data in the payload.
   The maximum value MUST NOT exceed DATA_SIZE (256).

5.3 flags (1 byte)

   Reserved for future use.
   This field is currently unused and MUST be set to 0.

6.  Payload (data)

   The payload is a character array of fixed size (256 bytes).
   Its interpretation depends on the message_type.

   If the payload contains a string, it SHOULD be null-terminated.
   Unused bytes MAY be set to zero.

7.  Message Types

   The following message types are defined:

   Value  Name               Description
   -----  -----------------  -------------------------------------
     1    INITIALIZE         Initialize a client/server connection
     2    ADD_STUDENT        Add a student record
     3    DEL_STUDENT        Delete a student record
     4    GET_STUDENT        Retrieve a single student
     5    GET_STUDENT_LIST   Retrieve all students
     6    OK                 Operation accepted
     7    DONE               Operation completed
     8    INVALID_OPTION     Unsupported or invalid request
     9    BYE                Terminate the connection

8.  Operations

8.1 Connection Initialization

   The client sends an INITIALIZE message to the server.
   The server replies with an OK message if the initialization
   succeeds.

8.2 Add Student

   The client sends an ADD_STUDENT message.
   The payload contains the student information.
   The server replies with OK followed by DONE.

8.3 Delete Student

   The client sends a DEL_STUDENT message with the student identifier
   in the payload.
   The server replies with DONE if the deletion succeeds.

8.4 Get Student

   The client sends a GET_STUDENT message.
   The server replies with a GET_STUDENT message containing the
   requested student data, or INVALID_OPTION if not found.

8.5 Get Student List

   The client sends a GET_STUDENT_LIST message.
   The server replies with one or more messages containing the list
   of students.

8.6 Termination

   Either peer MAY send a BYE message to terminate the session.
   No further messages MUST be sent after BYE.

9.  Error Handling

   If the server receives an unknown or unsupported message_type,
   it MUST respond with INVALID_OPTION.

   Malformed messages MAY be ignored.

10. Security Considerations

   This protocol provides no authentication, confidentiality, or
   integrity mechanisms. It is intended for demonstration purposes
   only and MUST NOT be used in production environments.

11. IANA Considerations

   This document has no IANA actions.

12. Author

   Pierre Muhirwa</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">Makefile</span>` est :</p>
<pre><code>all : client server

client : client.c myprotocol.h libcsock.a
	gcc -w -o client client.c -L. -lcsock

server : server.c myprotocol.h libcsock.a
	gcc -w -o server server.c -L. -lcsock

libcsock.a : csock.h csock.c
	gcc -w -c -o libcsock.a csock.c

clean:
	rm -f server
	rm -f client
	rm -f libcsock.a</code></pre>
                            <p>La commande <span class="em">make clean</span> supprime les fichiers générés lors de la compilation (comme les fichiers objets <span class="em">.o</span> et les exécutables) afin de nettoyer le répertoire de travail et permettre une recompilation propre du projet.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="exercices_network_security">Exercices de Network Security :</h2>
                    <fieldset class="question">
                        <legend>Question 1</legend>
                        <p>Un administrateur souhaite créer quatre sous-réseaux à partir de l'adresse réseau 192.168.3.0/24. Quelle est l'adresse réseau et le masque de sous-réseau du deuxième sous-réseau utilisable ?</p>
                        <ol type="A">
                            <li>
                                <p>Sous-réseau : 192.168.3.64</p>
                                <p>Masque de sous-réseau : 255.255.255.240</p>
                                <p>&#10060;</p>
                            </li>
                            <li>
                                <p>Sous-réseau : 192.168.3.32</p>
                                <p>Masque de sous-réseau : 255.255.255.240</p>
                                <p>&#10060;</p>
                            </li>
                            <li>
                                <p>Sous-réseau : 192.168.3.128</p>
                                <p>Masque de sous-réseau : 255.255.255.192</p>
                                <p>&#10060;</p>
                            </li>
                            <li>
                                <p>Sous-réseau : 192.168.3.64</p>
                                <p>Masque de sous-réseau : 255.255.255.192</p>
                                <p>&#9989;</p>
                            </li>
                            <li>
                                <p>Sous-réseau : 192.168.3.8</p>
                                <p>Masque de sous-réseau : 255.255.255.224</p>
                                <p>&#10060;</p>
                            </li>
                        </ol>
                        <p>Pour créer quatre sous-réseaux à partir de <span class="em">192.168.3.0/24</span>, on divise les 256 adresses disponibles par 4, ce qui donne un incrément de 64 et donc, selon le tableau présenté à la question 2, un masque <span class="em">/26</span> (255.255.255.192). Le deuxième sous-réseau utilisable est <span class="em">192.168.3.64/26</span>.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 2</legend>
                        <p>Combien d'adresses d'hôte sont disponibles sur le réseau 172.26.10.128/26 ?</p>
                        <ol type="A">
                            <li>
                                <p>30 &#10060;</p>
                            </li>
                            <li>
                                <p>32 &#10060;</p>
                            </li>
                            <li>
                                <p>60 &#10060;</p>
                            </li>
                            <li>
                                <p>62 &#9989;</p>
                            </li>
                            <li>
                                <p>64 &#10060;</p>
                            </li>
                            <li>
                                <p>254 &#10060;</p>
                            </li>
                            <li>
                                <p>128 &#10060;</p>
                            </li>
                        </ol>
                        <p><span class="em">Règle clé à retenir</span> : Le nombre total d'adresses IP dans un sous-réseau est égal à 2<sup>(nombre de bits hôte)</sup>. Il ne faut pas oublier qu'une adresse est réservée pour l'adresse réseau (tous les bits hôte à 0) et une autre pour l'adressse de broadcast (tous les bits hôte à 1).</p>
                        <p><span class="em">Astuce à mémoriser</span> : Dans le dernier octet, on observe le nombre de bits restants :</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>Masque</th>
                                    <th>Bits hôtes</th>
                                    <th>Total adresses</th>
                                    <th>Incrément</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>/24</td>
                                    <td>8</td>
                                    <td>256</td>
                                    <td>256</td>
                                </tr>
                                <tr>
                                    <td>/25</td>
                                    <td>7</td>
                                    <td>128</td>
                                    <td>128</td>
                                </tr>
                                <tr>
                                    <td>/26</td>
                                    <td>6</td>
                                    <td>64</td>
                                    <td>64</td>
                                </tr>
                                <tr>
                                    <td>/27</td>
                                    <td>5</td>
                                    <td>32</td>
                                    <td>32</td>
                                </tr>
                                <tr>
                                    <td>/28</td>
                                    <td>4</td>
                                    <td>16</td>
                                    <td>16</td>
                                </tr>
                            </tbody>
                        </table>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 3</legend>
                        <p>Combien d'adresses d'hôte sont disponibles sur le réseau 172.16.128.0 avec un masque de sous-réseau de 255.255.252.0 ?</p>
                        <ol type="A">
                            <li>
                                <p>510 &#10060;</p>
                            </li>
                            <li>
                                <p>512 &#10060;</p>
                            </li>
                            <li>
                                <p>1022 &#9989;</p>
                            </li>
                            <li>
                                <p>1024 &#10060;</p>
                            </li>
                            <li>
                                <p>2046 &#10060;</p>
                            </li>
                            <li>
                                <p>2048 &#10060;</p>
                            </li>
                        </ol>
                        <p>Le masque de sous-réseau <span class="em">255.255.252.0</span> correspond à <span class="em">/22</span>, ce qui signifie que 22 bits sont utilisés pour la partie réseau et qu'il reste <span class="em">10 bits pour la partie hôte</span>. Le réseau peut contenir <span class="em">2<sup>10</sup> = 1024 adresses IP au total</span>, dont <span class="em">1022 adresses d'hôte utilisables</span> après exclusion de l'adresse réseau et de l'adresse de diffusion.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 4</legend>
                        <p>On vous présente cette capture de paquet : pourriez-vous extrapoler les informations contenues dans ce paquet ? Donnez le plus d'information (minimum 10 informations).</p>
                        <img src="../images/question4_NS.PNG" alt="">
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>Champ</th>
                                    <th>Valeur</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Adresse MAC destination</td>
                                    <td>00:21:70:C0:56:F0</td>
                                </tr>
                                <tr>
                                    <td>Adresse MAC source</td>
                                    <td>00:21:29:66:71:94</td>
                                </tr>
                                <tr>
                                    <td>Type Ethernet</td>
                                    <td>0x0800 (IPv4)</td>
                                </tr>
                                <tr>
                                    <td>Version IP</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>IHL</td>
                                    <td>5 (20 octets)</td>
                                </tr>
                                <tr>
                                    <td>Type de service (ToS)</td>
                                    <td>00</td>
                                </tr>
                                <tr>
                                    <td>Total Length</td>
                                    <td>0x003c = 60 octets</td>
                                </tr>
                                <tr>
                                    <td>Identification</td>
                                    <td>0x728d = 29325</td>
                                </tr>
                                <tr>
                                    <td>Fragmentation</td>
                                    <td>
                                        <p>Flags = 0</p>
                                        <p>Offset = 0</p>
                                        <p>&#8594; Paquet non fragmenté.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>TTL</td>
                                    <td>0x7f = 127</td>
                                </tr>
                                <tr>
                                    <td>Protocole</td>
                                    <td>0x01 (ICMP)</td>
                                </tr>
                                <tr>
                                    <td>Checksum IP</td>
                                    <td>0xfdfe</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP source</td>
                                    <td>0a.0a.00.03 (10.10.0.3)</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP destination</td>
                                    <td>c0.a8.00.80 (192.168.0.128)</td>
                                </tr>
                                <tr>
                                    <td>Type ICMP</td>
                                    <td>08 (Echo Request (ping))</td>
                                </tr>
                                <tr>
                                    <td>Code ICMP</td>
                                    <td>00</td>
                                </tr>
                                <tr>
                                    <td>Checksum ICMP</td>
                                    <td>0x4d36</td>
                                </tr>
                                <tr>
                                    <td>Identifiant ICMP</td>
                                    <td>0x001</td>
                                </tr>
                                <tr>
                                    <td>Numéro de séquence ICMP</td>
                                    <td>0x0025 (37)</td>
                                </tr>
                            </tbody>
                        </table>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 5</legend>
                        <p>Quelle est l'adresse de diffusion du réseau 172.16.16.0/22 ?</p>
                        <ol type="A">
                            <li>
                                <p>172.16.23.255 &#10060;</p>
                            </li>
                            <li>
                                <p>172.16.20.255 &#10060;</p>
                            </li>
                            <li>
                                <p>172.16.19.255 &#9989;</p>
                            </li>
                            <li>
                                <p>172.16.16.255 &#10060;</p>
                            </li>
                            <li>
                                <p>172.16.255.255 &#10060;</p>
                            </li>
                        </ol>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 6</legend>
                        <p>Une entreprise utilise l'adresse 192.168.1.64 avec un masque de sous-réseau de 255.255.255.192. L'entreprise souhaite créer deux sous-réseaux qui contiennent respectivement 10 et 18 hôtes. Quels réseaux permettraient d'y parvenir ? Choisissez deux réponses.</p>
                        <ol type="A">
                            <li>
                                <p>192.168.1.128/27 &#10060;</p>
                            </li>
                            <li>
                                <p>192.168.1.192/28 &#10060;</p>
                            </li>
                            <li>
                                <p>192.168.1.64/27 &#9989;</p>
                            </li>
                            <li>
                                <p>192.168.1.16/28 &#10060;</p>
                            </li>
                            <li>
                                <p>192.168.1.96/28 &#9989;</p>
                            </li>
                        </ol>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 7</legend>
                        <p>Un utilisateur exécute une commande ping 192.168.80.65 et reçoit une réponse qui inclut un code de 4. Que représente ce code ?</p>
                        <ol type="A">
                            <li>
                                <p>Protocole inaccessible &#10060;</p>
                            </li>
                            <li>
                                <p>Port inaccessible &#10060;</p>
                            </li>
                            <li>
                                <p>Réseau inaccessible &#9989;</p>
                            </li>
                            <li>
                                <p>Hôte inaccessible &#10060;</p>
                            </li>
                        </ol>
                        <p>Lorsqu'une commande ping reçoit une réponse ICMP avec un <span class="em">code 4</span>, cela indique une erreur de type <span class="em">Destination Unreachable - Network Unreachable</span>. Ce qui signifie que le réseau de destination ne peut pas être atteint, généralement en raison d'un problème de routage ou d'une route inexistante vers ce réseau.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 8</legend>
                        <p>Examinez l'illustration. Quelle est l'adresse MAC de destination de la trame Ethernet quand elle quitte le serveur Web si la destination finale est le PC1 ?</p>
                        <img src="../images/question8_NS.PNG" alt="">
                        <ol type="A">
                            <li>
                                <p>AA:BB:CC:DD:00:AA &#10060;</p>
                            </li>
                            <li>
                                <p>AA:BB:CC:DD:00:DD &#10060;</p>
                            </li>
                            <li>
                                <p>AA:BB:CC:DD:00:CC &#9989;</p>
                            </li>
                            <li>
                                <p>AA:BB:CC:DD:00:BB &#10060;</p>
                            </li>
                        </ol>
                        <p><span class="em">Rappel du principe clé</span> : Une trame Ethernet est toujours adressée à la prochaine étape (next hop), jamais directement à la destination finale si elle est sur un autre réseau.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 9</legend>
                        <p>Quelles sont les trois parties de base communes à tous les types de trames pris en charge par la couche de liaison de données ? Choisissez trois propositions.</p>
                        <ol type="A">
                            <li>
                                <p>Valeur CRC &#10060;</p>
                            </li>
                            <li>
                                <p>données &#9989;</p>
                            </li>
                            <li>
                                <p>MTU size (Taille de MTU) &#10060;</p>
                            </li>
                            <li>
                                <p>en-tête &#9989;</p>
                            </li>
                            <li>
                                <p>queue de trame &#9989;</p>
                            </li>
                            <li>
                                <p>Champ Type &#10060;</p>
                            </li>
                        </ol>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 10</legend>
                        <p>Convertissez l'adresse IP hexadécimale CC.C6.B2.43 en notation décimale.</p>
                        <p class="em">204.198.178.67</p>
                        <p>Table à connaître par coeur :</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>Hex</th>
                                    <th>Dec</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>1</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>3</td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>5</td>
                                    <td>5</td>
                                </tr>
                                <tr>
                                    <td>6</td>
                                    <td>6</td>
                                </tr>
                                <tr>
                                    <td>7</td>
                                    <td>7</td>
                                </tr>
                                <tr>
                                    <td>8</td>
                                    <td>8</td>
                                </tr>
                                <tr>
                                    <td>9</td>
                                    <td>9</td>
                                </tr>
                                <tr>
                                    <td>A</td>
                                    <td>10</td>
                                </tr>
                                <tr>
                                    <td>B</td>
                                    <td>11</td>
                                </tr>
                                <tr>
                                    <td>C</td>
                                    <td>12</td>
                                </tr>
                                <tr>
                                    <td>D</td>
                                    <td>13</td>
                                </tr>
                                <tr>
                                    <td>E</td>
                                    <td>14</td>
                                </tr>
                                <tr>
                                    <td>F</td>
                                    <td>15</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><span class="em">Formule magique (pour un octet)</span> : XY(hex) = X * 16 + Y.</p>
                        <p>Les raccourcis mentaux très utiles pour les masques réseau, les adresses broadcast et Wireshark sont :</p>
                        <ul>
                            <li>
                                <p>F = 15</p>
                            </li>
                            <li>
                                <p>FF = 255</p>
                            </li>
                            <li>
                                <p>00 = 0</p>
                            </li>
                            <li>
                                <p>80 = 128</p>
                            </li>
                            <li>
                                <p>C0 = 192</p>
                            </li>
                            <li>
                                <p>E0 = 224</p>
                            </li>
                        </ul>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 11</legend>
                        <p>On vous présente cette capture de paquet : pourriez-vous extrapoler les informations contenues dans ce paquet ? Donnez le plus d'information.</p>
                        <img src="../images/question11_NS.PNG" alt="">
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>Champ</th>
                                    <th>Valeur</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Adresse MAC destination</td>
                                    <td>FE:FF:20:00:01:00</td>
                                </tr>
                                <tr>
                                    <td>Adresse MAC source</td>
                                    <td>00:00:01:00:00:00</td>
                                </tr>
                                <tr>
                                    <td>Type Ethernet</td>
                                    <td>0x0800 (IPv4)</td>
                                </tr>
                                <tr>
                                    <td>Version IP</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>IHL</td>
                                    <td>5 (20 octets)</td>
                                </tr>
                                <tr>
                                    <td>Type de service (ToS)</td>
                                    <td>00</td>
                                </tr>
                                <tr>
                                    <td>Longueur total du paquet IP</td>
                                    <td>0x0207 = 519 octets</td>
                                </tr>
                                <tr>
                                    <td>Identification IP</td>
                                    <td>0x0f45 = 3909</td>
                                </tr>
                                <tr>
                                    <td>Flags &amp; fragmentation</td>
                                    <td>
                                        <p>4000 &#8594; DF = 1 (Don't Fragment), MF = 0</p>
                                        <p>Offset = 0</p>
                                        <p>&#8594; Paquet IP non fragmenté.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>TTL</td>
                                    <td>0x080 = 128</td>
                                </tr>
                                <tr>
                                    <td>Protocole encapsulé</td>
                                    <td>0x06 (TCP)</td>
                                </tr>
                                <tr>
                                    <td>Checksum IP</td>
                                    <td>0x3010</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP source</td>
                                    <td>91.fe.a0.ed (145.254.160.237)</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP destination</td>
                                    <td>41.d0.e4.df (65.208.228.223)</td>
                                </tr>
                                <tr>
                                    <td>Port source</td>
                                    <td>0x0d2c (3372)</td>
                                </tr>
                                <tr>
                                    <td>Port destination</td>
                                    <td>0x0050 (80 (HTTP))</td>
                                </tr>
                                <tr>
                                    <td>Numéro de séquence TCP</td>
                                    <td>0x38affe14</td>
                                </tr>
                                <tr>
                                    <td>Numéro d'acquittement (ACK)</td>
                                    <td>0x114c618c</td>
                                </tr>
                                <tr>
                                    <td>Longueur de l'en-tête TCP</td>
                                    <td>0x50 = 20 octets</td>
                                </tr>
                                <tr>
                                    <td>Flags TCP</td>
                                    <td>0x18 &#8594; PSH + ACK</td>
                                </tr>
                                <tr>
                                    <td>Fenêtre TCP</td>
                                    <td>0x25bc (9660)</td>
                                </tr>
                                <tr>
                                    <td>Checksum TCP</td>
                                    <td>0xa958</td>
                                </tr>
                                <tr>
                                    <td>Urgent Pointer</td>
                                    <td>0x0000</td>
                                </tr>
                                <tr>
                                    <td>Méthode HTTP</td>
                                    <td>47 45 54 (GET) suivi de 20 (espace)</td>
                                </tr>
                                <tr>
                                    <td>Ressource demandée</td>
                                    <td>2f 64 6f 77 6e 6c 6f 61 64 2e 68 74 6d 6c &#8594; <q>/download.html</q></td>
                                </tr>
                                <tr>
                                    <td>Version HTTP</td>
                                    <td>48 54 54 50 2f 31 2e 31 &#8594; <q>HTTP/1.1</q></td>
                                </tr>
                                <tr>
                                    <td>Fin de ligne HTTP</td>
                                    <td>0d 0a &#8594; CRLF</td>
                                </tr>
                                <tr>
                                    <td>En-tête Host</td>
                                    <td>
                                        <p>48 6f 73 74 3a 20 &#8594; <q>Host: </q></p>
                                        <p>77 77 77 2e 65 74 68 65 72 65 61 6c 2e 63 6f 6d &#8594; <q>www.ethereal.com</q></p>
                                        <p>&#8594; <span class="em">Host: www.ethereal.com</span> permet d'indiquer au serveur web le nom de domaine demandé par le client afin qu'il fournisse le site correspondant lorsque plusieurs sites sont hébergés sur la même adresse IP.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête User-Agent</td>
                                    <td>
                                        <p>55 73 65 72 2d 41 67 65 6e 74 3a 20&#8594; <q>User-Agent: </q></p>
                                        <p>4d 6f 7a 69 6c 61 2f 35 2e 30 20 &#8594; <q>Mozilla/5.0 </q></p>
                                        <p>28 57 69 6e 64 6f 77 73 3b 20 &#8594; <q>(Windows; </q></p>
                                        <p>55 3b 20 &#8594; <q>U; </q></p>
                                        <p>57 69 6e 64 6f 77 73 20 4e 54 20 35 2e 31 3b 20 &#8594; <q>Windows NT 5.1; </q></p>
                                        <p>65 6e 2d 55 53 3b 20 &#8594; <q>en-US; </q></p>
                                        <p>72 76 3a 31 2e 36 29 20 &#8594; <q>rv:1.6) </q></p>
                                        <p>47 65 63 6b 6f 2f 32 30 30 34 30 31 31 33 &#8594; <q>Gecko/20040113</q></p>
                                        <p>&#8594; <span class="em">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.6) Gecko/20040113</span> est la signature claire d'un navigateur web Mozilla sous Windows.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Accept</td>
                                    <td>
                                        <p>41 63 63 65 70 74 3a 20 &#8594; <q>Accept: </q></p>
                                        <p>74 65 78 74 2f 78 6d 6c 2c 20 &#8594; <q>text/xml, </q></p>
                                        <p>61 70 70 6c 69 63 61 74 69 2f 78 68 74 6d 6c 2b 78 6d 6c 2c 20 &#8594; <q>application/xhtml+xml, </q></p>
                                        <p>74 65 78 74 2f 68 74 6d 6c 2c 20 &#8594; <q>text/html, </q></p>
                                        <p>69 6d 61 67 65 2f 70 6e 67 2c 20 &#8594; <q>image/png, </q></p>
                                        <p>69 6d 61 67 65 2f 6a 70 65 67 2c 20 &#8594; <q>image/jpeg, </q></p>
                                        <p>69 6d 61 67 65 2f 67 69 66 2c 20 &#8594; <q>image/gif, </q></p>
                                        <p>2a 2f 2a &#8594; <q>*/*</q></p>
                                        <p>&#8594; <span class="em">Accept: text/xml, application/xhtml+xml, text/html, image/png, image/jpeg, image/gif, */*</span> permet de définir les types MIME acceptés par le client.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Accept-Language</td>
                                    <td>
                                        <p>41 63 63 65 70 74 2d 61 6e 67 75 61 67 65 3a 20 &#8594; <q>Accept-Language: </q></p>
                                        <p>65 6e 2d 75 73 2c 20 65 6e &#8594; <q>en-us, en</q></p>
                                        <p>&#8594; <span class="em">Accept-Language: en-us, en</span> permet de dire que la langue préférée est l'anglais US puis l'anglais.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Accept-Encoding</td>
                                    <td>
                                        <p>41 63 63 65 70 74 2d 45 6e 63 6f 64 69 6e 67 3a 20 &#8594; <q>Accept-Encoding : </q></p>
                                        <p>67 7a 69 70 2c 20 64 65 66 6c 61 74 65 &#8594; <q>gzip, deflate</q></p>
                                        <p>&#8594; <span class="em">Accept-Encoding: gzip, deflate</span> permet de dire que le client accepte les réponses compressées (gzip, deflate).</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Accept-Charset</td>
                                    <td>
                                        <p>41 63 63 65 70 74 2d 43 68 61 72 73 65 74 3a 20 &#8594; <q>Accept-Charset: </q></p>
                                        <p>49 53 4f 2d 38 38 35 39 2d 31 2c 20 75 74 66 2d 38 &#8594; <q>ISO-8859-1, utf-8</q></p>
                                        <p>&#8594; <span class="em">Accept-Charset: ISO-8859-1, utf-8</span> permet de définir les encodages de caractères acceptés par le navigateur.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Keep-Alive</td>
                                    <td>
                                        <p>4b 65 65 70 2d 41 6c 69 76 65 3a 20 &#8594; <q>Keep-Alive: </q></p>
                                        <p>33 30 30 &#8594; &#8594; <q>300</q></p>
                                        <p>&#8594; <span class="em">Keep-Alive: 300</span> permet de déterminer la durée (en secondes) pendant laquelle la connexion TCP reste ouverte.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Connection</td>
                                    <td>
                                        <p>43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 &#8594; <q>Connection: </q></p>
                                        <p>6b 65 65 70 2d 41 6c 69 76 65 &#8594; <q>keep-alive</q></p>
                                        <p>&#8594; <span class="em">Connection: keep-alive</span> dit que le client demande une connexion TCP persistante.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>En-tête Referer</td>
                                    <td>
                                        <p>52 65 66 65 72 65 72 3a 20 &#8594; <q>Referer: </q></p>
                                        <p>68 74 74 70 3a 2f 2f 77 77 77 2e 65 74 68 65 72 65 61 6c 2e 63 6f 6d 2f 64 65 76 65 6c 6f 70 6d 65 6e 74 2e 68 74 6d 6c &#8594; <q>http://www.ethereal.com/development.html</q></p>
                                        <p>&#8594; <span class="em">Referer: http://www.ethereal.com/development.html</span> permet de désigner la page web depuis laquelle la requête HTTP a été initiée.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Fin des en-têtes HTTP</td>
                                    <td>0d 0a 0d 0a &#8594; ligne vide indiquant la fin des en-têtes HTTP et le début éventuel du corps du message.</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>En résumé, cette trame correspond à une requête HTTP GET envoyée par un navigateur web vers un serveur distant, encapsulée dans TCP sur IPv4, et dont les en-têtes HTTP sont directement lisibles en ASCII dans la charge utile TCP.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 12</legend>
                        <p>On vous présente cette capture de paquet : pourriez-vous extrapoler les informations contenues dans ce paquet ? Donnez le plus d'information.</p>
                        <img src="../images/question12_NS.PNG" alt="">
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>Champ</th>
                                    <th>Valeur</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Adresse MAC destination</td>
                                    <td>00:15:F2:40:76:EF</td>
                                </tr>
                                <tr>
                                    <td>Adresse MAC source</td>
                                    <td>00:16:CE:6E:8B:24</td>
                                </tr>
                                <tr>
                                    <td>Type Ethernet</td>
                                    <td>0x0800 (IPv4)</td>
                                </tr>
                                <tr>
                                    <td>Version IP</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>IHL</td>
                                    <td>5 (20 octets)</td>
                                </tr>
                                <tr>
                                    <td>Type de service (ToS)</td>
                                    <td>00</td>
                                </tr>
                                <tr>
                                    <td>Total Length</td>
                                    <td>0x05dc = 1500 octets</td>
                                </tr>
                                <tr>
                                    <td>Identification</td>
                                    <td>0x61d1 = 25041</td>
                                </tr>
                                <tr>
                                    <td>Flags &amp; fragmentation</td>
                                    <td>
                                        <p>2000 &#8594; DF = 1 (Don't Fragment), MF = 0</p>
                                        <p>Offset = 0</p>
                                        <p>&#8594; Paquet non fragmenté.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>TTL</td>
                                    <td>0x80 = 128</td>
                                </tr>
                                <tr>
                                    <td>Protocole encapsulé</td>
                                    <td>0x01 (ICMP)</td>
                                </tr>
                                <tr>
                                    <td>Checksum IP</td>
                                    <td>0x30cc</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP source</td>
                                    <td>c0.a8.00.72 (192.168.0.114)</td>
                                </tr>
                                <tr>
                                    <td>Adresse IP destination</td>
                                    <td>c0.a8.00.c1 (192.168.0.193)</td>
                                </tr>
                                <tr>
                                    <td>Type ICMP</td>
                                    <td>0x08 (Echo Request (ping))</td>
                                </tr>
                                <tr>
                                    <td>Code ICMP</td>
                                    <td>00</td>
                                </tr>
                                <tr>
                                    <td>Checksum ICMP</td>
                                    <td>0x7298</td>
                                </tr>
                                <tr>
                                    <td>Identifiant ICMP</td>
                                    <td>0x0300</td>
                                </tr>
                                <tr>
                                    <td>Numéro de séquence ICMP</td>
                                    <td>0x1600 (5632)</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>&#8594; Il s'agit d'un ping émis sur un réseau local, utilisé pour tester la connectivité entre deux hôtes.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 13</legend>
                        <p>Quels filtres de paquet un administrateur réseau peut-il utiliser sur une liste de contrôle d'accès étendue IPv4 ? Choisissez deux réponses.</p>
                        <ol type="A">
                            <li>
                                <p>Adresse Hello TCP source. &#10060;</p>
                            </li>
                            <li>
                                <p>Adresse MAC de destination. &#10060;</p>
                            </li>
                            <li>
                                <p>Type de message ICMP. &#9989;</p>
                            </li>
                            <li>
                                <p>Numéro de port UDP de destination. &#9989;</p>
                            </li>
                            <li>
                                <p>Type d'ordinateur. &#10060;</p>
                            </li>
                        </ol>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 14</legend>
                        <p>Un administrateur réseau établit une liste de contrôle d'accès standard qui interdira tout trafic venant du réseau 172.16.0.0/16 mais autorisera tous les autres trafics. Quelles sont les deux commandes à utiliser ? Choisissez deux réponses.</p>
                        <ol type="A">
                            <li>
                                <p>Router(config)# access-list 95 host 172.16.0.0 &#10060;</p>
                            </li>
                            <li>
                                <p>Router(config)# access-list 95 deny any &#10060;</p>
                            </li>
                            <li>
                                <p>Router(config)# access-list 95 deny 172.16.0 0.0.255.255 &#9989;</p>
                            </li>
                            <li>
                                <p>Router(config)# access-list 95 deny 172.16.0.0 255.255.0.0 &#10060;</p>
                            </li>
                            <li>
                                <p>Router(config)# access-list 95 permit any &#9989;</p>
                            </li>
                            <li>
                                <p>Router(config)# access-list 95 172.16.0.0 255.255.255.255 &#10060;</p>
                            </li>
                        </ol>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 15</legend>
                        <p>Reportez-vous à l'illustration. Un administrateur réseau a configuré l'ACL 9 comme indiqué. Le trafic des utilisateurs sur le réseau 172.31.1.0/24 ne peut pas transiter via le routeur ITSCM_Netsec. Quelle est la cause la plus probable de la défaillance du trafic réseau ?</p>
                        <img src="../images/question15_NS.PNG" alt="">
                        <ol type="A">
                            <li>
                                <p>L'instruction permit spécifie un masque générique incorrect. &#10060;</p>
                            </li>
                            <li>
                                <p>Le numéro de port du trafic n'a pas été identifié avec le mot-clé eq. &#10060;</p>
                            </li>
                            <li>
                                <p>La séquence des ACLs est incorrecte. &#9989;</p>
                            </li>
                            <li>
                                <p>Le mot-clé extended n'est pas spécifié. &#10060;</p>
                            </li>
                        </ol>
                        <p><span class="em">Règle fondamentale des ACL Cisco</span> : Les ACL sont lues de haut en bas. La première correspondance gagne. Une fois qu'un paquet correspond à une règle, les suivantes ne sont jamais lues.</p>
                        <p>Dans l'illustration, on voit que la commande <span class="em">deny 172.31.0.0 0.0.255.255</span> bloque TOUT le réseau 172.31.0.0/16. Le réseau 172.31.1.0/24 est déjà bloqué ici et donc la règle <span class="em">permit 172.31.1.0</span> n'est jamais atteinte.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 16</legend>
                        <p>Reportez-vous à l'illustration. Quel est le prochain numéro de séquence que cet hôte attend ?</p>
                        <img src="../images/question16_NS.PNG" alt="">
                        <p>Le prochain numéro de séquence attendu se calcule comme suit :</p>
<pre><code>Prochain numéro de séquence attendu = Numéro actuel + Taille des données TCP.</code></pre>
                        <p>Sur l'illustration, le numéro de séquence (relatif) est de <span class="em">1</span> et la longueur des données TCP est de <span class="em">35 octets</span>. Donc, en résumé, le prochain numéro de séquence attendu est <span class="em">36</span> car le segment commence à <span class="em">1</span> et transporte <span class="em">35 octets de données</span>.</p>
                        <p><span class="em">Phrase clé à mémoriser</span> : Le numéro ACK correspond toujours au prochain octet attendu par le récepteur.</p>
                    </fieldset>
                    <fieldset class="question">
                        <legend>Question 17</legend>
                        <p>De quelle façon les zombies sont-ils utilisés dans les attaques contre la sécurité ?</p>
                        <ol type="A">
                            <li>
                                <p>Il s'agit de segments de code créés de façon malveillante pour remplacer des applications légitimes. &#10060;</p>
                            </li>
                            <li>
                                <p>Ils ciblent des personnes précises pour obtenir les informations d'entreprises ou des informations personnelles. &#10060;</p>
                            </li>
                            <li>
                                <p>Ce sont des ordinateurs infectés qui effectuent une attaque par déni de service (DDoS). &#9989;</p>
                            </li>
                            <li>
                                <p>Ils sondent un groupe de machines pour trouver des ports ouverts afin de déterminer quels services sont en fonctionnement. &#10060;</p>
                            </li>
                        </ol>
                    </fieldset>
                </article>
                <article>
                    <h2 id="labo1">Labo 1 : construction d'un petit réseau :</h2>
                    <h3>Objectif :</h3>
                    <p>L'objectif de ce premier labo est de se familiariser avec l'environnement de simulation des réseaux (GNS3) et de mettre en place un petit réseau tout en introduisant les notions de sécurité des réseaux.</p>
                    <h3>Scénario :</h3>
                    <p>Vous êtes un administrateur réseau/sécurité junior, vous êtes engagé pour mettre en place et gérer le réseau d'une petite entreprise.</p>
                    <p>Le réseau est composé d'un routeur, d'un switch et de trois PC. Vous devez permettre aux utilisateurs d'accéder à Internet.</p>
                    <p>En tant qu'administrateur, vous devez protéger votre PC contre les éventuelles attaques depuis les PC utilisateurs (ils ne doivent pas voir votre PC).</p>
                    <p>Vous devez faire en sorte que si un équipement autre que ceux installés par vos soins ne soit pas autorisé.</p>
                    <h3>Mots clés :</h3>
                    <p>VLANs, Access Ports, Trunk Ports, Routage inter-vlan, NAT, DHCP, Packet capture (Wireshark).</p>
                    <p>Sécurité : désactivation du VLAN 1, STP, ACL, Mac Flooding, Port Security, ARP snooping, DHCP snooping.</p>
                    <h3>Topologie :</h3>
                    <img src="../images/labo1_NS.PNG" alt="">
                    <p>Voici les différentes étapes à réaliser :</p>
                    <ol>
                        <li>
                            <p>Créer un nouveau projet dans GNS3 avec le menu "File &#8594; New Project".</p>
                            <p>Avant d'ajouter quoi que ce soit, vérifier la VM dans le menu "Edit &#8594; Preferences &#8594; GNS3 VM".</p>
                        </li>
                        <li>
                            <p>Dans la fenêtre du projet, dans le panel "Devices" ou "Nodes", on doit faire un drag & drop les éléments suivants et les positionner sur l'aire de travail :</p>
                            <ul>
                                <li>
                                    <p>IOS ON UNIX / IOU L2 &#8594; place un Switch1.</p>
                                </li>
                                <li>
                                    <p>IOS ON UNIX / IOU L3 &#8594; place un Router1.</p>
                                </li>
                                <li>
                                    <p>End devices / VPCS &#8594; glisse 3 fois VPCS (PC1, PC2, PC3).</p>
                                </li>
                                <li>
                                    <p>Cloud &#8594; choisis NAT (ou Cloud puis configure l'interface NAT).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>On va câbler les différents éléments ensemble via l'icône "Connect" (le câble) avec les paramètres suivants :</p>
                            <ul>
                                <li>
                                    <p>Cloud (NAT) &#8594; sélectionne l'interface vers Router1 e0/0.</p>
                                </li>
                                <li>
                                    <p>Connecte Router1 e0/1 &#8594; Switch1 e0/0.</p>
                                </li>
                                <li>
                                    <p>Connecte Switch1 e0/1 &#8594; PC1.</p>
                                </li>
                                <li>
                                    <p>Switch1 e0/2 &#8594; PC2.</p>
                                </li>
                                <li>
                                    <p>Switch1 e0/3 &#8594; PC3.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Cliquez sur "Play" (bouton triangle vert en haut) pour démarrer tout le projet OU clique-droit sur chaque noeud &#8594; Start.</p>
                        </li>
                        <li>
                            <p>On va ouvrir les consoles (GUI) et entrer les commandes IOS. Pour cela, on clique sur l'élément &#8594; "Console" (ou double-clic) pour ouvrir une console.</p>
                            <div class="important">
                                <img src="../images/important.png" alt="Important" class="float_left">
                                <p>Chaque fois que tu entres en <span class="em">configure terminal</span> ou dans une <span class="em">interface</span>, pense à :</p>
                                <ul>
                                    <li>
                                        <p>sortir de l'interface : <span class="em">exit</span></p>
                                    </li>
                                    <li>
                                        <p>sortir du mode global : <span class="em">end</span> (ou <span class="em">exit</span> plusieurs fois)</p>
                                    </li>
                                    <li>
                                        <p>sauvegarder : <span class="em">write memory</span> ou <span class="em">copy running-config startup-config</span></p>
                                    </li>
                                </ul>
                            </div>
                            <ul>
                                <li>
                                    <h3>Configuration du routeur (Router1) :</h3>
                                    <p>Comme NAT va sûrement se crasher, il faut changer la <span class="em">RAM Size</span> dans la configuration du routeur. Attention, la <span class="em">RAM Size</span> dépend de l'image IOU. Voici ma configuration du Router 1 :</p>
                                    <img src="../images/configure_router1.png" alt="">
                                    <p>On entre en mode privilégié puis conf t :</p>
<pre><code>enable
configure terminal
interface e0/0
    ip address dhcp
    ip nat outside
    no shutdown
    exit</code></pre>
                                    <p>L'interface e0/0 du routeur est configurée en DHCP afin d'obtenir automatiquement une adresse IP depuis le cloud NAT de GNS3.</p>
                                    <p>Le NAT (Network Address Translation) est le mécanisme réseau qui <span class="em">traduit les adresses IP privées en adresses IP publiques (et inversement)</span> pour permettre à plusieurs machines d'un réseau interne de <span class="em">partager une seule adresse IP publique</span>, tout en <span class="em">masquant la structure interne du réseau</span> (bénéfice de sécurité de base).</p>
                                    <p>Lorsque l'on exécute la commande <span class="em">show ip interface brief</span> sur le routeur, on constate que l'interface obtient normalement une adresse IP via DHCP.</p>
                                    <p>Pour utiliser une configuration statique, on supprime l'addressage DHCP et on configure manuellement une adresse IP fixe sur l'interface à l'aide de la commande suivante :</p>
<pre><code>ip address 192.168.122.2 255.255.255.0</code></pre>
                                    <p>Le passage à une configuration IP statique garantit une adresse IP permanente sur le routeur, ce qui est indispensable pour assurer la cohérence des règles de sécurité, du routage et des services réseau.</p>
                                    <p>L'interface e0/0 représente la connexion vers le réseau externe (Internet) et est donc définie comme interface <span class="em">NAT outside</span>.</p>
                                    <h4>Interface vers le switch (e0/1) + Subinterfaces dot1Q :</h4>
<pre><code>interface e0/1
    no shutdown
    exit

interface e0/1.2
    encapsulation dot1Q 2
    ip address 192.168.2.1 255.255.255.0
    ip nat inside
    exit

interface e0/1.3
    encapsulation dot1Q 3
    ip address 192.168.3.1 255.255.255.0
    ip nat inside
    exit</code></pre>
                                    <p>Les interfaces e0/1.2 et e0/1.3 <span class="em">ne sont pas visibles dans l'image</span> car elles ne sont pas physiques.</p>
                                    <p>Ce sont des <span class="em">sous-interfaces virtuelles</span> nécessaires pour le routage inter-VLAN.</p>
                                    <p>La commande <span class="em">encapsulation dot1Q 2</span> configure l'encapsulation dot1Q avec le tag VLAN 2.</p>
                                    <p>La commande <span class="em">ip address 192.168.2.1 255.255.255.0</span> attribue l'adresse IP de passerelle pour le VLAN 2.</p>
                                    <h4>DHCP Server (dans les deux VLANs) :</h4>
                                    <p>On peut exclure des adresse IP du pool DHCP que ceux-ci ne soient pas utilisés dans les offres d'adresse par le serveur DHCP.</p>
<pre><code>ip dhcp excluded-address 192.168.2.1 192.168.2.2
ip dhcp excluded-address 192.168.3.1 192.168.3.2</code></pre>
                                    <p>Un DHCP pool représente le pool des adresses allouées, c'est-à-dire que c'est un ensemble d'adresses.</p>
<pre><code>ip dhcp pool POOL_UTILISATEURS
    network 192.168.2.0 255.255.255.0
    default-router 192.168.2.1
    dns-server 1.1.1.1 8.8.8.8
    exit

ip dhcp pool POOL_ADMINS
    network 192.168.3.0 255.255.255.0
    default-router 192.168.3.1
    dns-server 1.1.1.1 8.8.8.8
    exit</code></pre>
                                    <p>L'image ne mentionne pas explicitement la création de deux pools... mais elle l'implique parce que <span class="em">chaque VLAN est un réseau IP séparé</span>.</p>
                                    <p>La règle fondamentale est que <span class="em">1 VLAN = 1 réseau = 1 pool DHCP</span>. Tu ne peux pas faire un pool pour plusieurs réseaux. Donc, si tu as deux VLANs, tu DOIS avoir deux pools.</p>
                                    <p>En gros, l'image ne le dit pas en toutes lettres, mais c'est <span class="em">une conséquence logique obligatoire</span>.</p>
                                    <p>Cisco fonctionne comme ça parce qu'un pool DHCP inclut :</p>
                                    <ul>
                                        <li>
                                            <p>le réseau</p>
                                        </li>
                                        <li>
                                            <p>la passerelle par défaut</p>
                                        </li>
                                        <li>
                                            <p>les options DHCP</p>
                                        </li>
                                        <li>
                                            <p>la place d'adresses possibles</p>
                                        </li>
                                    </ul>
                                    <p>Or chaque VLAN :</p>
                                    <ul>
                                        <li>
                                            <p>a une <span class="em">passerelle différente</span></p>
                                        </li>
                                        <li>
                                            <p>est un <span class="em">broadcast domain différent</span></p>
                                        </li>
                                        <li>
                                            <p>a <span class="em">son propre sous-réseau</span></p>
                                        </li>
                                    </ul>
                                    <p>Donc, on ne peut pas mutualiser le pool.</p>
                                    <p>La commande <span class="em">network 192.168.2.0 255.255.255.0</span> ne signifie <span class="em">pas</span> <q>donner l'adresse 192.168.2.0</q>, mais signifie <q>ce pool DHCP concerne <span class="em">tout le réseau 192.168.2.0/24</span></q>.</p>
                                    <h4>NAT Overload (Internet) :</h4>
                                    <p>Le PAT est une forme de NAT (overload) qui traduit non seulement l'adresse IP mais aussi les ports pour permettre à plusieurs clients internes de partager une IP publique.</p>
                                    <p>Il faut configurer les listes d'accès (ACL) pour les subnets qui peuvent utiliser le NAT et configurer le NAT.</p>
<pre><code>access-list 1 permit 192.168.2.0 0.0.0.255
access-list 1 permit 192.168.3.0 0.0.0.255

ip nat inside source list 1 interface e0/0 overload</code></pre>
                                    <p>L'<span class="em">access-list 1</span> sert uniquement à filtrer sur l'IP source et rien d'autre.</p>
                                    <p>Pour le NAT, Cisco recommande une ACL standard, car NAT n'a pas besoin de protocole, ni port, ni IP destination. Il a juste besoin de <q>quelles IP internes sont autorisées à être NATées</q>.</p>
                                    <p>L'<span class="em">access-list 100</span> est une ACL étendue qui permet de filtrer :</p>
                                    <ul>
                                        <li>
                                            <p>IP source</p>
                                        </li>
                                        <li>
                                            <p>IP destination</p>
                                        </li>
                                        <li>
                                            <p>protocole</p>
                                        </li>
                                        <li>
                                            <p>port</p>
                                        </li>
                                        <li>
                                            <p>direction</p>
                                        </li>
                                        <li>
                                            <p>etc.</p>
                                        </li>
                                    </ul>
                                    <p>Elle est utilisée pour <span class="em">interdire la communication VLAN2 &#8594; VLAN3</span>, ce qui <span class="em">nécessite de spécifier les deux réseaux</span>.</p>
                                    <p>&#8594; ACL 100 = règle de sécurité pour contrôler le trafic inter-VLAN.</p>
                                    <p>&#8594; ACL 1 = liste des réseaux internes autorisés au NAT &#8594; pas une règle de sécurité.</p>
                                    <p>Ce sont donc deux usages différents et donc deux ACL différentes.</p>
                                    <p>La commande <span class="em">ip nat inside source list 1 interface e0/0 overload</span> permet au NAT de traduire plusieurs adresses internes simultanément en utilisant une seule adresse IP publique.</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">Avant la commande :</span> les machines internes ne pouvaient pas accéder à Internet correctement, car le routeur ne traduisait pas leurs adresses privées.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">Après la commande :</span> toutes les adresses internes autorisées par l'ACL partagent une seule adresse IP publique pour sortir vers Internet.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">Fonctionnement :</span> chaque flux est différencié par les numéros de port, permettant à plusieurs machines de communiquer simultanément avec l'extérieur.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">Bénéfice :</span> les machines internes peuvent désormais envoyer et recevoir des données sur Internet de manière stable et sécurisée.</p>
                                        </li>
                                    </ul>
                                    <p>Après avoir configuré le NAT overload et défini les interfaces inside et outside, une interface NVI (Network Virtual Interface) est créée automatiquement par le routeur.</p>
                                    <p>Cette commande est visible lorsqu'on exécute la commande suivante :</p>
<pre><code>show ip interface brief</code></pre>
                                    <p>Le NVI relie la règle NAT aux interfaces physiques et centralise la traduction des adresses pour simplifier la configuration.</p>
                                    <p>Aussi bien penser à changer le nuage avec NAT sur GNS3 :</p>
                                    <img src="../images/NAT_overload.PNG" alt="">
                                    <p>On vérifie la route par défaut :</p>
<pre><code>show ip route</code></pre>
                                    <p>Si elle est absente :</p>
<pre><code>ip route 0.0.0.0 0.0.0.0 e0/0</code></pre>
                                    <p>Ou sans DHCP :</p>
<pre><code>ip route 0.0.0.0 0.0.0.0 e0/0 192.168.122.1</code></pre>
                                    <h4>Sauvegarde :</h4>
<pre><code>end
copy running-config startup-config</code></pre>
                                    <p>Si tes interfaces ont d'autres noms (E0/1 etc.), adapte. Sur IOS L3 les noms peuvent être Ethernet0/1 ou GigabitEthernet0/1; vérifie avec :</p>
<pre><code>show ip interface brief</code></pre>
                                    <div class="important">
                                        <img src="../images/important.png" alt="Important" class="float_left">
                                        <p>Le mot <span class="em">do</span> permet d'exécuter une commande du mode EXEC (show, ping, etc.) depuis un mode de configuration.</p>
                                        <p>Normalement, les commandes <span class="em">show</span> ne fonctionnent que en mode privilégié (<span class="em">#</span>).</p>
                                    </div>
                                </li>
                                <li>
                                    <h3>Configuration du switch (Switch1) :</h3>
                                    <h4>Création des VLANs :</h4>
                                    <h5>Qu'est-ce qu'un VLAN et pouquoi l'utiliser ?</h5>
                                    <p>Un VLAN (Virtual Local Area Network) est un LAN virtuel (sous-groupe dans un LAN). Il permet aux administrateurs réseau de séparer un réseau commuté (présence de commutateur/switch) unique en plusieurs groupes pour un certain niveau de sécurité des systèmes présent dans le réseau.</p>
                                    <p>Utiliser un VLAN permet d'avoir :</p>
                                    <ul>
                                        <li>
                                            <p>Une faible latence (comparé à un LAN simple).</p>
                                        </li>
                                        <li>
                                            <p>Segmentation du réseau (avoir plusieurs sous-réseaux dans un même réseau qui permet d'augmenter le nombre d'hôtes dans le réseau).</p>
                                        </li>
                                        <li>
                                            <p>Une isolation entre plusieurs VLANs.</p>
                                        </li>
                                        <li>
                                            <p>Permet une certaine évolutivité (sans rajouter de matériels physiques inutiles et encombrant).</p>
                                        </li>
                                    </ul>
<pre><code>enable
configure terminal

vlan 2
    name UTILISATEURS
    exit

vlan 3
    name ADMINS
    exit</code></pre>
                                    <h4>Désactiver le VLAN (sécurité) :</h4>
                                    <p>Lorsque l'on fait <span class="em">show vlan</span>, on constate que l'on a tous les ports par défaut dans le vlan1 et c'est un problème. Si tous les ports inutilisés restent dans le vlan 1, un attaquant physique qui a accès à un port inutilisé peut faire plusieurs choses problématiques comme se connecter au switch, intercepter ou injecter du trafic interne, etc...</p>
                                    <p>La solution est donc de créer un SVI (Switched Virtual Interface) pour le vlan en question (ici le vlan 1) : l'interface de management passe sur ce VLAN3 dédié, isolé du vlan par défaut.</p>
<pre><code>interface Vlan1
    shutdown
    exit</code></pre>
                                    <p>Le VLAN 1 est désactivé afin de réduire la surface d'attaque, car il est utilisé par défaut pour la gestion et certains protocoles internes (CDP, STP, etc.).</p>
                                    <p>Cisco IOS écrit automatiquement les interfaces VLAN avec un "V" majuscule par convention interne pour nommer les SVI (Switched Virtual Interfaces).</p>
                                    <h4>Trunk vers le routeur (e0/0) :</h4>
                                    <h5>À quoi sert le mode trunk ?</h5>
                                    <p>Un trunk sert à transporter plusieurs VLANs sur un seul lien physique.</p>
                                    <ul>
                                        <li>
                                            <p>Il tague les trames avec 802.1Q pour indiquer à quel VLAN elles appartiennent.</p>
                                        </li>
                                        <li>
                                            <p>Usage typique : switch &#8596; switch ou switch &#8596; routeur / firewall (inter-VLAN, routeur-on-a-sick).</p>
                                        </li>
                                        <li>
                                            <p>Sans trunk, un lien ne peut porter qu'un seul VLAN (mode access).</p>
                                        </li>
                                    </ul>
                                    <h5>Que contient ce tag 802.1Q ?</h5>
                                    <p>Le tag 802.1Q contient :</p>
                                    <ul>
                                        <li>
                                            <p>VLAN ID (12 bits) : le numéro de VLAN (1-4094)</p>
                                        </li>
                                        <li>
                                            <p>PCP (3 bits) : priorité (QoS)</p>
                                        </li>
                                        <li>
                                            <p>DEI (1 bit) : indicateur de drop (congestion)</p>
                                        </li>
                                    </ul>
                                    <p>Remarque : Sur un trunk, un VLAN peut être "native" : ses trames passentsans tag (non taguées). Le VLAN natif permet de gérer le trafic non tagué sur un trunk et permet la compatibilité avec des équipements/flux qui ne taggent pas (ancien équipement ou protocole).</p>
                                    <p>Un bon réflexe de sécurité serait de ne pas utiliser VLAN 1, définir un native VLAN inutilisé et autoriser uniquement les VLANs nécessaires sur le trunk, ce qui permet d'éviter les attaques VLAN hopping (double-tagging).</p>
<pre><code>interface e0/0
    switchport trunk encapsulation dot1q
    switchport mode trunk
    switchport trunk allowed vlan 2,3
    no shutdown
    exit</code></pre>
                                    <p>La commande <span class="em">switchport trunk encapsulation dot1q</span> définit le protocole d'encapsulation 802.1Q pour le trunk. Ce protocole ajoute un tag (étiquette) de 4 octets aux trames Ethernet pour identifier le VLAN auquel elles appartiennent, permettant ainsi de transporter plusieurs VLANs sur un seul lien physique.</p>
                                    <p>La commande <span class="em">switchport mode trunk</span> configure le port en mode trunk pour transporter plusieurs VLANs.</p>
                                    <p>Par défaut, le trafic de tous les VLANs est autorisé à passer dans un lien trunk. Il est conseillé d'autoriser uniquement le trafic des VLANs que nous avons créé (que nous connaissons) à passer dans le lien trunk, le trafic des autres VLANs ne sera pas donc autorisé, c'est-à-dire la commande <span class="em">switchport trunk allowed vlan 2,3</span>.</p>
                                    <h4>Ports Access VLAN 2 (PC1 / PC2) :</h4>
<pre><code>interface e0/1
    switchport mode access
    switchport access vlan 2
    no shutdown
    exit

interface e0/2
    switchport mode access
    switchport access vlan 2
    no shutdown
    exit</code></pre>
                                    <p>On peut abréger les commandes précédentes comme ceci :</p>
<pre><code>interface e0/1-2
    switchport mode access
    switchport access vlan 2
    no shutdown
    exit</code></pre>
                                    <h4>Port Access VLAN 3 (PC3) :</h4>
<pre><code>interface e0/3
    switchport mode access
    switchport access vlan 3
    no shutdown
    exit</code></pre>
                                    <h4>Spanning Tree (bonne pratique) :</h4>
<pre><code>spanning-tree mode pvst
spanning-tree extend system-id</code></pre>
                                    <p>La commande <span class="em">spanning-tree mode pvst</span> active le mode <span class="em">PVST (Per-VLAN Spanning Tree)</span>, qui permet de calculer un arbre Spanning Tree distinct pour chaque VLAN afin d'éviter les boucles de niveau 2.</p>
                                    <p>La commande <span class="em">spanning-tree extend system-id</span> modifie la manière dont est calculé le <span class="em">Bridge ID</span> en y intégrant l'identifiant du VLAN, ce  qui garantit un Bridge ID unique par VLAN et permet l'élection d'un <span class="em">root bridge</span> différent pour chaque VLAN.</p>
                                    <h4>Sauvegarde :</h4>
<pre><code>end
write memory</code></pre>
                                    <p>Cisco préfère la commande suivante :</p>
<pre><code>end
copy running-config startup-config</code></pre>
                                </li>
                                <li>
                                    <h3>Configuration des PCS (PC1, PC2, PC3) :</h3>
                                    <p>Dans la console VPCS :</p>
<pre><code>ip dhcp</code></pre>
                                    <p>Cette commande sert à obtenir automatiquement une adresse IP depuis le routeur.</p>
                                    <img src="../images/IP_DHCP.PNG" alt="">
                                    <p>On a DDORA &#8594; 2 D car le PC n'est pas sûr que le premier Discover a été entendu, alors il envoie un deuxième Discover automatiquement après, par sécurité.</p>
                                    <p>En résumé, le client démarre sans IP et fait un échange en 4 étapes :</p>
                                    <ol>
                                        <li>
                                            <p>Il diffuse une demande (Discover).</p>
                                        </li>
                                        <li>
                                            <p>Le serveur propose une IP (Offer).</p>
                                        </li>
                                        <li>
                                            <p>Le client accepte et demande cette IP (Request).</p>
                                        </li>
                                        <li>
                                            <p>Le serveur valide et "loue" l'IP pour une durée (ACK + bail.)</p>
                                            <p>Le serveur garde en mémoire les baux pour éviter de donner la même IP à deux machines.</p>
                                        </li>
                                    </ol>
                                    <p>Vérifier :</p>
<pre><code>show ip</code></pre>
                                    <p>Tester la passerelle :</p>
<pre><code>ping 192.168.2.1 (depuis PC1/PC2)
ping 192.168.3.1 (depuis PC3)</code></pre>
                                    <p>Tester Internet :</p>
<pre><code>ping 8.8.8.8</code></pre>
                                </li>
                                <li>
                                    <h3>ACL - Bloquer PC1 &amp; PC2 d'acéder à PC3 :</h3>
                                    <p>Sur le Router1, l'ACL est configurée afin de bloquer l'initiation de nouvelles connexions TCP depuis le VLAN 2 vers le VLAN 3 en refusant les paquets TCP contenant le flag SYN.</p>
                                    <p>Les paquets TCP contenant le flag ACK, correspondant à des connexions déjà établies, sont quant à eux autorisés afin de ne pas interrompre les communications légitimes.</p>
                                    <p>Pour autoriser les réponses ICMP (ping reply) du VLAN 3 vers le VLAN 2 et bloquer les requêtes ICMP (ping) de VLAN 2 vers VLAN 3, il faut configurer l'ACL (Access Control List) suivante :</p>
<pre><code>enable
configure terminal
ip access-list extended block_icmpecho_in
    permit icmp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 echo-reply
    deny icmp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 echo
    permit ip any any
    exit

interface e0/1.2
    ip access-group block_icmpecho_in in
    exit

end
copy running-config startup-config</code></pre>
                                    <p>En résumé, cette configuration <span class="em">bloque uniquement les pings sortants vers le VLAN 3</span>, mais laisse <span class="em">les réponses passer</span> et <span class="em">ne bloque rien d'autre</span>.</p>
                                    <p>L'objectif est d'empêcher le VLAN 2 de découvrir ou de tester la présence du VLAN 3 via ICMP, tout en conservant les réponses légitimes.</p>
                                    <p>Une <span class="em">ACL seule est juste une liste de règles</span>, elle n'agit <span class="em">nulle part</span> tant qu'on ne l'associe pas à une interface.</p>
                                    <p>Les ACL nommées sont <span class="em">plus flexibles</span> que les ACL numérotées, car tu peux modifier ou ajouter des lignes sans tout supprimer.</p>
                                    <p>Sur l'interface e0/1.2 (subinterface VLAN2), on applique l'ACL 100. En clair, tout ce qui arrive dans VLAN 2 depuis les PC du VLAN 2 est filtré avant d'être routé.</p>
                                    <p>On peut tester depuis PC1 la commande suivante et ça doit échouer et idem depuis le PC2 :</p>
<pre><code>ping &lt;IP PC3&gt;</code></pre>
                                    <p>Du PC3 vers les PC1 et PC2, c'est possible grâce à l'ACL asymétrique.</p>
                                    <p>Le PC1 et le PC2 peuvent quand même aller sur Internet.</p>
                                    <p>L'ACL est volontairement asymétrique afin de bloquer l'initiation des communications depuis le VLAN 2 vers le VLAN 3, tout en autorisant les réponses et les communications initiées depuis le VLAN 3.</p>
                                    <p>Pour contrôler le trafic TCP (handshake) en bloquant le TCP handshake dans un sens et en l'autorisant dans un autre sens, voici l'ACL à configurer :</p>
<pre><code>enable
configure terminal

ip access-list extended block_tcpsyn-in
    permit tcp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 ack
    deny tcp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 syn
    permit ip any any
    exit

interface e0/1.2
    ip access-group block_tcpsyn-in in
    exit

end
copy running-config startup-config</code></pre>
                                    <p>L'objectif est d'empêcher les accès directs et les scans de ports TCP depuis le VLAN 2 vers le VLAN 3, tout en maintenant les connexions existantes.</p>
                                    <p>Remarque : vous pouvez combiner les deux ACL, <span class="em">block_icmpecho_in</span> et <span class="em">block_tcpsyn-in</span>, en un seul ACL, <span class="em">block_icmpecho_tcpsyn-in</span> :</p>
<pre><code>enable
configure terminal

ip access-list extended block_icmpecho_tcpsyn-in
    permit tcp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 ack
    deny tcp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 syn
    permit icmp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 echo-reply
    deny icmp 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255 echo
    permit ip any any
    exit

interface e0/1.2
    ip access-group block_icmpecho_tcpsyn-in in
    exit

end
copy running-config startup-config</code></pre>
                                </li>
                                <li>
                                    <h3>Sécurité supplémentaire requise :</h3>
                                    <p>Le MAC Flooding est une attaque de couche 2 qui consiste à ce que l'attaquant envoie des milliers de fausses adresses MAC sur un port du switch (dont la table CAM c'est-à-dire la table MAC du switch saturé) ce qui lui permettra de pouvoir sniffer le trafic des autres VLANs ou ports.</p>
                                    <p>Comment fonctionne une attaque par saturation de la table CAM (MAC flooding) ?</p>
                                    <ol>
                                        <li>
                                            <p>L'attaquant envoie rapidement un grand nombre de trames Ethernet contenant des adresses MAC source différentes, généralement générées de manière aléatoire (spoofées).</p>
                                        </li>
                                        <li>
                                            <p>Le commutateur (switch) "apprend" ces adresses MAC et remplit sa table CAM (association MAC &#8596; port) jusqu'à atteindre sa capacité maximale.</p>
                                        </li>
                                        <li>
                                            <p>Une fois la table CAM saturée, quand le switch reçoit une trame vers une adresse MAC "inconnue" ou évincée, il diffuse la trame sur plusieurs ports (flooding) se comportant alors comme un hub.</p>
                                        </li>
                                        <li>
                                            <p>L'attaquant peut alors intercepter et analyser (sniffer) du trafic qui ne lui était pas iniialement destiné, en particulier si les communications ne sont pas chiffrées.</p>
                                        </li>
                                    </ol>
                                    <p>Pour contrer cela, la solution est d'activer le port-security sur tous les ports.</p>
                                    <p>Sur le switch, tu dois aussi appliquer Port Security pour la liaison vers le PC 3 (ADMIN) :</p>
<pre><code>enable
configure terminal

interface e0/3
    switchport nonegotiate
    switchport port-security
    switchport port-security maximum 1
    switchport port-security mac-address sticky
    switchport port-security violation restrict
    switchport port-security aging time 1
    switchport port-security aging type inactivity

    no cdp enable
    no lldp transmit
    no lldp receive

    spanning-tree portfast edge
    spanning-tree bpduguard enable
    exit

end
copy running-config startup-config</code></pre>
                                    <p>La commande <span class="em">switchport nonegotiate</span> désactive le protocole DTP (Dynamic Trunking Protocol). D'un point de vue sécuritaire, cela empêche toute négociation automatique du port en mode trunk et limite ainsi les risques de mauvaise configuration ou d'attaque de type VLAN hopping.</p>
                                    <p>La commande <span class="em">switchport port-security</span> active le mécanisme de <span class="em">sécurité de port</span>, qui permet de contrôler les équipements autorisés à se connecter sur l'interface.</p>
                                    <p>La commande <span class="em">switchport port-security maximum 2</span> limite à <span class="em">deux adresses MAC</span> le nombre d'équipements pouvant être connectés simultanément sur ce port.</p>
                                    <p>La commande <span class="em">switchport port-security mac-address sticky</span> sert à <span class="em">activer l'apprentissage automatique des adresses MAC autorisées</span> sur un port sécurisé d'un switch Cisco.</p>
                                    <p>En cas de violation de la politique de sécurité, la commande <span class="em">switchport port-security violation restrict</span> permet de bloquer le trafic provenant des adresses non autorisées, d'incrémenter un compteur d'événements, tout en maintenant le port <span class="em">actif</span>.</p>
                                    <p>La commande <span class="em">switchport port-security aging time 1</span> définit une durée d'expiration des adresses MAC de <span class="em">1 minute</span>.</p>
                                    <p>Grâce à la commande <span class="em">switchport port-security aging type inactivity</span>, les adresses MAC sont automatiquement supprimées de la table de sécurité lorsqu'elles deviennent <span class="em">inactives</span>.</p>
                                    <p>Cette commande indique au switch que les adresses MAC apprises par le port-security doivent être supprimées (si elles sont âgées), c'est-à-dire si elles n'envoient plus de trafic pendant un certain temps. Donc, si une adresse MAC ne parle plus pendant X minutes, elle est retirée de la table port-security.</p>
                                    <p>Pour voir la sécurité sur les ports du switch, on utilise la commande suivante :</p>
<pre><code>do show port-security</code></pre>
                                    <img src="../images/show_port-security.PNG" alt="">
                                    <p>On voit pour tous les ports du switch que la sécurité est bien désormais RESTRICT.</p>
                                    <p>Si on veut vérifier en détails la sécurité d'un port, on fait la commande suivante (e0/0 est l'interface voulue par cet exemple) :</p>
<pre><code>show port-security interface e0/0</code></pre>
                                    <p>Nous obtenons le résultat suivant :</p>
                                    <img src="../images/show_port-security_interface_e0_0.PNG" alt="">
                                    <p>Pour vérifier que CDP est supporté :</p>
<pre><code>show cdp</code></pre>
                                    <p>Si CDP par interface n'est PAS supporté :</p>
<pre><code>configure terminal
no cdp run</code></pre>
                                    <p>Pour vérifier que LLDP est supporté :</p>
<pre><code>show lldp</code></pre>
                                    <p>Si LLDP par interface n'est PAS supporté :</p>
<pre><code>configure terminal
no lldp run</code></pre>
                                    <p>Les commandes <span class="em">no cdp enable</span>, <span class="em">no lldp transmit</span> et <span class="em">no lldp receive</span> permettent respectivement de désactiver le protocole <span class="em">CDP</span> (Cisco Discovery Protocol), d'empêcher l'envoi de trames <span class="em">LLDP</span> et d'empêcher la réception de trames <span class="em">LLDP</span>, afin de limiter la divulgation d'informations sur l'infrastructure réseau.</p>
                                    <p>L'attaque STP (Root Bridge Attack) (L2) consiste à ce que l'attaquant envoie des BPDU forgées avec une priorité très basse et une adresse MAC très faible, afin que l'attaquant soit élu le Root Bridge. Une fois qu'il est considéré comme la racine du spanning-tree, les switches doivent recalculer toute la topologie autour de lui, ce qui provoque une redirection des chemins habituels et entraîne de l'instabilité ainsi que des perturbations sur le trafic. En prenant la place du Root Bridge, l'attaquant se retrouve au centre du spanning-tree et peut alors influencer ou perturber une partie du réseau qui passe par lui.</p>
                                    <p>La solution est de configurer les ports comme port Edge pour protéger le réseau STP : le port ne participera pas à STP et toute BPDU reçue est bloquée. Ça empêche l'attaquant de faire élire Root Bridge.</p>
                                    <p>La commande <span class="em">spanning-tree portfast edge</span> active la fonctionnalité <span class="em">PortFast</span> sur un port connecté à un hôte final, ce qui permet d'accélérer la mise en service de l'interface.</p>
                                    <p>La commande <span class="em">spanning-tree bpduguard enable</span> provoque la désactivation immédiate du port si une <span class="em">BPDU (Bridge Protocol Data Unit)</span> est reçue, protégeant ainsi le réseau contre le raccordement de commutateurs non autorisés.</p>
                                    <p>Pour vérifier le portfast/edge, on utilise la commande suivante :</p>
<pre><code>show spanning-tree interface e0/1 detail</code></pre>
                                    <img src="../images/show_spanning-tree_interface_e0_1_detail.PNG" alt="">
                                    <p>Et aussi visible dans le <span class="em">show run</span> :</p>
                                    <img src="../images/show_run.PNG" alt="">
                                </li>
                                <li>
                                    <h3>DHCP Snooping + DAI (option sécurité avancée) :</h3>
                                    <p>Le DHCP Snooping est un mécanisme de sécurité intégré dans les switchs Cisco.</p>
                                    <p>Il sert à empêcher un faux serveur DHCP d'attribuer des adresses IP dans le réseau.</p>
                                    <p>&#8594; C'est un bouclier contre les attaques DHCP.</p>
<pre><code>enable
configure terminal
ip dhcp snooping
ip dhcp snooping vlan 2,3

interface e0/0
    ip dhcp snooping trust
    exit

ip arp inspection vlan 2,3

end
copy running-config startup-config</code></pre>
                                    <p>DHCP Snooping permet de créer une base de données de correspondance IP-MAC-port, qui est ensuite utilisée par Dynamic ARP Inspection (DAI) pour bloquer les attaques ARP spoofing.</p>
                                    <p>Tous les ports sont considérés comme <span class="em">untrusted</span> par défaut. Seul le port vers le routeur est configuré comme <span class="em">trusted</span>, car il est légitime pour envoyer des réponses DHCP.</p>
                                    <div class="important">
                                        <img src="../images/important.png" alt="Important" class="float_left">
                                        <p>Certaines images IOU L2 n'ont pas toutes les features (DHCP snooping/DAI). Si elles manquent, saute ces étapes ou utilise une image plus complète.</p>
                                    </div>
                                    <div class="important">
                                        <img src="../images/important.png" alt="Important" class="float_left">
                                        <p>Ne pas confondre DHCP snooping (protection) et DHCP snoofing (attaque). Le vrai nom correct est DHCP spoofing, mais beaucoup écrivent "snoofing".</p>
                                    </div>
                                    <p>On peut limiter également le taux DHCP :</p>
<pre><code>enable
configure terminal

interface e0/1
    ip dhcp snooping limit rate 10
    exit

end
copy running-config startup-config</code></pre>
                                    <p>Pour afficher <span class="em">l'état global du DHCP Snooping</span> sur le switch :</p>
<pre><code>show ip dhcp snooping</code></pre>
                                    <p>Pour afficher la <span class="em">table des baux DHCP sécurisés</span> (binding table) :</p>
<pre><code>show ip dhcp snooping binding</code></pre>
                                    <p>Quand un DHCP snooping est activé, le switch peut <span class="em">ajouter automatiquement l'Option 82</span> (DHCP Relay Agent Information) dans les messages DHCP qui sortent du switch. Pour désactiver l'injection de l'Option 82 dans les paquets DHCP, il faut faire la commande suivante :</p>
<pre><code>no ip dhcp snooping information option</code></pre>
                                    <p>En gros, cette commande empêche le switch d'ajouter l'Option 82 aux messages DHCP, tout en gardant le filtrage DHCP activé.</p>
                                </li>
                                <li>
                                    <h3>Vérification / troubleshooting :</h3>
                                    <p>Pour afficher la liste des VLANs existants, leur état (active / suspended) et les ports associés à chaque VLAN :</p>
<pre><code>show vlan brief</code></pre>
                                    <p>Pour afficher les ports configurés en <span class="em">trunk</span>, le type d'encapsulation (802.1Q) et les VLANs autorisés sur le trunk :</p>
<pre><code>show interfaces trunk</code></pre>
                                    <p>Pour afficher la <span class="em">table de routage IP</span> du routeur :</p>
<pre><code>show ip route</code></pre>
                                    <p>Pour afficher les adresses IP attribuées par le serveur DHCP, l'adresse MAC associée et la durée du bail :</p>
<pre><code>show ip dhcp binding</code></pre>
                                    <p>Pour afficher l'état de la <span class="em">Port Security</span> sur un port précis :</p>
<pre><code>show port-security interface e0/1</code></pre>
                                    <p>Pour afficher toutes les ACL configurées sur le routeur :</p>
<pre><code>show access-lists</code></pre>
                                    <p>Pour afficher la table de traduction NAT, c'est-à-dire "IP privée &#8594; IP publique" et "ports source traduits" :</p>
<pre><code>show ip nat translations</code></pre>
                                    <p>Pour afficher si le DHCP snooping est activé, les VLANs protégés et les ports trusted / untrusted :</p>
<pre><code>show ip dhcp snooping</code></pre>
                                    <p>Pour afficher l'état de <span class="em">Dynamic ARP Inspection (DAI)</span> :</p>
<pre><code>show ip arp inspection</code></pre>
                                    <p>Pour afficher <span class="em">la configuration active</span> d'un équipement réseau :</p>
<pre><code>show running-config</code></pre>
                                    <p>Ou encore la version abrégée :</p>
<pre><code>show run</code></pre>
                                </li>
                                <li>
                                    <p>Pour capturer un paquet, dans la topologie GNS3, clique-droit sur le lien "Start capture" et choisis Wireshark si installé. Tu pourras faire des pings depuis PC1 et tu verras alors ICMP traverser.</p>
                                    <p>N'oublies pas de "Stop capture" quand tu as fini (dans Wireshark ou dans GNS3).</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3>Conclusion :</h3>
                    <p>Cette configuration met en oeuvre une segmentation réseau sécurisée par VLANs, un routage inter-VLAN contrôlé par ACL, un accès Internet via NAT, et plusieurs mécanismes de sécurité de couche 2 (Port Security, STP, DHCP Snooping, DAI) afin de limiter les attaques internes et l'accès non autorisé.</p>
                </article>
                <article>
                    <h2 id="labo2">Labo 2 : construction et sécurisation d'un réseau de taille moyenne :</h2>
                    <h3>Objectif :</h3>
                    <p>L'objectif de ce labo est de mettre en place un réseau de taille moyenne et sécuriser celui-ci en mettant en oeuvre les principes de sécurisation d'une infrastructure réseau (network hardening).</p>
                    <h2>Scénario :</h2>
                    <p>Vous êtes un administrateur réseau et sécurité, votre entreprise a fait une acquisition d'un nouveau site que vous devez connecter sur le réseau existant, vous devez créer un réseau avec le routage dynamique entre les sites et sécuriser tout le réseau (sécurisation du data plane, du control plane et du management plane).</p>
                    <p>Le réseau est composé de deux sites et un Datacenter.</p>
                    <h3>Mots clés :</h3>
                    <p>AAA, Syslog, DNS, SNMP, NTP, ACL, OSPF.</p>
                    <p>Sécurité : Sécurité Labo1 + Tacacs (AAA), OSPF authentication, ACL (pour protéger les trois planes).</p>
                    <h3>Topologie :</h3>
                    <img src="../images/labo2_NS.PNG" alt="">
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Équipement 1</th>
                                <th>Équipement 2</th>
                                <th>IP</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Internet (e0/0)</td>
                                <td>RT-CORE (e0/0)</td>
                                <td>192.168.122.1/24</td>
                            </tr>
                            <tr>
                                <td>RT-CORE (e0/0)</td>
                                <td>Internet (e0/0)</td>
                                <td>192.168.122.2/24</td>
                            </tr>
                            <tr>
                                <td>RT-CORE (e0/3)</td>
                                <td>DMZ-CORE (e0/0)</td>
                                <td>172.19.254.2/24</td>
                            </tr>
                            <tr>
                                <td>DMZ-CORE (e0/0)</td>
                                <td>RT-CORE (e0/3)</td>
                                <td>172.19.X.1/24</td>
                            </tr>
                            <tr>
                                <td>DMZ-CORE (e0/1)</td>
                                <td>HQ-CORE (e0/0)</td>
                                <td>172.16.1.1/30</td>
                            </tr>
                            <tr>
                                <td>HQ-CORE (e0/0)</td>
                                <td>DMZ-CORE (e0/1)</td>
                                <td>172.16.1.2/30</td>
                            </tr>
                             <tr>
                                <td>DMZ-CORE (e0/2)</td>
                                <td>BRANCH-CORE (e0/0)</td>
                                <td>172.16.1.5/30</td>
                            </tr>
                            <tr>
                                <td>BRANCH-CORE (e0/0)</td>
                                <td>DMZ-CORE (e0/2)</td>
                                <td>172.16.1.6/30</td>
                            </tr>
                             <tr>
                                <td>BRANCH-CORE (e0/1)</td>
                                <td>HQ-CORE (e0/1)</td>
                                <td>172.16.1.9/30</td>
                            </tr>
                            <tr>
                                <td>HQ-CORE (e0/0)</td>
                                <td>BRANCH-CORE (e0/1)</td>
                                <td>172.16.1.10/30</td>
                            </tr>
                            <tr>
                                <td>HQ-CORE (e0/2)</td>
                                <td>HQ-ACCESS1 (e0/0)</td>
                                <td>172.17.X.3/24</td>
                            </tr>
                            <tr>
                                <td>HQ-ACCESS1 (e0/0)</td>
                                <td>HQ-CORE (e0/2)</td>
                                <td>172.17.X.1/24</td>
                            </tr>
                            <tr>
                                <td>HQ-CORE (e0/3)</td>
                                <td>HQ-ACCESS2 (e0/0)</td>
                                <td>172.17.X.2/24</td>
                            </tr>
                            <tr>
                                <td>HQ-ACCESS2 (e0/0)</td>
                                <td>HQ-CORE (e0/3)</td>
                                <td>172.18.X.1/24</td>
                            </tr>
                            <tr>
                                <td>BRANCH-CORE (e0/2)</td>
                                <td>BR-ACCESS1 (e0/0)</td>
                                <td>172.18.X.1/24</td>
                            </tr>
                            <tr>
                                <td>BR-ACCESS1 (e0/0)</td>
                                <td>BRANCH-CORE (e0/2)</td>
                                <td>172.18.X.3/24</td>
                            </tr>
                            <tr>
                                <td>BRANCH-CORE (e0/3)</td>
                                <td>BR-ACCESS2 (e0/0)</td>
                                <td>172.18.X.1/24</td>
                            </tr>
                            <tr>
                                <td>BR-ACCESS2 (e0/0)</td>
                                <td>BRANCH-CORE (e0/3)</td>
                                <td>172.18.X.2/24</td>
                            </tr>
                            <tr>
                                <td>RT-CORE</td>
                                <td>LOOPBACK</td>
                                <td>172.16.0.1/32</td>
                            </tr>
                            <tr>
                                <td>HQ-CORE</td>
                                <td>LOOPBACK</td>
                                <td>172.16.0.2/32</td>
                            </tr>
                            <tr>
                                <td>BRANCH-CORE</td>
                                <td>LOOPBACK</td>
                                <td>172.16.0.3/32</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Une <span class="em">interface loopback</span> est une interface <span class="em">virtuelle</span> d'un routeur ou d'un switch de niveau 3.</p>
                    <p>Elle ne dépend d'aucun lien physique et reste active tant que l'équipement est opérationnel.</p>
                    <p>Les interfaces loopback sont utilisées pour :</p>
                    <ul>
                        <li>
                            <p>identifier de manière <span class="em">unique et stable</span> un équipement,</p>
                        </li>
                        <li>
                            <p>servir d'adresse de <span class="em">gestion</span> (SSH, supervision),</p>
                        </li>
                        <li>
                            <p>fournir un <span class="em">identifiant fiable</span> pour les protocoles de routage.</p>
                        </li>
                    </ul>
                    <p>Les loopbacks sont généralement configurées avec un masque <span class="em">/32</span>, car elles représentent une adresse unique et non un réseau.</p>
                    <p><span class="em">Phrase clé à retenir</span> : Le plan d'adressage structure les communications entre équipements, tandis que l'interface loopback fournit une identité réseau stable et indépendante des liens physiques.</p>
                    <p>Voici les différentes étapes à exécuter :</p>
                    <h3>Étapes :</h3>
                    <ol>
                        <li>
                            <h4>Configuration IP sur RT-CORE :</h4>
<pre><code>enable
configure terminal

interface e0/0
    ip address 192.168.122.2 255.255.255.0
    no shutdown
    exit</code></pre>
                            <h5>Routage par défaut vers Internet :</h5>
<pre><code>ip route 0.0.0.0 0.0.0.0 192.168.122.1</code></pre>
                            <p>&#8594; Très important : cette route sera redistribuée plus tard via OSPF si demandé.</p>
                        </li>
                        <li>
                            <h4>Créer les VLANs (sur TOUS les switchs) :</h4>
<pre><code>enable
configure terminal
vlan 2
    name EMPLOYES
    exit
vlan 3
    name FINANCES
    exit
vlan 254
    name MANAGEMENT
    exit
end</code></pre>
                            <p>Même sur les switchs L3, les VLANs doivent exister.</p>
                        </li>
                        <li>
                            <h4>Configurer les ports ACCESS (switchs L2) :</h4>
                            <h5>PC employé :</h5>
<pre><code>interface e0/1
    switchport mode access
    switchport access vlan 2
    exit</code></pre>
                            <h5>PC finance :</h5>
<pre><code>interface e0/2
    switchport mode access
    switchport access vlan 3
    exit</code></pre>
                            <h5>PC admin :</h5>
<pre><code>interface e0/3
    switchport mode access
    switchport access vlan 254
    exit</code></pre>
                        </li>
                        <li>
                            <h4>Configurer les TRUNKS (L2 &#8596; L3) :</h4>
                            <p>&#8594; Toujours entre un switch L2 et un switch L3.</p>
<pre><code>interface e0/0
    switchport trunk encapsulation dot1q
    switchport mode trunk
    switchport trunk allowed vlan 2,3,254
    exit</code></pre>
                        </li>
                        <li>
                            <h4>Inter-VLAN routing (sur les SWITCHS L3) :</h4>
<pre><code>enable
configure terminal
ip routing

interface vlan 2
    ip address 172.17.2.1 255.255.255.0
    no shutdown
    exit

interface vlan 3
    ip address 172.17.3.1 255.255.255.0
    no shutdown
    exit

interface vlan 254
    ip address 172.17.254.1 255.255.255.0
    no shutdown
    exit

end</code></pre>
                            <p>&#8594; Ces IP sont les GATEWAYS des PCs.</p>
                        </li>
                        <li>
                            <h4>IP sur les liens inter-sites :</h4>
                            <h5>Sur RT-CORE :</h5>
<pre><code>interface e0/1
    ip address 172.16.1.1 255.255.255.252
    no shutdown
    exit

interface e0/2
    ip address 172.16.1.5 255.255.255.252
    no shutdown
    exit</code></pre>
                            <h5>Sur HQ-CORE</h5>
<pre><code>interface e0/0
    ip address 172.16.1.2 255.255.255.252
    no shutdown
    exit

interface e0/1
    ip address 172.16.1.9 255.255.255.252
    no shutdown
    exit</code></pre>
                            <h5>Sur BRANCH-CORE :</h5>
<pre><code>interface e0/0
    ip address 172.16.1.6 255.255.255.252
    no shutdown
    exit

interface e0/1
    ip address 172.16.1.10 255.255.255.252
    no shutdown
    exit</code></pre>
                        </li>
                        <li>
                            <h4>Loopbacks (identités) :</h4>
<pre><code>interface loopback0
    ip address 172.16.0.X 255.255.255.255
    exit</code></pre>
                            <p>(X selon l'équipement)</p>
                        </li>
                        <li>
                            <h4>Routage OSPF :</h4>
                            <h5>Sur RT-CORE, HQ-CORE, BRANCH-CORE, DMZ-CORE :</h5>
<pre><code>router ospf 1
    network 172.16.0.0 0.0.255.255 area 0
    network 172.17.0.0 0.0.255.255 area 0
    network 172.18.0.0 0.0.255.255 area 0
    network 172.19.0.0 0.0.255.255 area 0
    exit</code></pre>
                        </li>
                    </ol>
                    <h3>Résumé :</h3>
                    <p>Dans ce laboratoire, nous aborderons la sécurisation d'un réseau au <span class="em">niveau 3 (L3) et niveau 4 (L4)</span> à l'aide de techniques de <span class="em">firewalling classique</span>.</p>
                    <h4>Sécurisation L3/L4 - Firewalling :</h4>
                    <p>Nous verrons comment :</p>
                    <ul>
                        <li>
                            <p>Bloquer une adresse IP vers une autre adresse IP.</p>
                        </li>
                        <li>
                            <p>Bloquer une adresse IP depuis un port spécifique vers une autre adresse IP.</p>
                        </li>
                        <li>
                            <p>Mettre en place des règles de filtrage basées sur différents critères réseau.</p>
                        </li>
                    </ul>
                    <p><span class="em">Question potentielle</span> : Créer une <span class="em">ACL</span> qui bloque les paquets dont le <span class="em">numéro de séquence est égal à un chiffre donné</span>.</p>
                    <p><span class="em">OSPF (Open Shortest Path First)</span> est un <span class="em">protocole de routage dynamique</span> utilisé pour l'échange d'informations de routage au sein d'un réseau.</p>
                    <h4>Les trois axes de la sécurisation réseau :</h4>
                    <ol>
                        <li>
                            <h5>Data Plane :</h5>
                            <ul>
                                <li>
                                    <p>Sécurisation des <span class="em">données des utilisateurs</span>.</p>
                                </li>
                                <li>
                                    <p>Mise en oeuvre via des <span class="em">policies</span> (politiques de filtrage et de contrôle).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h5>Management Plane :</h5>
                            <ul>
                                <li>
                                    <p>Sécurisation de l'<span class="em">accès à l'administration des équipements</span>.</p>
                                </li>
                                <li>
                                    <p>Seules les personnes autorisées (les ingénieurs réseau désignés) peuvent effectuer des actions de configuration ou de gestion.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h5>Control Plane et Forwarding Plane :</h5>
                            <ul>
                                <li>
                                    <p><span class="em">Control Plane</span> : définit la manière dont les paquets doivent être acheminés (choix des routes, décisions de routage).</p>
                                </li>
                                <li>
                                    <p><span class="em">Forwarding Plane</span> : assure l'<span class="em">acheminement effectif des paquets</span> selon les décisions prises par le Control Plane.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>