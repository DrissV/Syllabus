<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>IANARCH - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3schools.com/js/default.asp" target="_blank">Tutoriel JavaScript de W3Schools</a></li>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>IANARCH (Introduction à l'ANalyse et à l'ARCHitecture des données) :</h1>
                    <p>Cette page va être axée sur la gestion de bases de données.</p>
                </article>
                <section>
                    <article id="partie_1">
                        <h2 id="partie_sql_1">Partie SQL 1ère année :</h2>
                        <h3 id="intro_sql">Introduction à SQL :</h3>
                        <p>L'informatique, comme le suggère son nom, est un ensemble de techniques destinées essentiellement à conserver et à <span class="em">manipuler des informations</span>.</p>
                        <p>En informatique, il est très fréquent de rencontrer encore et encore le même problème. Avec l’expérience, on peut évaluer les différentes solutions qui ont été apportées et choisir celle qui tient le mieux la route. Ce choix est d’ailleurs souvent très pragmatique : c’est la solution qui survit à l’épreuve du temps qui finit par être universellement acceptée.</p>
                        <p>Elle est particulièrement efficace dès qu'il s'agit de manpuler de grandes quantités d'informations de structure similaire, comme des listes de personnes (membres, clients, etc.), des listes d'articles, des séries de factures ou de contrats, etc.</p>
                        <p>De nombreuses organisations logiques et physiques ont été imaginées pour répondre à ce type de besoin, surtout depuis que les percées de l'électronique ont permis de créer des ordinateurs. Ainsi, on a d'abord parlé de "fichiers" : un fichier est une suite d'informations, en général toutes de même structure, conservées sur support électronique (disque dur, clé USB, etc.). Lorsqu'on a dû manipuler plusieurs fichiers et effectuer des traitements où leurs contenus interagissent, on s'est rendu compte qu'il valait mieux parler de "bases de données", qui sont essentiellement des ensembles de fichiers présentant certains liens entre eux.</p>
                        <p>Ainsi, dans le courant des années 1960, il existait un besoin grandissant d’automatiser la gestion des données. Non seulement il fallait pouvoir stocker ces données, mais en plus il fallait trouver un mécanisme permettant de les exploiter : récupérer les données, les faire évoluer d’une manière consistante, faire des croisements entre plusieurs informations, consolider des résultats, etc. Il y avait donc un besoin d’exprimer toutes sortes de requêtes et manipulations sur les données. Mais développer des algorithmes spécifiques à chaque besoin spécifique aurait été coûteux et contreproductif. C’est pourquoi Edgar F. Codd publia en 1970 un article intitulé "A Relational Model of Data for Large Shared Data Banks" proposant une manière de les représenter et de les manipuler. Cette approche donna naissance au langage SQL : Structured Query Language.</p>
                        <h3 id="sql_ajd">SQL de nos jours :</h3>
                        <p>SQL reste de nos jours incontestablement le standard pour gérer la persistance des données. SQL est tellement omniprésent sur Internet que probablement tous les sites web que vous fréquentez l’utilisent. Il commence aussi à avoir une grande présence sur les Smartphones pour toutes les applications ayant des données non triviales à gérer. Vous retrouverez SQL au cœur de la gestion des données de presque tous les systèmes informatique : applications bancaires, médicales, cartographie, multimédia, etc.….</p>
                        <p>Le marché est composé de poids lourds commerciaux (Access, SQL Server, DB2, Informix, Oracle, Microsoft, Sybase, …), mais aussi de produits issus du monde du logiciel libre (Ingres, MySQL, PostgreSQL, SQLite, …). SQL est un langage qui est normalisé mais reste très complexe. Ainsi chaque vendeur n’implémente qu’un sous ensemble plus ou moins complet du langage. De plus la concurrence étant bien présente, chaque vendeur essaie de se sortir du lot par des extensions qui lui sont propre. Au final, il y a un tronc SQL commun à toutes ces bases de données (BD), mais on se retrouve assez rapidement à utiliser des instructions qui sont spécifiques à un vendeur particulier.</p>
                        <p>Dans le cadre de ce cours, nous utiliserons <a href="https://www.postgresql.org/" target="_blank">PostgreSQL</a>. C’est un logiciel libre et donc gratuit. PostgreSQL est un <span class="em">Système de Gestion de Bases de données</span> (noté <span class="em">SGBD</span> ou, en anglais, <span class="em">DBMS</span> (<span class="em">DataBase Management System</span>)) relationnelles. Il attache une grande importance au respect de la norme SQL. C’est un produit moderne, avec une communauté de développeur très active. Il est fréquemment utilisé en milieu professionnel et il est fort probable que vous le rencontrerez à un moment ou un autre de votre future carrière. Pour toutes ces raisons nous avons choisi ce logiciel.</p>
                        <h3 id="rdbms">RDBMS (Relational Database Management System) :</h3>
                        <h3 id="modele_relationnel">Le modèle relationnel :</h3>
                        <p>Différentes générations de bases de donénes se sont succédé (hiérarchique, en réseaux et relationnelle), et les plus utilisées actuellement sont les "bases de données relationnelles", qui se sont répandues depuis les années 1980.</p>
                        <p>Une <span class="html">base de données relationnelle</span> est constituée d'un ensemble de "relations", souvent appelées "tables".</p>
                        <p>Chaque <span class="html">table</span> est divisée d'une part en colonnes et d'autre part en lignes.</p>
                        <p>Les <span class="html">colonnes</span> sont les "<span class="html">attributs</span>" (ou les "<span class="em">champs</span>"). Elles sont désignées par leur numéro d'ordre (1, 2, 3, ...) ou par des noms d'attributs; dans ce dernier cas, l'ordre des colonnes est sans importance. Chaque attribut peut se voir imposer un "<span class="em">domaine</span>", c'est-à-dire l'ensemble de toutes les valeurs possibles de cet attribut.</p>
                        <p>Les <span class="html">lignes</span> sont appelées les "<span class="em">tuples</span>" : elles correspondent plus ou moins aux "enregistrements" des fichiers classiques, à ceci près qu'une table n'est pas considérée comme une <span class="em">séquence</span> de tuples, mais bien comme un <span class="em">ensemble</span> (au sens mathématique) de tuples. Ceci entraîne deux conséquences :</p>
                        <ul>
                            <li>L'<span class="em">ordre</span> des tuples est <span class="html">sans importance</span> (c'est-à-dire que rien ne garantit un ordre déterminé, même pas l'ordre chronologique dans lequel les tuples ont été mis dans la table; cependant, le programmeur peut toujours, lors de l'affichage ou de l'impression d'une table, choisir un ordre bien précis).</li>
                            <li>Deux tuples devraient <span class="em">toujours être distincts l'un de l'autre</span>. On ne devrait jamais avoir dans une même table deux tuples qui soient exactement identiques.</li>
                        </ul>
                        <p>Les SGBD ont tous recours au langage SQL pour :</p>
                        <ul>
                            <li>créer des tables (vides).</li>
                            <li>insérer des informations (appelées "tuples") dans ces tables.</li>
                            <li>modifier ou supprimer certaines de ces informations.</li>
                            <li>consulter, de façon souple et puissante, les informations ainsi emmaganisinées.</li>
                        </ul>
                        <p>La définition en "intention" d'une base de données est constituée de la liste de ses tables, avec, pour chacune d'elles, la liste des attributs et de leurs domaines, ainsi que d'une série de "contraintes d'intégrité", servant à garantir la cohérence des donénes : cette définition, qui n'inclut pas le contenu actuel des tables, est la partie permanente, fixe de la base de données.</p>
                        <p>La définition en "extension" d'une base de données est constituée du contenu actuel de ses tables, c'est-à-dire des ensembles de tuples qu'elles contiennent.</p>
                        <p>La liste des attributs, c'est-à-dire le titre des colonnes, donne la structure de la table, elle indique la liste des informations qui vont être stockées pour chaque tuple.</p>
                        <p>Commençons par un exemple simple dans un classeur Excel :</p>
                        <img src="../images/classeur_excel_clients.PNG" alt="classeur Excel clients">
                        <p>Dans cet exemple, on conserve la liste de tous les clients d'une entreprise et pour chaque client, on mémorise :</p>
                        <ul>
                            <li>son numéro</li>
                            <li>son nom</li>
                            <li>son prénom</li>
                            <li>son adresse (rue et numéro)</li>
                            <li>son code postal</li>
                            <li>sa commune</li>
                            <li>son numéro de téléphone</li>
                            <li>son numéro de TVA</li>
                        </ul>
                        <p>De manière similaire, dans une base de données, les informations sont contenues dans une table.</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>num</th>
                                    <th>nom</th>
                                    <th>prenom</th>
                                    <th>adresse</th>
                                    <th>cp</th>
                                    <th>ville</th>
                                    <th>tel</th>
                                    <th>numtva</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>Dupuis</td>
                                    <td>Benoit</td>
                                    <td>clos Chapelle aux Champs, 43</td>
                                    <td>1200</td>
                                    <td>Bruxelles</td>
                                    <td>02/764.46.46</td>
                                    <td>BE413770425</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>Dupuis</td>
                                    <td>Luc</td>
                                    <td>rue Lambert Fortune, 2</td>
                                    <td>1300</td>
                                    <td>Wavre</td>
                                    <td>010/34.65.67</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>18</td>
                                    <td>Van Moer</td>
                                    <td>Willy</td>
                                    <td>rue Sainte Anne, 6</td>
                                    <td>1300</td>
                                    <td>Wavre</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Pour représenter la table, il est d'usage d'utiliser un <span class="html">diagramme de structure de données (DSD)</span>.</p>
                        <p>Par exemple, le DSD de la table <span class="em">clients</span> ressemble à :</p>
                        <table class="tableBalises">
                            <tbody>
                                <tr>
                                    <td class="bold">clients</td>
                                </tr>
                                <tr>
                                    <td>
                                        <p>num</p>
                                        <p>nom</p>
                                        <p>prenom</p>
                                        <p>adresse</p>
                                        <p>cp</p>
                                        <p>ville</p>
                                        <p>tel</p>
                                        <p>numtva</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Ces huit éléments sont les <span class="em">attributs</span> de la table des clients. Ils sont fixés lors de la création de la table, et existent donc quand la table est encore vide.</p>
                        <p>Les véritables informations, c'est-à-dire les coordonnées des clients réels, seront les <span class="em">tuples</span> de la table, chaque client constituant un tuple.</p>
                        <p>Lors de sa création, la table <span class="em">clients</span> définit 8 attributs. Normalement, cela ne changera pas. Si l'on a spécifié que le numéro est un nombre entier positif et que le nom est une suite de caractères de longueur maximale à 25, ces spécifications ne changeront pas non plus. Nous verrons en deuxième qu'il est quand même possible de modifier ces définitions.</p>
                        <h3 id="create_table">CREATE_TABLE :</h3>
                        <p>Pour créer une table, on utilise l'instruction <span class="html">CREATE TABLE</span> :</p>
<pre class="taille60"><code>CREATE TABLE nom_table ( [
    { nom_colonne type_donnees [ DEFAULT default_expr ] [ contrainte_colonne [...] ]
    | contrainte_table }
    [, ... ]
] )</code></pre>
                        <p>Cette représentation respecte les <span class="em">conventions syntaxiques</span> suivantes :</p>
<pre class="taille60"><code>MOT en MAJUSCULE = clause ou élément de l'instruction (mot réservé)
[] &#8594; élément facultatif
{ ... } &#8594; élément facultatif qui peut être répété
| &#8594; désigne une alternative (OU exclusif)</code></pre>
                        <p>Cette syntaxe de présentation est fréquemment utilisée dans les brochures.</p>
                        <ul>
                            <li>
                                <p><span class="em">contrainte_colonne</span> peut être :</p>
<pre class="taille60"><code>[ CONSTRAINT nom_contrainte ]
{ NOT NULL | NULL |
    UNIQUE |
    PRIMARY KEY |
    CHECK ( expression ) |
    REFERENCES table_reference [ ( colonne_reference ) ]
}</code></pre>
                            </li>
                            <li>
                                <p><span class="em">contrainte_table</span> peut être :</p>
<pre class="taille60"><code>[ CONSTRAINT nom_contrainte ]
{ UNIQUE ( nom_colonne [, ... ] ) |
    PRIMARY KEY ( nom_colonne [, ... ] ) |
    CHECK ( expression ) |
    FOREIGN KEY ( nom_colonne [, ...
] ) REFERENCES table_reference [ (
    colonne_reference [, ... ] ) ] }</code></pre>
                            </li>
                        </ul>
                        <p>Pour la table <span class="em">clients</span>, l'instruction est la suivante :</p>
<pre class="taille"><code>CREATE TABLE clients
(
    num INTEGER NOT NULL,
    nom VARCHAR(25) NOT NULL,
    prenom VARCHAR(15) NOT NULL,
    adresse VARCHAR(30) NOT NULL,
    cp INTEGER NOT NULL,
    ville VARCHAR(20) NOT NULL,
    tel VARCHAR(11) NULL,
    numtva VARCHAR(10) NULL
);</code></pre>
                        <p>Après le nom de la table, on définit les attributs. Pour chaque attribut : le premier correspond au nom de l'attribut, lesecond au type de l'attribut et enfin s'il peut être omis ou pas.</p>
                        <ol type="a">
                            <li>
                                <h4 id="conventions_ecritures">Les conventions d'écriture :</h4>
                                <p>Les noms de tables et d'attributs sont choisis par celui qui crée la table, de façon assez libre, mais en respectant toutefois certaines règles. Ils ne peuvent pas par exemple contenir des lettres accentuées (<span class="em">prenom</span> et non <span class="em">prénom</span>), ni espaces, ni caractères spéciaux.</p>
                                <p>Par contre les mots-clés (<span class="html">CREATE</span>, <span class="html">TABLE</span>, <span class="html">NULL</span>, etc.) doivent absolument figurer exactement tels quels, de mêmes que les signes particuliers : parenthèses, virgules, etc.</p>
                                <p>Seule la mise en page est totalement libre : alognement, espacements, identation, passages à la ligne. Provitons donc de cetteliberté pour améliorer la clarté et la visibilité de nos instructions.</p>
                                <p class="souligne">La sensibilité à la casse :</p>
                                <p>Les mots clés ainsi que ls noms de tables et d'attributs sans guillemets doubles, sont insensibles à la casse.</p>
                                <p>Écrire <span class="em">CREATE TABLE CLIENTS (...)</span> revient au même qu'écrire <span class="em">crEAtE taBLe cLIEnts (...)</span>.</p>
                                <p>Toutefois, une convention couramment utilisée revient à écrire les mots clés du langage en majuscule et les noms en minuscule, c'est-à-dire : <span class="em">CREATE TABLE CLIENTS (...)</span>.</p>
                                <p>On peut délimiter un identificateur en utilisant les doubles guillemets. Cela permet alors d'avoir des identifiants composés de n'importe quel caractère spécial (majuscule, minuscule, espace, ...). Exemple : CREATE TABLE "Un nOm 2 taBle trOp fUn !".</p>
                                <p>Les valeurs des attributs sont, elles, sensibles à la casse. Effectivement, si dans la table <span class="em">clients</span>, l'un des clients porte le nom <span class="em">'Dupont'</span>, cela est différent de la valeur <span class="em">'dupont'</span>.</p>
                                <p>Une chaîne de caractères en SQL est une séquence arbitraire de caractères entourée par des guillemets simples ('), c'est-à-dire <span class="em">'Ceci est une chaîne'</span>. Pour inclure un guillemet simple dans une chaîne constante,chaisissez deux guillemets adjacents, par exemple <span class="em">'L''odyssée d''Astérix'</span>. Notez que ce n'est pas un guillemet double (").</p>
                            </li>
                            <li>
                                <h4 id="types">Les types :</h4>
                                <p>Il existe différents types pour définir les attributs. Certains sont propres au SGBD, d'autres sont conformes à la norme SQL.</p>
                                <ul>
                                    <li>
                                        <h5 id="types_champs_bits">Types champs de bits :</h5>
                                        <p>Les champs de bits sont des chaînes de 0 et de 1. Ils peuvent être utilisés pour stocker ou visualiser des masques de bits. Il y a deux types de bits SQL : <span class="html">bit (n)</span> et <span class="html">bit varying (n)</span>, où <span class="em">n</span> estun entier positif.</p>
                                        <p>Les données de type <span class="em">bit</span> doivent avoir une longueur de exactement <span class="em">n</span> bits. Essayer d'y affecter une chaîne de bit longue ou plus courte déclenche une erreur. Les données de type <span class="em">bit varying</span> ont une longueur variable, mais ne peuvent dépasser une taille de <span class="em">n</span> bits. Les chaînes plus longues sont rejetées. Écrire <span class="em">bit</span> sans longueur indique une taille illimitée.</p>
                                    </li>
                                    <li>
                                        <h5 id="type_booleen">Type booléen :</h5>
                                        <p>Le type booléen ne peut avoir que deux valeurs : <span class="html">true</span> et <span class="html">false</span> (ou encore la valeur <span class="html">NULL</span>).</p>
                                        <p><span class="em">true</span> peut s'écrire littéralement de plusieurs manières : <span class="html">t</span>, <span class="html">true</span>, <span class="html">yes</span>, <span class="html">y</span> ou <span class="html">1</span>.</p>
                                        <p><span class="em">false</span> peut s'écrire littéralement des manières suivantes : <span class="html">false</span>, <span class="html">f</span>, <span class="html">no</span>, <span class="html">n</span> ou <span class="html">0</span>.</p>
                                        <p>Il est recommandé d'utiliser <span class="html">TRUE</span> et <span class="html">FALSE</span> qui sont compatibles avec la norme SQL.</p>
                                    </li>
                                    <li>
                                        <h5 id="types_caracteres">Types caractères :</h5>
                                        <table class="tableBalises">
                                            <thead>
                                                <tr>
                                                    <th>Nom</th>
                                                    <th>Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td><span class="html">character varying (n)</span>, <span class="html">varchar (n)</span></td>
                                                    <td>Longueur variable avec limite</td>
                                                </tr>
                                                <tr>
                                                    <td><span class="html">character (n)</span>, <span class="html">char (n)</span></td>
                                                    <td>Longueur fixe, comblé avec des espaces</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">text</td>
                                                    <td>Longueur variable illimitée</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <p>SQL définit deux types de caractères principaux : <span class="html">character varying (n)</span> et <span class="html">character (n)</span>, où <span class="html">n</span> est un entier positif. Ces deux types peuvent stocker des chaînes de caractères de taille inférieure ou égale à <span class="em">n</span>. Une tentative d'insérer une chaîne trop longue donnera une erreur, à moins que les caractères en trop soient tous des espaces, auquel cas la chaîne sera tronquée à la taille maximale. Si la chaîne est plus petite que la taille déclarée, elle sera complétée par des espaces pourle type <span class="em">character</span>, et elle sera stockée telle quelle pour le type <span class="em">character varying</span>.</p>
                                        <p>Les notations <span class="em">varchar (n)</span> et <span class="em">char (n)</span> sont des alias pour <span class="em">character varying (n)</span> et <span class="em">character (n)</span>, respectivement.</p>
                                        <p><span class="em">character</span> sans indication de taille, le type accepte des chaînes de toutes tailles. Il s'agit là d'une spécificité du PostgreSQL.</p>
                                        <p>PostgreSQL propose aussi le type <span class="em">text</span>, qui permet de stocker des chaînes de n'importe quelle taille. Bien que le type <span class="em">text</span> ne soit pas dans le standardSQL, plusieurs autres sytèmes de gestion de bases de données SQL le proposent aussi.</p>
                                    </li>
                                    <li>
                                        <h5 id="types_numeriques">Types numériques :</h5>
                                        <p>Les types numériques sont constitués d'entiers de 2, 4 ou 8 octets, de nombres à virgule flottante de 4 ou 8 octets, de décimaux à précision fixe.</p>
                                        <table class="tableBalises">
                                            <thead>
                                                <tr>
                                                    <th>Nom</th>
                                                    <th>Taille de stockage</th>
                                                    <th>Description</th>
                                                    <th>Étendue</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td class="html">bigint</td>
                                                    <td>8 octets</td>
                                                    <td>grand entier</td>
                                                    <td>de -9223372036854775808 à 9223372036854775807</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">smallint</td>
                                                    <td>2 octets</td>
                                                    <td>entier de faible étendue</td>
                                                    <td>de -32768 à 32767</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">integer</td>
                                                    <td>4 octets</td>
                                                    <td>entier (le plus fréquent)</td>
                                                    <td>de -2147483648 à 2147483647</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">decimal</td>
                                                    <td>variable</td>
                                                    <td>Valeurs indiquées par l'utilisateur. Valeurs exactes.</td>
                                                    <td>pas de limite</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">numeric</td>
                                                    <td>variable</td>
                                                    <td>Valeurs indiquées par l'utilisateur. Valeurs exactes.</td>
                                                    <td>pas de limite</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">real</td>
                                                    <td>4 octets</td>
                                                    <td>Précision variable. Valeurs inexactes.</td>
                                                    <td>Précision de 6 décimales</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">double precision</td>
                                                    <td>8 octets</td>
                                                    <td>Précision variable. Valeur inexactes.</td>
                                                    <td>Précision de 15 décimales</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <p>Les types <span class="html">smallint</span>, <span class="html">integer</span> et <span class="html">bigint</span> stockent des nombres entiers, c'est-à-dire sans décimale, de différentes étendues. Toute tentative d'y stockerune valeur trop grande ou trop petite produit une erreur.</p>
                                        <p>Le type <span class="html">integr</span> est le plus courant. Il offre un bon compromis entre capacité, espace utilisé et performances. Le type <span class="html">smallint</span> est utilisé que si l'économie d'espace disque est le premier critère de choix. Le type <span class="html">bigint</span> ne doit être utilisé que si le type <span class="html">integer</span> n'offre pas une étendue suffisante, car le type <span class="html">integer</span> est nettement plus rapide.</p>
                                        <p>Le type <span class="html">numeric</span> peut stocker des nombres avec jusqu'au 1000 chiffres significatifs et effectuer des calculs exacts. Il est spécialement recommander pour stocker les montants financiers et autres quantités pour lesquelles l'exactitude est indispensable. Néanmoins, le type <span class="html">numeric</span> est très lent comparé aux types à virgule flottante décrit ci-après.</p>
                                        <p>L'échelle d'un <span class="html">numeric</span> est le nombre de chiffres décimaux de la partie fractionnaire, c'est-à-dire le nombre de chiffres après la virgule.</p>
                                        <p>La précision d'un <span class="html">numeric</span> est le nombre de chiffres permis avant et après la virgule.</p>
                                        <p>Donc, le nombre 23,5151 a une précision de 6 et une échelle de 4. On peut considérer que les entiers ont une échelle de 0.</p>
                                        <p>La précision et l'échelle d'un numérique peuvent être réglés. Pour déclarer une colonne de type numérique, il faut utiliser la syntaxe <span class="html">NUMERIC (précision, échelle)</span>.</p>
                                        <p>La précision peut être strictement positive, l'échelle positive ou nulle. Alternativement, on peut écrire <span class="html">NUMERIC (précision)</span>. Dans ce cas, l'échele est de 0.</p>
                                        <p>Les types <span class="html">decimal</span> et <span class="html">numeric</span> sont équivalents. Les deux types sont dans le standard SQL.</p>
                                        <p>Les types de données <span class="html">real</span> et <span class="html">double precision</span> sont des types numériques à précision variable inexacts. En pratique, ils sont généralement conformes à la norme IEEE 754 pour l'arithmétique binaire à virgule flottante (respectivement simplement et double précision), dans la mesure où les processeurs, le système d'exploitation et le compilateur les supportent.</p>
                                    </li>
                                    <li>
                                        <h5 id="types_date_heure">Types date/heure :</h5>
                                        <table class="tableBalises">
                                            <thead>
                                                <tr>
                                                    <th>Nom</th>
                                                    <th>Taille de stockage</th>
                                                    <th>Description</th>
                                                    <th>Valeur minimale</th>
                                                    <th>Valeur maximale</th>
                                                    <th>Résolution</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td class="html">timestamp [ (p) ] [ without time zone ]</td>
                                                    <td>8 octets</td>
                                                    <td>date et heure</td>
                                                    <td>4713 avant J.C.</td>
                                                    <td>5874897 après J.C.</td>
                                                    <td>1 microseconde / 14 chiffres</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">timestamp [ (p) ] with time zone</td>
                                                    <td>8 octets</td>
                                                    <td>date et heure, avec fuseau horaire</td>
                                                    <td>4713 avant J.C.</td>
                                                    <td>5874897 après J.C.</td>
                                                    <td>1 microseconde / 14 chiffres</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">interval [ (p) ]</td>
                                                    <td>12 octets</td>
                                                    <td>intervales de temps</td>
                                                    <td>-178000000 années</td>
                                                    <td>178000000 années</td>
                                                    <td>1 microseconde</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">date</td>
                                                    <td>4 octets</td>
                                                    <td>date seulement</td>
                                                    <td>4713 avant J.C.</td>
                                                    <td>32767 après J.C.</td>
                                                    <td>1 jour</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">time [ (p) ] [ without time zone ]</td>
                                                    <td>8 octets</td>
                                                    <td>heures seulement</td>
                                                    <td>00:00:00.00</td>
                                                    <td>23:59:59.99</td>
                                                    <td>1 microseconde</td>
                                                </tr>
                                                <tr>
                                                    <td class="html">time [ (p) ] [ with time zone ]</td>
                                                    <td>8 octets</td>
                                                    <td>heures seulement, avec fuseau horaire</td>
                                                    <td>00:00:00.00+12</td>
                                                    <td>1 microseconde</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <p><span class="html">time</span>, <span class="html">timestamp</span>, et <span class="html">interval</span> acceptent une précision optionnelle <span class="em">p</span>, qui précise le nombre de chiffres après la virgule pour les secondes. Par défaut, il n'y a pas de limiteexplicite à la précision. Les valeurs acceptées pour <span class="em">p</span> vont de 0 à 6 pour les types <span class="html">timestamp</span> et <span class="html">interval</span>.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="null">NULL :</h4>
                                <p>Dans l'instruction <span class="html">CREATE TABLE</span>, après le type, <span class="html">NOT NULL</span> ou <span class="html">NULL</span> indique que cet attribut doit avoir une valeur bien spécifiée ou pas pour chaque tuple.</p>
                                <p>La valeur <span class="html">NULL</span> marque les colonnes ayant une valeur inconnue. Attention, il ne s'agit <span class="em">ni</span> de la valeur <span class="em">zéro ni</span> de la <span class="em">chaîne vide</span>. <span class="html">NULL</span> permet la distinction entre une saisie délibérée de zéro (pour les colonnes numériques) ou vide (pour les colonnes de type caractère) et la non saisie.</p>
                                <p>En gros, <span class="html">NULL</span> n'est ni <span class="em">0</span> ni <span class="em">''</span>.</p>
                                <p>Une valeur <span class="html">NULL</span> ne peut <span class="em">jamais vérifier une égalité</span>, même avec une autre valeur <span class="html">NULL</span>.</p>
                                <p>Une règle liée à une colonne doit inclure <span class="html">NULL</span> dans sa définition pour permettre l'insertion de valeur <span class="html">NULL</span>. Quand une ligne est créée, si aucune valeur n'est spécifiée dans la colonne, si aucun défaut n'est défini, si les <span class="html">NULL</span> sont permis dans la colonne, alors le serveur assinera automatiquement la valeur <span class="html">NULL</span>.</p>
                                <p>Lors de la création, la mention <span class="html">NULL</span> peut être omise car elle constitue l'option <span class="em">"par défaut"</span>; ce qui signifie que si on n'écrit ni <span class="html">NOT NULL</span> ni <span class="html">NULL</span> lors de la définition d'un attribut donné, le système le considère comme <span class="html">NULL</span> <span class="em">SAUF</span>, évidemment, pour la clé primaire !</p>
                            </li>
                        </ol>
                        <h3 id="cle_primaire">La clé primaire :</h3>
                        <p>Rien n'impose, pour le moment, que le numéro de client soit différent pour chaque client. La seule chose que l'on sait, c'est que deux tuples complets ne devraient pas être identiques. Mais rien n'empêche pour le moment d'ajouter le tuple suivant :</p>
                        <table class="tableBalises">
                            <tbody>
                                <tr>
                                    <td class="bold">3</td>
                                    <td>Dupuis</td>
                                    <td>Luc</td>
                                    <td>Rue Brol, 7</td>
                                    <td>1000</td>
                                    <td>Bruxelles</td>
                                    <td>02/764.46.54</td>
                                    <td>NULL</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Mais il existe déjà un client dont le numéro est 3 :</p>
                        <table class="tableBalises">
                            <tbody>
                                <tr>
                                    <td class="bold">3</td>
                                    <td>Dupuis</td>
                                    <td>Luc</td>
                                    <td>rue Lambert Fortune, 2</td>
                                    <td>1300</td>
                                    <td>Wavre</td>
                                    <td>010/34.65.67</td>
                                    <td>NULL</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Une telle situation est malsaine : ou bien il s'agit bien du même client et les programmes qui utilisent cette table pourraient croire qu'il y en a deux; ou bien il s'agit de deux clients distincts, mais alors des numéros distincts.</p>
                        <p>La notation de <span class="em">clé primaire</span> (<span class="em">PRIMARY KEY</span> en anglais) permet de résoudre ce problème. Si l'on spécifique que <span class="em">num</span> est une clé primaire, le SGBD va automatiquement s'assurer que toutes les valeurs données à cet attribut sont différentes une des autres, et, en particulier, refuser l'ajout du tuple proposé ci-dessus.</p>
                        <p>La clé primaire permet de rendre unique chaque tuple de la table; la table n'est pas considére comme une séquence de tuples, mais bien comme un <span class="em">ensemble</span> (au sens mathématique) de tuples.</p>
                        <table class="tableBalises">
                            <tbody>
                                <tr>
                                    <td class="bold">clients</td>
                                </tr>
                                <tr>
                                    <td class="bold">PK <span class="souligne">num</span></td>
                                </tr>
                                <tr>
                                    <td>
                                        <p>nom NN</p>
                                        <p>prenom NN</p>
                                        <p>adresse NN</p>
                                        <p>cp NN</p>
                                        <p>ville NN</p>
                                        <p>tel</p>
                                        <p>numtva</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>L'instruction de création de table deviendra :</p>
<pre class="taille60"><code>CREATE TABLE clients
(
    num INTEGER <span class="em">PRIMARY KEY</span>,
    nom VARCHAR(25) NOT NULL,
    prenom VARCHAR(15) NOT NULL,
    adresse VARCHAR(30) NOT NULL,
    cp INTEGER NOT NULL,
    ville VARCHAR(20) NOT NULL,
    tel VARCHAR(11),
    numtva VARCHAR(10),
);</code></pre>
                        <p>Notons qu'une <span class="em">clé primaire</span> est <span class="em">toujours</span> <span class="html">NOT NULL</span>, il est donc <span class="em">inutile</span> de le préciser !</p>
                        <p>Il s'agit du diagramme de structure de données correspondant à la table <span class="em">CLIENTS</span>. Dans ce diagramme, nous indiquons qu'un champ est <span class="html">NOT NULL</span> avec l'abréviation <span class="html">NN</span>.</p>
                        <h3 id="commentaires">Les commentaires :</h3>
                        <p>Un commentaire est une séquence de caractères commençant avec deux tirets qui s'étend jusqu'à la fin de la ligne, par exemple : <span class="em">-- Ceci est un commentaire standard en SQL</span>.</p>
                        <p>Autrement, les blocs de commentaires peuvent aussi être utilisés :</p>
<pre class="taille60"><code>/* commentaires multilignes
* et imbriqués : /* bloc de commentaire imbriqué */
*/</code></pre>
                        <p>où le commentaire commence avec <span class="html">/*</span> et s'étend jusqu'à l'occurence de <span class="html">*/</span>.</p>
                        <h3 id="insert_into">INSERT INTO :</h3>
                        <p>L'ajout d'un tuple dans une table se fait par l'instruction <span class="html">INSERT INTO</span>, dont la syntaxe est donnée ci-dessous :</p>
<pre class="taille60"><code>INSERT INTO table [ ( colonne [, ...] ) ]
    { DEFAULT VALUES
    | VALUES ( { expression | DEFAULT } [, ...] ) [, ...]
    [ RETURNING * | expression_sortie [ [ AS ] nom_sortie ] [, ...] ]</code></pre>
                        <p>Chaque valeur correspond à la colonne qui a la même position dans la liste.</p>
                        <p>Une <span class="em">valeur</span> est soit un nombre, soit une chaîne de caractères (entourée de 'simples guillemets') soit NULL, soit une date, etc.</p>
                        <p>L'ordre des noms des colonnes n'a pas d'importance. Si la liste des <span class="em">nom_colonne</span> n'est pas spécifiée, c'est la liste du <span class="em">CREATE TABLE</span> qui est supposée.</p>
                        <p>On voit qu'il peut y avoir deux situations :</p>
                        <ul>
                            <li>ou bien une liste de noms d'attributs est spécifiée : dans ce cas, la liste des valeurs doit comporter le même nombre d'éléments, et chaque valeur correspond au nom d'attribut situé au même numéro d'ordre dans la liste (la première valeur est celle du premier attribut listé, la deuxièmeest celle du deuxième attribut listé, etc.).</li>
                            <li>ou bien la liste n'est pas spécifiée : c'est comme si on avait noté tous les attributs de cette table, dans l'ordre où ils ont été fournis lors du <span class="html">CREATE TABLE</span>.</li>
                        </ul>
                        <p>Chaque colonne absente de la liste, implicite ou explicite, des colonnes se voit attribuer sa valeur par défaut, s'il y en a une, ou NULL dans le cas contraire.</p>
                        <p>Un trnastypage automatique est entrepris lorsque l'expression d'une colonne ne correspond pas au type de donnée déclaré.</p>
                        <p>La clause <span class="html">RETURNING</span> optionnelle fait que <span class="em">INSERT INTO</span> calcule et renvoie les valeurs basées sur chaque ligne en cours d'insertion. C'est principalement utile pour obtenir les valeurs qui ont été fournies par défaut, comme un numéro de séquence (confer 0). Néanmoins, toute expression utilisant les colonnes de la table est autorisée. La syntaxe de la liste <span class="em">RETURNING</span> est identique à celle de la commande <span class="em">SELECT</span>.</p>
                        <p>Voici différentes façons d'ajouter le tuple (à supposer qu'il ne soit pas encore présent dans la table) :</p>
<pre class="taille60"><code>INSERT INTO clients
VALUES (18, 'Van Moer', 'Willy', 'rue Sainte Anne, 6', 1300, 'Wavre', NULL, NULL);

INSER INTO clients (num, nom, prenom, adresse, cp, ville, tel, numtva)
VALUES (18, 'Van Moer', 'Willy', 'rue Sainte Anne, 6', 1300, 'Wavre', NULL, NULL);

INSERT INTO clients (num, nom, prenom, adresse, cp, ville)
VALUES (18, 'Van Moer', 'Willy', 'rue Sainte Anne, 6', 1300, 'Wavre');

INSERT INTO clients (num, nom, prenom, adresse, cp, ville, numtva
VALUES (18, 'Van Moer', 'Willy', 'rue Sainte Anne, 6', 1300, 'Wavre', NULL);

INSERT INTO clients (nom, prenom, numtva, num, tel, adresse, cp, ville)
VALUES ('Van Moer', 'Willy', NULL, 18, NULL, 'rue Sainte Anne, 6', 1300, 'Wavre');

INSERT INTO clients (num, prenom, nom, adresse, cp, ville)
VALUES (18, 'Willy', 'Van Moer', 'rue Sainte Anne, 6', 1300, 'Wavre');</code></pre>
                        <h3 id="update_set_where">UPDATE ... SET ... WHERE ...</h3>
<pre class="taille60"><code>UPDATE table
    SET { colonne = { expression | DEFAULT } |
    ( colonne [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]
    [ FROM liste_from ]
    [ WHERE condition ]
    [ RETURNING * | expression_sortie [ [ AS ] nom_sortie ] [, ...] ]</code></pre>
                        <ul>
                            <li>
                                <p><span class="html">UPDATE</span> modifie les valeurs des colonnes spécifiées pour toutes les lignes qui satisfont la condition. Seules les colonnes à modifier doivent être mentionnées dans la clause <span class="html">SET</span>; les autres colonnes conservent leur valeur.</p>
                                <p>La clause <span class="html">RETURNING</span> optionnelle fait que <span class="em">UPDATE</span> calcule et renvoie les valeurs basées sur chaque ligne en cours de mise à jour. Toute expression utilisant les colonnes de la table et/ou les colonnes d'autres tables mentionnées dans <span class="em">FROM</span> peut être calculée. La syntaxe de la liste <span class="em">RETURNING</span> est identique à celle de la commande <span class="em">SELECT</span>.</p>
                            </li>
                        </ul>
                        <h3 id="delete_from">DELETE FROM ... :</h3>
<pre class="taille60"><code>DELETE FROM table
    [ WHERE condition ]
    [ RETURNING * | expression_sortie [ [ AS ] output_name ] [, ...] ]</code></pre>
                        <ul>
                            <li>
                                <p><span class="html">DELETE</span> supprime de la table spécifiée les lignes qui satisfont la clause <span class="em">WHERE</span>. Si la clause <span class="em">WHERE</span> est absente, toutes les lignes de la table sont supprimées. Le résultat est une table valide, mais vide.</p>
                                <p>La clause <span class="html">RETURNING</span> optionnelle fait que <span class="em">DELETE</span> calcule et renvoie les valeurs basées sur chaque ligne en coursde suppression. La syntaxe de la liste <span class="em">RETURNING</span> est identique à celle de la commande <span class="em">SELECT</span>.</p>
                            </li>
                        </ul>
                        <h3 id="select">SELECT :</h3>
                        <p>L'instruction la plus utilisée et la plus riche en SQL est l'instruction <span class="html">SELECT</span> qui permet de consulter les données en affichant celles-ci de façon brute ou y apportant un certain traitement.</p>
<pre class="taille60"><code>SELECT [DISTINCT] *
    | [nom_table.] nom_colonne {,[nom_table . ] nom_colonne...}
    | nom_fonction (* | nom_colonne)
FROM nom_table {, nom_table...}
WHERE nom_condition
GROUP BY nom_colonne {, nom_colonne...}
HAVING nom_condition
ORDER BY nom_colonne {,nom_colonne...} | numero_champ</code></pre>
                        <ul>
                            <li><span class="em">*</span> permet de sélectionner tous les attributs de la table.</li>
                            <li><span class="em">nom_table</span> désigne le nom d'une table.</li>
                            <li><span class="em">DISTINCT</span> permet de ne pas répéter des valeurs identiques, <span class="em">DISTINCT</span> porte sur tous les attributs du <span class="em">SELECT</span>.</li>
                            <li><span class="em">nom_condition</span> se compose généralement d'un nom de colonne , d'un opérateur (<span class="em">=</span>, <span class="em">&lt;</span>, <span class="em">&gt;</span>, <span class="em">&lt;=</span>, <span class="em">&gt;=</span>, <span class="em">&lt;&gt;</span>, <span class="em">IS</span>) et d'une valeur (entier, caractère ou <span class="em">NULL</span>) ou d'un autre nom de colonne.</li>
                            <li><span class="em">nom_colonne</span> est le nom d'une colonne, s'il se trouve derrière la clause <span class="em">SELECT</span>, il doit se trouver également derrière la clause <span class="em">GROUP BY</span> (si cette clause est présente); mais inversement, on peut placer un nom de colonne derrière la clause <span class="em">GROUP BY</span> qui ne se trouve pas derrière la clause <span class="em">SELECT</span>.</li>
                            <li><span class="em">numero_champ</span> est un entier qui désigne la position du <span class="em">nom_colonne</span> dans la liste qui suit la clause <span class="em">SELECT</span>.</li>
                        </ul>
                        <p>Voici quelques exemples qui s'appuient yous sur la table de trois tuple donnée précédemment.</p>
<pre class="taille60"><code>&gt; SELECT* FROM clients;</code></pre>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>num</th>
                                    <th>nom</th>
                                    <th>prenom</th>
                                    <th>adresse</th>
                                    <th>cp</th>
                                    <th>ville</th>
                                    <th>tel</th>
                                    <th>numtva</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>Dupuis</td>
                                    <td>Benoit</td>
                                    <td>clos Chapelle aux Champs, 43</td>
                                    <td>1200</td>
                                    <td>Bruxelles</td>
                                    <td>02/764.46.46</td>
                                    <td>BE413770425</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>Dupuis</td>
                                    <td>Luc</td>
                                    <td>rue Lambert Fortune, 2</td>
                                    <td>1300</td>
                                    <td>Wavre</td>
                                    <td>010/34.65.67</td>
                                    <td>NULL</td>
                                </tr>
                                <tr>
                                    <td>18</td>
                                    <td>Van Moer</td>
                                    <td>Willy</td>
                                    <td>rue Sainte Anne, 6</td>
                                    <td>1300</td>
                                    <td>Wavre</td>
                                    <td>NULL</td>
                                    <td>NULL</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Le résultat pourrait être présenté dans un autre ordre puisqu'il s'agit d'un ensemble de lignes.</p>
<pre class="taille60"><code>&gt; SELECT num, nom, prenom, tel, cp FROM clients;</code></pre>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>num</th>
                                    <th>nom</th>
                                    <th>prenom</th>
                                    <th>tel</th>
                                    <th>cp</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>Dupuis</td>
                                    <td>Benoit</td>
                                    <td>02/764.46.46</td>
                                    <td>1200</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>Dupuis</td>
                                    <td>Luc</td>
                                    <td>010/34.65.67</td>
                                    <td>1300</td>
                                </tr>
                                <tr>
                                    <td>18</td>
                                    <td>Van Moer</td>
                                    <td>Willy</td>
                                    <td>NULL</td>
                                    <td>1300</td>
                                </tr>
                            </tbody>
                        </table>
<pre class="taille60"><code>&gt; SELECT cp FROM clients;</code></pre>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>cp</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1200</td>
                                </tr>
                                <tr>
                                    <td>1300</td>
                                </tr>
                                <tr>
                                    <td>1300</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>On constate que les lignes identiques du résultat (1300) se répètent lorsque l'on fait <span class="html">SELECT cp FROM clients</span>. Pour éviter cette répétition de valeur identique, il faut employer <span class="em">DISTINCT</span>.</p>
                        <ol type="a">
                            <li>
                                <h4 id="distinct">DISTINCT :</h4>
                                <p>Le mot <span class="em">DISTINCT</span> a pour effet que des lignes identiques du résultat ne sont affichées qu'une seule fois. Pour corriger l'erreur de la ligne précédente, on doit faire <span class="html">SELECT DISTINCT cp FROM clients</span>.</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>cp</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>1200</td>
                                        </tr>
                                        <tr>
                                            <td>1300</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p><span class="em">DISTINCT</span> porte sur toutes les colonnes du <span class="em">SELECT</span>. Efectivement, dans l'exemple <span class="em">SELECT DISTINCT nom, prenom FROM clients</span>, <span class="em">DISTINCT</span> porte sur le <span class="em">nom</span> et le <span class="em">prenom</span>. Le résultat de cette requête sera :</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>nom</th>
                                            <th>prenom</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                            <li>
                                <h4 id="where">WHERE - Les conditions :</h4>
                                <p><span class="em">Les conditions simples</span> ne posent pasde problème particulier. Les signes <span class="em">&lt;&gt;</span>, <span class="em">&lt;=</span> et <span class="em">&gt;=</span> signifient respectivement différent, plus petit ou égal, plus grand ou égal.</p>
                                <p>Les symbolesd'égalité (<span class="em">=</span>) et d'inégalité (<span class="em">&lt;&gt;</span>) portent sur tous les types de données, qu'elles soient numériques ou pas, alors que les symmboles de comparaison (<span class="em">&lt;</span>, <span class="em">&gt;</span>, <span class="em">&lt;=</span>, <span class="em">&gt;=</span>) s'utilisent de préférence sur les données numériques (<span class="em">integer</span>, <span class="em">float</span>, <span class="em">numeric</span>, <span class="em">decimal</span>).</p>
                                <p><span class="em">Les conditions générales</span> qui incluent les opérations <span class="em">AND</span>, <span class="em">OR</span>, <span class="em">NOT</span>, demandent quelques précisions et compléments.</p>
                                <h5 id="operations_logiques">Les opérations logiques :</h5>
                                <ul>
                                    <li><span class="html">NOT</span> : si la condition que nous appelerons C a la valeur "VRAI", la condition <span class="em">NOT</span> C aura la valeur "FAUX", et vice-versa.</li>
                                    <li><span class="html">AND</span> : C1 <span class="em">AND</span> C2 ne sera vrai que si C1 est vrai et que C2 est également vrai.</li>
                                    <li><span class="html">OR</span> : C1 <span class="em">OR</span> C2 sera vrai qu'au moins une des deux conditions C1 ou C2 est vraie.</li>
                                </ul>
                                <p>On remarque que le <span class="em">OR</span> est un "OU inclusif", qui signifie "l'un ou l'autre ou les deux", ... à ne pas confondre avec le "OU exclusif", qui signifie "un et un seul parmi les deux".</p>
                                <h5 id="priorite_operations_parentheses">La priorité des opérations et parenthèses :</h5>
                                <p>Que se passe-t-il dans les situations suivantes :</p>
                                <ol type="a">
                                    <li class="em">C1 AND C2 OR C3</li>
                                    <li class="em">NOT C1 AND C2</li>
                                </ol>
                                <p>Supposons que C1 et C2 soient FAUX, tandis que C3 a la valeur VRAI. La première condition (a) ci-dessus peut être interprétée de deux façons :</p>
                                <p><span class="em">(C1 AND C2) OR C3</span> ce qui donne VRAI, puisque C3 est VRAI.</p>
                                <p><span class="em">C1 AND (C2 OR C3)</span> ce qui donne FAUX, puisque C1 est FAUX.</p>
                                <p>L'utilisation de parenthèses dans les conditions permet au programmeur de choisir le cas qu'il souhaite. Mais il a aussi le droit de ne pas mettre de parznthèses, ce qui suppose que, dans la définition du langage SQL, on ait spécifié une priorité relative des opérateurs <span class="em">AND</span> et <span class="em">OR</span>, sans quoi l'expression <span class="em">C1 AND C2 OR C3</span> serait ambigüe. La convention choisie par les créateurs de SQL, qui est celle dans la majorité des langages de programmation ou d'interrogation de base de données, est que le <span class="em">AND</span> a priorité sur le <span class="em">OR</span> c'est-à-dire il est plus fort que lui. Cela signifie que la condition doit se lire comme : <span class="em">(C1 AND C2) OR C3</span>.</p>
                                <p>Cette situation est celle de la multiplication par rapport à l'addition (rappel : PEMDAS = Parenthèse, Exposant, Multiplication, Division, Addition, Soustraction) :</p>
                                <p><span class="em">3 * 4 + 6</span> représente <span class="em">(3 * 4) +6</span> et non pas <span class="em">3 * (4 + 6)</span>.</p>

                                <p>La convention donne la priorité au <span class="html">NOT</span> sur le <span class="html">AND</span> (et a fortiori sur le <span class="html">OR</span>), si bien qu'en absence de parenthèses c'est la première des deux interprétations (<span class="em">(NOT C1) AND C2</span> et <span class="em">NOT (C1 AND C2)</span>) qui sera choisie par SQL (et parla plupart des langages).</p>
                                <p><span class="html">LIKE</span> est une condition qui permet d'effectuer des tests sur des chaînes de caractères.</p>
                                <p><span class="em">chaine LIKE motif</span> ou encore <span class="em">chaine NOT LIKE motif</span>.</p>
                                <p>L'expression <span class="html">LIKE</span> renvoie TRUE si la chaîne est ccontenue dans l'ensemble de chaînes représentées par le motif. (L'expression <span class="html">NOT LIKE</span> renvoie <span class="em">FALSE</span> si <span class="html">LIKE</span> renvoie <span class="em">TRUE</span> et vice versa.)</p>
                                <p>Si le motif ne contient ni <span class="html">%</span> ni <span class="html">_</span>, alors il ne représente que la chaîne elle-même; dans ce cas, <span class="html">LIKE</span> agit exactement comme l'opérateur d'égalité.</p>
                                <p><span class="em">_</span> dans un motif correspond à un seul caractère.</p>
                                <p><span class="em">%</span> dans un motif correspond à toutes les chaînes de zéro ou plusieurs caractères.</p>
                                <p>Exemples :</p>
<pre class="taille60"><code>'abc' LIKE 'abc' &gt; true
'abc' LIKE 'a%' &gt; true
'abc' LIKE '_b_' &gt; true
'abc' LIKE 'c' &gt; false
'abc' LIKE 'ABC' &gt; false</code></pre>
                                <p>Remarque : la fonction <span class="html">lower()</span> permet de transformer le contenu du paramètre en minuscules pour permettre une comparaison non sensible à la casse.</p>
<pre class="taille60"><code>'abc' LIKE lower ('ABC') &gt; true</code></pre>
                                <p><span class="html">IS NULL</span> et <span class="html">IS NOT NULL</span> est une condition particulière puisqu'elle permet de tester si la valeur est précisée ou pas. Effectivement, une valeur <span class="html">NULL</span> ne peut jamais vérifier une égalité (<span class="em">=</span>) ou inégalité (<span class="em">!=</span>) ou différence (<span class="em">&lt;</span> ou <span class="em">&gt;</span>), même avec une autre valeur <span class="em">NULL</span>. Pour tester si une valeur est NULL, il faut utiliser le test <span class="em">IS NULL</span>.</p>
                                <p>Par exemple :</p>
<pre class="taille60"><code>SELECT * FROM clients WHERE numtva IS NULL;</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>num</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                            <th>adresse</th>
                                            <th>cp</th>
                                            <th>ville</th>
                                            <th>tel</th>
                                            <th>numtva</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>3</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                            <td>rue Lambert Fortune, 2</td>
                                            <td>1300</td>
                                            <td>Wavre</td>
                                            <td>010/34.65.67</td>
                                            <td>NULL</td>
                                        </tr>
                                        <tr>
                                            <td>18</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                            <td>rue Sainte Anne, 6</td>
                                            <td>1300</td>
                                            <td>Wavre</td>
                                            <td>NULL</td>
                                            <td>NULL</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Il faut rester prudent car les valeurs <span class="em">NULL</span> sont automatiquement exclues du résultat. Pour rappel, les valeurs sont sensibles à la casse ! Prenons un exemple :</p>
<pre class="taille60"><code>&gt; SELECT * FROM clients WHERE numtva &gt; 'BE00000000'</code></pre>
                                <p>Le résultat prendra en compte uniquement les clients pour lesquels le numéro de tva a été précisé et le comparera avec la valeur '<span class="em">BE00000000</span>'. Les clients pour lesquels le <span class="em">numtva</span> est <span class="em">NULL</span> ne sont pas comparables donc exclus du résultat.</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>num</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                            <th>adresse</th>
                                            <th>cp</th>
                                            <th>ville</th>
                                            <th>tel</th>
                                            <th>numtva</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>1</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                            <td>clos Chappelle aux Champs, 43</td>
                                            <td>1200</td>
                                            <td>Bruxelles</td>
                                            <td>02/764.46.46</td>
                                            <td>BE413770425</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Si on désire également considérer ceux pour lesquels le numéro de tva n'est pas précisé, il faut le mentionner explicitement :</p>
<pre class="taille60"><code>&gt; SELECT * FROM clients WHERE numtva &gt; 'BE00000000' OR numtva IS NULL;</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>num</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                            <th>adresse</th>
                                            <th>cp</th>
                                            <th>ville</th>
                                            <th>tel</th>
                                            <th>numtva</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>1</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                            <td>clos Chappelle aux Champs, 43</td>
                                            <td>1200</td>
                                            <td>Bruxelles</td>
                                            <td>02/764.46.46</td>
                                            <td>BE413770425</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                            <td>rue Lambert Fortune, 2</td>
                                            <td>1300</td>
                                            <td>Wavre</td>
                                            <td>010/34.65.67</td>
                                            <td>NULL</td>
                                        </tr>
                                        <tr>
                                            <td>18</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                            <td>rue Sainte Anne, 6</td>
                                            <td>1300</td>
                                            <td>Wavre</td>
                                            <td>NULL</td>
                                            <td>NULL</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                            <li>
                                <h4 id="order_by">ORDER BY :</h4>
                                <p>Comme il a été dit précédemmment, les tuples d'une table relationnelle n'ont en principe aucun ordre. De même, les résultats affichés par SQL peuvent l'être dans n'importe quel ordre : rien n'est garanti à ce sujet.</p>
                                <p>Cependant, on souhaite souvent que les résultats soient affichés dans un certain ordre : ordre croissant ou décroissant de numéro, de prix, d'âge, ordre alphabétique des noms, ordre chronologique, etc. À cet effet, il lui suffit d'ajouter une clause <span class="html">ORDER BY</span> à la fin de son instruction <span class="html">SELECT</span>.</p>
                                <p>Les lignes du résultat sont alors rangées dans l'ordre de l'attribut indiqué ou de la colonne dont le numéro d'ordre est indiqué. Cet attribut ou cette colonne est appelé "clé de tri". Les lignes sont rangées dans l'ordre croissant (numériquement en alphabétiquement selon le cas) si l'on a indiqué <span class="html">ASC</span>, <span class="html">ASCENDING</span> ou rien de tout, et dans l'ordre décroissant si l'on a indiqué <span class="html">DESC</span> ou <span class="html">DESCENDING</span>.</p>
                                <p>Si un second attribut ou un second numéro de colonne est indiqué, il sert à ordonner entre eux les tiples qui auraient même valeur pour la première clé de tri. Et ainsi de suite s'il y a de nouveau des ex-aequo pour cette deuxième clé de tri.</p>
                                <p>Par exemple, trions les clients par ordre anti alphabétique des prénoms :</p>
<pre class="taille60"><code>SELECT num, nom, prenom FROM clients
ORDER BY clients.prenom DESC;</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>num</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>18</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>1</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                        </ol>
                        <h3 id="fonctions_agregees">Les fonctions agrégées :</h3>
                        <ol type="a">
                            <li>
                                <h4 id="usage_fonctions_agregees">L'usage des fonctions agrégées :</h4>
                                <p>Souvent, on a besoin de connaître des valeurs globales qui sont les résultats de comparaisons ou de calculs effectués à partir de valeurs de plusieurs tuples : recherche de maximum, de minimum, de moyenne, de total, de dénombrement.</p>
                                <p>Les fonctions SQL suivantes répondent à ces besoins : <span class="html">max</span>, <span class="html">min</span>, <span class="html">avg</span>, <span class="html">sum</span>, <span class="html">count</span>. Le terme <span class="em">avg</span> est l'abréviation du mot anglais "average" qui signifie "moyenne".</p>
                                <p>Le paramètre placé entre parenthèses après une fonction d'agréagtion peut être remplacé par une expression plus générale, contenant (0,) 1 ou plusieurs attributs.</p>
                            </li>
                            <li>
                                <h4 id="resultat_fonction_agregee">Le résultat de la fonction agrégée :</h4>
                                <p>Remarquons bien que ces requêtes ne produisent chaque fois qu'une seule ligne de résultat.</p>
                                <p>Une requête telle que la suivante n'aurait aucun sens. Elle est d'ailleurs considérée comme une <span class="em">erreur</span> par la plupart des interpréteurs du langage SQL.</p>
<pre class="taille60"><code>SELECT SUM(prix), titre
FRM bd.albums
WHERE serie = 'Tintin';</code></pre>
                            </li>
                            <li>
                                <h4 id="importance_parametre_fonction_agregee">L'importance du paramètre de la fonction agrégée :</h4>
                                <p>Il est important de choisir judicieusement le paramètre de la fonction agrégée. Ce paramètre indique les lignes à prendre en compte dans le calcul.</p>
                                <table class="tableBalises">
                                    <tbody>
                                        <tr>
                                            <td class="em">
<pre class="taille60"><code>&gt; SELECT COUNT (*)
FROM bd1.albums;</code></pre>
                                            </td>
                                            <td><span class="em">COUNT (*)</span> : sélection de toutes les lignes.</td>
                                        </tr>
                                        <tr>
                                            <td class="em">
<pre class="taille60"><code>&gt; SELECT COUNT (serie)
FROM bd1.albums;</code></pre>
                                            </td>
                                            <td><span class="em">COUNT (serie)</span> : sélection de toutes les lignes pour lesquelles la série est spécifiée (non NULL).</td>
                                        </tr>
                                        <tr>
                                            <td class="em">
<pre class="taille60"><code>&gt; SELECT COUNT (DISTINCT serie)
FROM bd1.albums;</code></pre>
                                            </td>
                                            <td><span class="em">COUNT (DISINCT serie)</span> : sélection de toutes les séries différentes.</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                        </ol>
                        <h3 id="relation_1_aN">La relation de 1 à N :</h3>
                        <p>Reprenons notre exemple <span class="em">clients</span>.Dans cet exemple utilisé jusqu'ici, on s'occupait d'un type d'informations, à savoir les clients. Une seule table pouvait rassembler les informations utiles à leur sujet.</p>
                        <p>Intéressons-nous à présent à deux types d'objets, liés entre eux, par exemple les clients et leurs commandes.</p>
                        <p>Si on n'avait affaire qu'à des clients occassionnels, c'est-à-dire des clients qui commandent un article au comptoir, reçoivent leur marchandise et la paient puis "disparaissent dans la nature", on pourrait continuer à travailler avec une seule table, celle des "clients+commandes", dont chaque ligne contiendrait :</p>
                        <ul>
                            <li>les informations relatives au client (nom, adresse, etc.)</li>
                            <li>les informations relatives à la commande du client (nom de l'article, quantité, prix, etc.)</li>
                        </ul>
                        <p>Souvent cependant, on traite avec des clients réguliers, dont on mémorise une fois toutes les coordonnées. La méthode à une seule table demanderait de mémoriser le nom et l'adresse d'un client autant de fois qu'il a effectué des commandes. Il est beaucoup plus efficace de ne mémoriser qu'à un seul endroit les informations relatives au client, dans une "table des clients", et d'indiquer dans une autre table, la "table des commandes", les informations relatives aux commandes. Mais il faudra un lien entre les deux tables, car on doit, pour chaque commande, pivroir retrouver le client auquel elle se rapporte, ainsi que les coordonnées de ce client.</p>
                        <p>Le lien entre deux concepts tels que "clients" et "commandes" peut-être mis en évidence dans le diagramme de structure de données qui se présente comme suit :</p>
                        <img src="../images/1_N.PNG" alt="relation 1 à N">
                        <p>Lequel signifie exactement la même chose que les deux phrases suivantes :</p>
                        <ul>
                            <li>chaque client peut avoir (zéro,) un ou plusieurs commandes</li>
                            <li>chaque commande est relative à un seul client</li>
                        </ul>
                        <p>On appelle une "relation de 1 à N" entre la table <span class="em">clients</span> et la table <span class="em">commandes</span>.</p>
                        <ol type="a">
                            <li>
                                <h4 id="cle_etrangere">La clé étrangère :</h4>
                                <p>À présent, une table de commandes s'ajoute à la table des clients. Comme on doit pouvoir retrouver le client de chaque commande, nous allons prévoir, parmi les attributs de la commande, un attribut obligatoire (non NULL) qui est une <span class="em">référence au client</span>.</p>
                                <p>Nous allons à cet effet choisir une valeur qui permet de <span class="em">reconnaître le client de façon unique</span>, sans risque d'ambiguité (même si la table des clients est augmentée par la suite !) : le nom du client ne suffit pas à identifier un client précis, et même son nom et son prénom ensemble pourraient être ambigus (il peut y avoir plusieurs Luc Dupuis !). Mais nous avons heureusement prévu ci-dessus de donner à chaque client un numéro, et nous avons même spécifié que ce numéro était une <span class="em">clé primaire</span>, c'est-à-dire devait absolument être différent d'un client à l'autre : il suffit donc de remettre ce numéro de client dans le tuple relatif à une commande !</p>
                                <p>Cette mention du numéro du client dans la table des commandes constitue une <span class="em">clé étrangère</span> (<span class="html">FOREIGN KEY</span> en anglais). Le simple fait de spécifier cela dans le <span class="html">CREATE TABLE</span> va assurer que, à aucun moment, la table des commandes ne contiendra un tuple dont le numéro de client ne soit pas celui d'un client présent dans la table des clients. Dans le DSD, <span class="em">numcient</span>, la clé étrangère, doit être <span class="em">NOT NULL</span> dans notre cas mai une clé étrangère ne doit pas d'office être <span class="em">NOT NULL</span>.</p>
<pre class="taille60">CREATE TABLE commandes
(
    numcommande INTEGER PRIMARY KEY,
    jour INTEGER,
    mois INTEGER,
    annee INTEGER,
    numclient INTEGER NOT NULL REFERENCES clients (num),
    article VARCHAR(30),
    quantite INTEGER,
    prixunitaire INTEGER,
);<code></code></pre>
                                <p>Voici un exemple de contenu de cette table :</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>numcommande</th>
                                            <th>jour</th>
                                            <th>mois</th>
                                            <th>annee</th>
                                            <th>numclient</th>
                                            <th>article</th>
                                            <th>quantite</th>
                                            <th>prixunitaire</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>1</td>
                                            <td>5</td>
                                            <td>9</td>
                                            <td>2000</td>
                                            <td>1</td>
                                            <td>stylo M3</td>
                                            <td>20</td>
                                            <td>150</td>
                                        </tr>
                                        <tr>
                                            <td>2</td>
                                            <td>56</td>
                                            <td>9</td>
                                            <td>2000</td>
                                            <td>18</td>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>150</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>6</td>
                                            <td>9</td>
                                            <td>2000</td>
                                            <td>18</td>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>20</td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>8</td>
                                            <td>9</td>
                                            <td>2000</td>
                                            <td>3</td>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>80</td>
                                        </tr>
                                        <tr>
                                            <td>8</td>
                                            <td>1</td>
                                            <td>10</td>
                                            <td>2000</td>
                                            <td>1</td>
                                            <td>stylo M3</td>
                                            <td>30</td>
                                            <td>150</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                            <li>
                                <h4 id="jointure">La jointure :</h4>
                                <p>On peut à présent effectuer des recherches sur l'une ou l'autre des deux tables, ce qui n'est pas neuf, mais également sur les deux tables simultanément. On dit qu'on travaille sur la "<span class="em">jointure</span>" des deux tables.</p>
                                <p>Exemple : je veux connaître pour chaque commande, l'article, la quantité et les nom et prénom du client.</p>
<pre class="taille60"><code>SELECT commandes.article, commandes.quantite, clients.nom, clients.prenom
FROM commandes, clients
WHERE commandes.numclient = clients.num;</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>article</th>
                                            <th>quantite</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>20</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>30</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>On aura remarqué que les noms d'attributs sont précédés du nom de la table dont ils sont issus, en vue d'éviter les éventuelles ambiguités (au cas où deux tables auraient des attributs de même nom).</p>
                                <p>Dans le cas présent, il n'y a pas d'ambiguité possible, on aurait aussi écrire :</p>
<pre class="taille60"><code>SELECT article, quantite, nom, prenom
FROM commandes, clients
WHERE numclient = num;</code></pre>
                                <p>Autre exemple : je veux connaître les commandes de septembre 2000 (n°, article, quantité) faites par des clients de Wavre, et pour chacune d'elles, le nom, le prénom et le numéro de téléphone du client qui l'a effectuée.</p>
<pre class="taille60"><code>SELECT commandes.numcommande, commandes.article, commandes.quantite, client.nom, clients.prenom, clients.tel
FROM commandes, clients
WHERE commandes.numclient = clients.num AND commandes.annee = 2000 AND commandes.mois = 9 AND clients.ville = 'Wavre';</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>numcommande</th>
                                            <th>article</th>
                                            <th>quantite</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                            <th>tel</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>2</td>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                            <td>NULL</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                            <td>NULL</td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                            <td>010/34.65.67</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Parmi les conditions qui suivent le mot <span class="em">WHERE</span>, figure la "<span class="em">condition de jointure</span>", qui permet de faire le lien entre un tuple d'une table et un tuple de l'autre, c'est-à-dire, dans notre exemple, entre une commande et son client. Cette condition est celle d'égalité des numéros de client des deux tables : <span class="em">commandes.numclient = clients.num</span>.</p>
                                <p>Plutôt que de répéter les noms des tables, on peut avoir recours aux "<span class="em">alias</span>". Par exemple :</p>
<pre class="taille60"><code>SELECT CO.article, CO.quantite, CL.nom, CL.prenom
FROM commandes CO, clients CL
WHERE CO.numclient = CL.num;</code></pre>
                            </li>
                            <li>
                                <h4 id="produit_cartesien">Le produit cartésien :</h4>
                                <p>En <span class="em">l'absence de la condition de jointure</span>, le système croise chaque tuple de <span class="em">commandes</span> avec chaque tuple de <span class="em">clients</span>, sans tenir compte de cette correspondance.</p>
<pre class="taille60"><code>SELECT article, quantite, nom, prenom
FROM commandes, clients;</code></pre>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>article</th>
                                            <th>quantite</th>
                                            <th>nom</th>
                                            <th>prenom</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>20</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>20</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>20</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>80</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>cartouche</td>
                                            <td>160</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>classeurL</td>
                                            <td>10</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>30</td>
                                            <td>Dupuis</td>
                                            <td>Benoit</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>30</td>
                                            <td>Dupuis</td>
                                            <td>Luc</td>
                                        </tr>
                                        <tr>
                                            <td>stylo M3</td>
                                            <td>30</td>
                                            <td>Van Moer</td>
                                            <td>Willy</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Pour comprendre le résultat, il faut se souvenir des règles ensemblistes en mathématique.</p>
                                <p>Puisqu'il y a 3 clients et 5 commandes, le produit cartésien de ces deux ensembles fournit 15lignes en résultat.</p>
                                <p>Effectivement, il faut multiple le nombre de lignes des deux ensembles : 3 clients * 5 commandes = 15 lignes résultantes !</p>
                                <p>Chaque tuple d'une table est mis en lien avec les tuples de l'autre table.</p>
                                <p>Dans le cas présent, ce query n'a aucn intérêt.</p>
                                <p>Mais le produit cartésien peut s'avérer intéressant dans certains cas. Supposons qu'une des clientes se prénomme Cerise et qu'il existe un article intitulé Cerise dans l'assortiment.</p>
                                <p>Que répondez-vous aux deux questions suivantes :</p>
                                <ul>
                                    <li>Est-ce que Cerise a commandé des cerises ? (Combien ?)</li>
                                    <li>Est-ce qu'il existe un article qui porte le même prénom que celui d'un client ?</li>
                                </ul>
                                <p>La première question est une requête avec jointure.</p>
<pre class="taille60"><code>SELECT quantite
FROM commandes CO, clients CL
WHERE CO.numclient = CL.num AND CL.prenom = 'Cerise' AND CO.article = 'Cerise';</code></pre>
                                <p>Par contre, la réponse à la deuxième question fait intervenir un produit cartésien.</p>
<pre class="taille60"><code>SELECT DISTINCT prenom
FROM clients, commandes
WHERE prenom = article;</code></pre>
                            </li>
                            <li>
                                <h4 id="exemples_supplementaires">Exemples supplémentaires :</h4>
                                <ol>
                                    <li>
                                        <p>Je désire connaître le nombre de commandes réalisées pour des clients  de Wavre ainsi que le montant total de celles-ci avec une rédution de 5%.</p>
<pre class="taille60"><code>SELECT COUNT (CO.numcommande), SUM (CO.prixunitaire * CO.quantite) * 0.95
FROM commandes CO, clients CL
WHERE CO.numclient = CL.num AND CL.ville = 'Wavre';</code></pre>
                                        <p>Ça va afficher ceci :</p>
                                        <table class="tableBalises">
                                            <thead>
                                                <tr>
                                                    <th>count</th>
                                                    <th>?Column?</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>3</td>
                                                    <td>11780</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <p>Pour mettre un nom aux différentes colonnes, on utilise le mot <span class="html">AS</span>. Ça donnera un truc comme ceci :</p>
<pre class="taille60"><code>SELECT COUNT (CO.numcommande) <span class="em">AS</span> "nombre de commandes", SUM (CO.prixunitaire * CO.quantite) * 0.95 <span class="em">AS</span> "prix total"
FROM commandes CO, clients CL
WHERE CO.numclient = CL.num AND CL.ville = 'Wavre';</code></pre>
                                        <p>Avec le mot <span class="em">AS</span>, ça affichera ceci à la place :</p>
                                        <table class="tableBalises">
                                            <thead>
                                                <tr>
                                                    <th class="em">nombre de commandes</th>
                                                    <th class="em">prix total</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>3</td>
                                                    <td>11780</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </li>
                                    <li>
                                        <p>Je veux connaître le prénom des clients dont le nom est "Dupuis" qui ont commandé un article "classeurL".</p>
<pre class="taille60"><code>SELECT <span class="em">DISTINCT</span> CL.prenom
FROM commandes CO, clients CL
WHERE CO.numclient = CL.num AND CL.nom = 'Dupuis' AND CO.article = 'classeurL';</code></pre>
                                        <p>On met le mot <span class="em">DISTINCT</span> après le <span class="em">SELECT</span> en se posant la question, "<span class="em">Suis-je certain qu'il n'y aura qu'un seul résultat ?</span>" et que la réponse est <span class="em">NON</span>.</p>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="transitivite">La transitivité :</h4>
                                <p>Rappel mathématique : si <span class="em">A = B</span> et <span class="em">B = C</span>, alors <span class="em">A = C</span>.</p>
                                <p>Ce principe s'applique également au SQL. Prenons les tables suivates :</p>
                                <img src="../images/transitivite.PNG" alt="transitivité">
                                <p>Un client peut avoir plusieurs commandes et aussi plusieurs adresses de livraison. Les tables adresses_de_livraison et commandes ont la même clé étrangère <span class="em">numclient</span> qui fait référence à la table clients.</p>
                                <p>Essayons de répondre à la requête suivante : quelles sont les commandes qui ont été livrées à l'adresse de livraison dont le numéro (<span class="em">numadresselivraison</span>) est le 5 ?</p>
<pre class="taille60"><code>SELECT DISTINCT CO.numcommande
FROM commandes CO, <span class="em">clients CL</span>, adresses_de_livraison AL
WHERE CO.numclient = <span class="em">CL.num</span> AND AL.numclient = <span class="em">CL.num</span> AND AL.numadresselivraison = 5;</code></pre>
                                <p>La transitivité va nous permettre de simplifier cette requête en n'utilisant plus la table clients :</p>
<pre class="taille60"><code>SELECT DISTINCT CO.numcmmande
FROM commandes CO, adresses_de_livraison AL
WHERE CO.numclient = AL.numclient AND AL.numadresselivraison = 5;</code></pre>
                            </li>
                        </ol>
                        <h3 id="relation_M_a_N">La relation M à N :</h3>
                        <p>Repartons de l'exemple des clients et des commandes. Le lecteur aura peut-être surpris de la façon dont les articles ont été traités jusqu'ici.</p>
                        <ul>
                            <li>Les articles qui sont disponibles mais qui n'ont encore été commandés par personne ne figurent nulle part : comment le système connaîtra-t-il la liste ?</li>
                            <li>Les dénominations des articles pouvant être longues et changeantes, il est inutile de répéter ces informations pour chaque commande d'un article donné.</li>
                        </ul>
                        <p>Nous voici donc amenés à créer une nouvelle table : celle des articles susceptibles d'être commandés (le catalogue des articles).</p>
                        <p>Outre les allègements et autres améliorations déjà mis en évidence, nous pourrions profiter de cette table pour assurer une tenue de stock : il suffira, pour chaque article, de mémoriser sous forme d'attribut la quantité totale en stock. On peut même y ajouter un seuil de recommande, c'est-à-dire la valeur minimale du stock en dessous de laquelle il nous faut nous-mêmes nous réapprovisionner auprès de notre fournisseur. (Exemple : s'il nous reste moins de 100 stylos M3, il est temps que nous en recommandions.)</p>
                        <p>La table des commandes ne contiendra plus les informations relatives à l'article, mais un numéro qui fait référence à un tuple de la table des articles.</p>
                        <p>Voici les nouvelles instructions de création de tables (la table des clients reste identique) :</p>
<pre class="taille60"><code>CREATE TABLE articles
(
    numart INTEGER PRIMARY KEY,
    nomart VARCHAR(30),
    prixunitaire INTEGER,
    stock INTEGER,
    seuil INTEGER,
);

CREATE TABLE commandes
(
        numcommande INTEGER PRIMARY KEY,
        jour INTEGER,
        mois INTEGER,
        annee INTEGER,
        numclient INTEGER NOT NULL REFERENCES clients (num),
        numart INTEGER NOT NULL REFERENCES articles (numart),
        quantite INTEGER,
);</code></pre>
                        <img src="../images/M_N.PNG" alt="relation M à N">
                        <p>Il y a <span class="html">deux relations 1 à N</span> : entre <span class="em">clients</span> et <span class="em">commandes</span> d'une part, et entre <span class="em">articles</span> et <span class="em">commandes</span> d'autrepart. En effet :</p>
                        <ul>
                            <li>
                                <p>entre <span class="em">clients</span> et <span class="em">commandes</span> :</p>
                                <ul>
                                    <li>un client peut avoir fait zéro, une ou plusieurs commandes.</li>
                                    <li>une commande a été faite par un seul client.</li>
                                </ul>
                            </li>
                            <li>
                                <p>entre <span class="em">articles</span> et <span class="em">commandes</span> :</p>
                                <ul>
                                    <li>un article peut avoir fait l'objet de zéro, une ou plusieurs commandes.</li>
                                    <li>une commande mentionne un seul article.</li>
                                </ul>
                            </li>
                        </ul>
                        <p>Mais, entre <span class="em">clients</span> et <span class="em">articles</span>, il y a aussi une relation. On l'appelle une "<span class="html">relation M à N</span>" car :</p>
                        <ul>
                            <li>un client peut avoir commandé zéro, un ou plusieurs articles.</li>
                            <li>un article peut avoir été commandé par zéro, un ou plusieurs clients.</li>
                        </ul>
                        <p>Signalons qu'on utilise le mot "article" pour désigner plutôt un "type d'article", ou encore un "élément du catalogue des articles", MAIS pas une pièce précise, pas un "article physique individuel".</p>
                        <p>Les relations M à N ne sont jamais représentées directement dans un diagramme de structure de données, elles le sont toujours par deux relations 1 à N, dirigées vers une troisième entité intermédiaire (<span class="em">commandes</span> dans l'exemple).</p>
                        <p>Le contenu des tables <span class="em">commandes</span> et <span class="em">articles</span> pourraient être :</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>numcommande</th>
                                    <th>jour</th>
                                    <th>mois</th>
                                    <th>annee</th>
                                    <th>numclient</th>
                                    <th>numart</th>
                                    <th>quantite</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>5</td>
                                    <td>9</td>
                                    <td>2000</td>
                                    <td>1</td>
                                    <td>3</td>
                                    <td>20</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>6</td>
                                    <td>9</td>
                                    <td>2000</td>
                                    <td>18</td>
                                    <td>3</td>
                                    <td>80</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>6</td>
                                    <td>9</td>
                                    <td>2000</td>
                                    <td>18</td>
                                    <td>4</td>
                                    <td>160</td>
                                </tr>
                                <tr>
                                    <td>5</td>
                                    <td>8</td>
                                    <td>9</td>
                                    <td>2000</td>
                                    <td>3</td>
                                    <td>5</td>
                                    <td>10</td>
                                </tr>
                                <tr>
                                    <td>8</td>
                                    <td>1</td>
                                    <td>10</td>
                                    <td>2000</td>
                                    <td>1</td>
                                    <td>3</td>
                                    <td>30</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>numart</th>
                                    <th>nomart</th>
                                    <th>prixunitaire</th>
                                    <th>stock</th>
                                    <th>seuil</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1</td>
                                    <td>stylo M1</td>
                                    <td>100</td>
                                    <td>200</td>
                                    <td>100</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>stylo M2</td>
                                    <td>130</td>
                                    <td>125</td>
                                    <td>100</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>stylo M3</td>
                                    <td>150</td>
                                    <td>150</td>
                                    <td>100</td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>cartouche</td>
                                    <td>20</td>
                                    <td>950</td>
                                    <td>200</td>
                                </tr>
                                <tr>
                                    <td>5</td>
                                    <td>classeurL</td>
                                    <td>80</td>
                                    <td>23</td>
                                    <td>20</td>
                                </tr>
                                <tr>
                                    <td>6</td>
                                    <td>classeur XL</td>
                                    <td>150</td>
                                    <td>12</td>
                                    <td>20</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Voici quelques exemples de requêtes qui font appel aux trois tables.</p>
<pre class="taille60"><code>SELECT DISTINCT CL.nom, CL.prenom, CL.num, COM.quantite
FROM clients CL, commandes COM, articles AR
WHERE <span class="em">CL.num = COM.numclient</span>
<span class="em">AND COM.numart = AR.numart</span>
AND CL.ville = 'Wavre'
AND COM.annee = 2000
AND AR.nomart = 'stylo M3';</code></pre>
                        <p>Ce qui signifie que l'on veut connaître les clients de Wavre qui ont commandé en l'an 2000 des stylos M3, et en quelle quantité.</p>
                        <p>Les deux première conditions derrièrele mot <span class="em">conditions de jointures</span>, indispensables au bon fonctionnment de ce query. Le résultat affiché sera :</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>nom</th>
                                    <th>prenom</th>
                                    <th>num</th>
                                    <th>quantite</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Van Moer</td>
                                    <td>Willy</td>
                                    <td>18</td>
                                    <td>80</td>
                                </tr>
                            </tbody>
                        </table>
<pre class="taille60"><code>SELECT COUNT (*), SUM (quantite)
FROM clients CL, commandes COM, articles AR
WHERE CL.num = COM.numclient
AND COM.numart = ART.numart
AND CL.nom = 'Dupuis'
AND (AR.prixunitaire &gt; 50 OR COM.quantite &gt; 100);</code></pre>
                        <p>On veut connaître, pour tous les clients qui s'appellent 'Dupuis', le nombre de commandes et le nombre total d'unités commandées, si on se limite aux commandes "importantes" (c'est-à-dire portant sur des articles à plus de 50 cents, ou sur des quantités de plus de 100 unités).</p>
                        <p>Réflexion : les parenthèses de la dernière ligne de cette instruction sont-elles indispensables ? Que passerait-il si on les ôtait ?</p>
                        <h3 id="cle_primaire_concatenee">La clé primaire concaténée :</h3>
                        <p>Jusqu'ici, une commande consistait à ce qu'un client donné commande un article donné en une quantité donnée à une certaine date. Si le même client voulait commander simultanément des stylos et des cartouches, il devait effectuer deux commandes; et si pour chaque commande on édite une facture, il reçoit deux factures ! Cela peut devenir lourd et gênant.</p>
                        <p>Aussi décide-t-on souvent d'appeler "commande" une liste d'articles qu'un client désire obtenir en quantités précises. Chaque commande sera subdivisée en <span class="em">lignes de commande</span> (en référene aux formulaires de commande sur papier ou sur écran, dans lesquels chaque article commandé figure sur une nouvelle ligne).</p>
                        <img src="../images/cle_primaire_concatenee.PNG" alt="clé primaire concaténée">
                        <p>Les tables des commandes et lignes de commandes sont les suivantes (les tables des clients et des articles étant inchangées) :</p>
<pre class="taille60"><code>CREATE TABLE commandes
(
    numcommande INTEGER PRIMARY KEY,
    jour INTEGER,
    mois INTEGER,
    annee INTEGER,
    numclient INTEGER NOT NULL REFERENCES clients (num),
);

CREATE TABLE lignes
(
    numcommande INTEGER NOT NULL REFERENCES commandes (numcommande),
    numligne INTEGER,
    numart INTEGER NOT NULL REFERENCES articles (numart),
    quantite INTEGER,
    prix INTEGER,
    <span class="html">PRIMARY KEY (numcommande, numligne)</span>,
);</code></pre>
                        <p>On constate une nouveauté : la <span class="em">clé primaire</span> des lignes de commande est constituée de la <span class="em">concaténation</span> de deux attributs, car c'est <span class="em">leur combinaison qui est unique</span>.</p>
                        <p>Par exemple : il ne peut pas y avoir deux fois la ligne n°2 à la commande n°324; par contre, les commandes 327 et 328 peuvent avoir toutes deux une ligne n°2.</p>
                        <p>Le diagramme de structure de données est le suivant :</p>
                        <img src="../images/cle_primaire_concatenee_dsd.PNG" alt="DSD de la clé primaire concaténée">
                        <p>Exemples :</p>
                        <p>Si on n'a pas besoin des 4 tables dans certaines requêtes, on n'utilisera que celles qui sont nécessaires.</p>
                        <ol>
                            <li>
                                <p>Quelles sont les lignes de commandes dont la quantité aatteint ou dépasse les 500 unités, et, pour chacune d'elles, donnez le nom du client, le libellé de l'article et la quantité commandée.</p>
<pre class="taille60"><code>SELECT CL.nom, AR.nomart, LI.quantite
FROM clients CL, commandes COM, lignes LI, articles AR
WHERE CL.num = COM.numclient
AND COM.numcommande = LI.numcommande
AND LI.numart = AR.numart
AND LI.quantite &gt;= 500;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les articles qui nous ont été commandés en août ou septembre 2000 et dont le stock actuel est situé en-dessous du seuil de recommande ?</p>
<pre class="taille60"><code>SELECT AR.numart, ART.nomart, AR.stock
FROM commandes COM, lignes LI, articles AR
WHERE COM.numcommande = LI.numcommande
AND LI.numart = AR.numart
AND COM.annee = 2000
AND (COM.mois = 8 OR COM.mois = 9)
AND AR.stock &lt; AR.seuil;</code></pre>
                                <p>Attention, si un article donné a été commandé plusieurs fois ces deux mois, on constatera que la ligne de résultat correspondant à cet article apparaîtra plusieurs fois dans le résultat. Le moyen d'éviter cela est bien sûr d'ajouter le mot-clé <span class="em">DISTINCT</span> après le mot <span class="em">SELECT</span>. L'instruction devient :</p>
<pre class="taille60"><code>SELECT DISTINCT AR.numart, ART.nomart, AR.stock
FROM commandes COM, lignes LI, articles AR
WHERE COM.numcommande = LI.numcommande
AND LI.numart = AR.numart
AND COM.annee = 2000
AND (COM.mois = 8 OR COM.mois = 9)
AND AR.stock &lt; AR.seuil;</code></pre>
                                <p>Remarquons que ce mot <span class="em">DISTINCT</span> porte sur l'ensmeble de la ligne (et pas sur l'arttribut <span class="em">numart</span> qui le suit immédiatement). Cela n'aurait pas de sens de répéter ce mot ailleurs.</p>
                            </li>
                            <li>
                               <p>Quelles sont les villes des clients qui ont commandé des cartouches en septembre 2000 ?</p>
<pre class="taille60"><code>SELECT DISTINCT CL.ville
FROM clients CL, commandes COM, lignes LI, articles AR
WHERE CL.num = COM.numclient
AND COM.numcommande = LI.numcommande
AND LI.numart = AR.numart
AND AR.nomart = 'cartouche'
AND COM.annee = 2000
AND COM.mois = 9;</code></pre>
                            </li>
                        </ol>
                        <p>Autre possibilité, on choisit comme clé primaire de la table <span class="em">ligne</span> la <span class="em">concaténation</span> des deux <span class="em">clés étrangères</span> : <span class="em">numcommande</span> et <span class="em">numart</span>. Le choix d'une telle clé a pour conséquence qu'au sein d'une commande, il ne peut y avoir qu'une seule ligne par article. En d'autres termes, un article ne peut se trouver que dans une seule ligne de commande. Évidemment, ceci est plus contraignant.</p>
                        <p>Le <span class="html">CREATE TABLE</span> ne diffère pas beaucoup de celui déjà présenté :</p>
<pre class="taille60"><code>CREATE TABLE lignes
(
    numcommande INTEGER NOT NULL REFERENCES commandes (numcommande),
    numart INTEGER NOT NULL REFERENCES articles (numart),
    quantite INTEGER,
    prix INTEGER,
    <span class="html">PRIMARY KEY (numcommande, numart)</span>,
);</code></pre>
                        <img src="../images/cle_primaire_concatenee_dsd_2.PNG" alt="DSD de clé concaténée n°2">
                        <h3 id="cle_etrangere_concatenee">La clé étrangère concaténée :</h3>
                        <p>Lorsqu'on fait une jointure avec une clé étrangère concaténée, il faut penser à faire la jointure sur <span class="em">tous</span> les champs qui composent cette clé étrangère.</p>
                        <p>Prenons pour exemple le DSD (limité) suivant :</p>
                        <img src="../images/cle_etrangere_concatenee_dsd_1.PNG" alt="DSD de clé étrangère concaténée n°1">
                        <p>Imaginons des clubs de foot. Dans chaque club de foot, il y a plusieurs équipes, et dans chaque équipe il y a un certian nombre de membres.</p>
                        <p>La FK de la table membres est une FK composite, faisant référence à la PK composite de la table equipes : <span class="em">id_club, num_equipe</span>.</p>
                        <p>Pour afficher tous les membres de l'équipe numéro 5, il faudra écrire la requête suivante :</p>
<pre class="taille60"><code>SELECT m.num_membre, m.nom, m.prenom
FROM membres m, equipes e
WHERE <span class="em">m.id_club = e.id_club</span>
<span class="em">AND m.num_equipe = e.num_equipe</span>
AND e.num_equipe = 5;</code></pre>
                        <h3 id="sous-requete">Sous-requête :</h3>
                        <p>Une sous-requête <span class="em">SELECT</span> à l'intérieur d'une autre. Une sous-requête doit être placée à la suite d'une clause <span class="em">WHERE</span> ou d'une clause <span class="em">HAVING</span> (voir ci-dessous).</p>
                        <p>Le résultat de la sous-requête remplace une valeur ou un groupe de valeurs dans une condition.</p>
<pre class="taille60"><code>SELECT *
    FROM table1
    WHERE table1.id | IN <span class="html">(SELECT table2.id FROM table2)</span>;
    | NOT IN
    | =
    | NOT =
    | Autres opérateurs &lt;, &gt; ...</code></pre>
                        <p><span class="em">SELECT table2.id FROM table2</span> est la sous-requête. Une sous-requête s'exprime toujours entre parenthèses.</p>
                        <p>Exemples :</p>
                        <p>Quelles sont toutes les commandes de Mr Jean Dupont ?</p>
<pre class="taille60"><code>SELECT numcommande
FROM commandes, clients
WHERE numclient = num
AND nom = 'Dupont'
AND prenom = 'Jean';</code></pre>
                        <p>Ou</p>
<pre class="taille60"><code>SELECT numcommande
FROM commandées
WHERE numclient (SELECT num
FROM clients
WHERE nom = 'Dupont' AND prenom = 'Jean');</code></pre>
                        <p>Dans ce premier exemple, nous avons vu deux manières différentes d'écrire une requête. Dans un tel cas, l'emploi de la sous-requête n'est pas indispensable.</p>
                        <p>Dans l'exemple suivant, nous abordons un cas où l'emploi de la sous-requête est indispensable.</p>
                        <p>Quels sont les articles les plus chers, c'est-à-dire ceux dont le prix est égal au prix le plus élevé ?</p>
<pre class="taille60"><code>SELECT numart, nomart
FROM articles
WHERE prixunitaire = (SELECT MAX (prixunitaire) FROM articles);</code></pre>
                        <h3 id="clauses_supplementaires">Les clauses supplémentaires :</h3>
                        <ol type="a">
                            <li>
                                <h4 id="group_by">GROUP BY :</h4>
                                <p>L'objectif est d'efftuer des opérations de somme, comptage, moyenne, minimum ou maximum sur plusieurs groupes de tuples et non sur l'ensemble des tuples comme nous l'avons vu auparavant. C'est ce que l'on appelle une <span class="em">rupture de séquence</span>.</p>
                                <p>Par exemple, si on désire compter le nombre de lignes de commande :</p>
<pre class="taille60"><code>SELECT numcommande, COUNT (*)
FROM lignes
GROUP BY numcommande;</code></pre>
                                <p>On obtiendra autant de tuples dans le résultat qu'il y a de numéros de commandes différents.</p>
                                <p>Même exemple, mais en affichant la date de la commande.</p>
<pre class="taille60"><code>SELECT lignes.numcommande, annee, mois, jour, COUNT (*)
FROM lignes, commandes
WHERE lignes.numcommande = commandes.numcommande
GROUP BY lignes.numcommande, annee, mois, jour;</code></pre>
                                <p>Le groupement, comme dans le cas précédent, se fera par commande. On groupe ensemble tous les tuples qui ont la même valeur pour les attributs figurant derrière les <span class="html">GROUP BY</span>.</p>
                                <p>Dans le second exemple, l'ajout des attributs annee, mois et jour en fin d'instruction ne change rien au groupement, puisque si le numéro de commande est le même, la date sera forcément la même aussi, mais leur présence est exigée par SQL : en effet, tout attribut digurant hors d'une fonction d'agrégation après le mot <span class="em">SELECT</span> doit aussi figurer derrière les mots <span class="em">GROUP BY</span>.</p>
                                <p>La clause <span class="html">GROUP BY</span> n'a d'intérêt que si l'on utilise <span class="em">au moins une fonction d'agrégation</span>.</p>
                                <p>Autre exemple, on désire afficher le chiffre d'affaires (total de toutes les commandes) de chaque mois de l'année 2001 :</p>
<pre class="taille 60"><code>SELECT mois, SUM(prix * quantite)
FROM commandes, lignes
WHERE annee = 2001 AND commandes.numcommande = lignes.numcommande
GROUP BY mois</code></pre>
                                <p>Même chose, mais pour chaque mois de toutes les années :</p>
<pre class="taille 60"><code>SELECT annee, mois, SUM(prix * quantite)
FROM commandes, lignes
WHERE commandes.numcommande = lignes.numcommande
GROUP BY annee, mois</code></pre>
                                <p>Quel est le montant total payé par chaque client ?</p>
<pre class="taille60"><code>SELECT numclient, SUM (prix * quantite)
FROM commandes, lignes
WHERE commandes.numcommande = lignes.numcommande
GROUP BY numclient;</code></pre>
                                <p>Même chose, mais en indiquant le nom du client :</p>
<pre class="taille60"><code>SELECT CL.num, CL.nom, AVG (prix * quantite)
FROM commandes COM, clients CL, lignes
WHERE COM.numclient = CL.num
AND COM.numcommande = lignes.numcommande
GROUP BY CL.num, CL.nom;</code></pre>
                                <p>On peut aussi écrire, derrière le mot <span class="em">SELECT</span>, des expressions contenant une ou plusieurs fonctions d'agrégation mais il va de soi que celles-ci ne figureront pas dans le <span class="em">GROUP BY</span>.</p>
                            </li>
                            <li>
                                <h4 id="having">HAVING :</h4>
                                <p><span class="html">HAVING</span> permet d'élimiter certains tuples ou groupes de tuples du résultat.</p>
                                <p>La clause <span class="em">HAVING</span> existe en SQL parce qu'il est impossble d'utiliser des fonctions agrégées dans le <span class="em">WHERE</span>. Si une table a été groupée en utilisant la clause <span class="em">GROUP BY</span> mais que seuls certains groupes sont intéressants, la clause <span class="em">HAVING</span> peut être utilisée, comme une clause <span class="em">WHERE</span>, pour éliminer les groupes du résultat.</p>
                                <p>Les expressions de la clause <span class="em">HAVING</span> peuvent référer à la fois aux expressions groupées et aux expressions non groupées.</p>
                                <p>Exemple :</p>
<pre class="taille60"><code>SELECT CL.num, CL.nom, SUM (prix * quantite)
FROM commandes COM, clients CL
WHERE COM.numclient = CL.num
GROUP BY  CL.num, CL.nom
HAVING SUM (prix * quantite) &gt; 10000;</code></pre>
                            </li>
                        </ol>
                        <h3 id="conclusion_partie_1">Conclusion de la partie 1 :</h3>
                        <p>Nous avons maintenant découvert les premières instructions du langage SQL : <span class="em">CREATE TABLE</span>, <span class="em">INSERT INTO</span> et <span class="em">SELECT</span>; dans la partie suivante du cours, nous allons nous pencher sur la manière de concevoir des bases de données. Nous nous attarderons donc à la réalisation des diagrammes de structures de données (DSD).</p>
                        <h3 id="exercices">Exercices :</h3>
                        <h4 id="introduction_exercices">Introduction :</h4>
                        <p>Dans la suite, on présente les exercices SQL cours de BD1. Il vous sera proposé d'effectuer des requêtes (queries) sur une base de données contenant des bandes dessinées.</p>
                        <p>Les séances d'exercices ont pour but de vous apprendre à créer une base de données, à y insérer des informations et ensuite à consulter de façon souple et puissante les informations ainsi stockées.</p>
                        <p>Les exercices se découpent en 4 niveaux progressifs :</p>
                        <ul>
                            <li>Niveau 1 - Les requêtes portent sur une seule table.</li>
                            <li>Niveau 2 - Les requêtes portent sur deux tables.</li>
                            <li>Niveau 3 - Les requêtes portent sur une base de données de quatre tables.</li>
                            <li>Niveau 4 - Les requêtes reposent sur une base de données de quatre tables MAIS les requêtes s'effectuent sur 1, 2, 3 ou 4 tables.</li>
                        </ul>
                        <p>Dans chaque niveau, les queries demandées sont également classés par ordre de difficulté croissante.</p>
                        <p>Le Système de Gestion de Bases de Données (SGBD) utilisé est PostgreSQL (<a href="http://www.postgresql.org/" target="_blank">http://www.postgresql.org/</a>) qui est une base de données open source.</p>
                        <p>Le logiciel permettant d'exécuter les requêtes SQL avec PostgreSQL s'appelle pgAdmin (<a href="http://www.pgadmin.org/" target="_blank">http://www.pgadmin.org/</a>).</p>
                        <p>Il s'agit d'un logiciel qui permet d'exécuter des commandes SQL à travers une interface graphique (Windows) et donc relativement confortable.</p>
                        <p>Afin de réaliser ces exercices, vous disposez de 2 possibilités :</p>
                        <ol>
                            <li>Utiliser pgAdmin et créer vos propres tables dans <span class="em">votre système</span> en utilisant les fichiers SQL disponibles sur Moodle.</li>
                            <li>Utiliser un <span class="em">autre SGBD</span> avec les fichiers SQL à disposition. Attention, ces fichiers sont écrits pour PostgreSQL, il se peut qu'il faille opérer quelques modifications selon le SGBD que vous employez.</li>
                        </ol>
                        <h4 id="niveau_1">Niveau 1 : Base de données à une seule table :</h4>
                        <p>Imaginez une table SQL reprenant une liste de bandes dessinées ! <span class="em">Vous pouvez voir le contenu de cette table dans l'image suivante.</span> Le contenu de la yanle vous permettra de déterminer le type de chaque attribut.</p>
                        <p>Votre table doit au moins contenir les attributs suivants :</p>
                        <ul>
                            <li>ISBN</li>
                            <li>titre</li>
                            <li>série/héros principal</li>
                            <li>scénariste</li>
                            <li>dessinateur</li>
                            <li>coloriste</li>
                            <li>pays</li>
                            <li>prix</li>
                            <li>éditeur</li>
                            <li>année d'édition</li>
                        </ul>
                        <p>L'ISBN (International Standard Book Number) ou numéro international normalisé du livre est un numéro international qui permet d'identifier, de manière unique, chaque livre publié. Il est destiné à simplifier la gestion informatique du livre : bibliothèques, libraires, distributeurs, etc. (Extrait de Wikipédia)</p>
                        <p>Lorsque, dans une requête, on demande les albums sans précision des champs désirés; cela signifie qu'on désire obtenir toutes les colonnes de la table.</p>
                        <p>Un auteur est soit un scénariste, soit un dessinateur, soit un coloriste.</p>
                        <p>Le DSD est :</p>
                        <table class="tableBalises">
                            <thead>
                                <tr>
                                    <th>bd1.albums</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="bold">
                                    <td>PK</td>
                                    <td class="souligne">isbn</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>
                                        <p>titre NN</p>
                                        <p>serie</p>
                                        <p>scenariste</p>
                                        <p>dessinateur</p>
                                        <p>coloriste</p>
                                        <p>pays</p>
                                        <p>prix NN</p>
                                        <p>editeur NN</p>
                                        <p>annee_edition</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <ol type="a">
                            <li>
                                <p>Écrivez l'instruction <span class="html">CREATE TABLE</span> en vue de la créer sur machine.</p>
<pre class="taille60"><code>CREATE TABLE bd1.albums
(
    isbn char (13) PRIMARY KEY,
    titre character varying (50) NOT NULL,
    serie character varying (20),
    scenariste character varying (20),
    dessinateur character varying (20),
    coloriste character varying (20),
    editeur character varying (20) NOT NULL,
    pays character (1),
    annee_edition integer,
    prix double precision NOT NULL,
);</code></pre>
                            </li>
                            <li>
                                <p>Qu'est-ce que la PK ?</p>
<pre class="taille60"><code>La PK est la clé primaire. Elle est toujours <span class="em">NOT NULL</span> et unique.</code></pre>
                            </li>
                            <li>
                                <p>Remplissez votre table de deux ou tuples (reprenant des bandes dessinées réelles ou imaginaires). Donnez les instructions <span class="html">INSERT INTO</span>.</p>
                                <p class="souligne">Le contenu de la table bd1.albums :</p>
                                <img src="../images/bd1.albums.PNG" alt="bd1.albums">
<pre class="taille60"><code>INSERT INTO bd1.albums (isbn, titre, serie, scenariste, dessinateur, coloriste, éditeur, pays, annee_edition, prix)
VALUES ('2870970559', 'Joyeux Noël, May', NULL, 'Cosey', 'Cosey', 'Cosey', 'Dupuis', 'b', 1998, 7);

INSERT INTO bd1.albums (isbn, titre, serie, scenariste, dessinateur, coloriste, éditeur, pays, annee_edition, prix)
VALUES ('2205030434', 'La fiancée de Lucky Luke', 'Luky Luke', 'Guy Vidal', 'Morris', NULL, Dargaud, 'f', 1985, 5);</code></pre>
                            </li>
                        </ol>
                        <ol>
                            <li>
                                <p>Éccrivez une requête SQL qui permette d'afficher tout le contenu de votre table.</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Donnez, pour chaque album, son isbn, son titre, son scénariste, son dessinateur ainsi que son année d'édition.</p>
<pre class="taille60"><code>SELECT isbn, titre, scenariste, dessinateur, annee_edition
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums édités par "Dupuis" ?</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE editeur = 'editeur';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les titres des albums dont le scénariste est "Goscinny" ?</p>
<pre class="taille60"><code>SELECT DISTINCT titre
FROM bd1.albums
WHERE scenariste = 'Goscinny';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les titres et les éditeurs des albums dont un des auteurs s'appelle "Uderzo" ?</p>
<pre class="taille60"><code>SELECT DISTINCT titre, editeur
FROM bd1.albums
WHERE scenariste = 'Uderzo' OR dessinateur = 'Uderzo' OR coloriste = 'Uderzo';</code></pre>
                            </li>
                            <li>
                              <p>Quels sont les albums pour lesquels le coloriste n'a pas été spécifié ?</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE coloriste IS NULL;</code></pre>  
                            </li>
                            <li>
                                <p>Quels sont les éditeurs qui ont édité des albums en 1978 ?</p>
<pre class="taille60"><code>SELECT DISTINCT editeur
FROM bd1.albums
WHERE annee_edition = 1978;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les couples scénaristes-dessinateurs ayant travaillé pour l'éditeur "Dargaud" ? (Attention: si le nom du dessinateur est le mêm que celui du scénariste, c'est que la même personne a effectué les deux tâches, et on ne parlera donc pas de "couple".)</p>
<pre class="taille60"><code>SELECT DISTINCT scenariste, dessinateur
FROM bd1.albums
WHERE scenariste != dessinateur AND editeur = 'Dargaud';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums dont le scénariste et le dessinateur sont la même personne, mais ont été mis en couleurs par quelqu'un d'autre ?</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE scenariste = dessinateur AND scenariste != coloriste;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums dont le scénariste, le dessinateur et le coloriste sont la même personne ?</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE scenariste = dessinateur AND scenariste = coloriste;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums qui n'ont qu'un seul auteur ? (Cela recouvre les cas de l'exercice précédent, mais il ne faut pas oublier les tuples pour lesquels un ou deux des trois attributs concernés ont la valeur <span class="em">NULL</span> !)</p>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE (scenariste IS NOT NULL AND dessinateur IS NULL AND coloriste IS NULL) OR (scenariste IS NULL AND dessinateur IS NOT NULL AND coloriste IS NULL) OR (scenariste IS NULL AND dessinateur ISNULL AND coloriste IS NOT NULL) OR (scenariste = dessinateur AND scenariste = coloriste) OR (scenariste = desinateur AND coloriste IS NULL) OR (scenariste = coloriste AND dessinateur IS NULL) OR (dessinateur = coloriste AND scenariste IS NULL);</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les scénariste dont on a édité, après 1990, des oeuvres qui coûtent moins de 8€ ?</p>
<pre class="taille60"><code>SELECT DISTINCT scenariste
FROM bd1.albums
WHERE annee_edition &gt; 1990 AND prix &lt; 8;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les titres édités en dehors de la décennie 1990-1999, par un éditeur autre que "Casterman", et donc le coloriste est ou bien non spécifié ou bien le même que le dessinateur ?</p>
<pre class="taille60"><code>SELECT DISTINCT titre
FROM bd1.albums
WHERE (annee_edition &lt; 1990 OR annee_edition &gt; 1999) AND editeur != 'Casterman' AND (coloriste IS NULL OR coloriste = dessinateur);</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les titres qui n'ont été édités ni par "Casterman", ni par "Dupuis", et qui ont, comme scénariste, dessinateur et coloriste, trois auteurs distincts ?</p>
<pre class="taille60"><code>SELECT DISTINCT titre
FROM bd1.albums
WHERE editeur != 'Casterman' AND editeur != 'Dupuis' AND scenariste != dessinateur AND scenariste != coloriste AND dessinateur != coloriste;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont tous les albums qui rentrent dans une des catégories suivantes au moins :</p>
                                <ul>
                                    <li>albums de la série "Astérix" édité chez "Dargaud".</li>
                                    <li>albums de la série "Tintin" édités chez "Casterman" ou chez "Le Lombard".</li>
                                    <li>albums sans aucun auteur spécifié.</li>
                                </ul>
<pre class="taille60"><code>SELECT *
FROM bd1.albums
WHERE (serie = 'Astérix' AND editeur = 'Dargaud') OR (serie = 'Tintin' AND (editeur = 'Casterman' OR editeur = 'Le Lombard')) OR (dessinateur IS NULL AND scenariste IS NULL AND coloriste IS NULL);</code></pre>
                            </li>
                            <li>
                                <p>Lister les titres des albums qui contiennent le mot "César".</p>
<pre class="taille60"><code>SELECT DISTINCT titre
FROM bd1.albums
WHERE titre LIKE '%César%';</code></pre>
                            </li>
                            <li>
                                <p>Lister les coloristes dont le nom commence par le mot "de" (peu importe la casse).</p>
<pre class="taille60"><code>SELECT DISTINCT coloriste
FROM bd1.albums
WHERE upper (coloriste) LIKE 'DE%';</code></pre>
                                <h5 id="exercies_clause_order_by">Exercices sur la clause ORDER BY :</h5>
                            </li>
                            <li>
                                <p>Donnez tous les titres de la série "Astérix" et leur année d'édition, en ordre chronologique (cd. année d'édition).</p>
<pre class="taille60"><code>SELECT DISTINCT titre, annee_edition
FROM bd1.albums
WHERE serie = 'Astérix'
ORDER BY annee_edition;</code></pre>
                            </li>
                            <li>
                                <p>Donnez tous les titres des albums de la série "Astérix, en ordre alphabétique des titres.</p>
<pre class="taille60"><code>SELECT DISTINCT titre
FROM bd1.albums
WHERE serie = 'Astérix'
ORDER BY titre;</code></pre>
                            </li>
                            <li>
                                <p>Donnez les albums (isbn, titre, nom d'éditeur et année d'édition) en classant ces données par éditeur, et pour chaque éditeur, par année d'édition.</p>
<pre class="taille60"><code>SELECT isbn, titre, editeur, annee_edition
FROM bd1.albums
ORDER BY editeur, annee_edition;</code></pre>
                            </li>
                            <li>
                                <p>Donnez les titres et les prix des albums édités par "Dupuis", par ordre décroissant de prix.</p>
<pre class="taille60"><code>SELECT DISTINCT titre, prix
FROM bd1.albums
WHERE editeur = 'Dupuis'
ORDER BY prix DESC;</code></pre>
                                <h5 id="exercices_fonctions_agregees">Exercices sur les fonctions agrégées :</h5>
                            </li>
                            <li>
                                <p>Quelle est la plus ancienne année d'édition de la table <span class="em">bd1.albums</span> ?</p>
<pre class="taille60"><code>SELECT MIN (annee_edition)
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Quel est le prix de l'album le plus cher parmi ceux qui ont été dessinés par un autre dessinateur qu'"Uderzo" ?</p>
<pre class="taille60"><code>SELECT MAX (prix)
FROM bd1.albums
WHERE dessinateur != 'Uderzo';</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums édités chez "Casterman" ?</p>
<pre class="taille60"><code>SELECT COUNT (*)
FROM bd1.albums
WHERE editeur = 'Casterman';</code></pre>
                            </li>
                            <li>
                                <p>Combien d'années séparent l'album le plus ancien de l'album le plus récent ?</p>
<pre class="taille60"><code>SELECT MAX (annee_edition) - MIN (annee_edition)
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Combien devrais-je payer si j'achète 3 exemplaires de chacun des albums édités par "Blake et Mortimer" et si le libraire m'accorde une réduction de 25% ?</p>
<pre class="taille60"><code>SELECT SUM (3 * prix) * 0.75
FROM bd1.albums
WHERE editeur = 'Blake et Mortimer';</code></pre>
                            </li>
                            <li>
                                <p>Les albums de la série "Tintin" ont-ils tous le même prix ? (le query pourrait par exemple renvoyer la valeur 1 si la réponse est oui)</p>
<pre class="taille60"><code>SELECT COUNT (DISTINCT prix)
FROM bd1.albums
WHERE serie = 'Tintin';</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il de séries différentes dans la table <span class="em">bd1.albums</span> ?</p>
<pre class="taille60"><code>SELECT COUNT (DISTINCT serie)
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums pour lesquels la série n'est pas spécifiée ? Peut-on répondre à cette question par un query sans clause <span class="em">WHERE</span> ?</p>
<pre class="taille60"><code>SELECT COUNT (serie)
FROM bd1.albums;</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums dont un des aureurs au moins s'appelle "Uderzo", et quelles sont les dates d'édition du plus ancien et du plus récent d'entre eux ?</p>
<pre class="taille60"><code>SELECT COUNT (*), MIN (annee_edition), MAX (annee_edition)
FROM bd1.albums
WHERE dessinateur = 'Uderzo' OR scenariste = 'Uderzo' OR coloriste = 'Uderzo';</code></pre>
                            </li>
                            <li>
                                <p>Quel est le prix moten des albums édités par "Dupuis" entre 1990 et 1999 (y compris ces deux années extrêmes) ?</p>
<pre class="taille60"><code>SELECT AVG (prix)
FROM bd1.albums
WHERE editeur = 'Dupuis' AND annee_edition &gt;= 1990 AND annee_edition &lt;= 1999;</code></pre>
                            </li>
                            <li>
                                <p>Si je veux acheter un exemplaire de tous les albums dont le scénariste est"Goscinny" et/ou le dessinateur " est "Uderzo", combien dois-je débourser ?</p>
<pre class="taille60"><code>SELECT SUM (prix)
FROM bd1.albums
WHERE scenariste = 'Goscinny' OR dessinateur = 'Uderzo';</code></pre>
                            </li>
                            <li>
                                <p>Si veux acheter un exemplaire de tous les albums dont le scénariste n'est ni "Goscinny" ni "Uderzo", combien dois-je débourser ?</p>
<pre class="taille60"><code>SELECT SUM (prix)
FROM bd1.albums
WHERE scenariste != 'Goscinny' AND scenariste != 'Uderzo';</code></pre>
                            </li>
                        </ol>
                        <h4 id="niveau_2">Niveau 2 : Base de données à deux tables :</h4>
                        <p>Les queries suivantes seront effectuées à partir d'une base de deux tables : une table des <span class="em">bd2.editeurs</span> et une table des albums édités par chacun d'eux <span class="em">bd2.albums</span>.</p>
                        <p>La structure des données est présentée ci-dessous :</p>
                        <img src="../images/niveau2.PNG" alt="DSD du niveau 2">
                        <p>Dans la table <span class="em">bd2.editeurs</span>, chaque éditeur est identifié par un numéro (<span class="em">num</span>) et contient un nom (qui ne peut pas être <span class="em">NULL</span>), une adresse et un pays.</p>
                        <p>Dans table <span class="em">bd2.albums</span>, le nom de l'éditeur est remplacé par ce numéro. Ce numéro fait ainsi référence à l'éditeur de l'album. Il est le lien entre un album et son éditeur.</p>
                        <ol type="a">
                            <li>
                                <p>Écrivez les deux instructions <span class="html">CREATE TABLE</span>.</p>
<pre class="taille60"><code>CREATE TABLE bd2.editeurs
(
    num INTEGER PRIMARY KEY,
    nom CHARACTER VARYING (20) NOT NULL,
    adresse CHARACTER VARYING (30),
    pays CHARACTER VARYING (1),
);

CREATE TABLE bd2.albums
(
    isbn CHAR (13) PRIMARY KEY,
    titre VARCHAR (50) NOT NULL,
    serie CHARACTER VARYING (20),
    scenariste CHARACTER VARYING (20),
    dessinateur CHARACTER VARYING (20),
    coloriste CHARACTER VARYING (20),
    prix DOUBLE PRECISION NOT NULL,
    nom_editeur INTEGER NOT NULL REFERENCES bd2.editeurs (num),
    annee_edition INTEGER,
);</code></pre>
                            </li>
                            <li>
                                <p>Qu'est-ce que la FK ?</p>
<pre class="taille60"><code>La FK (FOREIGN KEY) est la clé étrangère permet de faire le lien entre deux tables. En logique, elle référencie la PRIMARY KEY de l'autre table.</code></pre>
                            </li>
                            <li>
                                <p>Remplissez vos tables de deux ou trois tuples (reprenant des bandes dessinées réelles ou imaginaires).</p>
                                <p>Donnez les instructions <span class="em">INSERT INTO</span>.</p>
<pre class="taille60"><code>INSERT INTO bd2.editeurs (num, nom, adresse, pays)
VALUES (1, 'Albert René', NLL, 'f');

INSERT INTO bd2.editeurs (num, nom, adresse, pays)
VALUES (2, 'Dargaud', NULL, 'f');

INSERT INTO bd2.albums (isbn, titre, serie, scenariste, dessinateur, coloriste, num_editeur, annee_edition, prix)
VALUES ('2-8709-055-9', 'Joyeux Noël, May', NULL, 'Cosey', 'Cosey', 'Cosey', 4, 1998, 7);

INSERT INTO bd2.albums (isbn, titre, serie, scenariste, dessinateur, coloriste, num_editeur, annee_edition, prix)
VALUES ('2-205-83043-4', 'La fiancée de Lucky Luke', 'Lucky Luke', 'Guy Vidal', 'Morris', NULL, 2, 1985, 5);</code></pre>
                            </li>
                        </ol>
                        <ol>
                           <li>
                            <p>Donnez la liste des albums avec, pour chacun d'eux, l'isbn, le titre, le scénariste, le dessinateur et le numéro de l'éditeur.</p>
<pre class="taille60"><code>SELECT BA.isbn, BA.titre, BA.scenariste, BA.dessinateur, BA.num_editeur
FROM bd2.albums BA;</code></pre>
                           </li>
                           <li>
                                <p>Donnez la liste des albums, avec, pour chacun d'eux, l'isbn, le titre, le scénariste, le dessinateur et le nom de l'éditeur.</p>
<pre class="taille60"><code>SELECT BA.isbn, BA.titre, BE.nom
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num;</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste des albums dont l'éditeur est belge (isbn, titre et nom de l'éditeur).</p>
<pre class="taille60"><code>SELECT BA.isbn, BA.titre, BE.nom
FROM bd2.albums BA, bd2.editeurs
WHERE BA.num_editeur = BE.num AND BE.pays = 'b';</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste des albums dont l'éditeur est belge sans la condition de jointure. (isbn, titre et nom de l'éditeur) Que constatez-vous ?</p>
<pre class="taille60"><code>SELECT BA.isbn, BA.titre, BE.nom
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.pays = 'b';

On remarque que toute la table est affichée comme aucune jointure, on a un produit cartésien avec les éditeurs belges : 44 albums * 5 éditeurs belges = 220 résultats.</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums de la série "Astérix" qui n'ont pas été édités chez "Dargaud" ?</p>
<pre class="taille60"><code>SELECT BA.*
FROM bd2_albums BA, bd2_editeurs BE
WHERE BA.num_editeur = BE.num AND BA.serie = 'Astérix' AND BE.nom != 'Dargaud';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont tous les éditeurs (num et nom) qui ont été édité en 1999 des livres coûtant au moins 10€ ?</p>
<pre class="taille60"><code>SELECT BE.num, BE.nom
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BA.annee_edition = 1999 AND BA.prix &gt;= 10;</code></pre>
                            </li>
                            <li>
                                <p>Chez quel(s) éditeur(s) (num et nom) "Goscinny" a-t-il des albums (en tant que scénariste, dessinateur ou coloriste) ?</p>
<pre class="taille60"><code>SELECT DISTINCT BE.num, BE.nom
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND (BA.scenariste = 'Goscinny' OR BA.dessinateur = 'Goscinny' OR BA.coloriste = 'Goscinny');</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les éditeurs (num et nom) localisés ailleurs qu'en Belgique ?</p>
<pre class="taille60"><code>SELECT BE.num, BE.nom
FROM bd2.editeurs BE
WHERE BE.pays != 'b';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums qui ont été édités en Belgique ou en France, et qui ne sont ni des albums de la série "Tintin", ni des albums de la série "Astérix" ?</p>
<pre class="taille60"><code>SELECT DISTINCT BA.*
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND (BE.pays = 'b' OR BE.pays = 'f') AND BA.serie != 'Tintin' AND BA.serie != 'Astérix';</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste des dessinateurs qui ont édités par "Dupuis". (Donnez-les en ordre alphabétique).</p>
<pre class="taille60"><code>SELECT DISTINCT BA.dessinateur
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.nom = 'Dupuis'
ORDER BY BA.dessinateur;</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste des albums édités par "Dupuis" entre 1990 et 2000 (bornes inclues), en affichant pour chacun son isbn, son titre, son dessinateur et son année d'édition. Triez le tout par dessinateur. Pour chaque dessinateur, les albums doivent être rangés en ordre chronologique.</p>
<pre class="taille60"><code>SELECT BA.isbn, BA.dessinateur, BA.annee_edition
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.nom = 'Dupuis' AND BA.annee_edition &gt;= 1990 AND BA.annee_edition &lt;= 2000
ORDER BY BA.dessinateur, BA.annee_edition;</code></pre>
                            </li>
                            <li>
                                <p>Chez quels éditeurs y a-t-il des albums pour lequel aucun auteur n'est fourni ?</p>
<pre class="taille60"><code>SELECT DISTINCT BE.nom
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BA.dessinateur IS NULL AND BA.scenariste IS NULL AND BA.coloriste IS NULL;</code></pre>
                            </li>
                            <li>
                                <p>Y a-t-il des albums pour lesquels le nom de l'éditeur est le même que celui de la série ? Listez les isbn des albums.</p>
<pre class="taille60"><code>SELECT BA.isbn
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.nom = BA.serie;</code></pre>
                            </li>
                            <li>
                               <p>Y a-t-il un éditeur qui porte le même nom q'un auteur ?</p>
<pre class="taille60"><code>SELECT BE.nom
FROM bd2.albums, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND (BE.nom = BA.scenariste OR BE.nom = BA.dessinateur OR BE.nom = BA.coloriste);</code></pre> 
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums édités en Belgique dont le dessinateur et le scénariste sont des personnes différentes ?</p>
<pre class="taille60"><code>SELECT COUNT(BA.*) AS "nombre d'albums"
FROM bd2.editeurs BE, bd2.albums BA
WHERE BE.num = BA.num_editeur AND BA.dessinateur != BA.scenariste AND BE.pays = 'b';</code></pre>
                            </li>
                            <li>
                                <p>Quelle est l'année d'édition la plus ancienne pour les albums édités chez "Casterman" ?</p>
<pre class="taille60"><code>SELECT MIN (BA.annee_edition AS "l'année la plus ancienne"
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.nom = 'Casterman';</code></pre>
                            </li>
                            <li>
                                <p>Quelle est l'ancienneté moyenne des albums édités par des éditeurs belges ?</p>
<pre class="taille60"><code>SELECT AVG (BA.annee_edition) AS "ancienneté moyenne"
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.pays = 'b';</code></pre>
                            </li>
                            <li>
                                <p>Si je n'ai que 5€ en poche, quelle est l'année d'édition de l'album le plus ancien que je puisse acheter ?</p>
<pre class="taille60"><code>SELECT MIN (BA.annee_edition)
FROM bd2.albums BA
WHERE BA.prix &lt;= 5;</code></pre>
                            </li>
                            <li>
                                <p>Combien d'albums n'ont ni scénariste, ni dessinateur, ni coloriste mentionné ?</p>
<pre class="taille60"><code>SELECT COUNT (BA.*) AS "nombre  d'albums"
FROM bd2.albums BA
WHERE BA.scenariste IS NULL AND BA.dessinateur IS NULL AND BA.coloriste IS NULL;</code></pre>
                            </li>
                            <li>
                                <p>Quel est le prix moyen des albums édités en Belgique ?</p>
<pre class="taille60"><code>SELECT AVG (BA.prix)
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.pays = 'b';</code></pre>
                            </li>
                            <li>
                                <p>Combien dois-je débourser pour acheter tous les albums fançais qui coûtent moins de 8€ ? Et combien d'albums achètererai-je ainsi ? Quel sera leur prix moyen ?</p>
<pre class="taille60"><code>SELECT SUM (BA.prix) AS "le montant des albums", COUNT (BA.*) AS "le nombre d'albums", AVG (prix) AS "le prix moyen"
FROM bd2.albums BA, bd2.editeurs BE
WHERE BA.num_editeur = BE.num AND BE.pays = 'f' AND BA.prix &lt; 8;</code></pre>
                            </li>
                            <li>
                                <p>Combien d'année "Franquin" a-t-il écrit ?</p>
<pre class="taille60"><code>SELECT MAX (BA.annee_edition) - MIN (BA.annee_edition) AS "les années de Franquin"
FROM bd2.albums BA
WHERE BA.scenariste = 'Franquin';</code></pre>
                            </li>
                            <li>
                                <p>Oscar a reçu pour son anniversaire l'album "Idées Noires" édité par le "Fluide glacial". Malheureusement, il possède déjà cet album; heureusement, il peut l'échanger contre un autre album du même prix. Contre quels albums peut-il échanger ?</p>
<pre class="taille60"><code>SELECT DISTINCT BA1.*
FROM bd2.albums BA1, bd2.albums BA2, bd2.editeurs BE
WHERE BA2.num_editeur = BE.num AND BA2.titre = 'Idées Noires' AND BE.nom = 'Froid glacial' AND BA1.prix = BA2.prix AND BA1.isbn != BA2.isbn;</code></pre>
                            </li>
                        </ol>
                        <h4 id="niveau_3">Niveau 3 : Base de données à plus de deux tables :</h4>
                        <img src="../images/niveau3.PNG" alt="DSD du niveau 3">
                        <p>Ce schéma est une nouvelle variante de votre base de données permettant une souplesse supplémentaireà propos des auteurs. Jusqu'ici, un album avait <span class="em">exactement trois</span> auteurs (ou moins de trois, si 2 d'entre eux, ou même les trois étaient identiques, ou encore si un ou plusieurs des champs scénariste, dessinateur ou coloriste avaient la valeur <span class="em">NULL</span>).</p>
                        <p>Ceci ne permet pas d'être fidèle à la réalite, car dans certains cas il peut y avoir plusieurs co-dessinateurs, co-scénaristes, ou co-coloristes.</p>
                        <p>De plus, on pourrait vouloir ajouter plus d'informations sur les auteurs : leur adresse courrier et mail, leur n° de téléphone, etc.</p>
                        <p>On vous suggère donc de fournir d'une part la table des albums, d'autre part celle des auteurs, et enfin une troisième table qui réalise la relation M à N entre albums et auteurs. De cette façon, non seulement chaque auteur pourra participer à autant d'albums que l'on veut, mais également chaque album pourra avoir autant d'auteurs que l'on veut.</p>
                        <p>Cette troisième table devra contenir <span class="em">les deux clés étrangères</span> (numéro du livre et numéro de l'auteur), plus un <span class="em">troisième attribut spécifiant le type de rôle joué par cet auteur dans le cadre de ce livre</span> (scénariste, dessinateur, coloriste). Ce 3ème attribut aura la valeur 's', 'c' ou 'd'.</p>
                        <p>Remarquons que de nouveaux attributs pourraient être ajoutés à la table auteurs. Le fait d'avoir créé cette table auteurs nous permet d'ajouter toute une série d'informations concernant chacun des auteurs en ne les précisant qu'une seule fois. Nous apprendrons plus tard que cette structure nous permet ainsi d'éviter la <span class="em">redondance des données</span>.</p>
                        <ol type="a">
                            <li>
                                <p>Écrivez les deux instructions <span class="html">CREATE TABLE</span> des tables <span class="em">auteurs</span> et <span class="em">participations</span>.</p>
<pre class="taille60"><code>CREATE TABLE bd3.editeurs
(
    num INTEGER PRIMARY KEY,
    nom VARCHAR (20) NOT NULL,
    adresse VARCHAR (30),
    pays CHAR (1),
);

CREATE TABLE bd3.albums
(
    isbn CHAR (13) PRIMARY KEY,
    titre VARCHAR (50) NOT NULL,
    serie VARCHAR (20),
    num_editeur INTEGER NOT NULL REFERENCES bd3.editeurs (num),
    annee_edition INTEGER,
    prix DOUBLE PRECISION NOT NULL,
);

CREATE TABLE bd3.auteurs
(
    num INTEGER PRIMARY KEY,
    nom VARCHAR (20) NOT NULL,
    adresse VARCHAR (30),
    e_mail VARCHAR (30),
);

CREATE TABLE bd3.participations
(
    isbn CHAR (13) NOT NULL REFERENCES bd3.albums (isbn),
    num_auteur INTEGER NOT NULL REFERENCES bd3.auteurs (num),
    participe CHAR (1) NOT NULL CHECK (participeIN ('s', 'd', 'c')),
    PRIMARY KEY (isbn, num_auteur, participe),
);</code></pre>
                            </li>
                            <li>
                                <p>Remplissez vos tables <span class="em">auteurs</span> et <span class="em">participations</span>.</p>
<pre class="taille60"><code>INSERT INTO bd3.participations (isbn, num_auteur, participe) VALUES ('2-87097055-9', 14, 's');
INSERT INTO bd3.participations (isbn, num_auteur, participe) VALUES ('2-87097055-9', 14, 'd');
INSERT INTO bd3.participations (isbn, num_auteur, participe) VALUES ('2-87097055-9', 14, 'c');

INSERT INTO bd3.auteurs (num, nom, e_mail) VALUES (3, 'Hergé', 'tintin@hotmail.be');
INSERT INTO bd3.auteurs (num, nom, e_mail, adresse) VALUES (11, 'Van Hamme', 'van_hamme@hotmail.com', 'Bruxelles');</code></pre>
                            </li>
                        </ol>
                        <ol>
                            <li>
                                <p>Quel est le dessinateur de l'album dont le titre est "Astérix chez les Belges" ?</p>
<pre class="taille60"><code>SELECT DISTINCT AU.*
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND AL.titre = 'Astérix chez les Belges' AND PA.participe = 'd';</code></pre>
                            </li>
                            <li>
                                <p>Pour quel(s) éditeur(s) a travaillé "Goscinny" ?</p>
<pre class="taille60"><code>SELECT DISTINCT ED.*
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND ED.num = AL.num_editeur AND AU.nom = 'Goscinny';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont tous les auteurs qui ont travaillé comme dessinateurs et/ou coloristes chez l'éditeur "Dupuis" ?</p>
<pre class="taille60"><code>SELECT DISTINT AU.*
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND ED.num = AL.num_editeur AND ED.nom = 'Dupuis' AND (PA.participe = 'd' OR PA.participe = 'c');</code></pre>
                            </li>
                            <li>
                                <p>Combien d'auteurs (différentsà a-t-on répertoriés pour l'album "Coke en Stock" ? (Essayez aussi avec d'autres titre, en fonction du contenu de vos tables)</p>
<pre class="taille60"><code>SELECT COUNT (DISTINCT PA.num_auteur)
FROM bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AL.titre = 'Coke en Stock';</code></pre>
                            </li>
                            <li>
                                <p>Donnez les titres et les prix de tous les albums dessinés par "Uderzo" entre 1985 et 1995.</p>
<pre class="taille60"><code>SELECT DISTINCT AL.titre, AL.prix
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND AU.nom = 'Uderzo' AND PA.participe = 'd' AND AL.annee_edition &gt;= 1985 AND AL.annee_edition &lt;= 1995;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums édités par "Casterman" pour lesquels on connaît le coloriste ?</p>
<pre class="taille60"><code>SELECT DISTINCT AL.titre
FROM bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AL.isbn = PA.isbn AND ED.num = AL.num_editeur AND ED.nom = 'Casterman' AND PA.participe = 'c';</code></pre>
                            </li>
                            <li>
                                <p>Quelle est l'année d'édition de l'album le plus récent ayant "Goscinny" parmi ses auteurs ?</p>
<pre class="taille60"><code>SELECT MAX (AL.annee_edition)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND AU.nom = 'Goscinny';</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste de tous les dessinateurs répertoriés, par ordre alphabétique.</p>
<pre class="taille60"><code>SELECT DISTINCT AU.nom
FROM bd3.auteurs AU, bd3.participations PA
WHERE AU.num = PA.num_auteue AND PA.participe = 'd'
ORDER BY AU.nom;</code></pre>
                            </li>
                            <li>
                                <p>Donnez la liste de tous les dessinateurs répertoriés, par ordre alphabétique, mais en donnant en outre, pour chaque dessinateur, le nom de l'éditeur (ou : les noms des éditeurs) pour qui il a travaillé. Donnez la liste par ordre alphabétique de dessinateur, et, pour chacun d'eux, par ordre alphabétique d'éditeur.</p>
<pre class="taille60"><code>SELECT DISTINCT AU.*, ED.nom
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND ED.num = AL.num_editeur AND PA.participe = 'd'
ORDER BY AU.nom, ED.nom;</code></pre>
                            </li>
                            <li>
                                <p>Donnez les noms de tous auteurs qui ont collaboré, d'une façon ou d'une autre, à des albums de la série "Astérix avant 1992.</p>
<pre class="taille60"><code>SELECT DISTINCT AU.nom
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND AL.serie = 'Astérix' AND AL.annee_edition &lt; 1992;</code></pre>
                            </li>
                            <li>
                                <p>Quels rôles l'auteur "Cosey" a-t-il tenu dans "Zeke raconte des histoires" ?</p>
<pre class="taille60"><code>SELECT DISTINCT PA.particpe
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND AU.nom = 'Cosey' AND lower (AL.titre) = 'zeke raconte des histoires';</code></pre>
                            </li>
                            <li>
                                <p>Quels rôles l'auteur "Uderzo" a-t-il tenus dans les albums édités par "Albert René" ?</p>
<pre class="taille60"><code>SELECT DISTINCT PA.participe
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND ED.num = AL.num_editeur AND lower (AU.nom) = 'uderzo' AND lower (ED.nom) = 'albert rené';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les auteurs qui ont joué plusieurs rôles (dessinateur, coloriste, ...) dans un même album ?</p>
<pre class="taille60"><code>SELECT DISTINCT PA.num_auteur
FROM bd3.participation PA1, bd3.participations PA2
WHERE PA1.isbn = PA2.isbn AND PA1.num_auteur = PA2.num_auteur AND PA1.participe != PA2.participe;

ou

SELECT DISTINCT PA.isbn, AU.*
FROM bd3.auteurs AU, bd3.participations PA
WHERE AU.num = PA.num_auteur
GROUP BY PA.isbn, AU.num, AU.nom, AU.adresse, AU.e_mail
HAVING COUNT (PA.participe) &gt; 1;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums qui ont été publiés en même temps que l'album dont le titre est "La marque jaune" ?</p>
<pre class="taille60"><code>SELECT DISTINCT AL2.*
FROM bd3.albums AL1, bd3.albums AL2
WHERE AL1.isbn != AL2.isbn AND lower (AL1.titre) = 'la marque jaune' AND AL1.annee_edition = AL2.annee_edition;</code></pre>
                                <h5 id="exercices_clause_group_by">Exercices sur la clause GROUP BY :</h5>
                            </li>
                            <li>
                                <p>Donnez les séries édités chez "Dupuis", et pour chacune d'elles, le nombre d'albums.</p>
<pre class="taille60"><code>SELECT AL.serie, COUNT (AL.isbn)
FROM bd3.albums AL, bd3.editeurs ED
WHERE AL.num_editeur = ED.num AND ED.nom = 'Dupuis' AND AL.serie IS NOT NULL
GROUP BY AL.serie;</code></pre>
                            </li>
                            <li>
                                <p>Quelles sont les dates du plus ancien et du plus récent album de chaque éditeur ?</p>
<pre class="taille60"><code>SELECT ED.num, ED.nom, MIN (AL.annee_edition), MAX (AL.annee_edition)
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur
GROUP BY ED.num, ED.nom;</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums dessinés pour chaque dessinateur ?</p>
<pre class="taille60"><code>SELECT AU.num, AU.nom, COUNT (PA.isbn)
FROM bd3.auteurs AU, bd3.participations PA
WHERE AU.num = PA.num_auteur AND PA.participe = 'd'
GROUP BY AU.num, AU.nom;</code></pre>
                            </li>
                            <li>
                                <p>DOnnez le nombre et le prix moyen des albums par année d'édition. Indiquez bien sûr l'année. Classez-le par ordre chronologique.</p>
<pre class="taille60"><code>SELECT AL.annee_edition, COUNT (AL.isbn), AVG (AL.prix)
FROM bd3.albums AL
ORDER BY AL.annee_edition
GROUP BY AL.annee_edition;</code></pre>
                            </li>
                            <li>
                                <p>Pour chaque éditeur quia édité au moins un album de moins de 10€, affichez son num, son nom, sa nationalité, et le nombre de livres de moins de 10€ qu'il a publiés.</p>
<pre class="taille60"><code>SELECT ED.num, ED.nom, ED.pays, COUNT (AL.isbn)
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur AND AL.prix &lt; 10
GROUP BY ED.num, ED.nom, ED.pays;</code></pre>
                            </li>
                            <li>
                                <p>Pour quels éditeurs "Uderzo" a-t-il été dessinateur ? Pour chacun de ces éditeurs, donnez le nombre d'albums dessinés, et le prix du plus cher d'entre eux.</p>
<pre class="taille60"><code>SELECT ED.num, ED.nom, COUNT (AL.isbn), MAX (AL.prix)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND ED.num = AL.num_editeur AND PA.participe = 'd' AND AU.nom = 'Uderzo'
GROUP BY ED.num, ED.nom;

ou

SELECT ED.num, ED.nom, COUNT (AL.isbn), MAX (AL.prix)
FROM bd2.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur AND ED.num IN (SELECT AL2.num_editeur
FROM bd3.auteurs AU2, bd3.participations PA2, bd3.albums AL2
WHERE AU2.num = PA2.num_auteur AND AL2.isbn = PA2.isbn AND PA2.participe = 'd' AND AU.nom = 'Uderzo')
GROUP BY ED.num, ED.nom;</code></pre>
                            </li>
                        </ol>
                        <h4 id="niveau_4">Niveau 4 : Les requêtes sur 1, 2, 3 ou 4 tables mélangées !</h4>
                        <p>Pour ces exercices, on se base sur la même base de données que celle du niveau 3; c'est-à-dire la bd3. Mais les questions sont complètement mixées; elles reposent parfois sur une seule table parfois sur les quatre.</p>
                        <img src="../images/niveau3.PNG" alt="DSD du niveau 3">
                        <p>La grande difficulté de ces exercices est de travailler (référencer dans le FROM) uniquement les tables nécessaires à la résolution de chaque query.</p>
                        <p>Parmi les exercices suivants, certains font appel à des notions qui n'ont pas été abordées au cours. Reprérez-les et éventuellement essayez de formuler la query en recherchant la solutions par vous-mêmes.</p>
                        <p>Vous remarquerez également que certaines queries sont bien plus faciles à résoudre dans les schémas des niveaux 1 (bd1) ou 2 (bd2). Mais, il faut les résoudre dans le schéma du niveau 3, c'est-à-dire <span class="em">bd3.albums</span>, <span class="em">bd3.editeurs</span>, etc. !</p>
                        <ol>
                            <li>
                                <p>Combien y a-t-il d'albums pour chaque série ?</p>
<pre class="taille60"><code>SELECT AL.serie, COUNT (AL.isbn)
FROM bd3.albums AL
WHERE AL.serie IS NOT NULL
GROUP BY AL.serie;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les éditeurs qui ont édité des albums en 1978 ?</p>
<pre class="taille60"><code>SELECT ED.nom
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur AND AL.annee_edition = 1978;</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums par éditeur ?</p>
<pre class="taille60"><code>SELECT ED.nom, COUNT (AL.isbn)
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur
GROUP BY ED.nom;</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums par scénariste ?</p>
<pre class="taille60"><code>SELECT AU.nom, COUNT (AL.isbn)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND PA.participe = 's';</code></pre>
                            </li>
                            <li>
                                <p>Combien y a-t-il d'albums  par auteur ?</p>
<pre class="taille60"><code>SELECT AU.nom, COUNT (DISTINCT AL.isbn)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur
GROUP BY AU.nom;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums pour lesquels le coriste n'a pas été spécifié ?</p>
<pre class="taille60"><code>SELECT AL.*
FROM bd3.albums AL
WHERE AL.isbn NOT IN (SELECT PA.isbn
FROM bd3.participations
WHERE PA.participe = 'c');</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les scénaristes dont on a édités, après 1990, des albums qui coûtent moins de 8€ ?</p>
<pre class="taille60"><code>SELECT AU.nom
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AU.num = PA.num_auteur AND AL.isbn = PA.isbn AND AL.annee_edition &gt; 1990 AND AL.prix &lt; 8 AND PA.participe = 's';</code></pre>
                            </li>
                            <li>
                                <p>Donnez le nom de la série et le nombre d'albums de chaque série dessinées par "Franquin" ? Cette question peut être formulée autrement : pour tous les albums dont le dessinateur est "Franquin", combien y a-t-il d'albums de chaque série ?</p>
<pre class="taille60"><code>SELECT AL.serie, COUNT (AL.titre)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND AU.nom = 'Franquin' AND PA.participe = 'd' AND AL.serie IS NOT NULL
GROUP BY AL.serie;</code></pre>
                            </li>
                            <li>
                                <p>Donnez le prix moyen des albums par année d'édition, avec bien entendu l'année d'édition.</p>
<pre class="taille60"><code>SELECT AL.annee_edition, AVG (AL.prix)
FROM bd3.albums AL
GROUP BY AL.annee_edition;</code></pre>
                            </li>
                            <li>
                                <p>Par série, combien y a-t-il de scénaristes pour les albums édités en Belgique ?</p>
<pre class="taille60"><code>SELECT AL.serie, COUNT (DISTINCT PA.num_auteur)
FROM bd3.participations PA, bd3.albums AL, bd3.editeurs ED
WHERE PA.isbn = AL.isbn AND ED.num = AL.num_editeur AND PA.particippe = 's' AND ED.pays 'b' AND AL.serie IS NOT NULL
GROUP BY AL.serie;</code></pre>
                            </li>
                            <li>
                                <p>Quelle est l'année d'édition la plus ancienne pour les albums édités chez "Casterman" ?</p>
<pre class="taille60"><code>SELECT MIN (AL.annee_edition)
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur AND ED.nom = 'Casterman';</code></pre>
                            </li>
                            <li>
                                <p>Quel est le prix moyen des albums édités en Belgique ?</p>
<pre class="taille60"><code>SELECT AVG (AL.prix)
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_editeur AND ED.pays = 'b';</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les albums qui n'ont qu'un seul auteur ?</p>
<pre class="taille60"><code>SELECT AL.*
FROM bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn
GROUP BY AL.*
HAVING COUNT (DISTINCT PA.num_auteur) = 1;</code></pre>
                            </li>
                            <li>
                                <p>Chez quels éditeurs y a-t-il des albums pour lesquels aucun auteur n'est spécifié ?</p>
<pre class="taille60"><code>SELECT ED.nom
FROM bd3.albums AL, bd3.editeurs ED
WHERE ED.num = AL.num_auteur AND AL.isbn NOT IN (SELECT PA.isbn
FROM bd3.participations PA);</code></pre>
                            </li>
                            <li>
                                <p>Quelle est la première année où l'on a édité un album ayant été écrit par un auteur complet, c'est-à-dire où le scénariste, le dessinateur et le coloriste sont la même personne; aucun n'est inconnu, c'est-à-dire absent de la base de données ? Essayez également avec la table <span class="em">bd1.albums</span>.</p>
<pre class="taille60"><code>SELECT MIN (AL.annee_editiion)
FROM bd3.albums AL
WHERE 3 IN (SELECT COUNT (PA.participe)
FROM bd3.participations PA
WHERE PA.isbn = AL.isbn);</code></pre>
                            </li>
                            <li>
                                <p>Quel est le titre du moins cher des albums édités en 1977 ?</p>
<pre class="taille60"><code>SELECT AL.titre
FROM bd3.albums AL
WHERE AL.annee_edition = 1977 AND AL.prix = (SELECT MIN (AL2.prix)
FROM bd3.albums AL2
WHERE AL2.annee_edition = 1977);</code></pre>
                            </li>
                            <li>
                                <p>Y a-t-il des albums différents portant le même titre ? Si oui, quels sont ces titres, et les années d'édition.</p>
<pre class="taille60"><code>SELECT AL1.titre, AL.annee_edition
FROM bd3.albums AL1, bd3.albums AL2
WHERE AL1.isbn != AL2.isbn AND AL1.titre = AL.titre;</code></pre>
                            </li>
                            <li>
                                <p>Quels sont les dessinateurs qui ont travaillé sur des albuls de plusieurs séries ? Essayez également avec la table <span class="em">bd1.albums</span>.</p>
<pre class="taille60"><code>SELECT AU.nom, COUNT (DISTINCT AL.serie)
FROM bd3.auteurs AU, bd3.participations PA, bd3.albums AL
WHERE AL.isbn = PA.isbn AND AU.num = PA.num_auteur AND PA.participe = 'd'
GROUP BY AU.nom
HAVING COUNT (DISTINCT AL.serie) &gt; 1;</code></pre>
                            </li>
                            <li>
                                <p>Donnez, pour chaque album ayant au moins un auteur répertorié, son isbn, son titre et le nombre d'auteurs différents intervenant dans cet album.</p>
<pre class="taille60"><code>SELECT AL.isbn, AL.titre, COUNT (DISTINCT PA.num_auteur)
FROM bd3.albums AL, bd3.participatons PA
WHERE AL.isbn = PA.isbn
GROUP BY AL.isbn, AL.titre;</code></pre>
                            </li>
                        </ol>
                    </article>
                    <article id="partie2">
                        <h2 id="partie_conception">Partie Conception 1ère année :</h2>
                        <h3 id="introduction_conception">Introduction :</h3>
                        <p>Nous allons maintenant aborder la seconde partie du cours. L'objectif de celle-ci est de concevoir des bases de données.</p>
                        <p>Au départ d'un énoncé, nous allons rechercher les entités-clé et les <span class="em">modéliser</span> sous forme d'un <span class="em">schéma</span> appelé <span class="em">Diagramme de Structure de Données (DSD)</span>.</p>
                        <p>La <span class="em">conception</span> de base de données est une démarche qui permet de réfléchir aux données afin de mémoriser finement l'information. Ceci nous permet :</p>
                        <ul>
                            <li>de mettre en évidence chaque entité et ses attributs, de manière à éviter la redondance,</li>
                            <li>de définir une information unique qui permet d'identifier chaque entité,</li>
                            <li>de préciser ce que contient chaque attribut, et d'éviter d'y placer des "choses" différentes,</li>
                            <li>d'établir et de formaliser les relations entre les entités,</li>
                            <li>de questionner plus précisément la base de données.</li>
                        </ul>
                        <p>Nous allons brièvement revoir la démarche que nous avions suivie pendant la première partie du cours pour évoluer d'une base de données contenant une seule table "albums" vers une base de données en contenant quatre : éditeurs, albums, auteurs et participations.</p>
                        <p>Ceci nous permettra d'introduire les contraintes d'intégrité et de passer en revue les concepts de clé primaire et de clé étrangère.</p>
                        <p>Nous verrons ensuite, dans le détail, les différents modèles de relations qui peuvent exister entre les tables et nous illusterons le problème de la prise en compte du temps dans les relations.</p>
                        <p>Nous donnerons, dans la foulée, les consignes pour organiser lisiblement le DSD.</p>
                        <p>Enfin, nous aborderons les tables spécialisées et les étapes de développement d'une application.</p>
                        <p>Nous terminerons cette partie du cours en évoquant la problématique de sauvegarde des données. La conception d'une DB exigeant que l'on chasse la redondance au maximum, nous pourrions entrevoir le concept de la normalisation dont on en reparlera dans la troisième partie du cours.</p>
                        <h3 id="rappels">Rappels</h3>
                        <ol>
                            <li>
                                <h4 id="bd1_albums">bd1.albums :</h4>
                                <p>Dans la partie 1 (SQL), nous étions partis d'un exemple pour gérer les données des albums de bandes dessinées.</p>
                                <p>Nous avions créé une table <span class="em">albums</span> correspondant à l'entité albums; chaque album dispose d'une information unique d'identification : le numéro isbn et les attributs suivants : titre, série, sénariste, coloriste, éditeur, pays d'édition, année d'édition et prix.</p>
<pre class="taille60"><code>CREATE TABLE bd1.albums
(
    isbn CHAR (13) PRIMARY KEY,
    titre CHARACTER VARYING (50) NOT NULL,
    serie CHARACTER VARYING (20),
    scenariste CHARACTER VARYING (20),
    dessinateur CHARACTER VARYING (20),
    coloriste CHARACTER VARYING (20),
    editeur CHARACTER VARYING (20) NOT NULL,
    pays CHARACTER (1),
    annee_edition INTEGER,
    prix DOUBLE PRECISION NOT NULL,
);</code></pre>
                                <p>Dans notre notation DSD, cela donne :</p>
                                <p>Les clés primaires (PRIMARY KEY) sont soulignées. On indique la mention 'PK'.</p>
                                <p>Les champs obligatoires (NOT NULL) sont indiqués 'NN'.</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th rowspan="2">bd1.albums</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="bold">PK</td>
                                            <td class="bold souligne">isbn</td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>
                                                <p>titre NN</p>
                                                <p>serie</p>
                                                <p>scenariste</p>
                                                <p>dessinateur</p>
                                                <p>coloriste</p>
                                                <p>editeur NN</p>
                                                <p>pays</p>
                                                <p>annee_edition</p>
                                                <p>prix NN</p>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Quelles étaient les contraintes de ce modèle ?</p>
                                <ul>
                                    <li>Le pays d'édition dépend de l'éditeur et non de l'album.</li>
                                    <li>
                                        <p>Le nom et le pays de l'éditeur sont répétés pour chaque album. Cette répétition peut entraîner les problèmes suivants :</p>
                                        <ul>
                                            <li>Risque d'erreur : le nom de l'éditeur n'est pas toujours orthographié de manière correcte, il peut être écrit de manière différente (majuscule/minuscule).</li>
                                            <li>Il faut modifier le nom dans tous les albums, si la société change de nom,</li>
                                            <li>Risque d'incohérence : le pays de l'éditeur peut être différent d'un album à l'autre...</li>
                                        </ul>
                                    </li>
                                    <li>Les mêmes problèmes peuvent se produire pour le nom du scénariste, du dessinateur et du coloriste,</li>
                                    <li>Un album ne peut avoir qu'un seul scénariste, qu'un seul dessinateur, qu'un seul coloriste.</li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="bd2_albums">bd2.albums :</h4>
                                <p>Afin de solutionner les deux premiers problèmes (relatifs à l'éditeur), nous avons introduit une seconde entité : éditeurs. Une relation permet ensuite de joindre un éditeur à chaque album.</p>
                                <p>L'éditeur est identifié par un numéro unique. Il a des attributs nom et pays comme dans la solution bd1.albums auxquels nous avons ajouté un attribut adresse.</p>
                                <p>Dans la base de données, nous avions ajouté une table <span class="em">editeurs</span> à laquelle faisait référence la table <span class="em">albums</span>.</p>
                                <p>La nouvelle DB se présentait comme suit :</p>
                                <p>On indique la mention 'FK' à droite des clés étrangères (FOREIGN KEY).</p>
                                <img src="../images/niveau2.PNG" alt="DSD du niveau 2">
                                <p>Cela permet également de mémoriser des informations sur des éditeurs qui n'ont pas (encore) édités d'album.</p>
                                <p>Le lien entre les deux tables est assuré par une clé étrangère dans <span class="em">albums</span> faisant référence à <span class="em">editeurs</span>.</p>
                            </li>
                            <li>
                                <h4 id="bd3_albums">bd3.albums :</h4>
                                <p>Ensuite, nous avons affiné le modèle pour résoudre les deux problèmes restants :</p>
                                <ul>
                                    <li>nom des scénariste, dessinateur et coloriste répété à chaque album,</li>
                                    <li>limitation à un seul scénariste, dessinateur ou coloriste par album.</li>
                                </ul>
                                <p>Était-il intéressant de créer trois scénaristes, dessinateurs et coloristes ? Non, cela aurait également introduit une duplication des données. Une même personne pouvant occuper chacun des rôles pour un même album ou pour des albums différents.</p>
                                <p>Nous avons donc introduit une entité auteurs et créé une table <span class="em">auteurs</span> dans laquelle chaque auteur sera référencé.</p>
                                <p>Comme un auteur peut participer à plusieurs albums et qu'un album peut avoir plusieurs auteurs, nous avons introduit une table intermédiaire notée ici <span class="em">participations</span>.</p>
                                <p>La table <span class="em">participations</span> indique quel auteur intervient dans quel album. Il y a 3 types d'intervention possible matérialisée dans le champ <span class="em">participe</span> : '<span class="em">s</span>' pour scénariste, '<span class="em">c</span> pour coloriste et '<span class="em">d</span>' pour dessinateur.</p>
                                <p>Un tuple de <span class="em">participation</span> est identifié par le numéro de l'auteur, l'ISBN de l'album et le rôle joué par l'auteur dans cet album.</p>
                                <p>Les 3 champs de participations ne peuvent donc jamais être <span class="em">NULL</span>.</p>
                                <img src="../images/niveau3.PNG" alt="DSD du niveau 3">
                                <p>Ce modèle permet donc, comme le second :</p>
                                <ul>
                                    <li>de mémoriser des informaions propres aux éditeurs, sans devoir les répéter à chaque album édité.</li>
                                    <li>de mémoriser des informations sur des éditeurs qui n'ont pas (encore) édité d'album.</li>
                                </ul>
                                <p>Mais, en plus,</p>
                                <ul>
                                    <li>de mémoriser des informations propres aux auteurs, sans devoir les répéter à chaque album édité.</li>
                                    <li>de mémoriser des informations sur des auteurs qui n'ont pas encore participé à un album.</li>
                                    <li>d'avoir plusieurs scénaristes, dessinateurs ou coloristes pour un même album.</li>
                                </ul>
                                <p>Exemple de contenu des tables :</p>
                                <img src="../images/contenu_tables_niveau_3.PNG" alt="contenu des tables de niveau 3">
                            </li>
                        </ol>
                        <h3 id="contraintes_integrite">Les contraintes d'intégrité :</h3>
                        <p>Nous avons défini des clés primaires et des clés étrangères dans nos bases de données. Elles assurent la cohérence de la base de données. Nous allons voir par quels mécanismes.</p>
                        <ol>
                            <li>
                                <h4 id="cle_primaire">La clé primaire :</h4>
                                <p>Une <span class="em">clé primaire</span> doit identifier chaque tuple d'une table de façon non ambiguë. C'est un identifiant <span class="em">unique</span> et <span class="em">non nul</span>. Cette contrainte d'intégrité permet de s'assurer de <span class="em">l'<span class="souligne">unicité</span> d'un enregistrement pour une table</span>.</p>
                                <p>Lorsqu'une entité dispose naturellement d'un identifiant unique, cet identifiant unique peut êtrechoisi comme clé primaire. Le numéro <span class="em">isbn</span> peut être la clé primaire de la table <span class="em">albums</span>.</p>
                                <p>Lorsqu'une entité ne dispose d'aucun identifiant unique ou par choix, on choisit un numéro auto incrémenté. Un numéro séquentiel unique est la clé primaire de la table <span class="em">editeurs</span>.</p>
                                <p>Dans la table participation, la clé primaire est une concaténation de troischamps : <span class="em">isbn</span>, <span class="em">num_auteur</span> et <span class="em">participe</span> qui permettent d'identifier de manière unique la participation d'un auteur à un album via son rôle.</p>
                            </li>
                            <li>
                                <h4 id="cle_etrangere">La clé étrangère :</h4>
                                <p>L'intégrité référentielle garantit la <span class="em">cohérence des références entre tables</span>.</p>
                                <p>Pour chaque information d'une table A qui fait référence à une information d'une table B, l'information référencée existe dans la table B.</p>
                                <p>Les <span class="em">contraintes d'<span class="souligne">intégrité référentielle</span></span> garantissent donc la cohérence de la base de données.</p>
                                <p>Elles précisent les conditions dans lesquelles peuvent être ajoutés ou supprimés des enregistrements dans une table lorsqu'il existe des relations entre cette table et d'autres tables par l'intermédiaire de <span class="em">clés étrangères</span>.</p>
                                <p>Cela signifie que :</p>
                                <ul>
                                    <li>
                                        <p class="em">Un 'enfant' ne peut référer un 'parent' que s'il existe.</p>
                                        <ul>
                                            <li>Le SGBD interdira d'ajouter un album si l'éditeur n'est pas enregistré dans la table <span class="em">editeurs</span>.</li>
                                            <li>La contrainte interdira d'ajouter une participation si l'auteur et l'album ne sont pas préalablement inscrits dans la base de données.</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <p class="em">Un 'parent' ne peut pas être supprimé s'il laisse des 'orphelins'.</p>
                                        <ul>
                                            <li>La contrainte interdira l'effacement d'un éditeur, tant que dans la base de données il existera au moins un album se référant à cet éditeur.</li>
                                            <li>Elle interdira de supprimer un auteur ou un album tant qu'il existera des participations pour cet auteur ou cet album.</li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>Notons également que si la clé primaire est composée de plusieurs champs, il en sera forcément même pour les clés étrangères.</p>
<pre class="taille60"><code>CREATE TABLE table1
(
    cle_partie1 CHAR (4) NOT NULL,
    cle_partie2 CHAR (3) NOT NULL,
    ...,
    PRIMARY KEY (cle_partie1, cle_partie2),
);

CREATE TABLE table2
(
    cle_table2 INTEGER PRIMARY KEY,
    cle_etrangere_partie1 CHAR (4) NOT NULL,
    cle_etrangere_partie2 CHAR (3) NOT NULL,
    ...,
    FOREIGN KEY (cle_etrangere_partie1, cle_etrangere_partie2) REFERENCES table1 (cle_partie1, cle_partie2),
);</code></pre>
                            </li>
                        </ol>
                        <h3 id="representation_schema">La représentation d'un schéma :</h3>
                        <ol>
                            <li>
                                <h4 id="conventions_dsd">Conventions :</h4>
                                <p>Pour représenter un schéma, nous utilisons les conventions suivantes :</p>
                                <ol>
                                    <li>Utiliser des noms de table entièrement en minuscules.</li>
                                    <li>Utiliser des noms de table au pluriel.</li>
                                    <li>Utiliser des noms de champs entièrement en minuscules.</li>
                                    <li>Utiliser "_" (underscore) pour séparer les mots.</li>
                                    <li>Ne mettre aucun caractère accentué dans les noms de table et de champ.</li>
                                    <li>Souligner la clé primaire et indiquer PK à gauche.</li>
                                    <li>Indiquer le mot-clé FK entre () à côté d'une clé étrangère.</li>
                                    <li>Indiquer NN pour les champs NOT NULL.</li>
                                    <li>Respecter le vocabulaire métier (le vocabulaire de l'énoncé).</li>
                                    <li>Vérifier la cohérence des clés étrangères (FK) et des relations.</li>
                                    <li>Mentionner le mot-clé unique lorsque cela est nécessaire.</li>
                                    <li>Mentionner les énumérés entre {}.</li>
                                </ol>
                                <p>Graphiquement, une table est représentée de la sorte :</p>
                                <img src="../images/conventions_dsd_1.PNG" alt="image n°1 des conventions du DSD">
                                <ul>
                                    <li>
                                        <p>Lorsqu'un seul champ compose la clé primaire, il est indiqué uniquement dans l'espace réservé à cet effet.</p>
                                        <p>Cela correspond au CREATE TABLE :</p>
<pre class="taille60"><code>CREATE TABLE bd1.albums
(
    isbn CHAR (13) <span class="em">PRIMARY KEY</span>,
    titre CHARACTER VARYING (50) NOT NULL,
    serie CHARACTER VARYING (20),
    ...
);</code></pre>
                                    </li>
                                    <li>
                                        <p>Lorsque plusieurs champs composent la clé primaire, leur concaténation est indiquée dans l'espace réservé à cet effet et chaque champ est repris avec ses propriétés dans la liste des champs.</p>
                                        <img src="../images/conventions_dsd_2.PNG" alt="image n°2 des conventions du DSD">
                                        <p>Cela correspond au CREATE TABLE :</p>
<pre class="taille60"><code>CREATE TABLE table1
(
  cle_partie1 CHAR (4) NOT NULL,
  cle_partie2 CHAR (3) NOT NULL,
  ...,
  <span class="em">PRIMARY KEY (cle_partie1, cle_partie2)</span>,
);</code></pre>
                                    </li>
                                    <li>
                                        <p>Lorsqu'un seul champ compose la clé étrangère, le mot-clé FK est indiqué immédiatement derrière ce champ.</p>
                                        <img src="../images/niveau2.PNG" alt="DSD du niveau 2">
                                        <p>Cela correspond au CREATE TABLE :</p>
<pre class="taille60"><code>CREATE TABLE bd3.albums
(
    isbn CHAR (14) PRIMARY KEY,
    titre CHARACTER VARYING (50) NOT NULL,
    serie CHARACTER VARYING (20),
    num_editeur INTEGER NOT NULL <span class="em">REFERENCES bd3.editeurs (num)</span>,
    ...
);</code></pre>
                                    </li>
                                    <li>
                                        <p>Lorsque plusieurs champs composent la clé étrangère, chaque champ est repris avec ses propriétés dans la liste des champs et leur concaténation est ensuite indiquée avec le mot-clé FK.</p>
                                        <img src="../images/conventions_dsd_3.PNG" alt="image n°3 des conventions de DSD">
                                        <p>Cela correspond au CREATE TABLE :</p>
<pre class="taille60"><code>CREATE TABLE table1
(
    cle_partie1 CHAR (4) NOT NULL,
    cle_partie2 CHAR (3) NOT NULL,
    ...,
    PRIMARY KEY (cle_partie1, cle_partie2),
);

CREATE TABLE table2
(
    cle_table2 INTEGER PRIMARY KEY,
    etr_partie1 CHAR (4) NOT NULL,
    etr_partie2 CHAR (3) NOT NULL,
    ...,
    <span class="em">FOREIGN KEY (etr_partie1, etr_partie2) REFERENCES table1 (cle_partie1, cle_partie2)</span>,
);</code></pre>
                                    </li>
                                    <li>
                                        <p>De la même manière, lorsqu'un champ est unique, le mot-clé <span class="html">unique</span> est indiqué immédiatement après ce champ. Lorsque la concaténation de plusieurs champs est unique, chaque champ est repris avec ses propriétés dans la liste des champs et leur concaténation est ensuite indiquée avec le mot-clé <span class="em">unique</span>. Dans l'exemple ci-dessous, on remarque que le mot-clé <span class="em">unique</span> est combiné avec le mot-clé FK.</p>
                                        <img src="../images/conventions_dsd_4.PNG" alt="image n°4 des conventions de DSD">
                                        <p>Cela correspond au CREATE TABLE :</p>
<pre class="taille60"><code>CREATE TABLE table1
(
    cle_partie1 CHAR (4) NOT NULL,
    cle_partie2 CHAR (3) NOT NULL,
    ...,
    PRIMARY KEY (cle_partie1, cle_partie2),
);

CREATE TABLE table2
(
    cle_table2 INTEGER NOT NULL,
    etr_partie1 CHAR (4) NOT NULL,
    etr_partie2 CHAR (3) NULL,
    ...,
    FOREIGN KEY (etr_partie1, etr_partie2) REFERENCES table1 (cle_partie1, cle_partie2),
    <span class="em">UNIQUE (etr_partie1, etr_partie2)</span>,
);</code></pre>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="organisation_graphique_dsd">L'organisation graphique du DSD :</h4>
                                <p>Certaines règles simples permettent de structurer le dessin pour qu'il devienne un support fiable à la conception.</p>
                                <ol>
                                    <li>On placera en haut (à la périphérie) du dessin les entités les plus indépendantes et en bas (au centre) du dessin les entités les plus dépendantes. Généralement, les entités les plus dépendantes sont les plus volumineurses et les plus mouvementées. Souvent on descend vers les tables volumineuses.</li>
                                    <li>On évitera de croiser les relations. Il faut éviter les schémas spaghetti ou jeu de piste.</li>
                                    <li>Pour les schémas très importants, on peut utiliser des couleurs différentes pour mettre en valeur des tables de natures différentes ou utilisées dans différentes applications.</li>
                                    <li>On peut également créer plusieurs schémas en reprenant les tables communes.</li>
                                </ol>
                                <img src="../images/organisation_graphique_dsd.PNG" alt="organisation graphique du DSD">
                            </li>
                        </ol>
                        <h3 id="relations">Les relations :</h3>
                        <ol>
                            <li>
                                <h4 id="relation_1_a_0N">Cas classique : relation 1 à 0 : N :</h4>
                                <p>Un client peut passer plusieurs commandes d'articles. Un client est identifié par un numéro unique de client. Ce numéro peut être fourni par le système(un champ auto incrémenté par le SGBD) par un programme ou encore par l'utilisateur. On ajoutera plusieurs champs : le nom, l'adresse, le numéro de téléphone, ...</p>
                                <p>Une commande est identifiée par un numéro de commande (clé primaire qui peut être également un numéro séquentiel ou un champ plus complexe...). On ajoutera d'autres champs pour indiquer la date de la commande, l'état (pour le suivi), et un numéro de facture (dans l'hypothèse simpliste où à une commande correspond une seule facture).</p>
                                <p>Il faut en outre faire le lient avec le client. Plutôt que de répéter les informations du client nécessaires à la commandes, on établira un lien avec la table <span class="em">clients</span> en mémorisant ici le numéro du client concerné. Ce champ était une clé primaire dans la table client, c'est une clef étrangère dans la table commande (FK).</p>
                                <img src="../images/relation_1_a_0N.PNG" alt="DSD de la relation 1 à 0 : N">
                                <p>Le symbole <span class="html">-o∊</span> montre une relation 1 : 0-N. Cette relation se lit dans les deux sens :</p>
                                <ul>
                                    <li>un client a plusieurs commandes. Il peut ne pas en avoir, effectivement le symbole <span class="html">o</span> indique que la relation est facultative.</li>
                                    <li>une commande est associée obligatoirement à un client.</li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="relation_1_a_1N">Cas de la relation 1 à 1 : N :</h4>
                                <p>On pourrait dire qu'un client n'est enregistré qu'au moment où il passe une première commande d'articles. Il pourra passer plusieurscommandes d'articles.</p>
                                <p>Le symbole <span class="html">-∊</span> montre une relation 1 : 1-N. Cette relation se lit dans les deux sens :</p>
                                <ul>
                                    <li>Un client a au minimum une commande. Il peut avoir plusieurs commandes.</li>
                                    <li>Une commande est associée obligatoirement à un client.</li>
                                </ul>
                                <img src="../images/relation_1_a_1N.PNG" alt="DSD de la relation 1 à 1 : N">
                            </li>
                            <li>
                                <h4 id="relation_1_a_01">Cas de la relation 1 à 0 : 1 :</h4>
                                <p>Une commande peut référencer éventuellement une facture. Pour le moment, la facture est considérée comme un attribut de la commande. Envisagons la nécessité d'en créer une entité à part entière. Nous avons donc deux tables : <span class="em">commandes</span> et <span class="em">factures</span>.</p>
                                <p>Une commande référence éventuellement une facture. Une facture référence toujours une commande mais on ne retirnt pas cette information.</p>
                                <p>La relation est donc facultative. Dans la table commandes, la clé étrangère sera donc annotée <span class="em">NULL</span> et graphiquement on ajoutera un petit rond à l'extrémité de l'association.</p>
                                <p>Le symbole <span class="html">-o</span> montre une relation 1 : 0-1. Cette relation se lit dans les deux sens :</p>
                                <ul>
                                    <li>une commande référence éventuellement une facture.</li>
                                    <li>une facture référence toujours une commande.</li>
                                </ul>
                                <img src="../images/relation_1_a_01_1.PNG" alt="DSD n°1 de la relation 1 à 0 : 1">
                                <p>Cette relation peut également être représentée par une clé étrangère du côté de la facture :</p>
                                <img src="../images/relation_1_a_01_2.PNG" alt="DSD n°2 de la relation 1 à 0 : 1">
                                <p>Afin de s'assurer que deux ou plusieurs commandes ne référencent pas le même numéro de facture, on peut noter une contrainte d'unicité sur le champ facture (noté ici <span class="em">unique</span>.</p>
                                <img src="../images/relation_1_a_01_3.PNG" alt="DSD n°3 de la relation 1 à 0 : 1">
                                <p>Et réciproquement,</p>
                                <img src="../images/relation_1_a_01_4.PNG" alt="DSD n°4 de la relation 1 à 0 : 1">
                            </li>
                            <li>
                                <h4 id="relation_1_a_1">Cas de la relation 1 à 1 :</h4>
                                <p>Si on considère qu'à chaque commande correspondra nécessairement une facture, il faut ajuster le diagramme afin de relier les tables <span class="em">commandes</span> et <span class="em">factures</span> avec une relation 1 à 1.</p>
                                <p>Le symbole <span class="html">-</span> montre une relation 1:1. Cette relatin se lit dans les deux sens :</p>
                                <ul>
                                    <li>une commande référence toujours une facture.</li>
                                    <li>une facture référence toujours une commande.</li>
                                </ul>
                                <img src="../images/relation_1_a_1_1.PNG" alt="DSD n°1 de la relation 1 à 1">
                                <p class="em">Pour que le SGBD puisse facilement garantir la relation 1 à 1, il est conseillé d'utiliser la même clé primaire dans les deux tables, quand c'est possible.</p>
                                <p>On utilise dans ce cas la clé primaire de la table <span class="em">commandes</span> également comme clé primaire pour la table <span class="em">factures</span>. Dans la table <span class="em">commandes</span>, on n'indique aucun clé étrangère. Une facture ser  identifiée par un numéro de commande.</p>
                                <img src="../images/relation_1_a_1_2.PNG" alt="DSD n°2 de la relation 1 à 1">
                                <p>&#8594; Remarquons qu'il serait plus judicieux d'utiliser le numéro de facture qui est un élément idispensable d'une facture en bonne et due forme.</p>
                                <img src="../images/relation_1_a_1_3.PNG" alt="DSD n°3 de la relation 1 à 1">
                            </li>
                            <li>
                                <h4 id="autres_relations">Autres relations entre deux tables :</h4>
                                <p>On peut combiner les terminaisons de relations supportées par le SGBD.</p>
                                <p>Le symbole <span class="html">o-o</span> montre une relation 0-1 : 0-1.Cette relation se lit dans les deux sens :</p>
                                <ul>
                                    <li>une entité a référence éventuellement une entité b.</li>
                                    <li>une entité b référence éventuellement une entité a.</li>
                                </ul>
                                <p>Le symbole <span class="html">o-o∊</span> montre une relation 0-1 : 0-N.</p>
                                <p>Le symbole <span class="html">o-∊</span> montre une relation 0-1 : 1-N.</p>
                            </li>
                            <li>
                                <h4 id="relation_m_a_n">Cas de la relation M à N :</h4>
                                <p>Une commande peut porter sur plusieurs articles. Un article peut faire partie de plusieurs commandes.</p>
                                <p>C'est une relation M à N.</p>
                                <img src="../images/cle_primaire_concatenee.PNG" alt="">
                                <p>Le SGBD ne peut pas implémenter cette relation directement mais le fait par le biais de deux relations 1 : N.</p>
                                <p>Cela exige donc la création d'une nouvelle entité intermédiaire.</p>
                                <p>Concrètement, on sera obligé de créer une table pour mémoriser le fait que dans une même commande, on rencontre plusieurs articles mais qu'un même article peut, bien entendu, être commandé plusieurs fois.</p>
                                <img src="../images/relation_M_a_N.PNG" alt="DSD de la relation M à N">  
                            </li>
                        </ol>
                        <h3 id="cle_etrangere_null">Une clé étrangère à NULL :</h3>
                        <p>La clé étrangère peut être à NULL pendant un certain temps et définie par la suite.</p>
                        <p>Prenons l'exemple du carnet de rendez-vous d'un cabinet médical. Ce cabinet est composé d'une dizaine de médecins qui ont une grille de rendez-vous qui s'échelonnent toutes les demi-heures. Les médecins prestent seulement certains jours ou demi-jours dans ce cabinet et parfois de façon irrégulière.</p>
                        <p>La secrétaire encode au départ les disponibilités de chaque médecin et puis fixe les rendez-vous avec les patients sur base de celles-ci.</p>
                        <p>Évolution de la construction du DSD :</p>
                        <h4>Étpae 1 : le planning :</h4>
                        <p>On prévoit les disponibilités de chaque médecin :</p>
                        <img src="../images/planning_1.PNG" alt="DSD n°1 du planning">
                        <p>Remarque : vu la convention que nous adoptons (nom d'une table toujours au pluriel), nous préférerons rendez-vous comme nom pour la table.</p>
                        <h4>Étape 2 : l'introduction des patients :</h4>
                        <p>Aussi longtemps que la plage du planning n'est pas attribuée à un patient, la clé étrangère <span class="em">num_sis</span> de la table rendez-vous reste à NULL.</p>
                        <img src="../images/planning_2.PNG" alt="DSD n°2 du planning">
                        <p>Lorsqu'un patient prend le rendez-vous disponsible, la clé étrangère est indiquée. Il se pourrait que certains rendez-vous ne soient jamais attribués.</p>
                        <ol>
                            <li>
                                <h4 id="influence_temps_cles_etrangeres">Influence du temps sur les clés étrangères :</h4>
                                <p>Exemple : un grossiste effectue des livraisons à ses clients tout au long du mois en fonction de leurs commandes. À la fin du mois, toutes ces livraisons sont facurées en une seule fois. La facture d'un client regroupe donc toutes les livraisons effectuées à ce client durant le mois.</p>
                                <img src="../images/influence_temps_cle_etrangere.PNG" alt="DSD de l'influence sur les clés étrangères">
                                <p>Cet exemple démontre bien <span class="em">l'importance de nommer les relations</span> dans certains cas. Il est une nouvelle illustration d'une clé étrangère de valeur NULL.</p>
                                <p>Entre les entités clients, il exite deux relations différentes. Celles-ci pourraient être de cardinalité différente (voir plus loin).</p>
                                <p>On peut noter que certains champs pourraient également servir d'identifiant unique. On peut en faire des index uniques (notés ici <span class="em">idx_unique</span>).</p>
                                <p>Un <span class="em">index</span> est une propriété d'une colonne de la base de données permettant de l'indexer dans le but d'améliorer l'accès aux données par le SGBD. Tout comme l'index dans un livrequi permet de retrouver plus facilement l'information, l'<span class="em">index unique</span> impose l'unicité de l'indexation; il permet d'identifier chaque tupled'une table de façon non ambiguë.</p>
                            </li>
                        </ol>
                        <h3 id="relations_multiples">Les relations multipkes entre tables :</h3>
                        <ol>
                            <li>
                                <h4 id="relations_M_a_N">Relations M à N :</h4>
                                <p>Une table donnée peut avoir deux relations M à N avec deux tables différentes (et beaucoup si nécessaire).</p>
                                <p>Voici un DD qui illustre ce propos :</p>
                                <img src="../images/relation_multiple_M_a_N.PNG" alt="relation multiple M à N">
                                <p>La même table <span class="em">cours</span> participe à deux relations M à N différentes.</p>
                                <ol>
                                    <li><span class="em">resultats</span> donne le résultat pour un cours et un étudiant. (remarque : il serait utile de se demander comment conserver les résultats s'il y a plusieurs sesions possibles).</li>
                                    <li><span class="em">horaires</span> décrit les heures auxquelles se donne un cours dans un local.</li>
                                </ol>
                                <h5>Choix des clés primaires :</h5>
                                <ol>
                                    <li><span class="em">resultats</span> est telle que pour un cours et un étudiant on n'a qu'un seul résultat. La clé primaire est donc formée par la <span class="em">concaténation des deux clés étrangères</span>.</li>
                                    <li>En ce qui concerne <span class="em">horaires</span>, c'est différent; un même cours peut être donné dans un même local à des moments différents. La clé primaire est donc indépendante des clés étrangères.</li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="relations_1_a_N">Relations 1 à N :</h4>
                                <h5>Gestion des classes d'une école de l'enseignement secondaire :</h5>
                                <p>Dans l'enseignement secondaire, les élèves sont regroupés par niveaux d'étude (ou années).</p>
                                <p>Une classe regroupe plusieurs élèves, en général entre 12 et 25.</p>
                                <p>Le programme de cours prévoit 32 heures de cours par élève. Outre les cours obligatoires, l'élève doit choisir et s'inscrire à des cours à option. Un cours est organisé pour minimum 8 élèves.</p>
                                <p>Un professeur donne 19 heures de cours, parfois il peut accepter de donner jusqu'à 4 heures supplémentaires, parfois il doit accepter un temps partiel.</p>
                                <p>Un cours n'est attribué qu'à un seul professeur.</p>
                                <p>Parmi les professeurs, on choisit un titulaire de classe. Il arrive qu'un professeur soit titulaire de 2 classes.</p>
                                <img src="../images/relation_multiple_1_a_N.PNG" alt="DSD de la gestion des classes d'une école de l'enseignement secondaire">
                                <p>Dans ce diagramme, plusieurs entités ont deux relations différentes entre elles : une classe a un professeur titulaire et un seul mais une classe a plusieurs professeurs qui lui donnent cours. Ces mêmes professeurs donnent cours à d'autre classes.</p>
                            </li>
                            <li>
                                <h4 id="relation_1_a_N_induite">Relation 1 à N induite :</h4>
                                <p>Si entre les entités <span class="em">clients</span> et <span class="em">commandes</span>, il y a une relation 1 à N et si entre les entités <span class="em">commandes</span> et <span class="em">lignes_commande</span>, il y a aussi une relation 1 à N, il existe alors une relation 1 à N déduite entre <span class="em">clients</span> et <span>lignes_commande</span>. Il est inutile de la dessiner.</p>
                                <img src="../images/relation_1_a_N_induite.PNG" alt="DSD de la relation 1 à N induite">
                            </li>
                        </ol>
                        <h3 id="relations_reflexives">Les relations réflexives :</h3>
                        <ol>
                            <li>
                                <h4 id="relations_reflexives_hierarchiques">Relations réflexives hiérarchiques :</h4>
                                <p>Le cas typique de ce genre de relation est la table où l'on désire mémoriser des services d'une institution organisée hiérarchiquement.</p>
                                <p>La direction comprend, entre autres, un service juridique. Celui-ci se décompose en service juridique du personnel et service juridique commercial ainsi que le contentieux. Le service juridique contentieux gère les conflits et les procès pour la Belgique et l'étranger; deux sous services sont donc créés, etc.</p>
                                <img src="../images/relations_reflexives_hierarchiques.PNG" alt="relations réflexives hiérarchiques">
                                <p>Cette hiérarchie sera mémorisée comme suit :</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>Code service</th>
                                            <th>Nom service</th>
                                            <th>Responsable du service</th>
                                            <th>Code service supérieur</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>0</td>
                                            <td>Direction générale</td>
                                            <td>Dupuis</td>
                                            <td>-</td>
                                        </tr>
                                        <tr>
                                            <td>1</td>
                                            <td>Juridique</td>
                                            <td>Janssens</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>2</td>
                                            <td>Personnel</td>
                                            <td>Durand</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>Commercial</td>
                                            <td>Carlot</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td>4</td>
                                            <td>Contentieux</td>
                                            <td>Van Camp</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>Belge</td>
                                            <td>André</td>
                                            <td>4</td>
                                        </tr>
                                        <tr>
                                            <td>6</td>
                                            <td>Etranger</td>
                                            <td>Michel</td>
                                            <td>4</td>
                                        </tr>
                                        <tr>
                                            <td>7</td>
                                            <td>UE</td>
                                            <td>Van den Berg</td>
                                            <td>6</td>
                                        </tr>
                                        <tr>
                                            <td>8</td>
                                            <td>Hors UE</td>
                                            <td>Lee</td>
                                            <td>6</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Représentation :</p>
                                <img src="../images/relations_reflexives_hierarchiques_dsd.PNG" alt="DSD des relations réflexives hiérarchiques">
                            </li>
                            <li>
                                <h4 id="relations_reseau">Relations en réseau (réflexives non hiérarchiques) :</h4>
                                <p>C'est le cas typique de structure d'assemblage. Une pièce peut être composée de plusieurs pièces et une même pièce peut être un composant de plusieurs pièces.</p>
                                <p>Représentation :</p>
                                <img src="../images/relations_reseaux.PNG" alt="relations en réseau">
                                <p>Par exemple, une foreuse est composée d'un accumulateur, d'un moteur et d'un interrupteur.</p>
                                <p class="souligne">Pièces :</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>no_piece</th>
                                            <th>nom</th>
                                            <th>description</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>B72</td>
                                            <td>FACC72</td>
                                            <td>Foreuse sur Accus 7.2 V modèle Brico</td>
                                        </tr>
                                        <tr>
                                            <td>P72</td>
                                            <td>PACC72</td>
                                            <td>Foreuse sur Accus 7.2 V modèle professionnel</td>
                                        </tr>
                                        <tr>
                                            <td>B96</td>
                                            <td>FACC96</td>
                                            <td>Foreuse sur Accus 9.6 V modèle Brico</td>
                                        </tr>
                                        <tr>
                                            <td>P96</td>
                                            <td>PACC96</td>
                                            <td>Foreuse sur Accus 9.6 V modèle professionnel</td>
                                        </tr>
                                        <tr>
                                            <td>A72</td>
                                            <td>ACC72</td>
                                            <td>Accus 7.2V</td>
                                        </tr>
                                        <tr>
                                            <td>A96</td>
                                            <td>ACC96</td>
                                            <td>Accus 9.6 V</td>
                                        </tr>
                                        <tr>
                                            <td>M72</td>
                                            <td>MOT72</td>
                                            <td>Moteur 7.2 V</td>
                                        </tr>
                                        <tr>
                                            <td>M96</td>
                                            <td>MOT96</td>
                                            <td>Moteur 9.6 V</td>
                                        </tr>
                                        <tr>
                                            <td>IP</td>
                                            <td>INTPROF</td>
                                            <td>Interrupteur Brico</td>
                                        </tr>
                                        <tr>
                                            <td>IB</td>
                                            <td>INTPROF</td>
                                            <td>Interrupteur Brico</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p class="souligne">Composants :</p>
                                <table class="tableBalises">
                                    <thead>
                                        <tr>
                                            <th>no_piece_composee</th>
                                            <th>no_piece_composante</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>B72</td>
                                            <td>A72</td>
                                        </tr>
                                        <tr>
                                            <td>B72</td>
                                            <td>IB</td>
                                        </tr>
                                        <tr>
                                            <td>B72</td>
                                            <td>M72</td>
                                        </tr>
                                        <tr>
                                            <td>P72</td>
                                            <td>A72</td>
                                        </tr>
                                        <tr>
                                            <td>P72</td>
                                            <td>IP</td>
                                        </tr>
                                        <tr>
                                            <td>P72</td>
                                            <td>M72</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Dans cet exemple, on constate qu'entre le modèle bricolage et professionnel, seul l'interrupteur change.</p>
                            </li>
                            <li>
                                <h4 id="parrainage">Exercice proposé : le parrainage :</h4>
                                <p>On désire mettre en place un système de parrainage des étudiants de 1ère et même de 2ème année par d'autres étudiants plus expérimentés (d'une année supérieure). Un étudiant pourrait demander des explications sur des matières plus difficiles à son parrain.</p>
                                <p>On souhaite mémoriser qui parraine qui.</p>
                                <p><span class="em">Première hypothèse :</span> un étudiant (parrain) pourrait parrainer plusieurs autres étudiants (ses filleuls) mais un filleul n'aurait qu'un seul parain.</p>
                                <p><span class="em">Deuxième hypothèse :</span> un filleul pourrait avoir plusieurs parrains plus ou moins spécialisés suivant les matières en question.</p>
                                <p>Pour chaque hypothèse, construisez une DB (DSD) et écrivez un SELECT SQL.</p>
                                <ol>
                                    <li>Qui affiche pour chaque parrain (matricule et nom) le nombrede ses filleuls.</li>
                                    <li>Qui affiche pour chaque parrain (matricule et nom) le matricule et le nom de ses filleuls.</li>
                                </ol>
                                <p class="souligne">DSD de la première hypothèse :</p>
                                <img src="../images/parrainage_1.PNG" alt="DSD de la première hypothèse du parrainage">
                                <p class="souligne">DSD de la deuxième hypothèse :</p>
                                <img src="../images/parrainage_2.PNG" alt="DSD de la deuxième hypothèse du parrainage">
                            </li>
                        </ol>
                        <h3 id="tables_specialisees">Les tables spécialisées :</h3>
                        <p>Partons d'une table décrivant les articles vendus par une société :</p>
                        <img src="../images/tables_specialisees_1.PNG" alt="DSD n°1 des tables spécialisées">
                        <p>Le champ <span class="em">type_produit</span> de la table <span class="em">produits</span> contient le char '<span class="em">S</span>' pour savon, '<span class="em">D</span>' pour détergent et '<span class="em">H</span>' pour shampoing.</p>
                        <p>Les autres champs de cette table sont remplis selon le type de produits :</p>
                        <ul>
                            <li>S'il s'agit d'un savon, les champs <span class="em">couleur</span>, <span class="em">texture</span> et <span class="em">parfum</span> seront remplis,</li>
                            <li>S'il s'agit d'un shampoing, le champ <span class="em">agent_moussant</span> sera rempli,</li>
                            <li>Enfin, s'il s'agit d'un détergent, le champ <span class="em">agent_detergent</span> sera rempli.</li>
                        </ul>
                        <p>Dans le cas d'un savon par exemple, les champs <span class="em">agent_moussant</span> et <span class="em">agent_detergent</span> resteront vides (<span class="em">NULL</span>). En fait, suivant le type de produit, l'enregistrement devrait avoir une structure différente.</p>
                        <p>Une solution plus claire est de définir 3 tables spécialisées (une par type de produits) en plus de la table générale des produits.</p>
                        <img src="../images/tables_specialisees_2.PNG" alt="DSD n°2 des tables spécialisées">
                        <p>Dans cet exemple, un produit est soit un savon, soit un shampoing, soit un détergent. Nous allons donc créer :</p>
                        <ul>
                            <li>un tuple dans la table <span class="em">produits</span> pour tous les produits (savons, shampoings et détergents) ET</li>
                            <li>
                                <p>un tuple dans la table correspondant au <span class="em">type_produit</span> :</p>
                                <ul>
                                    <li>Si 'S', dans la table <span class="em">savons</span>;</li>
                                    <li>Si 'D', dans la table <span class="em">detergents</span>;</li>
                                    <li>Si 'H' dans la table <span class="em">shampoings</span>.</li>
                                </ul>
                            </li>
                        </ul>
                        <p>La clé primaire des tables spécialisées est la même que la clé primaire de la table générale.</p>
                        <p>Cependant, il peut arriver que des clés primaires différentes existent. C'est ce que nous allons voir dans l'exemple suivant.</p>
                        <p>Au service central d'une université, on décide d'enregistrer toues les membres de l'université dans une seule table <span class="em">personnes</span>, spécialisée en deux tables <span class="em">etudiants</span> et <span class="em">professeurs</span>. Les professeurs sont identifiés par un numéro de matricule tandis que les étudiants sont identifiés par leur numéro d'inscription.</p>
                        <p>Voici deux manières de représenter cette situation :</p>
                        <p class="souligne">Solution 1 :</p>
                        <img src="../images/tables_specialisees_3.PNG" alt="DSD n°3 des tables spécialisées">
                        <p class="souligne">Solution 2 :</p>
                        <img src="../images/tables_specialisees_4.PNG" alt="DSD n°4 des tables spécialisées">
                        <p>Une personne peut être présente dans les deux tables spécialisées. Dans cette université, certains étudiants de doctorat ont déjà des charges académiques et sont donc considérés à la fois comme des étudiants et comme des professeurs.</p>
                        <h3 id="sauvegarde_donnees">La sauvegarde des données :</h3>
                        <p>La <span class="em">sauvegarde</span> est l'opération qui consiste à <span class="em">mettre en sécurité</span> les données contennues dans un sytème informatique. Ce terme est proche de deux notions :</p>
                        <ul>
                            <li><span class="em">l'enregistrement des données</span>, qui est l'opération d'écriture des données sur un item d'enregistrement durable, tel qu'un disque dur, une clé USB, des bandes magnétiques, etc. (<span class="em">back up</span>)</li>
                            <li><span class="em">l'archivage</span>, qui consiste à enregistrer des données sur un support à des fins légales ou historiques.</li>
                        </ul>
                        <ol>
                            <li>
                                <h4 id="backup">Le back up :</h4>
                                <p>Les copies de <span class="em">sûreté</span> sont utiles principalement à deux choses :</p>
                                <ul>
                                    <li>La première et la plus évidente est de permettre de <span class="em">restaurer</span> un système informatique dans un état de fonctionnement à la suite d'un incident (perte d'un support de stockage tel que disque dur, bande magnétique, etc., ou de tout ou partie des données qu'il contient).</li>
                                    <li>La seconde, incluse dans la première mais certainement la plus courante, est de <span class="em">faciliter la restauration</span> d'une partie d'un système informatique (un fichier, un groupe de fichiers, un système d'exploitation, une donnée dans un fichier, etc.) à la suite d'une suppression accidentelle ou à une modification non désirée.</li>
                                </ul>
                                <p>La technique la plus fréquente est la copie des données sur un support indépendant du système initial (serveur distant, bandes magnétiques...).</p>
                                <p>L'opération inverse qui consiste à réutiliser des données sauvegardées s'appelle une <span class="em">restauration</span>.</p>
                            </li>
                            <li>
                                <h4 id="archivage">L'archivage :</h4>
                                <p>L'archivage vise à <span class="em">désengorger</span> des tables de mouvements, souvent volumineuses et rapidement périmées.</p>
                                <p>Pour des raisons légales ou pour répondre à des demandes de statistiques, les données sont conservées plus longtemps. On stocke alors les données dans une DB séparée ou dans un data warehouse (Big data; business intelligence (informatique décisionnelle)).</p>
                            </li>
                        </ol>
                    </article>
                    <article id="partie_3">
                        <h2 id="partie_sql_2">Partie SQL 2ème année :</h2>
                        <h3 id="algebre_relationnelle">L'algèbre relationnelle :</h3>
                        <p>La première façon de manipuler de telles bases de données est d'utiliser un langage algébrique basé sur plusieurs opérateurs. Ci-dessous, sont proposés cinq opérateurs de base, suivi de quatre autres (qui ne sont pas indispensables car ils peuvent s'écrire au moyen des cinq premiers, mais augmentent le confort de manipulation).</p>
                        <h4 id="operateurs_base">Opérateurs de base :</h4>
                        <ol>
                            <li>
                                <h5 id="union">Union :</h5>
                                <p>L'union de deux tables R et S, que l'on notera R &#8746; S, est l'union au sens ensembliste des tuples des deux tables. Pour que le résultat soit encore une table, il faut que R et S comportent le même nombre de colonnes, et que si les colonnes ont des noms d'attributs, ces noms soient identiques et que les colonnes qui se correspondent dans les deux tables aient des domaines (ou au moins compatibles).</p>
                            </li>
                            <li>
                                <h5 id="difference">Différence :</h5>
                                <p>Il s'agit ici de la différence au sens ensembliste de tuples de deux tables. Les mêmes restrictions s'appliquent que pour l'union. On notera R - S ou R \ S.</p>
                            </li>
                            <li>
                                <h5 id="produit_cartesien">Produit cartésien :</h5>
                                <p>Si R est une table comportant r colonnes et S une table comportant s colonnes, leur produit cartésien RxS est une table comportant r+s colonnes héritant leurs noms d'attributs de ceux de R et S, et contenant pour tuples tous les tuples que l'on peut obtenir en juxtaposant un tuple de R et un tuple de S. Si R contient n tuples et que S en contient p, RxS en contiendra nxp. Si des attributs de R et S ont même noms, on les distinguera en mentionnant la table d'origine : R.i, S.i.</p>
                            </li>
                            <li>
                                <h5 id="projection">Projection :</h5>
                                <p>Si i,j,...,k sont des numéros de colonnes ou des noms d'attributs d'une table R, l'opérateur unaire de projection sur i,j,...,k est défini comme suit : la table &#960;<sub>i,j,...,k</sub> (R) est obtenue à partir de R en ne conservant que les colonnes i,j,...,k, et bien sûr en supprimant du résultats les éventuels tuples qui seraient identiques à d'autres.</p>
                            </li>
                            <li>
                                <h5 id="selection">Sélection :</h5>
                                <p>Soit R une table, et F une formule logique constituée :</p>
                                <ul>
                                    <li>de numéros ou noms d'attributs</li>
                                    <li>de constantes</li>
                                    <li>d'opérateurs arithmétiques ou autres s'appliquant aux constantes et aux domaines des attributs</li>
                                    <li>d'opérateurs de relation (=, &lt;, &gt;, etc.)</li>
                                    <li>d'opérateurs logiques : NOT, AND, OR.</li>
                                </ul>
                                <p>Alors l'opérateur de sélection est définies comme suit : la table &#963;<sub>F</sub>(R) est la table comportant les mêmes attributs que R, et contenant les tuples de R qui satisfont à la condition F (c'est-à-dire qui donnent la valeur TRUE à F si on y remplace les nomms d'attributs par les valeurs prises par ces attributs dans le tupke concerné).</p>
                            </li>
                        </ol>
                        <h4 id="operateurs_additionnels">Opérateurs additionnels :</h4>
                        <ol>
                            <li>
                                <h5 id="intersection">Intersection :</h5>
                                <p>L'intersection R &#8745; S est définiede façon similaire à l'union. Rappelons que : R &#8745; S = R - (R - S).</p>
                            </li>
                            <li>
                                <h5 id="quotient">Quotient :</h5>
                                <p>Soient R et S deux tables contenant respectivement r et s colonnes, avec s &lt; r. Supposons en outre que les noms d'attributs de S forment un sous-ensemble de ceux de R et queS ne soit pas vide. On définira le quotient R : S comme étant la table comportant r-s attributs (ayant pour noms ceux de la table R qui sont absents de la table S), et contenant comme tuples t ceux pour lesquels, pour tout tuple u de S, la combinaison "tu" soit dans R.</p>
                                <p>On peut définir cet opérateur à partir des cinq premiers de la façon suivante : si i,j,...,k sont les attributs présents dans R mais absents de S, on a :</p>
                                <p>R : S = &#960;<sub>i,j,...,k</sub> (R) - &#960;<sub>i,j,...,k</sub> (R) x S) - R).</p>
                            </li>
                            <li>
                                <h5 id="jointure">Jointure :</h5>
                                <p>Si i est un attribut de R et j un attribut de S, la jointure R JOIN<sub>i=j</sub> S est la table obtenue en prenant  le produit cartésien de R et S, dont ne conserve que les tuples pour lesquels les valeurs de l'attribut R.i et de l'attribut S.j sont égales. On peut de même définir des jointures basées sur d'autres opérateurs de relation (par exemple : R JOIN<sub>i&lt;j</sub> S) ou sur des conditions combinées (par exemple : R JOIN<sub>(i=j and k&#8800;l)</sub> S).</p>
                                <p>Le cas où l'opérateur d'égalité "=" est le seul présent est appelé "équijointure".</p>
                            </li>
                            <li>
                                <h5 id="jointure_naturelle">Jointure naturelle :</h5>
                                <p>La jointure naturelle de deux tables R et S comportant un ou plusieurs attributs identiqes (mêmes noms et mêmes domaines) est la table R JOIN S obtenue en effectuant tout d'abord une équijointure selon les attributs provenant de S qui sont des duplicatas d'attributs provenant de R.</p>
                            </li>
                        </ol>
                        <p class="souligne">Exemples :</p>
                        <table class="tableBalises">
                            <caption>R</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Destination</th>
                                    <th>Code-dépl</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                    <td>325</td>
                                </tr>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                    <td>360</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>322</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>312</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Oslo</td>
                                    <td>319</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>D</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dutoit</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>S</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Destination</th>
                                    <th>Code-dépl</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                    <td>325</td>
                                </tr>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                    <td>588</td>
                                </tr>
                                <tr>
                                    <td>Janssens</td>
                                    <td>Prague</td>
                                    <td>322</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>T</caption>
                            <thead>
                               <tr>
                                <th>Nom</th>
                                <th>Rembours</th>
                               </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>Janssens</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>Albrecht</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Fanuel</td>
                                    <td>3</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>R&#8746;S</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Destination</th>
                                    <th>Code-dépl</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                    <td>325</td>
                                </tr>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                    <td>360</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>322</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>312</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Oslo</td>
                                    <td>319</td>
                                </tr>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                    <td>588</td>
                                </tr>
                                <tr>
                                    <td>Janssens</td>
                                    <td>Prague</td>
                                    <td>322</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>R-S</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Destination</th>
                                    <th>Code-dépl</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                    <td>360</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>322</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>312</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Oslo</td>
                                    <td>319</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>R x T</caption>
                            <thead>
                                <tr>
                                    <th>R.Nom</th>
                                    <th>Destination</th>
                                    <th>Code-dépl</th>
                                    <th>T.Nom</th>
                                    <th>Rembours</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>Dufour</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>Dutoit</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>Janssens</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>Albrecht</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>Fanuel</td>
                                    <td>3</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                    <td>325</td>
                                    <td>Dufour</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>...</td>
                                    <td>...</td>
                                    <td>...</td>
                                    <td>...</td>
                                    <td>...</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Oslo</td>
                                    <td>319</td>
                                    <td>Fanuel</td>
                                    <td>3</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>R JOIN T</caption>
                            <thead>
                                <th>Nom</th>
                                <th>Destination</th>
                                <th>Code-dépl</th>
                                <th>Rembours</th>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                    <td>321</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                    <td>325</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>322</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                    <td>312</td>
                                    <td>4</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Oslo</td>
                                    <td>319</td>
                                    <td>4</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>&#960;<sub>Nom,Destination</sub>(R)</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Destination</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Paris</td>
                                </tr>
                                <tr>
                                    <td>Dufour</td>
                                    <td>Milan</td>
                                </tr>
                                <tr>
                                    <td>Durand</td>
                                    <td>Paris</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Paris</td>
                                </tr>
                                <tr>
                                    <td>Dutoit</td>
                                    <td>Oslo</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="tableBalises">
                            <caption>&#963;<sub>Rembours&lt;3</sub>(T)</caption>
                            <thead>
                                <tr>
                                    <th>Nom</th>
                                    <th>Rembours</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Dufour</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>Janssens</td>
                                    <td>0</td>
                                </tr>
                                <tr>
                                    <td>Albrecht</td>
                                    <td>2</td>
                                </tr>
                            </tbody>
                        </table>
                        <h4 id="analyse_relationnelle">L'analyse relationnelle :</h4>
                        <p>Les notations ensemblistes permettent d'atteindre les mêmes résultats. Ainsi, pour les exemples qui précèdent, on pourrait utiliser les notations équivalentes suivantes :</p>
                        <p>R &#8746; S = { t | t &#8714; R ou t &#8714; S }</p>
                        <p>R - S = { t | t &#8714; R et t &#8713; S }</p>
                        <p>R x T = { (R.Nom, Destination, Code-dépl, T.Nom, Rembours) | (R.Nom, Destination, Code-dépl) &#8714; R et (Nom, Rembours) &#8714; T }</p>
                        <p>R JOIN T = { (Nom, Destination, Code-dépl, Rembours) | (Nom, Destination, Code-dépl) &#8714; R et (Nom, Rembours) &#8714; T }</p>
                        <p>ou encore</p>
                        <p>R JOIN T = { (Nom, Destination, Code-dépl, Rembours) | (R.Nom, Destination, Code-dépl) &#8714; R et (T.Nom, Rembours) &#8714; T et R.Nom = T.Nom;</p>
                        <p>&#960;<sub>Nom,Destination</sub>(R) = { (Nom, Destination) | &#8707; Code-dépl : (Nom,Destination,Code-dépl) &#8714; R }</p>
                        <p>&#963;<sub>Rembours&lt;3</sub>(T) = { (Nom, Rembours) &#8714; T | Rembours &lt; 3 }</p>
                        <p>Ces notations ensemblistes ont directement inspiré le langage SQL, comme le montrent les exemples suivants :</p>
                        <p>R JOIN T s'obtient par l'instruction</p>
<pre class="taille60"><code>SELECT R.Nom, Destination, Code-dépl, Rembours
FROM R, T
WHERE R.Nom = T.nom;</code></pre>
                        <p>&#963<sub>Rembours&lt;3</sub>(T) s'obtient par l'instruction</p>
<pre class="taille60"><code>SELECT Nom, Rembours
FROM T
WHERE Rembours &lt; 3;</code></pre>
                        <h3 id="coalesce">Coalesce :</h3>
                        <p>Dans une requête, il est possible d'utiliser l'expression <span class="html">COALESCE</span> pour remplacer une valeur NULL par une valeur conventionnelle (par exemple la valeur 0 ou la chaîne vide).La particularité de cette fonction est d'accepter autant de paramètres que l'on veut. Elle renvoie la première expression évaluable (donc différente de NULL) dans l'ordre d'écriture (de gauche à droite).</p>
                        <p>Sa syntaxe est la suivante :</p>
<pre class="taille60"><code>COALESCE (expression1 [, expression2 [, expression3 [ ... ] ] ])</code></pre>
                        <p class="souligne">Exemple :</p>
<pre class="taille60"><code>SELECT au_id, au_fname, au_lname, COALESCE (country, state, 'état et pays inconnus')
FROM authors;</code></pre>
                        <p>Pour chaque auteur, cette requête affichera quatre champs. Les trois premiers champs seront l'id, le prénom et le nom de l'auteur. Si son pays est différent de NULL, le quatrième champ sera son pays. Si son pays est NULL mais que son état est différent de NULL, alors le quatrième champ sera son état. Si son pays et son état sont NULL, alors le quatrième champ sera la chaîne de caractères 'état et pays inconnus'.</p>
                        <h3 id="union_intersection_difference">Union, Intersection, Différence :</h3>
<pre class="taille60"><code>SELECT [ ALL | DISTINCT ]
    * | expression [ [ AS ] nom_d_affichage ] [, ...]
    [ FROM éléments_from [, ...] ]
    [ WHERE condition ]
    [ GROUP BY expression [, ...] ]
    [ HAVING condition [, ...] ]
    <span class="em">[ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]</span>
    [ ORDER BY order_expression [ ASC | DESC ] [, ...] ]</code></pre>
                        <ul>
                            <li>
                                <p>L'opérateur <span class="html">UNION</span> calcule l'union ensembliste des lignes renvoyées par les instructions <span class="em">SELECT</span> impliquées. Une ligne est dans l'union de deux ensembles de résultats si elle apparaît dans au moins un des ensembles. Les deux instructions <span class="em">SELECT</span> qui représentent les opérandes directes de l'UNION doivent produire le même nombre de colonnes et les colonnes correspondantes doivent être d'un type de données compatible.</p>
                                <p>Sauf lorsque l'option <span class="html">ALL</span> est spécifiée, il n'y a pas de doublons dans le résultat de <span class="em">UNION</span> <span class="em">ALL</span> empêche l'élimination des lignes dupliquées. <span class="em">UNION ALL</span> est donc significativement plus rapide qu'<span class="em">UNION</span>, et sera préféré.</p>
                                <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">UNION</span>, ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses impose un comportement différent.</p>
                            </li>
                            <li>
                                <p>L'opérateur <span class="html">INTERSECT</span> calcule l'intersection des lignes renvoyées par les deux instructions <span class="em">SELECT</span> impliquées. Une ligne est dans l'intersection des deux ensembles de résultats si elle apparaît dans chacun des des ensembles.</p>
                                <p>Le résultat d'<span class="em">INTERSECT</span> ne contient aucune ligne dupliquée sauf si l'option <span class="html">ALL</span> est spécifiée. Dans ce cas, une ligne dupliquée m fois dans la table gauche et n fois dans la table droite apparaît <span class="em">min(m, n)</span> fois dans l'ensemble de résultats.</p>
                                <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">INTERSECT</span>, ils sont évalués de gauche à droite, sauf si l'utilisation de parenthèses impose un comportement différent. <span class="em">INTERSECT</span> a une priorité supérieur à celle d'<span class="em">UNION</span>. C'est-à-dire que <span class="em">A UNION B INTERSECT C</span> est lu comme <span class="em">A UNION (B INTERSECT C)</span>.</p>
                            </li>
                            <li>
                                <p>L'opérateur <span class="html">EXCEPT</span> calcule l'ensemble des lignes qui appartiennent au résultat de l'instruction <span class="em">SELECT</span> de hauche pas à celui de droite.</p>
                                <p>Le résultat d'<span class="em">EXCEPT</span> ne contient aucune ligne dupliquée sauf si l'option <span class="html">ALL</span> est spécifiée. Dans ce cas, une ligne dupliquée m fois dans la table gauche et n fois dans la table droite apparaît <span class="em">max(m-n, 0)</span> foi dans l'ensemble de résultats.</p>
                                <p>Si une instruction <span class="em">SELECT</span> contient plusieurs opérateurs <span class="em">EXCEPT</span>n ils sont évalués de gauche à droite, sauf si l'utilisation de paenthèses impose un comportement différent. <span class="em">EXCEPT</span> a la même priorité qu'<span class="em">UNION</span>.</p>
                            </li>
                        </ul>
                        <p class="souligne">Exemples :</p>
                        <ol>
                            <li>
                                <p>Quelles sont les villes où l'on peut trouver un auteur et/ou un éditeur ?</p>
<pre class="taille60"><code>(SELECT DISTINCT city FROM authors) UNION (SELECT DISTINCT city FROM publishers);</code></pre>
                            </li>
                            <li>
                                <p>Pour chaque éditeur, donnez son nom et le nombre de livres de psychologie qu'il a édité. Classez le tout par ordre décroissant de nombre de livres.</p>
<pre class="taille60"><code>(
    SELECT P.pub_name, COUNT (title_id)
    FROM publishers P, titles T
    WHERE p.pub_id = t.pub_id
    AND type = 'psychology'
    GROUP BY P.pub_name
) UNION (
    SELECT pub_name, 0
    FROM publishers
    WHERE pub_id NOT IN (
        SELECT pub_id
        FROM titles
        WHERE type = 'psychology'
    )
)
ORDER BY DESC;</code></pre>
                            </li>
                        </ol>
                        <h3 id="outer_join">OUTER JOIN (Jointures externes) :</h3>
<pre class="taille60"><code>SELECT [ ALL | DISTINCT ]
    * | expression [ [ AS ] nom_d_affichage ] [, ...]
    [ FROM éléments_from [, ...] ]
    [ WHERE condition ]
    [ GROUP BY expression [, ...] ]
    [ HAVING condition [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]
    [ ORDER BY order_expression [ ASC | DESC ] [, ...] ]</code></pre>
                        <ul>
                            <li>
                                <p>avec <span class="em">éléments_from</span> qui peut être :</p>
<pre class="taille60"><code>nom_table [ * ] [ [ AS ] alias [ ( alias_colonne [, ...] ) ] ]
    [,éléments_from]
    <span class="em">éléments_from [ NATURAL ] type_jointure éléments_from [ ON condition_jointure
    | USING ( colonne_jointure [, ...] ) ]</span></code></pre>
                            </li>
                            <li>
                                <p>avec <span class="em">type_jointure</span> qui peut être :</p>
                                <ul>
                                    <li><span class="html">[ INNER ] JOIN</span> : équivalent à la jointure habituelle où la condition de jointure est exprimée dans la partie <span class="em">WHERE</span> du <span class="em">SELECT</span>.</li>
                                    <li><span class="html">LEFT [ OUTER ] JOIN</span> : tous les tuples de la table de gauche font partie du résultat; ils sont joints à la table de droite quand c'est possible de par la condition de jointure. Sinon les colonnes correspondantes à la table de droite sont remplies de NULL.</li>
                                    <li><span class="html">RIGHT [ OUTER ] JOIN</span> : identique à <span class="em">LEFT [ OUTER ] JOIN</span> mais en inversant les tables de gauche et de droite.</li>
                                    <li><span class="html">FULL [ OUTER ] JOIN</span> : tous les tuples de la table de gauche et de droite font partie du résultat, joints quand c'est possible sinon les colonnes manquanes sont remplies de NULL.</li>
                                </ul>
                                <p>Une condition de jointure doit être choisie entre :</p>
                                <ul>
                                    <li><span class="html">ON condition_jointure</span> permet d'exprimer une condition de jointure sous un fore similaire à la condition du <span class="em">WHERE</span>.</li>
                                    <li><span class="html">USING ( a, b, ... )</span> est un raccourci pour <span class="em">ON table_gauche.a = table_droite.a AND table_gauche.b = table_droute.b</span>.</li>
                                    <li><span class="html">NATURAL</span> est un raccourci pour une liste <span class="em">USING</span> qui mentionne toutes les colonnes de même nom dans les deux tables.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3 id="normalisation">Normalisation :</h3>
                        <p>Maintenant que l'on est capable de créer une table, il faut décider où placer les données. Il faut donc trouver une combinaison de tables possédant des relations entre elles et permettant d'exploiter les données. Ceci s'appelle un schéma.</p>
                        <p>Pour tout jeu de données, il existe une multiyude de schémas possibles permettant de les organiser. Cependant, de part la nature même du modèle relationnel, certains schémas s'avèrent meilleurs que d'autres. Par exemple, certains schémas évitent de dupliquer des données, enlevant ainsi un risque d'incohérence (la même donnée qui devrait être dupliquée à l'identique finit par avoir des valeurs différentes). On dit qu'un schéma est normalisé à une certaine forme lorsqu'il respecte les critères de cette forme. La normalisation est l'acte consistant à transformer un schéma pour atteindre une forme normalisée. Dans le cadre de ce cours, nous verrons uniquement les trois premiers niveaux.</p>
                        <h4 id="1FN">1FN - première forme normale :</h4>
                        <p>Relation dont tous les attributs :</p>
                        <ul>
                            <li>contiennent une valeur atomique (les valeurs ne peuvent pas être divisées en plusieurs sous-valeurs dépendant également individuellement de la clé primaire).</li>
                            <li>contiennent des valeurs non répétitives (le cas contraire consiste à mettre une liste dans un seul attribut).</li>
                            <li>sont constants dans le temps (utiliser par exemple la date de naissance plutôt que l'âge).</li>
                        </ul>
                        <p>Le non respect de deux premières conditions de la 1FN rend la recherche parmi les données plus lente parce qu'il faut analyser le contenu des attributs. La troisième condition quant à elle évite qu'on doive régulièrement mettre à jour les données.</p>
                        <h4 id="2FN">2FN - deuxième forme normale :</h4>
                        <p>Respecte la deuxième forme normale, la relation respectant la première forme normale et dont :</p>
                        <ul>
                            <li>Tous les attributs non-clés sont totalement dépendants fonctionnellement de la totalité de la clé primaire.</li>
                        </ul>
                        <p>Le non respect de la 2FN entraîne une redondance des données qui encombrent alors inutilement la mémoire et l'espace disque.</p>
                        <h4 id="3FN">3FN - troisième forme normale :</h4>
                        <p>Respecte la troisième forme normale, la relation respectant la seconde forme normale et dont :</p>
                        <ul>
                            <li>Tout attribut n'appartenant pas à une clé ne dépend pas d'un attribut non clé.</li>
                        </ul>
                        <p>Le non respect de la 3FN peut également entraîner une redondance des données.</p>
                        <h3 id="denormalisation">Dénormalisation :</h3>
                        <p>La normalisation permet de garantir la cohérence des données et permet d'éviter des problèmes inutiles. On cherchera donc en général à normaliser son schéma complètement. Il peut cependant y avoir des exceptions pour lesquelles on dénormalisera le schéma :</p>
                        <ul>
                            <li>On pourrait avoir dans un schéma unique des tables appartenant logiquement à des schémas séparés. L'exemple typique est la table d'archivage ou d'audit qui duplique l'information se trouvant dans les autres tables en les mettant complètement à plat (un tuple contient toute l'information sans devoir effectuer une jointure avec une autre table). Cette table n'est évidemment pas du tout normalisée de par sa nature même.</li>
                            <li>La normalisation force à multiplier les tables, ce qui impose une pénalité à l'exécution. Pour résoudre les problèmes de performance <span class="em">uniquement</span>, on accepte d'enlever la normalisation. Cependant, il existe quand même une technique permettant de s'assurer de la consistance des données, confer <span class="em">TRIGGER</span> plus loin.</li>
                        </ul>
                        <p class="souligne">Exemple :</p>
                        <p>Dans la base de données pub2, il y a un champ total_sales dans la table titles : ce champ ne dépend pas uniquement de la clé primaire de titles, il dépend aussi directement du contenu de la table salesdetail. Cependant, c'est une information dont on a fréquemment besoin dans le cadre de l'application utilisant pubs2, et pour garder de bonnes performances ce champ est dénormalisé. Comme il est dénormalisé, il y a un risque qu'il ne soit pas synchronisé correctement par rapport à la valeur réelle qu'il doit prendre.</p>
                        <h3 id="drop_table">DROP TABLE :</h3>
<pre class="taille60"><code>DROP TABLE nom;</code></pre>
                        <h3 id="alter_table">ALTER TABLE :</h3>
<pre class="taille60"><code>ALTER TABLE nom [ * ]
    action [, ... ]
ALTER TABLE nom [ * ]
    RENAME [ COLUMN ] colonne TO nouvelle_colonne
ALTER TABLE nom
    RENAME TO nouveau_nom</code></pre>
                        <ul>
                            <li>
                                <p><span class="em">action</span> peut être :</p>
<pre class="taille60"><code>ADD [ COLUMN ] colonne type [ contrainte_colonne [ ... ] ]
DROP [ COLUMN ] colonne
ALTER [ COLUMN ] colonne [ SET DATA ] TYPE type [ USING expression ]
ALTER [ COLUMN ] colonne SET DEFAULT expression
ALTER [ COLUMN ] colonne DROP DEFAULT
ALTER [ COLUMN ] colonne { SET | DROP } NOT NULL
ADD contrainte_table
DROP CONSTRAINT nom_contrainte</code></pre>
                            </li>
                        </ul>
                        <p class="souligne">Exemples :</p>
                        <ol>
                            <li>
                                <p>Ajouter une colonne de type VARCHAR à une table :</p>
<pre class="taille60"><code>ALTER TABLE publishers
ADD COLUMN continent VARCHAR (30);</code></pre>
                            </li>
                            <li>
                                <p>Changer le type de la colonne :</p>
<pre class="taille60"><code>ALTER TABLE publishers
ALTER COLUMN continent
TYPE VARCHAR (20);</code></pre>
                            </li>
                            <li>
                                <p>Supprimer la colonne :</p>
<pre class="taille60"><code>ALTER TABLE publishers
DROP COLUMN continent;</code></pre>
                            </li>
                        </ol>
                        <h3 id="sequences">Séquences :</h3>
<pre class="taille60"><code>CREATE SEQUENCE nom [ INCREMENT [ BY ] incrément ]
    [ MINVALUE valeurmin | NO MINVALUE ]
    [ MAXVALUE valeurmax | NO MAXVALUE ]
    [ START [ WITH ] début ]</code></pre>
                        <ul>
                            <li><span class="em">CREATE SEQUENCE</span> crée un nouveau générateur de séquence de nombres. Cela implique la création et l'initialisation d'une nouvelle table à une seule ligne nommée <span class="em">nom</span>.</li>
                        </ul>
                        <p>La séquence est surtout utile pour laisser la base de données générer elle-même des identifiants uniques pour les tuples. Pour réaliser cela, il faut créer une séquence d'un certain nom (par exemple <span class="em">'ABC'</span>) et dire que la valeur par défaut de la colonne est <span class="em">nextval ('ABC')</span>.</p>
                        <p>En PostgreSQL, on utilisera donc une séquence pour générer des clefs primaires automatiquement. D'autres bases de données utilisent d'autres approches pour générer des clefs primires automatiquement. On parle parfois d'<span class="em">AUTO-INCREMENT</span> ou d'<span class="em">IDENTITY</span>. Dans ce cas, lors de l'insertion d'un nouveau tuple, on ne spécifie pas de valeur pour la clef primaire. Par contre, on pourra vouloir directement récupérer sa valeur via la partie <span class="em">RETURNING</span> de l'<span class="em">INSERT</span>.</p>
                        <h3 id="serial">Serial :</h3>
                        <p>Une séquence est implicitement créée lorsque l'on déclare la création d'une table avec une colonne de type <span class="html">SERIAL</span>. La colonne se transformera en type INTEGER mais sa valeur par défaut suivra l'ordre d'une séquence.</p>
                        <p>Exemple :</p>
<pre class="taille60"><code>CREATE TABLE nom_de_table (
    nom_de_colonne SERIAL
);</code></pre>
                        <p>Cette dernière instruction est équivalente à :</p>
<pre class="taille60"><code>CREATE SEQUENCE nom_de_table_nom_de_colonne_seq;
CREATE TABLE nom_de_table (
    nom_de_colonne integer DEFAULT nextval('nom_de_table_nom_de_colonne_seq') NOT NULL
);</code></pre>
                        <p>Dans la plupart des cas, vous voudrez aussi aujouter une contrainte <span class="em">PRIMARY KEY</span> pour préciser que cet attribut est la clé primaire, mais ce n'est pas automatique.</p>
                        <h3 id="gestion_base_donnees">Gestion d'une base de données :</h3>
                        <p>À ce stade, nous sommes capables de créer les tables d'une base de données, d'y mettre des données et de l'interroger. Cela ne couvre cependant par tous les besoins d'une base de données en situation réelle. Dans la suite, on va aborder des besoins fréquents.</p>
                        <ol type="a">
                            <li>
                                <h4 id="sql_procedural">SQL Procédural :</h4>
                                <p>Au-delà de fournir des instructions SQL manipulant le schéma et les tuples d'une base de données, on peut aussi vouloir donner plus d'intelligence au serveur.</p>
                                <ul>
                                    <li>Comme le serveur est le dernier intervenant avant le stockage physique des données, c'est un bon candidat pour valider la cohérence des données avant d'écrire n'importe quoi. Ceci est d'ailleurs déjà l'intention des contraintes d'intégrité. Mais au-delà de ces contraintes, il existera toujours des cas particuliers qu'elles ne peuvent pas valider. Par exemple, on pourrait vouloir vérifier qu'un numéro de carte de banque respecte la validation numérique qu'elle est sensée avoir (les deux derniers chiffres sont le modulo 97 du restant).</li>
                                    <li>Le serveur est aussi un bon candidat pour gérer automatiquement la cohérence des données dénormalisées. Il pourra s'assurer que ces données seront mises à jour correctement automatiquement dès que nécessaire. Par exemple, dans pubs2, le champ total_sales de la table titles correspond à un calcul sur les ventes de ce livre. On pourra configurer le serveur pour effectuer la mise à jour de ce champ dès qu'une nouvelle vente est insérée.</li>
                                    <li>On pourra aussi vouloir abstraire de la complexité sous-jacente des données en fournissant des fonctions de haut niveau. Par exemple, à la place de laisser un client manipuler différentes tables pour réaliser une opération complexe, le serveur fournira une fonction qui se charge de réaliser l'intégralité de la tâche. Si le schéma de la base de données change, c'est uniquement les fonctions du serveur qui devront être mises à jour, le client pourra rester inchangé.</li>
                                </ul>
                                <p>Il faut donc un langage de programmation complet (au sens de Turing : <a href="http://fr.wikipedia.org/wiki/Turing-complet" target="_blank">http://fr.wikipedia.org/wiki/Turing-complet</a>) pour réaliser toute cette intelligence. Les systèmes de base de données modernes (dont fait partie PostgreSQL) permettent même de choisir le langage de programmation que l'on soihaite. Historiquement, on utilisait des langages procéduraux qui sont des extensions du SQL de base. Comme ces langages datent des années 70, les concepts présents dans les langages modernes n'en font pas partie. En particulier, il n'y a pas de notion d'objets. Dans le cadre de cours, nous utiliserons PL/pgSQL. Cette section introduit brièvement ce langage, veuillez-cous référer à la documentation en ligne de PostgreSQL pour plus de détails (<a href="http://docs.postgresqlfr.org/" target="_blank">http://docs.postgresqlfr.org/</a>).</p>
                                <ol type="i">
                                    <li>
                                        <h5 id="create_function">CREATE FUNCTION : </h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
    corpsFonction
$$ LANGUAGE plpgsql;</code></pre>
                                        <p>Définit une fonction qui prend X paramètres qui sont de type <span class="em">type1, type2, ..., typeX</span> et qui retourne une valeur de type <span class="em">typeOut</span>. <span class="em">corpsFonction</span> contient la définition de la fonction, voir ci-dessous. Une fonction ainsi créée fait partie intégrante de la base de données, c'est pourquoi on l'appelle parfois "procédure stockée". La commande <span class="html">DROP FUNCTION nomFonction</span> permet d'effacer la fonction.</p>
                                        <p>Attention, les délimitateurs <span class="html">$$</span> et l'instruction <span class="html">LANGUAGE plpgsql</span> font partie intégrante de la définition de la fonction.</p>
                                        <p>Une fois définie, une fonction se comporte comme une expression. Ainsi, on utilisera la commande <span class="em">SELECT nomFonction (param1, param2, ..., paramX)</span> pour afficher le résultat de son exécution.</p>
                                    </li>
                                    <li>
                                        <h5 id="declare">DECLARE :</h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
<span class="em">DECLARE
    nomParam1 ALIAS FOR $1 ;
    nomParam2 ALIAS FOR $2 ;
    ...
    nomParamX ALIAS FOR $X ;
    nomVar1 typeVar1;
    nomVar2 typeVar2;
    ...
    nomVarY typeVarY;
BEGIN
    corpsDeclare ;
END ;</span>
$$ LANGUAGE plpgsql;</code></pre>
                                        <p><span class="html">DECLARE</span> définit les variables internes à la fonction. <span class="html">ALIAS FOR</span> permet de donner un nom explicite a un paramètre particulier. Pour des variables locales, il faut d'abord donner leur nom suivi de leur type.</p>
                                    </li>
                                    <li>
                                        <h5 id="affectation">Affectation :</h5>
<pre class="taille60"><code class="em">variable := expression;</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="commentaire">Commentaire :</h5>
<pre class="taille60"><code>-- tout ce qui suit -- est ignoré jusqu'à la fin de la ligne</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="structures_controle">Structures de contrôle :</h5>
<pre class="taille60"><code class="em">RETURN expression;</code></pre>
                                        <p>Termine l'exécution de la fonction en renvoyant la valeur calculée par expression.</p>
<pre class="taille60"><code class="em">IF ... THEN ... END IF ;
IF ... THEN ... ELSE ... END IF ;
IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF ;
FOR record IN instructionSelect LOOP ... END LOOP ;</code></pre>
                                        <p><span class="em">record</span> doit être une variable de type <span class="em">RECORD</span>. L'instruction <span class="html">FOR</span> fera un parcours successif des tuples retournées par l'instruction <span class="em">SELECT</span>. On pourra accéder aux différents champs du tuple en cours par <span class="em">record.nomChamp</span>.</p>
                                        <p class="souligne">Exemple :</p>
<pre class="taille60"><code>CREATE FUNCTION compteSalesDetailQty() RETURNS INTEGER AS $$
DECLARE
    i integer := 0;
    record RECORD;
BEGIN
    FOR record IN SELECT * FROM Salesdetail LOOP
        i := i + record.qty;
    END LOOP;
    RETURN i;
END;
$$ LANGUAGE plpgsql;

SELECT compteSalesDetailQty();</code></pre>
                                        <p>Ceci est équivalent à :</p>
<pre class="taille60"><code>SELECT SUM (qty) FROM Salesdetail;</code></pre>
                                        <p class="em"><span class="souligne">Remarque importante :</span> il n'y a aucune valeur ajoutée à implémenter soi-même ce qui devrait en fait être une requête SQL. Le code ne sera jamais aussi performant que la requête équivalente. Cela prend toujours plus de temps d'écrire une implémentation plutôt que d'écrire la requête, et le risque d'erreur est olus élevé. Dans le cadre de ce cours, ceci est donc considéré comme une faute et sanctionné comme tel.</p>
                                    </li>
                                    <li>
                                        <h5 id="exceptions">Exceptions :</h5>
<pre class="taille60"><code>CREATE FUNCTION nomFonction(type1, type2,..., typeX) RETURNS typeOut AS $$
DECLARE
    ...
BEGIN
    corpsDeclare ;
<span class="em">EXCEPTION
WHEN condition [ OR condition ... ] THEN
    instructions_gestion_erreurs
[ WHEN condition [ OR condition ... ] THEN
    instructions_gestion_erreurs
... ]</span>
END ;</code></pre>
                                        <p>Si une exception est levée pendant l'exécution de <span class="em">corpsDeclare</span>, la partie <span class="html">EXCEPTION</span> l'attrapera. Pour lever une exception manuellement, il faut utiliser l'instruction <span class="html">RAISE EXCEPTION nom_exception</span> (confer la documentation de PostgreSQL pour la liste des <span class="em">nom_exception</span> possibles et leur signification).</p>
                                        <p class="souligne">Exemple :</p>
<pre class="taille60"><code>BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN -- ignore l'erreur
END;</code></pre>
                                    </li>
                                    <li>
                                        <h5>Exemple :</h5>
                                        <p>Écrire une fonction qui effectue une vente, en créant tous les tuples nécessaires dans toutes les tables.</p>
<pre class="taille60"><code>CREATE FUNCTION sell (VARCHAR (6), CHARACTER (4), VARCHAR (20), SMALLINT)
    RETURNS BOOLEAN AS $$
DECLARE
    v_title_id ALIAS FOR $1;
    v_stor_id ALIAS FOR $2;
    v_ord_num ALIAS FOR $3;
    v_qty ALIAS FOR $4;
    price INTEGER;
BEGIN
    SELECT price FROM titles WHERE title_id = v_title_id INTO price;
    IF price IS NULL THEN
        RETURN false;
    ELSE
        INSERT INTO sales VALUES (v_stor_id, v_ord_num);
        INSERT INTO salesdetail VALUES (v_stor_id, v_ord_num, v_title_id, v_qty),
        UPDATE titles
        SET total_sales = ((SELECT total_sales
                                            FROM titles WHERE title_id = v_title_id)
                                        + v_qty)
        WHERE title_id = v_title_id;
        RETURN true;
    END IF;
END;
$$ LANGUAGE plpgsql;</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="procedure_stockee_renvoyant_tableau">Procédure stockée renvoyant un tableau :</h5>
                                        <p>Une procédure stockée peut renvoyer un tableau. Elle s'utilise alors comme une table dans la commande SELECT :</p>
<pre class="taille60"><code>CREATE OR REPLACE FUNCTION listeAuthorsLivres () RETURNS <span class="em">SETOF RECORD</span> AS $$
DECLARE
    sep VARCHAR;
    texte VARCHAR;
    sortie RECORD;
    author RECORD;
    title RECORD;
BEGIN
    FOR author IN SELECT * FROM authors LOOP
        texte := '';
        sep := '';
        FOR title IN SELECT * FROM titles t, titleauthor ta WHERE t.title_id = ta.title_id AND ta.au_id = author.au_id LOOP
            texte := texte || sep || title.title;
            sep := ', ';
        END LOOP;
        <span class="em">SELECT author.au_fname, author.au_lname, texte INTO sortie;
        RETURN NEXT sortie;</span>
    END LOOP;
    RETURN;
END;
$$ LANGUAGE 'plpgsql';</code></pre>
                                        <p>Notez le type de retour <span class="html">:SETOF</span> signifie plusieurs lignes tandis que <span class="html">RECORD</span> signifie plusieurs colonnes. L'affectation à une variable de type <span class="em">RECORD</span> se fait par la commande <span class="em">SELECT valeur1, ... valeurX INTO record</span>. L'ajout d'une ligne en  retour de l'appel de la procédure stockée se fait par la commande <span class="html">RETURN NEXT</span>. La commande <span class="html">RETURN</span> simple se contenant alors de terminer l'exécution de la procédure stockée. L'appel de la procédure ci-dessous se fait par un <span class="em">SELECT</span>, mais il faut préciser la structure des colonnes ainsi que leurs noms :</p>
<pre class="taille60"><code>SELECT * FROM listeAuthorsLivres() t (fname VARCHAR (20), lname VARCHAR (40), title VARCHAR);</code></pre>
                                        <p>Comme il n'est pas très pratique d'embarquer la définition des colonnes dans le <span class="em">SELECT</span>, il est possible d'utiliser un type personnaisé pour que ceci se fasse au niveau de la procédure stockée. Dans ce cas, l'appel à la procédure stcokée devient identique au <span class="em">SELECT</span> habituel.</p>
<pre class="taille60"><code>CREATE TYPE <span class="em">listesAuthorsLivresReturn</span> AS (fname VARCHAR (20), lname VARCHAR (40), titles VARCHAR);

CREATE OR REPLACE FUNCTION listeAuthors() RETURNS SETOF <span class="em">listesAuthorsLivresReturn</span> AS $$
DECLARE
    sep VARCHAR;
    texte VARCHAR;
    sortie RECORD;
    author RECORD;
    title RECORD;
BEGIN
    FOR author IN SELECT * FROM authors LOOP
        texte := '';
        sep := '';
        FOR title IN SELECT * FROM titles t, titleauthor ta WHERE t.title_id = ta.title_id AND ta.au_id = author.au_id LOOP
            texte := texte || sep || title.title;
            sep := ', ';
        END LOOP;
        SELECT author.au_fname, author.au_lname, texte INTO sortie;
        RETURN NEXT sortie;
    END LOOP;
    RETURN;
END;
$$ LANGUAGE 'plpgsql';

SELECT * FROM listeAuthorsLivres();</code></pre>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="automatisation_trigger">Automatisation : TRIGGER :</h4>
                                <p>Revenons à la problématique de la dénormalisation. Pour fixer les idées, nous regardons le problème particulier du champ total_sales de la table titles qui est en fait la somme de toutes les ventes de ce livre. Ce champ n'est pas en 3ème forme normale" : il dépend en effet d'autre chose qu'uniquement sa clé primaire puisqu'il dépend du contenu de la table Salesdetail.</p>
                                <p>Sa présence est justifiée dans la base de données pour des raisons de performance : si cette information est fréquemment demandée, il sera beaucoup plus rapide qu'il soit précalculée dans la bae de données plutôt que de devoir refaire ce calcul à chaque fois.</p>
                                <p>Mais il y a donc un risque de désynchronisation dès qu'il se passe quelque chose avec une vente de ce livre (ajout, suppression ou modification). Les bases de données offrent un mécanisme pour être sûr de garder cette synchronisation : les triggers. Un trigger est placé sur une table pour réagir en cas d'ajout, de suppression ou de modification. Dès qu'un de ces événements arrive, le trigger exécute une procédure stockée qui met à jour les données devant rester  synchronisées.</p>
                                <ol type="i">
                                    <li>
                                        <h5 id="cas_typique_utilisation_trigger">Cas typique d'utilisation :</h5>
<pre class="taille60"><code>CREATE TRIGGER nom AFTER { INSERT | UPDATE | DELETE } ON table FOR EACH ROW EXECUTE PROCEDURE nomfonc;</code></pre>
                                        <p>La procédure <span class="em">nomfunc</span> doit être préalablement créée grâce à la commande <span class="html">CREATE FUNCTION</span>. Elle ne doit recevoir aucun paramètre mais retourner obligatoirement un type <span class="html">TRIGGER</span>. Cependant, la valeur de retour de ce paramètre sera ignorée avec la commande <span class="html">CREATE TRIGGER</span> ci-dessus. La procédure pourra donc se contenter de <span class="html">RETURN NULL</span>.</p>
                                        <p>À chaque insertion (<span class="html">INSERT</span>), mise à jour (<span class="html">UPDATE</span>) ou effacement (<span class="html">DELETE</span>), la procédure <span class="em">nomfonc</span> sera appelée pour chaque tuple inséré, modifié ou supprimé.  De plus, deux variables seront automatiquement disponibles lors de son exécution :</p>
                                        <ul>
                                            <li><span class="html">OLD</span> est un <span class="em">RECORD</span> contenant les anciennes valeurs du tuple modifié par un <span class="em">UPDATE</span>, effacé pour un <span class="em">DELETE</span> ou <span class="em">NULL</span> pour un <span class="em">INSERT</span>.</li>
                                            <li><span class="html">NEW</span> est un <span class="em">RECORD</span> contenant la nouvelle valeur du tuple dans la <span class="em">TABLE</span> pour un <span class="em">INSERT</span> ou un <span class="em">UPDATE</span>, ou <span class="em">NULL</span> pour un <span class="em">DELETE</span>.</li>
                                        </ul>
                                        <p class="souligne">Exemple :</p>
                                        <p>Cet exemple crée un trigger pour mettre le champ total_sales de la table titles automatiquement à jour lors de l'ajout d'un tuple dans sales_detail :</p>
<pre class="taille60"><code>CREATE OR REPLACE FUNCTION total_sales() RETURNS TRIGGER AS $$
DECLARE
    total INTEGER
BEGIN
    SELECT SUM (sd.qty) FROM salesdetail sd WHERE sd.title_id = NEW.title_id INTO total;
    UPDATE titles SET total_sales = total WHERE title_id = NEW.title_id;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER sales-detail_trigger AFTER INSERT OR SALESDETAIL FOR EACH ROW
EXECUTE PROCEDURE total_sales();</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="reference_complete_create_trigger">Référence complète de CREATE TRIGGER :</h5>
<pre class="taille60"><code>CREATE TRIGGER nom { BEFORE | AFTER } { evenement [ OR ... ] }
    ON table [ FOR [ EACH ] { ROW | STATEMENT } ]
    EXECUTE PROCEDURE nomfonc ( arguments )</code></pre>
                                        <ul>
                                            <li>
                                                <p><span class="html">CREATE TRIGGER</span> crée un nouveau déclencheur. Le déclencheur est associé à la table spécifiée et exécute la fonction <span class="em">nomfonc</span> lorsqu'un de ces trois événements survient : <span class="html">INSERT</span>, <span class="html">UPDATE</span> ou <span class="html">DELETE</span>.</p>
                                                <p>L'appel du déclencheur peut avoir lieu avant que l'opération ne soit tentée sur une ligne (avant la vérification des contraintes et la tentative d'<span class="em">INSERT</span>, <span class="em">UPDATE</span> ou <span class="em">DELETE</span>) ou une fois que l'opération est terminée (après la vérification des contraintes et la fin de la commande <span class="em">INSERT</span>, <span class="em">UPDATE</span> ou <span class="em">DELETE</span>). SI le déclencheur est lancé avant l'événement, le déclencheur peut ignorer l'opération sur la ligne courante ou modifier la ligneen cours d'insertion (uniquement pour les opérations <span class="em">INSERT</span> et <span class="em">UPDATE</span>). Si le déclencheur est activé après l'événement, toute modification, dont la dernière insertion, mise à jour ou suppression, est "visible" par le déclencheur.</p>
                                                <p>Un déclencheur marqué <span class="html">FOR EACH ROW</span> est appelé pour chaque ligne que l'opération modifie. Par exemple, un <span class="em">DELETE</span> affectant dix lignes entraîne dix appels distincts de tout déclencheur <span class="html">ON DELETE</span> sur la relation cible, une fois par ligne supprimée. Au contraire, un déclencheur marqué <span class="html">FOR EACH STATEMENT</span> ne s'exécute qu'une fois pour une opération donnée, quelque soit le nombre de lignes modifiées (en particulier, une opération qui ne modifie aucune ligne résulte toujours en l'exécution des déclencheurs <span class="em">FOR EACH STATEMENT</span> applicables).</p>
                                                <p>Si plusieurs déclencheurs du même genre sont définis pour le même événement, ils sont déclenchés suivant l'ordre alphabétique de leur nom.</p>
                                                <p><span class="em">SELECT</span> ne modifie aucune ligne; la création de déclencheurs sur <span class="em">SELECT</span> n'est pas possible.</p>
                                                <p><span class="em">nomfonc</span> est le nom d'une fonction qui a été créée préalablement. Cette fonction n'a aucun paramètre et doit retourner un type <span class="em">TRIGGER</span>. Lorsque la fonction est appelée avant l'événement <span class="em">et</span> tuple par tuple (<span class="html">BEFORE</span> et <span class="html">FOR EACH ROW</span>), elle a l'occasion d'annuler l'opération ou de modifier le tuple (ce dernier cas n'est possible que pour <span class="em">INSERT</span> et <span class="em">UPDATE</span>).</p>
                                                <ul>
                                                    <li>Pour modifier le tuple inséré ou modifié, il faut retourner une variable de type <span class="html">TRIGGER</span> contenant les nouvelles données à utiliser.</li>
                                                    <li>Pour laisser l'opération s'exécuter normalement, il faut soit retourner <span class="em">NEW</span> pour les événements <span class="em">INSERT</span> et <span class="em">UPDATE</span>, soit retourner <span class="html">OLD</span> pour l'événement <span class="em">DELETE</span>.</li>
                                                    <li>
                                                        <p>Pour annuler l'opération, il faut retourner <span class="em">NULL</span>. <span class="em">ATTENTION, CECI EST GÉNÉRALEMENT UNE ERREUR :</span></p>
                                                        <ul>
                                                            <li class="em">Cette technique est dangereuse car par exemple un <span class="em">INSERT</span> peut sembler avoir réussi alors que le trigger l'a silencieusement annulé. Lorsque ce problème surgit, il est excessivelent difficile d'en trouver l'origine et donc de la corriger.</li>
                                                            <li class="em">Nous verrons plus tard la mécanique permettant d'annuler une opération correctement.</li>
                                                            <li class="em">Il est donc <span class="souligne">interdit</span> dans le cadre de ce cours d'utiliser un trigger <span class="html">ON BEFORE</span> qui retourne <span class="html">NULL</span>.</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                                <p>Dans le cas d'un <span class="em">TRIGGER</span> appelé après l'opération (<span class="html">AFTER</span>) ou bien d'un <span class="em">TRIGGER</span> de niveau instruction (<span class="html">FOR EACH STATEMENT</span>), le retour de la fonction est ignoré et peut aussi bien être <span class="em">NULL</span>. On peut cependant toujours annuler complètement l'opération en envoyant une erreur.</p>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <h5 id="procedure_trigger_plpgsql">Procédure trigger en PL/pgSQL :</h5>
                                        <p>Une procédure trigger est créée grâce à la commande <span class="html">CREATE FUNCTION</span> utilisée comme fonction sans arguments ayant un type de retour <span class="em">TRIGGER</span>. Notez que la fonction doit être déclarée avec aucun argument même si elle s'attend à recevoir les arguments spécifiés dans <span class="html">CREATE TRIGGER</span> -- les arguments trigger sont passés via <span class="html">TG_ARGV</span>, comme décrit plus loin.</p>
                                        <p>Quand une fonction PL/pgSQL est appelée en tant que trigger, plusieurs variables spéciales sont créées automatiquement de plus haut niveau. Ce sont :</p>
                                        <ul>
                                            <li><span class="html">NEW</span> : Type de données <span class="em">RECORD</span>; variable contenant la nouvelle ligne de base de donénes pour les opérations <span class="em">INSERT</span>/<span class="em">UPDATE</span> dans les triggers de niveau ligne. Cette variable est <span class="em">NULL</span> dans un trigger de niveau instruction et pour les opérations <span class="em">DELETE</span>.</li>
                                            <li><span class="html">OLD</span> : Type de données <span class="em">RECORD</span>; variable contenant l'ancienne ligne de base de données pour les opérations <span class="em">UPDATE</span>/<span class="em">DELETE</span> dans les triggers de niveau ligne. Cette variable est <span class="em">NULL</span> dans les triggers de niveau instruction et pour les opérations <span class="em">INSERT</span>.</li>
                                            <li><span class="html">TG_NAME</span> :  Type de données <span class="em">name</span>; variable qui contient le nom du trigger réellement lancé.</li>
                                            <li><span class="html">TG_WHEN</span> : Type de données <span class="em">text</span>; une chaîne, soit <span class="html">BEFORE</span> ou <span class="html">AFTER</span>, selon la définition du trigger.</li>
                                            <li><span class="html">TG_LEVEL</span> : Type de données <span class="em">text</span>; une chaîne, soit <span class="html">BEFORE</span> ou <span class="html">AFTER</span>, selon la définition du trigger.</li>
                                            <li><span class="html">TG_OP</span> : Type de données <span class="em">text</span>; une chaîne, <span class="html">INSERT</span>, <span class="html">UPDATE</span>, <span class="html">DELETE</span> ou <span class="html">TRUCATE</span> indiquant pour quelle opération le trigger a été lancé.</li>
                                            <li><span class="html">TG_RELID</span> : Type de données <span class="em">oid</span>; l'<span class="html">ID</span> de l'obje de la table qui a causé le déclenchement du trigger.</li>
                                            <li><span class="html">TG_TABLE_NAME</span> : Type de données <span class="em">name</span>; le nom de la table qui a déclenché le trigger.</li>
                                            <li><span class="html">TG_NARGS</span> : Type de données <span class="em">integer</span>; le nombre d'arguments donnés à la procédure trigger dans l'instruction <span class="html">CREATE TRIGGER</span>.</li>
                                            <li><span class="html">TG_ARGV[]</span> : Type de données <span class="em">text</span>; les arguments de l'instruction <span class="html">CREATE TRIGGER</span>. L'index débute à 0. Les indices invalides (inférieurs à 0 ou suppérieurs ou égaux à tg_nargs) auront une valeur <span class="em">NULL</span>.</li>
                                        </ul>
                                        <p class="souligne">Exemple :</p>
                                        <p>Une procédure d'audit par trigger en PL/pgSQL. Cet exemple de trigger nous assure que toute insertion, modification ou suppression d'une ligne dans la table <span class="em">emp</span> est enregistrée dans la table <span class="em">emp_audit</span>. L'heure et le nom de l'utilisateur sont conservés dans la ligne avec le type d'opération réalisé.</p>
<pre class="taille60"><code>CREATE TABLE emp
(
    nom_employe TEXT NOT NULL,
    salaire INTEGER,
);

CREATE TABLE emp_audit
(
    operation CHAR (1) NOT NULL,
    tampon TIMESTAMP NOT NULL,
    id_utilisateur TEXT NOT NULL,
    nom_employe TEXT NOT NULL,
    salaire INTEGER,
);

CREATE FUNCTION audit_employe() RETURNS TRIGGER AS $$
BEGIN
    --
    -- Ajoute une ligne dans emp_audit pour réfléter l'opération réalisée sur emp,
    -- utilise la variable spéciale TG_OP pour cette opération.
    --
    IF (TG_OP = 'DELETE') THEN
        INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
    END IF;
    RETURN NULL; -- le résultat est ignoré car il s'agit d'un trigger AFTER
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
    AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE audit_employe();</code></pre>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="utilisateurs">Utilisateurs :</h4>
                                <p>La base de données gère aussi les utilisateurs. Ainsi, sur un serveur unique, il est possible de créer plusieurs bases de données, et d'attribuer des droits d'accès et d'écriture différents en fonction des utilisateurs.</p>
                                <ol type="i">
                                    <li>
                                        <h5 id="create_user">CREATE USER :</h5>
<pre class="taille60"><code>CREATE USER nom [ [ WITH ] option [ ... ] ];</code></pre>
                                        <ul>
                                            <li>
                                                <p>où <span class="html">option</span> peut être :</p>
<pre class="taille60"><code>SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| CREATEUSER | NOCREATEUSER
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| CONNECTION LIMIT limite_connexion
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'motdepasse'
| VALID UNTIL 'dateheure'
| IN ROLE nomrole [, ...]
| IN GROUP nomrole [, ...]
| ROLE nomrole [, ...]
| ADMIN nomrole [, ...]
| USER nomrole [, ...]
| SYSID uid</code></pre>
                                            </li>
                                        </ul>
                                        <p>Comme on le constate, il est possible de spécifier toutes sortes de droits globaux au niveau du serveur. Typiquement on se contentera de créer un utilisateur comme ceci pour un utilisateur non administrateur de la base de données :</p>
<pre class="taille60"><code>CREATE USER nom PASSWORD 'motdepasse';</code></pre>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="grant_revoke">GRANT / REVOKE :</h4>
                                <p><span class="html">GRANT</span> accorde des droits à un utilisateur, <span class="html">REVOKE</span> en supprime. Il existe de nombreuses variantes de ces instructions, nous en présentons ici une seule, veuillez consulter la documentation en ligne pour plus d'informations :</p>
<pre class="taille60"><code>GRANT { { SELECT | INSERT | UPDATE | DELETE }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] nomtable [, ...]
    TO { nomrole | PUBLIC } [, ...]
REVOKE [ GRANT OPTION FOR ]
    { { SELECT | INSERT | UPDATE | DELETE }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] nom_table [, ...]
    FROM { nom_role | PUBLIC } [, ...]</code></pre>
                                <ol type="i">
                                    <li>
                                        <h5>Exemple :</h5>
                                        <p>Georges est l'employé qui enregistre les ventes sur pubs2. Il n'a donc besoin d'insérer des tuples que dans les tables sales et salesdetail. Il doit par contre être capable de consulter le contenu de toutes les tables.</p>
<pre class="taille60"><code>CREATE USER georges PASSWORD 'jaimelipl';
GRANT CONNECT ON DATABASE pubs2 TO georges;
GRANT SELECT ON sales, salesdetail, titles, publishers, store, titleauthors TO georges;
GRANT INSERT ON TABLE sales, salesdetail TO georges;</code></pre>
                                        <p>Si pubs3 utilisait un schéma, il aurait fallu également donner les droits d'utilisation du schéma :</p>
<pre class="taille60"><code>GRANT USAGE ON SCHEMA pubs2 TO georges;</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="cas_particulier_serial">Cas particulier des SERIAL :</h5>
                                        <p>Lorsqu'on veut donner les droits d'insert sur une table contenant un serial, il faut également donner les droits sur les séquences implicitement créées :</p>
<pre class="taille60"><code>GRANT USAGE, SELECT ON SEQUENCE id_seq TO georges;</code></pre>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="simplification_requetes_view">Simplification des requêtes : VIEW :</h4>
<pre class="taille60"><code>CREATE VIEW nom [ ( nom_colonne [, ...] ) ] AS requête;

DROP VIEW nom;</code></pre>
                                <p>Un autre inconvénient de la normalisation est la décomposition des données en de multiples tables. Lors d'un <span class="em">SELECT</span>, il faudra donc effectuer la jointure de toutes les tables permettant d'accéder aux données dont on a besoin. Dans les situations complexes, cela force les requêtes à être artificiellement compliquées et nuit fortement à leur lisibilité. SQL propose une solution très élégante à ce problème : les vues (<span class="html">VIEW</span>). Une vue est une table virtuelle (car inexistante physiquement dans la base de données) correspondant au résultat d'un <span class="em">SELECT</span>. Cette table est elle-même utilisable en consultation pour tout autre <span class="em">SELECT</span> au même titre qu'une table physique réelle.</p>
                                <p>Les vues permettent aussi de changer le schéma d'une base de données plus facilement. En effet, tout code qui utilise l'ancien schéma pourra rester inchangé si l'on crée des vues le respectant.</p>
                                <p>Finalement, les vues permettent de gérer la visibilité des données en configurant la base de données pour empêcher l'accès direct aux tables mais en permettant celui aux vues juste nécessaires à l'utilisateur.</p>
                                <ol type="i">
                                    <li>
                                        <h5>Exemples :</h5>
<pre class="taille60"><code>CREATE VIEW LivresDePsychologiePasChers (numéro, titre, editeur, prix)
AS SELECT T.title_id, T.title, P.pub_name, T.price
    FROM titles T, publishers P
    WHERE T.pub_id = P.pub_id
        AND T.type = 'psychology'
        AND T.price &lt; 20;

SELECT titre, prix
FROM LivresDePsychologiePasChers
WHERE editeur = 'New Age Books';</code></pre>
                                        <p>Cette instruction est traduite par SQL en :</p>
<pre class="taille60"><code>SELECT T.title, t.price
FROM titles T, Publishers P
WHERE T.pub_id = P.pub_id
    AND T.type = 'psychology'
    AND T.price &lt; 20
    AND P.pub_name = 'New Age Books';

CREATE VIEW TotalVenteParMagasin (stor_id, stor_name, total_qty, total_price)
AS SELECT St.stor_id, St.stor_name, SUM (SD.qty), SUM (SD.qty * T.price)
    FROM Stores St, Salesdetail SD, Titles T
    WHERE St.stor_id = SD.stor_id AND SD.title_id = T.title_id
    GROUP BY St.stor_id, St.stor_name;

CREATE VIEW TotalVenteParMagasinBis
AS SELECT stor_id, total_qty
    FROM TotalVenteParMagasin
    WHERE total_qty &gt; 5000;</code></pre>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="performance_index">Performance : INDEX :</h4>
                                <p>Admettons que notre commerce devient aussi prolifique que celui d'Amazon, et que pubs2 soit rempli de millions de livres différents. Seulement les utilisateurs se plaignent des mauvaises performances de notre application et commencent à partir à la concurrence. Quand on observe de plus près qu'il se passe, on se rend compte que ces utilisateurs recherchent des livres principalement sur base de leur type (par exemple tous les livres de psychologie) et qu'avec le temps on a maintenant des milliers de type différents. À chacune de ces requêtes, notre serveur doit donc parcourir l'intégralité de la table titles afin de trouver ceux correspondant au type recherché.</p>
                                <p>Le même problème pourrait apparaître pour trouver un title_id particulier lors d'une jounture, cependant là on n'observe pas de ralentissement du serveur. La raison est qu'à chaque clef primaire le serveur crée automatiquement un index sur cette clef afin d'accélérer les jointures. Mais on garde la possibilité de créer des index supplémentaires si on en a besoin.</p>
<pre class="taille60"><code>CREATE [ UNIQUE ] INDEX nom ON table [ USING méthode ]
    ( { colonne | ( expression ) } [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [,
...] );</code></pre>
                                <ul>
                                    <li>
                                        <p><span class="html">CREATE INDEX</span> construit un index <span class="em">nom</span> sur la table spécifiée. Les index sont principalement utilisés pour améliorer les performances de la base de données (bien qu'une utilisation inappropriée puise produire l'effet inverse).</p>
                                        <p>Les champs clé pour l'index sont spécifiés à l'aide de noms des colonnes ou par des expressions écrites entre parenthèses. Plusieurs champs peuvent être spécifiés si la méthode d'indexation supporte les index multi-colonnes.</p>
                                        <p>Un champ d'index peut être une expression calculée à partir des valeurs d'une ou plusieurs colonnes de la ligne de table. Cette fonctinnalité peut être utilisée pour obtenir un accès rapide à des données obtenues par transformation des données basiques. Par exemple, un index calculé sur <span class="em">upper(col)</span> autorise clause <span class="em">WHERE upper(col) = 'JIM'</span> à utiliser un index.</p>
                                        <p>PostgreSQL<sup>TM</sup> fournit les méthodes d'indexation <span class="em">B-tree</span> (NDT : arbres balancés), <span class="em">hash</span> (NDT : hachage), <span class="em">GiST</span> (NDT : arbres de recherche généralisés) et <span class="em">GIN</span>.</p>
                                    </li>
                                    <li><span class="html">UNIQUE</span> : Le système vérifie la présence de valeurs dupliquées dans la table à la création de l'index (si des données existent déjà) et à chaque fois qu'une donnée est ajoutée. Les tentatives d'insertion ou de mises à jour qui résultent en des entrées dupliquées engendrent une erreur.</li>
                                    <li><span class="html">nom</span> : Le nom de l'index à créer. On pourra supprimer l'index par la commande <span class="html">DROP INDEX nom</span>.</li>
                                    <li><span class="html">table</span> : Le nom de la table.</li>
                                    <li><span class="html">méthode</span> : Le nom de la méthode à utiliser pour l'index. Les choix sont <span class="html">btree</span>, <span class="html">hash</span>, <span class="html">gist</span> et <span class="html">gin</span>. La méthode par défaut est <span class="html">btree</span>.</li>
                                    <li><span class="html">colonne</span> : Le nom d'une colonne de la table.</li>
                                    <li><span class="html">expression</span> : Une expression basée sur une ou plusieurs colonnes de la table. L'expression doit habituellement être écrite entre parenthèses, comme la synytaxe le précise. Néanmoins, les parenthèses peuvent être omises si l'expression a la forme d'un appel de fonction.</li>
                                    <li><span class="html">ASC</span> : Spécifie un ordre de tri ascendant (valeur par défaut).</li>
                                    <li><span class="html">DESC</span> : Spécifie un ordre de tri descendant.</li>
                                    <li><span class="html">NULLS FIRST</span> : Spécifie que les valeurs <span class="em">NULL</span> sont présentées avant les valeurs non NULL. Ceci est la valeur par défaut quand <span class="em">DESC</span> est indiqué.</li>
                                    <li><span class="html">NULLS LAST</span> : Spécifie que les valeurs <span class="em">NULL</span> sont présentées après les valeurs non NULL. Ceci est la valeur par défaut quand <span class="em">ASC</span> est indiqué.</li>
                                </ul>
                                <ol type="i">
                                    <li>
                                        <p>Créer un index sur le champ type de la table titles.</p>
<pre class="taille60"><code>CREATE INDEX titles_type
    ON titles
    USING btree(type);</code></pre>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <h3 id="concurrence">Concurrence :</h3>
                        <p>En situation réelle, les bases de données sont consultées et modifiées simultanément par un grand nombre d'utilisateurs. Par exemple, un site d'enchères devra répondre simultanément à toutes les requêtes de tous les utilisaateurs qui le consultent à un instant donné. Il devra prendre en compte correctement une enchère par un utilisateur et ce même si un autre utilisateur essaie simultanément de faire la même chose. On appelle concurrence le fait qu'une donnée unique soit accédée ou modifiée simultanément par plusieurs incstances (ici des personnes différentes). La concurrence introduit une complexité supplémentaire aux opérations que l'on effectue. Par exemple, si l'enchère permet un achat immédiat (au-delà d'un certain montant, l'objet est automatiquement gagné par l'enchéreur et celle-ci se conclut donc immédiatement), que se passe-t-il si deux utilisateurs effectuent cette opération simultanément ?</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Utilisateur A</th>
                                    <th>Utilisateur B</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Sélectionne achat immédiat</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>Sélectionne achat immédiat</td>
                                </tr>
                                <tr>
                                    <td>
                                        <p>Le système vérifie que l'enchère est toujours ouverte</p>
                                        <p>&#8594; OUI</p>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>
                                        <p>Le système vérifie que l'enchère est toujours ouverte</p>
                                        <p>&#8594; OUI</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <p>Le système clôture l'enchère et marque que l'acheteur est A</p>
                                        <p>Le système notifie A qu'il a gagné l'enchère</p>
                                        <p>Le vendeur est notifié qu'il a vendu l'objet à A</p>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>
                                        <p>Le système clôture l'enchère et marque que l'acheteur est B</p>
                                        <p>Le système notifie B qu'il a gagné l'enchère</p>
                                        <p>Le vendeur est notifié qu'il a vendu l'objet à B</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Les deux utilisateurs penseront avoir gagné l'enchère ! Comme il n'y a qu'un seul champ acheteur le système écrira donc d'abord A et puis B, mais cela aurait aussi bien pu être B et puis A. Dans les deux cas, l'information de la première vente est écrasée et donc perdue. Le vendeur est notifié deux fois de la vente de son objet. Il doit choisir à qui envoyer son objet, mais ne sait pas qui est mis comme acheteur dans la base de données (A qui a écrasé B ou l'inverse).</p>
                        <p>Il va sans dire que cette situation n'est pas admissible et il faut donc une gestion explicite de la concurrence.</p>
                        <ol type="a">
                            <li>
                                <h4 id="acid">ACID :</h4>
                                <p>Les bases de données fournissent un mécanisme permettant de gérer la concurrence : les transactions. Une transaction est une séquence d'opérations qui fait passer une base de données d'un état A cohérent à un état B cohérent. Les transactions respectent les propriétés <span class="em">ACID : Atomique, Cohérent, Isolé et Durable</span>.</p>
                                <ul>
                                    <li><span class="html">Atomique</span> : l'ensemble des opérations sera réalisé complètement ou pas du tout. Une transaction termine soit par une opération de réussite (<span class="html">commit</span>) ou par une opération d'échec (<span class="html">rollback</span>). Lors d'un commit, toutes les opérations sont effectuées. Lors d'un rollback, aucune de ces opérations n'est effectué : c'est exactement comme si la transaction n'avait jamais eu lieu.</li>
                                    <li><span class="html">Cohérent</span> : le résultat de l'exécution d'une transaction doit être cohérent, même si chaque opération de la transaction exécutée séparément ne donne pas un résultat cohérent. Un résultat incohérent entraînera l'échec et l'annulation des opérations de la transaction.</li>
                                    <li><span class="html">Isolé</span> : lorsque deux transactions A et B sont exécutées en même temps, les modifications effectuées par A ne sont pas visibles par B tant que la transaction A n'est pas terminée et validée (commit).</li>
                                    <li><span class="html">Durable</span> : une transaction terminée ne peut pas être annulée ou recouverte. Lorsque deux transactions sont exécutées en même temps, le résultat de la première transaction ne pourra pas être recouvert par la deuxième. Toute tentative de recouvrement entraînera l'annulation des opérations de la transaction fautive.</li>
                                </ul>
                                <p>Reprenons l'exemple de l'enchère, et plaçons l'opération d'achat immédiat au sein d'une transaction ACID.</p>
                                <ul>
                                    <li>La transaction commence lorsqu'un utilisateur sélectionne l'option achat immédiat et se termine lorsque l'enchère est clôturée et les parties notifiées correctement. L'atomicité garantit que tout ceci se fait complètement, ou pas du tout.</li>
                                    <li>Lorsque l'enchère est clôturée, l'acheteur doit être notifié et le vendeur doit être notifié de cet acheteur. La cohérence garantit que ces différentes opérations seront cohérentes entre elles.</li>
                                    <li>Admettons que l'acheteur A et B commencent leur transaction simultanément. L'isolation garantit que ce qui se passe dans la transaction A n'influencera pas ce qui se passe dans la transaction B. En d'autres mots, quand A marque l'enchère comme étant clôturée, B ne le voit pas du tout ! C'est seulement quand A termine sa transaction que cette modification devient visible pour B. Mais alors le système se rendra compte par la cohérence qu'il y a un problème de concurrence entre les deux transactions et annulera celle de B. De par l'atomicité, la transaction B sera complètement annulée comme si elle n'avait jamais eu lieu.</li>
                                    <li>Une fois que A termine sa transaction (commit), alors cette enchère est marquée durablement dans la base de données. Par exemple, il n'y aura plus jamais de cas où cette enchère sera encore considérée ouverte.</li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="transaction_sql">Transaction en SQL :</h4>
                                <ul>
                                    <li><span class="html">START TRANSACTION</span> débute une transaction.</li>
                                    <li><span class="html">COMMIT</span> valide la transaction en cours.</li>
                                    <li><span class="html">ROLLBACK</span> annule la transaction en cours.</li>
                                </ul>
                                <p>Attention, un bloc de transaction ne correspond pas à un bloc d'exécution de l'application. En particulier, il ne faut pas confondre ce comportement avec une méthode Java où le fait de return quitte immédiatement la méthode. La paire <span class="html">START TRANSACTION ... COMMIT</span> ne forme donc pas un bloc d'exécution terminé immédiatement si l'on rencontre un <span class="html">ROLLBACK</span> au milieu !</p>
                                <p>En réalité, les requêtes SQL se passent <span class="souligne">toujours</span> dans le contexte d'une transaction. Ceci semble contradictoire avec tout ce que l'on fat jusqu'ici : on n'a jamais utilisé <span class="em">START TRANSACTION</span> et <span class="em">COMMIT</span>, et pourtant les données ont manifestement été mises à jours et on a bien obtenu des réponses à nos requêtes. En réalité en dehors d'une transaction explicite, toutes les requêtes SQL sont implicitement exécutées dans leur propre transaction qui est directement <span class="em">COMMIT</span>. C'est exactement comme si chacune de ces instructions était précédée par <span class="em">START TRANSACTION</span> et suivie par <span class="em">COMMIT</span>. On appelle cela l'auto-commit.</p>
                                <p>On utilisera une transaction explicite dans les situations suivantes :</p>
                                <ul>
                                    <li>On a besoin d'effectuer plusieurs opérations  successices, qui ont des dépendances entre elles. Le cas le plus fréquent est quand on doit mettre plusieurs tuples à jour dans plusieurs tables et que ces modifications doivent toutes être effectuées pour garder la cohérence globale. Un autre exemple est quand on effectue des vérifications sur le contenu de la base de données avant d'effectuer une mise à jour. Par exemple, on vérifie qu'il reste un livre en stock avant de le vendre à un client. C'est l'atomicité de la transaction qui permet d'effectuer cela d'une manière cohérente.</li>
                                    <li>La création d'une transaction requiert du travail de la part du serveur. Si l'on exécute beaucoup d'instructions SQL (qui peuvent être indépendantes), on gagnera grandement en temps d'exécution si l'on exécute le tout dans une unique transaction explicite. Pour rappel, en l'absence de transaction explicite, l'auto-commit créera une transaction implicite pour chacune des instructions SQL, consommant inutilement les ressources du serveur.</li>
                                </ul>
                                <ol type="i">
                                    <li>
                                        <h5 id="transactions_plpgsql">Transactions en PL/pgSQL :</h5>
                                        <p>N'oublions pas qu'il faut faire la distinction entre le pur SQL et le SQL procédural. Avec PostgreSQL, la gestion des transactions est différente entre les deux. En PL/pgSQL :</p>
                                        <ul>
                                            <li>Une procédure stockée est en effet toujours exécutée au sein d'une unique transaction. Si elle est appelée en dehors d'une transaction explicite, c'est le mécanisme d'auto-commit qui en crée une implicitement.</li>
                                            <li><span class="em">START TRANSACTION ... COMMIT</span> n'a donc pas d'effet en PL/pgSQL.</li>
                                            <li>Si la procédure stockée lance une exception, alors la transaction dans laquelle est exécutée effectue un <span class="em">ROLLBACK</span>.</li>
                                            <li>Si la procédure stockée fini son exécution normalement, alors la transaction dans laquelle est exécutée continue normalement jusqu'à un éventuel <span class="em">COMMIT</span> ou <span class="em">ROLLBACK</span> futur.</li>
                                            <li>Si la procédure est exécutée en mode auto-commit et si elle termine normalement alors elle est directement suivie d'un <span class="em">COMMIT</span>.</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <p>Voici une procédure stockée chargée de gérer complètement une vente. Notez l'usage de la transaction afin de garantir que les différentes étapes de la vente seront bien effectuées correctement.</p>
<pre class="taille60"><code>CREARE FUNCTION sell (VARCHAR (6), CHARACTER (4), VARCHAR (20), SMALLINT) RETURNS BOOLEAN AS $$
DECLARE
    v_title_id ALIAS FOR $1;
    v_stor_id ALIAS FOR $2;
    v_ord_num ALIAS FOR $3;
    v_qty ALIAS FOR $4;
    price INTEGER;
BEGIN
    price := (SELECT prices FROM titles WHERE title_id = v_title_id);
    IF price IS NULL THEN
        RAISE no_data;
    ELSE
        INSERT INTO sales VALUES (v_stor_id, v_ord_num);
        INSERT INTO salesdetail VALUES (v_stor_id, v_ord_num, v_title_id, v_qty);
        UPDATE titles
            SET total_sales = ((
                SELECT total_sales
                FROM titles
                WHERE title_id = v_title_id 
            ) + v_qty)
            WHERE title_id = v_title_id;
        RETURN true;
    END IF;
END;
$$ LANGUAGE plpgsql;</code></pre>
                                    </li>
                                    <li>
                                        <h5 id="transaction_trigger">Transaction et trigger :</h5>
                                        <p>Lorsqu'une opération résulte en l'exécution d'un (ou plusieurs) triggers, ceux-ci sont exécutés dans la même transaction que l'opération. En particulier, si la procédure trigger jette une exception, c'est toute la transaction qui est annulée comprenant donc aussi l'opération. Ceci permet de programmer des contraintes d'intégrité plus intelligentes que ce qui est normalement permis : à l'insertion ou la modification le trigger valide les données et jette une exception si elles ne sont pas acceptables.</p>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <h4 id="mvcc">MVCC :</h4>
                                <p>PostgreSQL (ainsi que de nombreuses autres bases de données) réalise le mécanisme de transaction par la technique de MultiVersion Concurrency Control (MVCC) :</p>
                                <ul>
                                    <li>Chaque requête ne voit que les transactions terminées avant qu'elle n'ait commencé.</li>
                                    <li>À chaque transaction est associé un compteur unique (timestamp) permettant de les ordonner dans le temps.</li>
                                    <li>Chaque tuple est annoté par deux méta-informations : un compteur de transaction de création et un compteur de transaction d'expiration.</li>
                                    <li>
                                        <p>Au démarrage d'une requête, PostgreSQL retient :</p>
                                        <ul>
                                            <li>Le compteur de cette transaction</li>
                                            <li>Tous les compteurs des transactions en cours d'exécution</li>
                                        </ul>
                                    </li>
                                    <li>Dans une transaction couvrant plusieurs instructions SQL, les instructions précédentes de la transaction sont visibles au sein même de la transaction.</li>
                                    <li>Lorsqu'il y a insertion ou modification d'un tuple dans une transaction, le tuple original reste dans la table. Un tuple supplémentaire est ajoyté, annoté en création par le compteur de la transaction.</li>
                                    <li>Lorsqu'il y a suppression d'un tuple dans une transaction, le tuple original est annoté en expiration par le compteur de la transaction.</li>
                                    <li>
                                        <p>Les tuples visibles au sein d'une transaction doivent être annotés en création par un compteur de transaction tel que :</p>
                                        <ul>
                                            <li>Cette transaction a été commitée.</li>
                                            <li>
                                                <p>Ce compteur est inférieur au compteur de la transaction en cours.</p>
                                                <p>et</p>
                                                <p>Ce compteur ne faisait pas partie d'une autre transaction en cours au démarrage de celle-ci.</p>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <p>Les tuples visibles au sein d'une transaction doivent aussi être annotés en expiration par un compteur de transaction tel que :</p>
                                        <ul>
                                            <li>Il est vide ou annulé.</li>
                                            <li>
                                                <p>Ce compteur est supérieur au compteur de la transaction en cours.</p>
                                                <p>ou</p>
                                                <p>Ce compteur faisait partie d'une autre transaction en cours au démarrage de celle-ci.</p>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>Ainsi, la base de donées est capable d'exécuter les transactions en parallèle plutôt que séquentiellement. Pour chaque transaction, à tout instrant le système posède suffisament d'informations pour pouvoir inférer quels sont les tuples logiquement visibles au sein de cette transaction. À chaque requête, la base de données effectue un parcours séquentiel de la table et en fonction des annotations et des critères ci-dessus décide si le tuple est visible ou non.</p>
                                <p>Il existe un inconvénient à cette technique : phyiquement le système n'est capable que d'ajouter de l'information, jamais de la supprimer. Et chaque modification ajoute un tuple supplémentaire plutôt que d'écraser l'ancien. Ce n'est qu'une question de temps avant que la base de données grandisse au-delà de la taille disque disponibke. Il existe donc une commande permettant de nettoyer les tuples périmés afin de récupérer leur espace physique. C'est la commande <span class="html">VACUUM</span> qui s'en charge. PostgreSQL est aussi capable de déterminer automatiquement quand cette commande devrait être utilisée et de le faire sans intervention extérieure.</p>
                                <p>La technique MVCC est affinée en différents niveaux de performances et de garanties. En général, plus on demande des garanties sur la transaction, moin son a un niveau élevé de performance et inversement.</p>
                            </li>
                        </ol>
<pre class="taille60"><code>START TRANSACTION [ mode_transaction [, ...] ]</code></pre>
                        <ul>
                            <li>
                                <p>où <span class="em">mode_transaction</span> fait partie de :</p>
<pre class="taille60"><code>ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ
    | READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY</code></pre>
                                <p>Les caractéristiques de transition disponibles sont le niveau d'isolation et le mode d'accès de la transaction (lecture/écriture ou lecture seule).</p>
                                <p>Le niveau d'isolation détermine les données que la transaction peut voir quand d'autres transactions fonctionnent concurrentiellement :</p>
                                <ul>
                                    <li><span class="html">READ COMMITTED</span> : Une instruction ne peut voir que les lignes validées avant qu'elle ne commence. C'est la valeur par défaut.</li>
                                    <li><span class="html">SERIALIZABLE</span> : Toute instruction de la transaction en cours ne peut voir que les lignes validées avant que la première requête ou instruction de modification de données soit exécutée dans cette transaction.</li>
                                </ul>
                                <p>Le standard SQL définit deux niveaux supplémentaires, <span class="html">READ UNCOMMITTED</span> et <span class="html">REPEATABLE READ</span>. Dans PostgreSQL<sup>TM</sup>, <span class="em">READ UNCOMMITTED</span> est traité comme <span class="em">READ COMMITTED</span> alors que <span class="em">REPEATABLE READ</span> est traité comme <span class="em">SERIALIZABLE</span>.</p>
                                <p>La méthode d'accès de la transaction détermine si elle est en lecture/écriture ou en lecture seule. Lecture/écriture est la valeur par défaut. Quand une transaction est en lecture seule, les commandes SQL modifiant le contenu de la base de données sont interdites.</p>
                            </li>
                        </ul>
                        <h3 id="sql_embarque">SQL embarqué :</h3>
                        <p>Nous sommes donc maintenant capables de créer une base de données, d'y insérer/modifier/supprimer des données, d'automatiser la mise à jour de certains champs, de créer des vues, de gérer la concurrence, etc. Il ne reste donc maintenant plus qu'à écrire l'application qui va avec ces données ! Alors que la base de données est installée sur un serveur joignable par Internet, l'applicaion elle-même s'exécute généralement chez le client. Cette application se doit d'avoir une belle interface utilisateur, de gérer des aspects supplémentaires que juste les données, etc. C'est pourquoi on écrira cette application dans un langage de programation adapté à cette tâche. Nou utiliserons Java ici. Quand le programme Java aura besoin d'interagir avec la base de données, on y embarquera les commandes SQL correspondantes. On appelle donc cela le SQL embarqué (embedded SQL en anglais).</p>
                        <ol type="a">
                            <li>
                                <h4 id="jdbc">JDBC :</h4>
                                <p>Le module Java gérant le SQL embarqué s'appelle JDBC et est inclus en standard avec Java. JDBC est en fait le portage d'ODBC qui est la technologie à l'origine du SQL embarqué. Cette technologie date du début des années 1990, et, à l'époque, ses créateurs comptaient encore à partir de 1, alors que tout bon informaticien moderne se foit de compter à partir de zéro. Cet avis n'engage que l'auteur de ce texte ! Par héritage du pasé, JDBC requiert donc aussi de compter à prtir de 1 !</p>
                            </li>
                            <li>
                                <h4 id="driver">Driver :</h4>
                                <p>Le modèle JDBC requiert un driver pour fonctionner avec une base de données. Dans le cas de PostgreSQL, ce driver est disponible à l'adresse : <a href="http://jdbc.postgresql.org/download.html" target="_blank">http://jdbc.postgresql.org/download.html</a>.</p>
                                <p>Ce driver doit être placé dans le Build Path du projet Java qui l'utilise. Dans Eclipse, il fautplacerle jar (par exemple, postgresql-8.4-701.jdbc4jar) dans un répertoire du projet, cliquez-droit dessus et sélectionnez <span class="em">BuildPath/Add to Build Path</span>. Ceci permet à votre application d'accéder à ce driver pendant la compimation et son exécution.</p>
                                <p>En plus, il faut dire à l'application de charger ce driver en mémoire, ce qui se fait par cette commande :</p>
<pre class="taille60"><code>Class.forName("org.postgresql.Driver");</code></pre>
                            </li>
                            <li>
                                <h4 id="connection">Connection :</h4>
                                <p>Une fois le driver chargé, il faut établir une connexion avec la base de données :</p>
<pre class="taille60"><code>String url="jdbc:postgresql://postgresql.ipl/be/pubs2?user=public&password=public";
Connection conn = DriverManager.getConnection(url);</code></pre>
                                <p>L'URL est composé de :</p>
                                <ul>
                                    <li><span class="html">jdbc:postgresql</span> : signale que driver utiliser.</li>
                                    <li><span class="html">//postgresql.ipl.be</span> : URL du serveur, peut se terminer par <span class="html">:port</span> pour préciser un numéro de port.</li>
                                    <li><span class="html">/pubs2</span> : nom de la base de données.</li>
                                    <li><span class="html">?user=public</span> : nom de l'utilisateur à connecter.</li>
                                    <li><span class="html">&password=public</span> : mot de passe.</li>
                                </ul>
                                <p>Notez que <a href="https://en.wikipedia.org/wiki/Percent-encoding" target="_blank">le format d'encodage des caractères spéciaux des URLs</a> est d'application. Vous trouverez d'autres méthodes statiques dans la classe DriverManager qui ne requièrent pas d'encoder le login et le mot de passe.</p>
                                <p>Sur base d'une connexion, on pourra envoyer autant de commandes SQL qu'on le souhaite, et recevoir tout autant de résultats. Chaque connexion prend un certain temps à s'établir et occupe de la ressource auprès du client et du serveur. On veuillera donc à n'ouvrir une connexion qu'en cas de réel besoin. En général, on aura deux stratégies viables :</p>
                                <ul>
                                    <li>Pour une application mono-utilisateur, l'application ouvre une connexion au démarrage et la garde active pendant toute sa durée de vie. Toutes les opérations DB passent par cette connexion.</li>
                                    <li>Pour une application multi-utilisateur (typiquement une application Web), plusierus connexions sont ouvertes et fermées suivant les besoins en cours. Ainsi, quand moins d'utilisateurs sont actifs, les connexions sont fermées. Quand plus d'utilisateurs sont actifs, des connexions sont ouvertes en plus. En général, on utilise une librairie pour effectuer cette maintenance de connexions.</li>
                                </ul>
                                <p>Pour fermer manuellement une connexion, il faut appeler la méthode <span class="em">close</span> :</p>
<pre class="taille60"><code>conn.close();</code></pre>
                            </li>
                            <li>
                                <h4 id="statement">Statement :</h4>
                                <p>À partir d'une connexion, on peut créer un <span class="em">Statement</span> : une instruction SQL.</p>
<pre class="taille60"><code>try {
    st.execute("DELETE FROM Store;");
} catch (SQLException e) {
    e.printStackTrace();
}</code></pre>
                                <p>La méthode <span class="html">execute(String sql)</span> se charge d'exécuter cette instruction. Cette métode déclare lancer l'exception <span class="html">SQLException</span> que l'on est obligé d'attraper. En fait, toutes les méthodes de JDBC qui interagissent avec le serveur sont susceptibles de lancer cette exception. On se retrouve donc assez rapidement à devoir écrire des blocs <span class="html">try {} catch</span> en de multiples endroits, ce qui rend le code plutôt difficile à lire.</p>
                            </li>
                            <li>
                                <h4 id="resultset">ResultSet :</h4>
                                <p>En plus d'envoyer des instructions SQL, on a besoin de récupérer le résultat obtenu. Ceci se fait grâce aux <span class="html">ResultSet</span> :</p>
<pre class="taille60"><code>ResultSet rs = null;
try {
    Statement st = conn.createStatement(),
    try (ResulSet rs = st.executeQuery("SELECT au_fname, au_lname " + "FROM Authors;")) {
        while (rs.next()) {
            String r = rs.getString(1) +  " " + rs.getString(2);
            System.out.println(r);
        }
    }
} catch (SQLException e) {
    e.printStackTrace();
}</code></pre>
                                <p>La méthode <span class="html">executeQuery</span> d'un <span class="em">Statement</span> est similaire à la méthode <span class="em">execute</span> (elle exécute une commande SQL), mais en plus elle retourne un <span class="em">ResultSet</span> permettant d'accéder au résultat de la query.</p>
                                <p>Le <span class="em">ResultSet</span> est un curseur sur les résultats, similaire à un <span class="em">Iterator</span> Java. La méthode <span class="html">next()</span> permet de déplacer ce curseur vers l'avant; elle retourne <span class="em">false</span> quand on est arrivé à la fin des tuples, <span class="em">true</span> sinon. Il y a toute une série de getters permettant de récupérer les différents champs du tuple ponté par le curseur. Chacun de ces getters retourne un type Java particulier;  il faut choisir le getter qui a un sens par rapport au type du champ dans la base de données. Le paramètre des getters spécifie quel champ doit être retourné; comme dit précédemment, le premier champ est le numéro 1.</p>
                                <p>Un <span class="em">ResultSet</span> doit être fermé pour relâcher les ressources JDBC le concernant. La bonne pratique consiste à utiliser un <span class="em">try</span> d'allocation de ressource : la variable déclarée dans la parenthèse suivant le <span class="em">try</span> sera automatiquement clôturée à la fin de ce dernier. Ainsi, la base de données et le driver JDBC sont mis au courant que le curseur du <span class="em">ResultSet</span> peut disparaître et éviter ainsi une fuite de mémoire.</p>
                            </li>
                            <li>
                                <h4 id="preparedstatement">PreparedStatement :</h4>
                                <p>On a fréquemment besoin de paramétrer les requêtes en fonction de données provenant de l'application elle-même, par exemple en fonction d'une entrée de l'utilisateur. Il serait alors tentant d'utiliserun <span class="em">Statement</span> en construisant à l'exécution la chaîne de caractères spécifiant la requête SQL :</p>
<pre class="taille60"><code>public void showNames (String state) {
    try {
        Statement st = conn.createStatement(),
        try (ResulSet rs = st.executeQuery("SELECT au_fname, au_lname " + "FROM Authors " + "WHERE state = '" + state + "';")) {
            while (rs.next()) {
                String r = rs.getString(1) +  " " + rs.getString(2);
                System.out.println(r);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}</code></pre>
                                <p>Cette manière de faire est en fait très dangereuse ! Imaginons que le paramètre state provient d'une interface utilisateur permettant à l'utilisateur d'y mettre tout ce qu'il veut. S'il rentre :</p>
<pre class="taille60"><code>XX'; DROP TABLE SalesDetail; SELECT 'a'  'a</code></pre>
                                <p>La query devient :</p>
<pre class="taille60"><code>SELECT au_fname, au_lname FROM Authors WHERE state = 'XX'; DROP TABLE SalesDetail; SELECT 'a', 'a';</code></pre>
                                <p>Nous venons juste de perdre la table <span class="em">SalesDetail</span>. La query quant à elle retourne le tuple ('a', 'a') et le programme continue de s'exécuter comme si de rien n'était.</p>
                                <p>Il ne faut surtout pas croire que c'est un cas hypothétique et tordu qui n'arrive pas en réalité : ceci s'appelle une attaque par injection de SQL et est probablement le numéro un des failles de sécurité des sites web !</p>
                                <p>Pour éviter ce genre de problème, il faut utiliser <span class="html">PreparedStatement</span> à la place de <span class="em">Statement</span> :</p>
<pre class="taille60"><code>public void showNames (String state) {
    try {
        PreparedStatement st = conn.prepareStatement("SELECT au_fname, au_lname " + "FROM Authors " + "WHERE state = ?;");
        st.setString(1, state);
        try (ResultSet rs = st.executeQuery()) {
            while (rs.next()) {
                String r = rs.getString(1) +  " " + rs.getString(2);
                System.out.println(r);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}</code></pre>
                                <p>La méthode <span class="html">prepareStatement</span> prend une instruction SQL paramétrée par zéro, un ou plusieurs <span class="html">?</span>. Chaque <span class="em">?</span> représente une place logique à remplir plus tard. C'est le <span class="em">PreparedStatement</span> qui se charge de ce remplissage, d'une manière qui est garantie correcte. Par exemple, pourun champ textuel, il ne faudra pas placer d'apostrophes autours du <span class="em">?</span>, c'est le <span class="em">prepareStatement</span> qui se chargera de le faire.</p>
                                <p>Un <span class="em">PreparedStatement</span> ainsi créé peut être configuré à tout moment à l'aide de setters. Tout comme pour les <span class="em">ResulSet</span>, les setters existent sous différentes formes portant sur des types Java différents qu'il faut choisir en accord avec le type du champ correspondant de la base de données. Le premier paramètre du setter est le numéro du <span class="em">?</span> qu'il faut remplir, en comptant de nouveau à partir de 1. Le second paramètre est la valeur à place. Une fois que tous les <span class="em">?</span> ont été settés, <span class="em">executeQuery()</span> retourne le <span class="em">ResultSet</span> correspondant.</p>
                                <p>Avec cette technique, on évite tous les problèmes d'injection de SQL. Ainsi, dans l'exemple ci-desssus, le <span class="em">PreparedStatement</span> recherchera juste un état dont le nom est bien toute la chaîne "<span class="em">XX'; DROP TABLE SalesDetail; SELECT 'a', 'a</span>".</p>
                                <p>Un <span class="em">PreparedStatement</span> peut être utilisé plusieurs fois dans des requêtes successives paramétrées indépendamment les unes des autres. Ceci permet de mieux factoriser son code et a aussi l'avantage d'être plus performant. En effet, chaque instruction SQL doit être traduite par la base de données. Avec un <span class="em">PreparedStatement</span>, la base de données traduit l'instruction (incomplète) une et une seule fois.À l'exécution du <span class="em">PreparedStatement</span>, la base de données n'aura qu'à compléter les parties manquantes de l'instruction pour pouvoir l'exécuter.</p>
                                <p class="em">Remarque importe : Puisque les PreparedStatement sont plus efficaces et plus sûrs que les Statement simples, il faudra toujours les préférer. Dans le cadre de ce cours, l'utilisation d'un Statement est donc considérée comme une faute, et sanctionné comme tel.</p>
                            </li>
                            <li>
                                <h4 id="integration_java_db">Intégration entre Java et une base de données :</h4>
                                <p>Comme nous l'avons vu, il est possible de stocker des procédures au niveau de la base de données et d'utiliser des triggers pour les appeler automatiquement. Alternativement, on pourrait réaliser une fonctionnalité similaire e Java : répérer les requêtes qui exigent des mises à jour supplémentaires et alors appeler la méthode Java qui effectue cette dernière. On a donc une frontière qui se supperpose entre les deux mondes.</p>
                                <img src="../images/integration_Java_db.PNG" alt="Intégration entre Java et une base de données">
                                <p>Pour la partie commune, il y a des raisons diverses pour préférer Java à SQL ou inversement.</p>
                                <ul>
                                    <li>D'un point de vue monétaire, les grands vendeurs de base de données pousseront toujours à préférer SQL. Non seulement parce que cela fait partie de leur coeur de métier, mais surtout parce que cela lie fortement le logiciel avec leur produit et empêche ainsi de migrer vers la concurrence. En effet, tous les vendeurs proposent des extensions de SQL qui leur sont spécifiques, et dès que l'on commence à leur exploiter il devient difficile voire impossible de porter la base de données vers un autre produit. Si l'on veut éviter ce piège, il devient important de se limiter au strict minimum de SQL possible en favorisant au plus Java. Souvent, en entreprise, ceci est une décision stratégique sur laquelle le développeur n'aura pas d'influence. Les petites entreprises préfèrent en général ne pas se lier à un vendeur pour limiter leurs coûts, tandis que les grosses entreprises préfèrent se lier à Oracle ou à Microsoft afin de bénéficier d'un support préférentiel.</li>
                                    <li>D'un point de vue pragmatique, on peut s'interroger sur la nécessité de reproduire en Java des fonctionnalités déjà existantes en SQL. Surtout que ces fonctionnalités SQL sont sûrement des solutions beaucoup plus matures et optimisées. Ainsi, ce courant de pensée pousse à utiliser la base de données dans toutes ses possibilités. La partie Java doit être la moins concernée possible par le stockage des données, c'est la base de données qui a cette responsabilité.</li>
                                    <li>L'inconvénient de l'approche précédente est que maintenant le code gérant le stockage des données est en petite partie en Java et en grande partie en SQL. Le développeur doit avoir une bonne maîtrise technique des deux langages pour avoir une chance d'y résoudre un bug. Il lui faudra deux débuggeurs dans deux environnements de développement différents. Pire, le mécanisme des triggers s'exécute automatiquement et modifie des données "en cachette" du code que l'on pense en train de débugger. Il devient difficile de prédire le comportement de l'application. Il faut donc être excessivement attentif à d'abord trouver les triggers concernés et ensuite à bien voir quand et comment ils seront exécutés. Si par contre on se restreint au Java, on n'a plus qu'un seul environnement de développement et il n'y a plus de triggers mais bien des méthodes qui s'appellent entre elles. Il devient plus simple de comprendre le comportement de l'application et donc d'y résoudre les éventuels problèmes.</li>
                                </ul>
                                <p>Le choix d'une approche ou d'une autre dépend donc d'abord de la présence ou pas d'une politique d'entreprise à ce niveau. En son absence, il est souvent préférable de limiter autant que possible l'usage du SQL. Ainsi, on se garde la possibilité de migrer vers un autre système et on limite la connaissance technique nécessaire à la compréhension et maintenance de l'application. On diminue aussi le travail effectué par le serveur et on augmente donc ses performances. On perd évidemment l'avantage des services avancés que la base de données est capable de fournir.</p>
                                <p>Dans le cadre de ce cours, nous nous concentrons en priorité sur l'approche maximisant l'usage du SQL puisqu'après tout c'est le thème même de ce cours. Dans la suite, nous décriron une partie des bonnes pratiques de développement.</p>
                            </li>
                            <li>
                                <h4 id="bonne_pratique_jdbc_general">Bonne pratique JDBC en général :</h4>
                                <p>En gardant à l'esprit que le code SQL est dépendant de la base de données, on a un intérêt fort à isoler autant que possible toute la partie du code Java qui interagit avec JDBC. Ainsi, on aura un seul endroit à mettre à jour en cas de migration. Il y a des raisons supplémentaires (architecture, modularisation, pattern) pour vouloir isoler cette partie au sein de l'application, vous verrez cela dans d'autres cours. La bonne pratique consistera donc à :</p>
                                <ul>
                                    <li>Créer un package qui contiendra toute la partie de l'application Java interagissant directement avec la base de données.</li>
                                    <li>Au sein de ce package, créer une classe de gestion de la connexion JDBC. Au démarrage de l'application, cette classe sera instanciée et elle établira alors la connexion physique avec la basede données.</li>
                                    <li>Au sein de ce package, créer des classes gérant un ensemble de requêtes. Sans vouloir aller trop loin sur la manière d'écrire ces classes, une première approche consiste à regrouper des requêtes logiquement proches ensembles. Ainsi, on regroupera au sein d'une classe toutes les requêtes concernant la gestion d'une authentification d'une personne par exemple. On peut évidemment utiliser des sous-packages pour continuer à organiser ces classes.</li>
                                    <li>Lorsqu'une classe qui gère des requêtes est instanciée, elle crée autant de <span class="em">PreparedStatement</span> que nécessaire. Lorsque desméthodes sont appelées sur cette instance, ces méthodes n'utilisent que des <span class="em">PreparedStatement</span> pour communiquer avec la base de données.</li>
                                    <li>Utiliser des <span class="em">try</span> avec ressource pour s'assurer que les <span class="em">ResultSet</span> sont bien fermés correctement.</li>
                                    <li>Fermer la connexion lorsque l'application se termine.</li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="bonne_pratique_jdbc_minimise_usage_sql">Bonne pratique JDBC lorsque l'on minimise l'usage du SQL :</h4>
                                <p>Dans cette approche, on essaie de dépendre du minimum possible de SQL. Comme la création de la base de données s'effectue une et une suele fois, on créera un script SQL (un simple fichier texte de commandes SQL) pour la création de la base de données. On se passera complètement des triggers et des procédures stockées : si ce mécanisme est nécessaire au fonctionnement de l'application, il faudra reproduire son équivalent en Java. On gardera par contre les index pour des raisons de performance. On évitera tout ce qui est spécifique à la base de données, comme les index auto-générés et les fonctionalités non standard. On pourra se contenter d'un seul rôle (public) sachant que c'est au niveau du code Java que la sécurité d'accès à la base de données sera implémentée.</p>
                                <ul>
                                    <li>Au niveau du code Java, les requêtes seront des commandes <span class="em">SELECT</span>, <span class="em">UPDATE</span>, <span class="em">DELETE</span> explicites.</li>
                                </ul>
                            </li>
                            <li>
                                <h4 id="bone_pratique_jdbc_maximise_usage_sql">Bonne pratique JDBC lorsque l'on maximise l'usage du SQL :</h4>
                                <p>Dans cette approche, on va s'abstraire autant que possible au niveau du Java du SQL sous-jacent. Ceci permettra de faire évaluer la base de données en minimisant l'impact sur la partie Java :</p>
                                <ul>
                                    <li>Éviter les requêtes portant directement sur des tables. À la place, écrire des procédures stockées au niveau du serveur et n'utiliser que cela au niveau du client.</li>
                                    <li>Si le schéma de la base de données change, utiliser les vues pour garder constant les données retournées au client. Par exemple, si on ajoute une colonne à la table titles, créer une vue qui ignore cette colonne.</li>
                                </ul>
                                <p>De plus, on peut utiliser les fonctionnalités de la base de données pour amener plus de garanties de correction :</p>
                                <ul>
                                    <li>Utiliser des séquences afin de générer automatiquement des identifiants unique pour les tuples (des clefs primaires). Comme c'est le serveur qui gère cela, on a la garantie qu'il n'y aura jamais de collision de clefs primaires (deux clients pourraient souhaiter s'approprier la même clef au même moment).</li>
                                    <li>Créer des triggers pour gérer automatiquement la bonne cohérence des données.</li>
                                    <li>Créer des utilisateurs dans la base de données correspondant au rôle logique dont a besoin l'application. Par exemple, une application de consultation uniquement se connectera au serveur en spécifiant un utilisateur possédant un utilisateur possédant uniquementle droit d'effectuer des <span class="em">SELECT</span>. Par contre, l'application d'administration se connectera avec un utilisateur administrateur de la base données.</li>
                                </ul>
                            </li>
                            <li>
                                <h4>Exemple :</h4>
<pre class="taille60"><code>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class ProgrammePrincipal {

    private String url = "jdbc:postgresql://postgres.ipl.be/pubs2" + "?user=public&password=public";
    private PreparedStatement listeAuteurs;
    private PreparedStatement listeAuteursAvecNom;
    private Connection conn = null;

    public ProgrammePrincipal() {
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            System.out.println("Driver PostgreSQL manquant !");
            System.exit(1);
        }
        try {
            conn = DriverManager.getConnection(url);
        } catch (SQLException e) {
            System.out.println("Impossible de joindre le serveur !");
            System.exit(1);
        }
        try {
            listeAuteurs = conn.prepareStatement("SELECT au_fname, au_lastname" + " FROM Authors;");
            listeAuteursAvecNom = conn.prepareStatement("SELECT au_lname" + " FROM Authors" + " WHERE au_fname LIKE ?;");
        } catch (SQLException e) {
            System.out.println("Erreur avec les requêtesSQL !");
            System.exit(1);
        }
    }

    private void listeAuteursAvecNom(String name) {
        try {
            listeAuteursAvecNom.setString(1, name);
            try (ResultSet rs = listeAuteursAvecNom.executeQuery()) {
                while (rs.next()) {
                    System.out.println("Prénom "+ rs.getString(1));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void listeAuteurs () {
        try {
            try (ResulSet rs = listeAuteurs.executeQuery()) {
                while (rs.next()) {
                    System.out.println("Nom " + rs.getString(1) + " Prénom " + rs.getString(2));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        ProgrammePrincipal pp = new ProgrammePrincipal();
        System.out.println("Liste des auteurs");
        pp.listeAuteurs();
        System.out.println("Liste des auteurs dont le nom est Sheryl");
        pp.listeAuteursAvecNom("Sheryl");
        pp.close();
    }

}</code></pre>
                            </li>
                        </ol>
                    </article>
                </section>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
    </body>
</html>