<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Linux - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#cours_1">Introduction : Les commandes de bases</a></li>
                        <li><a href="#cours_2">Le système de fichier : Les manipulations des fichiers</a></li>
                        <li><a href="#cours_3">Le système de fichier : Les propriétés</a></li>
                        <li><a href="#cours_4">Les outils du shell : La redirection</a></li>
                        <li><a href="#cours_5">Les outils du shell : alias, history, variables, ...</a></li>
                        <li><a href="#cours_6">Ecercices Linux : find et grep</a></li>
                        <li><a href="#cours_7">Exercices Linux : Les processus</a></li>
                        <li><a href="#cours_8">Script Bash I : Les bases</a></li>
                        <li><a href="#cours_9">Script Bash || : Les expressions conditionnelles - les alternatives</a></li>
                        <li><a href="#cours_10">Les tables et les structures de contrôle répétitives</a></li>
                        <li><a href="#exercices_supplementaires_1">Exercices supplémentaires</a></li>
                        <li><a href="#interro_1">Interrogation de Linux n° 1 : Les répertoires et les fichiers</a></li>
                        <li><a href="#interro_2">Interrogation de Linux n° 2</a></li>
                        <li><a href="#exercices_supplementaires_2">Exercices supplémentaires n° 2</a></li>
                        <li><a href="#fonctions">Les fonctions</a></li>
                        <li><a href="#examen_juin_2016">Examen de Juin 2016</a></li>
                        <li><a href="#examen_juin_2017">Examen de Juin 2017</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Linux :</h1>
                </article>
                <article>
                    <h2 id="cours_1">Cours n° 1 : Introduction : Les commandes de bases :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p><span class="em">GNU/Linux</span> (couramment appelé <span class="em">Linux</span>) est un système d'exploitation basé sur le noyau Linux. Ses principales propriétés : portabilité, multitâche, multi-utilisateur, organosation arborescence des fichiers, ..., en font un outil de prédilection dans le monde des serveurs informatiques. Son intérêt vient  également de l'ensemble des outils qui l'accompagnent et qui en font toute sa puissance.</p>
                            <p>Les derniers développements en font aussi un système d'exploitation tout à fait adapté comme Pc personnel :</p>
                        </li>
                        <li>
                            <h4>Une longue et belle histoire :</h4>
                            <ol>
                                <li>
                                    <h5>UNIX :</h5>
                                    <p>Unix a été créé fin des années 60 (en 1969) par Ken Thompson et Denis Ritchie. En 1972, UNIX est récrit en langage C pour favoriser la portabilité des programmes. Dans un premier temps, le logiciel est fourni aux universités avec ses sources. Cette politique a favorisé la dissémination de UNIX et l'éparpillement des développements en différentes branches : la branche recherche de AT & T laboratoires Bell (UNIX éd 8, 9, 10 jusqu'en 1990), la branche commerciale de AT & T (Syss III, Sys V), l'université de Berkeley en Californie (4.1 BSD, 4.3 BSD, 4.4 BSD). Certainns constructeurs ont éalement commercialisé leur propre version de UNIX (entre autre : IBM (AIX), HP (HP-UX), Microsoft (XENIX), Sun Microsystem (Solaris), etc).</p>
                                </li>
                                <li>
                                    <h5>GNU (GNu's not Unix) :</h5>
                                    <p><a href="http://www.gnu.org/" target="_blank">http://www.gnu.org/ (nouvelle fenêtre)</a></p>
                                    <p>C'est un système d'exploitation de type Unix, pensé dans un esprit d'utilisation sans contrainte. C'est un logiciel libre qui donne à l'utilisateur la liberté d'exécuter le programme, d'en étudier son fonctionnement et de l'adapter, d'en distribuer des copies, d'en améliorer les sources. Le projet a été lancé en 1984 par Richard Stallman, rejoint par toute une communauté qui s'est appliquée à développer les outils de base exploitant le noyau.</p>
                                </li>
                                <li>
                                    <h5>Linux :</h5>
                                    <p>En 1987, Andrew S. Tanenbaum conçoit Minix, un petit système d'exploitation pour Pcs, destiné à illustrer son cours de système d'exploitation. En 1991, Linus Torvalds s'inspire de ce petit système d'exploitation pour développer son propre  noyau, de la famille de unix, mais sans reprendre de code UNIX. La publication de la première version de son programme attire la sympathie de nombreux passionnés qui vont se joindre à lui pour améliorer ce programme.</p>
                                </li>
                                <li>
                                    <h5>GNU/Linux :</h5>
                                    <p>Le noyau Linux à lui seul n'est pas exploitable sans les outils d'utilisation. Mais rapidement le projjet GNU intègre ce noyau pour en faire un système d'exploitation complet.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>Les distributions Linux :</h4>
                            <p>Deouis les balbutiements du début, de nombreux développements ont amélioré les programme. Certaines personnes ont décidé de compiler une série de prgrammes pour proposer un ensemble cohérent, distribué de manière libre ou commerciale. De nombreuses distributions existent aujourd'hui, chacune ayant ses caractéristiques propres. Les principales sont Debian (développée de manière indépendante, réputée la plus universelle et la plus viable car longuement testée avant d'être publiée, Ubuntu (version grand public qui sort une nouvelle version tous les 6 mois, elle est basée sur Debian), Fedora et sa version commerciale RHEL (Red Hat Entreprise Linux), Slackware (la plus ancienne), CentOS (issue directement des sources de Red Hat).</p>
                        </li>
                        <li>
                            <h4>L'organisation de Linux :</h4>
                            <p>GNU/Linux est donc un ensemble de programmes qui exploitent le noyau Linux. Contrairement à Windows, qui est une structure monolithique, Linux adopte une organisation en couche qui apporte une grande diversité, plusieurs programmes peuvent implémenter une même fonctionnalité. Cette organisation laisse le choix à l'utilisateur d'opter pour un environnement plus personnalisé. Par exemple, le noyau peut être exploité par un <span class="em">shell</span>, programme interface en ligne de commandes, mais aussi au travers de commandes ou de librairies standards. L'interface graphique se base sur le protocole X-Window qu'une multitude d'applications exploitent pour fournir différents environnements de travail.</p>
                        </li>
                        <li>
                            <h4>Le noyau de Linux :</h4>
                            <p>C'est le coeur du systèlme, le kernel, c'est lui qui gère l'ordinateur. Il est composé de primitives (les appels systèmes) qui exploitent les ressources physiques (disques, processeurs, mémoire, ...), logiques (utilisateurs, processus, fichiers, ...) de l'ordinateur et qui gèrent les communications entre processus (IPC). Il comprend également des tables nécessaires à la mémorisation des informations utilisées par les primitives (table des processus, tables des fichiers, table des utilisateurs connectés, ...).</p>
                        </li>
                        <li>
                            <h4>L'environnement de travail :</h4>
                            <p>Contrairement à Windows, sur les machines Linux il n'est pas obligatoire de travailler dans un environnement graphique. Il est possible d'utiliser l'ordinateur.</p>
                            <ul>
                                <li>Soit en ligne de commandes grâce à un <span class="em">shell</span> activé dans une console, dans un pseudo-terminal ou encore dans un Xterm fenêtre de l'environnement graphique, mais aussi à distance en utilisant un terminal distant ou une émulation terminale (ssh, putty).</li>
                                <li>Soit via une interface graphique. Plusieurs applications s'offrent à l'utilisateur (les bureaux graphiques gnome, KDE, ...).</li>
                            </ul>
                        </li>
                        <li>
                            <h4>L'environnement de travail à l'IPL :</h4>
                            <p>L'environnement de travail que vous allez utiliser à l'IPL consiste en une station de travail Linux (Ubuntu) stockée sur un serveur et accédée en utilisant le protocole "Remote Desktop Protocol" qui offre un bureau graphique distant. L'authentification sur la machine Linux est assurée par le serveur LDAP Windows (l'Active Directory du domaine stud). Tous les exercices doivent être réalisés en ligne de commandes, par exemple dans une fenêtre Xterm de votre environnement graphique X-Window.</p>
                        </li>
                        <li>
                            <h4>Briève introduction au shell :</h4>
                            <p>L'utilisation du <span class="em">shell</span> se fait au moyen de commandes introduites au clavier, ce qui peut paraître lourd à utiliser mais reste d'une puissance inégalée, ou dans des scripts, programmes constitués d'un ensemble de commandes. Une commande (mnémonique en général codée sur 2 caractères) peut recevoir 0, 1 ou plusieurs arguments (données traitées par la commande), ainsi que 0, 1 ou plusieurs options qui spécifient la manière dont le traitement sera effectué. Par exemple, la commande <span class="html">cp -r -p /home/bernard /media/MaCle/bu</span> va copier tous les fichiers du répertoire <span class="em">bernard</span> sur la clé USB dans le répertoire <span class="em">bu</span>.</p>
                            <ul>
                                <li><span class="em">/home/bernard</span> : source (ensemble des fichiers à copier)</li>
                                <li><span class="em">/media/MaCle/bu</span> : destination (endroit où seront copiés les fichiers)</li>
                                <li><span class="em">-r</span> :  de manière récursive (toute l'arborescence)</li>
                                <li><span class="em">-p</span> : en préservant les propriétés des fichiers</li>
                            </ul>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <ol>
                        <li>
                            <p>L'aide en ligne est donnée par la commande <span class="html">man</span>. Elle reprend la spécificité locale des sujets liés à l'implémentation de votre distribution. Cette documentation est divisée en plusieurs sections. Citez et décrivez les 3 pemières sections du man. Pour vous aider, consulter le man de la commande <span class="html">man</span>.</p>
                            <ul>
                                <li>Shell commands (commande Linux ou commande utilisateur)</li>
                                <li>System calls (Appel système)</li>
                                <li>librarycalls (bibliothèque de fonction)</li>
                            </ul>
                            <p>Cette application (<span class="em">man</span>) affiche à l'écran la description de la commande, fonction, ... passée en argument; elle accepte plusieurs commandes qui permettent de se déplacer dans le texte ou d'effectuer une recherche :</p>
                            <ul>
                                <li><span class="em">&lt;sp&gt;</span> (la barre d'espacement) déplace l'affichage de la taille d'un écran</li>
                                <li><span class="em">&lt;ret&gt;</span> déplace le texte affiché d'une ligne vers le bas</li>
                                <li><span class="em">&lt;b&gt;</span> (la lettre b <span class="em">back</span>) déplace l'affichage de la taille d'un écran vers le haut</li>
                                <li><span class="em">/pattern</span> recherche le pattern dans le texte</li>
                                <li><span class="em">&lt;p&gt;</span> permet de quitter l'application</li>
                                <li>Pour l'ensemble des commandes de l'utilisation de l'affichage, voir le manuel de la commande <span class="html">less</span></li>
                            </ul>
                        </li>
                        <li>
                            <p>Donner la commande qui permet d'afficher la liste des utilisateurs connectés au système.</p>
<pre><code class="html">who</code></pre>
                        </li>
                        <li>
                            <p>Qu'est-ce que le "login name" d'un utilisateur ? Donnez la commande qui permet d'afficher le "login name" de la personne connectée.</p>
<pre><code># login name = nom d'utilisateur = identifiant

<span class="html">whoami</span></code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de donner les informations de "login" de la personne connectée, expliquez les informations fournies.</p>
<pre><code><span class="html">who am i</span>

# donne le login name, le terminal où il est connecté et l'heure</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la ate système.</p>
<pre><code class="html">date</code></pre>
                        </li>
                        <li>
                            <p>Donnez la manière d'obtenir la date sous le format : <span class="em">mardi, le 1 janvier 2014</span>.</p>
<pre><code class="html">date "+%A, le %d %B %Y"</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de connaître le nom du jour de votre naissance (lun-dim).</p>
<pre><code class="html">date -d '1/1/1990' +%A</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de connaître le numéro du jour de votre anniversaire (1-365).</p>
<pre><code class="html">date -d '1/1/1990' +%j</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet d'afficher le calendrier du mois et de l'année de votre naissance.</p>
<pre><code class="html">cal 1 1990</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_2">Cours n° 2 : Le système de fichier : Les manipulations des fichiers :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>Un des premiers besoins d'un système d'exploitation est la possibilité de stocker de manière permanente les données du syst§me et des utilisateurs.</p>
                            <p>Généralement, les données sont stockées sur un ou plusieurs disques durs pouvant être découpés en partitions. Linux utilise une nomenclature (<span class="em">/ted/tdmn</span> où <span class="em">td</span> représente le type de disque (<span class="em">s</span> pour SCSI ou SATA), (<span class="em">h</span> pour ide); <span class="em">m</span> est le numéro du disque dur (<span class="em">a</span> pour 1<sup>er</sup>, <span class="em">b</span> pour le 2<sup>ème</sup>, etc); <span class="em">n</span> le numéro de la partition sur le disque. Par exemple <span class="em">/dev/sdb3</span> représente la 3<sup>ème</sup> partition du 2<sup>ème</sup> disque SATA) standarisée pour référencer les partitions physiques qu'il rencontre sur une machine. Le nom d'une partition physique permet de l'identifier dans l'ordinateur.</p>
                            <p>Chaque partition est découpée en blocs de bytes. La taille par défaut est de 512 bytes par bloc. Ce sont ces blocs qui constituent l'espace utilisé pour stocker les données du fichier.</p>
                        </li>
                        <li>
                            <h4>L'organisation logique des données :</h4>
                            <p>Dans le monde Unix, les données stockées sur les disques sont organisées de manière arborescente (une structure arborescence est composé de <span class="em">noeuds</span> (éléments internes) pouvant contenir d'autres éléments et de <span class="em">feuilles</span> (éléments externes)) dans une structure unique. Dans ce "file system" Unix, les noeuds sont implémentés au moyen de répertoires et les fichiers contenant les données sont les feuilles de l'arbre.</p>
                        </li>
                        <li>
                            <h4>Les fichiers :</h4>
                            <p>Un fichier est un ensemble séquentiel de bytes qui ne contient pas de marque de fin de fichier, c'est la taille, une des propriétés du fichier, qui permet de déterminer la fin du fichier. Il possède d'autres propriétés que nous aborderons plus tard.</p>
                            <p>Le nom du fichier doit être unique dans son répertoire. Et pour le système de fichier, la notion d'extension est sans objet car il n'en tient aucunement compte. Seules, les applications peuvent éventuellement s'en préoccuper (par exemple, le compilateur Java préférera traiter des sources dont l'extension est ".java").</p>
                            <p>Dans le monde Linux, il existe 2 sortes de fichiers réguliers, les fichiers de type <span class="em">text</span> (qui contiennent uniquement des caractères imprimables (Ascii) et les fichiers binaires (contenant des enregistrements formatés), des documents formatés (doc, ppt, xls, ...), des librairies, des fichiers compilés, ...</p>
                            <p>Dans le système de fichiers, on retrouvera également d'autres types de fichiers (les descriptions de devices (/dev), etc.).</p>
                        </li>
                        <li>
                            <h4>Les répertoires :</h4>
                            <p>Un répertoire est une sorte de table qui permet de mettre en relation un nom de fichier et une référence (<span class="em">inode</span>) vers le fichier physique sur le disque.</p>
                            <p>Pour Linux, les répertoires sont des fichiers d'un type spécial, ils peuvent donc être manipulés au moyen des commandes de gestion de fichiers.</p>
                        </li>
                        <li>
                            <h4>L'arborescence :</h4>
                            <p>Tous ces fichiers et répertoires sont organisés sous une forme arborescente avec une racine, un répertoire particulier origine de toute la structure, des branches qui aboutissent aux différents éléments de l'arbre : les répertoires (éléments intermédiaires) et les fichiers (éléments terminaux). Dans le monde Unix, le répertoire racine se nomme '<span class="html">/</span>'.</p>
                        </li>
                        <li>
                            <h4>Le pathname :</h4>
                            <p>Pour retrouver un fichier dans l'arborescence, le système parcourt l'arborescence à partir de la racine, le chemin parcouru s'appelle le <span class="em">pathname absolu</span>. Dans ce chemin, chaque répertoire traversé est séparé par le caractère '<span class="html">/</span>'; donc, le fichier <span class="em">test.c</span> qui se trouve dans le répertoire <span class="em">tux</span> du répertoire <span class="em">home</span> se notera <span class="em">/home/tux/test.c</span>, ce nom complet est unique sur le système. Utiliser le pathname absolu pour nommer un fichier peut être contraignant, mais il existe une autre manière retrouver un fichier dans l'arbre du système de fichiers, c'est le <span class="em">pathname relatif</span> qui au lieu de démarrer de la racine part du répertoire courant. Le <span class="em">répertoire courant</span>, c'est le répertoire de référence à un moment donné du travail de l'utilisateur est "positionné" quelque part dans l'arborescence, ce répertoire courant, qui varie en fonction des traitements envoyés par l'utilisateur se nomme toujours au moyen du caractère '<span class="html">.</span>'. Le répertoire parent d'un répertoire se nomme '<span class="html">..</span>'.</p>
                        </li>
                        <li>
                            <h4>Shell et répertoires :</h4>
                            <p>Lorsqu'il se connecte, l'utilisateur démarre un shell (programme interface entre l'utilisateur et le système) qui le positionne dans un répertoire particulier, le <span class="em">répertoire de login</span>, indiqué par le caractère '<span class="html">~</span>'.</p>
                            <p>Pour aider l'utilisateur, le shell pour afficher dans son prompt (message d'invite) le nom du répertoire de login.</p>
                        </li>
                        <li>
                            <h4>Les commandes utiles :</h4>
                            <ol>
                                <li>
                                    <h5>pour manipuler les répertoires :</h5>
                                    <ul>
                                        <li><span class="html">cd</span> : change directory</li>
                                        <li><span class="html">ls</span> : list information about file(s)</li>
                                        <li><span class="html">mkdir</span> : create new folder(s)</li>
                                        <li><span class="html">rmdir</span> : remove folder(s)</li>
                                        <li><span class="html">pwd</span> : print working directory</li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>pour manipuler les fichiers :</h5>
                                    <ul>
                                        <li><span class="em">cp</span> : copy one or more files to another location</li>
                                        <li><span class="em">rm</span> : remote files</li>
                                        <li><span class="html">mv</span> : move or rename files or directories</li>
                                        <li><span class="html">touch</span> :change file timestamps</li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>pour traiter les fichiers text :</h5>
                                    <ul>
                                        <li><span class="html">cat</span> : concatenate and print (display) the content of files</li>
                                        <li><span class="html">wc</span> : print byte, word, and line count</li>
                                        <li><span class="html">head</span> : output the first part of file(s)</li>
                                        <li><span class="html">tail</span> : output the last part of file(s)</li>
                                        <li><span class="htmml">od</span> : dump files in octal and other formats</li>
                                        <li><span class="html">nl</span> : number lines and write files</li>
                                        <li><span class="html">sort</span> : sort text files</li>
                                        <li><span class="html">grep</span> : search file(s) for lines that match a given pattern</li>
                                        <li><span class="html">cut</span> : divid a file into a several parts</li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>Les répertoires particuliers :
                                <ol>
                                    <li>le répertoire racine : <span class="html">/</span></li>
                                    <li>le répertoire de login : <span class="html">~</span></li>
                                    <li>le répertoire courant : <span class="html">.</span></li>
                                    <li>le répertoire parent : <span class="html">..</span></li>
                                </ol>
                            </h4>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <h4>Les répertoires :</h4>
                    <ol>
                        <li>
                            <p>Donnez la commande qui permet d'afficher le nom du répertoire courant, c'est votre répertoire de login, indiquez le nom de ce répertoire et complétez l'arborescence en y ajoutant votre répertoire de login.</p>
<pre><code><span class="html">pwd</span>

# affiche /home/u1bin000</code></pre>
                        </li>
                        <li>
                            <p>Introduisez la commande <span class="html">ls</span>, qu'affiche-t-elle ?</p>
<pre><code><span class="html">ls</span>

# affiche le contenu du répertoire courant donc ici rien</code></pre>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">linux</span> dans le répertoire courant.</p>
<pre><code class="html">mkdir linux</code></pre>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">theorie</span> dans le répertoire <span class="em">linux</span> que vous vous venez de créer.</p>
<pre><code class="html">mkdir linux/theorie</code></pre>
                        </li>
                        <li>
                            <p>Déplacez-vous dans ce répertoire.</p>
<pre><code class="html">cd linux/theorie</code></pre>
                        </li>
                        <li>
                            <p>Affichez le pathname absolu du répertoire courant.</p>
<pre><code><span class="html">pwd</span>

# affiche /home/u1bin000/linux/theorie</code></pre>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">exercices</span> dans le répertoire <span class="em">theorie</span>.</p>
<pre><code class="html">mkdir exercices</code></pre>
                        </li>
                        <li>
                            <p>Grâce à la commande <span class="html">rmdir</span>, essayez de supprimer le répertoire <span class="em">theorie</span>, en utilisant le pathname absolu. Est-ce possible, si non pourquoi</p>
<pre><code><span class="html">rmdir /home/u1bin000/linux/theorie</span>

# impossible car le répertoire n'est pas vide</code></pre>
                        </li>
                        <li>
                            <p>Affichez le contenu du répertoire parent.</p>
 <pre><code class="html">ls ..</code></pre>
                        </li>
                        <li>
                            <p>Revenez dans le répertoire de login et affichez le contenu du répertoire courant.</p>
<pre><code><span class="html">cd</span> (ou <span class="html">cd ~</span> ou <span class="html">cd /home/u1bin000</span> ou <span class="html">cd ../..</span>)

<span class="html">ls</span></code></pre>
                        </li>
                    </ol>
                    <h4>Les fichiers :</h4>
                    <ol>
                        <li>
                            <p>Grâce à la commande <span class="html">touch</span>, créez le fichier <span class="em">lusreDesCommandes.txt</span> dans le répertoire <span class="em">linux</span>.</p>
<pre><code class="html">touch linux/listeDesCommandes.txt</code></pre>
                        </li>
                        <li>
                            <p>Créez le fichier <span class="em">ex1</span> dans le répertoire <span class="em">exercices</span>.</p>
<pre><code class="html">touch linux/theorie/exercices/ex1</code></pre>
                        </li>
                        <li>
                            <p>Déplacez-vous dans le répertoire <span class="em">exercices</span> et affichez le contenu du répertoire au moyen de la commande <span class="html">ls</span>.</p>
<pre><code class="html">cd linux/theorie/exercices

ls</code></pre>
                        </li>
                        <li>
                            <p>Affichez de nouveau le contenu du répertoire en utilisant la commande <span class="html">ls &gt; listeDesFichiers</span> puis à nouveau la commande <span class="html">ls</span>, mais seul. Que constatez-vous ?</p>
<pre><code># Au début, pas d'affichage

# Au rappel de la commande, un nouveau fichier est arrivé</code></pre>
                        </li>
                        <li>
                            <p>Copiez le fichier <span class="em">listeDesFichiers</span> dans le fichier <span class="em">listeDesFichiers.bu</span>.</p>
<pre><code class="html">cp listeDesFichiers listeDesFichiers.bu</code></pre>
                        </li>
                        <li>
                            <p>Copiez le fichier <span class="em">listeDesFichiers</span> dans le répertoire parent.</p>
<pre><code><span class="html">cp listeDesFichiers ..</span>

# le fichier est créé avec le même nom</code></pre>
                        </li>
                        <li>
                            <p>Renommez le fichier <span class="em">listeDesFichiers</span> en <span class="em">listeDesFichiers.txt</span>.</p>
<pre><code class="html">mv listeDesFichiers listeDesFichiers.txt</code></pre>
                        </li>
                        <li>
                            <p>Positionnez-vous dans le répertoire de login et déplacez le répertoire <span class="em">exercices</span> dans le répertoire <span class="em">linux</span>.</p>
<pre><code class="html">cd

mv linux/theorie/exercices linux/</code></pre>
                        </li>
                        <li>
                            <p>Copiez l'arborescence <span class="em">linux</span> dans le répertoire <span class="em">/tmp</span>.</p>
<pre><code class="html">cp -r linux /tmp</code></pre>
                        </li>
                        <li>
                            <p>Supprimez le fichier <span class="em">listeDesFichiers.bu</span>.</p>
<pre><code class="html">rm linux/exercices/listeDesFichiers.bu</code></pre>
                        </li>
                        <li>
                            <p>Exécutez la commande <span class="html">~/lesCommandes/whoami</span>; en cas de problème, faites en sorte que cette commande puisse s'exécuter.</p>
<pre><code># KO car le répertoire n'existe pas

mkdir lesCommandes</code></pre>
                        </li>
                    </ol>
                    <h4>Les fichiers text :</h4>
                    <ol>
                        <li>
                            <p>Donez la commande qui affiche le contenu du fichier <span class="em">passwd</span> du répertoire de configuration <span class="html">/etc</span>.</p>
<pre><code class="html">cat /etc/passwd</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche le nombre de lignes de ce même fichier.</p>
<pre><code class="html">wc -l /etc/passwd</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des utilisateurs potentiels du système et leur uid (c'est-à-dire le 1<sup>er</sup> et 3<sup>ème</sup> champs de chaque enregistrement).</p>
<pre><code class="html">cut -d: -f1,3 /etc/passwd</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche les 3 dernières lignes du fichier des utilisateurs.</p>
<pre><code class="html">tail -n3 /etc/passwd</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche le contenu du fichier <span class="em">passwd</span> du répertoire de configuration <span class="html">/etc</span> en numérotant les lignes.</p>
<pre><code class="html">nl /etc/passwd</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des répertoires standards du répertoire racine d'un "File System" Linux et expliquez en l'utilité.</p>
                            <ul>
                                <li>
                                    <p><span class="html">/bin</span> : User Binairies</p>
                                    <p>Ce répertoire contient les exécutables binaires. Toutes les commandes utilisées par tous les utilisateurs du système se trouvent dans ce répertoire (ex. : <span class="html">ps</span>, <span class="html">ls</span>, <span class="html">ping</span>, <span class="html">grep</span>, <span class="html">cp</span>).</p>
                                </li>
                                <li>
                                    <p><span class="html">/sbin</span> : System Binairies</p>
                                    <p>Ce répertoire contient également des exécutables binaires. Les commandes Linux sous ce répertoire sont utilisées généralement par des administrateurs du système à des fins de maintenance du système (ex. : <span class="html">iptables</span>, <span class="html">reboot</span>, <span class="html">fdisk</span>, <span class="html">ifconfig</span>, <span class="html">swapon</span>).</p>
                                </li>
                                <li>
                                    <p><span class="html">/etc</span> : Configuration Files</p>
                                    <p>Ce répertoire contient des fichiers de configuration requis par tous les programmes.</p>
                                </li>
                                <li>
                                    <p><span class="html">/dev</span> : Device Files</p>
                                    <p>Ce répertoire contient des fichiers de périphérique comprenant des dispositifs terminaux, usb, ou tout autre appareil connecté au système.</p>
                                </li>
                                <li>
                                    <p><span class="html">/proc</span> : Process Information</p>
                                    <p>Ce répertoire contient des informations sur le processus de système.</p>
                                </li>
                                <li>
                                    <p><span class="html">/var</span> : Variable Files</p>
                                    <p>Ce répertoire contient des fichiers variables qui inclut les fichiers journauxx du système (<span class="html">/var/log</span>), les packages et fichiers de base de données (<span class="html">/var/lib</span>), les emails (<span class="html">/var/mail</span>), les files d'attente d'impression (<span class="html">/var/spool</span>), verrouiller les fichiers (<span class="html">/var/lock</span>) et les fichiers temporaires nécessaires entre les redémarrages (<span class="html">/var/tmp</span>).</p>
                                </li>
                                <li>
                                    <p><span class="html">/tmp</span> : Tempory Files</p>
                                    <p>Ce répertoire contient les fichiers temporaires créés par le système et les utilisateurs qui sont supprimés lorsque le système est redémarré.</p>
                                </li>
                                <li>
                                    <p><span class="html">/usr</span> : User Programs</p>
                                    <p>Ce répertoire contient les binaires, les bibliothèques, la documentation et le code source pour les programmes de deuxième niveau.</p>
                                    <p><span class="html">/usr/bin</span> contient des fichiers binaires pour les programmes utilisateur.</p>
                                    <p><span class="html">/usr/sbin</span> contient des fichiers binaires pour les administrateurs système.</p>
                                    <p><span class="html">/usr/lib</span> contient les bibliothèques <span class="html">/usr/bin</span> et <span class="html">/usr/sbin</span>.</p>
                                    <p><span class="html">/usr/local</span> contient des programmes utilisateurs que vous installez de la source.</p>
                                </li>
                                <li>
                                    <p><span class="html">/home</span> : Home Directories</p>
                                    <p>Ce répertoire contient les répertoires de login de tous les utilisateurs avec leurs fichiers personnels.</p>
                                </li>
                                <li>
                                    <p><span class="html">/boot</span> : Boot Loaer Files</p>
                                    <p>Ce répertoire contient des fichiers liés au chargement du démarrage.</p>
                                </li>
                                <li>
                                    <p><span class="html">/lib</span> : System Librairies</p>
                                    <p>Ce répertoire contient des fichiers de bibliothèque qui prend en charge les fichiers binaires situés sous <span class="html">/bin</span> et <span class="html">/sbin</span>.</p>
                                </li>
                                <li>
                                    <p><span class="html">/opt</span> : Optional add-on Apps</p>
                                    <p>Ce répertoire contient les applications supplémentaires provenant de fournisseurs individuels.</p>
                                </li>
                                <li>
                                    <p><span class="html">/mnt</span> : Mount Directory</p>
                                    <p>C'est un répertoire temporaire de montage où les administrateurs systèmes peuvent monter des systèmes de fichiers.</p>
                                </li>
                                <li>
                                    <p><span class="html">/media</span> : Removable Devices</p>
                                    <p>C'est un répertoire temporaire pour les périphériques amovibles.</p>
                                </li>
                                <li>
                                    <p><span class="html">/srv</span> : Service Data</p>
                                    <p>Ce répertoire contient des services spécifiques au serveur de données relatives.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_3">Cours n° 3 : Le système de fichier : Les propriétés :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>Nous avons vu au cours précédent que les données pouvaient être stockées sur des disques durs et acédées au travers d'une structure arborescente de fichiers. Mais comment le système d'exploitation peut-il retrouver un fichier sur la partition</p>
                        </li>
                        <li>
                            <h4>Inode :</h4>
                            <p>Sur une partition, chaque fichier est identifié par son numéro appelé <span class="em">inode</span>. Cet inode est mis en relation avec le nom du fichier dans un répertoire qui peut être vu comme une table.</p>
                            <p>Lorsque l'on fournit le nom d'un fichier, le système retrouve l'inode dans le répertoire si l'élément y est présent; grâce à cet inode, le gestionnaire des disques recherche l'adresse des blocs de données dans la table des inodes liée à la partition, cette adresse lui permet d'accéder aux données du fichier.</p>
                            <img src="../images/inode.png" alt="">
                            <p>Il est possible d'afficher le numéro d'inode d'un fichier grâce à la commande <span class="html">ls -i</span> (option i).</p>
                        </li>
                        <li>
                            <h4>Les liens :</h4>
                            <p>Un lien est le moyen d'accéder à un fichier en lui spécifiant un autre nom. En Linux, il existe deux manières de spécifier un lien sur un fichier, le <span class="em">lien physique</span> (hard link) et le <span class="em">lien symbolique</span> (symlink).</p>
                            <ol>
                                <li>
                                    <p>Le Lien physique consiste à créer une nouvelle entrée dans un répertoire en utilisant l'inode d'un fichier déjà existant, dans ce cas, un même fichier possède deux noms. Le lien physique nécessite évidemment que les deux noms soient repris dans la même partition, mais pas nécessairement dans le même répertoire. Puisqu'ils partagent le même inode, aucune donnée n'est ajoutée dans le "file system".</p>
                                    <p>La commande permettant de créer un lien physique est la commande <span class="html">ln src dst</span>.</p>
                                    <img src="../images/lien_physique.png" alt="">
                                </li>
                                <li>
                                    <p>Par contre, le lien symbolique utilise une indirection (comme les raccourcis en Windows).</p>
                                    <p>Dans ce cas, un nouvel élément est ajouté dans le système de ficier (c'est-à-dire un nouvel iode); cet élément va contenir la référence sur le nom de fichier; contrairement aux liens physiques, les liens symboliques peuvent traiter des fichiers qui se trouvent sur des partitions différentes.</p>
                                    <p>La commande pour créer un lien symbolique est la commande <span class="html">ln -s src dest</span>.</p>
                                    <p>Pour retrouver les données enregistrées sur le disque à partir d'un lien symbolique, le gestionnaire de fichiers récupère l'inode du lien symbolique (1) qui lui permet d'accéder (2) aux informations du lien symbolique stockées dans la table des inodes, celles-ci permettent de retrouver (3) le nom du fichier (<span class="em">fichier.txt</span>) qui donne accès aux blocs de données (4-5-6).</p>
                                    <img src="../images/lien_symbolique.png" alt="">
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>La structure inode :</h4>
                            <p>Si l'inode est un numéro identifiant le fichier sur la partition, il représente également une structure qui reprend toutes les propriétés du fichier, notamment le numéro d'inode, la taille du fichier, le nombre de liens (physqiues), différents horodatages (timestamps), le propriétaire et le groupe propriétaire, les droits d'accès, plus d'autres informations (le nom du fichier n'est pas repris dans la structure inode).</p>
                            <p>La commande qui permet d'afficher le contenu de l'inode est la commande <span class="html">stat fichier</span>.</p>
                            <p>Certaines propriétés sont affichées grâce à la commande <span class="html">ls -l fichier</span>.</p>
                            <ol>
                                <li>
                                    <h5>Timestamp :</h5>
                                    <p>Les fichiers Linux sont caractérisées par 3 horodatages : le <span class="html">ctime</span> (change time) indique le moment où l'inode a été modifié pour la dernière fois, c'est-à-dire quand une des propriétes a été modifiée, le <span class="html">mtime</span> (modified time) indique la date (et l'heure) de la dernière modification du contenu fichier et le <span class="html">atime</span> (access time) donne la date du dernier accès au fichier.</p>
                                    <p>La commande <span class="html">touch fichier</span> permet de modifier le mtime d'un fichier sans en modifier le contenu.</p>
                                    <p>La commande <span class="html">ls</span> permet d'afficher le ctime (option <span class="html">-lc</span>), le mtime (option <span class="html">-l</span>), le atime (option <span class="html">-lu</span>).</p>
                                </li>
                                <li>
                                    <h5>Propriétaire :</h5>
                                    <p>Chaque ressource Linux possède un <span class="em">propriétaire</span> (user/owner) et un <span class="em">groupe propriétaire</span>. Ceux-ci sont donnés par les numéros <span class="html">uid</span> (user id) et <span class="html">gid</span>. Pour retrouver les noms correspondants, le système doit consulter le fichier <span class="html">/etc/passwd</span> (pour le uid) et le fichier <span class="html">/etc/group</span> (pour le gid).</p>
                                    <p>Les commandes <span class="html">chown</span> et <span class="html">chgrp</span> permet de modifier cette propriété des fichiers, mais elles sont réservées à l'utilisateur privilégié (root).</p>
                                </li>
                                <li>
                                    <h5>Les droits d'accès :</h5>
                                    <p>La dernière propriété que nous allons développer permet de spécifier les droits positionnés sur les fichiers. Ces droits sont accordés à trois catégories d'utilisateurs : le propriétaire, le groupe et les autres utilisateurs du système.</p>
                                    <p>Pour chacune de ces catégories, il est possible de définir 3 niveaux d'accès différents : le droit de lecture (<span class="html">Read</span>) permet d'accéder au contenu du fichier, le droit d'écriture (<span class="html">Write</span>) permet de modifier le fichier tandis que le droit d'exécution (<span class="html">eXecute</span>) permet d'"exécuter" le fichier. L'interprétation de ces droits est différente suivant qu'il s'agisse d'un fichier régulier ou d'un répertoire : le droit d'écriture sur un répertoire permet d'en modifier le contenu, c'est-à-dire pouvoir ajouter ou supprimer un fichier, le droit d'exécution permet de traverser le répertoire pour accéder aux sous-répertoires.</p>
                                    <p>La commande <span class="html">chmod mode fichier</span> permet de moifier les droits sur le fichier. Le <span class="em">mode</span>, 1<sup>er</sup> argument de la commande, spécifie les droits, il peut être donné en notation symbolique : le droits <span class="html">RWX</span> appliqués aux utilisateurs <span class="html">U</span> (user (propriétaire)), <span class="html">G</span> (group), <span class="html">O</span> (other (autres)) ou en notation octale (<span class="html">4&#8594;R 2&#8594;W 1-&#8594;X</span>, pour le propriétaire, le groupe et les autres) sur trois groupes de chiffres : 1 (eXecute), 2 (Write), 4 (Read).</p>
                                    <ul>
                                        <li>
                                            <p>Pour imposer de nouveaux droits, sans tenir compte des droits déjà existants, le mode peut être spécifié en noattaion octale ou en symbolique.</p>
                                            <p>Par exemple : pour accorder au fichier <span class="em">exemple.txt</span> tous les drots au propriétaire, permettre la simple consultation par le groupe et aucun droit aux autres utilisateurs, nous utiliserons la notation octale 750 (7 = 4 + 2 + 1, 5 = 4 + 1, 0 = 0 + 0 + 0) ou la notation symbolique (U = RWX, G = RX, O =).</p>
<pre><code><span class="html">chmod 750 exemple.txt</span>

# ou

<span class="html">chmod u=rwx,g=rx,o= exemple.txt</span></code></pre>
                                        </li>
                                        <li>
                                            <p>Pour modifier des droits existants, il est obligatoire de spécifier le mode en notation symbolique (<span class="html">+</span> : pour ajouter des droits, <span class="html">-</span> pour supprimer certains droits).</p>
                                            <p>Par exemple : Pour ajouter le droit d'exécution pour le propriétaire et le groupe, <span class="html">chmod ug+x exemple.txt</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <h4>Les liens :</h4>
                    <ol>
                        <li>
                            <p>Crez le répertoire <span class="em">seance3</span> et déplacez-vous dans ce nouveau répertoire.</p>
<pre><code class="html">mkdir seance3

cd seance3</code></pre>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">linux</span>.</p>
<pre><code class="html">mkdir linux</code></pre>
                        </li>
                        <li>
                            <p>Créez le fichier <span class="em">fichier.txt</span> grâce à la commande <span class="html">ls ~ &gt; fichier.txt</span> et créez un lien symbolique <span class="em">lien.sym</span> sur le fihcier.</p>
<pre><code class="html">touch fichier.txt

ln -s fichier.txt lien.sym</code></pre>
                        </li>
                        <li>
                            <p>Créez un lien physique <span class="em">lien.phy</span> sur le même fichier.</p>
<pre><code class="html">ln fichier.txt lien.phy</code></pre>
                        </li>
                        <li>
                            <p>Affichez les inodes de ces fichiers. Que constatez-vous concernant ces identifants ?</p>
<pre><code><span class="html">ls -i</span>

# fichier.txt et lien.phy ont le même inode
# lien.sym a une autre couleur</code></pre>
                        </li>
                        <li>
                            <p>Affichez le contenu des 2 liens en utilisant la commande <span class="html">cat</span>.</p>
<pre><code><span class="html">cat lien.phy

cat lien.sym</span>

# même contenu que fichier.txt différents liens</code></pre>
                        </li>
                        <li>
                            <p>Supprimez le fichier <span class="em">fichier.txt</span>, ensuite ré-affichez le contenu des 2 liens, notez les modifications apportées aux 2 liens.</p>
<pre><code><span class="html">rm fichier.txt</span>

# le lien symbolique est mort</code></pre>
                        </li>
                        <li>
                            <p>Introduisez la commande <span class="html">date &gt; fichier.txt</span> et ré-affichez le contenu des 2 liens, expliquez le résultat obtenu.</p>
<pre><code><span class="html">cat lien.phy</span>

# pas de changement de lien

<span class="html">cat lien.sym</span>

# lien.sym revient</code></pre>
                        </li>
                    </ol>
                    <h4>Les timestamps :</h4>
                    <ol>
                        <li>
                            <p>Quelle option de la commande <span class="html">ls</span> utiliser pour afficher la date de dernière modification des fichiers du répertoire courant.</p>
<pre><code class="html">ls -l</code></pre>
                        </li>
                        <li>
                            <p>Quel est le résultat de la commande <span class="html">touch fichier.txt</span> ? Pour s'en rendre compte introduisez la commande <span class="html">ls -l</span>.</p>
<pre><code># la date est modifiée</code></pre>
                        </li>
                        <li>
                            <p>Grâce à la commande <span class="html">ls</span>, affichez la date du dernier accès au fichier <span class="em">fichier.txt</span>.</p>
<pre><code class="html">ls -lu fichier.txt</code></pre>
                        </li>
                        <li>
                            <p>Comment la modifier ?</p>
<pre><code class="html">cat fichier.txt

ls -lu fichier.txt</code></pre>
                        </li>
                        <li>
                            <p>De quand date la dernière modification des status du fichier <span class="em">fichier.txt</span> (comment trouver cette date ?). Donnez une commande qui permet de modifier cette date.</p>
<pre><code class="html">ls -lc fichier.txt

ln fichier.txt fichier.bu</code></pre>
                        </li>
                    </ol>
                    <h4>Les propriétés : les droits :</h4>
                    <ol>
                        <li>
                            <p>Quelle est la commande qui affiche les droits du répertoire de login, quels sont ces droits ?</p>
<pre><code><span class="html">ls -ld ~</span>

# rwxr_xr_x</code></pre>
                        </li>
                        <li>
                            <p>Supprimez les droits d'écrituresur le fichier <span class="em">fichier.txt</span>.</p>
<pre><code class="html">chmod -w fichier.txt</code></pre>
                        </li>
                        <li>
                            <p>Exécutez la commande <span class="html">date &gt;&gt; fichier.txt</span>, que constatez-vous et pourquoi ?</p>
<pre><code># message d'erreur car le shell veut modifier le fichier</code></pre>
                        </li>
                        <li>
                            <p>Supprimez les droits d'écriture sur le répertoire <span class="html">~/seance3</span> et supprimez l'extension <span class="em">.bu</span> au fichier <span class="em">fichier.bu</span>, que constatez-vous et pourquoi ?</p>
<pre><code><span class="html">chmod -w .

mv fichier.bu fichier</span>

# erreur car le répertoire est protégé en écriture</code></pre>
                        </li>
                        <li>
                            <p>Repositionnez-vous dans le répertoire de login et supprimez le droit d'exécution sur le répertoire <span class="html">~/seance3</span>.</p>
<pre><code class="html">cd

chmod -x seance3</code></pre>
                        </li>
                        <li>
                            <p>Copiez le fichier <span class="em">fichier.txt</span> dans le répertoire <span class="em">linux</span>.</p>
<pre><code><span class="html">cp seance3/fichier.txt seance3/linux</span>

# KO car plus d'accès au répertoire seance3</code></pre>
                        </li>
                        <li>
                            <p>Remettez les droits d'exécution sur le répertoire <span class="em">seance3</span> en y supprimant le droit de lecture; pouvez-vous afficher le contenu du fichier <span class="em">fichier.txt</span> ?</p>
<pre><code><span class="html">chmod +x,-r .

cat seance3/fichier.txt</span>

# OK mais la complétion du nom du fichier est KO</code></pre>
                        </li>
                        <li>
                            <p>Affichez les droits sur le répertoire <span class="em">seance3</span> et ensuite sur le contenu du répertoire.</p>
<pre><code><span class="html">ls -ld seance3</span>

# pas de souci

<span class="html">ls -l seance3</span>

# KO car pas droit read sur le répertoire</code></pre>
                        </li>
                        <li>
                            <p>Créez un répertoire <span class="em">lesCommandes</span> et pour ce répertoire, donnez les droits <span class="em">rwx</span> pour le propriétaire, <span class="em">r_x</span> pour le groupe et aucun droit pour les autres utilisateurs du système.</p>
<pre><code class="html">mkdir lesCommandes

chmod 750 les Commandes</code></pre>
                        </li>
                        <li>
                            <p>Positionnez l'<sapn class="em">umask</sapn> pour supprimer les droits au groupe et aux autres utilisateurs lors de toute création de fichier. Testez votre solution.</p>
<pre><code class="html">umask 0077

mkdir soumissions

touch fichier1.txt</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_4">Cours n° 4 : Les outils du shell : La redirection :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Les fichiers standards :</h4>
                            <p>Toute application Linux (c'est également vrai sur d'autres systèmes) utilise trois fichiers spéciaux ouverts dès le début de son exécution, ce sont les fichiers <span class="html">stdin</span> (en Java, il s'appelle "System.in"), <span class="html">stdout</span> (en Java, il s'appelle "System.out"), <span class="html">stderr</span> (en Java, il s'appelle "System.err"). En temps normal, le fichier <span class="html">stdin</span> représente le clavier, c'est-à-dire que lire le fichier <span class="html">stdin</span> signifie lire les caractères introduits au clavier. D'autre part, les fichiers <span class="html">stdout</span> et <span class="html">stderr</span> représentent l'écran, c'est-à-dire que ces fichiers envoient leurs données à l'écran de la console; pour <span class="html">stdout</span>, ce sont les messages normaux tandis que pour <span class="html">stderr</span>, ce sont les messages d'erreur.</p>
                        </li>
                        <li>
                            <h4>La redirection :</h4>
                            <p>Le shell, le programme qui sert d'interface entre l'utilisateur et le système, peut offrir un certain nombre de services. Parmi ceux-ci, nous abordons ici la <span>redirection</span>. Ce service permet de modifier les fichiers standards sans rien modifier à l'application exécutée.</p>
                        </li>
                        <li>
                            <h4>La redirection en entrée :</h4>
                            <p>Si l'on désire remplacer la source des caractères introduits au clavier par des lignes de caractères stockées dans un fichier, il n'est pas nécessaire de modiifer le programme, il suffit de demander au shell de rediriger le clavier vers le fichier, l'application exécutée ne fera pas la différence. Pour indiquer cette redirection au shell, il suffit d'utiliser le symbole '<span class="html">&lt;</span>'.</p>
                            <p>Par exemple, la commande <span class="html">wc -l &lt; monFichier.txt</span> introduite au shell va indiquer au système d'approvisionner l'application avec les lignes du fichier <span class="em">monFichier.txt</span>, donc le programme <span class="html">wc</span> va compter le nombre de lignes du fichier <span class="em">monFichier.txt</span> plutôt que celles introduites au clavier.</p>
                        </li>
                        <li>
                            <h4>La redirection en sortie :</h4>
                            <p>Si l'on désire enregistrer les caractères produits par l'application plutôt que de les afficher à l'écran, il suffit de demander au shell de rediriger l'output standard vers le fichier, l'application exécutée ne verra pas la différence. Pour indiquer cette redirection au shell, il suffit d'utiliser le symbole '<span class="html">&gt;</span>'.</p>
                            <p>Par exemple, la commande <span class="html">ls -l &gt; maListe.txt</span> introduite au shell va indiquer au système d'ajouter le résultat de l'application <span class="html">ls</span> au contenu déjà présent dans le fichier <span class="em">maListe.txt</span>, plutôt à l'écran; si le fichier existe, il est supprimé.</p>
                        </li>
                        <li>
                            <h4>La redirection en sortie par ajout :</h4>
                            <p>La redirection d'output peut se faire en ajoutant les données au fichier spécifié. Pour indiquer cette indirection au shell, il suffit le symbole '<span class="html">&gt;&gt;</span>.</p>
                            <p>Par exemple, la commande <span class="html">ls - l &gt;&gt; maListe.txt</span> introduite au shell va indiquer au système d'ajouter le résultat de l'application <span class="html">ls</span> au contenu déjà présent dans le fichier <span class="em">maListe.txt</span>. Si le fichier n'xiste pas, il sera créé.</p>
                        </li>
                        <li>
                            <h4>La redirection des messages d'erreur :</h4>
                            <p>Si l'on désire récupérer les messages d'erreurs écrits par une application, il est possible de spécifier au shell lors de l'appel de la commande que la destination de ces messages est modifiée et que ces messages doivent être sauvés dans un fichier plutôt qu'à l'écran. Pour indiquer cette redirection au shell, il suffit d'utiliser le symbole '<span class="html">2&gt;</span>.</p>
                            <p>Par exemple, la commande <span class="html">mkdir monRep 2&gt; mesErreurs.err</span> introduite au shell va indiquer au système de sauver les messages d'erreur générés par l'application <span class="html">mkdir</span> dans le fichier <span class="em">mesErreurs.err</span>, plutôt qu'à l'écran.</p>
                        </li>
                        <li>
                            <h4>Le pipe :</h4>
                            <p>C'est le mécanisme de redirection qui permet de fournir à un processus l'output standard d'un autre processus, c'est le shell qui gère le mécanisme de transfert des données. Il suffit d'utiliser le symbole '<span class="html">|</span>' entre les deux applications.</p>
                            <p>Par exemple, la commande <span class="html">ls | wc -l</span> introduite au shell va compter le nombre de lignes écrites par la commande <span class="html">ls</span>, c'est-à-dire que l'ensemble des deux commandes va fournir le nombre de fichiers du répertoire courant.</p>
                        </li>
                        <li>
                            <h4>La substitution de commande :</h4>
                            <p>Ce n'est pas à proprement parler de la redirection, mais c'est malgré tout la récupération de l'output standard d'une application. Ces données récupérées de <span class="html">stdout</span> sont fournies en argument à une autre commande. Pour indiquer au shell cette substitution de commande, il faut utiliser les caractères backquotes '<span class="html">`</span>'.</p>
                            <p>Par exemple, la commande <span class="html">echo il y a `ls | wc -l` fichiers dans le répertoire.</span> introduite au shell va compter le nombre de lignes écrites par la commande <span class="html">ls</span> et utiliser ce nombre comme argument de la commande <span class="html">echo</span>.</p>
                            <p>Il est possible d'utiliser une autre notation pour indiquer la substitution de commande : <span class="html">$(cmd)</span>.</p>
                        </li>
                        <li>
                            <h4>Les filtres :</h4>
                            <p>Ce sont des applications qui traitent des données reçues sur <span class="html">stdin</span> et qui écrivent le résultat sur <span class="html">stdout</span>.</p>
                            <ol>
                                <li>
                                    <h5>Affichage à l'écran (l'output n'est pas écrit sur <span class="html">stdout</span> mais directement à l'écran) :</h5>
                                    <ol>
                                        <li><span class="html">more</span>, <span class="html">less</span> : affichage écran par écran</li>
                                        <li><span class="html">tee</span> :  envoie de l'output sur <span class="html">stdout</span> et en même temps dans un fichier</li>
                                    </ol>
                                </li>
                                <li>
                                    <h5>Output normal (peuvent recevoir des fichiers en argument à la place de lire sur <span class="html">stdin</span>) :</h5>
                                    <ol>
                                        <li><span class="html">cat</span> : concatène le contenu des fichiers donnés en argument et l'écrit sur <span class="html">stdout</span>, sans argument <span class="html">cat</span> lit sur <span class="html">stdin</span></li>
                                        <li><span class="html">tac</span> : idem mais en inversant l'ordre des lignes des fichiers</li>
                                        <li><span class="html">head</span> :  affiche les premières lignes de <span class="html">stdin</span></li>
                                        <li><span class="html">tail</span> : affiche les dernières lignes de <span class="html">stdin</span></li>
                                    </ol>
                                </li>
                                <li>
                                    <h5>Traitement du contenu de <span class="html">stdin</span> :</h5>
                                    <ol>
                                        <li><span class="html">grep</span> : sélectionne certaines lignes de <span class="html">stdin</span> (en utilisant les reg exp)</li>
                                        <li><span class="html">wc</span> : compte le nombre de caractères, de lignes, de mots</li>
                                        <li><span class="html">sort</span> : trie les lignes</li>
                                        <li><span class="html">od</span> : dump de <span class="html">stdin</span> ou du fichier</li>
                                        <li><span class="html">nl</span> : numérote les lignes</li>
                                        <li><span class="html">tr</span> : traduit les lignes</li>
                                        <li><span class="html">cut</span> : coupe les lignes</li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>Les fichiers spéciaux :</h4>
                            <p>Linux possède dans le répertoire <span class="html">/dev</span> des fichiers spéciaux. Celui qui nous intéresse le plus est le fichier <span class="html">/dev/null</span> qui est un fichier poubelle qui absorbe les données pour les ignorer.</p>
                            <p>Par exemple, la commande <span class="html">find / 2&gt; /dev/null</span> va exécuter la commande <span class="html">find</span> en ignorant les messages d'erreur qui sont redirigés vers ce fichier poubelle.</p>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <h4>La redirection simple :</h4>
                    <ol>
                        <li>
                            <p>Récupérez la liste longue des fichiers du répertoire racine dans le fichier <span class="em">racine.txt</span>.</p>
<pre><code class="html">ls -l &gt; racine.txt</code></pre>
                        </li>
                        <li>
                            <p>Affichez le nombre de lignes contenues dans le fichier <span class="html">racine.txt</span> que vous venez de créer.</p>
                            <ol>
                                <li>
                                    <p>Sans redirection :</p>
<pre><code class="html">wc -l racine.txt</code></pre>
                                </li>
                                <li>
                                    <p>Avec redirection :</p>
<pre><code class="html">wc -l &lt; racine.txt</code></pre>
                                </li>
                                <li>
                                    <p>Quelle est la différence entre ces deux solutions ?</p>
<pre><code># Sans redirection, la commande gère le fichier et donc elle connaît son nom et le donne, avec redirection la commande ignore l'origine des données.</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">u1bin000</span> dans le répertoire racine de l'arborescence, les messages d'erreurs seront stockés dans le fichier <span class="em">mesErreurs.txt</span>.</p>
<pre><code class="html">mkdir /u1bin000 2&gt; ~/mesErreurs.txt</code></pre>
                        </li>
                        <li>
                            <p>Stockez dans le fichier <span class="em">bin.cmd</span> la liste des commandes du répertoire <span class="html">/bin</span>, précédée du nom répertoire. Faites de même avec les commandes du répertoire <span class="html">/usr/bin</span> dans le fichier <span class="html">usrBin.cmd</span> (en plusieurs commandes).</p>
<pre><code><span class="html">echo "/bin" &gt; bin.cmd; ls /bin &gt;&gt; bin.cmd;</span>

# idem pour /usr/bin</code></pre>
                        </li>
                        <li>
                            <p>Stockez dans le fichier <span class="em">lesCommandes.linux</span> le contenu des 2 fichiers précédents.</p>
<pre><code class="html">cat bin.cmd usr.cmd &gt; ~/lesCommandes.linux</code></pre>
                        </li>
                        <li>
                            <p>Affichez page à page, le contenu de ce fichier.</p>
<pre><code><span class="html">less ~/lesCommandes.linux</span>

# la redirection n'est pas nécessaire</code></pre>
                        </li>
                        <li>
                            <p>Créez un fichier <span class="html">entete.txt</span> qui contient une ligne composée du caractère <span class="em">#</span> suivi de votre nom, de votre prénom et du numéro de votre série, en utilisant la commande <span class="html">cat</span>.</p>
<pre><code class="html">cat &gt; entete.txt

&lt;ctrl+d&gt;</code></pre>
                        </li>
                    </ol>
                    <h4>Le pipe :</h4>
                    <ol>
                        <li>
                            <p>Donnez la combinaison de commandes qui permet d'afficher le nombre de fichiers de la directory de login.</p>
<pre><code class="html">ls ~ | wc -l</code></pre>
                        </li>
                        <li>
                            <p>Comment afficher la liste numérotée et en majuscule des fichiers du répertoire de login.</p>
<pre><code><span class="html">ls | nl | tr "a-z" "A-Z"</span>

# ou encore

<span class="html">ls ~ | tr [:lower:] [:upper:] | nl</span></code></pre>
                        </li>
                        <li>
                            <p>Affichez écran par écran le contenu du répertoire au moyen de la commande <span class="html">ls -l</span>.</p>
<pre><code><span class="html">ls -l | less</span>
 
# donne une liste longue (les propriétés) des fichiers</code></pre>
                        </li>
                    </ol>
                    <h4>Exercices complémentaires :</h4>
                    <ol>
                        <li>
                            <p>À partir des fichiers <span class="em">bin.cmd</span> et <span class="em">usr.cmd</span>, créez le fichier <span class="em">lesCommandes2.linux</span> dont la 1<sup>ère</sup> ligne est "Les commandes de Linux" et qui contient toutes les commandes stockées dans ces fichiers.</p>
<pre><code class="html">echo "Les commandes de Linux" &gt; lesCommandes2.linux

tail -n+2 bin.cmd &gt;&gt; lesCommandes2.linux

tail -n+2 usrBin.cmd &gt;&gt; lesCommandes.linux</code></pre>
                        </li>
                        <li>
                            <p>Copiez dans le fichier <span class="em">dump.txt</span> le contenu en hexadécimal du fichier que vous venez de créer et affichez -le à l'écran.</p>
<pre><code class="html">od lesComandes2.linux | cut -c "8-" | tee dump.txt</code></pre>
                        </li>
                        <li>
                            <p>La commande <span class="html">find /</span> permet de parcourir l'arborescence de votre <span class="em">file system</span> de manière récursive. Utilisez cette commande pour compter le nombre de fichiers auquel vous avez accès dans tout le file system de votre machine en évitant d'être pollué par les mssages d'erreur.</p>
<pre><code class="html">find / 2&gt; /dev/null | wc -l</code></pre>
                        </li>
                        <li>
                            <p>Ajoutez dans le fichier <span class="em">entete.txt</span> une ligne commençant par le caractère "<span class="em">#</span> et contenant la datesous la forme 'nom_du_jour nr_du_jour nom_du_mois année'.</p>
<pre><code class="html">echo # `date "+%A %d %B %Y"` &gt;&gt; entete.txt</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_5">Cours n° 5 : Les outils du shell : alias, history, variables, ... :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>En mode de commandes, l'utilisateur accède au système grâce à un programme spécial, le <spen class="em">shell</spen>. Le monde Unix propose à l'utilisateur plusieurs programmes shells différents : en Linux, le shell par défaut est le <span class="html">bash</span>. Les fonctionnalités offertes par les différents shells sont assez semblables, même si la syntaxe peut parfois être différennte.</p>
                        </li>
                        <li>
                            <h4>Les différents modes :</h4>
                            <p>Le shell peut fonctionner dans différents modes, en fonction de la manière dont il est invoqué.</p>
                            <ol>
                                <li>
                                    <p>En ouverture de session, au login, on démarre un <span class="em">shell de login</span>; le programme qui s'exécute est le programme spécifié dans l'enregistrement du fichier<span class="html">/etc/passwd</span>, lié à l'utilisateur</p>
                                    <p>Par exemple, pour l'utilisateur <span class="em">u1bin</span> enregistré dans le fichier <span class="html">/etc/passwd</span>, u1bin:x:1003:1003::/home/u1bin:/bin/bash, le répertoire de login est <span class="em">/home/u1bin</span> et son shell de login est <span class="em">bash</span>. C'est un <span class="em">shell interactif</span>, c'est-à-dire que sa fonction principale est d'interpréter les caractères introduits au clavier par l'utilisateur.</p>
                                </li>
                                <li>
                                    <p>À l'ouverture d'un xterm ou en lançant le programme (<span class="html">bash</span>, <span class="html">/bin/su</span>, ...), le shell est un <span class="em">shell non-login</span>.</p>
                                </li>
                                <li>
                                    <p>Le troisième mode, le <span class="em">shell non-interactif</span>, est exécuté à l'appel d'un script.</p>
                                </li>
                            </ol>
                            <p>Suivant ces différents modes, il y a une exécution automatique de fichiers de démarrage (startup files). Ces fichiers de configuration permettent d'initialiser l'environnement de travail : instancier certaines variables (par exemple <span class="html">PATH</span>), exécuter des commandes de configuration (par exemple <span class="html">umask</span>), ...</p>
                            <p>Dans un shell de login, les fichiers de configuration sont les fichiers <span class="html">/etc/profile</span> (pour les configurations communes à tous les utilisateurs) et <span class="html">~/.bash_profile</span> (pour les particularités de l'utilisateur).</p>
                            <p>Le démarrage du shell interactif non-loginrécupère l'environnement de travail et exécute le fichier <span class="html">~/.bashrc</span>.</p>
                            <p>Le shell non-interactif n'exécute aucun fichier de démarrage, mais il récupère l'environnement du shell d'origine.</p>
                            <p>En fin de session, il y a exécution éventuelle du fichier <span class="html">~/.bash_logout</span>.</p>
                        </li>
                        <li>
                            <h4>Les services du shell :</h4>
                            <p>À côté de l'interprétation et de l'exécution des commandes, le shell offre une série de services qui aident l'utilisateur. Le premier service déjà abordé est la <span class="em">redirection</span>. Nous allons maintenant voir d'autres services offerts par le <span class="em">bash</span>.</p>
                            <ol>
                                <li>
                                    <h5>La gestion des variables :</h5>
                                    <p>Dans les shells, il existe deux sortes variables, les <span class="em">variables locales</span> et les <span class="em">variables d'environnement</span>. Les variables sont définies lors de leur première affectation <span class="html">maVariable=uneValeur</span>.</p>
                                    <p>L'utilisation du contenu d'une variable se fait grâce à l'opérateur <span class="html">$</span>.</p>
                                    <p>Par exemple, <span class="html">echo $maVariable</span>.</p>
                                    <p>Les variables d'environnement sont des variables (+/- globales) accessibles dans les processus démarrés à partir du shell.</p>
                                    <p>Il existe des variables d'environnement prédéfinies dans le shell qui permettent de configurer le shell par exemple<span class="em">PATH=/usr/local/bin:/usr/bin:/bin</span> et l'utilisateur peut définir ses propres variables d'environnement en exportant la variable (le nom de la variable doit être en majuscule) : <span class="html">export MA_VARIABLE</span>.</p>
                                    <p>Remarque : les caractères spéciaux tels que le <span class="html">$</span> peuvent être protégés pour perdre leur fonctionnalité dans <span class="em">quotes</span> (apostrophes) ou par le caractère <span class="html">|</span>, mais le caractère <span class="html">$</span> garde sa signification dans les <span class="em">doubles quotes</span> (guillemets).</p>
                                    <p>Donc, <span class="html">echo $maVariable</span> et <span class="html">echo "$maVariable"</span> affiche le contenu de la variable tandis que <span class="html">echo '$maVariable'</span> et <span class="html">echo \$maVariable</span> affiche <span class="em">$maVariable</span>.</p>
                                </li>
                                <li>
                                    <h5>Certaines commandes internes :</h5>
                                    <p>Les commandes les plus fréquemment utilisées sont reprogrammés dans le shell pour réduire le temps de recherche et d'exécution de la commande.</p>
                                    <p>Pour retrouver le type des commandes, on peut utiliser la commande <span class="html">type</span>. Par exemple, <span class="html">type ls</span>.</p>
                                    <p>Les commandes externes doivent être appelées par le nom absolu mais le shell offre dans la variable d'environnement <span class="html">PATH</span> une liste de répertoires qui peuvent permettre de construire ce path absolu.</p>
                                    <p>Par exemple, grâce au contenu de la variable PATH, <span class="em">PATH=/usr/local/bin:/usr/bin:/bin</span> quand on tape la commande <span class="html">mkdir</span>, le shell construit les paths <span class="em">/usr/local/bin/mkdir</span>, <span class="em">/usr/bin/mkdir</span> ou <span class="em">/bin/mkdir</span> et peut ainsi retrouver la commande voulue par l'utilisateur.</p>
                                    <p>Les commandes peuvent être enchaînées sur une seule ligne (un seul '<span class="html">\n</span>') :</p>
                                    <ul>
                                        <li>
                                            <p>soit de manière inconditionnelle par '<span class="html">;</span>' : <span class="html">ls - l ; cd monRep</span></p>
                                        </li>
                                        <li>
                                            <p>soit de manière conditionnelle <span class="html">&&</span> la deuxième commande est exécutée si la première a réussi sont traitement <span class="html">code = 0</span>) (<span class="html">||</span> la deuxième commande est exécutée si la première a retourné un <span class="html">code &gt; 0</span>).</p>
<pre><code class="html">ls monRep || mkdir monRep # je crée le répertoire s'il n'existe pas

ls monRep && cd monRep # je change de répertoire s'il existe</code></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h4>Les alias :</h4>
                                    <p>Dans le shell, un <span class="em">alias</span> est un raccourci vers une commande. L'alias se crée au moyen de la commande <span class="html">alias</span>.</p>
                                    <p>Par exemple, <span class="html">alias ll='ls -l'</span> crée un alias qui s'appelle la commande <span class="html">ll</span> et qui appelle la commande <span class="html">ls -l</span>. La commande <span class="html">alias</span> sans argument affiche la liste des alias et la commande <span class="html">unalias</span> supprime un alias. Attention, l'alias est local au shell et disparaît à la fin du shell. Pour le retrouver dans chaque shell, il faut le définir dans un fichier de configuration.</p>
                                </li>
                                <li>
                                    <h4>L'history :</h4>
                                    <p>L'<span class="html">history</span>est le service du shell qui permetde stocker les commandes introduites de manière à pouvoir les récupérer. L'history est local au shell mais peut être sauvé à la fin du shell.</p>
                                    <p>La récupération d'une commande de l'history se fait à l'usage de la touche '<span class="html">&#8593;</span>' ou du caractère '<span class="html">!</span>'.</p>
                                    <p>Les commandes récupérées par la touche '<span class="html">&#8593;</span> peuvent être modifiées directement tandis que les commandes récupérées par le caractère '<span class="html">!</span>' doivent être exploitées pour en extraire un élément et éventuellement pour le modifier.</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">!n</span> : Récupération d'une commande par son numéro absolu</p>
                                        </li>
                                        <li>
                                            <p><span class="html">!-n</span> : Récupère d'une commande en remontant dans l'history de <span class="em">n</span> commandes</p>
                                        </li>
                                        <li>
                                            <p><span class="html">!str</span> : Récupération de la dernière commande commençant la chaîne <span class="em">str</span></p>
                                        </li>
                                        <li>
                                            <p><span class="html">!?str?</span> : Récupération de la commande contenant la chaîne <span class="em">str</span></p>
                                        </li>
                                        <li>
                                            <p>Un format particulier permet de modifier la dernière commande introduite : <span class="html">^abc^def</span>. Après la commande <span class="html">mkdir fichier1</span>, la modification <span class="html">^1^2</span> va permettre d'exécuter la commande <span class="html">mkdir fichier2</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h4>La complétion :</h4>
                                    <p>La complétion est une facilité apportée par bash pour compléter automatiquement les noms de fichiers à partir des premiers caractères introduits par l'utilisateur.</p>
                                    <p><span class="html">&lt;tab&gt;</span> complète jusqu'à rencontrer une ambiguïté.</p>
                                    <p><span class="html">&lt;tab&gt;&lt;tab&gt;</span> donne la liste des noms possibles.</p>
                                </li>
                                <li>
                                    <h4>Les méta-caractères (globbing) :</h4>
                                    <p>Ce sont des caractères qui ont une signification particulière dans le nom des fichiers du répertoire considéré :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">*</span> représente 0, 1 ou plusieurs caractères. Par exemple, <span class="html">ls -l *.java</span> donne la liste des fichiers d'extension java.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">?</span> représente 1 caractère. Par exemple, <span class="html">rm fichier.?</span> supprime tous les fichiers d'extension sur un caractère.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">[a-r]</span> ou <span class="html">[abcde]</span> représente un quelconque caractère de la liste indiquée entre les crochets soit par une intervalle, soit par une liste complète. Par exemple, <span class="html">cp fichier[0-5] /tmp</span> copie les fichiers dont le nom commence par <span class="em">fichier</span> et se termine par un chiffre compris entre 0 et 5.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <h4>History :</h4>
                    <ol>
                        <li>
                            <p>En utilisant au mieux les faciliés offertes par l'<span class="html">history</span>, créez le répertoire <span class="em">exercicesShell</span> et déplacez-vous y pour créer les fichiers <span class="em">test.txt</span> et <span class="em">test.bu</span>.</p>
<pre><code class="html">mkdir exercicesShell

cd !$

touch test.txt

^txt^bu</code></pre>
                        </li>
                        <li>
                            <p>Rappelez la commande <span class="html">ls</span> préccédemment introduite.</p>
<pre><code class="html">!ls</code></pre>
                        </li>
                    </ol>
                    <h4>Les commandes :</h4>
                    <ol>
                        <li>
                            <p>Parmi les commandes suivantes, citez celles qui sont internes au shell, les commandes du répertoire <span class="html">/bin</span> et celle du répertoire <span class="html">/usr/bin</span>: (<span class="html">cd</span>, <span class="html">chmod</span>, <span class="html">cp</span>, <span class="html">date</span>, <span class="html">echo</span>, <span class="html">head</span>, <span class="html">pwd</span>, <span class="html">whoami</span>).</p>
<pre><code class="html">type nom_de_la_commande</code></pre>
                            <ul>
                                <li>
                                    <p><span class="em">interne</span> : <span class="html">cd</span>, <span class="html">echo</span>, <span class="html">pwd</span></p>
                                </li>
                                <li>
                                    <p><span class="em">/bin</span> : <span class="html">cp</span>, <span class="html">date</span>, <span class="html">touch</span></p>
                                </li>
                                <li>
                                    <p><span class="em">/usr/bin</span> : <span class="html">head</span>, <span class="html">whoami</span></p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h4>Les variables :</h4>
                    <ol>
                        <li>
                            <p>Affichez le contenu de la variable <span class="html">PATH</span> puis supprimez son contenu et vérifiez.</p>
<pre><code class="html">echo $PATH; PATH=

!echo</code></pre>
                        </li>
                        <li>
                            <p>Déplacez-vous dans le répertoire parent.</p>
<pre><code class="html">cd ..</code></pre>
                        </li>
                        <li>
                            <p><span class="html">Affichez le contenu du répertoire courant (que se passe-t-il ?).</span></p>
<pre><code><span class="html">ls</span>

# problème à cause de $PATH vide</code></pre>
                        </li>
                        <li>
                            <p>Positionnez la variable PATH avec la valeur <span class="em">/usr/bin:/bin:</span> et rappelez la commande <span class="html">ls</span>.</p>
<pre><code class="html">PATH=/usr/bin:/bin:; !ls</code></pre>
                        </li>
                        <li>
                            <p>Comment afficher une ligne contenant le texte "<span class="em">$PATH contient ...</span>" où <span class="em">...</span> représente le contenu de la variable PATH ?</p>
<pre><code class="html">echo "\$PATH contient $PATH"</code></pre>
                        </li>
                    </ol>
                    <h4>Alias :</h4>
                    <ol>
                        <li>
                            <p>Affichez la liste des alias.</p>
<pre><code class="html">alias</code></pre>
                        </li>
                        <li>
                            <p>Créez un alias <span class="em">h</span> qui affiche l'history et testez-le.</p>
<pre><code class="html">alias h=history; h</code></pre>
                        </li>
                        <li>
                            <p>Créez un alias qui modifie l'usage de la commande <span class="html">rm</span> en lui imposant l'option <span class="html">-i</span>.</p>
<pre><code class="html">alias rm="rm -i"</code></pre>
                        </li>
                        <li>
                            <p>Testezl'alias en supprimant le fichier <span class="em">test.bu</span>.</p>
<pre><code class="html">rm exercicesShell/test.bu</code></pre>
                        </li>
                        <li>
                            <p>Comment éviter l'usage de cet alias pour imposer une suppression de fichier sans demander de confirmation ?</p>
<pre><code class="html">/bin/rm fichier</code></pre>
                        </li>
                    </ol>
                    <h4>Globbing :</h4>
                    <ol>
                        <li>
                            <p>Donnez la commande qui affiche la liste des fichiers du répertoire <span class="html">/usr/bin</span> dont le nom commence par la lettre <span class="em">z</span>.</p>
<pre><code class="html">ls /usr/bin/z*</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui compte tous les fichiers du répertoire <span class="html">/usr/bin</span> dont le nom contient au moins 2 lettres <span class="em">a</span>. Combinez les commandes <span class="html">ls</span> et <span class="html">wc</span>.</p>
<pre><code class="html">ls /usr/bin/*a*a* | wc -l</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des fichiers du répertoire <span class="html">/usr/bin</span> dont le nom contient la lettre <span class="em">y</span> ou <span class="em">z</span>.</p>
<pre><code class="html">ls /usr/bin/*[yz]*</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des fichiers du répertoire <span class="html">/usr/bin</span> dont le nom est formé de 3 lettres.</p>
<pre><code class="html">ls -d /usr/bin/???</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des fichiers du répertoire <span class="html">/usr/bin</span> dont le nom contient au moins une voyelle majuscule.</p>
<pre><code><span class="html">ls /usr/bin/*[AEIOUY]*</span>

# ou encore

<span class="html">ls /usr/bin/*[:VOYEL:]*</span></code></pre>
                        </li>
                    </ol>
                    <h4>Exercice supplémentaire :</h4>
                    <ol>
                        <li>
                            <p>Reprenez l'exercice 5 sur les variables mais en affichant les différents répertoires un par ligne.</p>
<pre><code class="html">echo "\$PATH contient $PATH" | tr : \\n</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_6">Cours n° 6 : Exercices Linux : find et grep :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p><span class="html">find</span> et <span class="html">grep</span> sont deux commandes Linux qui effectuent des recherches. <span class="em html">Mais la comparaison s'arrête là</span> car <span class="html">find</span> travaille sur le <span class="em">file system</span> et recherche des fichiers tandis que <span class="html">grep</span> analyse des lines de texte (sur <span class="html">stdin</span> ou dans un fichier) et sélectionne celles qui correspondent à un motif (une exrpression régulière (RegExp ou plus exactement expression rationnelle)).</p>
                        </li>
                        <li>
                            <h4>La commande find :</h4>
                            <p>La commande <span class="html">find</span> permet de rechercher dans une arborescence une série de fichiers. Les critères de sélection sont basés sur les propriétés des fichiers. De plus, la commande <span class="html">find</span> permet d'effectuer des actions sur les fichiers qui correspondent aux critères spécifiés lors de l'appel de la commande.</p>
                            <p>La commande travaille de manière récursive à partir d'un ou de plusieurs répertoires spécifiés en argument à la commande.</p>
                            <ol>
                                <li>
                                    <h5>La syntaxe :</h5>
                                    <p>La commande <span class="html">find</span> reçoit en argument une liste de répertoires, points de départ d'arborescences du <span class="em">file system Linux</span> et une liste d'éoptions" spécifiant les critères de sélection et les actions à appliquer aux fichiers trouvés.</p>
<pre><code class="html">find [rep [...]] [-critère [...]] [-action [...]]</code></pre>
                                    <ul>
                                        <li>
                                            <p>Si l'utilisateur ne spécifie aucun répertoire en argument, la commande traite le répertoire courant.</p>
                                        </li>
                                        <li>
                                            <p>Si l'utilisateur ne donne aucun critère de sélection, la commande sélectionne tous les fichiers de l'arborescence.</p>
                                        </li>
                                        <li>
                                            <p>Si l'utilisateur n'indique aucune action, la commande affiche le nom du fichier sur <span class="html">stdout</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Les critères de sélection :</h5>
                                    <ol>
                                        <li>
                                            <p>Si plusieurs critères sont introduits lors de l'appel de la commande, ils sont combinés par un opérateur implicite "et", c'est-à-dire que les fichiers doivent respecter tous les critères pour être sélectionnés. Mais il est également possible de spécifier des opérateurs booléens (voir man).</p>
                                        </li>
                                        <li>
                                            <h6>Sur le type : -type :</h6>
                                            <p>La sélection peut limiter les fichiers retenus en se basant sur le type de fichiers : les principaux types utilisés par ce critère sont <span class="html">d</span> (directory : répertoire), <span class="html">f</span> (fichier) et <span class="html">l</span> (lien symbolique).</p>
<pre><code class="html">find . -type d # sélectionne tous les répertoires de l'arborescence issue du répertoire courant.</code></pre>
                                        </li>
                                        <li>
                                            <h6>Sur le nom : -name :</h6>
                                            <p>La sélection se base sur le nom des fichiers (le critère pour interpréter les caractères du globbing du shell).</p>
<pre><code class="html">find . -type f -name "*.txt" # sélectionne tous les fichiers réguliers dont le nom se termine par .txt</code></pre>
                                        </li>
                                        <li>
                                            <h6>Les critères basés sur des valeurs numériques :</h6>
                                            <p>Les paramètres numériques peuvent être données :</p>
                                            <ul>
                                                <li>
                                                    <p>soit de manière absolue (<span class="em">n</span>), la valeur vaut juste <span class="em">n</span></p>
                                                </li>
                                                <li>
                                                    <p>soit de manière positive (<span class="em">+n</span>), ce qui signifie supérieure à <span class="em">n</span></p>
                                                </li>
                                                <li>
                                                    <p>soit de manière négative (<span class="em">-n</span>), ce qui signie inférieure à <span class="em">n</span></p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h6>Sur les horodatages : mtime, ctime et atime :</h6>
                                            <p>Les trois horodatages mémorisés dans l'inode sont utilisables comme critère de délecton de find. Le paramètre numérique est interprété comme un multiple de 24 heures.</p>
                                            <ul>
                                                <li>
                                                    <p><span class="em">n</span> : Par exemple, la commande <span class="html">find ~ -mtime 7</span> permet de rechercher tous les fichiers du répertoire courant dont la dernière modification a été apportée il y a une semaine.</p>
                                                </li>
                                                <li>
                                                    <p><span class="em">+n</span> : <span class="html">find ~ -mtime +7</span> sélectionne tous les fichiers dont la dernière modification date de plus d'une semaine (plus vieux que <span class="em">7*24heures</span>).</p>
                                                </li>
                                                <li>
                                                    <p><span class="em">-n</span> : <span class="html">find ~ -mtime -7</span> sélectionne tous les fichiers dont la dernière modification a été réalisée dans la semaine (plus récent que <span class="em">7*24heures</span>).</p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h6>Sur les droits : -perm :</h6>
                                            <p>Les droits peuvent être utilisés comme critère de sélection.</p>
                                            <ul>
                                                <li>
                                                    <p><span class="html">-perm mode</span> : le fichier doit avoir les mêmes droits que ceux dnnés par <span class="em">mode</span>.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">-perm -mode</span> : le fichier doit avoir au moins tous les droits spécifiés dans <span class="em">mode</span> (éventuellement d'autres droits peuvent être positionnés sur le fichier).</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">-perm /mode</span> (<span class="html">+mode</span> dépréciée) : au moins un des droits donnés dans <span class="em">mode</span> oit être positionné sur le fichier.</p>
                                                </li>
                                            </ul>
                                            <p>Le mode peut être spécifié soit dans sa forme octale, soit symbolique. Par exemple :</p>
                                            <ul>
                                                <li>
                                                    <p><span class="html">find ~ -perm 0777</span> : tous les fichiers qui ont tous les droits.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">find ~ -perm -0444</span>(<span class="html">-ugo=w</span>) : tous les fichiers modifiables par le propriétaire et le groupe et les autres utilisateurs système.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">find ~ -perm /0444</span>(<span class="html">/ugo=w</span>) : tous les fichiers modifiables par le propriétaire, le groupe ou même les autres utilisateurs du système.</p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <p>D'autres critères de sélection peuvent être spécifiés (voir man).</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h5>Les actions :</h5>
                                    <ol>
                                        <li>
                                            <p><span class="html">-exec</span> : permet d'exécuter une commande sur chaque fichier sélectionné.</p>
<pre><code class="html">find ~ -name "*.tmp" -exec rm {} \;</code></pre>
                                            <p>où <span class="em">{}</span> représente le nom de chaque fichier sélectionné.</p>
                                            <p>où <span class="em">;</span> marque la fin de la commande à exécuter.</p>
                                            <p>où <span class="em">\</span> protège le caractère de son interprétation par le shell.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-ok</span> : semblable à la précédente mais avec demande de confirmation.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-ls</span> : exécute la commande <span class="html">ls</span> sur les fichiers sélectionnés.</p>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>La commane grep :</h4>
                            <p>La commande <span class="html">grep</span> est une commande filtre de Linux qui sélectionne certaines lignes d'entrée (<span class="html">stdin</span> ou fichier(s)) et les écrit sur <span class="html">stdout</span>.</p>
                            <ol>
                                <li>
                                    <h5>La syntaxe :</h5>
<pre><code class="html">grep [options] motif [fichier [...]]</code></pre>
                                    <p>Le motif est obligatoire et représente une expression régulière, la commande accepte un ou plusieur(s) en argument (par défaut lit sur <span class="html">stdin</span>).</p>
                                </li>
                                <li>
                                    <h5>Les options :</h5>
                                    <ul>
                                        <li>
                                            <p><span class="html">-E</span> (<span class="em">egrep</span>) : utilise des expressions régulières étendues.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-v</span> : inverse la sélection.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-l</span> : donne le nom des fichiers sans afficher les lignes sélectionnées.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-L</span> : donne uniquement le nom des fichiers qui ne contiennent aucune ligne correspondant au motif.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-o</span> : affiche uniquement la partie des lignes correspondant au motif.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-q</span> (quiet)^n'affiche rien mais positionne le <span class="em">return code</span>.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-n</span> : affiche le numéro de la ligne.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Les expressionnes rationnelles (RegExp) :</h5>
                                    <ol>
                                        <li>
                                            <h6>Les caractères de base :</h6>
                                            <p>La plupart des caractères se correspondent à eux-mêmes. Les méta-caractères (qui ont une signification particulière) doivent être échappés (<span class="html">\</span>) pour représenter le caractère (sans sa fonctionnalité).</p>
                                        </li>
                                        <li>
                                            <p>Le caractère '<span class="html">.</span>' représente n'importe quel caractère.</p>
                                        </li>
                                        <li>
                                            <h6>Les ancres :</h6>
                                            <p>Le caractère '<span class="html">^</span>' représente une chaîne vide en début de ligne et '<span class="html">$</span>' en fin de ligne : '<span class="html">^[0-9]</span>' recherche les lignes qui commencent par un chiffre.</p>
                                        </li>
                                        <li>
                                            <h6>Les listes :</h6>
                                            <p>Les <span class="html">[]</span> donne une liste de caractères qui peuvent correspondre à un caractère des lignes traitées, la liste peut être donnée par extension (en donnant tous les caractères <span class="html">[azerty]</span>) ou par intervalle (<span class="html">[a-z0-9]</span>). Le caractère <span class="html">^</span> en début de liste inverse la liste (<span class="html">[^a-z]</span> tous les caractères sauf les lettres minuscules).</p>
                                        </li>
                                        <li>
                                            <h6>Les classes prédéfinies :</h6>
                                            <p><span class="html">[:alpha:]</span>, <span class="html">[:alnum:]</span>, <span class="html">[:digit:]</span>, <span class="html">[:lower:]</span>, ...</p>
                                        </li>
                                        <li>
                                            <h6>Les quantificateurs :</h6>
                                            <p>Certains méta-caractères représentent un quantificateur qui s'applique au caractère précédent :</p>
                                            <ul>
                                                <li>
                                                    <p><span class="html">?</span> : 0 ou 1 fois le caractère précédent.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">*</span> : 0, 1 ou plusieurs fois le caractère précédent.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">+</span> : 1 ou plusieurs fois le caract!re précédent.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">n,m</span> : <span class="html">n</span> à <span class="html">m</span> fois le caractère précédent (<span class="html">{n,}</span>, <span class="html">{,m}</span>, <span class="html">{n}</span>).</p>
                                                </li>
                                                <li>
                                                    <p>exemple : '<span class="html">[a-z]+</span>' : représente une chaîne de au moins une lettre minuscule.</p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <p>Les expressions rationnelles de base (commande<span class="html">grep</span> simple) ignore les méta-caractères : <span class="html">? + { } ( ) .</span></p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <p>Pour les autres règles, référez-vous au <span class="html">man</span>.</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <p>Pour réaliser cette séance d'exercice, vous devez récupérer une archive contenant l'arborescence de test. Pour cela conectez-vous sur l'extra-net et récupérez le fichier seance06.tar. L'installation de l'archive se fait grâce à la commande <span class="html">tar xvf seance06.tar</span>.</p>
                    <h4>find :</h4>
                    <ol>
                        <li>
                            <p>Donnez la liste des fichiers réguliers de l'arborescence <span class="em">seance06</span>.</p>
<pre><code class="html">find seance06 -type f</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des fichiers réguliers d'extension sur 1 caractère de l'arborescence <span class="em">seance06</span>.</p>
<pre><code class="html">find seance06 -name "*.?" -type f</code></pre>
                        </li>
                        <li>
                            <p>Donnez le nombre de fichiers réguliers de l'arborescence <span class="em">seance06</span> dont le nom comprend au moins 1 chiffre.</p>
<pre><code class="html">find seance06 -name "*[0-9]*" -type f | wc -l</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des fichiers (et répertoires) de l'arborescence <span class="em">seance06</span> qui ont l'accès en lecture ou en exécution pour le groupe propriétaire et affichez-en les propriétés.</p>
<pre><code><span class="html">find seance06 -perm /0050 -ls</span>

# ou encore

<span class="html">find seance06 -perm /g+rx -ls</span></code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui compte le nombre de commandes des arborescences <span class="html">/bin</span> et <span class="html">/usr/bin</span> dont le nom est sur 2 caractères et pour lesquels les autres utilisateurs ont un accès en lecture et exécution.</p>
<pre><code class="html">find /usr/bin -perm -o+rx -name "??" 2&gt; /dev/null | wc -l</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des fichiers de l'arborescence <span class="html">/tmp</span> qui ont été accédé cette semaine.</p>
<pre><code class="html">find /tmp -atime -7</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des fichiers de l'arborescence issue du répertoire <span class="html">/usr</span> dont l'inode n'a pas été modifé durant la dernière année (365 jours).</p>
<pre><code class="html">find /usr -ctime +365</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de supprimer (si l'utilisateur le permet) les fichiers réguliers vides de l'arborescence de login.</p>
<pre><code><span class="html">find ~ -type f -size 0 -exec rm -i {} \;</span>

# ou encore

<span class="html">find ~ -type f -empty -ok -exec rm {} \;</span></code></pre>
                        </li>
                    </ol>
                    <h4>grep :</h4>
                    <ol>
                        <li>
                            <p>Donnez les lignes du fichier <span class="em">find.txt</span> qui contiennent le mot <span class="em">find</span>.</p>
<pre><code><span class="html">egrep "find" $(find seance06 -type f -name "find.txt")</span>

# ou encore

<span class="html">egrep "find" seance06/theorie/doc/find.txt</span>

# ou encore

<span class="html">find seance06 -type f -name "find.txt" | egrep "find"</span></code></pre>
                        </li>
                        <li>
                            <p>Donnez les lignes de ce fichier qui commencent et par une lettre majuscule.</p>
<pre><code><span class="html">egrep "^[A-Z]" !$</span>

# ou encore

<span class="html">egrep "^[[:upper:]]" !$</span></code></pre>
                        </li>
                        <li>
                            <p>Donnez toutes les lignes qui se terminent par le caractère '<span class="em">.</span>'.</p>
<pre><code class="html">egrep "\.$" !$</code></pre>
                        </li>
                        <li>
                            <p>Donnez le numéro des lignes de ce fichier qui sont vides.</p>
<pre><code class="html">egrep -n "^$" !$</code></pre>
                        </li>
                        <li>
                            <p>Donnez celles qui ont des mots de plus de 11 lettres minuscules (et non accentuées).</p>
<pre><code class="html">egrep "[a-z]{12,}" !$</code></pre>
                        </li>
                        <li>
                            <p>Donnez celles qui ont au moins une paire de crcochets '<span class="em">[</span>' et '<span class="em">]</span>'.'</p>
<pre><code class="html">egrep "\[.*\]" !$</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des fichiers réguliers du répertoire <span class="em">seance06</span> qui ont les droits de lecture pour le groupe ou les autres utilisateurs.</p>
<pre><code><span class="html">ls -l seance06 | egrep "^-.{3}r..r.."</span>

# ou encore

<span class="html">find seance06 -type f -perm -go+r -ls</span></code></pre>
                        </li>
                        <li>
                            <p>Créez un alias <span class="em">lsd</span> qui permet d'afficher la liste (longue) des répertoires du répertoire courant.</p>
<pre><code class="html">alias lsd="ls -l | egrep ^d"</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de supprimer (en demandant la confirmation) tous les fichiers réguliers se terminant par 2 chiffres et tous les fichiers modifiables par le groupe ou les autres utilisateurs de l'arboresceence <span class="em">java</span>.</p>
<pre><code class="html">find java -type f \( -name "[0-9][0-9]" -o -perm +0022 \) -ok -exec rm {} \;</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste des scripts <span class="html">bash</span> (fichier d'extension <span class="html">sh</span>) dont une ligne contient l'appel du shell (<span class="html">#!/bin/sh</span>).</p>
<pre><code><span class="html">egrep -l '#!/bin/(ba)sh' $(find ~ -type f -name "*.sh")</span>

# ou encore

<span class="html">find ~ -type f -name "*.sh" -exec egrep -l '#!/bin/(ba)?sh'{} \;</span></code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_7">Cours n° 7 : Exercices Linux : Les processus :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Les processus</h4>
                            <p>Un processus est l'instance d'un programme en cours d'exécution. Lorsque vous démarrez une application, que vous ouvrez une fenêtre, etc, vous demandez au système de créer un nouveau processus.</p>
                            <p>Ce nouveau processus reçoit un identifiant le <span class="html">PID</span> (Process ID). Comme les autres ressources, un processus possède un propriétaire <span class="html">UID</span> (User ID, l'utilisateur qui a lancé le processus) et un groupe propriétaire <span class="html">GID</span> (Group ID); mais dans cetains cas, le propriétaire réel peut être modifié pour pouvoir accéder à certaines données, dans ce cas, son <span class="html">EUID</span> (Effective UID) et son <span class="html">EGID</span> (Effective GID) sont différents de l'UID et du GID.</p>
                            <p>Chaque processus est généré à partir d'un processus existant (le processus père <span class="html">PPID</span>). Par exemple, le PPID d'une commande introduite par un utilisateurs et le shell à partir duquel il travaille. Et donc les processus sont organisés sous forme arborescente; le seul processus qui n'a pas de processus père est le processus de PID 1, le processus <span class="html">init</span> qui est exécuté lors du démarrage du système.</p>
                            <p>D'autres propriétés caractérisent les processus : le terminal à partir duquel est démarré le processus (<span class="html">TTY</span>), la mémoire utilisée, l'utilisation du CPU et l'état du processus.</p>
                        </li>
                        <li>
                            <h4>Les états d'un processus :</h4>
                            <p>Étant multitâche, Linux partage le processeur entre différents processus. Il y a donc plusieurs états pour ses processus.</p>
                            <ul>
                                <li>
                                    <p>À la création du processus, il est dans l'état <span class="em">nouveau</span>,</p>
                                </li>
                                <li>
                                    <p>ensuite, il passe dans l'état <span class="em">prêt</span>, c'est-à-dire qu'il est prêt à utiliser le processeur, mais il attend que le processus <span class="em">shedulder</span> (le processus qui gère les processus) lui accorde l'accès au processeur.</p>
                                </li>
                                <li>
                                    <p>Dès qu'il obtient cet accès, il passe dans l'état <span class="em">élu</span> et il y reste jusqu'à ce qu'il soit interrompu</p>
                                </li>
                                <li>
                                    <p>et se retrouve dans l'état <span class="em">prêt</span></p>
                                </li>
                                <li>
                                    <p>ou bien qu'il soit en attente sur une entrée/sortie de données qui le met dans l'état <span class="em">bloqué</span>.</p>
                                </li>
                                <li>
                                    <p>Dès qu'il a obtenu ses données, il retrouve dans l'état <span class="em">prêt</span>.</p>
                                </li>
                                <li>
                                    <p>En fin de traitement, il quitte l'application en passant de l'état <span class="em">élu</span> à l'état <span class="em">terminé</span>.</p>
                                </li>
                            </ul>
                            <img src="../images/states_process.png" alt="">
                            <p>Deux commandes permettent de contrôler les processus :</p>
                            <ul>
                                <li>
                                    <p><span class="html">top</span> qui affiche régulièrement la liste des processus et</p>
                                </li>
                                <li>
                                    <p><span class="html">ps</span> (processus status) qui affiche un instantané de certains processus en fonctions des options spécifiées. Cette commande accepte des options Unix (system V : précédées d'un tiret) et BSD (sans tiret), ou encore étendue GNU (deux tirets). Ces options permettent de demander certains processus (sans option de sélection, la commande affiche la liste des processus liés au terminal de l'utilisateur) (l'option <span class="html">- u user</span> donne les processus de l'utilisateur, <span class="html">-e</span> tous les processus, <span class="html">a</span> tous les processus liés à un terminal, <span class="html">x</span> tous les processus du système, ...). D'autres options spécificient les propriétés des processus renvoyés  (<span class="html">-l</span> : longue liste, <span class="html">-f</span> full, ...). Les options <span class="html">f</span> et <span class="html">-H</span> donnent la hiérarchie des procesus.</p>
                                </li>
                            </ul>
                            <p>Outre les propriétés déjà abordées (<span class="html">PID</span>, <span class="html">PPID</span>, <span class="html">UID</span>, <span class="html">TTY</span>, <span class="html">ETAT</span>), on peut encore citer <span class="html">TIME</span>( temps depuis le lancement du processus), <span class="html">CMD</span> (nom de l'application), <span class="html">PRI</span> (priorité de -20 très haute à 19 très basse), etc.</p>
                            <p>La commande "<span class="html">nice -n increment cmd</span>" permet de lancer en modifiant la prioriété de base afin de soulager le système en abaissant la priorité d'un processus gourmand en temps CPU, par contre seul peut augmenter la priorité.</p>
                        </li>
                        <li>
                            <h4>Les processus "système" :</h4>
                            <p>À côté des processus lancés par les utilisateurs, il existe des processus initiés par le système. En général ces processus sont exécutés durant la phase de boot du système et sont prévus pour fonctionner éternellement, ils sontappelés daemon (démon en français) et leur nom se termine par la lettre 'd'.</p>
                        </li>
                        <li>
                            <h4>Les tâches "utilisateur" (jobs) :</h4>
                            <p>Les processus "utilisateur" sont démarrés à partir d'un shell. Dans ce cas, on parle de <span class="em">tâche utilisateur</span>. Ils peuvent être <span class="em">interactifs</span>, c'est-à-dire qu'ils prennent le contrôle du terminal (clavier et écran); pendant ce temps, le processus du shell s'interrompt. Ou ils peuvent être exécutés en <span class="em">background</span> (le caractère <span class="html">&</span> permet d'exécuter le processus directement en background), en parallèle à l'exécution du shell qui garde le contrôle du terminal. Le shell permet de contrôler toutes les tâches lancées à partir de lui : la commande <span class="html">jobs</span> affiche la liste des jobs, la commande <span class="html">bg</span> permet de renvoyer un job en <span class="em">background</span>, tandis que la commande <span class="html">fg</span> permet de remettre un job en <span class="em">foreground</span> (il reprend le contrôle du terminal). Le shell permet de suspendre un processus en <span class="em">foreground</span> grâce à la touche de contrôle <span class="em">&lt;ctrl+z&gt;</span>, il reprend par la même occassion le contrôle du terminal. Il peut aussi terminer le processus grâce à la touche de contrôle <span class="em">&lt;ctrl+c&gt;</span>.</p>
                            <p>La gestion des jobs peut être résumée dans le schéma suivant :</p>
                            <img src="../images/states_job.png" alt="">
                        </li>
                        <li>
                            <h4>L'interaction entre processus : les signaux :</h4>
                            <p>L'interaction avec le processus est possible grâce aux <span class="em">signaux</span> qui peuvent lui être envoyés. L'envoi d'un signal à un processus va interrompre ce processus et lui permettre de réaliser le traitement prévu dans l'application, à savoir soit s'arrêter (c'est le traitement par défaut le plus fréquent), soit réaliser un traitement particulier (choisi par le programmeur ou par l'utilisateur) ou même ignorer le signal.</p>
                            <p>Il existe plusieurs signaux en Linux (la liste peut être obtenue grâce à la commande " <span class="html">kill -l</span>"), chacun ayant une signification particulière. La commande qui permet d'envoyer un signal est la commande <span class="html">kill [SIGNAME] PID</span>. Les principaux sont <span class="html">SIGINT</span> (2) qui correspond au <span class="em">&lt;ctrl+c&gt;</span>, <span class="html">SIGTERM</span> (15) qui correspond à une fin douce du processus, <span class="html">SIGTSTP</span> (20) <span class="em">&lt;ctrl+z&gt;</span>, <span class="html">SIGKILL</span> (9) fin brutale du processus (ne peut être ignoré par le processus) <span class="html">SIGUSR1</span> et <span class="html">SIGUSR2</span> (réservés aux usages personnalisés des applications).</p>
                        </li>
                        <li>
                            <h4>Les signaux dans le shell :</h4>
                            <p>Le shell, comme tout programme peut recevoir des signaux, il peut aussi modifier le traitement lié à un signal. La commande <span class="html">trap</span> permet à l'utilisateur de spécifier le traitement à exécuter en réponse à un signal. Par exemple, bash ignore le signal SIGINT mais il est possible de remplacer ce traitement par défaut et demander l'exécuter d'une commande : <span class="html">trap " echo Hello " SIGINT</span>.</p>
                            <p>À la réception d'un signal SIGINT, le shell va exécuter la commande <span class="html">echo</span>.</p>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <p>Grâces à des commandes LINUX, réalisez les actions suivantes :</p>
                    <h4>Gestion des jobs de l'utilisateur :</h4>
                    <ol>
                        <li>
                            <p>Lancez en arrière-plan la commande <span class="html">find /usr</span>.</p>
<pre><code class="html">find /usr &</code></pre>
                        </li>
                        <li>
                            <p>Relancez cette même commande et en même temps affichez le contenu du répertoire de login.</p>
<pre><code class="html">find /usr & ls -l</code></pre>
                        </li>
                        <li>
                            <p>Vous constatez qu'il y a un mélange de l'output des 2 commandes. Comment éviter ce problème ?</p>
<pre><code># Il faut rediriger stdout et stderr du find dans des fichiers.</code></pre>
                        </li>
                        <li>
                            <p>Lancement directement en arrière-plan l'exécution d'une commande qui a pour effet d'attendre 15 minutes (<span class="html">sleep</span>); ensuite, exécutez la commande <span class="html">ps -l</span>.</p>
<pre><code class="html">sleep 900 & ps -l</code></pre>
                        </li>
                        <li>
                            <p>Dans quel état se trouve le processus <span class="html">sleep</span> ?</p>
<pre><code># S (stoppé)</code></pre>
                        </li>
                        <li>
                            <p>Recherchez tous les fichiers du "file system" qui ont au moins les droits d'exécution pour le propriétaire et stocker le résultat dans le fichier <span class="em">cmd.lst</span> du répertoire de login, les messages d'erreur sont envoyés à la "poubelle".</p>
<pre><code class="html">find / -perm -u+x &gt; ~/cmd.lst 2&gt; /dev/null</code></pre>
                            <p>Suspendez son exécution.</p>
<pre><code class="html">&lt;ctrl+z&gt;</code></pre>
                            <p>Puis relancez l'exécution en arrière-plan.</p>
<pre class="taill60"><code class="html">bg</code></pre>
                        </li>
                        <li>
                            <p>Donnez la liste de tous les "jobs" en arrière-plan.</p>
<pre><code class="html">jobs</code></pre>
                        </li>
                        <li>
                            <p>Ramenez à l'avant plan le processus du <span class="html">find</span>.</p>
<pre><code class="html">fg 1</code></pre>
                        </li>
                        <li>
                            <p>Exécutez une commande qui a pour effet d'attendre 5 minutes.</p>
<pre><code class="html">sleep 5m</code></pre>
                            <p>Terminez le processus.</p>
<pre><code class="html">&lt;ctrl+c&gt;</code></pre>
                        </li>
                        <li>
                            <p>Ouvrez une nouvelle session (fenêtre) et lancez-y 3 processus qui s'endorment pour 20 minutes.</p>
<pre><code class="html">sleep 1200 &

!!

!!</code></pre>
                        </li>
                    </ol>
                    <h4>Les processus et les signaux :</h4>
                    <ol>
                        <li>
                            <p>Donnez la liste des processus appartenant à l'utilisateur connecté.</p>
<pre><code class="html">ps -u $(whoami)</code></pre>
                            <p>Récupérez le porgramme <span class="html">timer</span> de l'extranet et démarrez son exécution.</p>
<pre><code class="html">./timer</code></pre>
                            <p>Terminez "gentillement" son exécution grâce à une touche de contrôle.</p>
<pre><code class="html">&lt;ctrl+c&gt; # mais sans efet (le signal est intercepté par la commande)</code></pre>
                            <p>Suspendez son exécution.</p>
<pre><code class="html">&lt;ctrl+z&gt; # mais sans effet (idem)</code></pre>
                            <p>En cas d'échec, trouvez un autre moyen d'y arriver.</p>
<pre><code># Dans la seconde fenêtre
<span class="html">ps -u $(whoami) | grep timer</span>
<span class="html">kill -KILL pid</span>
# signal non interceptible</code></pre>
                        </li>
                        <li>
                            <p>Introduisez la commande suivante :</p>
<pre><code><span class="html">cat &gt; listeDesCommandes.txt</span>
<span class="html">top</span>, <span class="html">ps</span>, <span class="html">kill</span>,
<span class="html">jobs</span>, <span class="html">fg</span>, <span class="html">bg</span>,
<span class="html">&lt;ctrl+d&gt;</span></code></pre>
                        </li>
                        <li>
                            <p>À quoi sert la touche de contrôle <span class="html">&lt;ctrl+d&gt;</span> ?</p>
<pre><code># À indiquer EOF de stdin</code></pre>
                            <p>Quelle est la différence avec :</p>
                            <ul>
                                <li>
                                    <p class="html">&lt;ctrl+c&gt; # tue le processus, certaines données peuvent être perdues</p>
                                </li>
                                <li>
                                    <p class="html">&lt;ctrl+s&gt; # suspend l'affichage (&lt;ctrl+q&gt; pour relancer l'affichage)</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Créez un processus qui attend en lecture sur stdin grâce à la commande <span class="html">cat</span>.</p>
<pre><code><span class="html">cat</span>
# Ceci est le début du texte à introduire.</code></pre>
                            <p>Dans une autre session, vérifiez la liste des processus, quels sont les <span class="html">pid</span> et <span class="html">ppid</span> de la commande <span class="html">cat</span>.</p>
<pre><code class="html">ps -l -u $(whoami) | grep cat pid=...,ppid=...</code></pre>
                            <p>Quel est le processus parent du processus <span class="html">cat</span> ?</p>
<pre><code># le bash car son ppid est ...</code></pre>
                            <p>Terminez la commande <span class="html">cat</span>.</p>
<pre><code class="html">&lt;ctrl+d&gt;</code></pre>
                        </li>
                        <li>
                            <p>Que se passe-t-il lorsqu'on envoie le caractère de contrôle <span class="html">&lt;ctrl+c&gt;</span> ?</p>
                            <ul>
                                <li>
                                    <p>Quel mécanisme est utilisé par le système ?</p>
<pre><code class="html">SIGINT 2</code></pre>
                                </li>
                                <li>
                                    <p>Comment réagit le shell ?</p>
<pre><code># il ignore ce signal</code></pre>
                                </li>
                                <li>
                                    <p>Comment modifier ce comportement pour qu'il affiche l'heure système sous le formt 99H99 ?</p>
<pre><code class="html">trap "date +%HH%M" SIGINT</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>Comment configurer le shell pour lui faire afficher l'heure en réponse à l'appel <span class="em">heure</span> ? (pensez au mécanisme des signaux, à un alias, ...)</p>
<pre><code class="html">alias heure="date +%HH%M"</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_8">Cours n° 8 : Script Bash I : Les bases :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>L'automatisation de beaucoup de traitements se réalise grâce à des shells scripts, programmes reprenant une liste de commandes à exécuter. Et de fait, les shells Linux sont de vrais langages de programmation, avec utilisation de variables, de structures de contrôle (répétitives et conditionnelles), de fonctions. Les scripts bash sont notamment utilisés pour le prototypage d'applications, essentielleemnt système.</p>
                        </li>
                        <li>
                            <h4>Mode d'emploi :</h4>
                            <p>Les scripts bash sont une suite de commandes Linux qui s'exécutent les unes à la suite des autres, dans un sous-shell indépendant du shell appelant; cela ne nécessite aucune compilation préalable à l'exécution du programme.</p>
                            <ul>
                                <li>
                                    <p>La toute première ligne du fichier doit contenir le chemin du programme qui va interpréter les lignes du programme. Cette première ligne commence toujours par les 2 caractères '<span class="html">#!</span>' appelé <span class="em">shebang</span>. Par exemple, pour un script bash <span class="html">#!/bin/bash</span>.</p>
                                </li>
                                <li>
                                    <p>Un script bash est un fichier texte. Pour utiliser le script, soit il est fournit en argument de l'appel du shell <span class="html">/bin/bash monScript.sh</span>, soit il faut rendre ce fichier exécutable en ajoutant le droit d'exécution au fichier <span class="html">chmod u+x monScript.sh</span>.</p>
                                    <p>À partir de ce moment, la simple évocation du nom du fichier en débutera l'exécution.</p>
                                    <p><span class="html">./monScript.sh</span><span class="em"> # pourquoi doit-on spécifier le point avant le nom du fichier ??</span> Parce que le fichier ne se trouve généralement pas dans un répertoire repris dans la liste spécifiée par la variable PATH, mais dans le répertoire courant.</p>
                                    <p>Remarque : L'usage conseille d'utiliser l'extension <span class="html">.sh</span> pour nommer les scripts bash.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Les commentaires :</h4>
                            <p>Les commentaires insérés dans un script sont introduits par le caractère '<span class="html">#</span>' et se termine à la fin de la ligne. Par exemple, la première line du fichier peut être considérée comme un commentaire quand le fichier n'est pas exécuté directement à partir du shell mais qu'il est passé en argument à un programme shell.</p>
<pre><code class="html">chmod +x $fichier # je donne le droit d'exécution au fichier dont le nom est stocké dans la variable fichier.</code></pre>
                        </li>
                        <li>
                            <h4>Les variables :</h4>
                            <ul>
                                <li>
                                    <p>Dans la première partie du cours, nous avons découvert différentes sortes de variables : les variables d'environnement (variables exportées dans le sous-shell, initiés à partir du shell courant) et les variables locales. Nous pouvons les utiliser dans des scripts comme nous les avons utilisées en ligne de commande du shell. Pour rappel, une variable s'initialise grâce à la commande '<span class="html">=</span>' en faisant bien attention de ne pas mettre aucun séparateur autour du symbole. Par exemple, <span class="html">maVariable='Une valeur" # la variable maVariable reçoit la chaîne de caractères "Une valeur"</span>.</p>
                                </li>
                                <li>
                                    <p>La valeur stockée dans une variable est récupérée grâce à l'opérateur '<span class="html">$</span>, comme dans l'exemple :</p>
<pre><code class="html">echo $maVariable

cat &gt; $monFichier # sauve l'input de stdin dans le fichier dont le nom est mémorisé dans la variable monFichier</code></pre>
                                    <p>Il peut être nécessaire d'entourer le nom de la variable par des accolades pour éviter tout ambiguïté quant à ce nom : <span class="html">echo ${maVariable}1</span> affiche le contenu de la variable suivi du caractère 1.</p>
                                </li>
                                <li>
                                    <p>Bash connaît un certain nombre de variables prédéfinies, nous retiendrons particulièrement les variables <span class="html">$$</span> (<span class="html">$$</span> représente le PID du script (du shell dans lequel est exécuté le script)) et <span class="html">$?</span> (<span class="html">$?</span> représente le statut de la dernière commande exécutée).</p>
                                </li>
                                <li>
                                    <p>Les variables ne doivent pas être déclarées. Si elles sont utilisées avant d'être initialisées, la valeur sera considérée comme indéfinie, nulle.</p>
                                </li>
                                <li>
                                    <p>Les variables sont non typées, mais la valeur qui y est stockée comme une valeur numérique entière si elle ne contient que des chiffres et éventuellement un signe ou comme chaîne de caractères dans tous les autres cas. Bash ne reconnaît pas et ne peut donc pas traiter des valeurs numériques réelles.</p>
<pre><code class="html">monInt=5 # valeur considérée entière

monReel=3.5 # valeur considérée comme chaîne de caractères

maString="ceci est une string"

maString='ceci est une autre valeur'</code></pre>
                                </li>
                                <li>
                                    <p>Les chaînes de caractères peuvent être spécifiée entre simple (avec des apostrophes, le texte est repris sans aucune interprétation) ou doubles quotes (les guillemets permettent l'interprétario des caractères spéciaux et l'expansion des variables) et même entre quotes inverses (substitution de commande, la chaîne est remplacé par le résultat de la commande). Voyez la différence entre <span class="html">echo $(ls -l)</span>, <span class="html">'echo $(ls -l)'</span> et <span class="html">echo "$(ls -l)"</span>.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Expansion d'entiers :</h4>
                            <p>L'évaluation d'une expression numérique (entière) peut se faire au moyen de doubles parenthèses : <span class="html">(( expression ))</span>, sa valeur est récupérée grâce à l'utilisation de l'opérateur <span class="html">$</span> soit en affectant le résultat à une variabe <span class="html">a=$((b + 4))</span> calcule la somme entre le contenu de la variable b et 4, soit dans le style de C <span class="html">((a=b + 4))</span>.</p>
                        </li>
                        <li>
                            <h4>Les arguments du programme :</h4>
                            <p>Les arguments fournis au script sont récupérés dans les variables spéciales <span class="html">$1</span>, <span class="html">$2</span>, ... <span class="html">$n</span>( ou <span class="html"></span>). La variable <span class="html">$0</span> reprend le nom de l'application.</p>
                            <p>La variable <span class="html">$*</span> fournit la liste des n arguments et la variable <span class="html">$#</span> donne le nombre d'arguments.</p>
                            <p>La variable <span class="html">exit</span> permet de fournir au shell appelant un code de sortie, qui vaut <span class="html">0</span> si le déroulement du script est considéré comme correct, et une valeur positive (comprise entre 1 et 255) pour indiquer une erreur dans le déroulement du programme.</p>
                        </li>
                        <li>
                            <h4>Read :</h4>
                            <p>La commande <span class="html">read</span> permet de lire sur <span class="html">stdin</span> du texte qui est stocké dans les variables passées en paramètres à la commande (le caractère séparateur de mots est le caractère d'espacement ' ').</p>
                            <p><span class="html">read a b c</span> va lire sur <span class="html">stdin</span> des mots, le premier est stocké dans la variable <span class="em">a</span>, le deuxième dans <span class="em">b</span> et le reste de la ligne dans <span class="em">c</span>.</p>
<pre><code class="html">cat &gt; toto.sh # STUPIDE
vim toto.sh # HARDCORE
emacs toto.sh # HARD
nano toto.sh # NORMAL
gedit toto.sh # CAREBEAR</code></pre>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <ol>
                        <li>
                            <p>Écrivez un script qui affiche sur <span class="html">stdout</span> le nom du programme, le nom de l'utilisateur connecté, le path du répertoire courant et le contenu de la variable d'environnement PATH.</p>
<pre><code class="html">nano ex1.sh

#!/bin/bash
echo $0
whoami
pwd
echo $PATH

chmod +x ex1.sh
./ex1.sh</code></pre>
                        </li>
                        <li>
                            <p>Écrivez 3 versions du programme <span class="em">somme.sh</span> qui calcule la somme de 2 nombres :</p>
                            <ol>
                                <li>
                                    <p>initialisés dans la source :</p>
<pre><code class="html">#!/bin/bash
a=1
b=2
resultat=$((a + b))
echo "$a + $b = $resultat"</code></pre>
                                </li>
                                <li>
                                    <p>donnés en arguments :</p>
<pre><code class="html">#!/bin/bash
a=$1
b=$2
((resultat=a + b))
echo "$a + $b = $resultat"</code></pre>
                                </li>
                                <li>
                                    <p>introduits au clavier sur <span class="html">stdin</span> :</p>
<pre><code class="html">#!/bin/bash
read a b
resultat=$((a + b))
echo "$a + $b = $resultat"</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <p>Le squelette et les propriétés d'un script bash peuvent être générés automatiquement. Rédigez un script qui crée un fichier script reprenant une entête standardisé et posséfant les propriétés adéquates. Le texte de ce fichier est stocké dans une variable et ensuite copié dans le fichier dont le nom est passé en paramètre. La première ligne doit être compatible avec votre système.</p>
<pre><code>#!/bin/bash
###############################
# nom_du_fichier
# user
# 23 avril 2012
###############################</code></pre>
<pre><code>#!/bin/bash
nomFichier=$1
texte="#!/bin/bash\n"
texte="${texte}###############################\n"
texte="${texte}# $nomFichier\n"
texte=${texte}# $(whoami)\n"
texte=${texte}# $(date '+%d %B %Y')\n"
texte="${texte}###############################"
echo -e $texte &gt; $nomFichier
chmod +x $nomFichier
exit 0</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_9">Cours n° 9 : Script Bash II : Les expressions conditionnelles - les alternatives :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>Après les premiers pas dans le monde des scripts bash, nous allons aborder l'évaluation des expressions conditionnelles et leur utilisation dans les alternatives.</p>
                        </li>
                        <li>
                            <h4>L'exit code :</h4>
                            <p>Toute application, sous Linux, se termine en renvoyant un code qui est une valeur positive ou nulle (comprise entre 0 et 255).</p>
                            <p>Par convention, la valeur nulle est réservée pour marquer un arrêt normal du processus, elle est considérée comme la valeur booléenne <span class="em">VRAI</span>; les valeurs strictement positives permettent d'indiquer un type d'erreur et sont toutes équivalentes à la valeur booléenne <span class="em">FAUX</span>.</p>
                            <p>Cet "exit code" peut être exploité par les shells, pour contrôler les exécutions conditionnelles (<span class="html">&&</span> et <span class="html">||</span>). Par exemple : <span class="html">mkdir rep && cp rep</span>.</p>
                            <p>De plus, les shells récupèrent cette valeur en la plaçant dans la variable implicite <span class="html">$?</span>. Cette valeur peut être utilisée comme n'importe quelle autre variabe. Par exemple :</p>
<pre><code class="html">rmdir monRep
echo "Le code de retour est $?"</code></pre>
                        </li>
                        <li>
                            <h4>Les alternatives :</h4>
                            <p>Les shells bash sont des langages de programmation; ils connaissent l'utilisation de traitements alternatifs comme nous en rencontrons dans les autres langages de programmation, mais attention, la syntaxe est plus contraignante.</p>
                            <ol>
                                <li>
                                    <h5>Les alternatives simples :</h5>
                                    <p>Une alternative simple est donnée par les mots réservés <span class="html">if</span>, <span class="html">then</span> et <span class="html">fi</span> :</p>
<pre><code class="html">if cmde
then
    cmde(s)
fi</code></pre>
                                    <p>Une syntaxe plus condensée est possible en séparant les différentes commandes de cette commande par des points-virgules.</p>
<pre><code class="html">if cmde; then
    cmde(s)
fi</code></pre>
                                    <p>L'évaluation de la condition est basée sur l'exit code de la commande placée en argument du if : <span class="em">TRUE</span> si cette valeur est nulle.</p>
<pre><code class="html">if rmdir monRep; then
    echo "La suppression du répertoire est réussie."
fi</code></pre>
                                </li>
                                <li>
                                    <h5>Les alternatives doubles :</h5>
                                    <p>La seconde proposition dans une alternative double est introduite par le mot réservé <span class="html">else</span>.</p>
<pre><code class="html">if rmdir monRep; then
    echo "La suppression du répertoire est réussie."
else
    echo "Hum, il y a un léger souci !"
fi</code></pre>
                                </li>
                                <li>
                                    <h5>Les alternatives multiples :</h5>
                                    <p>Lorsque le traitement nécessite plusieurs conditions mutuellement exclusives, les conditions supplémentaires sont introduites par le mot réservé <span class="html">elif</span> :</p>
<pre><code class="html">if rmdir monRep; then
    echo "La suppression du répertoire est réussie."
elif rm -r monRep; then
    echo "Le répertoire n'était pas vide."
else
    echo "Hum, il y a un léger souci !"
fi</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>Les expressions conditionnelles :</h4>
                            <p>L'évaluation des expressions conditionnelles est réalisée grâce à la commande <span class="html">test expr</span> qui peut s'utiliser plus simplement avec la fonction <span class="html">[ expr ]</span>.</p>
                            <p>La valeur <span class="em">VRAI</span> se traduit par un code de retour valant <span class="em">0</span> et <span class="em">FAUX</span> correspond à <span class="em">1</span>.</p>
                            <p>Les expressions conditionnelles s'appliquent à plusieurs domaines : les tests de fichiers, de variables, les comparaisons de chaînes de caractères et les comparaisons de valeurs numériques entières.</p>
                            <ol>
                                <li>
                                    <h5>Comparaison de chaînes de caractères au moyen des opérateurs <span class="html">=</span>, <span class="html">==</span> et <span class="html">!=</span> :</h5>
                                    <ul>
                                        <li>
                                            <p><span class="html">"$a" = "$b"</span> ou <span class="html">"$a" == "$b"</span> a est-il égal à b ?</p>
                                        </li>
                                        <li>
                                            <p><span class="html">"$a" != "$b"</span> a est-il différent de b ?</p>
                                        </li>
                                        <li>
                                            <p>Exemple : <span class="html">[ "$a" =  "$b" ]</span></p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Comparaisons de valeurs numériques :</h5>
                                    <ul>
                                        <li>
                                            <p>Se réalisent grâce aux opérateurs <span class="html">-lt</span> (lower than), <span class="html">-gt</span> (greater than), <span class="html">-eq</span> (equal), <span class="html">-ne</span> (non equal), <span class="html">-le</span> (lower or equal) et <span class="html">-ge</span> (greater or equal).</p>
                                        </li>
                                        <li>
                                            <p>Exemple : <span class="html">[ "$a" -eq "$b" ]</span> a est-il égal à b ?</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Tests de propriétés des fichiers :</h5>
                                    <p>Les propriétés des fichiers peuvent être testées grâce à une série d'opérations dont les principaux sont :</p>
                                    <ul>
                                        <li>
                                            <p>Test sur le type (<span class="html">-f</span> : fichier régulier, <span class="html">-d</span> : répertoire, <span class="html">-h</span> (ou <span class="html">-L</span>) : lien symbolique).</p>
                                        </li>
                                        <li>
                                            <p>Test sur l'existence (<span class="html">-e</span> : le fichier existe, <span class="html">-s</span> le fichier est non vide).</p>
                                        </li>
                                        <li>
                                            <p>Tests sur les droits (<span class="html">-r</span>, <span class="html">-w</span> et <span class="html">-x</span>). Ai-je un succès en lecture, écriture, exécution sur le fichier</p>
                                        </li>
                                        <li>
                                            <p>Exemple : <span class="html">[ -f "$a" ]</span> # le fichier dont le nom est dans la variable a est-il un fichier régulier ?</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Test sur les chaînes de caractères :</h5>
                                    <ul>
                                        <li>
                                            <p><span class="html">-z "$a"</span> : chaîne vide ou non définie</p>
                                        </li>
                                        <li>
                                            <p><span class="html">-n "$a"</span> : chaîne non vide</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h4>Le switch :</h4>
                            <p>Bash possède une construction d'alternative testant différentes valeurs d'une variable. Sa syntaxe est un peu particulière où interviennent les éléments suivants :</p>
                            <ul>
                                <li>
                                    <p><span class="html">cas var in</span> : propose la variable à comparer</p>
                                </li>
                                <li>
                                    <p><span class="html">n)</span> : propose une des valeurs possibles</p>
                                </li>
                                <li>
                                    <p><span class="html">*)</span> : les valeurs restantes</p>
                                </li>
                                <li>
                                    <p><span class="html">esac</span> : termine la structure de contrôle</p>
                                </li>
                                <li>
                                    <p><span class="html">;;</span> : termine chaque cas</p>
                                </li>
                            </ul>
                            <p>Exemple :</p>
<pre><code class="html">case "$a" in
    1)
        echo ""$a" vaut 1";;
    2)
        echo ""$a" vaut 2";;
    *)
        echo ""$a" n\'est ni 1 ni 2 mais une autre valeur"
        exit 1;;
esac</code></pre>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <ol>
                        <li>
                            <p>Écrivez un script <span class="em">backup.sh</span> qui prend un backup du répertoire dont le nom est passé en argument et qui sauve cette archive dans le répertoire <span class="em">backup</span> du répertoire de login. Respectez les contraintes suivantes :</p>
                            <ul>
                                <li>
                                    <p>L'usage du script est correct (l'argument existe et est bien un répertoire), en cas d'erreur, le script se termine prématurément en affichant sur <span class="html">stderr</span> le message <span class="em">Usage : nom-du-script.sh repertoire</span> et en retournant un code valant 1.</p>
                                </li>
                                <li>
                                    <p>Le répertoire de backup est existant et protégé en écriture.</p>
                                </li>
                                <li>
                                    <p>La commande de backup est la commande <span class="html">tar</span> (options <span class="html">c</span> (create) et <span class="html">f</span> (filename)) : <span class="html">tar cf archive.tar source</span>.</p>
                                </li>
                                <li>
                                    <p>Le script commande par remettre l'accès en écriture sur le répertoire <span class="em">backup</span>, il quitte le script avec un code d'erreur 1 en cas de problème.</p>
                                </li>
                                <li>
                                    <p>Le nom de l'archive doit comprendre la date système (au format : 2016mai02) reprenant l'année, le mois, le jour.</p>
                                </li>
                                <li>
                                    <p>En cas de réussite, le fichier est le répertoire de backup sont protégés en écriture.</p>
                                </li>
                            </ul>
<pre><code class="html">#!/bin/bash

if [ "$#' -ne 1 ]; then
    echo "Usage : $0 dir" &gt; /dev/stderr
    exit 1
fi

if [ ! -d "$1" ]; then
    echo ""$1" n\'est pas un répertoire." &gt; /dev/stderr
    exit 1
fi

back="$HOME/backup"

if [ ! -e "$back" ] || [ ! -d "$back" ] || [ -w "$back" ]; then
    echo "Le dossier backup n'existe pas ou n'est pas un répertoire ou n'est pas protégé en écriture" &gt; /dev/stderr
    exit 1
fi

if ! chmod u+w "$back"; then
    echo "L'opération a malencontreusement échouée." &gt; /dev/stderr
    exit 1
fi

archive="backup$(date %Y%B%d).tar"

if [ -e "$back/$archive" ]; then
    echo ""$archive" existe dans backup &gt; /dev/stderr
    rm -f "$back/$archive"
fi

if ! tar cf "$back/$archive" "$1"
    echo "L'opération a malencontreusement échouée" &gt; /dev/stderr
    exit 1
else
    chmod u-w "$back" "$back/$archive"
    exit 0
fi</code></pre>
                        </li>
                        <li>
                            <p>Écrivez une nouvelle version du script <span class="em">somme.sh</span> dans laquelle les nombres peuvent être introduits en argument du programme. Si l'utilisateur n'indique pas les 2 arguments, le script demande le (ou les) argument(s) manquant(s) qui seront lus sur <span class="html">stdin</span>. Si l'utilisateur introduit plus de deux arguments, l'usage lui est rappelé est l'application qui lui est rappelé et l'application se termine avec un code d'erreur à 1.</p>
<pre><code class="html">#!/bin/bash

case "$#" in
    0)
        read a b;;
    1)
        a="$1"
        read b;;
    2)
        a="$1"
        b="$2";;
    *)
        echo "Il y a trop d'arguments !" &gt; /dev/stderr
        exit 1;;
esac

resultat=$((a + b))
echo "$a" + "$b" = "$resultat"</code></pre>
                        </li>
                        <li>
                            <p>Compléter le script <span class="em">squelette.sh</span> rédigé lors de la séance passée. Cette nouvelle version permet :</p>
                            <ol>
                                <li>
                                    <p>de vérifier :</p>
                                    <ul>
                                        <li>
                                            <p>La présence de l'argument (en cas d'absence, le script affiche l'usage et se termine prématurément avec un code valant 1).</p>
                                        </li>
                                        <li>
                                            <p>L'existence du fichier (s'il existe, le script demande à l'utilisateur s'il faut écraser le fichier ou arrêter le processus, code valant 2).</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>d'introduire une ligne de description sur <span class="html">stdin</span>. Si l'utilisateur n'introduit aucune ligne (<span class="html">&lt;ctrl+d&gt;</span>) ou une ligne vide, le script ignore la description, sinon la ligne est ajoutée à l'entête standard, après le nom du fichier :</p>
<pre><code>#!/bin/bash
#################################
# nom-du-fichier
#	script qui réalise un backup
# user
# 23 avril 2014
#################################</code></pre>
                                </li>
                            </ol>
<pre><code class="html">#!/bin/bash

if [ "$# -ne 1]; then
    echo "paramètre manquant" &gt; /dev/stderr
    exit 1
fi

if [ -e "$1" ]; then
    echo "Vous-vous écraser le fichier (O) ou arrêter le processus (N) ?" &gt; /dev/stdout
    read choix

    if [ "$choix" != 'O' ] && [ "$choix" != 'N' ]; then
        echo 'Veuillez entrer "O" ou "N" ?' &gt; /dev/stdout
        exit 1
    fi

    if [ "$choix" == 'N' ]; then
        echo "Le processus a bien été arrêté" &gt; /dev/stdout
        exit 2
    fi
fi

read description
nomFichier="$1"
user=$(whoami)
date="$(date +'%d %B %Y')"

texte="#!/bin/bash\n"
texte="${texte}##############################\n"
texte="${texte}# $nomFichier\n"

if [ -n "$desccription" ]; then
    texte=${texte}# $description\n"
fi

texte="${texte}# $user\n"
texte=${texte}# $date\n"
texte=${texte}##############################\n"

echo -e $texte &gt; $nomFichier
chmod +x $nomFichier
exit 0</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="cours_10">Cours n° 10 : Les tables et les structures de contrôle répétitives :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>Terminons l'apprentissage des scripts bash en abordant les tableaux en bash et les structures de contrôle répétitives.</p>
                        </li>
                        <li>
                            <h4>Les tableaux :</h4>
                            <p>Comme pour les simples variables, bash n'exige pas la déclaration des tableaux, mais la fonction interne <span class="html">declare -a tableau</span> le permet. Dès lors, les tableaux existent à partir du momentoù un des éléments est initialisé. Cette initialisé peut être :</p>
                            <ul>
                                <li>
                                    <p>individuelle : par exemple, <span class="em">table[6]=17</span></p>
                                </li>
                                <li>
                                    <p>proposée par une liste : par exemple : <span class="em">table=(1 3 5 7 11)</span>, <span class="em">mesCouleurs=(rouge vert bleu)</span> ou encore <span class="em">lesFichiers=(1(ls))</span>.</p>
                                </li>
                            </ul>
                            <p>Une table peut contenir des éléments inexistants (non initialisés), comme l'élément d'indice 5 dans le tableau <span class="em">table</span>.</p>
                            <p>L'utilisation d'un élément du tableau se fait grâce à l'opérateur <span class="html">$</span>, mais le nom de la variable doit être <span class="html">{</span> et <span class="html">}</span>, comme dans l'exemple suivant <span class="html">1{table[3]}</span>.</p>
                            <p>La valeur de l'indice doit être un entier positif ou nul; les tableaux commencent toujours à l'indice 0.</p>
                            <p>Il existe deux notations particulières : <span class="html">${mesCouleurs[*]}</span> donne la liste de tous les éléments de la table et <span class="html">${#mesCouleurs[*]}</span> donne le nombre d'éléments initialisés de la table.</p>
                            <p>Attention, le nom du tableau représente le premier élément du tableau, celui d'indice 0. Donc, <span class="html">$table</span> est égale à <span class="html">${table[0]}</span>.</p>
                        </li>
                        <li>
                            <h4>Les répétitives :</h4>
                            <ol>
                                <li>
                                    <h5>Avec conditions de continuation :</h5>
                                    <p>Les commandes qui interviennent dans ce type de répétitives sont les commandes :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">while cmd</span> : la commande '<span class="em">cmd</span>' doit retourner 0 pour que l'itération soit réalisée.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">do</span> : introduit la liste des commandes d'une itération.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">done</span> : termine l'itération.</p>
                                        </li>
                                        <li>
                                            <p>Exemple :</p>
<pre><code class="html">while [ -eq $b ]
do
    read $a $b
done</code></pre>
                                            <p>ou encore :</p>
<pre><code class="html">while [ $a -eq 1b ]; do
    read $a $b
done</code></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Avec conditiion d'arrêt :</h5>
                                    <p>Les commandes qui interviennent dans ce type de répétitives sont les commandes :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">until cmd</span> : la commande '<span class="em">cmd</span>' doit retourner 0 pour quitter la boucle.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">do</span> : introduit la liste des commandes d'une itération.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">done</span> : termine l'itération.</p>
                                        </li>
                                        <li>
                                            <p>Exemple :</p>
<pre><code class="html">until [ $a -ne $b ]
do
    read $a $b
done</code></pre>
                                            <p>ou encore :</p>
<pre><code class="html">until [ $a -ne $b ]; do
    read $a $b
done</code></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Sur les éléments d'une liste :</h5>
                                    <p>Le traitement est appliquée à chacun des éléments de la liste. Les commandes qui inverviennent dans ce type de répétitives sont les commandes :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">for elem in liste</span> : <span class="em">elem</span> est la variable de contrôle et <span class="em">liste</span> la liste parcourue par la répétitive.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">do</span> : introduit la liste des commandes d'une itération.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">done</span> : termine l'itération.</p>
                                        </li>
                                        <li>
                                            <p>Exemple :</p>
<pre><code class="html">for fichier in $(ls)
do
    echo $fichier
done</code></pre>
                                            <p>ou encore :</p>
<pre><code class="html">for fichier in $(ls); do
    echo $fichier
done</code></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h5>Sortie de boucles :</h5>
                                    <p>La commande <span class="html">continue</span> permet de passer à l'itération suivante.</p>
                                    <p>La commande <span class="html">break</span> permet de quitter une boucle.</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <ol>
                        <li>
                            <p>Écrivez le script <span class="em">somme.sh</span> qui affiche la somme des éléments d'un tableau initialisé aux valeurs 1, -3, 45, 67.</p>
<pre><code class="html">#!/bin/bash
tab=(1 -3 45 67)
somme=0

for chiffre in ${tab[*]}; do
    ((somme+=chiffre))
done

echo "$somme"
exit 0</code></pre>
                        </li>
                        <li>
                            <p>Dans une nouvelle version plus complète, le programme doit commencer par sommer les nombres d'une table initialisée dans le code, ensuite les nombres introduits en arguments du script, enfin ceux introduits sur <span class="html">stdin</span>. La fin des données est indiquée par <span class="html">&lt;ctrl+d&gt;</span> ou une ligne vide.</p>
<pre><code class="html">#!/bin/bash
tab=(1 -3 45 67)
somme=0

for chiffre in ${tab[*]}; do
    ((somme+=chiffre))
done

for nombre in $*; do
    ((somme+=nombre))
done

while rea nb && [ -n "$nb" ]; do
    ((somme+=nb))
done

echo "$somme"
exit 0</code></pre>
                        </li>
                        <li>
                            <p>Rédigez un script <span class="em">lsd.sh</span> qui donne la liste des répertoires du répertoire courant.</p>
<pre><code class="html">#!/bin/bash
for fichier in $(ls); do
    if [ -d "$fichier" ]; then
        echo "$fichier"
    fi
done
exit 0</code></pre>
                        </li>
                        <li>
                            <p>Complétez le script précéde,y de telle sorte qu'il puisse recevoir en argument le nom d'un répertoire. Par défaut (s'il n'y a pas d'arguments), le script traite le répertoire courant. Si l'argulent n'est pas un répertoire, le script affiche un message d'erreur et quitte avec un code valant 2. Par exemple, à l'appel <span class="em">./lsd.sh ..</span> le script affiche la liste du répertoire parent. Si l'utilisateur introduit plus d'un argument, le script rappelle l'usage <span class="em">Usage : nomDuScript [rep]</span> et se termine avec le code 1. Par exemple, à l'appel <span class="em">./lsd.sh rep1 rep2</span> le qcript affiche <span class="em">Usage : lsd.sh [rep]</span> et retourne le code 2.</p>
<pre class="taill60"><code class="html">#!/bin/bash
case "$#" in
    0) rep=.;;
    1) rep="$1";;
    *)
        echo "Usage : $0 [rep]" &gt; /dev/sterr
        exit 1;;
esac

if [ ! -d "$1" ]; then
    echo "$1 n'est pas un répertoire." &gt; /dev/stderr
    exit 2
fi

for fichier in $(ls "$rep"); do
    if [ -d "$rep/$fichier" ]; then
        echo "$fichier"
    fi
done
exit 0</code></pre>
                        </li>
                        <li>
                            <p>Complétez le script squelette commencé lors de la séance précédente pour permettre à l'utilisateur d'introduire sur <span class="html">stdin</span> une brève description (2 ou 3 lignes) à insérer dans l'entête comme nous le montre l'exemple suivant.</p>
<pre><code>#!/bin/bash
#################################
# lsd.sh
#	script qui affiche la liste des répertoires
#		du répertoire passé en argument,
#		le répertoire par défaut est le répertoire courant
# user
# 23 avril 2016
#################################</code></pre>
<pre><code class="html">#!/bin/bash

if [ "$# -ne 1]; then
    echo "paramètre manquant" &gt; /dev/stderr
    exit 1
fi

if [ -e "$1" ]; then
    echo "Vous-vous écraser le fichier (O) ou arrêter le processus (N) ?" &gt; /dev/stdout
    read choix

    if [ "$choix" != 'O' ] && [ "$choix" != 'N' ]; then
        echo 'Veuillez entrer "O" ou "N" ?' &gt; /dev/stdout
        exit 1
    fi

    if [ "$choix" == 'N' ]; then
        echo "Le processus a bien été arrêté" &gt; /dev/stdout
        exit 2
    fi
fi

nomFichier="$1"
user=$(whoami)
date="$(date +'%d %B %Y')"

texte="#!/bin/bash\n"
texte="${texte}##############################\n"
texte="${texte}# $nomFichier\n"

while read description && [ -n "$desccription" ]; do
    texte=${texte}# $description\n"
done

texte="${texte}# $user\n"
texte=${texte}# $date\n"
texte=${texte}##############################\n"

echo -e $texte &gt; $nomFichier
chmod +x $nomFichier
exit 0</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="exercices_supplementaires_1">Exercices supplémentaires :</h2>
                    <ol>
                        <li>
                            <p>Donnez la commande qui permet de lister tous les fichiers de l'arboresccence <span class="html">/usr</span> qui ont changé de propriétés durant l'année écoulée.</p>
<pre><code class="html">find /usr -ctime -365</code></pre>
                        </li>
                        <li>
                            <p>Suspendez le traitement du processus, puis continuez son traitement en arrière-plan.</p>
<pre><code class="html">&lt;ctrl+z&gt;
bg</code></pre>
                        </li>
                        <li>
                            <p>Supprimez ce processus.</p>
<pre><code class="html">kill %1</code></pre>
                        </li>
                        <li>
                            <p>En utilisant l'history, relancez la recherche précédente directement en arrière-plan, en récupérant le résultat dans le fichier <span class="em">findUsr.txt</span> dans le répertoire linux du répertoire de login, les messages d'erreur sont ignorés.</p>
<pre><code class="html">!find &gt; ~/linux/findUsr.txt 2&gt; /dev/null &</code></pre>
                        </li>
                        <li>
                            <p>Déplacez-vous dans le répertoire linux du répertoire de login.</p>
<pre><code class="html">cd ~/linux</code></pre>
                        </li>
                        <li>
                            <p>Affichez page à page la liste des fichiers de l'arborescence <span class="html">/etc</span> qui ont au moins le droit d'écriture pour le groupe ou pour les autres utilisateurs, les messages d'erreurs sont jetés à la poubelle.</p>
<pre><code class="html">find /etc -perm /go+w 2&gt; /dev/null | less</code></pre>
                        </li>
                        <li>
                            <p>Donnez les propriétés du répertoire <span class="html">/usr/local</span>.</p>
<pre><code class="html">stat /usr/local</code></pre>
                        </li>
                        <li>
                            <p>Créez dans le répertoire de login, un lien symbolique <span class="em">usrLocal</span> sur le répertoire <span class="html">/usr/local</span>.</p>
<pre><code class="html">ln -s /usr/local ~/usrLocal</code></pre>
                        </li>
                        <li>
                            <p>Quelles sont les propriétés de l'inode du répertoire <span class="html">/usr/local</span> qui ont été modifiées.</p>
<pre><code># aucune</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de supprimer tous les droits sur le répertoire theorie pour les autres utilisateurs du système.</p>
<pre><code class="html">chmod o-rwx theorie</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de calculer la taille totale des fichiers d'extension log du répertoire <span class="html">/var/log</span>.</p>
<pre><code class="html">wc -l /var/log/*.log | tail -1 | egrep -o [0-9]</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche toutes les lignes du fichier <span class="html">/var/log/syslog</span> qui contiennent un nombre de 5 ou 6 chiffres.</p>
<pre><code class="html">egrep "[0-9]{5,6}" /var/log/syslog</code></pre>
                        </li>
                        <li>
                            <p>J'ai exécuté un programme qui boucle et n'arrête pas d'écrire des messages sur l'écran du terminal (par exemple<span class="html">timer -INT</span>).</p>
                            <ol>
                                <li>
                                    <p>Quel signal puis-je envoyer au processus pour le terminer prématurément et comment ?</p>
<pre><code class="html">SIGINT (2)
&lt;ctrl+c&gt;</code></pre>
                                </li>
                                <li>
                                    <p>Si le processeur ne répond pas à ce signal (par exemple <span class="html">timer</span>), comment puis-je tuer le processus et pourquoi</p>
<pre><code><span class="html">kill -SIGNKILL pid</span>

# parce que le signal ne peut pas être ignoré par le processus</code></pre>
                                </li>
                                <li>
                                    <p>Donnez la commande qui affiche la liste des fichiers réguliers des arborescences <span class="html">/home</span> et <span class="html">/tmp</span> propriété de l'utilisateur connecté.</p>
<pre><code class="html">find /home /tmp-type f `whoami`</code></pre>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="interro_1">Interrogation de Linux n° 1 : Les répertoires et les fichiers :</h2>
                    <p>Vous ne devez changer de répertoire courant que lorsque cela est spécifié dans la question.</p>
                    <p>Le répertoire courant en début d'exercices est le répertoire de login de l'utilisateur <span class="em">Viande</span> : <span class="em">/home/Viande</span>.</p>
                    <p>Vous devez compléter le schéma du système de fichier pour y incorporer les modifications liées aux commandes que vous introduisez.</p>
                    <img src="../images/linux_interro1.png" alt="">
                    <p>La commande <span class="html">stat monTajine.jpg</span> donne le résultat suivant :</p>
<pre><code>File: "monTajine.jpg"
    Size: 102123	FileType: Regular File
    Mode: (0640/-rw-r-----)	Uid: (	501/viande)	Gid: (	20/	staff)
Device: 14,2	Inode: 5221802	Links: 1
    Access: Fri Mar	6 16:44:40 2015
Modify: Fri Mar	6 16:44:12 2015
Change: Fri Mar 6 16:44:40 2015</code></pre>
                    <p>Que représente les propriétés suivantes et pour chacune d'elles, donnez une commande qui la modifie :</p>
                    <ul>
                        <li>
                            <p>Access :</p>
<pre><code># La date et l'heure du dernier accès au fichier.
<span class="html">cat monTajine.jpg</span></code></pre>
                        </li>
                        <li>
                            <p>Modify :</p>
<pre><code># La date et l'heure de la dernière modification du fichier.
<span class="html">touch monTajine.jpg</span></code></pre>
                        </li>
                        <li>
                            <p>Change :</p>
<pre><code># La date et l'heure de la dernière modification de l'inode.
<span class="html">chmod 0777 monTajine.jpg</span></code></pre>
                        </li>
                        <li>
                            <p>Uid :</p>
<pre><code># Utilisateur à qui appartient le fichier
/</code></pre>
                        </li>
                    </ul>
                    <ol>
                        <li>
                            <p>DOnnez la comamnde qui permet de créer les répertoires (voir le schéma du système de fichiers) de l'arborescence issue du répertoire de login.</p>
<pre><code class="html">mkdir roti
mkdir tajine
mkdir saucisses
mkdir saucisses /memrguez</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de copier dans le répertoire <span class="em">tajine</span>, l'arborescence <span class="em">agneau</span> du répertoire <span class="html">/usr/local</span>.</p>
<pre><code class="html">cp -r /usr/local/agneau tajine</code></pre>
                        </li>
                        <li>
                            <p>Donnez la comamnde qui permet de déplacer les <span class="em">merguez</span> dans le répertoire <span class="em">tajine</span>.</p>
<pre><code class="html">mv saucisses/merguez tajine</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet à l'utilisateur connecté de se déplacer dans le répertoire <span class="em">agneau</span>.</p>
<pre><code class="html">cd /usr/local/agneau</code></pre>
                        </li>
                        <li>
                            <p>Donnez la comande qui affiche le contenu du répertoire parent.</p>
<pre><code class="html">ls ..</code></pre>
                        </li>
                        <li>
                            <p>Qu'affiche cette commande ?</p>
<pre><code># affiche le contenu du répertoire parent (local) : agneau</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de créer le fichier vide "<span class="em">5 merguez</span>" dans le répertoire <span class="em">merguez</span>.</p>
<pre><code class="html">touch "/home/Viande/tajine/merguez/5 merguez"</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de créer un lien physique du fichier "<span class="em">5 merguez</span>" vers le répertoire de login en gardant le même nom.</p>
<pre><code class="html">ln "/home/Viande/tajine/merguez/5 merguez" ~</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet d'empêcher les autres utilisateurs du système de modifier le répertoire <span class="em">tajine</span> et justifiez votre commande.</p>
<pre><code><span class="html">chmod o-w /home/Viande/tajine</span>
# -w pour enlever les droits d'écriture donc cela empêche les modifications et o pour les autres utilisateurs</code></pre>
                        </li>
                        <li>
                            <p>Donnez une manière de prouver que vous avez bien créé un lien physique.</p>
<pre><code># l'inode du lien physique et du fichier est le même
ls -i</code></pre>
                        </li>
                        <li>
                            <p>Donnez au moins 2 façons de repositionner dans le répertoire de login.</p>
<pre><code><span class="html">cd</span> ou <span class="html">cd ~</span> ou <span class="html">cd /home/Viande</span> ou <span class="html">cd ../../../home/Viande</span></code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="interro_2">Interrogation de Linux n° 2 :</h2>
                    <p>L'inode est une notation importante dans l'organisation des données sur un système Linux. Expliquez son utilité.</p>
<pre>
    <code>
        <p>L'inode est à la fois :</p>
        <ul>
            <li>
                <p>l'identifiant d'une ressource sur le système de fichiers (répertoire, fichiers, liens symboiques, ...)</p>
            </li>
            <li>
                <p>une structure reprenant les propriétés des fichiers (au sens large) à savoir les timestamps (atime, ctime, mtime), les droits d'accès (UGO RWX), le nombre de liens, la taille, le type, ... Mais pas le nom de la ressource qui est stocké au niveau d'un répertoire.</p>
            </li>
        </ul>
    </code>
</pre>
                    <ol>
                        <li>
                            <p>Exécutez en tâche de fond la commande qui permet de rechercher tous les répertoires de l'arborescence de login, le résultat est sauvé dans le fichier <span class="em">interro2.txt</span> et les messages d'erreurs doiventêtre ignorés.</p>
<pre><code class="html">find ~ -type d &gt; interro2.txt 2&gt; /dev/null &</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui recherche toutes les lignes qui contiennent un commentaire commeçant en début de ligne par "<span class="em">//</span>" dans les fichiers sources java du répertoire <span class="em">I1040_sd</span>.</p>
<pre><code class="html">grep "^//.*$" I1040_sd/*.java</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des jobs du shell courant.</p>
<pre><code class="html">jobs</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de supprimer la tâche de numéro 4.</p>
<pre><code class="html">kill %4</code></pre>
                        </li>
                        <li>
                            <p>Créez un alias <span class="em">ll</span> qui affiche la liste longue d'un répertoire.</p>
<pre><code class="html">alias ll="ls -l"</code></pre>
                        </li>
                        <li>
                            <p>Utilisez l'alias que vous venez de créer pour sélectionner les répertoires du répertoire <span class="em">I1040_sd</span>.</p>
<pre><code class="html">ll I1040_sd | grep "^d"</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche la liste des fichier réguliers de l'arborescence issue du répertoire racine, qui ont au moins le droit d'écriture pour le groupe et les autres utilisateurs du système.</p>
<pre><code class="html">find / -type f -perm -go=w</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui affiche les processus de l'utilisateur connecté.</p>
<pre><code class="html">ps -u $(whoami)</code></pre>
                        </li>
                        <li>
                            <p>Donnez la taille totale des sources C (fichiers d'extension "<span class="html">.c</span>") du répertoire <span class="em">2100_lgC</span> du répertoire de login.</p>
<pre><code class="html">wc -c ~/I2100_lgC/*.c | tail -n1</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui crée le fichier <span class="em">modele.sh</span> dont la première line respecte le format "<span class="em"># lundi, 25 avril 2016</span>" (la date est récupérée du système).</p>
<pre><code class="html">echo "# $(date '+%A, %d %B %Y')" &gt; modele.sh</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui permet de déplacer tous les images (fichiers d'extension png) de la semaine de l'arborescence <span class="em">mesPhotos</span> dans le répertoire backup du répertoire de login.</p>
<pre><code class="html">find mesPhotos -name "*.png" -mtme -7 -exec mv {} ~/backup \;</code></pre>
                        </li>
                        <li>
                            <p>Donnez la commande qui supprime tous les droits aux autres utilisateurs sur les fichiers du répertoire parent dont l'extension est sur 2 caractères.</p>
<pre><code class="html">chmod o-rwx ../*.??</code></pre>
                        </li>
                        <li>
                            <p>Rappelez la commande précédente.</p>
<pre><code class="html">!!</code></pre>
                        </li>
                        <li>
                            <p>Recherchez dans le fichier <span class="em">mesContacts.txt</span> toutes les lignes qui se terminent par un nombre de 4 chiffres suivi par le caractère '<span class="em">.</span>'.</p>
<pre><code class="html">egrep "[0-9]{4}\.$" mesContacts.txt</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="exercices_supplemetaires_2">Exercices supplémentaires n° 2 :</h2>
                    <h3>Grep :</h3>
                    <p><span class="html">\b</span> représente une limite de mot.</p>
                    <p><span class="html">\B</span> représente une chaîne vide dans un mot (une non limite de mot).</p>
                    <ol>
                        <li>
                            <p>Donnez une expression régulière qui représente une chaîne qui commence et se termine par le même mot :</p>
<pre><code class="html">egrep "([a-zA-Z]*)\b.*\b\1$"</code></pre>
                        </li>
                        <li>
                            <p>Créez un alias <span class="em">grep</span> qui représente la commande <span class="html">grep -E --color</span> :</p>
<pre class="taille 60"><code class="html">alias grep="grep -E --color"</code></pre>
                        </li>
                        <li>
                            <p>Donnez une expresion régulière qui représente l'adresse web du site de l'IPL ou de VINCI :</p>
<pre><code class="html">egrep www\.(ipl|vinci)\.be</code></pre>
                        </li>
                        <li>
                            <p>Comptez le nombre lignes trop longues (&gt; 80 caractères) du fichier <span class="em">find.txt</span> :</p>
<pre><code><span class="html">egrep ".{81,}" seance06/theorie/doc/find.txt | wc -l</span>

# ou encore

<span class="html">egrep -c ".{81,}" seance06/theorie/doc/find.txt</span></code></pre>
                        </li>
                        <li>
                            <p>Recherchez dans l'arborescence <span class="em">seance06</span> les scripts bash (fichiers exécutables dont l'extension est <span class="html">sh</span>) et pour chaque script affichez-en le nom et les lignes qui contiennent un commentaire '#' et se termine à la fin de ligne.</p>
<pre><code><span class="html">egrep "^#" $(find seance06 -type f -name "*.sh")</span>

# ou encore

<span class="html">find seance06 -type f -name "*.sh" -ls -exec egrep "^#" {} \;</span></code></pre>
                        </li>
                        <li>
                            <p>La commande <span class="html">last</span> fournit les dernières connexions réussies au système. À partir de son contenu, donnez la liste de vos connections terminées.</p>
<pre><code><span class="html">last $(whoami) | grep -v "still logged in"</span>

# ou encore

<span class="html">last $(whoami) | grep "\)"</span>

# ou encore

<span class="html">last $(whoami) | egrep "\([0-9]{2}:[0-9]{2}\)"</span></code></pre>
                        </li>
                    </ol>
                    <h3>History :</h3>
                    <p>Sans une commande récupérée, il est possible d'exploiter l'un ou l'autre élément :</p>
                    <ul>
                        <li>
                            <p><span class="html">!...:0</span> : récupère le nom de la commande.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:m</span> : récupère le m<sup>ième</sup> argument.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:^</span> : récupère le 1<sup>er</sup> argument.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:$</span> : récupère le dernier argument.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:*</span> : récupère tous les arguments.</p>
                        </li>
                    </ul>
                    <p>Le mot récupéré peut être modifié soit pour :</p>
                    <ul>
                        <li>
                            <p><span class="html">!...:h</span> : sélectionne le path sans le nom du fichier final.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:t</span> : sélectionner le nom du fichier final (sans le path).</p>
                        </li>
                        <li>
                            <p><span class="html">!...:r</span> : sélectionner le path sans l'extension du fichier final.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:e</span> : sélectionner l'extension du fichier final.</p>
                        </li>
                        <li>
                            <p><span class="html">!...:s/a/b/</span> : modifier la 1<sup>ère</sup> occurence de <span class="em">a</span> par <span class="em">b</span>.</p>
                        </li>
                    </ul>
                    <ol>
                        <li>
                            <p>Créez le répertoire <span class="em">exercicesShell</span> et déplacez-vous y pour créer les fichiers <span class="em">test.txt</span> et <span class="em">test.bu</span>.</p>
<pre><code class="html">mkdir exercicesShell
cd !$
touch test.txt
^txt^bu</code></pre>
                        </li>
                        <li>
                            <p>Créez un répertoire <span class="em">revision</span>, inaccessible aux autres utilisateurs et déplacez-vous dans ce répertoire.</p>
<pre><code class="html">mkdir revision
chmod go-rwx !$
cd !$</code></pre>
                        </li>
                        <li>
                            <p>Configurez votre shell pour qu'il affiche l'heure à la réception d'un signal <span class="html">SIGINT</span> :</p>
<pre><code class="html">trap "date +%HH%M" SIGINT</code></pre>
                        </li>
                        <li>
                            <p>Comment pouvez-vous tester votre nouvelle configuration ?</p>
<pre><code class="html">&lt;ctrl+c&gt;</code></pre>
                        </li>
                        <li>
                            <p>Créez un répertoire <span class="em">public</span> dans le répertoire de login qui vous permet de publier des fichiers à l'intention de tous les autres utilisateurs du sytème.</p>
<pre><code class="html">mkdir ~/public
chmod o+rx !$</code></pre>
                        </li>
                        <li>
                            <p>Dans ce répertoire <span class="em">public</span>, créez un répertoire <span class="em">maSerie</span> accessible aux seuls étudiants de votre série.</p>
<pre><code class="html">cd !$
mkdir maSerie
chmod o-rwx !$</code></pre>
                        </li>
                        <li>
                            <p>Pouvez-vous tester cette configuration ? Si non, que faut-il faire pour tester ce répertoire ?</p>
<pre>
    <code>
        <p>Non. Plusieurs méthodes :</p>
        <ul>
            <li>
                <p>L'administrateur système crée un groupe et ajoute les utilisateurs de la série.</p>
            </li>
            <li>
                <p>Le répetoire de login est inaccessible aux autres, donc faire un <span class="html">chmod go+x ~</span> (~toto).</p>
            </li>
        </ul>
    </code>
</pre>
                        </li>
                        <li>
                            <p>Quelle est l'heure système ?</p>
<pre><code><span class="html">&lt;ctrl+c&gt;</span>

# ou encore

<span class="html">date %Hh%M</span></code></pre>
                        </li>
                        <li>
                            <p>Dans ce répertoire <span class="em">maSerie</span>, créez un fichier <span class="em">monArbo</span> qui reprend l'arborescence de votre répertoire de login (uniquement les répertoires); pour chaque fichier l'output ne reprend que le nom et les permissions.</p>
<pre><code class="html">cd maSerie
find -type d -printf "%M %p\n" &gt; monArbo</code></pre>
                        </li>
                        <li>
                            <p>Combien de lignes compte ce fichier ?</p>
<pre><code class="html">wc -l !1</code></pre>
                        </li>
                        <li>
                            <p>Affichez les lignes non vides de la page de manuel de la commande <span class="html">find</span>.</p>
<pre><code class="html">man find | egrep -v "^$"</code></pre>
                        </li>
                        <li>
                            <p>Affichez la liste des options de la commande <span class="html">grep</span>.</p>
<pre><code><span class="html">man grep | egrep "^( )*-"</span>

# ou encore

<span class="html">man grep | egrep "^[[:space:]]*-"</span></code></pre>
                        </li>
                        <li>
                            <p>Créez un répertoire <span class="em">scripts</span> dans votre répertoire de login. Créez-y un fichier <span class="em">modele.sh</span> qui contient une ligne qui respecte le format "<span class="em">#nom</span>" où <span class="em">nom</span> reprend le nom de l'utilisateur connecté.</p>
<pre><code class="html">mkdir ~/scripts
cd !$
echo "# $(whoami)" &gt; modele.sh</code></pre>
                        </li>
                        <li>
                            <p>Ajoutez-y une ligne reprenant la date et en respectant le même format (<span class="em">#date</span>.</p>
<pre><code class="html">echo "# $(date)" &gt;&gt; !$</code></pre>
                        </li>
                        <li>
                            <p>Comment obtenir le même résultat en stockat le texte dans une variable ?</p>
<pre><code class="html">v="# $(whoami)\n"
v="${v}# $(date)\n"
echo -e $v</code></pre>
                        </li>
                        <li>
                            <p>Recherchez tous les liens physiques d'un fichier présents dans une arborescence donnée (votre solution utilisera les commandes <span class="html">find</span>, <span class="html">ls</span>, <span class="html">cut</span> - n'oubliez pas de consulter les pages du man).</p>
<pre class="taill60"><code class="html">find . -inum $(ls -i toto | cut -d ' ' -f1)</code></pre>
                        </li>
                        <li>
                            <p>Pour vérifier votre solution, affichez le nombre de liens trouvés par votre commande et celui fourni par la commande <span class="html">stat</span> :</p>
<pre><code class="html">stat -c %h toto</code></pre>
                        </li>
                        <li>
                            <p>Affichez toutes les commandes stockées dans l'history qui contiennentun appel à la commande <span class="html">find</span>.</p>
<pre><code class="html">history | egrep "^find"</code></pre>
                        </li>
                        <li>
                            <p>Recherchez tous les fichiers compressés (extension .gz) du répertoire <span class="html">/var/log</span>.</p>
<pre><code class="html">find /var/log -type f -name "*.gz"</code></pre>
                        </li>
                        <li>
                            <p>Créez le répertoire <span class="em">~/tmp</span> et recopiez-y tous les fichiers vides de l'arborescence créée lors de la 6<sup>ième</sup> séance et dont le nom se termine par un chiffre paire, la recherche doit être réalisée en background.</p>
<pre><code class="html">mkdir ~/tmp
find ~/seance06 -type f -empty -name "[02468]$" -exec cp {} !$ \; &</code></pre>
                        </li>
                    </ol>
                    <h3>Script :</h3>
                    <ol>
                        <li>
                            <p>Quel est la commande pour savoir quel bash on utilise ?</p>
<pre><code class="html">which bash</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="fonctions">Les fonctions :</h2>
                    <h3>Présentation :</h3>
                    <ol>
                        <li>
                            <h4>Introduction :</h4>
                            <p>Comme d'autres langages de programmation, bash supporte l'utilisation de fonctions, (à ne pas confondre avec les méthodes des langages OO).</p>
                            <p>Contrairement au langage C, les fonctions ne doiventpas être déclarées, mais elles doivent être définies avant leur utilisation; en général, elles sont déclarées en début de fichier.</p>
                        </li>
                        <li>
                            <h4>Définition d'une fonction :</h4>
                            <ul>
                                <li>
                                    <p>Une fonction est définie par le mot réservé <span class="html">function</span> qui introduit le nom de la fonction.</p>
                                </li>
                                <li>
                                    <p>Le code de la fonction doit être entre les accolades {}.</p>
                                </li>
                                <li>
                                    <p>La fonction peut recevoir des informations du programme appelant grâce aux paramètres <span class="html">$1</span>, <span class="html">$2</span>, etc.</p>
                                </li>
                                <li>
                                    <p>La fonction se termine lorsqu'il n'y a plus de commande à exécuter ou bien lorsqu'elle rencontre la commande <span class="html">return</span>. Le code de retour de la fonction est un entier &lt;=255 qui vaut soit la valeur passée en argumentà la commande <span class="html">return</span>, soit le code de retour de la dernière commande exécutée avant de quitter la fonction.</p>
                                </li>
                                <li>
                                    <p>Exemple :</p>
<pre><code class="html">function f {

if [ -z $1 ]; then
    exit 255 # sortie immédiate du script
fi

echo "Il y a $# arguments"
cpt=1

for arg in $*; do
    ((cpt++))
done

return $# #sortie de la fonction avec une valeur imposée
}</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Les variables dans une fonction :</h4>
                            <p>Par défaut, les variables définies dans un script sont globales donc accessibles à l'intérieur des fonctions.</p>
                            <ul>
                                <li>
                                    <p>Une fonction peut accéder aux variables défiies dans le script.</p>
                                </li>
                                <li>
                                    <p>Une fonction peut déclarer des variables qui seront globales et accessibles en dehors de la fonction.</p>
                                </li>
                            </ul>
                            <p>Une fonction peut néanmoins définir des variables locales grâce au mot réservé local : <span class="html">local a=5</span>.</p>
                        </li>
                        <li>
                            <h4>Utilisation d'une fonction :</h4>
                            <p>La fonction est appelée par la simple évocation de son nom, qui peut être accompagné d'une liste d'arguments.</p>
                            <p>Exemple : <span class="html">f 1 2 3</span>.</p>
                        </li>
                    </ol>
                    <h3>Exercices :</h3>
                    <ol>
                        <li>
                            <p>Écrire une fonction bash <span class="em">cmpfile</span> qui permet de comparer deux fichiers en utilisant leur clé <span class="em">md5</span> (une clé md5 est une valeur obtenu en utilisant le programme <span class="html">md5sum(md5)</span> qui évalue la somme de contrôle du fichier à partir de son contenu). La fonction reçoit un ou deux argument(s). Le premier argument est la clé <span class="em">md5</span> du fichier à comparer, le second reprend le nom d'un fichier.</p>
                            <ul>
                                <li>
                                    <p>Si un des arguments est absent ou une chaîne vide, la fonction retourne le code 225.</p>
                                </li>
                                <li>
                                    <p>Si le deuxième argument est le nom d'un fichier vide, la fonction retourne le code 3.</p>
                                </li>
                                <li>
                                    <p>Si le deuxième fichier est identique au fichier à tester (même clé md5), la fonction retourne le code 0, sinon le code 1.</p>
                                </li>
                            </ul>
                            <p>Exemple : à l'appel de la fonction <span class="html">cmpfile $cle f1.sh</span> la fonction va retourner la valeur 0 si la clé md5 du fichier <span class="em">f1.sh</span> est égale à la clé sauvée dans la variable <span class="em">cle</span> calculée à partir du fichier à tester. La clé peut être obtenue en récupérant grâce à <span class="html">egrep</span> (option <span class="html">-o</span>) la clé produite par la commande <span class="html">md5sum</span> (en Linux) <span class="html">md5</span> (sur MacOS). N'oubliez pas de tester votre fonction dans les différentes situations.</p>
<pre><code class="html">#!/bin/bash

function cmpfile {

    if [ -z "$1" -o -z "$2" ]; then
        return 225
    elif [ ! -s "$2" ]; then
        return 3
    fi

    local cle=$(md5sum "$2" | egrep -o "^[[:xdigit:]]*")

    if [ "$1" == "$cle" ]; then
        return 0
    else
        return 1
    fi

}

cmpfile $(md5sum "$1" | egrep -o "^[0123456789abcdef]*") "$2"
echo "$?"</code></pre>
                        </li>
                        <li>
                            <p>Écrire un script <span class="em">checkRep.sh</span> qui utilise la fonction <span class="em">cmpfile</span> puis rechercher tous les fichiers d'une arborescence qui ont une ou plusieurs copies dans cette même arborescence.</p>
                            <p>Exemple : à l'appel <span class="html">checkRep.sh ..</span> le programme va parcourir toute l'arborescence et pour chaque fichier qui a une ou plusieurs copie(s) dans cette même arborescence, le script va afficher le nom fichier et de ses images.</p>
<pre><code>../interro.tar a 1 copie(s) :
    ../interro1Linux.tar
../script3/rep/checkRep.sh a 1 copie(s) :
    ../script3/rep2/checkRep.sh
../script3/rep2/chk2.sh a 2 copie(s) :
    ../script3/rep2/chk.sh
    ../script3/rep2/chk.tmp</code></pre>
                            <p>Avec for :</p>
<pre><code class="html">#!/bin/bash

function cmpfile {

    if [ -z"$1" ] || [ -z "$2" ]; then
        return 225
    elif [ ! -s "$2" ]; then
        return 3
    fi

    local cle=$(md5sum "$2" | egrep -o "[[:xdigit:]]*")

    if [ "$1" == "$cle" ]; then
        return 0
    else
        return 1
    fi

}

if [ -z "$1" -o ! -d "$1" ]; then
    echo "Veuillez entrer un répertoire en argument !"
    exit 1
fi

lesFichiers=($(find "$1" -type f 2&gt; /dev/null))
nombreFichiers=${#lesFichiers[*]}

for ((i=0; i &lt; "$nombreFichiers"; i++)); do
    f1="${lesFichiers[$i]}"
    cleF1=$(md5sum "$f1" | egrep -o "^[0123456789abcdef]*")
    lesCopies=()

    for ((j=i+1; j &lt; "$nombreFichiers"; j++)); do
        f2="${lesFichiers[$j]}"
        cmpfile "$cleF1" "$f2"
        lesCopies=("${#lesCopies[@]}" "$2")
    done

    v="\n$f1 a ${#lesCopies[*]} copie(s) :"

    for copie in "${lesCopies[@]}"; do
    v="${v}\n\t$copie"
    done

    echo -e "$v"

done

exit 0</code></pre>
                            <p>Avec while :</p>
<pre><code class="html">#!/bin/bash

function cmpfile {

    if [ -z "$1" ] || [ -z "$2" ]; then
        return 225
    elif [ ! -s "$2" ]; then
        return 3
    fi

    local cle=$(md5sum "$2" | egrep -o "^[[:xdigit:]]*")

    if [ "$1" == "$cle" ]; then
        return 0
    else
        return 1
    fi

}

if [ -z "$1" -o ! -d "$1" ]; then
    echo "Veuillez entrer un répertoire en argument !"
    exit 1
fi

lesFichiers=($(find "$1" -type f 2&gt; /dev/null))
nombreFichiers=${#lesFichiers[*]}
cpt1=0

while [ "$cpt1" -lt "$nombreFichiers" ]; do
    f1="${lesFichiers[$cpt1]}
    cleF1=$(md5sum "f1" | egrep -o "^[0123456789abcdef]*")
    lesCopies=()
    cpt2=$((cpt1+1))
    cpt3=0

    while [ "$cpt2" -lt "$nombreFichiers" ]; do
        f2="${lesFichiers[$cpt2]}"
        cmpfile "$cleF1" "$f2"

        if [ "$?" -eq 0 ]; then
            lesCopies[$cpt3]="$f2"
            ((cpt3++))
        fi

        ((cpt2++))
    done

    v="\n$f1 a $cpt3 copie(s) :"

    while [ "$cpt3" -ge 0 ]; do
        v="${v}\n\t${lesCopies[$cpt3]}"
        ((cpt3--))
    done

    echo -e "$v"
    ((cpt1++))

done

exit 0</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="examen_juin_2016">Examen Juin 2016 :</h2>
                    <h3>Écriture d'un script bash :</h3>
                    <p>Rédiger un script bash <span class="em">lsh</span> qui affiche la liste des scripts <span class="html">bash</span> du (desà répertoire(s) en arguments à la commande. Pour chaque script trouvé, votre programme doit afficher les lignes de commentaires d'entête (le début du fichier) (maximum 10 lignes).</p>
                    <p>Votre programme doit implémenter les directives suivantes :</p>
                    <ul>
                        <li>
                            <p>Le script reçoit 0, 1 ou plusieurs argument(s), le(s) nom(s) de répertoire(s). Si l'utilisateur ne positionne aucun argument, le script doit traiter le répertoire courant.</p>
                        </li>
                        <li>
                            <p>La liste des arguments doit être recopiées dans un tableau.</p>
                        </li>
                        <li>
                            <p>Si votre programme trouve au moins un script valide, il retourne le code 0 sinon la valeur 1.</p>
                        </li>
                        <li>
                            <p>Tous les messages d'erreur sont sauvés dans un fichier log dans le répertoire <span class="em">var</span> du répertoire de login de l'utilisateur, le nom du fichier incorpore le pid du programme pour en assurer une certaine unicité, ce nom est de la forme <span class="em">lshXXX.log</span> où <span class="em">XXX</span> représente le pid du programme.</p>
                        </li>
                        <li>
                            <p>En fin de traitement, votre programme doit afficher le nombre total de scripts valides (de type text et dont le shebang (<span class="html">#!</span>, entête d'un fichier text qui spécifie le type de script) est correct).</p>
                        </li>
                        <li>
                            <p>Pour une meilleure lisibilité des résultats affichés, votre programme marque une pause après chaque script trouvé (en attendant que l'utilisateur introduise un caractère), de plus, cette pause permet à l'utilisateur d'écourter la boucle de traitement d'un répertoire s'il introduit une ligne vide ou une marque de fin de fichier (<span class="html">&lt;ctrl+d&gt;</span> en Linux/Unix).</p>
                        </li>
                        <li>
                            <p>Les messages d'erreur que votre programme peut générer selon les suivants :</p>
                            <ul>
                                <li>
                                    <p>L'argument ... n'est pas un répertoire.</p>
                                </li>
                                <li>
                                    <p>le fichier ... n'est pas de type text.</p>
                                </li>
                                <li>
                                    <p>le shebang du fichier ... ne correspond pas à celui d'un script bash.</p>
                                </li>
                                <li>
                                    <p>le script ... n'a pas de commentaire en début de fichier.</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h3>Liste de quelques commandes de base de Linux (avec leurs options essentielles) :</h3>
                    <h4>echo :</h4>
<pre><code class="html">echo [-ne] [message ...]</code></pre>
                    <p><span class="html">echo</span> écrit chaque <span class="html">message</span> sur la sortie standard, avec un espace entre chacun d'eux, et un saut de ligne après le dernier.</p>
                    <p>options :</p>
                    <p><span class="html">-n</span> : Ne pas effectuer le saut de ligne final.</p>
                    <p><span class="html">-e</span> : Interpréter les séquences de caractères précédées.</p>
                    <h4>file :</h4>
<pre><code class="html">file fichier ...</code></pre>
                    <p><span class="html">file</span> teste chaque <span class="html">fichier</span> : la commande affiche une description reprnenant le mot <span class="html">text</span>, <span class="html">executable</span>, ou <span class="html">data</span> en fonction du contenu analysé.</p>
                    <h4>egrep :</h4>
<pre><code class="html">egrep [-lLqv] motif fichier ...</code></pre>
                    <p><span class="html">egrep</span> recherche dans les <span class="html">fichiers</span> d'entrée indiqués les lignes correspondant à un certain <span class="html">motif</span>.</p>
                    <p>options :</p>
                    <p><span class="html">-l</span> : affiche le nom des fichiers pour lesquels un résultat est trouvé, sans afficher ce résultat.</p>
                    <p><span class="html">-L</span> : cf. option <span class="html">-l</span> mais en inversant la recherche.</p>
                    <p><span class="html">-q</span> : quiet n'affiche rien, positionne le code de retour.</p>
                    <p><span class="html">-v</span> : inverse la recherche, affiche les lignes ne correspondant pas au <span class="html">motif</span>.</p>
                    <h4>head :</h4>
<pre><code class="html">head [-n N] fichier ...</code></pre>
                    <p><span class="html">head</span> affiche sur la sortie standard le début des <span class="html">fichiers</span>.</p>
                    <p>options :</p>
                    <p><span class="html">-n N</span> : affiche les <span class="html">N</span> premières lignes.</p>
                    <h4>read :</h4>
<pre><code class="html">read [-p prompt] nom ...</code></pre>
                    <p><span class="html">read</span> lit une ligne sur l'entrée standard, chaque mot lu est stocké dans la variable <span class="html">nom</span>, la fin de la ligne est sauvé dans la dernière variable.</p>
                    <p>options :</p>
                    <p><span class="html">-p prompt</span> : affiche le <span class="html">prompt</span> (sans passer à la ligne) avant d'effectuer la lecture.</p>
                    <h4>exit :</h4>
<pre><code class="html">exit valeur</code></pre>
                    <p><span class="html">exit</span> termine le script en retournant la <span class="html">valeur</span>.</p>
<pre><code class="html">#!/bin/bash
compteur=0
log=/var/lsh$$.log

if [ "$#" -eq 0 ]; then
    tab="."
else
    tab=($*)
fi

for rep in ${tab[*]}; do

    if [ ! -d "$rep" ]; then
        echo "L'argument $rep n'est pas un répertoire" &gt;&gt; "$log"
        continue
    fi

    for fichier in $(ls"$rep"); do
        fichier="$rep/$fichier"

        if [ ! -f "$fichier" ]; then
        elif ! file "$fichier" | egrep -q "text"; then
            echo "Le fichier $fichier n'est pas de type text" &gt;&gt; "$log"
        elif ! head -1 "$fichier" | egrep -q "#!/bin/(ba)?sh"; then
            echo "Le shebang du fichier $fichier ne correpond pas à celui d'un script bash" &gt;&gt; "$log"
        else
            ((compteur++))
            echo -e "\n$fichier\n"
            head -10 "$fichier" | egrep -o "^#.*$"
            echo -e "\n"
        fi

        if ! read -p "Veuillez introduire un caractère : " c && [ -z "$c" ]; then
            break
        fi

    done

done

echo -e "\nIl y a $compteur fichier(s) valide(s) !!!"

if [ "$compteur" -ge 1 ]; then
    exit 0
else
    exit 1
fi</code></pre>
                </article>
                <article>
                    <h2 id="examen_juin_2017">Examen de Juin 2017 :</h2>
                    <h3>Écriture d'un script bash :</h3>
                    <p>Écrire une fonction <span class="em">entete</span> qui affiche l'entête d'un script bash passé en paramètre. Cette fonction commence par vérifier l'existence d'un paramètre et que ce paramètre contient le nom d'un fichier régulier de type <span class="html">text</span>. Dans l'affirmative, la fonction affiche sur <span class="html">stdout</span>les 15 premières lignes de commentaire et retourne un code nul. En cas d'erreur, la fonction affiche un message d'erreur sur <span class="html">stderr</span> et retourne un code strictement positif (1 si absence de paramètre, 2 s'il ne contient pas le nom d'un fichier et 2 si ce n'est pas un script bash).</p>
                    <p>Écrire une seconde fonction <span class="em">enteteRep</span> qui recherche les scripts d'un répertoire dont le nom est en paramètre. La fonction vérifie que l'argument est bien un répertoire sinon elle affiche un message sur <span class="html">stderr</span> et retourne code valant 11. Pour chaque script trouvé, elle affiche l'entête grâce à la fonction <span class="em">entete</span> écrite précédemment. La fonction retourne un code valant 0 si au moins un script a été trouvé sinon un code valant 1.</p>
                    <p>Écrire le script <span class="em">resume.sh</span> qui reçoit 0, un plusieurs arguments. S'il n'y a pas d'arguments le script doit traiter le répertoire courant sinon pour chaque argument, le script vérifie s'il s'agit d'un fichier régulier (dans ce cas, il utilise la fonction <span class="em">entete</span>) ou d'un répertoire (dans ce cas, il utilise la fonction <span class="em">enteteRep</span>.</p>
                    <h3>Liste de quelques commandes de base de Linux (avec leurs options essentielles) :</h3>
                    <h4>echo :</h4>
<pre><code class="html">echo [-ne] [message ...]</code></pre>
                    <p><span class="html">echo</span> écrit chaque <span class="html">message</span> sur la sortie standard, avec un espace entre chacun d'eux, et un saut de ligne après le dernier.</p>
                    <p>options :</p>
                    <p><span class="html">-n</span> : Ne pas effectuer le saut de ligne final.</p>
                    <p><span class="html">-e</span> : Interpréter les séquences de caractères précédées.</p>
                    <h4>file :</h4>
<pre><code class="html">file fichier ...</code></pre>
                    <p><span class="html">file</span> teste chaque <span class="html">fichier</span> : la commande affiche une description reprnenant le mot <span class="html">text</span>, <span class="html">executable</span>, ou <span class="html">data</span> en fonction du contenu analysé.</p>
                    <h4>egrep :</h4>
<pre><code class="html">egrep [-lLqv] motif fichier ...</code></pre>
                    <p><span class="html">egrep</span> recherche dans les <span class="html">fichiers</span> d'entrée indiqués les lignes correspondant à un certain <span class="html">motif</span>.</p>
                    <p>options :</p>
                    <p><span class="html">-l</span> : affiche le nom des fichiers pour lesquels un résultat est trouvé, sans afficher ce résultat.</p>
                    <p><span class="html">-L</span> : cf. option <span class="html">-l</span> mais en inversant la recherche.</p>
                    <p><span class="html">-q</span> : quiet n'affiche rien, positionne le code de retour.</p>
                    <p><span class="html">-v</span> : inverse la recherche, affiche les lignes ne correspondant pas au <span class="html">motif</span>.</p>
                    <h4>head :</h4>
<pre><code class="html">head [-n N] fichier ...</code></pre>
                    <p><span class="html">head</span> affiche sur la sortie standard le début des <span class="html">fichiers</span>.</p>
                    <p>options :</p>
                    <p><span class="html">-n N</span> : affiche les <span class="html">N</span> premières lignes.</p>
                    <h4>read :</h4>
<pre><code class="html">read [-p prompt] nom ...</code></pre>
                    <p><span class="html">read</span> lit une ligne sur l'entrée standard, chaque mot lu est stocké dans la variable <span class="html">nom</span>, la fin de la ligne est sauvé dans la dernière variable.</p>
                    <p>options :</p>
                    <p><span class="html">-p prompt</span> : affiche le <span class="html">prompt</span> (sans passer à la ligne) avant d'effectuer la lecture.</p>
                    <h4>exit :</h4>
<pre><code class="html">exit valeur</code></pre>
                    <p><span class="html">exit</span> termine le script en retournant la <span class="html">valeur</span>.</p>
                    <h4>return :</h4>
<pre><code class="html">return valeur</code></pre>
                    <p><span class="html">return</span> termine la fonction en retournant la <span class="html">valeur</span>.</p>
                    <h3>Solution longue (préférée par le prof de l'époque, Mr Bernard Henriet) :</h3>
<pre><code class="html">#!/bin/bash
# fonction entete qui affiche l'entête d'un fichier dont le nom est passé en paramètre
function entete {

    if [ -z "$1" ]; then
        echo "absence de paramètre" &gt;&gt; /dev/stderr
        return 1
    fi

    if [ ! -f "$1" ] || ! file "$1" | egrep -q "text"; then
        echo "$1 pas un fichier text" &gt;&gt; /dev/stderr
        return 2
    fi

    if ! head -1 "$1" | egrep -q "^#!/bin/(ba)sh$"; then
        echo "$1 pas un script bash" &gt;&gt; /dev/stderr
        return 3
    fi

    head -15 "$1" | egrep -o "^#.*"
    return 0
}

# fonction enteteRep quii recherche les scripts d'un répertoire
function enteteRep {

    if [ ! -d "$1" ]; then
        echo "$1 pas un répertoire" &gt;&gt; /dev/stderr
        return 11
    fi

    local cpt=0

    for fichier in $(ls "$1"); do
        entete "$fichier"
        
        if [ "$?" -eq 0 ]; then
            ((cpt++))
        fi

    done

    if [ "$cpt" -le 1 ]; then
        return 0
    else
        return 1
    fi

}

# programme principal
if [ "$#" -eq 0 ]; then
    args="."
else
    args=$(*)
fi

for arg in ${args[*]}; do

    if [ -f "$arg" ]; then
        entete "$arg"
    elif [ -d "$arg" ]; then
        enteteRep "$arg"
    fi

done</code></pre>
                    <h3>Solution courte (écrite par moi-même lors de l'examen papier à l'époque) :</h3>
<pre><code class="html">#!/bin/bash
# fonction entete qui affichhe l'entête d'un fichier dont le nom est passé en paramètre
function entete {
    
    if [ -z "$1" ]; then
        echo "absence de paramètres" &gt;&gt; /dev/stderr
        return 1
    elif ! file "$1" | egrep -q "text"; then
        echo "$1 pas un fichier text" &gt;&gt; /dev/stderr
        return 2
    elif ! head -1 "$1" | egrep -q "^#!/bin/(ba)sh" &gt;&gt; /dev/stderr
        echo "$1 pas un script bash" &gt;&gt; /dev/stderr
        return 3
    fi

    head -15 "$1" | egrep -o "^#.*"
}

# fonction enteteRep qui recherche les scripts d'un répertoire
function enteteRep {

    if [ ! -d "$1" ]; then
        echo "$1 pas un répertoire" &gt;&gt; /dev/stderr
        return 11
    fi

    local cpt=0

    for fichier in $(ls "$1"); do
        if entete "$fichier"; then
            ((cpt++))
        fi
    done

    if [ "$cpt" -le 1 ]; then
        return 0
    else
        return 1
    fi

}

# programme principal
if [ "$#" -eq 0 ]; then
    args="."
else
    args=($*)
fi

for arg in ${args[*]}; do
    
    if [ -f "$arg" ]; then
        entete "$arg"
    elif [ -d "$arg" ]; then
        enteteRep "$arg"
    fi

done</code></pre>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>