<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>XML - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#DTD">Les DTD</a></li>
                        <li><a href="#XML_Schemas">Les XML Schemas</a></li>
                        <li><a href="#XML_JAVA">XML et JAVA</a></li>
                        <li><a href="#feuilles_style">Les feuilles de style</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Structures de données : avancé : XML :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Ce syllabus est le support du cours de XML de 2<sup>ème</sup> année de Bac informatique de gestion de l'Institut Paul Lambin.</p>
                    <p>L'objectif de ce cours est de permettre à l'étudiant de comprendre les structures de données XML ainsi que leurs validations par des DTD et des XML Schema. Les étudiants comprendront également les avantages de telles structures et surtout comment les manipuler. Ensuite, ils comprendront comment lire, modifier et créer des documents XML en Java. Enfin, ils apprécieront la puissance des feuilles XSLT et des requêtes XQuery combinés aux expressions xPath.</p>
                    <p>Les objectifs intermédiaires sont les suivants :</p>
                    <ol>
                        <li>
                            <p>En ce qui concerne le XML :</p>
                            <ul>
                                <li>
                                    <p>Compréhension de la syntaxe et de la structure d'un document XML.</p>
                                </li>
                                <li>
                                    <p>Développement de documents XML.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>En ce qui concerne les DTD :</p>
                            <ul>
                                <li>
                                    <p>Compréhension de la syntaxe, de la structure, de l'unité et des limites des DTD.</p>
                                </li>
                                <li>
                                    <p>Développement de DTD.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>En ce qui concerne les XML Schema :</p>
                            <ul>
                                <li>
                                    <p>Compréhension de la syntaxe et de la structure des XML Schema.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>En ce qui concerne des parseurs XML en Java :</p>
                            <ul>
                                <li>
                                    <p>Développement de parseur de type SAX et DOM.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>En ce qui concerne les feuilles XSL et le XPath :</p>
                            <ul>
                                <li>
                                    <p>Compréhension de l'usage des feuilles de style XSL, du langage XSLT et des expressions XPath.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>En ce qui concerne les requêtes XQuery :</p>
                            <ul>
                                <li>
                                    <p>Développement de requêtes XQuery.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <p>Ce syllabus s'articule autour de 7 grands chapitres :</p>
                    <ol>
                        <li>
                            <p><span class="html">Les bases XML</span> : le vocabulaire XML, les règles de composition et de formulation de <span class="em">document XML bien formé</span>.</p>
                        </li>
                        <li>
                            <p><span class="html">DTD</span> : la <span class="em">validation des documents XML</span> par l'usage des Document Type Definition.</p>
                        </li>
                        <li>
                            <p><span class="html">XML Schema</span> : la <span class="em">validation des documents XML</span> par l'usage des XML Schema. Comparaison avec les DTD.</p>
                        </li>
                        <li>
                            <p><span class="html">Java et XML</span> : la <span class="em">manipulation en Java</span> de document XML.</p>
                        </li>
                        <li>
                            <p><span class="html">XSL</span> : la <span class="em">transformation des documents XML</span> par l'usage du eXtensive StyleSheet Language et du eXtensible Stylesheet Language Transformation.</p>
                        </li>
                        <li>
                            <p><span class="html">XPath</span> : la <span class="em">recherche simple</span> d'information dans les documents XML.</p>
                        </li>
                        <li>
                            <p><span class="html">XQuery</span> : la <span class="em">recherche avancée</span> d'information dans les documents XML.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="documents_XML">Les documents XML :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <ol>
                                <li>
                                    <h4>Les principes du XML :</h4>
                                    <ol>
                                        <li>
                                            <h5>XML, un langage de balisage :</h5>
                                            <p>XML signifie eXensible Markup Language, ce qui signifie <span class="em">langage de balisage de données</span> extensible. Le balisage désigne les règles qui doivent être utilisées pour concevoir les balises. En mer, une balise est une perche surmontée d'un objet visible qui indique un danger.</p>
                                            <p>En informatique, une balise est une marque destinée à l'identification, la description ou la mise en forme d'un élément de document. Elle définit le contenu au niveau sémantique. Les balises délimitent donc les données d'un document; elles permettent de les marquer. On parle de métadonnées qui permettent de donner du sens aux données.</p>
                                            <p>Prenons un exemple, considérons la chaîne de caractères suivante : "Rue de l'arbre, 43 à 1300 Wavre".</p>
                                            <p>Nous comprenons tous que les données de l'exemple ci-dessus correspondent à une adresse postale. Notre cerveau a automatiquement compris l'information contenue dans ces données et nous avons "inconsciemment" ajouté des métadonnées qui nous ont permis de comprendre l'adresse en tant que telle.</p>
                                            <p>Un système informatique est initialement dépourvu de telle intelligence et comprend donc ces données comme une chaîne de caractères et rien de plus. C'est donc à nous de structurer ces données afin qu'elles constituent de l'information, c'est-à-dire qu'elles véhiculent du sens. Nous entendons ici le terme information comme des données et des métadonnées qui les décrivent (Information = donnée + métadonnée).</p>
                                            <p>Afin de structurer les données, nous allons utiliser des métadonnées qui permettront de restituer la sémantique voulue. Effectivement, automatiquement, nous avons perçu cette chaîne comme une adresse; inconsciemment, nous avons placés des métadonnées sur les données. Une métadonnée est une donnée qui permet de décrire une donnée, qui donne du sens à une donnée.</p>
                                            <p>Plaçons les balises dans notre chaînes de caractères :</p>
<pre><code>&lt;adresse&gt;
    &lt;rue&gt;Rue de l'arbre&lt;/rue&gt;
    &lt;numero&gt;43&lt;/numero&gt;
    &lt;codePostal&gt;1300&lt;/codePostal&gt;
    &lt;ville&gt;Wavre&lt;/ville&gt;
&lt;/adresse&gt;</code></pre>
                                            <p>Notre chaîne de caractères ainsi balisée prend tout son sens et devient de l'information !</p>
                                        </li>
                                        <li>
                                            <h5>Les différences entre HTML et XML :</h5>
                                            <p>Le HTML (HyperText Markyp Language) est également un langage informatique basé sur SGML, qui décrit les différents éléments d'un texte à l'aide de balises, en vue de sa publication sur internet. Le XHTML (eXtensible HyperText Markup Language) est le HTML qui respecte les règles du XML.</p>
                                            <p>Le XML et HTML ont pour point commun d'être des langages de balisage reponsant sur le SGML mais ils sont bien et bien différents dans leur usage et dans leur intention. Le tableau ci-dessous compare le XML et le HTML.</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>HTML</th>
                                                        <th>XML</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>Langage de présentation des données</td>
                                                        <td>Langage de structuration des données (importance de la sémantique)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Interprétation dépendante des browsers</td>
                                                        <td>Information toujours pareille</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Nombre de tags définis par le langage</td>
                                                        <td>Nombre illimité de tags définis par l'utilisateur</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Conçu uniquement pour le Web</td>
                                                        <td>Conçu pour toutes manipulations (transport ou stockage de données)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>
                                                            <p>Peu de rigueur dans la vérification de la syntaxe.</p>
                                                            <p>Exemple : un tag non fermé ne provique pas obligatoirement une erreur.</p>
                                                        </td>
                                                        <td>Vérification intransigeante. Tant syntaxique que structurelle (via DTD par exemple).</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>XML - version 1.0 ou version 1.1 :</h5>
                                            <p>Le W3C a tenu à ce que la norme reste inchangée depuis sa publication initiale malgré la publication d'errata et d'éditions.</p>
                                            <p>Malheureusement la norme Unicode n'a pas eu la même stabilité. La version Unicode 2.0 sur laquelle se base la version 1.0 de XML a évolué vers la norme 4.0 incluant de nouveaux caractères.</p>
                                            <p>La <span class="em">version 1.1</span> du XML prend donc en compte ces nouveaux caractères. Il s'agit donc d'une évolution mineure par rapport à la <span class="em">version 1.0</span>.</p>
                                            <p>La version 1.0 reste donc tout à fait variable. Il est d'ailleurs conseillé de n'utiliser la version 1.1 que quand cela est réellement nécessaire car beaucoup d'applications ne sont pas encore compatibles avec la version 1.1.</p>
                                            <blockquote>
                                                <q>XML 1.1 updates XML so that it no longer depends on the specific Unicode version: you can always use the latest. It also adds checking of normalization, and follows the Unicode,line ending rules more closely. You are encouraged to create or generate XML 1.0 documents if you do not need the new features in XML 1.1; XML Parsers are expected to understand both XML 1.0 and XML 1.1.</q>
                                                <a href="http://www.w3.org/XML/Core#_blank" target="_blank">http://www.w3.org/XML/Core</a>
                                            </blockquote>
                                        </li>
                                        <li>
                                            <h5>SGML :</h5>
                                            <p>En 1986, un standard voit le jour dans le domaine de la gestion documentaire : SGML (Standard Generalized Markup Language, Standard ISO n°8879). SGML est un langage de balisage établi pour créer d'autres langages de balisge. La complexité de mise en oeuvre du SGML en avait limité l'usage à de très grands systèmes documentaires. En 1996 une équipe conduite par Jon Bosak de Sun Microsystems décide de créer une version du SGML plus simple et mieux adaptée aux besoins d'échange de données sur le Web. Le XML est né. En quelques mois, il raille tous les efforts dans ce domaine et le W3C publie la première version le 10 février 1998. Les spécifications du XML tiennent sur 26 pages à comparer aux 500 5.s du SGML !</p>
                                            <q>XML c'est 20% de la complexité de SGML et 80% de ses capacités.</q>
                                            <p>XML est un sous ensemble de SGML. De telle sorte, tout document XML valide est aussi un document SGML valide.</p>
                                        </li>
                                        <li>
                                            <h5>Les usages du XML :</h5>
                                            <p>Citons quelques exemples d'utilisation du XML :</p>
                                            <ul>
                                                <li>
                                                    <p>On utilise du XML en tant que <span class="em">fichier de propriétés</span> qui permet la configuration d'un serveur ou d'une application.</p>
                                                </li>
                                                <li>
                                                    <p>Afin de <span class="em">standardiser</span> des <span class="em">échanges d'informations</span> entre diverses applications Web par exemple, c'est-à-dire des web services, on se conforme à des standards qui reposent sur le XML (WSDL (Web Services Description Language), SOAP (Simple Object Access Protocol) et UDDI (Universal Description Discovery and Integration)).</p>
                                                </li>
                                                <li>
                                                    <p>Une source d'information peut avoir plusieurs utilisations ou présentations. Dans ce cas, le XML permet de <span class="em">structurer l'information</span> dans un seul document (une seule source) et permet l'affichage, l'impression, ou encore mise à disposition sur un CD-ROM, (...) et ce avec plusieurs présentations différentes.</p>
                                                </li>
                                                <li>
                                                    <p>On utilise également le XML comme une "mini cache". Quand un fichier XML est la source de données d'une page Web (en HTML), il est possible d'y opérer des sélections, de faire une nouvelle recherche sans refaire transiter l'information sur le net.</p>
                                                </li>
                                            </ul>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Définitions :</h4>
                                    <ol>
                                        <li>
                                            <h5>Les caractéristiques du XML :</h5>
                                            <p>Il s'agit d'un <span class="em">langage de balisage</span> de données comme expliqué ci-dessus mais bien plus encore...</p>
                                            <ul>
                                                <li>
                                                    <p>XML a été conçu pour <span class="em">manipuler des données</span> (transporter et stocker).</p>
                                                </li>
                                                <li>
                                                    <p>XML permet un <span class="em">nombre illimité de balises</span>; chacun peut en créer.</p>
                                                </li>
                                                <li>
                                                    <p>XML rend les <span class="em">données auto-descriptives</span>.</p>
                                                </li>
                                                <li>
                                                    <p>XML est <span class="em">international</span>; il utilise le <span class="em">standard Unicode</span>, un système d'encodage des caractères qui permet de mélanger des textes dans la plupart des alphabets du monde. Unicode est une norme informatique, développée par le consortium Unicode, qui vise à donner à tout caractère de n'importe quel système d'écriture de langue un nom et un identifiant numérique, et ce de manière unifiée, quelle que soit la plate-forme informatique ou le logiciel.</p>
                                                </li>
                                                <li>
                                                    <p>XML est une <span class="em">recommandation</span> du <span class="em">W3C</span> qui est organisme de standardisation qui met en oeuvre des normes Web. Pour en savoir plus sur la recommandation XML : <a href="http://www.w3.org/XML/" target="_blank">http://www.w3.org/XML/</a>. Le XML est donc <span class="em">indépendant</span> au point de vue :</p>
                                                    <ul>
                                                        <li>
                                                            <p>Plate-forme</p>
                                                        </li>
                                                        <li>
                                                            <p>Vendeur / constructeur</p>
                                                        </li>
                                                        <li>
                                                            <p>Langage de programmation</p>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h5>Vocabulaire :</h5>
                                            <dl>
                                                <dt>Balise</dt>
                                                <dd>
                                                    <p>Une <span class="em">balise</span> est un <span class="em">délimiteur de données</span> ou encore une <span class="em">métadonnée</span>. En anglais, on parle de <span class="em">tag</span>. Une balise est comprise entre les signes &lt; et &gt;. Il existe des <span class="em">balises ouvrantes</span> et <span class="em">fermantes</span>. Une balise ouvrante est une balise qui ouvre un élément tandis qu'une balise fermante le ferme. Une balise fermante commence par /.</p>
                                                    <p>Exemples :</p>
                                                    <ul>
                                                        <li>
                                                            <p>Une balise ouvrante livre : <span class="em">&lt;livre&gt;</span></p>
                                                        </li>
                                                        <li>
                                                            <p>Une balise fermante album : <span class="em">&lt;/album&gt;</span></p>
                                                        </li>
                                                    </ul>
                                                </dd>
                                                <dt>Élément</dt>
                                                <dd>
                                                    <p>Un <span class="em">élément</span> est composé d'une balise d'ouverture, des données et de la balise de fermeture correspondante.</p>
                                                    <p>Élément = balise d'ouverture + (<span class="em">donnée textuelle</span> ou sous-éléments) + balise de fermeture</p>
                                                    <p>Exemples :</p>
<pre><code>&lt;titre&gt;Les Misérables&lt;/titre&gt;

&lt;livre&gt;
    &lt;titre&gt;Les Misérables&lt;/titre&gt;
    &lt;auteur&gt;Hugo&lt;/auteur&gt;
&lt;/livre&gt;</code></pre>
                                                </dd>
                                                <dt>Élément vide</dt>
                                                <dd>
                                                    <p>Un <span class="em">élément vide</span> est un élément <span class="em">sans aucune donnée</span>. Voici deux manières similaires d'écrire un élément vide :</p>
<pre><code>&lt;vide&gt;&lt;/vide&gt;

&lt;vide/&gt;</code></pre>
                                                </dd>
                                                <dt>Attribut</dt>
                                                <dd>
                                                    <p>Un <span class="em">attribut</span> est un descriptif que l'on place <span class="em">dans uen balise ouvrante</span>. Un attribut porte un <span class="em">nom</span> et <span class="em">contient une valeur</span> donnée, c'est-à-dire une <span class="em">donnée textuelle</span>, entre <span class="em">guillemets</span>. Une balise d'ouverture peut contenir un ou des attributs mais une seule fois chaque attribut.</p>
                                                    <p>Exemples :</p>
<pre><code>&lt;personne sexe="F"&gt;Lisa&lt;/personne&gt;

&lt;animal race="chien"/&gt;</code></pre>
                                                </dd>
                                                <dt>Élément racine</dt>
                                                <dd>
                                                    <p>L'<span class="em">élément racine</span>, <span class="em">root</span> element, est l'<span class="em">élément principal</span> du document XML. Il englobe tous les autres éléments.</p>
                                                    <p>Dans l'exemple ci-dessous, <span class="em">carnet.xml</span>, <span class="em">carnet</span> est l'élément racine du document XML :</p>
<pre><code>&lt;carnet&gt;
    &lt;personne titre="Mme"&gt;
        &lt;nom&gt;Leconte&lt;/nom&gt;
        &lt;prenom&gt;Emmeline&lt;/prenom&gt;
        &lt;contact&gt;
            &lt;tel&gt;027644688&lt;/tel&gt;
            &lt;bureau&gt;028&lt;/bureau&gt;
            &lt;email&gt;emmiline.leconte&amp;#64;ipl.be&lt;/email&gt;
        &lt;/contact&gt;
    &lt;/personne&gt;
    &lt;personne titre="Mr"&gt;
        &lt;nom&gt;Debacker&lt;/nom&gt;
        &lt;prenom&gt;Michel&lt;/prenom&gt;
        &lt;contact&gt;
            &lt;tel&gt;027644653&lt;/tel&gt;
            &lt;bureau&gt;045&lt;/bureau&gt;
            &lt;email&gt;michel.debacker&amp;#64;ipl.be&lt;/email&gt;
        &lt;/contact&gt;
    &lt;/personne&gt;
&lt;/carnet&gt;</code></pre>
                                                </dd>
                                                <dt>Document XML</dt>
                                                <dd>un fichier qui renferme uniquement du XML est ce que l'on appelle un <span class="em">document XML</span>.</dd>
                                            </dl>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Écrire un document XML :</h3>
                            <ol>
                                <li>
                                    <h4>Le prologue du document XML :</h4>
                                    <ol>
                                        <li>
                                            <h5>La déclaration XML :</h5>
                                            <p>Un document XML débute par une <span class="em">ligne d'instruction de traitement</span> qui permet de déclarer que le document est effectivement du XML. Une instruction de traitement commence toujours par <span class="em">&lt;?</span>.</p>
                                            <p>La déclaration XML est <span class="em">obligatoirement</span> la <span class="em">première</span> ligne du document. Il ne faut placer ni commentaire, ni même une simple ligne vide avant elle.</p>
                                            <p>Cette déclaration XML, <span class="em">facultative mais vivement conseillée</span>, permet à l'application qui va manipuler ce document de l'interpréter correctement. Cette instruction <span class="em">ne fait pas partie du document</span> en soi.</p>
                                            <p>Exemple de déclaration XML :</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</code></pre>
                                            <p>Les attributs présents <span class="em">version</span>, <span class="em">encoding</span> et <span class="em">standalone</span> doivent être placés dans cet ordre.</p>
                                            <ul>
                                                <li>
                                                    <p><span class="html">version</span> : version du XML utilisée dans le document, 1.0 en ce qui nous concerne;</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">encoding</span> : le jeu de codage de caractères utilisé. Le jeu de caractères habituel pour le français est l'<span class="em">ISO-8859-1</span>. Il a tendance à être remplacé par l'<span class="em">ISO-8859-15</span> en attendant la généralisation de l'Unicode. Par dafaut, l'attribut <span class="html">encoding</span> a la valeur <span class="em">UTF-8</span>. Cela permet à l'ordinateur de "savoir" quel caractère il doit afficher en réponse aux combinaisons de 1 et de 0 que contient le fichier sur le disque dur;</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">standalone</span> : dépendance du document par rapport à une déclaration de type de document. Si <span class="html">standalone</span> a la valeur <span class="em">yes</span>, le processeur de l'application n'attend aucune déclaration de type de document extérieure au document. Sinon, le processeur attend une référence de déclaration de type de document. La valeur par défayt est <span class="em">no</span>.</p>
                                                </li>
                                            </ul>
                                            <p>Après la déclaration XML, on peut déclarer éventuellement une feuille de style.</p>
<pre><code>&lt;?xml-stylesheet type="text/xsl" href="fichier.xsl"?&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>La déclaration de type de document :</h5>
                                            <p>Cette déclaration, lorsqu'elle est présente, permet de référencer la DTD qui permet la <span class="em">validation</span> du document.</p>
<pre><code>&lt;!DOCTYPE elementRacine [ ... définition ou appel de la DTD ... ]&gt;</code></pre>
                                            <p>Cette section doit se trouver juste après la déclaration XML et juste avant l'élément racine du document. <span class="em">Après</span> le mot <span class="html">DOCTYPE</span>, il faut indiquer l'<span class="em html">élément racine</span> du document XML.</p>
                                            <p>Ensuite, il faut préciser soit la définition de la DTD lorsqu'elle est <span class="em">interne</span> au document XML soit l'appel vers la DTD <span class="em">externe</span> au document XML.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>L'élement racine :</h4>
                                    <p>Enfin, après la déclaration XML et la déclaration de la DTD, le document XML commence à proprement parler. Il <span class="em">débute</span> toujours par l'<span class="em">élément racine</span> (root element). Il s'agit de l'élément maître qui inclut tous les autres éléments du document. Il n'y a qu'un seul élément racine dans un document XML.</p>
                                    <p>Finalement, un document XML se structure généralement comme suit :</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;!DOCTYPE elementRacine [ ... définition ou appel de la DTD ... ]&gt;

&lt;elementRacine&gt; ...
&lt;/elementRacine&gt;</code></pre>
                                    <p>Dans l'élment racine se trouvent la déclaration de tous les éléments du document, éventuellement avec des attributs. Ces éléments doivent respecter des <span class="em">règles lexicales</span> quant à leur <span class="em">composition</span> mais aussi des <span class="em">règles de formation</span> qui définissent la <span class="em">syntaxe</span> à respecter pour que le document XML soit bien formé.</p>
                                    <ol>
                                        <li>
                                            <h5>Les règles de composition :</h5>
                                            <p>Tous les éléments constituants d'un document XML doivent être écrits en suivant les règles de <span class="em">lexicales</span> énoncées ci-après.</p>
                                            <p>Tout <span class="em">identificateur</span> XML, c'est-à-dire nom de balise, nom d'attribut, valeur d'attribut de type ID, nom de namespace, ... doit :</p>
                                            <ol>
                                                <li>
                                                    <p><span class="em">Commencer</span> par une des lettres de l'alphabet ou l'underscore (_).</p>
                                                </li>
                                                <li>
                                                    <p>Se poursuivre avec des lettres de l'alphabet, des chiffres, des underscores (_), des tirets (-) ou des points(.).</p>
                                                </li>
                                                <li>
                                                    <p>Absolument <span class="em">ne pas</span> contenir d'<span class="em">espace</span>.</p>
                                                </li>
                                                <li>
                                                    <p><span class="em">Ne pas</span> contenir de deux points (:) car ceux-ci sont réservés.</p>
                                                </li>
                                            </ol>
                                            <p class="em">Attention XML est sensible à la casse : A n'est pas a ! b n'est pas B, ...</p>
                                            <p>Dans la suite (partie parlant de la DTD), nous abordons le type ID des attributs.</p>
                                        </li>
                                        <li>
                                            <h5>Les règles de formulation :</h5>
                                            <p>Un document XML est <span class="em">bien formé</span> (well-formed XML document) est un document XML dont la <span class="em">syntaxe</span> est correcte.</p>
                                            <p>Cela signifie qu'il :</p>
                                            <ol>
                                                <li>
                                                    <p>Respecte les <span class="em">règles de composition</span> énoncées ci-dessus.</p>
                                                </li>
                                                <li>
                                                    <p>Renferme en première ligne la <span class="em">déclaration XML</span>.</p>
                                                </li>
                                                <li>
                                                    <p>Les <span class="em">valeurs</span> d'<span class="em">attribut XML</span> doivent toujours être entre <span class="em">guillemets</span>.</p>
                                                </li>
                                                <li>
                                                    <p>Se compose d'<span class="em">éléments</span> qui se <span class="em">correspondent</span> de manière hiérarchique. Les éléments XML doivent être positionnés <span class="em">correctement</span>. Ce point est détaillé ci-après.</p>
                                                </li>
                                            </ol>
                                            <p>Dire que les éléments doivent se correspondre signifie qu'il faut veiller à ce qu'un élément qui commence, dans un élement se termine bien dans ce même élément.</p>
                                            <p>Par exemple, <span class="em">&lt;tag1&gt;&lt;tag2&gt; ... &lt;/tag2&gt; &lt;/tag1&gt;</span> est bien formé car <span class="em">tag2</span> débute et se ferme dans <span class="em">tag1</span>. Mais <span class="em">&lt;tag1&gt;&lt;tag2&gt; ... &lt;/tag1&gt; &lt;/tag2&gt;</span> n'est pas bien formé car <span class="em">tag2</span> se ferme après <span class="em">tag1</span>.</p>
                                            <p>Remarquez que les règles de formulation sont très permissives. Des valeurs peuvent flotter, c'est-à-dire se trouver en dehors de balises (sauf de l'élément racine). Effectivement, l'élément <span class="em">&lt;tag1&gt; donnée 1 &lt;tag2&gt; donnée 2 &lt;/tag2&gt; donnée 3 &lt;/tag1&gt;</span> est bien formé pourtant <span class="em">donnée 1</span> et <span class="em">donnée 3</span> ne sont pas dans des éléments précis, elles "flottent" dans l'élément <span class="em">tag1</span>. Ces données seront plus difficilement accessibles dans tout parseur, c'est pourquoi il est vivement recommandé de ne pas faire flotter de donnés.</p>
                                            <p>Attention, <span class="em">il ne faut pas confondre</span> la notion de document <span class="em">bien formé</span> avec celle de document <span class="em">valide</span>, qui se définit comme un document XML bien formé dont la structure obéit à un modèle (ou schéma) donné par une DTD ou un XML Schema.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Les données textuelles :</h4>
                                    <p>Notons au préalablable que les caractères blancs sont l'espace, la tabulation, le retour chariot (carriage return) ou le passage à la ligne (linefeed). La différence entre le retour chariot (\r) et le passage à la ligne (\n) est historique. Elle trouve son origine dans les machines à écrire, à la fin de la ligne écrite on doit faire un retour du chariot pour se positionner en début de ligne et tourner le rouleau d'un cran pour passer à la ligne suivante. En Windows, le passage à la ligne suivante se marque par l'usage d'un retour du chariot et d'un passage à la ligne (\r\n). En Linux, il suffit de faire un passage à la ligne (\n).</p>
                                    <p>Les <span class="em">données textuelles</span> sont les valeurs qui apparaissent au sein d'un <span class="em">élément</span> ou comme valeur d'un <span class="em">attribut</span>.</p>
                                    <p>Elles peuvent se composer de <span class="em">caractères blancs</span> et de <span class="em">caractères imprimables</span> du jeu de caractères utilisé dans le document XML exceptés quelques caractères notamment "&lt;" réservé au balisage, "&amp;" pour l'encodage des caractères spéciaux, ...</p>
                                    <p>Les caractères "&lt;" et "&amp;" doivent donc être codés par une <span class="em">référence de caractères</span> ou par une entité prédéfinie sauf s'ils sont au sein d'une section CDATA (Character Data, c'est-à-dire n'importe quelle chaîne de caractères) ou d'une instruction de traitement.</p>
                                    <p>" et ' doivent également être codés dans une donnée textuelle.</p>
                                    <p>Par exemple :</p>
<pre><code>&lt;dessin_anime&gt;Tom &amp;amp; Jerry&lt;/dessin_anime&gt;</code></pre>
                                    <ol>
                                        <li>
                                            <h5>gestion des caractères blancs :</h5>
                                            <p>La gestion des caractères blancs est différente pour les éléments et les attributs.</p>
                                            <ul>
                                                <li>
                                                    <p>pour les données textuelles comprises dans la <span class="em">valeur d'un attribut</span>, le parseur effectue une normalisation qui consiste à remplacer les caractères blancs par des espaces.</p>
                                                </li>
                                                <li>
                                                    <p>pour les attributs de type autre que CDATA, le parseur remplace toute suite de caractères blancs par un seul espace et il supprime les caractères blancs en fin ou début de valeur d'attribut.</p>
                                                </li>
                                            </ul>
                                            <p>Les caractères blancs contenus dans une donnée textuelle d'un <span class="em">élément</span> sont par contre par défaut transmis par le parseur à l'application sauf s'il existe une DTD ou un XML Schema indiquant qu'il faut les ignorer. Effectivement, ces caractères ont parfois tout leur sens mais parfois il s'agit simplement d'une question de mise en forme. Le parseur ne peut pas toujours faire la différence entre ceux-ci.</p>
                                            <p>Prenons un exemple :</p>
<pre><code>&lt;carnetAnniversaires&gt;
    &lt;anniversaire&gt, &lt;date&gt;1/4&lt;/date&gt;
        &lt;qui&gt;Jean-Marc Dupond&lt;/qui&gt;
        &lt;qui&gt;Mireille de la Fontaine&lt;/qui&gt;
    &lt;/anniversaire&gt;
&lt;/carnetAnniversaires&gt;</code></pre>
                                            <p>Dans cet exemple, les blancs situés entre les balises <span class="em">&lt;qui&gt;</span> et <span class="em">&lt;/qui&gt;</span> doivent toujours être conservés tandis qu'entre les autres balises, les caractères blancs sont là uniquement pour la mise en forme.</p>
                                        </li>
                                        <li>
                                            <h5>&lt;!CDATA[ :</h5>
                                            <p>Une donnée textuelle peut contenir une ou plusieurs <span class="em">zones de données non structurées</span>, c'est-à-dire <span class="em">zones CDATA</span>. Une zone CDATA est une zone qui ne sera pas interprétée comme du XML mais comme une donnée; les balises qu'elle contient sont ignorées.</p>
                                            <p>Par exemple :</p>
<pre><code>&lt;doc&gt;
<span class="em">&lt;![CDATA[</span>
    Cette zone non structurée &lt;/p&gt; permet de mettre des &lt;balises&gt; &amp; autres dedans ... &lt; div &lt;ceQueJeVeux&gt; &gt;
<span class="em">]]&gt;</span>
&lt;/doc&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>Les références de caractères :</h5>
                                            <p>S'ils ne sont pas reconnus directement par le type d'encodage (précisé dans l'attribut <span class="html">encoding</span> de ligne de déclaration XML), kes caractères non-imprimables doivent être notés par une <span class="em">référence de caractères</span> constitué du code décimal (ou <span class="em">hexadécimal</span>) de ce caractère dans <span class="em">Unicode</span> précédé de "<span class="em">&amp;#</span> et suivi d'un "<span class="em">;</span>".</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>caractère</th>
                                                        <th>référence</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>é</td>
                                                        <td>&amp;#E9;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>è</td>
                                                        <td>&amp;#E8;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ê</td>
                                                        <td>&amp;#EA;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ë</td>
                                                        <td>&amp;#EB;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>î</td>
                                                        <td>&amp;#EE;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ï</td>
                                                        <td>&amp;#EF;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ô</td>
                                                        <td>&amp;#F4;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>ö</td>
                                                        <td>&amp;#F6;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>$</td>
                                                        <td>&amp;#24;</td>
                                                    </tr>
                                                    <tr>
                                                        <td>²</td>
                                                        <td>&amp;#B2;</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Exemples :</p>
<pre><code>&lt;prenom&gt;Am&amp;#E9;lie&lt;/prenom&gt;  (Amélie)
&lt;nom&gt;No&amp;EB;l&lt;/nom&gt;  (Noël)
&lt;prix&gt;45&amp;#24;&lt;/prix&gt;   (45$)</code></pre>
                                            <p>Toutes les références de caractères définies en Unicode est disponible sur <a href="http://www.unicode.org/" target="_blank">http://www.unicode.org/</a>.</p>
                                        </li>
                                        <li>
                                            <h5>Les références d'entité :</h5>
                                            <p>Un document XML peut contenir des <span class="em">références d'entité</span> constituées du nom d'une entité précédé d'un "<span class="em">&amp;</span>" et suivi d'un "<span class="em">;</span>". Une entité est une unité de stockage qui contient une partie d'un document XML.</p>
                                            <p>Exemple :</p>
<pre><code>&lt;synopsis&gt;
    Il était une fois dans une forêt lointaine, une jeune fille (jouée par &amp;princesse;) qui dormait ...
&lt;/synopsis&gt;</code></pre>
                                            <p>Dans l'exemple, <span class="em">princesse</span> est une entité référencée. Le parseur remplacera celle-ci par le texte de remplacement correspondant dans la définition de l'entité.</p>
                                            <p>La définition d'une entité se fait par le biais d'un DTD qui peut être interne au document XML ou externe.</p>
                                            <p>Dans notre exemple, l'entité peut être référencée en interne comme suit :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE synopsis [
&lt;!ENTITY princesse "Jennifer Lopez"&gt;
]&gt;
&lt;synopsis&gt;
    Il était une fois dans une forêt lointaine, une jeune fille (jouée par &amp;princesse;) qui dormait ...
&lt;/synopsis&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>Les entités prédéfinies :</h5>
                                            <p>Il existe en XML quelques entités prédéfinies pour coder les caractères spéciaux :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>caractère</th>
                                                        <th>référence</th>
                                                        <th>signification</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>&amp;</td>
                                                        <td>&amp;amp;</td>
                                                        <td>ampersand</td>
                                                    </tr>
                                                    <tr>
                                                        <td>&lt;</td>
                                                        <td>&amp;lt;</td>
                                                        <td>less then</td>
                                                    </tr>
                                                    <tr>
                                                        <td>&gt;</td>
                                                        <td>&amp;gt;</td>
                                                        <td>greater then</td>
                                                    </tr>
                                                    <tr>
                                                        <td>"</td>
                                                        <td>&amp;quot;</td>
                                                        <td>quote</td>
                                                    </tr>
                                                    <tr>
                                                        <td>'</td>
                                                        <td>&amp;apos;</td>
                                                        <td>apostophe</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Les commentaires :</h4>
                                    <p>En XML, un commentaire se note comme en HTML, car ils reprennent la syntaxe du SGML.</p>
                                    <p>Ils commencent donc par <span class="em">&lt;!--</span> et se terminent par <span class="em">--&gt;</span>. Ils peuvent être placés à n'importe quel endroit tant qu'ils se trouvent à l'extérieur d'une balise.</p>
                                    <p>Exemples de commentaires valides :</p>
<pre><code>&lt;!-- ceci est un commentaire --&gt;

&lt;elt&gt; &lt;!-- ceci est un commentaire --&gt; Un peu de texte &lt;/elt&gt;

&lt;!-- &lt;commentaireCorrect&gt; --&gt;</code></pre>
                                    <p>En raison de la compatibilité XML/SGML, la chaîne de caractères <span class="em">--</span> est interdite dans un commentaire.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Réflexion : choisir entre un élément et un attribut :</h3>
                            <p>Faut-il utiliser un attribut ou un élément ? C'est une question souvent posée et qui mérite quelques réflexions ...</p>
                            <p>Il faut savoir avant tout que techniquement parlant, il n'y a pas de réponse à la question. Les applications XML traiteront l'information sans aucun problème avec des performances similaires.</p>
                            <p>Le choix qu'on pose dépend donc de divers facteurs tels que la lisibilité du document, la facilité d'encodage, également la concision que l'on veut apporter au document.</p>
                            <p>Voici quelques pistes :</p>
                            <ul>
                                <li>
                                    <p>L'usage d'éléments engendre des documents XML plus volumineux mais offre une meilleure structure et donc une meilleure lisibilité.</p>
                                </li>
                                <li>
                                    <p>Si le séquencement a de l'importance, on privilégiera l'usage d'élément dans lequel l'ordre a toute son importance.</p>
                                </li>
                                <li>
                                    <p>Un attribut ne peut être présent qu'une seule fois au sein d'un élément tandis qu'un élément peut être plusieurs fois présent.</p>
                                </li>
                                <li>
                                    <p>En ce qui concerne les données contenues, un élément peut être vide. Dans un attribut, le contenu peut être une valeur par défaut, ou encore être une énumération de valeurs possibles ou encore imposer l'unicité du contenu dans l'ensemble du document.</p>
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="DTD">Les DTD :</h2>
                    <ol>
                        <li>
                            <h3>Définition :</h3>
                            <p>Une Document Type Definition fournit comme son nom l'indique une définition des types du document XML. Une DTD décrit de manière précise quels éléments peut contenir un document XML, dans quel ordre ils peuvent apparaître et quels sont leurs attributs.</p>
                            <p>Lorsqu'un document XML est <span class="em">bien formé</span>, c'est-à-dire qu'il respecte les règles de formulation, et qu'il respecte également une <span class="em">DTD</span>, on dit que ce document est <span class="em">valide</span>. Une DTD fournit donc une <span class="em">définition de la structure et des règles qu'un document XML doit suivre pour être valide</span>.</p>
                            <p>Dans une DTD, il y a donc des déclarations d'éléments, d'attributs et d'entités. Il y a également des notations mais ce pont n'est pas abordé dans le cours. Nous nous contentons des définitions d'éléments et d'attributs.</p>
                        </li>
                        <li>
                            <h3>Déclaration de DTD :</h3>
                            <p>La déclaration d'une DTD peut être effectuée en <span class="em">interne</span>, directement dans la déclaration du type de document, ou alors en <span class="em">externe</span>, dans un fichier séparé dont l'URI est donné dans la décaration du type de document.</p>
                            <p><span class="html">URI</span> : Uniform Resource Identifier &#859§; String qui permet d'identifier une ressource sur internet</p>
                            <p><span class="html">URN</span> : Uniform Resource Name &#8596; String correspondant au nom de la ressource</p>
                            <p><span class="html">URL</span> : Uniform Resource Locator &#8596; String correspondant à l'adresse de la ressource</p>
                            <img src="../images/URI_URN_URL.png" alt="">
                            <p>La déclaration d'une DTD qu'elle soit interne ou externe <span class="em">se trouve entre la déclaration XML et la racine du document</span>. Dans un document HTML, la DTD doit être déclarée en première ligne.</p>
                            <p>La déclaration d'une DTD débute toujours par <span class="html">&lt;!DOCTYPE</span> suivi du nom de l'élément <span class="em">racine</span> du document. Attention, la définition de l'élément racine est propre au document XML, il ne s'agit pas d'une information fournie par une DTD (ni un XML Schema).</p>
                            <p>Prenons l'exemple d'une page HTML qui renferme égalemnt une déclaration de doctype :</p>
<pre><code>&lt;!DOCTYPE <span class="em">html</span> ...
&lt;<span class="em">html</span>&gt;
&lt;head&gt;...&lt;/head&gt;
&lt;body&gt;...&lt;/body&gt;
&lt;/<span class="em">html</span>&gt;</code></pre>
                            <p><span class="em">html</span> est le nom de l'élément racine du document.</p>
                            <ol>
                                <li>
                                    <h4>Déclarer une DTD interne :</h4>
                                    <p>Par exemple :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?&gt;
&lt;!DOCTYPE voitures [
    &lt;!ELEMENT voitures (voiture) * &gt;
    ...
]&gt;
&lt;voitures&gt;
    &lt;voiture&gt;...&lt;/voiture&gt;
    ...
&lt;/voitures&gt;</code></pre>
                                    <p>Remarquez que dans la déclaration XML de l'exemple, l'attribut <span class="html">standalone</span> prend la valeur <span class="em">yes</span> puisqu'aucun DTD externe n'est déclarée. Pour rappel, par défaut, la valeur de <span class="html">standalone</span> est <span class="em">no</span>.</p>
                                </li>
                                <li>
                                    <h4>Déclarer une DTD externe :</h4>
                                    <p>Dans la déclaration du doctype, on trouve l'URI qui permet d'atteindre le fichier dont l'extension est ".dtd" externe. Dans cette déclaration, avant l'URI, on trouve le mot SYSTEM ou PUBLIC.</p>
                                    <p>Le mot <span class="html">SYSTEM</span> est utilisé pour signifier que l'URI de la DTD référencée est une URI relative au document XML.</p>
                                    <p>Par exemple :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="no"?&gt;
&lt;!DOCTYPE voitures SYSTEM "voitures.dtd"&gt;
&lt;voitures&gt;
    &lt;voiture&gt;...&lt;/voiture&gt;
    ...
&lt;/voitures&gt;</code></pre>
                                    <p>Le mot <span class="html">PUBLIC</span> est utilisé pour signifier que la DTD référencée est publique. Dans ce cas, on précise l'idnetificateur public de cette DTD suivi de l'URI qui permet d'y accéder.</p>
                                    <p>De façon similaire, dans les fichiers HTML, la déclaration de doctype est publique. L'identificateur public qui permet de signifier que le document HTML respecte la norme 4.01 strict est <span class="em">"-//W3C//DTD HTML 4.01//EN"</span> et son URI est <span class="em">"http://www.w3c.org/TR/html4/strict.dtd"</span>.</p>
                                    <p>Voici un exemple de document HTML qui référence la DTD 4.01 strict :</p>
<pre><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3c.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1"&gt;
&lt;title&gt;Le titre de ma page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
J'écris ici le contenu de ma page...
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                                    <p>Remarquez que les browsers ont des copies locales des DTD validant les documents HTML pour éviter l'explosion des demandes sur <span class="em">http://www.w3c.org</span>.</p>
                                    <p>Toutes les DTD publiques émises par le W3C sont disponibbles sur le site <a href="http://www.w3.org/QA/2002/04/valid-dtd-list.html" target="_blank">http://www.w3.org/QA/2002/04/valid-dtd-list.html</a>.</p>
                                </li>
                                <li>
                                    <h4>Syntaxe :</h4>
                                    <p>En résumé, la déclaration d'une DTD peut s'écrire de cinq façons :</p>
<pre><code>&lt;!DOCTYPE racine [déclarations internes]&gt;
&lt;!DOCTYPE racine SYSTEM "URI"&gt;
&lt;!DOCTYPE racine SYSTEM "URI" [déclarations internes]&gt;
&lt;!DOCTYPE racine PUBLIC "id_public" "URI"&gt;
&lt;!DOCTYPE racine PUBLIC "id_public" "URI" [déclarations internes]&gt;</code></pre>
                                    <p>Il est effectivement possible de déclarer à la fois une DTD interne et une DTD externe. Dans un tel cas, c'est l'ensemble des définitions des deux DTD que le document XML doit respecter pour être valide. Si jamais une définition se trouve à la fois en externe et en interne, c'est la définition interne qui sera prioritaire.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Écrire une DTD :</h3>
                            <p>Dans une DTD, on détaille les règles de validation de document XML. Il s'agit d'une énumération de règles de définition pour les éléments, pour les attributs ainsi que pour les entités.</p>
                            <p>L'ordre dans lequel les règles sont déclarées n'a aucune importance.</p>
                            <ol>
                                <li>
                                    <h4>Déclaration d'élément :</h4>
                                    <ol>
                                        <li>
                                            <h5>&lt;!ELEMENT :</h5>
                                            <p>Une déclaration d'élment dans une DTD permet de définir un élément et son contenu, c'est-à-dire ce qui se trouve entre sa balise ouvrante et sa balise fermante.</p>
                                            <p>La déclaration d'un élément débute par <span class="html">&lt;!ELEMENT</span> suivi du nom de l'élément puis du format du contenu de cet élément et enfin <span class="em">&gt;</span>.</p>
                                            <p>On distingue quatre types de format :</p>
                                            <ul>
                                                <li>
                                                    <p class="html">EMPTY</p>
                                                </li>
                                                <li>
                                                    <p class="html">ANY</p>
                                                </li>
                                                <li>
                                                    <p class="html">#PCDATA</p>
                                                </li>
                                                <li>
                                                    <p>Les formes composées</p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h5>EMPTY :</h5>
                                            <p><span class="html">EMPTY</span> permet de déclarer qu'un élément doit toujours être vide, c'est-à-dire qu'il ne peut contenir aucun élément, ni aucune donnée textuelle.</p>
                                            <p>Par exemple :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT flag EMPTY&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;flag/&gt;
&lt;flag&gt;&lt;/flag&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>PCDATA :</h5>
                                            <p><span class="html">PCDATA</span>, Parsed Character Data, indique qu'un élément peut contenir des données textuelles.</p>
                                            <p>Par exemple :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT texte(#PCDATA)&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;texte&gt;Des textuelles...&lt;/texte&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Il est possible de mélanger les données textuelles avec d'autres éléments, pour autant qu'ils soient correctement déclarés dans la DTD, en utilisant la barre verticale | et l'astérisque *. Le format à respecter est <span class="html">(#PCDATA | element1 | element2 | ...)*</span>.</p>
                                            <p>Par exemple :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT texte (#PCDATA | flag)*&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;texte&gt;Des données &lt;flag/&gt; textuelles... &lt;/texte&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>ANY :</h5>
                                            <p>Un élément dont le contenu est défini de type <span class="html">ANY</span> peut contenir un mélange de données textuelles et de n'importe quels autres éléménts, pour autant qu'ils soient correctement déclarés dans la DTD.</p>
                                            <p>Par exemple :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT tout ANY&gt;
Pour autant que flag et texte soient correctement définis, comme ci-dessus.</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;tout&gt;
Du texte et des éléments &lt;flag/&gt; ou &lt;texte&gt; avec du contenu textuel &lt;/texte&gt;
&lt;/tout&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>Les formes composées :</h5>
                                            <p>Les formes composées permettent de déclarer des éléments qui contiennent uniquement d'autres éléments et pas de données textuelles.</p>
                                            <p>Il s'agit de définir quels sont les éléments enfants que peut contenir l'élément en question et l'ordre dans lequel ils doivent apparaître. Kes éléments enfants doivent être correctement déclarés dans le fichier.</p>
                                            <p>Une forme composée s'indique entre parenthèses. La parenthèse fermante peut être suivie du caractère <span class="em">?</span>, <span class="em">*</span> ou <span class="em">+</span> pour préciser un nombre d'occurences.</p>
                                            <p>En résumé :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td class="em">(contenu)?</td>
                                                        <td>L'élément doit contenir 0 ou 1 fois le contenu.</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="em">(contenu)*</td>
                                                        <td>L'élément doit contenir 0 ou plusieurs fois le contenu.</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="em">(contenu)+</td>
                                                        <td>L'élément doit contenir 1 ou plusieurs fois le contenu.</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="em">(contenu)</td>
                                                        <td>L'élément doit contenir 1 fois le contenu.</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Le contenu spécifié entre parenthèse peut prendre plusieurs formes :</p>
                                            <ul>
                                                <li>
                                                    <p>Soit correspondre exactement à un élément déjà déclaré.</p>
                                                </li>
                                                <li>
                                                    <p>Soit correspondre à une <span class="em">suite</span> d'éléments déjà déclarés séparés par des <span class="em">virgules</span>.</p>
<pre><code>(element1, element2, ...)</code></pre>
                                                </li>
                                                <li>
                                                    <p>Soit correspondre à un <span class="em">choix</span> entre des éléments déjà déclarés séparés par une <span class="em">barre verticale</span>.</p>
<pre><code>(element1 | element2 | ...)</code></pre>
                                                </li>
                                            </ul>
                                            <p>Dans les suites et les choix, chaque élément peut être suivi d'un <span class="em">?</span>, <span class="em">*</span> ou <span class="em">+</span> pour préciser un nombre d'occurences.</p>
                                            <p>Par exemples :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT personne (nom, prenom+, contact?)&gt;

Sachant que
&lt;!ELEMENT nom (#PCDATA)&gt;
&lt;!ELEMENT prenom (#PCDATA)&gt;
&lt;!ELEMENT contact (#PCDATA)&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;personne&gt;
    &lt;nom&gt;Leconte&lt;/nom&gt;
    &lt;prenom&gt;Emmeline&lt;/prenom&gt;
    &lt;prenom&gt;Simone&lt;/prenom&gt;
&lt;/personne&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT carnet (personne)*&gt;

Sachant que personne est défini ci-dessus</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;carnet&gt;
    &lt;personne&gt;
        &lt;nom&gt;Leconte&lt;/nom&gt;
        &lt;prenom&gt;Emmeline&lt;/prenom&gt;
        &lt;prenom&gt;Simone&lt;/prenom&gt;
    &lt;/personne&gt;
    &lt;personne&gt;
        &lt;nom&gt;Debacker&lt;/nom&gt;
        &lt;prenom&gt;Michel&lt;/prenom&gt;
    &lt;/personne&gt;
&lt;/carnet&gt;</code></pre>                                                            
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ELEMENT client (personne | societe)&gt;

Sachat que personne est défini ci-dessus
&lt,!ELEMNT societe (#PCDATA)&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;client&gt;
    &lt;personne&gt;
        &lt;nom&gt;Leconte&lt;/nom&gt;
        &lt;prenom&gt;Emmeline&lt;/prenom&gt;
    &lt;/personne&gt;
&lt;/client&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Enfin, dans une suite ou un choix, chaque élément peut être lui-même une forme composée.</p>
                                            <p>Dans l'exemple suivant, un <span class="em">contact</span> se compose d'un <span class="em">tel</span> suivi de 0 ou plusieurs <span class="em">tel</span>, <span class="em">gsm</span> ou <span class="em">fax</span>, ensuite éventuellement un <span class="em">email</span>, enfin 1 ou plusieurs <span class="em">adresse</span> :</p>
<pre><code>&lt;!ELEMENT contact (tel, (tel|gsm|fax)*, email?, adresse+à&gt;

&lt;contact&gt;
    &lt;tel&gt; 00 32 2 737 48 81 &lt;/tel&gt;
    &lt;fax&gt; 00 32 2 737 28 07 &lt;/fax&gt;
    &lt;email&gt; cap48@rtbf.be &lt;/email&gt;
    &lt;adresse&gt; Bd Reyers n°52 1044 Bruxelles &lt;/adresse&gt;
    &lt;adresse&gt; 5, chée de Bruxelles 1300 Wavre &lt;/adresse&gt;
&lt;/contact&gt;</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Déclaration d'attribut :</h4>
                                    <ol>
                                        <li>
                                            <h5>&lt;!ATTLIST : </h5>
                                            <p>La déclaration d'attributs permet de définir les attributs que peut ou doit contenir un élément du document.</p>
                                            <p>La déclaration d'attributs pour un élément débute par <span class="html">&lt;!ATTLIST</span> suivi du <span class="em">nom</span> de l'élément pour lequel on déclare les attributs puis la <span class="em">spécification</span> de chacun des attributs que l'on veut déclarér et enfin <span class="em">&gt;</span>. Chaque déclaration d'attributs est séparée par un espace, une tabulation ou un retour à la ligne.</p>
                                            <p>La spécification d'un attribut débute par son nom, puis son type et enfin une précision sur sa valeur par défaut.</p>
                                            <p>On peut déclarer tous les attributs d'un élément dans une seule règle ATTLIST ou utiliser une règle ATTLIST par attribut :</p>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST element
attr_nom1 TypeAttribut Presence
attr_nom2 TypeAttribut Presence
...&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;!ATTLIST element
attr_nom1 TypeAttribut Presence ...&gt;
&lt;!ATTLIST element
attr_nom2 TypeAttribut Presence ...&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>Les types d'attribut (TypeAttribut) :</h5>
                                            <p>Le type d'un attribut peut valoir :</p>
                                            <dl>
                                                <dt>CDATA</dt>
                                                <dd>
                                                    <p>CDATA, Character Data, représente une chaîne de caractères quelconques.</p>
                                                </dd>
                                                <dt>Un choix entre valeurs</dt>
                                                <dd>
                                                    <p>Une valeur choisie dans une liste de valeurs possibles, c'est-àdire un énuméré.</p>
                                                    <p>Par exemple (A|B|C), la valeur de l'attribut doit être une de celles listées : A, B ou C.</p>
                                                </dd>
                                                <dt>ID</dt>
                                                <dd>
                                                    <p><span class="html">ID</span> permet de définir un identificateur <span class="em">unique</span> un élément du document. Donc chaque <span class="html">ID</span> doit être différent au sein du document !</p>
                                                </dd>
                                                <dt>IDREF</dt>
                                                <dd>
                                                    <p><span class="html">IDREF</span> permet de définir un attribut dont la valeur doit correspondre à un attribut <span class="html">ID</span> dans un des éléments du document.</p>
                                                </dd>
                                                <dt>IDREFS</dt>
                                                <dd>
                                                    <p><span class="html">IDREFS</span> pemret de définir un attribut dont la valeur doit correspondre à 1 ou plusieurs <span class="html">ID</span> définis dans le document. Chaque ID doit être séparé par un espace.</p>
                                                </dd>
                                                <dt>NMTOKEN</dt>
                                                <dd>
                                                    <p><span class="html">NMTOKEN</span> permet de définir un attribut dont la valeur doit être un seul mot (sans caractère blanc).</p>
                                                </dd>
                                                <dt>NMTOKENS</dt>
                                                <dd>
                                                    <p><span class="html">NMTOKENS</span> permet de définir un attribut dont la valeur doit être plusieurs <span class="html">NMTOKEN</span> séparé par un ou plusieurs caractères blancs.</p>
                                                </dd>
                                                <dt>ENTITY et ENTITIES</dt>
                                                <dd>
                                                    <p>Un attribut de type <span class="html">ENTITY</span> doit contenir un mot qui doit correspondre à une entité déclarée dans la DTD. Pour le type <span class="html">ENTITIES</span>, il s'agit d'une liste d'entités déclarées séparées par un ou plusieurs caractères blancs.</p>
                                                </dd>
                                            </dl>
                                        </li>
                                        <li>
                                            <h5>La présence de l'attribut (Presence) :</h5>
                                            <p>Après la précision du type de l'attribut, il faut déclarer la valeur par défaut ou son caractère obligatoire.</p>
                                            <p>Il y a quatre valeurs possibles :</p>
                                            <dl>
                                                <dt>#REQUIRED</dt>
                                                <dd>
                                                    <p>L'attribut doit avoir une valeur; il n'y a pas de valeur par défaut. L'attribut est donc <span class="em">obligatoire</span>.</p>
                                                </dd>
                                                <dt>#IMPLIED</dt>
                                                <dd>
                                                    <p>L'attribut peut être ignoré si aucune valeur n'est donné; il n'y a pas de valeur par défaut. L'attribut n'est <span class="em">pas obligatoire</span>.</p>
                                                </dd>
                                                <dt>"valeur_par_défaut"</dt>
                                                <dd>
                                                    <p>L'attribut n'est <span class="em">pas obligatoire</span> et il possède une <span class="em">valeur par défaut</span>. Lorsque l'attribut n'est pas présent, c'est cette valeur qui sera utilisée par défaut.</p>
                                                </dd>
                                                <dt>#FIXED "valeur"</dt>
                                                <dd>
                                                    <p>Enfin, il est possible de fixer la valeur d'un attribut quand celui-ci est présent grâce au mot clef #FIXED suivi de ladite valeur. Dans ce cas, l'attribut lorsqu'il est présent ne peut jamais contenir <span class="em">que la valeur précisée</span> entre guillemets.</p>
                                                    <p>Cette situation peut par exemple se rencontrer lorsque l'on souhaite travailler dans une devise bien précise et que l'on souhaite qu'elle apparaisse dans le document.</p>
                                                </dd>
                                            </dl>
                                        </li>
                                        <li>
                                            <h5>Exemples :</h5>
                                            <table class="tableBalises">
                                                <tbody>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST personne prenom CDATA #REQUIRED&gt;
&lt;!ELEMENT personne (#PCDATA)&gt;</code></pre>
                                                </td>
                                                <td>
<pre><code>&lt;personne prenom="Pauline"&gt;
Ducobu
&lt;/personne&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST personne genre (male|femelle|indetermine) "indetermine"&gt;
&lt;!ELEMENT personne (#PCDATA)&gt;</code></pre>
                                                </td>
                                                <td>
<pre><code>&lt;personne&gt;
Ducobu
&lt;/personne&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST personne
genre (male|femelle) #REQUIRED&gt;
&lt;!ELEMENT personne (#PCDATA)&gt;</code></pre>
                                                </td>
                                                <td>
<pre><code>&lt;personne genre="male"&gt;
Ducobu
&lt;/personne&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST personne
freres IDREFS #IMPLIED
ident ID #REQUIRED &gt;

&lt;!ELEMENT personne (#PCDATA)&gt;</code></pre>
                                                        </td>
                                                        <td>
<pre><code>&lt;personne ident="_23"&gt;Pauline Ducobu&lt;/personne&gt;

&lt;personne ident="_24" freres="_23"&gt;Robin Ducobu&lt;/personne&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
<pre><code>&lt;!ATTLIST form method CDATA #FIXED "POST"&gt;
&lt;ELEMENT form (ANY)&gt;
&lt;!ELEMENT input (EMPTY)&gt;</code></pre>
                                                </td>
                                                <td>
<pre><code>&lt;form method="POST"&gt;
&lt;input ... /&gt;
&lt;/form&gt;</code></pre>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Déclaration d'entité :</h4>
                                    <p>Il est possible de déclarer des entités dans une DTD de trois manières :</p>
<pre><code>&lt;!ENTITY nom="texte de remplacement"&gt;
&lt;!ENTITY nom SYSTEM "URI"&gt;
&lt;!ENTITY nom PUBLIC "id_public" "URI"&gt;</code></pre>
                                    <p>La première forme permet de définir un texte de remplacement fourni entre guillemets pour un nom d'entité.</p>
                                    <p>La seconde forme permet de définir, pour un nom, une URI qui contient la référence relative du fichier qui contient le texte de remplacement.</p>
                                    <p>La dernière forme permet de définir une entité externe publique. Même principe que la déclaration de doctype public; voir la parrtie "Déclarer une DTD externe".</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="XML_Schemas">Les XML Schemas :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La norme XML Schema est une évolution des DTD. Conçu pour pallier les difficiences citées des <span class="html">DTD</span>, elle propose bien plus de fonctionnalités.</p>
                            <p>Citons quelques uns des atouts des XML Schemas par rapport au DTD :</p>
                            <ul>
                                <li>
                                    <p>Le typage des données :</p>
                                    <ul>
                                        <li>
                                            <p>Il est possible via la définition d'un XML Schema de contraindre les valeurs des attributs ou des éléments. Les données peuvent désormais être des booléens, des entiers, des intervalles de temps, ... Il est même possible de créer de nouveaux types à partir de types existants.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>La notion d'héritage :</p>
                                    <ul>
                                        <li>
                                            <p>Les éléments peuvent hériter du contenu et des attributs d'un autre élément.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Le support des espaces de noms :</p>
                                    <ul>
                                        <li>
                                            <p>Un espace de noms XML est une recommandation du W3C qui permet d'employer des éléments et des attributs nommés dans une instance XML.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>La gestion des occurences :</p>
                                    <ul>
                                        <li>
                                            <p>Les indicateurs d'occurences des éléments peuvent être tout nombre non négatif (rappel: dans une <span class="html">DTD</span>, on est limité à 0, 1 ou un nombre infini d'occurences pour un élément).</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <p>XML Schema est extrêmement puissant mais hélas très complexe...</p>
                            <p>Étant donné que XML Schema, c'est du XML, il est possible de valider tout XML Schema grâce à un validateur fournit par le W3C : <a href="http://www.w3.org/2001/03/webdata/xsv" target="_blank">http://www.w3.org/2001/03/webdata/xsv</a>.</p>
                        </li>
                        <li>
                            <h3>Utiliser un XML Schema - xmlns :</h3>
                            <ol>
                                <li>
                                    <h4>Déclarer un XML Schema :</h4>
                                    <p>Après avoir écrit un XML Schema, il faut le déclarer dans le document XML, tout comme on déclare une DTD. Nous n'allons pas ici entrer dans les détails de la notion d'espace de noms, mais simplement apprendre à valider un document XML d'après un XML Schema. On utilise pour ce faire le préfixe <span class="html">xmlns</span>.</p>
                                    <p>Dans le cas d'un référencement à un <span class="em">XML Schema public</span>, équivalent à une DTD de type <span class="html">PUBLIC</span>, on référence l'URI ainsi que l'URL du schéma public.</p>
                                    <p>Considérons que l'on désire créer un document XML valide selon un XML Schema public localisé à l'URL suivante : <a href="http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" target="_blank">http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd</a>. Ce XML Schema permet d'écrire des fichiers qui définissent la persistance d'une application Enterprise (EJB).</p>
                                    <p>Peu importe, il s'agit d'écrire un document <span class="em">persistence.xml</span> qui sera valide selon ce XML Schema public.</p>
<pre><code>&lt;persistance xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" version="1.0"&gt;</code></pre>
                                    <p>L'élément racine est l'élement <span class="em">persistence</span> avec les attributs dans l'ordre :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">xmlns</span> précise l'identifiant de l'espace de noms par défaut</p>
                                        </li>
                                        <li>
                                            <p><span class="html">xmlns:xsi</span> précise qu'il faut employer le préfixe <span class="em">xsi</span> pour s'adresser à l'espace de noms qui permet d'associer un XML Schema public : <a href="https://www.w3.org/2001/XMLSchema-instance" target="_blank">https://www.w3.org/2001/XMLSchema-instance</a>.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">xsi:schemaLocation</span> permet de préciser l'URL de l'espace de noms qui permet de valider le document <span class="em">persistence</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Dans le cas d'une <span class="em">référence locale</span>, correspondant à une DTD de type <span class="html">SYSTEM</span>, on fait référence au XML Schema dans le document XML en utilisant l'attribut <span class="html">noNamespaceSchemaLocation</span>, par <span class="em">&lt;elementRacine xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="biblio.xsd"&gt;</span>.</p>
                                </li>
                                <li>
                                    <h4>Espace de nommage - namespace :</h4>
                                    <p>L'usage d'espace de nommage permet d'éviter des <span class="em">confusions</span> entre éléments d'espaces de noms différents.</p>
                                    <p>Un espace de noms ou namespace en anglais :</p>
                                    <ul>
                                        <li>
                                            <p>Permet, grâce à un préfixe, l'usage de balises définies.</p>
                                        </li>
                                        <li>
                                            <p>Permet la distinction entre les éléments du langage et ceux définis par l'utilisateur.</p>
                                        </li>
                                        <li>
                                            <p>Est identifié par un URI.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Comprendre un XML Schema :</h3>
                            <ol>
                                <li>
                                    <h4>Le prologue :</h4>
                                    <p>Un XML Schema commence par une déclaration XML en prologue :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</code></pre>
                                    <p>Un XML Schema possède un élément racine : <span class="html">schema</span>.</p>
                                    <p>Cet élément <span class="html">schema</span> ainsi que tous les autres éléments de XML Schema sont définis dans un espace de noms public dont l'URI est <a href="http://www.w3.org/2001/XMLSchema" target="_blank">http://www.w3.org/2001/XMLSchema</a> qui correspond au "<span class="em">schema des schemas</span>".</p>
                                    <p>Pour pouvoir utiliser cet espace de noms, il faut le déclarer via l'attribut <span class="html">xmlns</span>. Cet attribut permet d'associer un préfixe (ou non) au schéma public.</p>
                                    <p>Exemple :</p>
<pre><code>&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"&gt;...&lt;/schema&gt;</code></pre>
                                    <p>L'élément ci-dessus déclare l'espace de noms, <a href="http://www.w3.org/2001/XMLSchema" target="_blank">http://www.w3.org/2001/XMLSchema</a> <span class="em">par défaut</span>. Tout élément non préfixé du document sera automatiquement associé à cet espace de noms.</p>
                                    <p>Il est également possible, et c'est ce que l'on fait la plupart du temps, d'associer un <span class="em">préfixe</span> à un espace de noms. Dans un tel cas, tout élément de cet espace de noms devra être préfixé.</p>
                                    <p>Exemple :</p>
<pre><code>&lt;<span class="em">xs</span>:schema xmlns:<span class="em">xs</span>="http://www.w3.org/2001/XMLSchema"&gt;...&lt;/<span class="em">xs</span>:schema&gt;</code></pre>
                                    <p>En bref, un XML Schema se présente comme suit :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

&lt;!-- déclarations d'éléments, d'attributs et de types ici --&gt;

&lt;/xs:schema&gt;</code></pre>
                                </li>
                                <li>
                                    <h4>Les définitions d'éléments et d'attributs :</h4>
                                    <p>Exactement comme dans une DTD, on définit dans un XML Schema des règles pour les éléments et les attributs.</p>
                                    <ol>
                                        <li>
                                            <h5>xs:element :</h5>
                                            <p>Pour déclarer un élément, on utilise l'élément <span class="html">xs:element</span> dans lequel on précise dans les attributs le nom de l'élément (<span class="html">name</span>) et son type (<span class="html">type</span>) sauf s'il est anonyme.</p>
                                        </li>
                                        <li>
                                            <h5>xs:attribute :</h5>
                                            <p>Pour déclarer un attribut, on utilise l'élément <span class="html">xs:attribute</span> dans lequel on précise dans les attributs le nom de l'éléméent (<span class="html">name</span>) et son type (<span class="html">type</span>) sauf s'il est anonyme. Si aucun type n'est précisé dans la déclaration d'un attribut, le type par défaut <span class="html">xs:anySimpleType</span> sera utilisé.</p>
                                            <dl>
                                                <dt>use</dt>
                                                <dd>
                                                    <p>Pour préciser qu'un attribut est optionnel, obligatoire ou interdit, on précise l'attribut <span class="html">use</span> avec comme valeur <span class="html">optional</span>, <span class="html">required</span> ou <span class="html">prohibited</span>. La valeur par défaut est <span class="html">optional</span>.</p>
                                                </dd>
                                            </dl>
                                        </li>
                                        <li>
                                            <h5>default-fixed :</h5>
                                            <p>Dans la déclaration d'un élément ou d'un attribut, on peut préciser des valeurs par défaut en utilisant l'attribut <span class="html">default</span>.</p>
                                            <p>On peut également préciser une valeur fixée pour un élément ou un attribut en utilisant <span class="html">fixed</span>.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Type simple et type complexe :</h4>
                                    <p>Dans un XML Schema, les éléments peuvent être de type simple ou de type complexe tandis que les attributs sont toujours de type simple.</p>
                                    <p>Un type simple permet donc de structurer une donnée contenue dans un attribut ou dans un élément qui ne possède pas de sous-élément ni d'attribut tandis qu'un type complexe sert à structurer des éléments qui se compose de sous-éléments ou qui possèdent des attributs.</p>
                                </li>
                                <li>
                                    <h4>Type anonyme :</h4>
                                    <p>Il est possible de nommer ou pas un type simple ou complexe. Il n'est pas toujours nécessaire de déclarer explicitement un nouveau type et décider de le garder anonyme.</p>
                                    <p>Dans un tel cas, la déclaration du type se fait directement à l'intérieur la déclaration de l'élément ou de l'attribut :</p>
<pre><code>&lt;xs:element name="unElementComplexeAnonyme"&gt;
    &lt;xs:complexType&gt; ... &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</code></pre>
                                    <p>OU encore</p>
<pre><code>&lt;xs:attribute name="unAttributSimpleAnonyme"&gt;
    &lt;xs:simpleType&gt; ... &lt;/xs:simpleType&gt;
&lt;/xs:attribute&gt;</code></pre>
                                    <p>Voici un exemple de définition d'attribut <span class="em">resultat</span> dont la définition du type <span class="em">pourcent</span> est anonyme :</p>
<pre><code>&lt;xs:attribute name="resultat"&gt;
    &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:integer"&gt;
            &lt;xs:minINclusive value="0"/&gt;
            &lt;xs:maxInclusive value="100"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:attribute&gt;</code></pre>
                                </li>
                                <li>
                                    <h4>Type simple :</h4>
                                    <ol>
                                        <li>
                                            <h5>Les types existants :</h5>
                                            <p>Les types simples sont utilisés pour définir la valeur des attributs ou la valeur des éléments qui ne contiennent que des données textuelles et qui ne possèdent pas d'attributs.</p>
                                            <p>Voici 3 exemples, deux définitions d'attributs et une définition d'élément :</p>
<pre><code>&lt;xs:attribute name="nom" type="xs:string"/&gt;
&lt;xs:attribute name="id" type="xs:decimal"/&gt;
&lt;xs:element name="date" type="xs:date"/&gt;</code></pre>
                                            <p>XML Schema propose un grand nombre de types simples prédéfinis. Référez-vous au site du W3C pour l'ensemble des types prédéfinis dans XML Schema : <a href="http://www.w3schools.com/" target="_blank">http://www.w3schools.com/</a>. Le tableau ci-après reprend un sous-ensemble de ceux-ci :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>simpleType</th>
                                                        <th>Exemples</th>
                                                        <th>Notes</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td class="html">string</td>
                                                        <td>Bonjour</td>
                                                        <td>Chaîne de caractères</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">byte</td>
                                                        <td>-1 126</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">binary</td>
                                                        <td>456E789</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">integer</td>
                                                        <td>-126789 -1 0 1 126789</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">long</td>
                                                        <td>-1 1267896543213</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">short</td>
                                                        <td>-1 12678</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">decimal</td>
                                                        <td>_1.23 0 123.4 1000.00</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">float</td>
                                                        <td colspan="2">-INF -1E4 -0 0 12.78E-2 12 INF</td>
                                                        <td>Floating point 32 bits</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">double</td>
                                                        <td>Floating point 64 bits</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">boolean</td>
                                                        <td>true false</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">time</td>
                                                        <td>13:20:00.000 13:20:00.000-05:00</td>
                                                        <td>13h20 13h20 GMT-5</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">timeInstant</td>
                                                        <td>1999-05-21T13:20:00.000-05:00</td>
                                                        <td>31 mai 1999 à 13h20 GMT-5</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">timeDuration</td>
                                                        <td>P1Y2M3DT10H30M12.35</td>
                                                        <ts>1 an 2 mois 3 jours 10 heures 30 minutes et 12.3 secondes</ts>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">date</td>
                                                        <td>1999-05-31</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <th colspan="3">Remarque, les types ci-dessous sont réservés aux attributs :</th>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">ID</td>
                                                        <td>A_123.125.16</td>
                                                        <td>Identifiant unique (idem DTD)</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">IDREF</td>
                                                        <td>A-123.125.16</td>
                                                        <td>Référence d'une valeur d'ID (idem DTD)</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="html">IDREFS</td>
                                                        <td>A-123.125.16</td>
                                                        <td>Référence de valeurs d'ID (idem DTD)</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li><li>
                                            <h5>xs:simpleType :</h5>
                                            <p>Il est également permis de définir de nouveaux types simples. L'exemple suivant montre comme on crée un type simple intitulé <span class="em">pourcent</span> :</p>
<pre><code>&lt;xs:simpleType name="pourcent"&gt;
    &lt;xs:restriction base="xs:integer"&gt;
        &lt;xs:minInclusive value="0"/&gt;
        &lt;xs:maxInclusive value="100"/&gt;
    &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                            <p>On peut donc déclarer un attribut par exemple <span class="em">resultat</span> de ce type :</p>
<pre><code>&lt;xs:attribute name="resultat" type="pourcent"/&gt;</code></pre>
                                            <p>Il est également possible d'ajouter des restrictions sur un type simple qui permettent par exemple de préciser la valeur minimum ou maximum d'un entier ou encore la longueur maximum d'une chaîne de caractères.</p>
                                            <p>L'exemple ci-dessous montre la définition d'un type anonyme simple pour un élément âge dont la valeur doit être un entier compris entre 0 et 100 inclus.</p>
<pre><code>&lt;xs;element name="age"&gt;
    &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:integer"&gt;
            &lt;xs:minInclusive value="0"/&gt;
            &lt;xs:maxInclusive value="100"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;</code></pre>
                                            <p>L'exemple ci-dessous montre la définition d'un élément <span class="em">password</span> de type anonyme dont la valeur est une chaîne contenant entre 5 et 8 caractères.</p>
<pre><code>&lt;xs:element name="password"&gt;
    &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:minLength value="5"/&gt;
            &lt;xs:maxLength value="8"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>xs:pattern :</h5>
                                            <p>L'élément <span class="html">xs:pattern</span> permet d'imposer une restriction sur les valeurs possibles d'un type similaire d'un type simple à l'aide d'une expression régulière. La formulation de ces expressions régulières est similaire au Perl.</p>
                                            <p>L'élément <span class="em">compte</span> défini ci-après contient la définition d'un type nomm" simple étant une restriction du type string. Les valeurs des comptes doivent être composées des lettres BE suivies de 2 chiffres puis 3 blocs de 4 chiffres.</p>
<pre><code>&lt;xs:element name="compte"&gt;
    &lt;xs:simpleType name="numeroSEPAType"&gt;
        &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:pattern value="BE\d\d \d{4} \d{4} \d{4}" /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;</code></pre>
                                            <p>Le tableau ci-dessous reprend des exemples d'expression régulière :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>expression</th>
                                                        <th>signification</th>
                                                        <th>exemple</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>.</td>
                                                        <td>
                                                            <p>. représente n'importe quel caractère.</p>
                                                            <p>Pour rechercher '.', il faut indiquer '\.'.</p>
                                                        </td>
                                                        <td>
                                                            <p>123.5 &#8594; 123.5, 12345, 123s5, 123-5</p>
                                                            <p>123\.5 &#8594; 123.5</p>
                                                            <p>mais pas 1234 ni 123s5</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>?</td>
                                                        <td>
                                                            <p>Le caractère précédent ? est optionnel.</p>
                                                            <p>Pour rechercher '?', il faut indiquer '\?'.</p>
                                                        </td>
                                                        <td>
                                                            <p>123?4 &#8594; 1234, 124</p>
                                                            <p>les? chats? &#8594; les chats, le chat, le chats, les chat</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>*</td>
                                                        <td>
                                                            <p>Le caractère précédent * peut être répété 0 ou plusieurs fois.</p>
                                                            <p>Pour rechercher '*', il faut indiquer '\*'.</p>
                                                        </td>
                                                        <td>
                                                            <p>12*34 &#8594; 134, 1234, 12234, 122222234, ...</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>+</td>
                                                        <td>
                                                            <p>Le caractère précédent + peut être répété 1 ou plusieurs fois.</p>
                                                            <p>Pour recherche '+', il faut indiquer '\+'.</p>
                                                        </td>
                                                        <td>
                                                            <p>12+45 &#8594; 1245, 12245, 122222245, ... mais pas 1234 ni 145</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>$</td>
                                                        <td>
                                                            <p>Le dollar signifie la fin de ligne.</p>
                                                            <p>Pour rechercher '$', il faut indiquer '\1'.</p>
                                                        </td>
                                                        <td>
                                                            <p>ette$ &#8594; assiette, sonnette, pipette, ...</p>
                                                            <p>45\$$ &#8594; 45$, 645$, 7894$, ...</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>^</td>
                                                        <td>
                                                            <p>Le chapeau signifie le début de ligne.</p>
                                                            <p>Pour rechercher '^', il faut indiquer '\^'.</p>
                                                        </td>
                                                        <td>
                                                            <p>^bon &#8594; bon, bonne, bonjour, ...</p>
                                                            <p>^bon$ &#8594; bon</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>\d</td>
                                                        <td>Tout caractère numérique : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.</td>
                                                        <td>\d+ &#8594; 123, 455, 57689943</td>
                                                    </tr>
                                                    <tr>
                                                        <td>\D</td>
                                                        <td>Tout caractère sauf numérique.</td>
                                                        <td>\D* &#8594; rtre, uyt_g, dsfoooo    ooffj, ...</td>
                                                    </tr>
                                                    <tr>
                                                        <td>\w</td>
                                                        <td>Word metacharacter : une lettre [a-z] [A-Z] ou lettre accentuée, un chiffre [0-9] ou '_'.</td>
                                                        <td>\w$ &#8594; e, r, à, à, ...</td>
                                                    </tr>
                                                    <tr>
                                                        <td>\W</td>
                                                        <td>Tout caractère sauf lettre [a-z] [A-Z], lettre accentuée, chiffre [0-9] et '_'.</td>
                                                        <td>\W+ &#8594; :-), (, _+, ...</td>
                                                    </tr>
                                                    <tr>
                                                        <td>\s</td>
                                                        <td>Whitespace metacharacter : espace, tabulation, saut de ligne, saut de page, tabulation verticale, ...</td>
                                                        <td></td>
                                                    </tr>
                                                    <tr>
                                                        <td>\S</td>
                                                        <td>Tout caractère sauf ceux définis par \s</td>
                                                        <td>\S+ &#8594; :-99HG), df(u, ...)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>{m, n}</td>
                                                        <td>Le caractère précédent l'accolade peut être répété entre m fois minimum et n fois maximum.</td>
                                                        <td>
                                                            <p>ab{2,4}c &#8594; abbc, abbc ou abbbbc</p>
                                                            <p>mais pas abc</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>x | y</td>
                                                        <td>Alternative, soit x soit y.</td>
                                                        <td>
                                                            <p>a|b &#8594; a, b</p>
                                                            <p>(a|b)* &#8594; a, b, bba, bababab, aaaaabbbb, …</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>[]</td>
                                                        <td>
                                                            <p>Les chrochets marquent l'occurence de différentes manières :</p>
                                                            <p>[] signifie une lettre parmi celles entre [].</p>
                                                            <p>[m-p] signifie une lettre entre m et p.</p>
                                                            <p>MAIS si le tiret doit être présent, il doit figurer en première ou dernière position.</p>
                                                            <p>[5-9] signifie chiffre compris entre 5 et 9.</p>
                                                            <p>Le caractère ^ (accent circonflexe) a un rôle particulier s'il est placé en début d'intervalle; il prend le complémentaire de l'ensemble, il faut le lire "tout caractère sauf ...".</p>
                                                        </td>
                                                        <td>
                                                            <p>b[iou] &#8594; bu, bi ou bo mais pas ba</p>
                                                            <p>b[b[a-d]c &#8594; bac, bbc, bcc ou bdc mais pas bec</p>
                                                            <p>[ab][1-4] &#8594; a1, a2, a3, a4, b1, ... mais pas b5</p>
                                                            <p>[^ao] &#8594; g, u, i, t, ... mais pas a ni o</p>
                                                            <p>[^a-z] &#8594; 0, 1, ..., 9, A, G, ?, ... mais pas a, ni b, ... ni z</p>
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>xs:enumeration :</h5>
                                            <p>L'élement <span class="html">xs:enumeration</span> permet d'énumérer toutes les valeurs possibles que pourra prendre un attribut ou un élément.</p>
                                            <p>Par exemple le type <span class="em">visibilite</span> est une énumération de 4 valeurs possibles :</p>
<pre><code>&lt;xs:simpleType name="visibilite"&gt;
    &lt;xs:restriction base="xs:string"/&gt;
        &lt;xs:enumeration value="private"/&gt;
        &lt;xs:enumeration value="public"/&gt;
        &lt;xs:enumeration value="protected"/&gt;
        &lt;xs:enumeration value="default"/&gt;
    &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>xs:list :</h5>
                                            <p>L'élément <span class="html">xs:list</span> permet de définir un nouveau type simple dont le format est une liste de valeurs séparées par des espaces.</p>
                                            <p>Pour créer, par exemple, un type <span class="em">listeEntiersType</span> et un élément <span class="em">listeEntiers</span> de ce type, il suffit de déclarer :</p>
<pre><code>&lt;xs:simpleType name="listeEntiersType"&gt;
    &lt;xs:list itemType="xs:integer"/&gt;
&lt;/xs:simpleType&gt;
&lt;xs:element name="listeEntiers" type="listeEntiersType"/&gt;</code></pre>
                                            <p>Exemples d'éléments de ce type :</p>
<pre><code>&lt;listeEntiers&gt;12 4 9 -4 8&lt;/listeEntiers&gt;
&lt;listeEntiers&gt;&lt;/listeEntiers&gt;</code></pre>
                                            <p>On peut ajouter des restrictions sur la définition d'une liste :</p>
                                            <ul>
                                                <li>
                                                    <p>sa longueur :</p>
<pre><code>&lt;xs:simpleType name="listeDe10EntiersType"&gt;
    &lt;xs:list itemType="xs:integer"&gt;
        &lt;xs:length value="10"/&gt;
    &lt;/xs:list&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                                </li>
                                                <li>
                                                    <p>sa longueur minimum :</p>
<pre><code>&lt;xs:simpleType name="listeDeMinimum3EntiersType"&gt;
    &lt;xs:list itemType="xs:integer"&gt;
        &lt;xs:minLength value="3"/&gt;
    &lt;/xs:list&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                                </li>
                                                <li>
                                                    <p>sa longueur maximum :</p>
<pre><code>&lt;xs:simpleType name="listeDeMaximum9EntiersType"&gt;
    &lt;xs:list itemType="xs:integer"&gt;
        &lt;xs:maxLength value="9"/&gt;
    &lt;/xs:list&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h5>xs:union :</h5>
                                            <p>L'élément <span class="html">xs:union</span> permet de définir un nouveau type simple représenté par l'union de deux ou plusieurs autres types simples.</p>
                                            <p>Si on désire créer un type <span class="em">zipUnionType</span> qui permet de déclarer une ville soit par son nom soit par son code postal.</p>
<pre><code>&lt;xs:simpleType name="villeType" type="xs:string"/&gt;

&lt;xs:simpleType name="cpType"&gt;
    &lt;xs:restriction base="xs:integer"&gt;
        &lt;xs:minInclusive value="1000"/&gt;
        &lt;xs:maxInclusive value="10000"/&gt;
    &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="zipUnionType"&gt;
    &lt;xs:union memberTypes="villeType cpType"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:element name="ville" type="zipUnionType/&gt;</code></pre>
                                            <p>Voici quelques exemples :</p>
<pre><code>&lt;ville&gt;1200&lt;/ville&gt;
&lt;ville&gt;Gembloux&lt;/ville&gt;</code></pre>
                                            <p>Autre exemple, supposons un type <span class="em">numeroDeTelephone</span> qui permet de définir un numéro de téléphone comme une liste de chiffres :</p>
<pre><code>&lt;xs:element name="telephone" type="numeroDeTelephone"/&gt;

&lt;xs:simpleType name="numeroDeTelephone"&gt;
    &lt;xs:list itemType="xs:unsignedByte"/&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                            <p>On peut définir des numéros de téléphone comme suit :</p>
<pre><code>&lt;telephone&gt;02 58 95 62&lt;/telephone&gt;
&lt;telephone&gt;25 89&lt;/telephone&gt;</code></pre>
                                            <p>Si on désire que le type <span class="em">numeroDeTelephoneMnemotechnique</span> permette soit un nombre, soit une chaîne de caractères alors on le modifie comme suit :</p>
<pre><code>&lt;xs:simpleType name="numeroDeTelephoneMnemotechnique"&gt;
    &lt;xs:union memberTypes="xs:string numeroDeTelephone"/&gt;
&lt;/xs:simpleType&gt;</code></pre>
                                            <p>Considérant maintenant que l'élément <span class="em">telephone</span> spoy défini comme suit :</p>
<pre><code>&lt;xs:element name="telephone" type="numeroDeTelephoneMnemotechnique"&gt;</code></pre>
                                            <p>On peut définir alors des numéros de téléphone comme suit :</p>
<pre><code>&lt;telephone&gt;25 89&lt;/telephone&gt;
&lt;telephone&gt;police&lt;/telephone&gt;</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>xs:complexType :</h4>
                                    <p>Les types complexes sont utilisés pour définir un élément qui contient d'autres éléments et/ou qui possède des attributs.</p>
                                    <p>Pour définir un type complexe, on utilise l'élément <span class="html">xs:complexType</span>. Cet élément renferme la définition de la structure XML que devra respecter tout élément défini avec ce type.</p>
                                    <p>Le contenu d'un type complexe est soit <span class="html">xs:simpleContent</span> soit <span class="html">xs:complexContent</span> soit directement la définition du type complexe c'est-à-dire une séquence d'éléments (<span class="html">xs:sequence</span>) qui, dans une DTD, correspond à l'usage des parenthèses et des virgules (A, B, C), un choix entre éléments (<span class="html">xs:choice</span>) qui, dans une DTD, correspond à l'usage des barres verticales (A|B|C), un tout <span class="html">xs:all</span>) ou un groupe (<span class="html">xs:group</span>).</p>
                                    <p>Nous n'aborderons pas les deux derniers types.</p>
                                    <ol>
                                        <li>
                                            <h5>xs:simpleContent :</h5>
                                            <p><span class="html">xs:simpleContent</span> permet de définir un type complexe dérivé à partir d'un type simple par restriction ou par extension. La différence par rapport à un type simple classique est que le type complexe peut servir à définir des attributs.</p>
                                            <p>Exemple de dérivation par <span class="em">restriction :</span></p>
<pre><code>&lt;xs:complexType name="prix"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:restriction base:"xs:positiveInteger"&gt;
            &lt;xs:maxInclusive value="100"/&gt;
            &lt;xs:attribute name="devise" type="xs:string"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
                                            <p>Dans l'exemple précédent, les éléments de type <span class="em">prix</span> pourront contenir des entiers positifs inférieurs ou égaux à 100, ainsi qu'un attribut optionnel <span class="em">devise</span> (il est optionnel car <span class="em">use</span> n'est pas mentionné dans sa déclaration).</p>
                                            <p>Exemple de dérivation par <span class="em">extension</span> :</p>
<pre><code>&lt;xs:complexType name="prix"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:positiveInteger"&gt;
            &lt;xs:attribute name="devise" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</code></pre>
                                            <p>Dans l'exemple précédent, les éléments de type <span class="em">prix</span> pourront contenir des entiers positifs, ainsi qu'un attribut optionnel <span class="em">devise</span> (il est optionnel car <span class="Em">use</span> n'est pas mentionné dans sa déclaration).</p>
                                            <p>Dans une extension, on ne peut définir que des attributs tandis que par restriction, on peut également restreindre le type simple. Dans ce cas, les restrictions doivent être définies avant les attributs.</p>
                                        </li>
                                        <li>
                                            <h5>xs:complexContent :</h5>
                                            <p><span class="html">xs:complexContent</span> permet de définir un type complexe dérivé à partir d'un type complexe de base par restriction ou par extension. Ce type se définit de manière similaire au <span class="html">xs:simpleContent</span> si ce n'est qu'on pourra également ajouter des séquences et des choix comme dans un type complexe.</p>
                                        </li>
                                        <li>
                                            <h5>xs:sequence :</h5>
                                            <p><span class="html">xs:sequence</span> permet de définir une séquence d'éléments.</p>
                                            <p>L'exemple suivant montre la définition d'un type <span class="em">adresseType</span> qui contient donc une rue suivie d'un numéro suivi d'un code postal et enfin de la ville (<span class="em">l'ordre</span> des éléments a de l'importance !) :</p>
<pre><code>&lt;xs:complexType name="adresseType"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="rue" type="xs:string"/&gt;
        &lt;xs:element name="numero" type:"xs:positiveInteger"/&gt;
        &lt;xs:element name="codePostal" type="xs:positiveInteger"/&gt;
        &lt;xs:element name="ville" type:"xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</code></pre>
                                            <p>On peut définir une séquence à l'intérieur d'une autre séquence.</p>
                                        </li>
                                        <li>
                                            <h5>xs:choice :</h5>
                                            <p><span class="html">xs:choice</span> permet de <span class="em">choisir</span> un élément parmi plusieurs.</p>
                                            <p>Dans l'exemple ci-après, on définit un type <span class="em">personneType</span> qui est soit un professeur soit un étudiant (l'ordre n'a pas d'importance, il s'agit d'un choix !).</p>
<pre><code>&lt;xs:complexType name="personneType"&gt;
    &lt;xs:choice&gt;
        &lt;xs:element name="professeur" type="xs:string"/&gt;
        &lt;xs:element name="etudiant" type="xs:string"/&gt;
    &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;</code></pre>
                                        </li>
                                        <li>
                                            <h5>minOccurs - maxOccurs :</h5>
                                            <p>Les attributs <span class="html">minOccurs</span> et <span class="html">maxOccurs</span> peuvent être utilisés dans une séquence (<span class="html">xs:sequence</span>), dans un choix (<span class="html">xs:choice</span>) et dans un élément (<span class="html">xs:element</span>).</p>
                                            <p>Par défaut, ces deux attributs valent 1. On peut leur donner une valeur entière ou encore la valeur <span class="html">unbounded</span> qui indique qu'il n'y a pas de limite maximale du nombre d'occurences.</p>
                                        </li>
                                        <li>
                                            <h5>Élément vide :</h5>
                                            <p>Il n'existe pas dans le langage XML Schema de type prédéfini pour déclarer des éléments vides, similaire au type <span class="html">EMPTY</span> qu'on trouve dans une DTD.</p>
                                            <p>Pour déclarer qu'un élément doit être vide, il faut utiliser un type complexe qui ne contient aucune déclaration d'élément (mais qui peut contenir des déclarations d'attributs).</p>
                                            <p>La définition de l'élément prix déclarée ci-dessous ne comporte aucun sous-élément et aucune donnée, il est vide. Il contient par contre deux attributs.</p>
<pre><code>&lt;xs:element name="prix"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:attribute name="montant" type="xs:float"/&gt;
        &lt;xs:attribute name="devise" type="xs:string"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</code></pre>
                                            <p>Exemple :</p>
<pre><code>&lt;prix montant="25" devise="euro"/&gt;</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Référence d'élément :</h4>
                                    <p>Lorsq'un élément se compose de sous-éléments, il est souvent utile de les définir une fois et ensuite, de les référencer. Cela permet d'éviter des redéfinitions inutiles.</p>
                                    <p>Voici un exemple :</p>
<pre><code>&lt;xs:element name="voiture"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element ref="immat"/&gt;
            &lt;xs:element ref="prix"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="immat" type="xs:string"/&gt;

&lt;xs:element name="prix" type="xs:string"/&gt;</code></pre>
                                    <p>L'élément voiture de l'élément <span class="em">immat</span> suivi du prix. Si je désire définir un autre élément, <span class="em">camion</span> par exemple, dans lequel on précise également l'immatriculation, il suffit de référencer le même élément :</p>
<pre><code>&lt;xs:element name="camion"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element ref="immat"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</code></pre>
                                    <p>Les éléments suivants sont valides :</p>
<pre><code>&lt;voiture&gt;
    &lt;immat&gt;FKJ256&lt;/immat&gt;
    &lt;prix&gt;8639&lt;/prix&gt;
&lt;/voiture&gt;
&lt;camion&gt;
    &lt;immat&gt;DFR854&lt;/immat&gt;
&lt;/camion&gt;</code></pre>
                                </li>
                                <li>
                                    <h4>Les contraintes d'unicité :</h4>
                                    <p>W3C XML Schema nous fournit plusieurs fonctionnalités s'appuyant sur XPath et permettant de décrire des contraintes d'unicité et des contrôles référentiels.</p>
                                    <p>Les éléments <span class="html">xs:unique</span>, <span class="html">xs:key</span> et <span class="html">xs:keyref</span> permettent d'imposer des contraintes d'identité à certains sous-éléments ou attributs de l'élément en question.</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">xs:unique</span> et <span class="html">xs:key</span> assurent l'unicité à l'aide d'une ou plusieurs valeurs calculées par des expressions XPath.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">xs:keyref</span> assure un référencement vers une des clés déjà définies dans d'autre contrainte d'identité.</p>
                                        </li>
                                    </ul>
                                    <p>Dans le cadre de ce cours, nous n'aborderons pas davantage les contraintes d'identité.</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="XML_JAVA">XML et JAVA :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Si l'on veut pouvoir lire ou manipuler les données d'un document XML dans un langage de programmation tel que Java, il faut utiliser un parseur XML.</p>
                            <p>Les parseurs XML sont divisés en deux groupes selon l'approche qu'ils utilisent pour traiter le document.</p>
                            <ul>
                                <li>
                                    <p>Les parseurs utilisant une approche hiérarchique. Ils construisent une structure hiérarchique contenant des objets représentant les éléments du document. La principale API utilisant cette approche est <span class="html">DOM</span>(<span class="em">Document Object Model</span>).</p>
                                </li>
                                <li>
                                    <p>Les parseurs utilisant une approche événementielle. Cette approche permet de réagir à des événements (comme le début d'un élément, la fin d'un élément) et de renvoyer le résultat. <span class="html">SAX</span>(<span class="em">Simple API for XML</span>) est la principale interface utilisant l'aspect événementiel.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>DOM :</h3>
                            <ol>
                                <li>
                                    <h4>Introduction :</h4>
                                    <p>Le principale rôle de DOM est de fournir une représentation mémoire d'un document XML sous la forme d'un arbre d'objets et d'en permettre la manipulation et d'en permettre la manipulation (parcours, recherche et mise à jour). DOM est défini pour être indépendant du langage dans lequel il sera implémenté. C'est une spécification du W3C.</p>
                                </li>
                                <li>
                                    <h4>DOM en JAVA :</h4>
                                    <p>Pour utiliser DOM avec Java, il faut utiliser les classes du package <span class="html">org.w3c.dom</span>.</p>
                                    <p>En Java, le parseur DOM représente un document XML sous forme d'un arbre dont tous les noeuds appartiennent à une sous-classe de l'interface <span class="html">Node</span>. Dans ce chapitre, nous ne parlerons pas de toutes les interfaces, classes et méthodes disponibles dans ce package. Nous allons parcourir assez vite les points les plus importants. Comme toujours, référez-vous à la javadoc pour plus d'informations.</p>
                                    <p>Les interfaces les plus utiles pour utiliser DOM en Java sont :</p>
                                    <ul>
                                        <li>
                                            <p><span class="html">Node</span> : chaque noeud de l'arbre DOM est de ce type.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">Element</span> : cette interface héritant de <span class="html">Node</span> définit des méthodes pour manipuler un élément et ses attributs.</p>
                                        </li>
                                        <li>
                                            <p><span class="html">Document</span> : cette interface héritant de <span class="html">Node</span> définit les caractéristiques pour un objet qui sera la racine de l'arbre DOM.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h4>L'obtention d'un arbre DOM :</h4>
                                    <p>Pour pouvoir obtenir un arbre DOM représentant un document XML, il faut utiliser un parseur qui implémente DOM. Ce dernier va parcourir le document XML et créer l'arbre DOM correspondant. Le but est d'obtenir un objet qui implémente l'interface <span class="html">Document</span> car cet objet est le point d'entrée pour toutes opérations sur l'arbre DOM.</p>
                                    <p>Le code suivant permet d'obtenir l'arbre DOM pour le fichier <span class="em">carnet.xml</span>.</p>
<pre><code>import java.io.File;
import javax.xml.parsers.*;
import org.w3c.dom.*;

public class DOMParseExample {
    public static void main(String[] args) {
        try {
            File xmlFile = new File("carnet.xml");
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder(),
            Document doc = dBuilder.parse(xmlFile);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
                                </li>
                                <li>
                                    <h4>Parcours d'un arbre DOM :</h4>
                                    <p>Il ya plusieurs manières de parcourir un arbre DOM. Une manière simple est d'utiliser directement les méthodes disponibles sur l'interface <span class="html">Document</span> (comme dans l'exemple ci-dessous). Ce programme va afficher le titre, le nom et le téléphone des personnes répertoriées dans le document <span class="em">carnet.xml</span>.</p>
<pre><code>import java.io.File;
import javax.xml.parsers.*;
import org.w3c.dom.*;

public class DOMParseExample {
    public static void main(String[] args) {
        try {
            File xmlFile = new File("carnet.xml");
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder(),
            Document doc = dBuilder.parse(xmlFile);
            doc.getDocumentElement().normalize();
            NodeList personnes = doc.getElementsByTagName("personne");
            for (int i = 0; i &lt; personnes.getLength(); i++) {
                Node nPersonne m= personnes.item(i);
                Element ePersonne = (Element) nPersonne;
                System.out.println(ePersonne.getAttribute("titre") + " " + ePersonne.getElementsByTagName("nom").item[0].getTextContent());
                Element eContact : (Element) ePersonne.getElementsByTagName("contact").item(0);
                System.out.println("telephone: " + eContact.getElementsByTagName("tel").item(0).getTextContent());
                System.out.println("----------------");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
                                    <p>Voici un exemple de sortie pour ce programme :</p>
<pre><code>me Leconte
telephone: 027644688
-------------------
Mr Debacker
telephone: 027644653
-------------------</code></pre>
                                    <p>Il existe d'autres manières plus élaborées de parcourir un arbre DOM via les interfaces <span class="html">DocumentTraversal</span> et <span class="html">TreeWalker</span> (voir javadoc).</p>
                                </li>
                                <li>
                                    <h4>Création d'un arbre DOM :</h4>
                                    <p>La méthode <span class="html">newDocument()</span> de la classe <span class="html">DocumentBuilder</span> renvoie une nouvelle instance d'un objet de type <span class="html">Document</span> qui encapsule un arbre DOM vide. Il faut au minimum ajouter un élément racine au document XML. Pour cela, il faut appeler la méthode <span class="html">createElement()</span> de l'objet <span class="html">Document</span>. Il suffit ensuite d'utiliser la méthode <span class="html">appendChild()</span> de l'objet <span class="html">Document</span> en lui fournissant la référence du noeud. Ensuite, il faut rajouter les autres éléments et attributs de la même manière.</p>
                                    <p>Le programme suivant va créer un arbre DOM et va enregistrer cet arbredans un document XML nommé <span class="em">carnet.xml</span>.</p>
<pre><code>import java.io.FIle;

import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.*;

public class DomCreateExample {
    public static void main(String[] argv) {

        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.newDocument();
            Element rootElement = doc.createElemnt("carnet");
            doc.appendChild(rootElement);

            // creation element personne
            Element personne = doc.createElement("personne");
            rootElement.appendChild(personne);

            // ajout de l'attribut titre
            Attr attr = doc.createElement("titre");
            attr.setValue("Mme");
            personne.setAttributeNode(attr);

            // ajout element nom et prenom
            Element nom = doc.createElement("nom");
            nom.appendChild(doc.createTextNode("Leconte"));
            personne.appendChild(nom);
            Element prenom = doc.createElement("prenom");
            prenom.appendChild(doc.creatteTextNode("Emmeline"));
            personne.appendChild(prenom);

            // ajout element contact
            Element contact = doc.createElement("contact");
            personne.appendChild(contact);
            Element tel = doc.createElement("tel");
            tel.appendChild(doc.createTextNode("027644688"));
            contact.appendChild(tel);
            Element bureau = doc.createElement("bureau");
            bureau.appendChild(doc.createTextNode("028"));
            contact.appendChild(bureau);
            Element email = doc.createElement("email");
            email.appendChild(doc.createTextNode("emmeline.leconte&amp;64;ipl.be"));
            contact.appendChild(email);

            // enregistrer dans un fichier XML

            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            DOMSouce = new DOMSource(doc);
            StreamResult result = new StreamResult(new File("output.xml"));
            transformer.transform(source, result);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
                                </li>
                                <li>
                                    <h4>Avantages et inconvénients :</h4>
                                    <p>La principale caractéristique de DOM est que la totalité de l'arborescence XML va être chargée en mémoire. L'avantage de cette technique et qu'on peut naviguer vers n'importe quel noeud. Cependant si le fichier XML contient beaucoup de données, cela va couter très cher en mémoire. Tout le document va être chargé même si vous n'avez besoin que d'une toute petite partie du document.</p>
                                    <p>DOM est conseillé lorsqu'il faut modifier une structure XML et lorsqu'on est face à des données petites. DOM est le seul moyen pour naviguer vers les éléments parents et enfants. Cela rend DOM plus facile à utiliser.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>SAX :</h3>
                            <p>SAX a une approche très différente de DOM. SAX lit le document XML de manière linéaire du début jusqu'à la fin mais il ne garde rien en mémoire; il ne crée donc pas d'arbre. À la place, il génère des événements et l'utilisateur peut ajouter des <span class="html">Handler</span> pouvant réagir à certains événements qui l'intéressent. Un <span class="html">Handler</span> va par exemple être appelé quand un élément commence ou se termine.</p>
                            <ol>
                                <li>
                                    <h4>SAX en Java :</h4>
                                    <p>Pour utiliser SAX avec Java, il faut utiliser les classes du package <span class="html">org.w3c.sax</span>.</p>
                                    <ol>
                                        <li>
                                            <h5>Définition des Handler :</h5>
                                            <p>Tout <span class="html">Handler</span> devra implémenter l'interface <span class="html">ContentHandler</span>. Cette interface définit un certain nombre de méthodes que le parseur SAX utilisera pour avertir le programme qu'un composant du document XML a été vu.</p>
                                            <p>Voici quelques exemples de méthodes contenues dans cette interface (pour des informations complètes, référez-vous à la javadoc) :</p>
                                            <ul>
                                                <li>
                                                    <p><span class="html">void startDocument()</span> - appelé au début du document.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">void endDocument()</span> - appelé à la fin du document.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">void startElement(String uri, String localName, String qName, Attributes atts)</span> - appelé au début d'un élément.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">void endDocument(String uri, String localName, String qName)</span> - appelé à la fin d'un élément.</p>
                                                </li>
                                                <li>
                                                    <p><span class="html">void characters(char[] ch, int start, int length)</span> - appelé quand des CDATA sont rencontrés.</p>
                                                </li>
                                            </ul>
                                            <p>En général, l'utilisateur va étendre la classe <span class="html">DefaultHandler</span> qui implémente <span class="html">ContentHandler</span>. Cette classe fournit une implémentation par défaut pour réagir à tous les événements.</p>
                                            <p>Voici un exemple de <span class="html">Handler</span> qui va s'occuper d'afficher le titre, le nom et le téléphone des personnes répertoriées dans le document <span class="em">carnet.xml</span>.</p>
<pre><code>import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;

public class SAXHandler extends DefaultHandler {
    String titre;
    boolean bNom = false;
    boolean bTel = false;

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        if (qName.equalsIgnoreCase("personne")) {
            titre = attributes.getValue("titre");
        } else if (qName.equalsIgnoreCase("nom")) {
            bNom = true;
        } else if (qName.equalsIgnoreCase("tel")) {
            bTel = true;
        }
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if (qName.equalsIgnoreCase("personne")) {
            System.out.println("-------------------");
        }
    }

    @Override
    public void characters(char ch[], int start, int length) throws SAXException {
        if (bNom) {
            System.out.prinln(titre + " " + new String(ch, start, length));
            bNom = false;
        } else if (bTel) {
            System.out.println("telephone: " + new String(ch, start, length));
            bTel = false;
        }
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <h5>Programme principal :</h5>
                                            <p>Après avoir défini le Handler, la manipulation est très simple. Pour parser un document XML avec SAX, il faut obtenir un parser SAX et lui fournir le Handler défini précédemment comme dans l'exemple ci-dessous.</p>
<pre><code>import java.io.File;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXParseExample {
    public static void main(String[] args) {

        try {
            File inputFile = new File("carnet.xml");
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser saxParser = factory.newSAXParser();
            SAXHandler userhandler = new SAXHandler();
            saxParser.parse(inputFile; userhandler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
                                            <p>Voici un exemple de sortie pour ce programme :</p>
<pre><code>Mme Leconte
telephone: 027644688
-------------------
Mr Debacker
telephone: 027644653
-------------------</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Avantages et inconvénients :</h4>
                                    <p>L'utilisation de SAX est conseillée quand :</p>
                                    <ul>
                                        <li>
                                            <p>on peut lire le document XML de manière linéaire de haut en bas.</p>
                                        </li>
                                        <li>
                                            <p>on veut lire un très gros document XML; dans ce cas-là, l'arbre DOM consommerait trop d'espace en mémoire.</p>
                                        </li>
                                        <li>
                                            <p>le problème à résoudre implique une petite partie du document XML.</p>
                                        </li>
                                    </ul>
                                    <p>Le désavantage de SASX est la non-présence d'une structure d'arbre qui permettrait d'obtenir facilement les éléments parents et enfants.</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="feuilles_style">Les feuilles de style :</h2>
                    <ol>
                        <li>
                            <h3>CSS pour XML :</h3>
                            <p>Il est possible d'afficher un document XML dans un navigateur web en l'associant à une feuille de style CSS exactement comme un document HTML. Le W3C a défini une norme de référence à ce sujet : <a href="http://www.w3c.org/TR/xml-stylesheet" target="_blank">http://www.w3c.org/TR/xml-stylesheet</a>.</p>
                            <p>Le principe est assez simple : il suffit d'associer la feuille de style CSS au document XML grâce à l'instruction de traitement appelée <span class="html">&lt;?xml-stylesheet ?&gt;</span>. Cette instruction de traitement utilise les mêemes attributs que la balise <span class="html">&lt;link rel="stylesheet"...&gt;</span> du langage HTML, à savoir les attributs <span class="html">type</span> et <span class="html">href</span>. Elle est placée dans le prologue du document.</p>
                            <p>Dans l'attribut <span class="html">type</span>, on spécifie la valeur "<span class="html">text/css</span>" et dans l'attribut <span class="html">href</span>, on mentionne l'URI de la feuille de style CSS.</p>
                            <p>Voici un exemple de document XML <span class="em">menu.xml</span> associé à une feuille de style <span class="em">menu.css</span>. Remarquez que ce document référence également une DTD <span class="em">menu.dtd</span>.</p>
                            <p><span class="em">menu.xml</span> :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;

<span class="em">&lt;?xml-stylesheet type="text/css" href="menu.css"?&gt;</span>

&lt;!DOCTYPE menu SYSTEM "menu.dtd"&gt;
    &lt;plat&gt;
        &lt;nom&gt;Un quartier de pizza&lt;/nom&gt;
        &lt;prix&gt;3&lt;/prix&gt;
        &lt;description&gt;Un quart de pizza du jour&lt;/description&gt;
        &lt;calories&gt;610&lt;/calories&gt;
    &lt;/plat&gt;
    &lt;plat&gt;
        &lt;nom&gt;Une ciabatta chorizo&lt;/nom&gt;
        &lt;prix&gt;2.89&lt;/prix&gt;
        &lt;description&gt;Une ciabatta fourrée d'une omelette au chorizo&lt;/description&gt;
        &lt;calories&gt;450&lt;/calories&gt;
    &lt;/plat&gt;
    ...
&lt;/menu&gt;</code></pre>
                            <p><span class="em">menu.css</span> :</p>
<pre><code>menu {
    float: left;
    margin-top: 30px;
    margin-left: 150px;
    margin-right: 150px;
}

plat {
    display: block;
    font-family: Arial,sans-serif;
    padding-bottom: 16px;
    background-color: yellow;
}

...</code></pre>
                            <p>Le navigateur affichera alors la page suivante :</p>
                            <img src="../images/menu_XML.png" alt="">
                            <p>L'usage de feuilles CSS est une façon simple d'afficher un document XML mais il s'agit vraiment d'une solution basique qui ne permet pas d'exploiter toute la richelle du langage XML.</p>
                            <p>Le principale inconvénient est que l'<span class="em">entièreté du document</span> XML est systématiquement affiché et ce dans l'<span class="em">ordre d'apparition</span> des éléments dans le document XML.</p>
                            <p>C'est pourquoi une technique plus élaborée consiste à utiliser des feuilles de style XSLT ppour produire du code HTML (ou XHTML). Ces fichiers HTML peuvent eux référencer des feuilles de style CSS.</p>
                        </li>
                        <li>
                            <h3>XSL :</h3>
                            <p>Les feuilles de styles conçues pour les documents XML utilisent les langages XSLT et XPath afin de fournir un document dans un format HTML par exemple. Il est également possible de fournir un autre type de document dans un langage de formatage (XSL) qui permet lui des transformations dans des multiples formats : PDF, PostScript, ...</p>
                            <p>Le principe esy assez complexe et repose sur deux parties : un <span class="em">langage de transformation</span>, qui permet de transformer un document XML en un autre document, et un <span class="em">langage de formatage</span>, qui est un vocabulaire particulier pour décrire une sémantique de présentation.</p>
                            <p>Trois recommandations du W3C (3 langages donc) permettent de définir les feuilles de style :</p>
                            <ul>
                                <li>
                                    <p><span class="html">XSLT</span> signifie <Span class="em">eXtensible Stylesheet Langage Transformation</Span>.</p>
                                </li>
                                <li>
                                    <p><span class="html">XSL</span> signifie <span class="em">eXtensible Stylesheet Langage</span>.</p>
                                    <p>Notons l'existence du <span class="html">XSL-FO</span> signifie <span class="em">eXtensible Stylesheet Langage - Formating Objects</span>, et désigne un langage permettant le contrôle de la mise en page finale de la transformation. Ce langage est particulièrement destiné à la production de contenu au format PDF.</p>
                                </li>
                                <li>
                                    <p><span class="html">XPath</span> est langage d'expression qui permet d'extraire de l'information du document XML.</p>
                                </li>
                            </ul>
                            <p>Dans le cadre de ce cours, nous utiliserons exclusivement le langage de formatage HTML pour définir la présentation. Nous aborderons donc les langages <span class="html">XSLT</span> et <span class="html">XPath</span>.</p>
                            <p>Avant d'aborder ces normes, il est utile d'introduire la notion d'arbre document qui consiste en une représentation du document XML sous forme d'arborescence.</p>
                        </li>
                        <li>
                            <h3>L'arbre document :</h3>
                            <p>La structure logique d'un document XML bien formé peut toujours se représenter sous forme d'un arbre, appelé l'<span class="em">arbre document</span>.</p>
                            <p>Cette représentation s'avère bien utile en XML pour la bonne compréhension des expressions XPath, des feuilles de style XSLT, ...</p>
                            <p>Ainsi le document XML se représente sous forme d'arborescence de noeuds de types différents : le <span class="em">noeud racine</span> ("/"), les <span class="em">noeuds éléments</span>, les <span class="em">noeuds attributs</span> et les <span class="em">noeuds textes</span>. Nous ne tiendrons pas comptes des noeuds instructions de traiteemnt, des noeuds espaces de noms et des noeuds commentaires.</p>
                            <p>Le noeud racine et les noeuds éléments possèdent éventuellement <span class="em">un ou plusieurs noeuds enfants</span> et possèdent toujours un et un <span class="em">seul noeud parent</span> à l'exception du noeud racine qui n'en possède pas.</p>
                            <p>Le <span class="em">noeud racine</span> ou "<span class="em">/</span>" est le noeud principal représentant le document XML dans l'arbre document. Il ne faut pas le confondre avec l'élément racine du document XML qui est lui un noeud élément, enfant du noeud racine.</p>
                            <p>Les données textuelles comprises dans un élément sont représentées dans des <span class="em">noeuds textes</span>. Chaque contenu d'un élément est représenté dans un noeud texte qui est un noeud enfant de l'élément en question.</p>
                            <p>Les <span class="em">noeuds attributs</span> sont associés à un noeud élément, ce ne sont pas des enfants de celui-ci. Leurs valeurs sont directement placées dans ce noeud.</p>
                            <p>Voici un exemple de document XML :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;

&lt;?xml-stylesheet type="text/xsl" href="voiture.xsl"?&gt;
&lt;voitures&gt;
    &lt;voiture&gt;
        &lt;marque&gt;Volkswagen&lt;/marque&gt;
        &lt;immatriculation&gt;UIJ 375&lt;/immatriculation&gt;
        &lt;modele&gt;Polo&lt;/modele&gt;
        &lt;couleur&gt;blue&lt;/couleur&gt;
    &lt;/voiture&gt;
    &lt;voiture&gt;
        &lt;marque&gt;Volkswagen&lt;/marque&gt;
        &lt;immatriculation&gt;HYD 765&lt;/immatriculation&gt;
        &lt;modele&gt;Golf&lt;/modele&gt;
        &lt;couleur&gt;pink&lt;/couleur&gt;
    &lt;/voiture&gt;
&lt;/voitures&gt;</code></pre>
                            <p>Et son arbre document correspondant :</p>
                            <img src="../images/arbre_document_voitures_XML.png" alt="">
                        </li>
                        <li>
                            <h3>XSLT :</h3>
                            <ol>
                                <li>
                                    <h4>Définition :</h4>
                                    <p>Le langage XSLT définit donc la <span class="em">syntaxe</span> et le fonctionnement d'une feuille de style utilisée pour transformer un document XML en un autre document HTML, XSL, texte ou autre.</p>
                                    <p>Cette transformation est assurée par un <span class="em">parseur XSLT</span>. Ce parseur est toujours lié à une application :</p>
                                    <ul>
                                        <li>
                                            <p>MSXML pour Internet Explorer</p>
                                        </li>
                                        <li>
                                            <p>Xalan pour Apache</p>
                                        </li>
                                        <li>
                                            <p>Saxon...</p>
                                        </li>
                                    </ul>
                                    <p>La norme de référence est <a href="http://www.w3.org/TR/xslt" target="_blank">http://www.w3.org/TR/xslt</a>.</p>
                                </li>
                                <li>
                                    <h4>Associer le document XML :</h4>
                                    <p>Pour associer une feuille de style XSLT, par exemple <span class="em">maFeuilleDeStyle.xsl</span>, à un document XML l'instruction de traitement suiivante :</p>
<pre><code>&lt;.xml-stylesheet type="text/xsl" href="maFeuilleDeStyle.xsl"?&gt;</code></pre>
                                    <p>La norme XSLT préconise l'usage de la valeur <span class="html">text/xml</span> pour l'attribut <span class="html">type</span> mais de nombreux parseurs utilient la valeur <span class="html">text/xsl</span>.</p>
                                </li>
                                <li>
                                    <h4>La structure d'une feuille de style XSLT :</h4>
                                    <div>
                                        <img src="../images/structure_XSLT.png" alt="" class="float_right">
                                        <div>
                                            <p>La structure de base d'une feuille de style XSLT commence par un <span class="em">prologue</span>, suivi de l'<span class="em">élément racine</span> <span class="html">xsl:stylesheet</span> pouvant contenir des attributs, notamment une déclaration d'espace de noms ainsi que le numéro de version.</p>
                                            <p>Le prologue consiste en la <span class="em">déclaration XML</span> :</p>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</code></pre>
                                            <p>Commence ensuite directement l'élément racine de la feuille de style.</p>
<pre><code>&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code></pre>
                                        </div>
                                    </div>
                                    <p>Cet élément renferme la déclaration de <span class="em">deux attributs</span> :</p>
                                    <ul>
                                        <li>
                                            <p>l'attribut <span class="html">version</span> qui permet de déclarer la version du XSLT du document (1.0).</p>
                                        </li>
                                        <li>
                                            <p>l'attribut <span class="html">xmlns</span> qui permet la déclaration de l'espace de noms du langage XSLT avec le préfixe <span class="html">xsl</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Enfin, suivent les <span class="em">éléments déclaratifs</span> qui déclarent des informations nécessaires au bon fonctionnement de feuille de style. Par exemple, le type de transformation opérée dans le code XSLT. Dans ce cours, il peut s'agir de HTML ou de XHTML.</p>
<pre><code>&lt;xsl:output method="html"
version="html4.01"
encoding="ISO-8859-1"
doctype-public="-//W3C//DTD HTML 4.01//EN"
doctype-system="http://www.w3.org/TR/html4/strict.dtd"/&gt;</code></pre>
                                    <p>Ou du XML :</p>
<pre><code>&lt;xsl:output method="xml"&gt;</code></pre>
                                    <p>Ou encore du texte :</p>
<pre><code>&lt;xs:output method="text"/&gt;</code></pre>
                                </li>
                                <li>
                                    <h4>Les template rules (règles modèles) :</h4>
                                    <ol>
                                        <li>
                                            <h5>Définition d'un template :</h5>
                                            <p>Dans les feuilles de style tout repose sur les templates définis entre les balises <span class="html">&lt;xsl:template&gt;</span> et <span class="html">&lt;/xsl:template&gt;</span>. Un <span class="em">template</span> définit un <span class="em">modèle</span> qui est utilisé pour <span class="em">construire</span> une partie du <span class="em">résultat</span>.</p>
                                            <p>Un template est définit comme suit en XSLT :</p>
<pre><code>&lt;xsl:template match="pattern"&gt;
...
&lt;/xsl:template&gt;</code></pre>
                                            <p>L'attribut <span class="html">match</span> permet de préciser un <span class="em">pattern</span> (motif). Il s'agit d'une expression qui détermine si le template peut s'appliquer ou non au contexte courant. Le pattern est un chemin d'accès <span class="html">XPath</span> particulier.</p>
                                            <p>La <span class="em">définition</span> du <span class="em">template</span> se trouve dans l'élément <span class="html">xsl:template</span>. Il contient un mélange d'instructions et de données textuelles (HTML). Les instructions sont les éléments qui sont préfixés par <span class="html">xsl</span>.</p>
                                        </li>
                                        <li>
                                            <h5>Fonctionnement de la feuille de style :</h5>
                                            <p>Le <span class="em">premier template</span> qu'un document XSLT contient celui associé à la racine du document XML, que l'on note <span class="html">&lt;xsl:template match="/"&gt;</span>. Le pattern "/", précisé dans l'attribut <span class="html">match</span>, indique que ce template s'applique à la racine du document XML.</p>
                                            <p>Dans un premier temps, le parseur XSLT <span class="em">définit le contexte initial</span> qui correspond à la <span class="em">racine</span> du document XML.</p>
                                            <p>Ensuite, il va parcourir tous les <span class="em">templates</span> et sélectionner ceux qui peuvent s'appliquer au contexte initial. Parmi les templates sélectionnés, <span class="em">un seul</span> est choisi, selon un mécanisme précis (voir la section suivante nommée "Choix du template le plus adéquat"), et est exécuté.</p>
                                            <p>Pour <span class="em">exécuter un template</span>, le parseur XSLT procède comme suit :</p>
                                            <ol>
                                                <li>
                                                    <p>Les instructions, préfixées par <span class="html">xsl</span>, sont exécutées.</p>
                                                </li>
                                                <li>
                                                    <p>Les éléments non préfixés sont recopiés tels quels dans le document résultat.</p>
                                                </li>
                                                <li>
                                                    <p>Les données textuelles sont recopiées telles quelles pour autant qu'elles contiennent autre chose que des caractères blancs.</p>
                                                </li>
                                                <li>
                                                    <p>Les commentaires et les instructions de traitement éventuels sont ignorés.</p>
                                                </li>
                                            </ol>
                                            <p>Si le parseur rencontre l'instruction <span class="html">xsl:apply-templates</span>, il sélectionne un ensemble de noeurd définit dans l'attribut <span class="html">select</span> de cette instruction. Cet ensemble de noeuds définit des nouveaux <span class="em">noeuds contextes</span> qui à leur tour sont exécutés par le parseur XSLT. Lors de l'exécution des nouveaux noeuds contextes, l'exécution du template en cours est suspendue.</p>
                                            <p>Elle reprendra son cours après ce traitement en récupérant le contexte initial.</p>
                                            <img src="../images/xsl-apply-templates.png" alt="">
                                        </li>
                                        <li>
                                            <h5>Choix du template le plus adéquat :</h5>
                                            <p>La sélection du template le plus adéquat est déterminée par son <span class="em">pattern</span> (valeur de l'attribut <span class="html">match</span>). Pour rappel, le pattern est une <span class="em">expression XPath</span>.</p>
                                            <p>De manière simplifiée, le parseur XSLT <span class="em">sélectionne</span> le template dont le pattern donne <span class="em">le plus de détails</span>.</p>
                                            
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>