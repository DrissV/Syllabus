<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Pascal - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#elements_langage">Éléments du langage</a></li>
                        <li><a href="#entete_partie_declaration">En-tête et partie déclaration</a></li>
                        <li><a href="#partie_instruction">Partie instruction</a></li>
                        <li><a href="#types">Types</a></li>
                        <li><a href="#instructions_structurees">Instructions structurées</a></li>
                        <li><a href="#type_string">Type string (chaînes courtes)</a></li>
                        <li><a href="#fonctions_procedures">Fonctions et procédures</a></li>
                        <li><a href="#tableaux">Tableaux (Array)</a></li>
                        <li><a href="#lazarus">Lazarus</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Pascal :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage Pascal a été créé dans les années 1970 à Züricg par le professeur suisse Niklaus Wirth, avec pour objectif principal de favoriser la clarté, la lisibilité et la fiabilité du code. Il tire son nom du mathématicien, physicien, inventeur et philosophe français Blaise Pascal (1623-1662).</p>
                    <p>Pascal est un langage de programmation impératif et structuré, largement utilisé dans les milieux académiques et éducatifs, ainsi que dans le développement de logiciels système, d'applications scientifiques et d'ensembles d'outils.</p>
                    <p>Il se distingue par sa syntaxe formelle, ses structures de contrôle claires telles que les boucles et les structures conditionnelles, ainsi que par ses types de données statiquement typés. Ces caractéristiques en font un langage idéal pour l'apprentissage des concepts fondamentaux de la programmation.</p>
                    <p>Pascal a influencé de nombreux autres langages de programmation, notamment Ada, Modula-2 et Delphi. Bien que son utilisation ait décliné dans le monde professionnel au profit de langage plus modernes, il reste un choix populaire pour l'enseignement de la programmation en raison de sa simplicité et de sa lisibilité.</p>
                    <p>Si vous faites une recherche sur le langage Pascal, vous verrez systématiquement cités <span class="em">Turbo Pascal</span>, <span class="em">Free Pascal</span>, <span class="em">Lazarus</span> et <span class="em">Delphi</span>.</p>
                    <p>Le premier est en quelque sorte l'ancêtre des trois autres : <span class="em">Turbo Pascal</span>, édité par Borland, a fait les beaux jours du langage Pascal sur MS-DOS, puis sur les premières versions de Windows.</p>
                    <p>Le successeur de Turbo Pascal a été (et toujoursk malgré successifs de Borland) <span class="em">Delphi</span>. Des extensions ont été ajoutées au langage qui s'appelle désormais le <span class="em">Pascal Objet</span> (cette appelation tient au fait que le Pascal moderne a intégré les principes de la Programmation Orientée Objet dont nous parlerons en temps utile). De plus, la conception des applications se fait visuellement et plus rapidement : on parle de <span class="em">RAD</span> pour <span class="em">Rapid Application Development</span> ("Développement rapide d'application"). Delphi est à présent inclus dans la suite appelée <span class="eem">RAD Studio</span>.</p>
                    <p>Parallèlement à la mise au point de Turbo Pascal, au début des années 1990, une équipe de développeurs a créé une alternative libre et gratuite au produit phare de Borland : FPK Pascal, devenu <span class="em">Free Pascal</span>, parfois abrégé en <span class="em">FPC</span>. Lui aussi compile du Pascal Objet.</p>
                    <p>Lorsque Delphi s'est installé sur le marché des outils de développement, s'est bâtie sur Free Pascal l'alternative livre et gratuite <span class="em">Lazarus</span>.</p>
                    <p>Tous ces outils de développement permettent de compiler du langage Pascal. Avec Turbo Pascal et Free Pascal, vous écrivez vous-même tout le code n'écessaire; avec Lazarus et Delphi, une partie est automatiquement générée lorsque vous déposez et modifiez des composants prêts à l'emploi sur des fiches.</p>
                    <ol>
                        <li>
                            <h3>Pourquoi apprendre le Pascal aujourd'hui ?</h3>
                            <p>Si par curiosité vous parcourez des forums de discussion sur la programmation, vous risquez de tomber sur des réflexions qui ne vous encourageront pas à apprendre le langage Pascal. Étant donné qu'il a longtemps étét enseigné comme langage de base de programmation dans les écoles, le Pascal est resté, dans l'esprit de certains, un langage pour débutants ou développeurs amateurs.</p>
                            <p>Eh bien, c'est totalement faux ! Les première versions du système Macintosh d'Apple, des programmes pour les missions spatiales Apollo et des logiciels comme Photoshop, Skype, Kaspersky, Jabber, SpyBot ou Everest ont été initialement écrits en Pascal. Savez-vous, par exemple, qu'un logiciel de composition musicale aussi célèbre que FL Studio est écrit en Pascal ? Et ce rapide inventaire ne comprend pas de plus en plus d'applications créées pour les smartphones ! En fait, dans le monde du développement professionel, le Pascal navigue toujours dans les dix à quinze langages les plus utilisés (citons les plus courants : C (avec ses dérivés C++, C#, Objective-C), Java, PHP, JavaScript, Python, Perl, Ruby, Basic, Lisp et Assembleur...). C'est tout simplement qu'il a su évoluer et intégrer les acquis d'une programmation moderne.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="elements_langage">Éléments du langage :</h2>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Un programme Pascal est écrit sous la forme d'une suite de lignes de texte. La longueur d'une ligne ne fait pas partie des spécifications du Pascal.</p>
                            <p>Un programme Pascal est composé :</p>
                            <ul>
                                <li>
                                    <p><span class="em">d'éléments du langage</span> (les plus petits éléments significatifs - tokens) séparés (si nécessaire par)</p>
                                </li>
                                <li>
                                    <p>un ou plusieurs <span class="em">séparateurs</span>.</p>
                                </li>
                            </ul>
                            <p>Un séparateur est :</p>
                            <ul>
                                <li>
                                    <p>soit un <span class="em">caractère inerte</span> : <span class="em">le caractère espace</span> (valeur ASCII 32) et <span class="em">tous les caractères de contrôle</span> (valeurs ASCII de 0 à 31)</p>
                                </li>
                                <li>
                                    <p>soit un <span class="em">commentaire</span>; les commentaires (qui ne peuvent être imbriqués) sont ignorés par le compilateur; ils aident seulement à la lisibilité de vos programmes.</p>
<pre><code>{ceci est un commentaire}
(* ceci également *)
// et ceci est un commentaire en ligne</code></pre>
                                    <p class="em">Un commentaire comportant le symbole $ immédiatement après l'accolade ouvrante est une directive de compilation.</p>
                                    <p class="em">Ainsi, dans l'environnement Delphi 4, la directive {$APPTYPE CONSOLE} signifie au compilateur que le programme devra correspondre à une application console.</p>
<pre><code>Program Hello ;
<span class="em">{$APPTYPE CONSOLE}</span>
begin
    writeLn('Hello, World…') ;
    <span class="em">readLn</span>
end.</code></pre>
                                </li>
                            </ul>
                            <p>Les éléments du langage comprennent :</p>
                            <ul>
                                <li>
                                    <p>les symboles spéciaux et les mots réservés</p>
                                </li>
                                <li>
                                    <p>les identificateurs</p>
                                </li>
                                <li>
                                    <p>les nombres</p>
                                </li>
                                <li>
                                    <p>les constantes chaînes de caractères</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Symboles spéciaux et mots réservés :</h3>
                            <p>Les symboles spéciaux et les mots réservés sont des caractères ou des suites de caractères ayant une ou plusieurs significations fixées par le langage.</p>
                            <ol>
                                <li>
                                    <h4>Symboles spéciaux :</h4>
                                    <ul>
                                        <li>
                                            <p>+</p>
                                        </li>
                                        <li>
                                            <p>*</p>
                                        </li>
                                        <li>
                                            <p>/</p>
                                        </li>
                                        <li>
                                            <p>=</p>
                                        </li>
                                        <li>
                                            <p>&lt;</p>
                                        </li>
                                        <li>
                                            <p>&gt;</p>
                                        </li>
                                        <li>
                                            <p>[</p>
                                        </li>
                                        <li>
                                            <p>]</p>
                                        </li>
                                        <li>
                                            <p>.</p>
                                        </li>
                                        <li>
                                            <p>,</p>
                                        </li>
                                        <li>
                                            <p>(</p>
                                        </li>
                                        <li>
                                            <p>)</p>
                                        </li>
                                        <li>
                                            <p>:</p>
                                        </li>
                                        <li>
                                            <p>;</p>
                                        </li>
                                        <li>
                                            <p>'</p>
                                        </li>
                                        <li>
                                            <p>^</p>
                                        </li>
                                        <li>
                                            <p>@</p>
                                        </li>
                                        <li>
                                            <p>{</p>
                                        </li>
                                        <li>
                                            <p>}</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>$</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>&lt;=</p>
                                        </li>
                                        <li>
                                            <p>&gt;=</p>
                                        </li>
                                        <li>
                                            <p>&lt;&gt;</p>
                                        </li>
                                        <li>
                                            <p>:=</p>
                                        </li>
                                        <li>
                                            <p>..</p>
                                        </li>
                                        <li>
                                            <p>(*)</p>
                                        </li>
                                        <li>
                                            <p>*)</p>
                                        </li>
                                        <li>
                                            <p>(.)</p>
                                        </li>
                                        <li>
                                            <p>.)</p>
                                        </li>
                                        <li>
                                            <p>//</p>
                                        </li>
                                        <li>
                                            <p>&amp;</p>
                                        </li>
                                    </ul>
                                    <p>Exemple :</p>
                                    <p>Le symbole <span class="em">&lt;=</span> représente un opérateur. Il est d'ailleurs surchargé, ce qui signifie qu'il possède plusieurs significations. Suivant le contexte, il symbolise l'opération inférieur ou égal ou l'opération sous-ensemble de.</p>
                                </li>
                                <li>
                                    <h4>Mots réservés :</h4>
                                    <p>Les mots réservés ou mots clés font partie du langage Pascal; ils ne peuvent en aucun cas être redéfinis et possèdent une signification standard prédéfinie. En voici la liste :</p>
                                    <ul>
                                        <li>
                                            <p>and</p>
                                        </li>
                                        <li>
                                            <p>array</p>
                                        </li>
                                        <li>
                                            <p>begin</p>
                                        </li>
                                        <li>
                                            <p>case</p>
                                        </li>
                                        <li>
                                            <p>const</p>
                                        </li>
                                        <li>
                                            <p>div</p>
                                        </li>
                                        <li>
                                            <p>do</p>
                                        </li>
                                        <li>
                                            <p>downto</p>
                                        </li>
                                        <li>
                                            <p>else</p>
                                        </li>
                                        <li>
                                            <p>End</p>
                                        </li>
                                        <li>
                                            <p>file</p>
                                        </li>
                                        <li>
                                            <p>for</p>
                                        </li>
                                        <li>
                                            <p>function</p>
                                        </li>
                                        <li>
                                            <p>goto</p>
                                        </li>
                                        <li>
                                            <p>if</p>
                                        </li>
                                        <li>
                                            <p>in</p>
                                        </li>
                                        <li>
                                            <p>label</p>
                                        </li>
                                        <li>
                                            <p>mod</p>
                                        </li>
                                        <li>
                                            <p>nil</p>
                                        </li>
                                        <li>
                                            <p>not</p>
                                        </li>
                                        <li>
                                            <p>of</p>
                                        </li>
                                        <li>
                                            <p>or</p>
                                        </li>
                                        <li>
                                            <p>packed</p>
                                        </li>
                                        <li>
                                            <p>procedure</p>
                                        </li>
                                        <li>
                                            <p>program</p>
                                        </li>
                                        <li>
                                            <p>record</p>
                                        </li>
                                        <li>
                                            <p>repeat</p>
                                        </li>
                                        <li>
                                            <p>set</p>
                                        </li>
                                        <li>
                                            <p>then</p>
                                        </li>
                                        <li>
                                            <p>to</p>
                                        </li>
                                        <li>
                                            <p>type</p>
                                        </li>
                                        <li>
                                            <p>until</p>
                                        </li>
                                        <li>
                                            <p>var</p>
                                        </li>
                                        <li>
                                            <p>while</p>
                                        </li>
                                        <li>
                                            <p>with</p>
                                        </li>
                                    </ul>
                                    <p>Le Pascal Objet en allonge la liste :</p>
                                    <ul>
                                        <li>
                                            <p>As</p>
                                        </li>
                                        <li>
                                            <p>asm</p>
                                        </li>
                                        <li>
                                            <p>class</p>
                                        </li>
                                        <li>
                                            <p>constructor</p>
                                        </li>
                                        <li>
                                            <p>destructor</p>
                                        </li>
                                        <li>
                                            <p>dispinterface</p>
                                        </li>
                                        <li>
                                            <p>except</p>
                                        </li>
                                        <li>
                                            <p>exports</p>
                                        </li>
                                        <li>
                                            <p>finalization</p>
                                        </li>
                                        <li>
                                            <p>implementation</p>
                                        </li>
                                        <li>
                                            <p>inherited</p>
                                        </li>
                                        <li>
                                            <p>initialization</p>
                                        </li>
                                        <li>
                                            <p>inline</p>
                                        </li>
                                        <li>
                                            <p>interface</p>
                                        </li>
                                        <li>
                                            <p>is</p>
                                        </li>
                                        <li>
                                            <p>library</p>
                                        </li>
                                        <li>
                                            <p>object</p>
                                        </li>
                                        <li>
                                            <p>out</p>
                                        </li>
                                        <li>
                                            <p>finally</p>
                                        </li>
                                        <li>
                                            <p>unit</p>
                                        </li>
                                        <li>
                                            <p>property</p>
                                        </li>
                                        <li>
                                            <p>raise</p>
                                        </li>
                                        <li>
                                            <p>resourcestring</p>
                                        </li>
                                        <li>
                                            <p>shl</p>
                                        </li>
                                        <li>
                                            <p>shr</p>
                                        </li>
                                        <li>
                                            <p>string</p>
                                        </li>
                                        <li>
                                            <p>threadvar</p>
                                        </li>
                                        <li>
                                            <p>try</p>
                                        </li>
                                        <li>
                                            <p>uses</p>
                                        </li>
                                        <li>
                                            <p>xor</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Identificateurs :</h3>
                            <p>Les identificateurs symbolisent les constantes, les champs (d'enregistrement) les unités, les bibliothèques et les paquets. Nous en avons déjà étudié la syntaxe. Pascal contient des identificateurs (directives) standards dotés de sognifications prédéfinies. Contrairement aux mots réservés, vous "pouvez" les redéfinir...</p>
                            <ul>
                                <li>
                                    <p>absolute</p>
                                </li>
                                <li>
                                    <p>abstract</p>
                                </li>
                                <li>
                                    <p>assembler</p>
                                </li>
                                <li>
                                    <p>automated</p>
                                </li>
                                <li>
                                    <p>Cdel</p>
                                </li>
                                <li>
                                    <p>contains</p>
                                </li>
                                <li>
                                    <p>default</p>
                                </li>
                                <li>
                                    <p>At</p>
                                </li>
                                <li>
                                    <p>dispid</p>
                                </li>
                                <li>
                                    <p>dynamic</p>
                                </li>
                                <li>
                                    <p>export</p>
                                </li>
                                <li>
                                    <p>external</p>
                                </li>
                                <li>
                                    <p>far</p>
                                </li>
                                <li>
                                    <p>implements</p>
                                </li>
                                <li>
                                    <p>forward</p>
                                </li>
                                <li>
                                    <p>on</p>
                                </li>
                                <li>
                                    <p>index</p>
                                </li>
                                <li>
                                    <p>message</p>
                                </li>
                                <li>
                                    <p>name</p>
                                </li>
                                <li>
                                    <p>near</p>
                                </li>
                                <li>
                                    <p>nodefault</p>
                                </li>
                                <li>
                                    <p>reintroduce</p>
                                </li>
                                <li>
                                    <p>override</p>
                                </li>
                                <li>
                                    <p>safecall</p>
                                </li>
                                <li>
                                    <p>pascal</p>
                                </li>
                                <li>
                                    <p>private</p>
                                </li>
                                <li>
                                    <p>protected</p>
                                </li>
                                <li>
                                    <p>public</p>
                                </li>
                                <li>
                                    <p>published</p>
                                </li>
                                <li>
                                    <p>overload</p>
                                </li>
                                <li>
                                    <p>read</p>
                                </li>
                                <li>
                                    <p>Readonly</p>
                                </li>
                                <li>
                                    <p>register</p>
                                </li>
                                <li>
                                    <p>resident</p>
                                </li>
                                <li>
                                    <p>stdcall</p>
                                </li>
                                <li>
                                    <p>stored</p>
                                </li>
                                <li>
                                    <p>virtual</p>
                                </li>
                                <li>
                                    <p>requires</p>
                                </li>
                                <li>
                                    <p>write</p>
                                </li>
                                <li>
                                    <p>writeonly</p>
                                </li>
                            </ul>
                            <p>Rappelons le diagramme de Conway pour l'écriture des identificateurs :</p>
                            <img src="../images/diagramme_Conway_ecriture_identificateurs.png" alt="">
                            <p>Un identificateur peut avoir une taille quelconque mais seuls les 255 (<span class="em">63 pour les anciens compilateurs</span>) premiers caractères sont significatifs.</p>
                        </li>
                        <li>
                            <h3>Nombres :</h3>
                            <p>Les nombres avec décimales ou exposants sont des constantes de type réel. Les autres nombres sont des entiers. Les valeurs doivent se trouver à l'intérieur de l'intervalle du plus grand type prédéfini entier ou réel.</p>
                            <p>Les nombres hexadécimaux sont des entiers et ils doivent être compris entre $00000000 et $FFFFFFFF.</p>
                            <ul>
                                <li>
                                    <p>Un nombre entier en notation décimale se compose d'une suite de chiffres éventiellement précédés d'un signe (exemple : 46). En notation hexadécimale, il se compose en plus, des lettres de A à F (ou a à f); il est alors préfixé par le signe $ (exemple : $2E).</p>
                                    <p>Notation décimale :</p>
                                    <img src="../images/notation_decimale_Pascal.png" alt="">
                                    <p>Notation hexadécimale :</p>
                                    <img src="../images/notation_hexadecimale_Pascal.png" alt="">
                                </li>
                                <li>
                                    <p>Un nombre réel doit contenir un point décimal ou un exposant - ou bien les deux.</p>
                                    <p>S'il contient un point décimal, celui doit figurer entre deux chiffres (exemple : 46.0).</p>
                                    <p>Et en notation scientifique : 0.46 E2 (se lit 0.46 fois dix à la puissance 2)</p>
                                    <img src="../images/notation_scientifique_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Notez que les nombres entiers sont des quantités exactes, alors que les nombres réels correspondent à des approximations.</p>
                        </li>
                        <li>
                            <h3>Chaînes de caractères :</h3>
                            <p>Une chaîne de caractères est une suite éventuellement vide de caractères délimitée par des apostrophes.</p>
                            <p>Pascal Objet offre la possibilité d'insérer dans les chaînes de caractères des caractères de contrôle (le signe dièse suivi directement d'une constante entière dans l'intervalle 0..255 représente le caractère ASCII correspondant).</p>
                            <p>UneMethode chaîne de caractères doit s'écrire sur une seule ligne.</p>
                            <img src="../images/chaines_caracteres_Pascal.png" alt="">
                            <p>(*) tous les caractères sauf l'apostrophe et le retour chariot.</p>
<pre><code>'Exemple d''une chaîne'
''	{chaîne vide}
''''	{chaîne comprenant une apostrophe}
#7#7'Debout !'#7#7
'Ligne 1'#13'Ligne 2'</code></pre>
                            <p>Dans un programme Pascal, on peut utiliser indifféremment majuscules et miniscules. Dans une chaîne, où les caractères se représentent eux-mêmes, il existe une différence entre une lettre minuscule et la majuscule correspondante. Le caractère espace (#32) n'y est pas considéré comme un séparateur et les caractères accentués peuvent y être employés.</p>
                        </li>
                        <li>
                            <h3>Un exemple de programme Pascal :</h3>
                            <p>Considérons le programme Pascal qui traduit le premier algorithme du chapitre précédent et retrouvons les éléments de langage.</p>
<pre><code>PROGRAM Premier_Programme_Pascal ;
{édition de la longueur de la circonférence d'un cercle }

{$APPTYPE CONSOLE}		// cfr. Delphi 4

CONST PI = 3.14159 ;
VAR   rayon,circonference : REAL ;

BEGIN 
    write('Rayon : ') ;
    readLn(rayon) ;
    circonference := 2 * PI * rayon ;
    writeLn('Circonférence : ',circonference) ;
    readLn
END.</code></pre>
                            <p><span class="em">symboles spéciaux :</span> ; = ( ) * , := . : { }</p>
                            <p><span class="em">mots réservés :</span> PROGRAM CONST VAR BEGIN END</p>
                            <p><span class="em">identificateurs standard :</span> write readlin writeln</p>
                            <p><span class="em">identificateurs :</span></p>
                            <ul>
                                <li>
                                    <p>de programme : Premier_Programme_Pascal</p>
                                    <li>
                                        <p>de constante : PI</p>
                                    </li>
                                    <li>
                                        <p>de variable : rayon circonference</p>
                                    </li>
                                </li>
                            </ul>
                            <p><span class="em">commentaires :</span> {édition ... cercle}</p>
                            <p><span class="em">directive de compilation :</span> {$APPTYPE CONSOLE}</p>
                            <p><span class="em">chaînes de caractères :</span> 'Rayon : ' 'Circonférence : '</p>
                            <p><span class="em">nombre entier :</span>2</p>
                            <p><span class="em">nombre réel :</span>3.14259</p>
                            <p class="em">Remarque : très souvent, dans la suite du cours, nous omettrons la directive de compilation (ainsi que le readLn final). Il est bien certain cependant, que dans l'environnement Delphi 4, vous devrez l'insérer si vous désirez construire une application console !</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="entete_partie_declaration">En-tête et partie déclaration :</h2>
                    <ol>
                        <li>
                            <h3>Structure générale d'un programme :</h3>
                            <p>Un programme Pascal est constitué d'un en-tête de programme suivi par un bloc de programme.</p>
                            <p>Le bloc est divisé en une partie déclaration dans laquelle sont définis tous les objets locaux au programme, et une partie instructions qui spécifie les actions à exécuter sur ces objets. Ainsi, toute variable apparaissant dans une instruction doit avoir été déclarée au préalable dans une déclaration de variable.</p>
                            <img src="../images/structure_generale_programme_Pascal.png" alt="">
                            <p>Reprenons notre premier programme Pascal et tentons d'en découvrir la structure générale.</p>
                            <img src="../images/premier_programme_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Partie déclaration :</h3>
                            <p>La partie déclaration peut elle-même être divisée en plusieurs déclarations : de labels, de constantes, de types, de variables, de procédures et de fonctions. Contraitrement au Pascal Objet, le Pascal standard impose que ces déclarations - si elles existent - se fassent une seule fois et dans un certain ordre. Cette façon de procéder manque de souplesse.</p>
                            <img src="../images/partie_declaration_Pascal.png" alt="">
                            <p class="em">Remarque : La partie déclaration peut être absente, comme  dans l'exemple suivant :</p>
<pre><code>program qui_ne_fait_rien ;
BEGIN
END.</code></pre>
                            <p>Nous ne nous intéresserons dans les paragraphes suivants qu'aux déclarations de constantes et de variables.</p>
                        </li>
                        <li>
                            <h3>Déclaration des constantes :</h3>
                            <p>On devrait parler plutôt de définition de constante; celle-ci permet d'introduire un identificateur comme synonyme d'une expression constante. Une expression constante est une expression qui peut être évaluée lors de la compilation, sans qu'il soit nécessaire d'exécuter le programme.</p>
                            <p>Exemples :</p>
<pre><code>const PI = 3.14159 ;
      MESSAGE = 'Hello, world' ;
      CARACT = 'F' ;
      NBRCAR = ORD('Z') - ORD('A') + 1 ;
      MIN = 1 ;
      MAX = 100 ;
      CENTRE = (MAX - MIN) DIV 2 ;</code></pre>
                            <img src="../images/declaration_constantes" alt="">
                            <p>Il existe des identificateurs de constantes standard comme MAXINT qui représente le plus grand entier (INTEGER). Sa valeur, dans une implémentation 32 bits, est +2147483647 soit 2<sup>31</sup> - 1.</p>
                            <p>L'utilisation d'identificateurs de constante rend un programme plus lisible, facilite sa documentation et certaines modifications.</p>
                            <p>Remarques :</p>
                            <ul>
                                <li>
                                    <p>Les fonctions standard suivntes sont autorisées dans les expressions constantes : <span class="html">Abs</span>, <span class="html">Addr</span>, <span class="html">Chr</span>, <span class="html">Hi</span>, <span class="html">high</span>, <span class="html">Length</span>, <span class="html">Lo</span>, <span class="html">Low</span>, <span class="html">Odd</span>, <span class="html">Ord</span>, <span class="html">Pred</span>, <span class="html">Ptr</span>, <span class="html">Round</span>, <span class="html">SizeOf</span>, <span class="html">Succ</span>, <span class="html">Swap</span>, <span class="html">Trunc</span>.</p>
                                </li>
                                <li>
                                    <p>Notre Pascal possède un identificateur prédéclaré <span class="html">pi</span>. Il s'agit non d'une constante, mais d'une fonction arithmétique qui renvoie la valeur <span class="em">3.141592653587932385</span>. Si, comme dans notre exemple, nous avons redéclaré <span class="em">pi</span>, nous n'avons plus accès à cette fonction.</p>
                                </li>
                                <li>
                                    <p>Il permte la définition de constantes typées. Une constante typée est une variable spécifiant une valeur initiale et qui ne peut pas être mdoifiée.</p>
<pre><code>const max : integer = 100 ;
    titre : string = 'Les constantes typées' ;</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Déclaration des variables :</h3>
                            <p>Déclarer une variable, c'est donner un nom à une variable. C'est aussi lui associer un type ce qui détermine les valeurs qu'elle peut prendre, les opérations dont elle peut faire l'objet et son encombrement mémoire.</p>
                            <p>Chaque variable ne peut faire l'objet que d'une seule déclaration dans une partie déclarative donnée. Cette déclaration implique la réservation, <span class="em">si c'est approprié</span>, d'une place en mémoire. Rappelons qu'en Pascal, les variables ne possèdent pas de valeur initiale définie. Les variables déclarées dans le bloc du programme sont appelées variables globales; ce sont les seules que nous connaissons pour l'instant.</p>
                            <p>Une déclaration de variables consiste en une liste d'idnetificateurs de variables et un type associé.</p>
                            <img src="../images/declaration_variables_Pascal.png" alt="">
                            <p><span class="html">&lt;type&gt;</span> représente soit un identificateur de type, soit un descripteur de type.</p>
                            <p>Exemples :</p>
<pre><code>var racine, quotient : REAL ;
    compteur, x, y : INTEGER ;
    reponse : CHAR ;
    trouve, continue : BOOLEAN ;</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="partie_instruction">Partie instruction :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La partie instruction définit les instructions ou actions algorithmiques exécutées dans le bloc.</p>
                            <img src="../images/partie_instruction_Pascal.png" alt="">
                            <p>Délimitée par les mots réservés <span class="html">begin</span> et <span class="html">end</span>, la partie instruction se compose d'une instruction ou d'une suite d'instructions séparées par <span class="em">;</span>. Le point-virgule, en Pascal, est un séparateur d'instructions, alors que dans d'autres langages, il termine une instruction. Dans l'exemple du programme <span class="em">qui_ne_fait_rien</span>, l'instruction était l'instruction vide.</p>
                        </li>
                        <li>
                            <h3>Instructions simples :</h3>
                            <p>Il en existe de quatre sortes en Pascal :</p>
                            <ul>
                                <li>
                                    <p>instructin d'affectation</p>
                                </li>
                                <li>
                                    <p>appel de procédure</p>
                                </li>
                                <li>
                                    <p>instruction goto</p>
                                </li>
                                <li>
                                    <p>instruction vide</p>
                                </li>
                            </ul>
                            <ol>
                                <li>
                                    <h4>L'instruction d'affectation :</h4>
                                    <p>L'instruction d'affectation remplace la valeur d'une variable par une nouvelle valeur. Cette nouvelle valeur est spécifiée par une expression qui doit être du même type ou du moins d'un type compatible avec le type de la variable.</p>
<pre><code>&lt;variable&gt; := &lt;expression&gt;</code></pre>
                                    <p>Exemple :</p>
                                    <p>LDA : <span class="em">circonference &lt;--- 2 * pi * rayon</span></p>
                                    <p>Pascal : <span class="em">circonference := 2 * pi * rayon</span></p>
                                </li>
                                <li>
                                    <h4>L'instruction de procédure :</h4>
                                    <p>Une procédure est un sous-programme qui produit un effet. Il en existe des prédéclarées que vous pouvez appeler par des instructions de procédure. Il suffiit, pour ce faire, de spécifier l'identificateur de procédure ainsi que les paramètres nécessaires. Nous nous intéresserons aux procédures de lecture (entrées) et d'écriture (sorties).</p>
                                    <ul>
                                        <li>
                                            <p>À l'instruction LDA <span class="em">lire</span> correspond les procédures <span class="html">read</span> et <span class="html">readln</span>,</p>
                                        </li>
                                        <li>
                                            <p>Et à l'instruction <span class="em">écrire</span> les procédures <span class="html">write</span> et <span class="html">writeln</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="types">Types :</h2>
                    <ol>
                        <li>
                            <h3>Valeurs, variables et types :</h3>
                            <p>De manière générale, les programmes expriment des calculs sur des <span class="em">valeurs</span>. Cependant, les valeurs ne sont pas le seul genre d'objet qui apparaissent dans les programmes algorithmiques. En effet, les valeurs produites par l'exécution séquentielle des programmes peuvent être à mémoriser explicitement pour une utilisation ultérieure. Pour ce faire, un deuxième genre d'objet est nécessaire : les variables. Ces objets ont non seulement des propriétés logiques, mais aussi une représentation physique : les valeurs sont représentées par des emplacements en mémoire (chaque emplacement correspond à une adresse). Tous ces objets, c'est l'évidence, ne possèdent pas les mêmes propriétés : les nombres réels ne se manipulent pas comme les nombres entiers, les opérateurs relationnels produisent des valeurs logiques, les valeurs diffèrent des variables...</p>
                            <p>Quel que soit leur genre, tous ces objets ont leurs propriétés propres que l'on caractérise par un <span class="em">type</span>.</p>
                            <p>Les langages algorithmiques associent aux objets en général et aux valeurs en particulier des types. Chaque type spécifie :</p>
                            <ul>
                                <li>
                                    <p>un ensemble d'objets, par ex. des valeurs entières,</p>
                                </li>
                                <li>
                                    <p>un ensemble de propriété que ces objets doivent satisfaire <span class="em">et</span></p>
                                </li>
                                <li>
                                    <p>un ensemble d'opérations qui utilisent ces objets comme opérandes ou les produisent comme résultats.</p>
                                </li>
                            </ul>
                            <p>Ainsi, à chaque objet sera associé un type, et tous les objets d'un même type auront des propriétés communes, caractéristiques de ce type.</p>
                            <p>Dans le langage courant, nous disons qu'une valeur tel qu'une valeur tel que 12345 ou une variable x sont de type entier ... qu'en Pascal on définit par l'identificateur de type INTEGER. En toute rigueur, cela est inexact.</p>
                            <p>Une valeur entière et une variable entière sont deux objets qui ont des propriétés bien différentes :</p>
                            <ul>
                                <li>
                                    <p>12345 appartient au type INTEGER.</p>
                                    <p>À ce type correspond un ensemble de valeurs entières, des propriétés (<span class="em">ces valeurs sont ordonnées</span>) et des opérations (<span class="em">l'addition, la soustraction ...</span>).</p>
                                </li>
                                <li>
                                    <p>par contre, x dénote une variable entière qu'on devrait spécifier de type VAR INTEGER. Les opérations que nous connaissons sur de telles variables sont :</p>
                                    <ul>
                                        <li>
                                            <p>sa déclaration (var x : Integer;)</p>
                                        </li>
                                        <li>
                                            <p>l'affectation (x:= 12345)</p>
                                        </li>
                                        <li>
                                            <p>la prise de valeur (y := x +3)</p>
                                        </li>
                                    </ul>
                                    <p>À gauche du signe d'affectatipn, x dénote une variable et est de type VAR INTEGER. Il en est de même à droite, mais il doit être clair que l'addition + 3 est à effectuer sur la <span class="em">valeur</span> de cette variable. l'opération <span class="em">prise de valeur</span> est ici à effectuer bien qu'aucun opérateur ne la désigne : elle est implicitement spécifiée par le contexte.</p>
                                    <p>On appelle <span class="em">opération implicite</span> une opération à laquelle ne correspond aucun opérateur. L'opération prise de valeur est donc une opération implicite auquel correspond une transformation de type VAR INTEGER &#8594; INTEGER.</p>
                                    <p>Remarque : vous pouvez écrire <span class="em">z := w</span> ou <span class="em">z := (w)</span> mais non <span class="em">(z) := w</span> !</p> 
                                </li>
                            </ul>
                            <p>Les langages algoirithmiques sont définis de telle sorte que toutes les valeurs d'un type T donné puissent être représentées par des chaînes de bits de même taille. Il s'ensuit que toutes les variables du type T peuvent être représentées par des emplacements mémoire de même taille et que chacun de ces emplacements pourra contebur la représentation de n'importe quelle valeur du type T.</p>
                            <p>Il doit bien être évident cependant qu'à chaque classe de valeurs va correspondre une classe de variables de même structure. Dans la suite de ce cours, nous parlerons par abus de langage, d'une variable de type INTEGER par exemple, vius saurez ce que cela recouvre implicitement. Rappelons que contrairement à une variable, une valeur telle 12345 est supposée exister en dehors de toute exécution.</p>
                            <p>Un littéral (12345), une expression (12000+345), une constante (CONST N = 12345), un identificateur de variable après l'opération de prise de valeur peuvent dénoter la même valeur.</p>
                            <p>Lorsque nous parlons de variables, il peut s'agir, selon le contexte, des variables algorithmiques, de variables de programme ou de variables d'état. Une variable d'état est caractérisée comme une variable de programme par un identificateur et un type. Elle est par contre la seule pour laquelle nous pouvons parler d'allocation mémoire et de valeur. Cependant, par référence aux variables d'état, nous dirons d'une variable de programme qu'elle est... <span class="em">déclarée</span> lorsque sont connus identificateur et son type, <span class="em">définie</span> lorsqu'elle est déclarée et que l'on peut faire référence à son allocation physique en mémoire, <span class="em">initialisée</span> lorsqu'elle est définie et qu'une valeur lui a été associée (d'après Cardon et Charras).</p>
                        </li>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Il existe en Pascal Objet sept classes majeures de types.</p>
                            <img src="../images/classes_majeures_types_Pascal.png" alt="">
                            <p>Ces différentes classes sont décrites dans la suite du cours. Nous nous intéresserons dans ce chapitre aux types simples.</p>
                        </li>
                        <li>
                            <h3>Types simples :</h3>
                            <p>Les types simples sont comme leurs noms l'indiquent les types de base; pour la plupart, ce sont ceux que l'on trouve tout faits sur les ordinateurs. Ces types sont des types de valeurs simples, c'est-à-dire qui ne sont pas considérés, dans un langage donné, comme composées d'éléments discernables. Les valeurs simples sont les valeurs les plsu classiques, en particulier les nombres.</p>
                            <p>Le langage Pascal sépare les types simples en deux classes :</p>
                            <ul>
                                <li>
                                    <p>d'une part les types réels et</p>
                                </li>
                                <li>
                                    <p>d'autre part les types scalaires.</p>
                                </li>
                            </ul>
                            <p>Un type scalaire (étymologiquement scalaire signifie échelle) caractérise un ensemble fini et ordonné de valeurs. On parle aussi de type discret ou ordinal. À chaque valeur d'un type scalaire est associé un rang qui est une valeur entière (ORDINALE). Sauf dans le cas des types entiers (le rang d'un élément de type entier est la valeur de l'élément lui-même), la première valeur de tous les types scalaires est de rang 0, la suivante 1 et ainsi de suite.</p>
                            <p>Chaque valeur a un prédécesseur sauf la première et un successeur sauf la dernière (cfr ORD, PRED, SUCC).</p>
                            <p>Il existe des types simples scalaires standards (<span class="em">prédéclarés</span>) comme les types INTEGER, CHAR et BOOLEAN. D'autres doivent être <span class="em">déclarés</span> par l'utilisateur : ce sont les types énumérés et intervalle.</p>
                            <p>Tous les types scalaires partagent les propriétés suivantes :</p>
                            <p>Les fonctions standards <span class="html">low</span> et <span class="html">high</span> peuvent être appliquées à un tyê scalaire ou à une référence de variable d'un type scalaire. La fonction low renvoie la borne inférieure alors que la fonction high renvoie la borne sdupérieure de l'intervalle du type scalaire en question.</p>
                            <dl>
                                <dt>Ord, fonction</dt>
                                <dd>
                                    <p>Ord renvoie le rang d'une expression ordinale.</p>
                                    <p><span class="em">Unité :</span> System</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Ord(X):Longint;</p>
                                    <p><span class="em">Description :</span> La fonction Ord renvoie le rang d'une expression de type scalaire. X est une expression de type scalaire. Le résultat est de type Longint, sa valeur indiquant le rang de X.</p>
                                </dd>
                                <dt>Succ, fonction</dt>
                                <dd>
                                    <p>Succ renvoie le successeur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Succ(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le successeur de X.</p>
                                </dd>
                                <dt>Pred, fonction</dt>
                                <dd>
                                    <p>Pred renvoie le prédécesseur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Pred(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le prédécesseur de X.</p>
                                </dd>
                            </dl>
                        </li>
                        <li>
                            <h3>Les types réels :</h3>
                            <p>Classiquement, il n'existait en Pascal qu'un seul type réel : le type REAL.</p>
                            <p>Quelle définition nous en donne N.WIRTH ?</p>
                            <p>"Une valeur de type REAL est un élément du sous-ensemble des nombres réels que l'on peut représenter sur une machine donnée ...".</p>
                            <p>Actuellement, il existe six types réels fondamentaux : <span class="html">Real48</span>, <span class="html">Single</span>, <span class="html">Double</span>, <span class="html">Extended</span>, <span class="html">Comp</span> et <span class="html">Currency</span>... et un type réel générique : <span class="html">Real</span> (<span class="em">équivalent à Double</span>). À chacun de ces types réels correspond un intervalle et une précision spécifiques, indiqués dans le tableau ci-dessous (manuel de référence) :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Intervalle</th>
                                        <th>Chiffres significatifs</th>
                                        <th>Taille en octets</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Real48</td>
                                        <td>2.9 x 10<sup>-39</sup>..1.7 x 10<sup>38</sup></td>
                                        <td>11-12</td>
                                        <td>6</td>
                                    </tr>
                                    <tr>
                                        <td>Single</td>
                                        <td>1.5 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>7-8</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>Double</td>
                                        <td>5.0 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>15-16</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Extended</td>
                                        <td>3.4 x 10<sup>-4932</sup>..1.1 x 10<sup>4932</sup></td>
                                        <td>19-20</td>
                                        <td>10</td>
                                    </tr>
                                    <tr>
                                        <td>Comp</td>
                                        <td>-2<sup>63</sup>+1..2<sup>63</sup>-1</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Currency</td>
                                        <td>-922337203685477.5808..922337203685477.5807</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Le type Comp (Computational) est un entier de 64 bits qui contient les valeurs intégrales comprises entre -9 223 372 036 854 775 808 et 9 223 372 036 854 775 807 (-2<sup>63</sup> à 2<sup>63</sup>-1).</p>
                            <p>Le type Currency est un type de données à virgule fixe recommandé pour les calculs monétaires. Il est stocké en tant qu'entier scalaire de 64 bits avec les quatre chiffres les moins significatifs représentant implicitement qutre décimales. L'intervalle de valeurs de Currency est compris entre -922 337 203 685 477,5808 et 922 337 203 685 477,5807. Combinés avec d'autres types réels dans des affectations et des expressions, les valeurs de type Currency sont automatiquement graduées en divisant ou en multipliant par 10 000. Puisque les nombres stockés au format Currency sont des représentations exactes, les opérations sur les valeurs Currency ne sont pas sujettes à des erreurs d'arrondi.</p>
                            <p><span class="em">Remarque :</span> Le type Real48 qui correspond à l'ancien type Real est fourni pour assurer une compatibilité avec les versions précédentes de Pascal. Comme son format de stockage n'est pas natif dans la gamme CPU d'Intel, les opérations sur des valeurs de ce type sont plus lentes que d'autres types de calcul en virgule flottante. Les types Single, Double et Extended correspondent aux formats natifs des processeurs Intel Pentium, de précision simple, double et étendue.</p>
                            <p>Mathématiquement, le type réel comporte un nombre infini de valeurs. Dans tout ordinateur, cependant, une information de type réel est codée sur un nombre limité de bits. Entre deux valeurs de type réel, il n'existe pas toujours une valeur de type réel. L'arithmétique utilisée avec des valeurs de type réel peut conduire à des résultats légèrement faussés en raison des erreurs d'arrondi. Si les types entiers sont des types exacts, les types réels sont par essence des approximations ... et peuvent donc introduire des problèmes de précision et de portabilité. Les nombres réels sont représentés en notation à virgule flottante? Ils se composent d'une partie fractionnaire (la mantisse) que multiplie un exposant. Le nombre de chiffres significatifs de la mantisse et l'intervalle de valeurs possibles pour l'exposant déterminent l'intervalle et la précision du type réel.</p>
                            <p class="em">Remarque : Toutes les opérations arithmétiques sur des valeurs de type réel sont exécytées avec l'intervalle et la précision du type EXTENDED. Cette plus grande précision permet de réduire les erreurs d'arrondi, et la largeur de l'intervalle permet de réduire les risques de dépassements de capacité positifs et négatifs.</p>
                            <h4>Comparaison de réels :</h4>
                            <p>Du fait que les valeurs de type réel sont des approximations, les résultats de comparaisons de valeurs de types réels différents ne sont pas toujours conformes à l'attente.</p>
<pre><code>//...
var
    x : Single ;
    y : Double ;
    r : Real ;

begin
    x := 1 / 3 ;
    y := 1 /3 ;
    writeln(x : y) ;    // FALSE
    r := 1 / 3 ;
    writeln(r = 1 / 3) ;    // FALSE
    // ...
end.</code></pre>
                            <p>Le premier writeln affichera FALSE. Cette "inexactitude" vient de ce que la précision de x est de 7 à 8 chiffres, alors que celle de y est de 15 à 16 chiffres. Ainsi, lorsque ces deux valeurs sont converties en type extended, elles ne coïncident que sur 7 ou 8 chiffres. De la même manière, le deuxième writeln affichera FALSE puisque le résultat de 1/3 est calculé avec 20 chiffres significatifs.</p>
<pre><code>//...
var
    s : Single ; d : Double ; e : extended ;
begin
    s := 1 / 3 ; d := 1 / 3 ; e := 1 / 3 ;
    writeln(s : 20 : 17) ;  // 0.33333334326744080
    writeln(d : 20 : 17) ;  // 0.33333333333333331
    writeln(e : 20 : 17) ;  // 0.33333333333333333
    //...
end.</code></pre>
                            <h4>Opérations :</h4>
                            <p>Un certain nombre d'opérateurs arithmétiques binaires correspondent aux types réels.</p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Opérateurs</th>
                                        <th>Opérations</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>+</td>
                                        <td>addition réelle</td>
                                    </tr>
                                    <tr>
                                        <td>-</td>
                                        <td>soustraction réelle</td>
                                    </tr>
                                    <tr>
                                        <td>*</td>
                                        <td>multiplication réelle</td>
                                    </tr>
                                    <tr>
                                        <td>/</td>
                                        <td>division réelle</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="em">Il est à remarquer que pour l'addition, la soustraction et la multiplication réelle, il suffit qu'un des opérandes soit de type réel (l'autre pouvant être de type entier).</p>
                            <p class="em">Pour la division réelle (/), il est même permis que les deux opérandes soient de type entier; le résultat est évidemment toujours de type réel. Rappelons que le dénominateur doit être différent de zéro.</p>
                            <p>Comme pour le type entier, il existe deux opérateurs arithmétiques unaires : l'opérateur identité de signe (+) et l'opérateur inversion de signe (-).</p>
                            <p>-(-8.3) est équivalent à +8.3 ou 8.3.</p>
                            <p>Les opérateurs relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type réel; le type du résultat est évidemment booléen. Signalons pour terminer qu'un des opérandes peut être de type entier et l'autre d'un type réel.</p>
                        </li>
                        <li>
                            <h3>Types scalaires prédéclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Types entiers :</h4>
                                    <p>Pascal Objet distingue sept types fondamentaux (<span class="em">ne dépendant ni du processeur, ni du système d'exploitation</span>). Chacun d'eux représente un sous-ensemble particulier de valeurs entières.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format (en bits)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>SHORTINT</td>
                                                <td>-128..+127</td>
                                                <td>8 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>SMALLINT</td>
                                                <td>-32768..32767</td>
                                                <td>16 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGINT</td>
                                                <td>-2147483648..2147483647</td>
                                                <td>32 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>INT64</td>
                                                <td>-2<sup>63</sup>..2<sup>63</sup>-1</td>
                                                <td>64 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>BYTE</td>
                                                <td>0..255</td>
                                                <td>8 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>WORD</td>
                                                <td>0..65535</td>
                                                <td>16 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGWORD</td>
                                                <td>0..4294967295</td>
                                                <td>32 (non signé)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les types entiers génériques sont <span class="html">Integer</span> et <span class="html">Cardinal</span>. L'intervalle et le format sont ceux qui permettent les calculs entiers les plus rapides en tenant compte du processeur et du système d'exploitation sous-jacent.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-32768..32767</td>
                                                <td>16-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..65535</td>
                                                <td>16-bits non signé</td>
                                            </tr>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-2147483648..214743647</td>
                                                <td>32-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..4294967295</td>
                                                <td>32-bits non signé</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les propriétés de l'arithmétique ordinaire ne s'appliquent que dans la mesure où le résultat de l'opération reste dans le domaine, c'est-à-dore qu'il n'y ait pas de <span class="em">dépassement de capacité</span>. Cette restriction mise à part, toute opération sur des données entières est exacte.</p>
                                    <p>Les opérateurs suivants s'appliquent à des opérandes de type entier et produisent un résultat entier.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateurs</th>
                                                <th>Opérations</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>+</td>
                                                <td>addition entière</td>
                                            </tr>
                                            <tr>
                                                <td>-</td>
                                                <td>soustraction entière</td>
                                            </tr>
                                            <tr>
                                                <td>*</td>
                                                <td>multiplication entière</td>
                                            </tr>
                                            <tr>
                                                <td>DIV</td>
                                                <td>division entière</td>
                                            </tr>
                                            <tr>
                                                <td>MOD</td>
                                                <td>modulo (reste de la division entière)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les opérateurs DIV et MOD exigent que le second opérande soit différent de zéro.</p>
                                    <p>Les opérateur relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type entier; le type du résultat est évidemment booléen.</p>
                                    <p>Il existe également des opérations logiques qui s'appliquent à des entiers pour donner des entiers. Ces "entiers" doivent cependant s'interpréter comme des <span class="em">chaînes de bits</span>.</p>
                                    <p>Les opérations <span class="em">I shl J</span> et <span class="em">I shr J</span> décalent la valeur I de J bits vers la gauche pour shl, et vers la droite pour shr. Le résultat est du même type entier que I.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Types des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not</td>
                                                <td>négation binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shl</td>
                                                <td>décalage à gauche binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shr</td>
                                                <td>décalage à droite binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                        </tbody>
                                    </table>
<pre><code>program TestBin;
{$APPTYPE CONSOLE}

const ZERO : Cardinal = 0 ;
var  masque , x : Cardinal ;

begin
        write('valeur positive : ') ;
        readLn(x) ;

        masque := not(not ZERO shr 1) ;
        repeat
                if (x and masque) &lt;&gt; ZERO
                    then write('1')
                    else write('0')
                {fi} ;
                masque := masque shr 1
        until masque = ZERO ;
        writeLn   ;
        readLn
end.</code></pre>
                                    <img src="../images/TestBin.png" alt="">
                                </li>
                                <li>
                                    <h4>Type CHAR :</h4>
                                    <p>Le type CHAR comprend l'ensemble des caractères disponibles. Malheureusement il n'existe pas d'ensemble de caractères qui soit accepté par tous les ordinateurs. La définition du Pascal standard ne donne donc que des conventions générales.</p>
                                    <p>Ainsi, l'ordre des caractères doit préserver l'ordre alphabétique des lettres et l'ordre numérique des chiffres : <span class="em">'a' &lt; 'b'</span> et <span class="em">'0' &lt; '9'</span>.</p>
                                    <p>Les valeurs de type CHAR sont pourvues d'un nombre ordinal qui est un entier non négatif et qui traduit le rang de chaque caractère. L'implémentation qui est la nôtre a été décrite au chapitre 3. Le caract!re 'A' y possède le numéro d'ordre 65, 'B' 66, ... 'a' 95 et 'b' 96 ...</p>
                                    <p>Les opérateurs relationnels s'appliquent à des opérandes de type CHAR. Dans notre environnement, l'expression (<span class="em">'A' &lt; 'a'</span>) a la valeur TRUE.</p>
                                    <p>Toutes ces propriétés nous rappellent bien que le type de caracyère générique.</p>
                                    <p>Les types de caractères fondamentaux sont AnsiChar et WideChar.</p>
                                    <p>Les valeurs du type AnsiChar sont les caractères (en octets), rangés dans l'ordre du jeu de caractères ANSI étendu.</p>
                                    <p>Les valeurs du type WideChar sont les caractères (en mots), rangés dans l'ordre du jeu Unicode. Les 256 premiers caractères du jeu Unicode correspondent aux caractères ANSI.</p>
                                </li>
                                <li>
                                    <h4>Type BOOLEAN :</h4>
                                    <p>Une valeur booléenne est une des valeurs logiques "vrai" ou "faux" que l'on notera par les identificateurs de constantes prédéfinis TRUE et FALSE.</p>
                                    <p>Les opérateurs booléens sont :</p>
                                    <ul>
                                        <li>
                                            <p>la conjonction logique (AND)</p>
                                        </li>
                                        <li>
                                            <p>la disjonction logique (OR)</p>
                                        </li>
                                        <li>
                                            <p>la négation (NOT)</p>
                                        </li>
                                        <li>
                                            <p>le Pascal Objet ajoute l'opérateur XOR qui correspond au <span class="em">ou exclusif logique</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Ces opérateurs "opèrent" entre variables, constantes et expressions de types booléens.</p>
                                    <h5>Opérations booléennes :</h5>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Type des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not (unaire)</td>
                                                <td>négation logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Si p et q sont des variables booléennes, on a :</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>p</th>
                                                <th>q</th>
                                                <th>p AND q</th>
                                                <th>p OR q</th>
                                                <th>p XOR q</th>
                                                <th>NOT p</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les autres fonctions logiques (il y en a seize en tout !) peuvent être construites grâce aux opérateurs de relation.</p>
                                    <h5>Lois de de Morgan :</h5>
                                    <p>Les lois de de Morgan sont souvent très utiles si l'on désire, par exemple, passer d'une condition de continuation à la condition de terminaison inverse.</p>
                                    <p>NOT (p OR q) = NOT p AND NOT q</p>
                                    <p>NOT (p AND q) = NOT p OR NOT q</p>
                                    <p>Exemple : le complémentaire de l'expression booléenne <span class="em">(x &gt;= 15) OR (y &lt; 4)</span> est <span class="em">(x &lt; 15) AND (y &gt;= 4)</span>.</p>
                                    <p>Le type booléen est ordonné; il est en effet prédéfini de façon à ce que FALSE &lt; TRUE. AU niveau format interne des données, un type booléen est stocké comme un octet qui peut prendre la valeur 0 (FALSE) et 1 (TRUE).</p>
                                    <p>En fait, le type booléen est un type énuméré.</p>
                                    <p>Comme le type booléen est un type scalaire ordonné, nous pouvons définir simplement toutes les fonctions logiques.</p>
                                    <p>Si p et q sont deux booléens :</p>
                                    <p>p &lt;= q définit l'implication</p>
                                    <p>p = q définit l'équivalence</p>
                                    <p>p &lt;&gt; q définit le ou exclusif</p>
                                    <h5>Entrées-Sorties :</h5>
                                    <p>S'il est possible d'imprimer une valeur booléenne, il est par contre impossible de lire <span class="em">directement</span> un booléen !</p>
<pre><code>program TestBool;
{$APPTYPE CONSOLE}

var nbre1, nbre2 : Integer ;
    croissant    : Boolean ;
begin
        write(' Entrez deux entiers : ') ;
        readLn(nbre1,nbre2) ;
        croissant := nbre1 &lt;= nbre2 ;
        writeln('ordre croissant : ', croissant) ;

        readLn
end.</code></pre>
                                    <img src="../images/TestBool.png" alt="">
                                    <p>Remarques : l'instruction test := Nbre1 &lt; Nbre2 est péférable à l'instruction conditionnelle :</p>
<pre><code>if Nbre1  &lt;=  Nbre2
    then test := true
    else test := false
{fi}</code></pre>
                                    <p>Signalons enfin que les types ByteBool, WordBool et LongBool existent pour proposer une compatibilité avec l'environnement Windows et certains langages.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Types scalaires déclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Type énuméré :</h4>
                                    <p>Nous pouvons définir un nouveau type simple en énumérant toutes les valeurs distinctes qui le composent. Les valeurs de ce nouveau type sont représentées par des identificateurs et sont donc des constantes du nouveau type.</p>
                                    <p>La définition d'un type énuméré de la forme :</p>
<pre><code>Type enum = (c1,c2,...,cn) ;</code></pre>
                                    <ul>
                                        <li>
                                            <p><span class="em">enum</span> est l'identificateur du nouveau type.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">c1,c2,...,cn</span> sont les nouveaux identificateurs de constantes.</p>
                                        </li>
                                    </ul>
                                    <p>Exemples :</p>
<pre><code>Type Tcouleur = (BLEU,JAUNE,VERT,ROUGE) ;
     Tjour = (LU,MA,ME,JE,VE,SA,DI) ;
     TAssaisonnement = (HUILE,VINAIGRE,SEL,POIVRE) ;
     Tchoix = (AM,STRAM,GRAM) ;
     Tnote = (UT,RE,MI,FA,SOL,LA,SI) ;</code></pre>
                                    <p>La définition de chacun de ces types introduit :</p>
                                    <ul>
                                        <li>
                                            <p>un nouvel identificateur de type (<span class="em">TChoix</span> par ex.)</p>
                                        </li>
                                        <li>
                                            <p>l'ensemble des identificateurs dénotant les valeurs de ce nouveau type (AM,STRAM,GRAM).</p>
                                        </li>
                                    </ul>
                                    <p>Nous pouvons dès lors utiliser ces identificateurs comme des constantes.</p>
                                    <p>Les identificateurs qui dénotent les valeurs d'un nouveau type correspondent à des constantes et s'utilisent comme telles. Il convient évidemment de ne déclarer une constante que dans une seule déclaration de type. Ainsi, les déclarations suivantes sont <span class="em">erronées</span> :</p>
<pre><code>Type Fruit = (pomme,orange,pore) ;
     Color = (bleu,rouge,orange) ;</code></pre>
                                    <p>Suppons les déclarations de variables suivantes :</p>
<pre><code>var col1, col2 : TCouleur;
    ch : TChoix;
    n : TNote;</code></pre>
                                    <p>nous pouvons écrire :</p>
<pre><code>col1 := ROUGE ;  // col1 := TCouleur(3) ;
col2 := VERT ;  // col2 := TCouleur(2) ;
n := FA ;   // n := TNote(3) ;
ch := GRAM ;    // ch := TChoix(2) ;</code></pre>
                                    <p>Comme dans tout type scalaire, il existe un ordre; cet ordre est déterminé par l'ordre d'écriture des identificateurs de constantes dans la déclarative.</p>
<pre><code>BLEU &lt; JAUNE &lt; VERT &lt; ROUGE</code></pre>
                                    <h5>Format interne des données :</h5>
                                    <p>Les scalaires énumérés ayant moins de 256 valeurs possibles sont rangés dans un seul octet (sinon deux). Cet octet contient la valeur ordinale de la variable; la valeur ordinale correspond au rang. Le rang d'une constante énumérée est déterminé par sa position dans la séquence d'énumération, la première constante ayant le rang 0. Aussi le rang (valeur ordinale) de <span class="em">jaune</span> est <span class="em">1</span> et celui de <span class="em">rouge</span> est <span class="em">3</span>.</p>
                                    <p>Une variable de type <span class="em">TCouleur</span> (exemple <span class="em">col1</span>) pourra prendre une des quatre valeurs : BLEU, JAUNE, VERT ou ROUGE. Le domaine du type <span class="em">TCouleur</span> correspond bien à un ensemble fini et ordonné (type SCALAIRE).</p>
                                    <p>Les opérateurs relationnels (=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=) peuvent s'appliquer à tous les types énumérés tant que les deux opérandes sont de même type.</p>
                                    <p><span class="em">(col1 &lt;= col2)</span> est une expression booléenne.</p>
                                    <p><span class="em">Remarque : À propos de booléen, signalons que le type boolean est en fait un type énuméré prédéclaré : <span class="html">Type boolean = (false,true)</span></span>.</p>
                                    <p>Les fonctions standards comme ORD, PRED, SUCC peuvent être utilisées avec des arguments de type scalaire et donc énuméré.</p>
                                    <p>Les variables de type énuméré pourront également être utilisées comme compteur de boucle ou sélecteurs de cas.</p>
                                    <p>Les variables et les valeurs d'un type énuméré ne sont pas acceptées par writeln, read et readln...</p>
                                    <p>Les langages de programmation qui permettent la définition de types énumérés nous offrent un mécanisme simple d'ABSTRACTION; il contient de les utiliser toutes les fois où cela est possible. D'une part, cela augmente la lisibilité de vos programmes, d'autre part cela renforce le typage de vos données. Un typage sévère assure que chaque objet a un ensemble bien défini de valeurs et qu'un ensemble bien défini d'opérations s'applique à ces objets : cela empêche les confusions entre des concepts logiquement différents.</p>
                                    <p>Dans des langages plus anciens, il est souvent nécessaire d'implémenter des concepts comme les types énumérés à l'aide de types plus primitifs tels que les entiers et de donner des valeurs telles 0, 1, 2 et 3 à des vakeurs comme bleu, jaune, vert et rouge. Des affectations accidentelles comme col1 := col2 + 10 ne peuvent alors être détectées par le compilateur (il y a pourtant une double erreur : au niveau de l'oépration + et au niveau du domaine des valeurs).</p>
                                </li>
                                <li>
                                    <h4>Type intervalle :</h4>
                                    <p>On constate souvent qu'une variable doit prendre ses valeurs dans un intervalle de valeurs bien déterminé. Il est alors intéressant de définir un nouveau type (sous-type), caractérisé par un ensemble de valeurs qui est un sous-ensemble de valeurs d'un autre type de base, type associé ou type hôte.</p>
                                    <p>Un type de données peuvent être défini comme un intervalle d'un autre type scalaire déjà défini. Cette définition donne la plus petite et la plus grande valeur de l'intervalle. La première constante spécifie la borne inférieure et ne dois pas être plus grande que la deuxième constante, la borne supérieure (ces deux constantes sont du même type scalaire).</p>
                                    <p>Un type intervalle conserve toutes les priorités du type scalaire associé; il n'y a aucun moyen de restreindre l'ensemble des opérations du type de base ! Il n'est restreint que dans l'échelle de ses valeurs; c'est pourquoi on peut parler de <span class="em">sous-type</span>.</p>
                                    <p>Exemples :</p>
<pre><code>type TJour = (LU,MA,ME,JE,VE,SA,DI) ;
     THeure = 0..60 ;
     TMajuscule = 'A'..'Z' ;
     Travail = LU..VE ;</code></pre>
                                    <p>Le type Travail est un sous-type du type TJour qui doit être défini préalablement.</p>
                                    <p>Si nous déclarons <span class="em">var h : THeure ;</span>, l'affectation <span class="em">h := 15</span> est correcte alors que <span class="em">h := 90</span> ne l'est pas.</p>
                                    <p>Pascal permet lors de la déclaration de variables, l'utilisation de descripteurs de type à la place d'identificateurs de type :</p>
<pre><code>var x : 17..87 ;</code></pre>
                                    <p>plutôt que :</p>
<pre><code>type TInter = 17..87 ;
var x : TInter ;</code></pre>
                                    <p>Nous vous déconseillons un tel raccourci, et même nous vous conseillons la forme déclaratice suivante :</p>
<pre><code>const MAX = 87 ;
      MIN = 17 ;
type TInter = MIN..MAX ;
var x : TInter ;</code></pre>
                                    <p class="em">Remarques : Supposons les déclarations de variables suivantes :</p>
<pre><code>var x : TInter ;
    y : Integer ;</code></pre>
                                    <p class="em">Nous l'avons signalé, une affectation tel que <span class="html">x := 15000</span> est incorrecte; elle sera décelée par le compilateur : il s'agit d'un <span class="html">CONTRÔLE STTAIQUE</span> c'est-à-dire liké au texte.</p>
                                    <p class="em">Par contre l'affectation <span class="html">x := y</span> est parfaitement légale du point de vue syntaxique. Bien sûr, à l'exécution, la valeur de la variable y peut être ou non dans l'intervalle MIN..MAX. Si cette valeur y est comprise, tout va bien; sinon une erreur doit être signalée. Il s'agit alors d'un <span class="html">CONTRÔLE DYNAMIQUE</span> c'est-à-dire lié à l'exécution. L'affectation <span class="html">y := x</span> marchera évidemment toujours.</p>
                                    <p class="em">Pascal Objet n'introduit pas <span class="html">automatiquement</span> des tests de validité à l'exécution. Il convient, pour ce faire, d'activer la vérification des limites.</p>
                                    <q class="em">Une déclaration de type intervalle n'introduit pas vraiment de nouveau type mais plutôt un sous-type, c'est-à-dire un sous-ensemble défini au moyen d'une constrainte (la restriction ne s'appliquant qu'aux valeurs).</q>
                                    <p class="em">Le rang de chaque valeur d'un intervalle est celui qu'elle a dans le type de base.</p>
                                    <img src="../images/type_intervalle_Pascal.png" alt="">
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Procédures et fonctions standards :</h3>
                            <p>Vous connaissez déjà des procédires prédéclarées comme write et writeln.</p>
                            <p>Pascal Objet propose les procédures de décrémentation (dec) et d'incrémentation (inc).</p>
                            <p>Si x est une variable de type scalaire et n une expression facultative de type entier alors :</p>
                            <ul>
                                <li>
                                    <p>dec(x) correspond à l'instruction x := x - 1</p>
                                </li>
                                <li>
                                    <p>dec(x,n) correspond à l'instruction x := x - n</p>
                                </li>
                                <li>
                                    <p>inc(x) correspond à l'instruction x := x + 1</p>
                                </li>
                                <li>
                                    <p>inc(x,n) correspond à l'instruction x := x + n</p>
                                </li>
                            </ul>
                            <p>Les procédures dec et inc génèrent un code optimisé.</p>
                            <p>Une foncion est un sous-prgramme qui renvoie une valeur; d'un point de vue syntaxique et sémantique, une fonction correspond à une expression.</p>
                            <p>Il existe ainsi une série de fonctions mathématiques prédéfinies qui facilitent la programmation en Pascal :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Fonction</th>
                                        <th>Valeur</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>abs(x)</td>
                                        <td>valeur absolue de x</td>
                                    </tr>
                                    <tr>
                                        <td>arcTan(x)</td>
                                        <td>arc dont la tangente est x</td>
                                    </tr>
                                    <tr>
                                        <td>cos(x)</td>
                                        <td>cosinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>exp(x)</td>
                                        <td>exponentielle de x : e<sup>x</sup></td>
                                    </tr>
                                    <tr>
                                        <td>frac(x)</td>
                                        <td>partie fractionnaire de x</td>
                                    </tr>
                                    <tr>
                                        <td>int(x)</td>
                                        <td>partie entière de x</td>
                                    </tr>
                                    <tr>
                                        <td>ln(x)</td>
                                        <td>logarithme naturel de x</td>
                                    </tr>
                                    <tr>
                                        <td>pi</td>
                                        <ts>valeur de pi</ts>
                                    </tr>
                                    <tr>
                                        <td>sin(x)</td>
                                        <td>sinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqr(x)</td>
                                        <td>carré de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqrt(x)</td>
                                        <td>racine carrée de x</td>
                                    </tr>
                                </tbody>
                            </table>
<pre><code>program TestFonctionsArithmetiques ;
{$APPTYPE CONSOLE}

var r : Real ;
    i : Integer ;

begin
    i := abs(-123) ;
    r := sqr(12.3) ;
    writeln(i) ;               	{123}
    writeln(r:8:4) ;	 		{151.2900}
    writeln(sqrt(r):8:4) ;	 	{ 12.3000}

    readLn
end.</code></pre>
                        </li>
                        <li>
                            <h3>Règles de priorité :</h3>
                            <p>Une expression est une phrase de programme spécifiant un calcul sur un ou des opérandes et dont l'exécution produit un résultat. Telle que nous l'envisageons ici, une expression renvoie une valeur.</p>
                            <p>Dans l'évaluation d'une expression où interviennent plusieurs opérateurs, il convient d'éliminer toute ambiguïté dans l'ordre de réalisation des opérations. Chaque langage définit pour ce faire certaines règles et associé à chaque opérateur une priorité.</p>
                            <p>Le langage Pascak divise l'ensemble des opérateurs en catégories hiérarchiques (du plus prioritaire au moins prioritaire) :</p>
                            <ul>
                                <li>
                                    <p>le moins unaire</p>
                                </li>
                                <li>
                                    <p>les opérateurs not, @</p>
                                </li>
                                <li>
                                    <p>les opérateurs multiplificatifs (*, /, DIV, MOD, AND, SHL, SHR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs additifs (+, -, OR, XOR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs relatinnels (=, &lt;&gt;, &lt;=, &gt;=, &lt;, &gt;, IN, IS ...)</p>
                                </li>
                            </ul>
                            <p>Considérons un opérande entre deux opérateurs :</p>
                            <ul>
                                <li>
                                    <p>Si les opérateurs sont de même priorité, l'opérande sera liée à l'opérateur de gauche sinon au plus prioritaire.</p>
<pre><code>2 + x * 4 &lt;=&gt; 2 + (x * 4) { * plus prioritaire }
3 * x /2 &lt;=&gt; (3 * x) / 2 { même priorité =&gt; opérateur de gauche }</code></pre>
                                </li>
                                <li>
                                    <p>Afin de traiter leur résultat comme un seul opérande, les expressions contenues entre parenthèses sont évaluées en premier lieu. Nous vous conseillons d'utiliser les parenthèses.</p>
                                    <p>Exemple :</p>
                                    <p>Si on attribue respectivement aux variables entières a, b et c les valeurs 8, 15 et -4, comment sera évaluée l'expression numérique suivante :</p>
<pre><code>2 * ((a mod 5) * (4 + (b -3) / sqr (c + 2)))</code></pre>
                                    <img src="../images/regles_priorites_Pascal.png" alt="">
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="instructions_structurees">Instructions structurées :</h2>
                    <p class="em">Nous allons au cours de ce chapitre étudier deux nouvelles instructions structurées : l'instruction "FOR" qui est une répétitive et l'instruction "CASE" qui est une conditionnelle particulière.</p>
                    <ul>
                        <li>
                            <p>L'instruction IF dans le choix entre deux éventualités selon la valeur booléenne d'une expression. L'instruction CASE, ou instruction de sélection, permet de choisir entre n éventualités selon la valeur discrète d'une expression appelée expression de sélection. Cette instruction permettra donc à votre programme d'effectuer - sous certaines conditions - un choix parmi plusieurs possibilités sans devoir employer des quantités d'instructions IF.</p>
                        </li>
                        <li>
                            <p>L'instruction FOR s'utilisera lorsque l'on désirera lorsque l'on désirera un certain traitement un nombre précis de fois.</p>
                        </li>
                    </ul>
                    <p>Ces deux instructions ont en commun le fait qu'elles sont à la fois limitées et puissantes.</p>
                    <p>Une autre caractéristique commune est le fait qu'elles ne sont pas "standardisées". D'un langage algorithmique à l'autre et même parfois d'une implémentation à l'autre d'un même langage, des variantes significatives existent.</p>
                    <p>Proposer dans ce cas une forme générale de ces instructions en L.D.A est difficile. Tout au plus, pouvons-nous proposer une traduction L.D.A des instructions "CASE" et "FOR" Pascal !</p>
                    <p>Par exemple :</p>
<pre><code>cas où (expression de sélection) vaut
    v1 : traitement1
    v2 : traitement2
    ... : ...
    autres cas : traitementN
fincas

pour Vc allant de Vi à Vf par pas de +1 faire
    traitement
fpour</code></pre>
                    <p>Avant de passer à l'étude détaillée de ces deux instructions, il peut être intéressant de signaler qu'il existe dans certains langages une instruction de sélection généralisée sans sélecteur que l'on nomme choix multiple.</p>
                    <p>La forme L.D.A du choix multiple pourrait être la suivante :</p>
<pre><code>cas où
        condition1 : traitement1
        condition2 : traitement2
        ...
        autre cas : traitementN
fincas</code></pre>
                    <p>Dans un choix multiple, les conditions sont mutuellement exclusives. Cette instruction peut être facilement simulée en Pascal :</p>
<pre><code>if expr1
    then instruction1
    else
        if expr2
            then instruction2
            else
                if expr3
                    then instruction3
                    else instructionN</code></pre>
                    <p>Pour éviter une cascade inutile de tests, on a tout intérêt à ordonner les tests dans le sens des probabilités décroissantes. Il n'y a, de plus, aucune raison d'imbriquer les instructions...</p>
<pre><code>if expr1 then instruction1
else if expr2   then instruction2
else if expr3   then instruction3
else    instructionN</code></pre>
                    <ol>
                        <li>
                            <h3>Instruction CASE :</h3>
                            <p>L'instruction CASE est utilisée pour choisir une action parmi plusieurs suivant la valeur d'une expression.</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_CASE_Pascal.png" alt="">
                            <p>Exemples :</p>
<pre><code>...
case abs(k) of
    0 : p := 0 ;
    1..5,7 : begin
                p := m - 1
                m := 0
             end ;
    else{case} p := m + 1
end{case}
...</code></pre>
<pre><code>case caract of
    'a', 'e', 'i', 'o', 'u', 'y' : writeln('voyelle minuscule') ;
    'A', 'E', 'I', 'O', 'U', 'Y' : writeln('voyelle majuscule') ;
    'b'..'d', 'f'..'h', 'j'..'n', 'p'..'t', 'v'..'x', 'z' : writeln('consonnes minuscules') ;
    'B'..'D', 'F'..'H', 'J'..'N', 'P'..'T', 'V'..'X', 'Z' : writeln('consonnes majuscules') ;
    '0'..'9' : writeln('chiffres')
    else{case} writeln('autres caractères ...')
end{case} ;
...</code></pre>
                            <h4>Sémantique :</h4>
                            <p>L'exécution de cette instruction conditionnelle commence par celle de l'expression de sélection qui produit une valeur V d'un type scalaire. Le choix de la liste de choix qui contient cette valeur V parmi les sélecteurs de sa liste de sélecteurs est sélectionné et l'action correspondante est exécutée.</p>
                            <p>Les sélecteurs sont aussi appelés étiquettes de cas ou encore constantes de cas; ces sélecteurs sont en effet des constantes.</p>
                            <p>Ils doivent être <span class="em">uniques</span> et d'un type scalaire compatible avec le type de l'expression de sélection. <span class="em">Dans les réalisations anciennes, Pascal Objet imposait que l'expression de sélection soit d'un type scalaire dont les bornes étaient comprises entre certaines valeurs (-32768 et 32767).</span></p>
                            <p>Que se passe-t-il si aucun des sélecteurs ne correspond à la valeur de sélection ?</p>
                            <ul>
                                <li>
                                    <p>Si la partie ELSE (autre choix) est présente, l'instruction correspondante est exécutée,</p>
                                </li>
                                <li>
                                    <p>sinon aucune instruction n'est exécutée et le traitement se poursuit par l'exécution de l'instruction (si elle existe) qui suit l'instruction CASE.</p>
                                </li>
                            </ul>
                            <p class="em">Remarques :</p>
                            <ul>
                                <li>
                                    <p class="em">En Pascal, l'instruction case possède cependant certains défauts. En absence d'une clause else, le fait qu'aucune des constantes de cas ne soit égale à la valeur de l'expression de sélection devrait constituer une ereeur.</p>
                                </li>
                                <li>
                                    <p class="em">Autre remarque qui est une constation : le else d'une instruction case peut être précédé d'un point-virgule (;) et le délimiteur final d'une construction case est le mot réservé end (auquel ne correspond aucun begin !).</p>
                                </li>
                                <li>
                                    <p class="em">Pour les différencier de leurs autres utilisations, il peut être utile d'ajouter un commentaire à ces mots réservés (cfr exemple ci-dessus else{case} et end{case}).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Instruction FOR :</h3>
                            <p>L'instruction for indique qu'une instruction (le corps de la répétitive) doit être exécutée un nombre précis de fois, pendant qu'une variable de contrôle progresse au sein d'une intervalle de valeurs discrètes.</p>
                            <p>La variable de contrôle progresse donc entre deux valeurs fixées : la valeur initiale et la valeur finale, et cette progression est soit ascendante (TO), soit descendante (DOWNTO).</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_FOR_Pascal.png" alt="">
                            <p>L'emploi du mot réservé to provoque l'incrémentation d'une unité à la fois de la variable de contrôle à chaque tour de boucle, alors que l'emploi de downto en provoque la décrémentation.</p>
                            <p>L'instruction n'est pas exécutée si, en utilisant la clause to, la valeur initiale est strictement supérieure à la valeur finale ou si, en utilisant la clause downto, la valeur initiale est strictement inférieure à la valeur finale.</p>
                            <p>La variable de contrôle est une variable (<span class="em">déclarée dans le bloc contenant l'instruction for</span>) de type scalaire et les valeurs initiales et finales sont des expressions de type compatible avec la variable de contrôle.</p>
                            <p>L'instruction suivante provoquera l'affichage des valeurs de 1 à 10 :</p>
<pre><code>for compteur := 1 to 10 do write(compteur:4)</code></pre>
                            <p>Celle-ci lit n entiers et effectue leur somme :</p>
<pre><code>somme := 0 ;
for compteur := 1 to n do
    begin
        readln(nbre) ;
        somme := somme + nbre
    end ;
...</code></pre>
                            <p>Voici, comme dernier exemple un programme dont l'exécution provoquera l'affichage des jours de la semaine.</p>
<pre><code>program AfficherJourSemaine ;
{$APPTYPE CONSOLE}

type TJour = (LU,MA,ME,JE,VE,SA,DI) ;

var j : TJour ;

begin
    for j := LU TO DI DO
    case j of
        LU : writeln('lundi') ;
        MA : writeln('mardi') ;
        ME : writeln('mercredi') ;
        JE : writeln('jeudi') ;
        VE : writeln('vendredi') ;
        SA : writeln('samedi');
        DI : writeln('dimanche')
    end{case}  ;

    readLn
end.</code></pre>
                            <p>Dans de nombreux ouvrages, on retrouve l'assertion suivant laquelle l'instruction :</p>
<pre><code>for indice := expr1 to expr2 do instruction</code></pre>
                            <p>est équivalente aux instructions suivantes :</p>
<pre><code>indice := expr1 ;
while indice &lt;= expr2 do
    begin
        instruction ;
        inc(indice)
    end</code></pre>
                            <p>Il convient de relativiser cette "équivalence".</p>
                            <p>La définition du langage Pascal impose certaines restrictions au sujet de l'instruction FOR :</p>
                            <ul>
                                <li>
                                    <p>La valeur de la variable de contrôle ne peut en aucun cas être modifiée dans l'instruction qui correspond au corps de la boucle (<span class="em">Pascal Objet permet la modification de la variable de contrôle dans le corps de la boucle ! Ne profitez pas de ce laxisme coupable !</span>).</p>
                                </li>
                                <li>
                                    <p>La valeur finale est déterminée une seule fois lors de l'entrée dans la boucle for. Ainsi si expr2 correspondait à la valeur d'une certaine variable Vf, la modification de la valeur de Vf dans le corps de la boucle ne changerait pas le nombre de répétitions.</p>
                                </li>
                                <li>
                                    <p>À la sortie (normale) de l'instruction for, la valeur de la variable de contrôle est indéfinie.</p>
                                </li>
                            </ul>
                            <p>Dans le manuel de référence, l'instruction <span class="em">for v:= expr1 to expr2 do Corps</span> est dite équivalente à :</p>
<pre><code>begin
    temp1 := expr1 ;
    temp2 := expr2 ;
    if temp1 &lt;= temp2 then
        begin
            V := temp1 ;
            Corps ;
            while V &lt;&gt; temp2 do
                begin
                    V := succ(V) ;
                    Corps
                end
        end
end</code></pre>
                            <p>temp1 et temp2 sont des variables temporaires du même type que la variable de contrôle V et qui n'apparaissent nulle part ailleurs dans le programme.</p>
                            <p>Cette équivalence est <span class="em">logique</span> et l'utilisation du for générera un <span class="em">code optimisé</span> !</p>
                            <p>Application :</p>
                            <ul>
                                <li>
                                    <p>Justifiez cette équivalence.</p>
                                </li>
                                <li>
                                    <p>Réécrire les programmes du chapitre 4 où l'utilisation de l'instruction for est souhaitable.</p>
                                </li>
                            </ul>
                            <p class="em">Remarque : Curieusement, à partir de la version du Pascal Objet qui correspond à Delphi 4, la réalisation du for a changé et l'équivalence présentée ici a disparu du manuel de référence. La valeur non significative de la variable de contrôle est "égale" à succ(temp2) si l'itération a eu lieu !</p>
                            <p>Exercices :</p>
<pre><code>program WhileFor;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 31 ;
    EXPR2 : Cardinal = 39 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;

    EXPR2 := 39 ;
    k := EXPR1 ;
    while k &lt;= EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2) ;
            inc(k)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;
    readLn
end.</code></pre>
                            <img src="../images/WhileFor_Pascal.png" alt="">
<pre><code>program breakContinue;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 1 ;
    EXPR2 : Cardinal = 9 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then continue ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4)
    end ;
    writeLn ;

    k := EXPR1 ;
    while k &lt;= EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then
        begin
            inc(k) ;     // sinon vous bouclez !!!
            continue
        end  ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4) ;
        inc(k)
    end ;
    writeLn ;

    readLn
end.</code></pre>
                            <img src="../images/breakContinue_Pascal.png" alt="">
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="type_string">Type string (chaînes courtes) :</h2>
                    <p>Il existe aujourd'hui plusieurs types chaîne.</p>
                    <p>Sans parler des chaînes à zéro terminal, le Pascal Objet gère les types chaînes prédéfinis suivants (<span class="em">manuel de référence</span>) :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Longueur maximum</th>
                                <th>Mémoire nécessaire</th>
                                <th>Utilisation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ShortString</td>
                                <td>255 caractères</td>
                                <td>de 2 à 256 octets</td>
                                <td>string classique</td>
                            </tr>
                            <tr>
                                <td>AnsiString</td>
                                <td>~2<sup>31</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères sur 8 bits</td>
                            </tr>
                            <tr>
                                <td>WideString</td>
                                <td>~2<sup>30</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères Unicode;</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Nous nous intéresserons dans ce chapitre au type <span class="em">string classique</span> qui correspond dans les dernières versions du langage aux chaînes courtes (ShortString). <span class="em">Dans l'état par défaut {$H+}, le compilateur interprète <span class="html">string</span> comme désignant AnsiString. Utilisez la directive <span class="html">{$H-}</span> pour que string soit interprété comme désignant ShortString.</span></p>
                    <p>Nous reviendrons plus tard aux autres types chaînes et, spécialement, aux chaînes longues qui est <q>le type le mieux adapté aux utilisations les plus diverses</q>.</p>
                    <p>Une valeur de type string ou chaînes de caractères est une séquence de caractères de taille variable. Le nombre réel de caractères dans une chaîne peut varier dynamiquement - au cours de l'exécution -, entre 0 et une limite supérieure définie.</p>
                    <p>Les constantes chaînes de caractères sont évidemment compatibles avec les types chaînes de caractères.</p>
                    <ol>
                        <li>
                            <h3>Définition d'un type chaîne de caractères :</h3>
<pre><code>&lt;identificateur&gt; = string [E]</code></pre>
                            <p>L'entier <span class="em">E</span> spécifiant la taille maximale est une constante entière tel que <span class="em">1 &lt;= E &lt; 255</span>.</p>
                            <p>Mprsque l'attribut de taille n'est pas déclaré, il vaut 255 par défaut.</p>
                            <p>Exemple :</p>
<pre><code>type str20 = STRING[20];
     str8 = STRING[8]
     ligne = STRING[80];
     AnyString = STRING;</code></pre>
                            <p>Seules les variables possèdent un type string spécifique, pas les valeurs.</p>
                            <p>Soient les déclarations suivantes :</p>
<pre><code>var ch1 : str8;
    ch2 : str20;
    ch : AnyString;</code></pre>
                            <p>L'exécution de ces déclarations réservera 9 octets pour <span class="em">ch1</span>, 21 pour <span class="em">ch2</span> et 256 octets pour <span class="em">ch</span>. Une chaîne de caractères occupe en effet un octet de plus que son nombre de caractères maximum. Le premier octet contient le caractère dont le rang équivaut à la longueur courante de la chaîne.</p>
                            <p>Lors de l'affectation de la valeur d'une expression chaîne à une variable d'un certain type string, si la longueur maximum de la variable chaîne est dépassée, les caractères en trop sont éliminés.</p>
                            <p>Exemple :</p>
<pre><code>...
ch2 := 'BONJOUR MONDE !';
ch1 := ch2;
writeln(ch2);   {BONJOUR MONDE !}
writeln(ch1);   {BONJOUR}</code></pre>
                            <p class="em">Remarquez :</p>
                            <ul>
                                <li>
                                    <p class="em">que les types chaînes de caractères sont compatibles (puisque ch2 est une valeur chaîne) :</p>
<pre><code>ch1 := ch2</code></pre>
                                </li>
                                <li>
                                    <p class="em">et que l'on peut écrire une expression chaîne et lire une variable chaîne.</p>
<pre><code>...
write('Entre votre nom : ');
readln(ch);
writeln('Bonjour ', ch);
...</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Comment accéder aux éléménts d'une chaîne ?</h3>
                            <p>Nous n'avons pas encore étudié le type tableau. Signalons néanmoins que le type chaîne peut être assimilé à un type tableau possédant des caractéristiques spéciales.</p>
                            <p>Une variable d'un type chaîne pourrait être considérée comme une suite, une liste finie de variables char que l'on aurait regroupées sous un nom. Les éléments de cette liste sont rangés en des positions mémoire successives et sont repérés respectivement par un ensemble d'indices consistant en un certain nombre d'entiers consécutifs.</p>
                            <p>L'expression d'indice (de type BYTE) doit être compris dans l'intervalle 0..E où E est la longueur déclarée de la variable chaîne. Rappelons que le premier caractère d'une variable d'un type chaîne (celui qui correspond à l'indice 0) traduit en fait la longueur courante de la chaîne.</p>
                            <p>La référence à un élément d'une variable chaîne de caractères est réalisée par une référence à la variable chaîne suivie entre crochets par l'expression d'indice qui indique la position de l'élément au sein de la variable chaîne.</p>
                            <p>Exemple :</p>
                            <p>Soit la déclaration :</p>
<pre><code>var s:string[9];</code></pre>
                            <p>Après exécution de l'instruction :</p>
<pre><code>s := 'CHAINES';</code></pre>
                            <p>nous pouvons représenter la variable s de la manière suivante :</p>
                            <img src="../images/chaines_caracteres_Pascal_1.png" alt="">
                            <p><span class="em">writeln(s[2])</span> affichera le caractère '<span class="em">H</span>'.</p>
<pre><code>Program anagramme  ;
{$APPTYPE CONSOLE}

var s : string[9]  ;
    tampon : char  ;
begin
    s := 'CHAINES'   ;
    tampon := s[1]   ;
    s[1]   := s[6]   ;
    s[6]   := s[3]   ;
    s[3]   := s[2]   ;
    s[2]   := tampon ;
    writeln (s)	;      {ECHINAS}

    readLn
end.</code></pre>
                            <p>Vous ne pouvez cependant pas allonger une chaîne par cette méthode.</p>
                            <p><span class="em">s[8] := 'E'</span> n'ajoutera pas de 'E' à la fin de 'ECHINAS'.</p>
                            <p>Pour <span class="em">allonger</span> une chaîne, il faudra utiliser <span class="em">l'opérateur de concaténation (+)</span>.</p>
                            <p><span class="em">s := s + 'E'</span> ajoutera un 'E' à la fin de 'ECHINAS'.</p>
                        </li>
                        <li>
                            <h3>Comparaison de chaînes :</h3>
                            <p>Les opérateurs relationnels <span class="em">=</span>, <span class="em">&lt;&gt;</span>, <span class="em">&lt;</span>, <span class="em">&gt;</span>, <span class="em">&gt;=</span>, <span class="em">&lt;=</span> comparent deux chaînes de caractères. "L'ordre entre deux chaînes est déterminé par les relations d'ordre entre les valeurs des caractères situés en même position dans chacune des chaînes". Comme toutes les valeurs chaînes de caractères sont compatibles, toutes les chaînes peuvent être comparées.</p>
                            <ul>
                                <li>
                                    <p>Si les chaînes ne possèdent pas la même longueur, les caractères de la plus longue chaîne qui ne possèdent pas de correspondant sont considérés comme ayant une valeur supérieure.</p>
                                    <p>Ainsi l'expression <span class="em">'PASCAL' &lt; 'PASCALE'</span> a la valeur true et l'expression <span class="em">'PASCAL ' = 'PASCAL'</span> a la valeur false.</p>
                                    <p>Il est évident que <span class="em">'XZ' &gt; 'XWXYZ'</span> !</p>
                                </li>
                                <li>
                                    <p>Les chaînes vides ('') correspondent à la plus petite valeur et ne peuvent être égales qu'à d'autres chaînes vides.</p>
                                </li>
                                <li>
                                    <p>Signalons enfin qu'une valeur de type char est considérée comme une valeur chaîne de caractères de longueur 1; nous pouvons donc comparer une valeur de type char à une valeur de type chaîne.</p>
<pre><code>if s &lt; 'H'
    then ...</code></pre>
                                </li>
                            </ul>
                            <q class="em">Les fonctions standard high et low acceptent les identificateurs de type chaîne courte et les variables de ces types. High renvoie la longueur maximum du type de chaîne courte alors que low renvoie zéro.</q>
<pre><code>program lowhighstr;
{$APPTYPE CONSOLE}

type Str30 = string[30] ;
var  nom : Str30 ;
begin
    nom := 'TinTin' ;
    writeLn(low(nom)) ;          {0}
    writeLn(high(STr30)) ;       {30}

    readln
end.</code></pre>
                        </li>
                        <li>
                            <h3>Quelques fonctions prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>COPY(&lt;expr.chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">chaine := COPY(ch,p,n)</span></p>
                                    <p>La fonction <span class="html">COPY</span> renvoie une chaîne contenant <span class="em">n</span> caractères de <span class="em">ch</span> à partir de la position <span class="em">p</span>. Si <span class="em">p</span> est supérieur à la longueur de <span class="em">ch</span>, une chaîne vide est renvoyée et si <span class="em">n</span> indique un nombre de caractères qui dépasse la fin de la chaîne <span class="em">ch</span>, seuls les caractères inclus dans la chaîne sont renvoyés.</p>
<pre><code>program test_copy; 
{$APPTYPE CONSOLE}

var ch1,ch2,ch3,ch4:string;
begin
    ch1:='ABCDEFGH'    ;
    ch2:=COPY(ch1,2,3) ;
    ch3:=COPY(ch1,6,5) ;
    ch4:=COPY(ch1,10,4);
    writeLn(ch2);		{BCD}
    writeLn(ch3);		{FGH}
    writeLn(ch4);		{chaîne vide}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>CONCAT(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;,...) :</h4>
                                    <p>Exemple : <span class="em">chaine := CONCAT(ch1,ch2,ch3)</span></p>
                                    <p>La fonction <span class="html">CONCAT</span> renvoie une chaîne de <span class="em">ch1</span>, <span class="em">ch2</span>, <span class="em">ch3</span>. Si sa longueur dépasse 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractères.</p>
                                    <p><span class="em">CONCAT('AB','CDE','F')</span> retourne <span class="em">'ABCDEF'</span>.</p>
                                    <p class="em">Remarque : Pascal propose également l'opérateur + pour traduire l'opération de concaténation. Le type du résultat est le type chaîne de caractères et les types opérandes peuvent être chaîne de caractères ou caractère.</p>
                                    <p class="em">L'expression <span class="html">'AB'+'CDE'+'F'</span> a également la valeur <span class="html">'ABCDEF'</span>.</p>
                                </li>
                                <li>
                                    <h4>LENGTH(&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">longueur := LENGTH(ch)</span></p>
                                    <p>La fonction <span class="html">LENGTH</span> renvoie un entier représentant la longueur effective de la chaîne <span class="em">ch</span>.</p>
                                    <p class="em">Remarque : Le premier octet d'une chaîne contient - indirectement - la longueur courante de la chaîne; elle contient en fait le caractère dont le rang est égal à la longueur courante. Si <span class="html">ch := 'ABCDE'</span> alors <span class="html">ORD(ch[0])</span> est égal à la valeur 5.</p>
                                </li>
                                <li>
                                    <h4>POS(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">position := POS(ss,ch)</span></p>
                                    <p>La fonction <span class="html">POS</span> renvoie un entier (BYTE) représentant la position du premier caractère de <span class="em">ss</span> dans <span class="em">ch</span>.</p>
                                    <p>Si <span class="em">ss</span>n'est pas trouvé, la valeur renvoyée par <span class="em">POS</span> est 0. Cette fonction recherche donc la première occurence d'une sous-chaîne dans une chaîne.</p>
                                    <p>Exemple : <span class="em">POS('SITI', 'POSITION')</span> retourne <span class="em">3</span> et <span class="em">POS('ST', 'POSITION')</span> retourne <span class="em">0</span>.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Quelques procédures prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>DELETE(&lt;variable chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">DELETE(VarStr,p,n)</span></p>
                                    <p>La procédure <span class="html">DELETE</span> supprime <span class="em">n</span> caractères à la valeur de la variable <span class="em">VarStr</span> à partir de la position <span class="em">p</span>.</p>
                                    <p>Si <span class="em">p</span> est supérieur à la longueur de la chaîne <span class="em">VarStr</span>, aucun caractère n'est supprimé. Si <span class="em">n</span> indique plus de caractères qu'il n'en reste à partir de <span class="em">p</span>, seule la fin de la chaîne correspondant à <span class="em">VarStr</span> est effacée.</p>
<pre><code>program  test_delete ; 
{$APPTYPE CONSOLE}

var ch : string[10] ;
begin
    ch := 'ABCDEFGH' ;
    delete(ch,20,3) ;
    writeln(ch) ;			{ABCDEFGH}
    delete(ch,6,10) ;
    writeln(ch) ;           {ABCDE}
    delete(ch,2,2) ;
    writeln(ch)  ;			{ADE}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>INSERT(&lt;expr.chaîne&gt;,&lt;variable chaîne&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">INSERT(ch,VarStr,p)</span></p>
                                    <p>La procédure <span class="html">INSERT</span> insère l'expression chaîne <span class="em">ch</span> dans <span class="em">VarStr</span> en position <span class="em">p</span>.</p>
                                    <p>Lorsque <span class="em">p</span> est supérieure à la longueur courante de <span class="em">Varstr</span>, <span class="em">ch</span> est concaténée à <span class="em">VarStr</span>.</p>
                                    <p>Si la somme de la longueur de l'expression chaîne et de la longueur courante de la variable chaîne dépasse la longueur maximale de cette dernière, il y a évidemment "troncature" après insertion.</p>
<pre><code>program test_insert ; 
{$APPTYPE CONSOLE}

var ch : string[15] ;

begin
    ch := 'ABCDE' ;
    insert('fghijk',ch,10) ;
    writeln(ch) ;                    	{ABCDEfghijk}
    insert('xyz',ch,3) ;
    writeln(ch) ;                    	{ABxyzCDEfghijk}
    insert('mnopq',ch,7) ;
    writeln(ch) ;                     {ABxyzCmnopqDEfg}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>Str et val :</h4>
<pre><code>STR (&lt;expr.numérique [:expr.entière [:expr.entière]]&gt;;&lt;variable chaîne&gt;)</code></pre>
                                    <p>Exemple : <span class="em">STE(NombreReel:taille:NbreDec,VarStr)</span></p>
                                    <p>La procédure <span class="html">STR</span>convertit NombreReel en une chaîne de caractères en respectant les paramètres de formatage <span class="em">taille</span> et <span class="em">NbreDec</span>.</p>
                                    <p>L'expression numérique à convertir est une expression de type entier ou réel. L'effet est identique à un appel à la procédure standard write pourvues des mêmes paramètres, excepté que la chaîne résultante est chargée dans <span class="em">VarStr</span> au lieu d'être écrite dans un fichier texte.</p>
<pre><code>VAL (&lt;expr.chaîne&gt;,&lt;variable num.&gt;,&lt;variable entière&gt;)</code></pre>
                                    <p>Exemple : <span class="em">VAL(s,N,erreur)</span></p>
                                    <p>La procédure <span class="html">VAL</span> convertit une chaîne de caractères représentant une quantité en une valeur numérique. Plus précisément, si <span class="em">s</span> est une expression de type chaîne et N une variable d'un type entier ou réel, alors <span class="em">VAL</span> convertit - si possible - <span class="em">s</span> en une valeur numérique et charge le résultat dans <span class="em">N</span>.</p>
                                    <p>Si vous désirez convertir une chaîne qui représente une quantité entière, nous vous conseillons de déclarer <span class="em">N</span> de type longint, d'effectuer le contrôle des domaines de validité et enfin d'affecter la valeur entière renvoyée. La variable <span class="em">erreur</span> a la valeur zéro si tout c'est bien passé.</p>
                                    <p>Remarque : Toutes les fonctions et procédures présentées ici se trouvent dans l'unité System. Il existe également des routines de gestion de chaînes dans l'unité SysUtils.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Fonction Copy :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Copy(S:String;Index,Count:Integer):String;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Copy renvoie une sous-chaîne d'une chaîne.</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières. Copy renvoie une chaîne de Count caractères en commençant à S[Index].</p>
                            <p>Si Index est plus grand que la longueur de S, Copy renvoie une chaîne vide.</p>
                            <p>Si Count spécifie davantage de caractères qu'il y en a de disponibles, seuls les caractères de S[Index] jusqu'à la fin de S sont renvoyés.</p>
                            <p>Exemple :</p>
<pre><code>var S: string;
begin
    S := 'ABCDEF';
    S := Copy(S, 2, 3);	{ 'BCD' }
end;</code></pre>
<pre><code>function _copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        if p &lt;= lg then
        begin
            if n &gt; lg-p+1 then n := lg-p+1 {fi} ;
            for k := p to p+n-1 
            do Result := Result + ch[k] {od}
        end
    {fi}
end ;</code></pre>
<pre><code>function __copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        k := 0 ;
        while (k+p &lt;= lg) and (k &lt; n) do
            begin
                Result := Result + ch[k+p] ;
                inc(k)
            end
        {od}
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Delete :</h3>
                            <p>Routines de gestion de chaîne (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Delete(var S:string;Index,Count:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Delete supprime une sous-chaîne de Count caractères de la chaîne S en commençant à partir de S[Index].</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières.</p>
                            <p>Si Index est plus grand que la longueur de S, aucun caractère n'est supprimé. Si Count spécifie davantage de caractères qu'il y en a de disponibles après S[Index], Delete supprime le reste de la chaîne.</p>
                            <p>Exemple :</p>
<pre><code>var s: string;
begin
    s := 'Honest Abe Lincoln';
    Delete(s,8,4);
    Canvas.TextOut(10, 10, s); { 'Honest Lincoln' }
end;</code></pre>
<pre><code>procedure _delete(var ch : String ; p,n : Byte) ;
begin
    ch := CONCAT(copy(ch,1,p-1),copy(ch,p+n,length(ch)-n-p+1))
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Insert :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Insert(Source:String;var S:String,Index:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Insert fusionne une sous-chaîne dans une chaîne en commençant au point spécifié.</p>
                            <p>Source est une expression de type chaîne. S est une variable de type chaîne de longueur quelconque et Index une expression entière.</p>
                            <p>Insert insère Source dans S à la position S[index]. Si la chaîne résultante excède 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractère.</p>
                            <p class="em">Exemple :</p>
<pre><code>var
    S: string;
begin
S := 'Honest Lincoln';
Insert('Abe ', S, 8);      { 'Honest Abe Lincoln' }
end;</code></pre>
<pre><code>procedure _insert(ss:String;var ch:String; p:Byte) ;
begin
        ch := copy(ch,1,p-1)+ss+copy(ch,p,length(ch)-p+1)
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Fonction Pos :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité : </span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Pos(Substr:string;S:string):Byte;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Pos recherche une sous-chaîne dans une chaîne.</p>
                            <p>Substr et S sont des expressions de type chaîne.</p>
                            <p>Pos recherche Substr dans S et renvoie une valeur entière donnant l'indice du premier caractère de Substr dans S.</p>
                            <p>Si Substr n'est pas trouvée, Pos renvoie zéro.</p>
                            <p class="em">Exemple :</p>
<pre><code>var S: string;
begin
    S := '   123.5';
    { Convertit les espaces en zéros }
    while Pos(' ', S) &gt; 0 do  S[Pos(' ', S)] := '0';
end;</code></pre>
<pre><code>function _pos(ss,ch : String) : Integer ;
var lgch,lgss,k,ich,iss : Integer ;
begin
        lgch := length(ch) ;
        lgss := length(ss) ;
        result := 0 ;
        k := 1 ;
        while(k + lgss - 1 &lt;= lgch) do
        begin
            ich := k ;
            iss := 1 ;
            while (is&lt;=lgss)and(ch[ich]=ss[iss]) do
            begin
                    inc(ich) ;
                    inc(iss) ;
            end ;
            if iss &gt; lgss then
            begin
                Result := k ;
                break
            end ;
            inc(k)
        end
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Routines de gestion de chaînes :</h3>
                            <dl>
                                <dt>AnsiCompareStr</dt>
                                <dd>Effectue une comparaison de distinction majuscule/minuscule entre deux chaînes.</dd>
                                <dt>AnsiCompareText</dt>
                                <dd>Effectue une comparaison de deux chaînes sans distinction majuscule/miniscules.</dd>
                                <dt>AnsiLowerCase</dt>
                                <dd>Convertit des caractères en minuscules.</dd>
                                <dt>AnsiUpperCase</dt>
                                <dd>Convertit des caractères en majuscules.</dd>
                                <dt>CompareStr</dt>
                                <dd>Réalise une comparaison de deux chaînes en distinguant les minuscules des majuscules.</dd>
                                <dt>CompareText</dt>
                                <dd>Réalise une comparaison de deux chaînes en ne distinguant pas les minuscules des majuscules.</dd>
                                <dt>Concat</dt>
                                <dd>Concaténation de plusieurs chaînes de caractères.</dd>
                                <dt>Copy</dt>
                                <dd>Renvoie une partie d'une chaîne de caractères.</dd>
                                <dt>Delete</dt>
                                <dd>Supprime une partie d'une chaîne de caractères.</dd>
                                <dt>Insert</dt>
                                <dd>Insère une sous-chaîne dans une chaîne.</dd>
                                <dt>IntToHex</dt>
                                <dd>Convertit un entier en valeur hexadécimale.</dd>
                                <dt>IntToStr</dt>
                                <dd>Convertit un entier en une chaîne.</dd>
                                <dt>IsValidIdent</dt>
                                <dd>Renvoie True (Vrai) si la chaîne donnée est un identificateur valide.</dd>
                                <dt>Length</dt>
                                <dd>Renvoie la taille dynamique d'une chaîne.</dd>
                                <dt>LowerCase</dt>
                                <dd>Transforme en minuscules la chaîne donnée.</dd>
                                <dt>Pos</dt>
                                <dd>Recherche une sous-chaîne dans une chaîne.</dd>
                                <dt>Str</dt>
                                <dd>Convertit une valeur numérique en une chaîne.</dd>
                                <dt>StrToInt</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>StrToIntDef</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>UpperCase</dt>
                                <dd>Transforme en majuscule la chaîne donnée.</dd>
                                <dt>Val</dt>
                                <dd>Convertit une chaîne en sa représentation numérique.</dd>
                            </dl>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="fonctions_procedures">Fonctions et procédures :</h2>
                    <blockquote>
                        <p>"Si d'un point de vue philosophique les procédures permettent de définir une nouvelle instruction, d'un point de vue pratique elles nous donnent la possibilité d'utiliser la méthode d'analyse descendante (raffinements successifs). On peut ainsi se concentrer d'abord sur ce que l'on doit faire (et le nommer) avant de réfléchir à la façon dont on va le faire. Le Quoi faire ? avant le Comment faire ?, c'est bien cela la philosophie de l'abalyse descendante.</p>
                        <p>C'est ce que l'on nomme parfois l'abstraction procédurale.</p>
                        <p>De la même façon, on peut vouloir faire abstraction des détails d'un calcul complexe. D'un point de vue philosophique tout autant que pratique, les fonctions nous permettent de définir de nouveaux opérateurs du langage.</p>
                        <p>Le mécanisme d'abstraction procédurale est essentiel dans la conception d'un logiciel que l'on veut modulaire et fiable. L'essence même de ce mécanisme réside dans le fait que l'on peut utiliser une procédure ou une fonction sans se soucier de la façon dont elle est implémentée. Cela n'est possible que si nous savons ce que fait la procédure, c'est-à-dire que nous connaissons la syntaxe et la sémantique de son utilisation.</p>
                        <p>Si cette procédure est prédéfinie, à nous de nous ajuster à ses spécifications; si nous écrivons nous-mêmes la procédure, nous aurons à en déterminer la syntaxe et la sémantique d'appel."</p>
                    </blockquote>
                    <p>H. Paul HAIDUK.</p>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La résolution d'un problème passe souvent par sa décomposition en sous-problèmes et par la résolution de chacun d'eux.</p>
                            <p>Cette décomposition d'une tâche complexe en tâches élémentaires est un des concepts fondamentaux de la programmation structurée. On parle alors de développement de programmes par raffinements successifs.</p>
                            <p>En Pascal, les modules ainsi créés sont des sous-programmes qui sont soit des procédures, soit des fonctions.</p>
                            <p>Cette modularité de programmes permet :</p>
                            <ul>
                                <li>
                                    <p>une meilleure qualité de programmation</p>
                                </li>
                                <li>
                                    <p>une mise au point aisée</p>
                                </li>
                                <li>
                                    <p>une facilité de maintenance.</p>
                                </li>
                            </ul>
                            <p>Le Pascal, nous le savons, offre un certain nombre d'outils de base qui sont les procédures et fonctions standards : <span class="html">ABS</span>, <span class="html">SUCC</span>, <span class="html">SQR</span>, <span class="html">CHR</span>, <span class="html">COPY</span>, <span class="html">DELETE</span>, <span class="html">POS</span> ...</p>
                            <p>Une procédure ou une fonction apparaissent comme la définition d'un traitement.</p>
                            <p>Cependant, une fonction est assimilable à une <span class="em">valeur</span> et une procédure à une <span class="em">instruction</span>.</p>
                            <p>Ce sont en fait des sous-programmes écrits en langage machine et incorporés au Pascal. Nous ne connaissons de ces outils que les modes d'emploi.</p>
                            <p>Le langage Pascal permet de créer ses propres fonctions et procédures.</p>
                        </li>
                        <li>
                            <h3>Les fonctions :</h3>
                            <ol>
                                <li>
                                    <h4>Rappel mathématique :</h4>
                                    <p>En mathématique, l'utilisation d'une fonction f permet d'obtenir la valeur f(x<sub>0</sub>) de la fonction pour une valeur x<sub>0</sub> de la variable.</p>
                                    <p>Soit la fonction f(x) = x<sup>2</sup> - 2x + 3, nous aurons f(2) = 3, f(5) = 18, ...</p>
                                </li>
                                <li>
                                    <h4>Fonctions en Pascal :</h4>
                                    <p>En Pascal, une fonction se définit comme une structure de programme autonome dont le but consiste à calculer puis renvoyer une valeur. Le type du résultat à retourner est une valeur qui peut être de tout type sauf d'un type fichier.</p>
                                    <img src="../images/fonctions_Pascal.png" alt="">
                                    <p>Considérons le programme suivant dans lequel nous utilisons les fonctions standard <span class="html">sin</span> et <span class="html">upcase</span>. Cette fonction renvoie le sinus de son argulent, qui représente un angle exprimé en radians. Comme la valeur retournée est de type Extended, on dit que la fonction <span class="html">sin</span> est de type Extended. Le programme fait également appel à une autre fonction standard : la fonction <span class="html">upcase</span> qui convertit en majuscule un caractère. Si le caractère passé en argument à la fonction n'appartient pas à l'étendue 'a'..'z', la fonction renvoie la valeur caractère non affectée.</p>
<pre><code>program sinus;
{$APPTYPE CONSOLE}

var
    angle : Extended ;
    rep  : char ;

begin
    repeat
        write('valeur d''un angle en radians : ') ;
        readLn(angle) ;
        writeLn('valeur du sinus : ',sin(angle):8:2) ;
        write('continue O/N : ') ;
        readLn(rep)
    until upcase(rep) = 'N' ;

    readLn
end.</code></pre>
                                    <p>À chaque répétition, il y a appel de la fonction <span class="em">SIN</span>. Pour chaque valeur de type Extended de l'argument, la fonction <span class="em">SIN</span> retournera la valeur du sinus correspondant.</p>
                                    <p class="em">Exemple d'exécution :</p>
<pre><code>valeur d'un angle en radians : 1.57079
valeur du sinus :     1.00    
continue O/N ? o
valeur d'un angle en radians : 3.14159
valeur du sinus :     0.00
continue O/N ? o
valeur d'un angle en radians : 4.71238 
valeur du sinus :    -1.00
continue O/N ? n</code></pre>
                                    <p>La valeur de la variable angle est, dans notre exemple, l'argument (ou le paramètre effectif) de la fonction. L'argument doit être une valeur d'un type réel, il s'agit d'une expression réelle.</p>
                                    <p>Exemples :</p>
<pre><code>SIN(1.3)
SIN(A) 
SIN(A*PI/2) 
SIN(ABS(X))</code></pre>
                                    <p>Comme une fonction dénote une valeur, nous pourrons l'utiliser au sein d'une expression là où nous mettions une valeur.</p>
<pre><code>y := 3 * SIN(x)   1
writeln(sin(x))</code></pre>
                                    <p>Remarquons que dans le programme sinus, il y a appel à 5 sous-programmes :</p>
                                    <ul>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">write</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">writeLn</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la fonction </p>
                                            <span class="em">sin</span>
                                        </li>
                                        <li>
                                            <p>appel à la fonction <span class="em">upcase</span></p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Déclarations de fonctions :</h3>
                            <p>Une <span class="em">déclaration (de définition)</span> de fonction définit un sous-programme qui, nous l'avons déjà signalé, effectue un certain traitement avant de renvoyer une valeur.</p>
                            <img src="../images/declarations_fonctions_Pascal.png" alt="">
                            <p>Quand vous déclarez une fonction, vous spécifiez son nom, le nombre et le type des paramètres, ainsi que le type de la valeur renvoyée. La simple déclaration d'une fonction qui correspond à son en-tête est parfois appelé son prototype ou sa signature.</p>
<pre><code>function sin(x : Extended) : Extended ;

function upcase(ch : Char) : Char ;</code></pre>
                            <p>Pour définir la fonction, il convient de faire suivre son en-tête du corps de la fonction.</p>
                            <p>Le corps de la fonction est constitué d'un bloc, c'est-à-dire d'une partie déclaration et d'une partie instruction.</p>
                            <p>Dans la partie déclaration seront déclarés et définis tous les objets locaux à la fonction : il pourra s'agir de constantes, types, variables et ... de procédures et fonctions. <span class="em">Une bonne règle de programmation consiste à déclarer localement au sous-programme tout objet dont il n'est jamais fait usage à l'extérieur.</span></p>
                            <p>La partie instruction du corps de la fonction contient les instructions qui seront exécutées lors de l'activation de la fonction. Ce bloc doit contenir au moins une instruction pour affecter une valeur à la variable prédéfinie Result qui est propre à chaque fonction et du type de la fonction. Le résultat de la fonction est la dernière valeur affectée à cette variable spéciale. Si aucune instruction n'affecte de valeur à Result, la fonction retourne une valeur indéfinie. (<span class="em">Anciennement, on utilisait le nom de la fonction à la place de Result</span>).</p>
                        </li>
                        <li>
                            <h3>Paramètres formels et Appel de fonction :</h3>
                            <p>Des valeurs peuvent être passées à des sous-programmes par des paramètres. Ceux-ci fournissent un mécanisme de substitution permettant à la logique d'un sous-programme d'être utilisé avec différentes valeurs initiales, donnant évidemment des résultats différents.</p>
                            <p>Il existe différentes sortes de paramètres !</p>
                            <p>Ceux dont il est question ici sont les <span class="em">paramètres valeur</span>.</p>
                            <p>Une fonction est activée par l'évaluation d'une expression contenant l'appel de la fonction.</p>
                            <p>Cet appel de fonction se fait en écrivant le nom de la fonction doit être faite. Ces paramètres effectifs représentent des <span class="em">valeurs</span>.</p>
                            <p>À chaque appel, les paramètres effectifs sont subtitués aux paramètres formels spécifiés dans l'en-tête de la fonction.</p>
                            <p>L'ordre des paramètres passés est l'ordre d'apparition dans la liste des paramètres formels. Dans ce type de passage, <span class="em">chaque paramètre formel représente une variable locale au sous-programme qui est initialisé à la valeur du paramètre effectif correspondant</span>.</p>
                            <p>Les types des paramètres formels et des paramètres effectifs doivent - c'est l'évidence - être compatibles.</p>
                            <p>Le diagramme syntaxique définissant la liste de paramètres formels (<span class="em">paramètres valeur</span>) devient :</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>Exemples :</p>
                            <p>Si la fonction <span class="html">COPY</span> n'existait pas, il conviendrait de l'écrire nous-même.</p>
                            <p>À quoi ressemblerait le prototype d'une telle fonction ?</p>
                            <p>La fonction <span class="html">COPY</span> renvoie une partie d'une chaîne de caractères. Elle renvoie une chaîne constituée de <span class="em">n</span> caractères à partir de la position <span class="em">p</span>.</p>
                            <img src="../images/parametres_formels_Pascal_1.png" alt="">
                            <p>L'en-tête de la fonction <span class="html">COPY</span> pourrait être :</p>
<pre><code>function COPY (ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres constante :</h3>
                            <p class="em">(Manuel de référence) :</p>
                            <p>Un paramètre constante (const) est semblable à une constante locale ou à une variable en lecture seule. Les paramètres constantes sont semblables aux paramètres valeur à cette différence qu'il n'est pas possible d'affecter une valeur à un paramètre constante dans le corps de la routine, <span class="em">ni de le transmettre comme paramètre var à une autre routine</span>.</p>
                            <p>L'utilisation de <span class="html">const</span> permet au compilateur d'optimiser le code pour les paramètres de type structuré ou chaîne.</p>
                            <p>Le protocole de la fonction copy peut donc s'écrire :</p>
<pre><code>function COPY(<span class="html">const</span> ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Exemples de définitions de fonctions :</h3>
                            <p>En guise d'exercice, nous allons réécrire la fonction upcase ainsi que la fonction uppercase qui renvoie une chaîne en majuscules.</p>
<pre><code>function uppercase(const S : String) : String ;</code></pre>
<pre><code>program majuscule;
{$APPTYPE CONSOLE}

<span class="em">function charMaj(ch : Char) : Char ;
begin
    Result := ch ;
    if (ch &gt;= 'a') and (ch &lt;= 'z') then
        Result := chr( ord(ch) + ord('A') - ord('a') )
    {fi}
end ;

function strMaj(const S : String) : String ;
var k : Cardinal ;
begin
    Resukt := s ;
    for k := 1 to length(Result) do
        Result[k] := charMaj(Result[k]) ;
end ;</span>

var chaine : String ;
begin
    repeat
        write('chaine : ') ;
        readLn(chaine) ;
        if chaine = '' then break ;
        writeLn(strMaj(chaine)) ;
        writeLn(chaine) ;
    until False ;
end .</code></pre>
                            <p>Le programme majuscule correspond à une boucle généralisée. À chaque répétition, il y a appel à la fonction strMaj avec comme argument (paramètre effectif) la valeur courante de la variable chaîne de type String. La valeur de cette variable <span class="em">chaine</span> ne sera pas modifiée par l'exécution de la routine puisque (sémantiquement) c'est la valeur et non la variable qui est transmise !</p>
                            <p class="em">Exemple d'exécution d'une répétition... :</p>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                    <tr>
                                        <td>write('Chaine :') ; readLn(chaine) ;</td>
                                        <td>Chaine : <span class="em">aAzZeErRtTyY ! !</span></td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(strMaj(chaine)) ;</td>
                                        <td class="em">AAZZEERRTTYY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(chaine) ;</td>
                                        <td class="em">aAzZeErRtTyY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Pour chaque appel de la fonction strMaj, il y aura un appel à la fonction prédéfinie length et une suite d'appels à la fonction charMaj (en fait, un appel pour chaque caractère de la valeur String).</p>
                        </li>
                        <li>
                            <h3>Problématique de l'usage des routines :</h3>
                            <p>La structure du programme <span class="em">majuscule</span> reflète (en simplifié) celle de la majorité des programmes. Le programme principal lance successivement un ensemble de sous-programmes, chacun d'eux pouvant lancer ses propres sous-pogrammes...</p>
                            <p>Ce mécanisme d'exécution revient à suspendre l'exécution du programme en cours. Le processus qui s'exécute se suspend par l'appel explicite d'un sous-programme et permet le lancement du processus associé au sous-programme. Lorsque l'exécution de ce sous-programme est terminée, le programme appelant reprend la main, et continue son exécution là où il l'avait suspendue.</p>
                            <img src="../images/problematique_usage_routines.png" alt="">
                            <p>Le concepteur, dans une démarche d'écriture structurée, donne grande importance aux routines. La forme générale de son projet est alors un ensemble de nombreux sous-programmes, chacun étant de taille fort réduite et de fonctionnalité simple, et l'exécution consiste en de nombreux appels de ces sous-programmes.</p>
                            <p>Le programme principal a un rôle de lanceur. Il réalise certaines initialisations, puis passe la main. Dans tous les cas, c'est par lui qui commence l'exécution et également qu'elle se termine.</p>
                        </li>
                        <li>
                            <h3>Bloc et Portée d'une déclaration :</h3>
                            <p>Un bloc est composé d'un ensemble de déclarations suivi d'un ensemble d'instructions. Chaque bloc est contenu dans une déclaration de procédure, de fonction, de programme (ou d'unité).</p>
                            <p>Tous les identificateurs déclarés dans la partie déclaration d'un bloc sont locaux à ce bloc.</p>
                            <p>Une déclaration introduit un nom (identificateur) dans une portée.</p>
                            <q class="em">La <span class="html">portée</span> d'une déclaration est la partie du texte du programme où l'association entre le nom de l'objet déclaré et sa desccription est d'application.</q>
                            <p>On parle aussi parfois du domaine d'application d'une déclaration en lieu et place de la portée d'une déclaration.</p>
                            <p class="em">La portée d'un identificateur déclaré dans une déclaration de constantes, de types, de variables, de procédures ou de fonctions s'étend de l'endroit de la déclaration jusqu'à la fin du bloc courant, en incluant tous les blocs définis à l'intérieur de ce bloc courant.</p>
                            <p>Un identificateur déclaré dans un bloc peut être <span class="em">redéclaré</span> dans un bloc plus interne.</p>
                            <p class="em">Visibilité :</p>
                            <p><span class="em">Une déclaration est visible</span> dans la partie du texte où on peut l'identifier, c'est-à-dire où le nom déclaré peut être écrit et signifier l'objet décrit. Un identificateur est visible là où sa déclaration est visible.</p>
                            <p>Une déclaration peut être visible dans toute l'étendue de sa portée mais peut aussi être <span class="em">masquée</span> par d'autres déclarations dont la portée et la visibilité chevauchent celles de la première déclaration.</p>
                        </li>
                        <li>
                            <h3>Durée de vie :</h3>
                            <p>Les variables et les sous-programmes, contrairement aux types, existent lors de l'exécution du programme <span class="em">&lt; ils occupent une place mémoire</span>.</p>
                            <q class="em">La durée de vie d'un objet est la période durant laquelle cette mémoire lui est allouée.</q>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui est allouée pour toute la durée de l'exécution du programme.</p>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui esr allouée pour toute la durée de l'exécution du programme.</p>
                            <p>Une variable peut avoir une durée de vie <span class="em">temporaire</span>. Elle est alors créée à l'entrée du sous-programme contenant sa déclaration et détruite quand son nom sort de sa portée.</p>
                            <blockquote>
                                <p>durée de DYNAMIQUE (liée à l'exécution du programme)</p>
                                <p>portée = propriété STATIQUE (liée au texte du programme)</p>
                            </blockquote>
                            <p class="em">Variables globales et variables locales (résumé) :</p>
                            <p>Les programmes jusqu'à présent rencontrés étaient constitués d'un seul bloc. Comme on n'y avait déclaré aucun sous-programme, il n'y avait pas d'imbrication de blocs. Les variables étaient toutes des variables globales. Elles avaient été déclarées dans le bloc principal du programme; leur durée de vie était celle du programme.</p>
                            <p>La portée de la déclaration d'une variable globale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc courant c'est-à-dire jusqu'à la fin du programme.</p>
                            <p>Il conviendra de réduire au maximum cette portée... De ce fait, nous ne serons pas tentés d'utiliser des variables globales à l'intérieur des sous-programmes.</p>
                            <p class="em">Une bonne règle de programmation étant de construire des sous-programmes étanches.</p>
                            <p>Les variables déclarées dans un sous-programme auront une durée de vie qui correspondra à l'exécution de ce sous-programme. De telles variables locales.</p>
                            <p>La portée de la déclaration d'une variable locale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc du sous-programme. Il y a cohérence entre la propriété statique de portée et la propriété dynamique de durée de vie.</p>
                            <q>Une fonction doit constituer un tout; elle doit être "<span class="em">étanche</span>", et compréhensible en dehors du contexte dans lequel elle est utilisée. C'est d'ailleurs à ce prix que vous pourrez la réutiliser dans d'autres programmes.</q>
                        </li>
                        <li>
                            <h3>Procédures - Introduction :</h3>
                            <p>Une procédure est destinée à réaliser une action, un traitement. Elle correspond à la notion de sous-programme dans toute sa généralité. Son appel sera assimilable à une <span class="em">instruction</span>.</p>
                            <p>Comme premier exemple, nous pourrions définir une procédure <span class="em">erreur</span> dont l'effet est pour le moins dévasteur.</p>
<pre><code>procedure erreur(const message : String) ;
begin
        writeLn(message) ;
        halt
end ;</code></pre>
                            <p>Cette procédure fait elle-même appel à deux procédures prédéfinies.</p>
                            <p>La procédure d'affichage writeLn et la procédure halt qui exécute une fin anormale de programme !</p>
                            <img src="../images/procedure_affichage_writeLn_Pascal.png" alt="">
                            <p>Nous avons déjà rencontré des procédures dont "l'effet" étaient de modifier des variables. Ainsi la procédure inc permet d'incrémenter la valeur d'une variable. C'est la variable qu'il conviendra de transmettre au sous-programme !</p>
<pre><code>…
{ assert(x=12) }
inc(x) ;
{ assert(x=13) }
…</code></pre>
                            <img src="../images/assert.png" alt="">
                            <p>Pour que la procédure soit un outil général, il convient qu'elle puisse aussi restituer une ou plusieurs valeurs au programme (ou sous-programme) appelant.</p>
                            <p>Un nouveau mode de transmission de paramètres sera alors nécessaire. Nous l'étudierons après avoir précisé la syntaxe d'une délcaration de procédure.</p>
                        </li>
                        <li>
                            <h3>Déclaration (de définition) de procédure :</h3>
                            <p>Une déclaration de procédure associe un identificateur à un bloc d'instructions.</p>
                            <p>L'appel de la procédure se fera par une instruction de procédure; celle-ci spécifie l'identificateur de la procédure, ainsi que les paramètres effectifs, si nécessaire. Quand une procédure est appelée, le contrôle se trouve transféré au début de la procédure. Après avoir exécuté les instructions qui composent le traitement de la procédure, le contrôle retourne automatiquement à l'instruction qui suit l'instruction d'appel de la procédure.</p>
                            <img src="../images/declaration_procedure_Pascal.png" alt="">
                            <p class="em">L'en-tête de la procédure est suivi :</p>
                            <ul>
                                <li>
                                    <p class="em">d'une partie déclaration qui déclare les objets locaux;</p>
                                </li>
                                <li>
                                    <p>des instructions comprises entre begin et end, qui spécifient ce qui doit être exécuté lorsqu'il est fait appel à la procédure.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Paramètres variable :</h3>
                            <p>Répétons-le, un paramètre valeur est simplement une variable locale au sous-programme, qui lors de son activation a été initialisée à la valeur du paramètre effectif correspondant.</p>
                            <p class="em">Si vous transmettez une variable comme paramètre valeur, la routine en crée une copie et les modifications apportées à la copie sont sans effet sur la variable d'origine et sont perdues quand l'exécution du programme revient à l'appel de la routine.</p>
                            <p>Un paramètre variable se comporte, lui, comme une sorte d'alias, un autre nom permettant d'accéder au paramètre effectif qui doit être une variable (référence à une variable).</p>
                            <p class="em">Un paramètre variable dénote une variable !</p>
                            <p>De ce fait, les modifications apportées aux paramètres dans le corps de la routine sont conservées lorsque l'exécution du programme revient à l'appel de la routine et que le nom du paramètre est hors de portée.</p>
                            <p>Rappelez-vous qu'un identificateur de variable représente en fait l'adresse symbolique de la case mémoire correspondant à la variable désignée. Le paramètre formel variable est dans la procédure un nouveau nom pour la variable référencée par le paramètre effectif. Ainsi, le paramètre formel et le paramètre effectif font référence à la même case mémoire.</p>
                            <p>En conséquence, modifier le paramètre formel dans un sous-programme, c'est en fait modifier le paramètre effectif correspondant.</p>
                            <p>On comprend alors pourquoi cette technique est utilisée pour les paramètres de retour (lorsqu'une valeur doit être renvoyée à l'appelant d'une procédure) et pourquoi paramètres formels et effectifs doivent être de types rigoureusement identiques.</p>
                            <p>Une liste de paramètres par adresse est précédée du mot réservé var.</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>L'exemple classique suivant bien la différence entre les deux types de paramètres.</p>
<pre><code>program val_var ; 
{$APPTYPE CONSOLE}

procedure echange_local( a,b : integer ) ; 
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ; 

<span class="em">procedure echange( var a,b : integer ) ;
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ;</span>
    
var x,y : integer ; 
    
begin 
    x := 1 ; y := 2 ; 
    writeln(x:8,y:8) ;              {       1       2} 
    echange_local(x,y) ; 
    writeln(x:8,y:8) ;              {       1       2}     
    echange(x,y) ; 
    writeln(x:8,y:8) ;              {       2       1} 

    readLn     
end.</code></pre>
                        </li>
                        <li>
                            <h3>Une nouveauté : les paramètres out :</h3>
                            <p>(Manuel de référence) :</p>
                            <p class="em">Un paramètre de sortie (out) est transmis par adresse comme un paramètre variable. Mais avec un paramètre out, la valeur initiale de la variable référencée n'est pas prise en compte par la routine à laquelle elle est transmise. Le paramètre out n'est utilisé qu'en sortie; il indique simplement à la routine où placer la valeur en sortie sans spécifier de valeur en entrée.</p>
                            <p class="em">Soit, par exemple, l'en-tête de procédure suivant :</p>
<pre><code>procedure ExtraitInfos(out Info: UnTypeEnreg);</code></pre>
                            <p class="em">Quand vous appelez <span class="html">ExtraitInfos</span>, vous devez lui transmettre une variable de type <span class="html">UnTypeEnreg</span> :</p>
<pre><code>var MonEnreg: UnTypeEnreg;

...
ExtraitInfos(MonEnreg);</code></pre>
                            <p class="em">Mais vous n'utilisez pas <span class="html">MonEnreg</span> pour transmettre des données à la procédure <span class="html">ExtraitInfos</span>; <span class="html">MonEnreg</span> sert simplemeent de conteneur où <span class="html">ExtraitInfos</span> stocke les informations qu'elle génère. L'appel de <span class="html">ExtraitInfos</span> libère immédiatement la mémoire utilisée par <span class="em">MonEnreg</span>, avant que le contrôle du programme ne passe à la procédure.</p>
                            <p class="em">Les paramètres <span class="html">Out</span> sont fréquememment utilisés avec les modèles d'objets distribués comme <span class="html">COM</span> ou <span class="html">COBRA</span>. De plus, vous devez utiliser des paramètres <span class="html">out</span> pour transmettre une variable non initialisée à une routine.</p>
                        </li>
                        <li>
                            <h2>Transfert de paramètre :</h2>
                            <p>Les paramètres sont transmis aux procédures et aux fonctions par l'intermédiaire (<span class="em">des registres CPU ou</span>) de la pile, selon la convention d'appel de la routine.</p>
                            <p>Selon une des conventions possibles, les paramètres sont placés, avant l'appel du sous-programme, dans la pile suivant l'ordre de leur déclaration. Juste avant la fin de son exécution, le sous-programme retire tous les paramètres de la pile.</p>
                            <p>La structure d'appel d'une routine pourrait être la suivante :</p>
<pre><code>PUSH		param1
PUSH		param2
        …
PUSH		paramN
CALL 		routine</code></pre>
                            <p>Il n'existe que deux sortes de transmission :</p>
                            <ul>
                                <li>
                                    <p>par valeur,</p>
                                </li>
                                <li>
                                    <p>par référence ou adresse.</p>
                                </li>
                            </ul>
                            <p class="html">Lorsqu'un paramètre est transmis par adresse, un pointeur sur l'emplacement en mémoire de la "valeur" à transmettre est placé dans la pile.</p>
                            <p class="html">Pour une transmission par valeur, c'est la valeur elle-même qui est placée dans la pile.</p>
                            <p class="em">Les paramètres variables (et de sortie) sont toujours transmis par adresse.</p>
                            <p class="em">Les paramètres valeurs (et constantes) sont transmis, suivant leur type et leur taille, par adresse ou par valeur.</p>
                            <p>En général, si le paramètre occupe quelques octets, la valeur est directement placée dans la pile. Sinon, le sous-programme appelé copie la valeur dans une zone de mémoire locale et c'est un pointeur sur cette zone qui est placé dans la pile.</p>
                            <p><span class="em">L'effcicacité des paramètres constantes</span> par rapport aux paramètres valeurs vient de ce que le compilateur n'a pas à générer de copie des paramètres effectifs à l'entrée dans le sous-programme <span class="em">puisque les paramètres constantes ne sont pas modifiables !</span></p>
                        </li>
                        <li>
                            <h3>Laboratoire d'analyse :</h3>
                            <p>Comme petit exercice, analysez le programme suivant :</p>
                            <p class="em">(fonction, procédure et contexte d'appel...)</p>
<pre><code>program test;
{$APPTYPE CONSOLE}

procedure NumString(N:Integer;var S:String) ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        S := '' ;
        repeat
        S := chr(V mod 10 + ord('0')) + S ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then S := '-'+ S
end ;

function NumString(N : Integer) : String ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        Result := '' ;
        repeat
        Result := chr(V mod 10 + ord('0')) + Result ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then REsult := '-'+ Result
end ;

var str : String ;
begin

    NumString(-12345,str) ;
    writeLn(str) ;

    writeLn(NumString(-12345)) ;

    readLn
end .</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="tableaux">Tableaux (Array) :</h2>
                    <h3>1<sup>ère</sup> Partie : Les tableaux en Pascal Objet :</h3>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Lorsqu'un nombre important de variables de même type et surtout associées à une même catégorie d'objet, doit être utilisé dans un programme, il est bien entendu impossible d'envisager d'attribuer un identificateur différent à chaque variable (par exemple le chiffre d'affaires quotidien d'un représentant).</p>
                            <p>Les tableaux permettent de résoudre cette difficulté.</p>
                            <p>Un tableau est une manière assez naturelle de ranger des éléments de même type. Il permet de regrouper ceux-ci dans une structure fixe et d'accéder à chaque élément par le biais d'un indice.</p>
                            <p>On peut considérer une variable tableau comme un tableau de variables.</p>
                        </li>
                        <li>
                            <h3>Définition :</h3>
                            <p>Un tableau est une structure constituée d'un nombre fixe d'éléments du même type qui est appelé type de base ou type composant.</p>
                            <p>Il s'agit donc d'une <span class="em">structure homogène</span>.</p>
                            <p>Nous pouvons construire des tableaux d'entiers, des tableaux de booléens, mais aussi des tableaux de chaînes et pourquoi pas... des tableaux de tableaux !</p>
                            <p>Un tableau est aussi une structure dite <span class="em">à accès aléatoire</span> : à un instant donné, on peut sélectionner n'importe quel composant. Le temps d'accès à un élément est indépendant de la place qu'occupe cet élément dans la structure.</p>
                            <p>Pour désigner, pour référencer un composant, on ajoute entre crochets au nom de la variable de type tableau ce qu'on appelle un indice. Cet indice signale la position de l'élément dans le tableau et doit être une valeur du type défini comme le type d'indice du tableau.</p>
                            <p>Le type de l'indice permet de définir le nombre d'éléments du tableau. En Pascal, les types autorisés pour les indices sont tous les types scalaires.</p>
                            <p>La définition d'un type de tableau <span class="em">TT</span> spécifie à la fois un type de base <span class="em">TB</span> et un type d'indice <span class="em">TI</span>.</p>
<pre><code>Type TT = ARRAY[TI] of TB ;</code></pre>
                            <p>Exemples :</p>
<pre><code>
Type Tab1_20Real = ARRAY [1..20] of Real ;
     Tab0_255Boolean = ARRAY [byte] of Boolean ;

var t1,t2 : Tab1_20Real ;
t3,t4 : Tab0_255Boolean ;

Type Tetat = (travail,conge,recuperation,in¬defini) ;
     Tjour = (lun,mar,mer,jeu,ven,sam,dim) ; 
     Tableau = ARRAY [Tjour] of Tetat ;
var t : Tableau ;
...</code></pre>
                            <p>Notez cependant qu'il peut exister des restrictions qui dépendent de la capacité mémoire et non de la définition du langage.</p>
<pre><code>type 	TropGros = array [Longint] of Extended ;
{ erreur  => type de donnée trop grand : dépasse 2Go }</code></pre>
                            <p class="em">Remarque : Le type des composants d'un tableau peut être lui-même d'un type tableau; nous obtenons ainsi des tableaux de tableaux "ou" tableaux multidimensionnels.</p>
<pre><code>
Type Tvecteur = ARRAY [1..3] of Extended ;
     Tmatrice = ARRAY [1..5] of Tvecteur ;
var m : Tmatrice ;</code></pre>
                            <p class="em">Pour référencer l'élément de la matrice correspondant à la i<sup>ème</sup> ligne et à la j<sup>ème</sup> colonne, nous pouvons écrire <span class="html">m[i][j]</span> ou encore <span class="html">m[i,j]</span>.</p>
                            <p class="em">Nous aurions pu définir le type Tmatrice autrement :</p>
<pre><code>Type Tmatrice = ARRAY [1..5] of ARRAY [1..3] od Extended ;
// ou encore
     Tmatrice = ARRAY[1..5,1..3] of Extended ;</code></pre>
                            <p class="em">Ces définitions sont cependant moins souples que la première qui permet une assignation tel que : <span class="html">v := m[k]</span> en supposant que <span class="html">v</span> est une variable de type <span class="html">Tvecteur</span>.</p>
                        </li>
                        <li>
                            <h3>Opérations sur les tableaux :</h3>
                            <p>La seule opération globale sur des tableaux est l'affectation. Celle-ci n'est possible que si les deux tableaux sont rigoureusement de même type.</p>
                            <p>Supposons les déclarations suivantes :</p>
<pre><code>type Tab1 = ARRAY [1..5] of integer ;
     Tab2 = ARRAY [1..5] of integer ;
var t,t1 : Tab1 ;
    t2 : Tab2 ;</code></pre>
                            <p>l'affectation <span class="em">t1 := t</span> est possible alors que l'affectation <span class="em">t1 := t2</span> ne l'est pas car les types <span class="em">tab1</span> et <span class="em">tab2</span> sont distincts !</p>
                            <ul>
                                <li>
                                    <p>Les procédures prédéfinies de lecture et écriture (readln, writeln, ...) ne permettent que de traiter des nombres des chaînes - étant bien entendu qu'il s'agit de variables pour les lectures et d'expressions pour les écritures.</p>
                                    <p>Il conviendra donc de lire ou d'écrire successivement chaque élément du tableau.</p>
<pre><code>...
for k := 1 to 5 do
    begin
        write('t[',k,'] = ');
        readln(t[k])
    end;
...</code></pre>
                                </li>
                                <li>
                                    <p>Les opérations réalisables sur un élément de tableaux sont celles réalisables sur le type composant. Ainsi, dans notre exemple, <span class="em">t1[3]</span> est assimilable à une variable entière. Il s'agit d'une <span class="em">extension de la notion de variable</span> : un composant d'une variable de type structuré est une référence à une variable et correspond donc à un emplacement adressable.</p>
                                    <p>Au niveau représentation en mémoire, un tableau est stocké comme une séquence de variables adjacentes de même type que le type de base du tableau.</p>
                                    <img src="../images/operations_tableaux_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Lorsque les fonctions <span class="html">low</span> et <span class="html">high</span> sont appliquées à un identificateur de type tableau ou une référence d'un type tableau, elles retournent les bornes inférieures et supérieure du type d'indice du tableau.</p>
<pre><code>program highlow ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     TabA_ZInt = array[TMajuscule] of Integer ;
     Tab1_10Int = array[TIndex] of Integer ;
var M : TabA_ZInt ;
    L : Tab1_10Int ;
begin
    writeln(low(TabA_zInt):8,low(M):8) ;
    writeln(high(TabA_zInt):8,high(M):8) ;
    writeln(low(Tab1_10Int):8,low(L):8) ;
    writeln(high(Tab1_10Int):8,high(L):8) ;
    readLn
end.</code></pre>
                            <img src="../images/highlow_Pascal.png" alt="">
                            <p>Exemple :</p>
<pre><code>program testab ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     Tableau = array[Tindex] of TMajuscule ;
    
procedure afficheTableau(const T : Tableau) ;
var k : TIndex ;
begin
    for k := low(T) to high(T) do
        writeln('T[',k:2,'] = ',T[k]) ;
    writeln
end ;

function genereTableau : Tableau ;
var k : TIndex ;
begin
    for k := low(Result) to high(Result) do
        Result[k] := char(65 + random(26))
end ;

procedure echange(var x,y : TMajuscule) ;
var tmp : TMajuscule ;
begin
    tmp := x ; x := y ; y : tmp
end ;

var Tab : Tableau ;
begin
    randomize ; tab := genereTableau ;
    afficheTableau(tab) ;
    echange(tab[1],tab[10]) ; echange(tab[2], tab[9]) ;
    afficheTableau(tab) ;
    readLn
end.</code></pre>
                            <img src="../images/testab_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Constante typée :</h3>
                            <p>Pascal Objet autorise la définition de constantes de type tableau sauf celles qui contiennent des éléments de type fichier.</p>
<pre><code>type TEtat = (actif,passif,attente) ;
     TabEtat : array [TEtat] of String ;
const ETATTOSTR : TabEtat = ('actif','passif','attente') ;</code></pre>
                            <p>La constante tableau <span class="em">ETATTOSTR</span> peut être utilisée pour convertir les valeurs du type énuméré <span class="em">TEtat</span> en leur représentation sous forme de chaîne de caractères.</p>
<pre><code>type TCarre = array[1..3,1..4] of Integer ;
const UNCARRE : TCarre = ( (1,2,3,4) , (5,6,7,8) , (9,10,11,12) ) ;</code></pre>
                            <img src="../images/constante_typee_Pascal.png" alt="">
<pre><code>procedure afficheCarre(const C:TCarre) ;
var j,k : Byte ;
begin
    for j := 1 to 3 do begin
        for k := 1 to 4 do
            write(C[j,k]:4)
        {od} ;
    end{do} ;
    writeln
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres tableaux ouverts :</h3>
                            <p>Les paramètres tableaux ouverts permettent de transmettre à un même sous-programme des tableaux de tailles différentes.</p>
                            <p>Un paramètre formel déclaré avec la syntaxe <span class="html">array of T</span> où T est un identificateur de type est un paramètre tableau ouvert. Le paramètre effectif correspondant doit être une variable de type T (<span class="em">tableau à une dimension</span>) ou un tableau dont les éléments sont de type T.</p>
                            <p>À l'intérieur du sous-programme, tout se passe comme si le paramètre formel avait été déclaré...</p>
<pre><code>array [0..N-1] of T</code></pre>
                            <p>où <span class="em">N</span> est le nombre d'éléments du paramètre effectif. Il y a mise en correspondance entre l'intervalle des indices du paramètre effectif et l'intervalle du paramètre formel, soit l'intervalle <span class="em">0..N-1</span>.</p>
                            <p>Il existe une restriction : un paramètre tableau ouvert n'est accessible qu'élément par élément. Lorsqu'elle est appliquée à un paramètre tableau ouvert, la fonction <span class="html">low</span> renvoie <span class="em">0</span> et la fonction <span class="html">high</span> renvoie <span class="em">N-1</span>.</p>
<pre><code>function sommerTabInt(const T : array of Integer):Integer;
var k : Cardinal ;
begin
    Result := 0 ;
    for k := low(T) to high(T) do inc(Resylt,T[k])
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Constructeurs de tableaux ouverts (Guide du langage Pascal Objet) :</h3>
                            <p>Lorsqu'un paramètre formel est un paramètre valeur ou un paramètre constant de type tableau ouvert, le paramètre effectif correspondant dans l'appel du sous-programme peut être un constructeur de tableaux ouverts.</p>
                            <p>Un constructeur de tableau ouvert est constitué d'une ou plusieurs expressions, séparées par des virgules, et encadrées de crochets. Chaque expression doit être compatible en terme d'affectation avec le type des éléments du paramètre tableau ouvert.</p>
                            <p>L'utilisation d'un constructeur d'un tableau ouvert revient à créer une variable tableau temporaire et à initialiser ses éléments avec les valeurs fournies par la liste des expressions.</p>
<pre><code>program Opentab;
{$APPTYPE CONSOLE}

procedure afficherTabInt(const T : array of Integer) ;
var k : cardinal ;
begin
    for k := low(T) to high(T) do write(T[k]:4) ;
    writeln
end ;

function sommerTabInt(const T : array of Integer):Integer;
var k : Cardinal ;
begin
    Result := 0 ;
    for k := low(T) to high(T) do inc(Result,T[k])
end ;

var k : Cardinal ;
begin
    afficherTabInt([1,2,3,4,5]) ;
    writeln(sommerTabInt([1,2,3,4,5])) ;
    afficherTabInt([6,7,8]) ;
    writeln(sommerTabInt([6,7,8])) ;
    readLn
end.</code></pre>
                            <img src="../images/Opentab_Pascal.png" alt="">
                        </li>
                    </ol>
                    <h3>2<sup>ème</sup> Partie : Algorithmes :</h3>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Nous présentons à présent la construction de quelques algorithmes itératifs portant sur les tableaux. Si l'on excepte la recherche dichotomique, nous nous intéresserons ici aux situations où l'on traite les éléments d'un tableau de manière séquentielle. Nous pouvons dès lors interpréter le tableau comme la représentation d'une séquence de longueur fixe et nous ramener à des schémas itératifs déjà étudiés.</p>
                            <p class="em">Description de l'état dans un parcours séquentiel d'un tableau :</p>
                            <img src="../images/description_etat_parcours_sequentiel_tableau_Pascal.png" alt="">
                            <p>À titre d'exemple, nous présentons la fonction maximum qui renvoie la valeur maximum d'un tableau d'entiers. (La construction de l'algorithme est une simple adaptation de ce qui a été étudié précédemment pour les séquences d'entiers.)</p>
<pre><code>function maximum(const T : array of Integer) : Integer ;
var k : Cardinal ;
begin
    Result := T[0] ;
    for k := 1 to high(T) do
        if T[k] &gt; Result
            then Result := T[k]
        {fi}
    {od}
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Tri :</h3>
                            <p>On définit le tri comme un processus de rangement d'un ensemble de rangement d'un ensemble donné d'objets dans un certain ordre. En triant un ensemble de données, on facilite les recherches ultérieures sur les membres de cet ensemble.</p>
                            <p>On classe les méthodes de tri en deux catégories :</p>
                            <ul>
                                <li>
                                    <p>les tris internes (tris de tableaux)</p>
                                </li>
                                <li>
                                    <p>les tris externes (tris de fichiers).</p>
                                </li>
                            </ul>
                            <p>Nous nous intéresserons ici à quelques méthodes de tris internes.</p>
                            <ol>
                                <li>
                                    <h4>Tri par extraction ou par sélection :</h4>
                                    <p class="em">Principe :</p>
                                    <ol>
                                        <li>
                                            <p>Sélection de l'élément de plus basse clé</p>
                                        </li>
                                        <li>
                                            <p>Échange de cet élément avec le premier élément</p>
                                        </li>
                                        <li>
                                            <p>Répétition de ces opérations avec les n-1 éléments restants, puis avec les n-2, ... jusqu'à ce qu'il ne reste qu'un seul élément : le plus grand.</p>
                                        </li>
                                    </ol>
                                    <p class="em">Simulation :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td></td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td></td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td></td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td></td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td></td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>M</td>
                                                <td>P</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procedure tri_extraction(var T : array of Integer) ;
var k,j,indMin : Cardinal ;
begin
    for k := low(T) to high(T)-1 do begin
        indMin := k ;
        for j := k+1 to high(T) do
            if T[j] &lt; T[indMin] then indMin := j {fi}
        {od} ;
        if k &lt;&gt; indMin then echanger(T[indMin],T[k]) {fi}
    end{do}
end ;</code></pre>
                                </li>
                                <li>
                                    <h4>Tri par insertion :</h4>
                                    <p class="em">Principe :</p>
                                    <p>Conceptuellement, la suite des éléments est divisée en deux suites :</p>
                                    <ul>
                                        <li>
                                            <p>une suite déjà triée (suite destination)</p>
                                            <p>t<sub>0</sub>..t<sub>k-1</sub></p>
                                        </li>
                                        <li>
                                            <p>une suite des éléments à insérer (suite source)</p>
                                            <p>t<sub>k</sub>..t<sub>n-1</sub></p>
                                        </li>
                                    </ul>
                                    <p>À chaque étape, on prend le k<sup>ième</sup> élément et on l'insère à sa place dans la suite destination.</p>
                                    <p class="em">Invariant de cet algorithme :</p>
                                    <p>"Après l'étape k, tous les éléments entre la première et la k<sup>ième</sup> position sont triés." Au départ, la suite destination, c'est-à-dire la suite déjà triée est la suite constituée du premier élément.</p>
                                    <p class="em">Simulation :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>S</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td></td>
                                                <td>S</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>L</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                                <td>M</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td></td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procesure Tri_Insertion (var T : array of Integer) ;
var k,j : Cardinal ; valeurAinserer : Integer ;
begin
    for k := low(T)+1 to high(T) do begin
        valeurAinserer := t[k] ;
        j := k ;
        while (j &gt; low(T)) and (valeurAinserer &lt; t[j - 1]) do begin
            t[j] := t[j - 1];
            dec(j)
        end{do};
        t[j] := valeurAinserer
    end{do}
end;</code></pre>
                                </li>
                                <li>
                                    <h4>Tri par permutations ou tri bulles :</h4>
                                    <p class="em">Principe :</p>
                                    <p>Imaginons que les éléments à trier soient rangés dans un tableau vertical et que les éléments dont les clés sont les plus petites soient "moins lourds" et remontent comme des bulles vers la surface. On effectue des passages successifs sur le tableau de bas en haut. À chaque étape, si deux éléments sont en ordre inverse, on les permute.</p>
                                    <p>La conséquence de cette opération est qu'à la fin du premier passage, l'élément le plus léger remonte jusqu'à la première position du tableau. Au deuxième passage, l'élément ayant la deuxième plus petite clé remonte à la deuxième position du tableau, et ainsi de suite...</p>
                                    <p class="em">Simulation :</p>
                                    <p>1<sup>er</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>E</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>E</td>
                                                <td>I</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>E</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>E</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>2<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>L</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>3<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>4<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>5<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>S</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procudure tri_bulles(var T : array of Integer) ;
var k,j : Cardinal ;
begin
    for k := low(T) to high(T)-1 do
        for j := high(T) downto k+1 do
            if T[j] &lt; T[j-1] then echanger(T[j],t[j-1]) {fi}
        {od}
    {od}
end ;</code></pre>
                                </li>
                                <li>
                                    <h4>Méthodologie :</h4>
                                    <p>Le tri sélection et le tri bulles partagent la même hypothèse inductive.</p>
                                    <p>Les éléments de la partie gauche sont supposés définitevement placés (et donc triés).</p>
                                    <p>Cette hypothèse implique que les éléments de la partie droite (non triée) sont des valeurs supérieures.</p>
                                    <img src="../images/methodologie_tri_selection_tri_bulles_Pascal.png" alt="">
                                    <p>L'itération pourra se terminer lorsque la partie droite se réduira au dernier élément du tableau puisque celui-ci est forcément de valeur supérieure.</p>
                                    <p>Quant à l'initialisation, le plus petit sous-tableau gauche pour lequel l'hypothèse est vérifiée ne peut être (conceptuellement) qu'un sous-tableau vide.</p>
                                    <p>Toutes ces considérations nous donnent l'algorithme suivant :</p>
<pre><code>for k := low(T) to pred(high(T)) do
{ placer en T[k] l'élément minimum du sous-tableau droit T[k..N-1] }</code></pre>
                                    <p>C'est dans la façon de rétablir l'invariant que le tri par sélection et le tri bulles se différentient.</p>
                                    <ul>
                                        <li>
                                            <p>Pour le tri de sélection, on recherche séquentiellement l'indice du minimum dans le sous-tableau droit puis on échange, si nécessaire, l'élément minimum avec la valeur de T[k].</p>
                                            <p>C'est la réalisation du PAS INDUCTIF qui nous permet d'agrandir le sous-tableau gauche correspondant à la séquence des éléments déjà traités et donc définivement bien placés.</p>
<pre><code>indMin := k ;
for j := k+1 to high(T) do
    if T[j] &lt; T[indMin] then indMin := j {fi}
{od} ;
if k &lt;&gt; indMin then echanger(T[indMin],T[k]) {fi}</code></pre>
                                            <img src="../images/tri_selection_Pascal.png" alt="">
                                            <p>Pour le tri bulles, on ramène la valeur minimale en position k par échanges successifs.</p>
<pre><code>for j := high(T) downto k+1 do
    if T[j] &lt; T[j-1] then echanger(T[j],T[j-1]) {fi}
{od}</code></pre>
                                            <img src="../images/tri_bulles_Pascal.png" alt="">
                                            <p>Pour le tri par insertion, l'hypothèse inductive est plus faible puisque nous supposons simplement que les éléments du sous-tableau gauche sont triés. (Cela n'implique pas qu'ils soient définitivement bien placés).</p>
                                            <img src="../images/hypothese_inductive_Pascal.png" alt="">
                                            <p>Le pas inductif va correspondre ici à l'insertion de l'élément T[k] dans le sous-tableau T[0..k].</p>
                                            <p>L'itération se terminera lorsque nous aurons insérer le dernier élément du tableau.</p>
                                            <p>Au niveau de l'initialisation, le plus petit sous-tableau gauche pour lequel l'hypothèse est vérifiée correspond au premier élément.</p>
<pre><code>for k := low(T)+1 to high(T) do
    { insérer T[k] dans T[0..k]  }</code></pre>
                                            <p class="em">Rétablissement de l'invariant :</p>
                                            <img src="../images/retablissement_invariant_Pascal_1.png" alt="">
<pre><code>valeurAinserer := t[k] ;
j := k ;</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_2.png" alt="">
<pre><code>while (j &gt; low(T)) and (valeurAinserer &lt; t[j - 1]) do
    begin
        t[j] := t[j - 1] ;
        dec(j)
end {do} ;</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_3.png" alt="">
<pre><code>t[j] := valeurAinserer</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_4.png" alt="">
                                            <p><span class="em">Remarque :</span> les trois algorithmes de tri sont de complexité quadratique (N<sup>2</sup>). Nous en étudierons de plus performants : tri rapide, tri fusion, tri par tas.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Recherche :</h3>
                            <p>Soient les déclarations-définitions suivantes :</p>
<pre><code>
const IndMin = 1 ;
      IndMax = 10 ;
type  Item = Integer ;
      TabItem = array [IndMin..IndMax] of Item ;</code></pre>
                            <p>Soient un ensemble d'éléments représenté par un tableau de type <span class="em">TabItem</span>.</p>
                            <p>Le problème est de trouver un élément du tableau qui soit égal à l'argument de recherche <span class="em">el</span>.</p>
                            <p>En Pascal, nous traduirons le module de recherche d'un élément dans un tableau par une fonction booléenne qui retournera la valeur <span class="em">true</span> si la recherche aboutit et <span class="em">false</span> sinon.</p>
                            <p>Cette fonction Pascal correspond en fait à une "procédure fonctionnelle" car elle retourne également l'indice de l'élément recherché. Cela sera réalisé via un paramètre variable dont la valeur sera significative si et seulement si la recherche a abouti.</p>
                            <p>Pour plus de généralité, le module de recherche reçoit également en entrée les valeurs des indices qui délimitent la portion du tableau dans laquelle la recherche doit être effectuée (<span class="em">et, pour plus de simplicité, les valeurs des indices sont des valeurs entières positives</span>).</p>
                            <img src="../images/recherche_Pascal.png" alt="">
                            <ol>
                                <li>
                                    <h4>Recherche séquentielle ou linéaire :</h4>
                                    <p>La méthode la plus simple consiste à explorer séquentiellement le tableau. Si plusieurs composants du tableau correspondent à l'élément recherché, c'est celui d'indice le plus bas (le premier rencontré) qui sera "retourné".</p>
                                    <p>Deux conditions permettent d'arrêter cette recherche linéaire :</p>
                                    <ol>
                                        <li>
                                            <p>on a trouvé l'élément</p>
                                        </li>
                                        <li>
                                            <p>on a parcouru le tableau sans trouver l'élément</p>
                                        </li>
                                    </ol>
                                    <p>L'algorithme devient :</p>
                                    <ul>
                                        <li>
                                            <p>initialiser <span class="em">IndEl</span> à la valeur de <span class="em">IndDeb</span></p>
                                        </li>
                                        <li>
                                            <p>
                                                <span class="em">tant que</span> le tableau n'a pas été totalement parcouru et que l'élément n'a pas été trouvé
                                                <p class="em">faire</p>
                                                <p>continuer la recherche</p>
                                                <p class="Em">ftant</p>
                                            </p>
                                        </li>
                                        <li>
                                            <p>si le tableau n'a pas été vainement parcouru, la fonction retourne la valeur <span class="em">true</span> et la valeur de <span class="em">IndEl</span> correspond à la valeur de l'indice de l'élément recherché, sinon la fonction retourne la valeur <span class="em">false</span>.</p>
                                        </li>
                                    </ul>
                                    <p>La condition "le tableau n'a pas été totalement parcouru" correspond à (<span class="html">IndEl &lt;= IndFin</span>) et la condition "l'élément n'a pas été trouvé" à (<span class="html">t[IndEl] &lt;&gt; el</span>).</p>
                                    <p>Quant à l'action "continuer recherche", elle se traduit par l'incrémentation de <span class="em">IndEl</span> c'est-à-dire par l'instruction <span class="html">inc(IndEl)</span>.</p>
<pre><code>function Recherche_Lineaire
(   const T : TabItem ;
    IndDeb,IndFin : Cardinal ;
    el : item;
    var IndEl : Cardinal
) : Boolean;
{recherche la première occurence de l'item el dans le tableau T entre les indices IndDeb et IndFin, si l'item est trouvé, l'indice correspondant est stocké dans IndEl et la fonction retourne vrai, sinon la fonction retourne faux et la valeur de IndEl est non significative}

begin
    IndEl := IndDeb ;
    while (IndEl &lt;= IndFin) and (t[IndEl] &lt;&gt; el ) do
        inc(IndEl)
    {od} ;
    { (IndEl &gt; IndFin) or (T[IndEl] = el)
       évaluation optimisée
       (IndEl &gt; IndFin) or ( (IndEl &lt;= IndFin) and (T[IndEl] = el) ) }
    Result := IndEl &lt;= IndFin
end;</code></pre>
                                    <p>Il existe une autre version de la recherche linéaire qui utilise une sentinelle que l'on ajoute en fin de tableau. Il suffit d'insérer dans cette emplacement supplémentaire la valeur recherchée... ce qui simplifie la condition de continuation de la boucle de recherche.</p>
<pre><code>while (T[IndEl &lt;&gt; El) do ...</code></pre>
                                </li>
                                <li>
                                    <p>Si les données sont ordonnées (si le tableau est <span class="em">trié</span>), la recherche sera certainement plus efficace (complexité logarithmique). Pensez à l'annuaire téléphonique !</p>
                                    <p>La recherche dichotomique est une méthode de recherche qui fait l'hypoth!se que le tableau est ordonné.</p>
                                    <p>L'idée de base est de prendre l'élément au milieu (<span class="em">t[IndEl]</span>) de la portion de tableau où l'élément à rechercher (<span class="em">el</span>) peut se trouver.</p>
                                    <ul>
                                        <li>
                                            <p>Si cet élément du milieu est égal à <span class="em">el</span>, la recherche est terminée;</p>
                                        </li>
                                        <li>
                                            <p>S'il est inférieur à <span class="em">el</span>, on en déduit que tous les éléments dont l'indice est inférieur ou égal à milieu peuvent être éliminés des recherches futures.</p>
                                        </li>
                                        <li>
                                            <p>Si l'élément du milieu est supérieur à 
                                            <span class="em">el</span>, la recherche se poursuit dans la portion du tableau délimitée par les valeurs d'indice (<span class="em">IndDeb</span>) et (<span class="em">IndEl-1</span>).</p>
                                        </li>
                                    </ul>
                                    <p>Ainsi, à chaque itération, les paramètres <span class="em">IndDeb</span> et <span class="em">IndFin</span> seront les indices "gauche" et "droite" de la portion de tableau dans laquelle on peut encore espérer trouver l'élément recherché.</p>
<pre><code>function Recherche_dichotomique
(   const T : TabItem ;
    IndDeb,IndFin : Cardinal ;
    el : item;
    var IndEl : Cardinal
) : Boolean;
{recherche une occurence de l'item el dans le tableau T entre les indices IndDeb et IndFin; si l'item el est trouvé, l'indice correspondant est stocké dans IndEl et la fonction retourne vrai, sinon la fonction retourne faux et la valeur de IndEl est non significative}
begin
    Result := false
    while (IndDeb &lt;= IndFin) and not Result do begin
        IndEl := (IndDeb + IndFin) div 2;
        if T[IndEl] &lt; el then IndDeb := IndEl + 1
        else if T[IndEl] &gt; el then IndFin := IndEl - 1
        else {T[indEl] = el } Result := True
    end{do}
end;</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Problèmes d'adaptation :</h3>
                            <p>Les procédures de tri ont été présentées de manière générale en utilisant les paramètres tableaux ouverts. Il est bien certain que vous aurez à adapter ces procédures à des types particuliers de tableaux. Un cas fréquent est celui des tableaux dont tous les éléments ne sont pas significatifs et dont l'utilisation nécessite la connaissance de la longueur effective.</p>
<pre><code>program d_adaption ;
{$APPTYPE CONSOLE}

const INDMAX = 100 ;
type TabInt = array[1..INDMAX] of Integer ;

<span class="em">procedure Tri_Insertion
(var T : TabInt ; lgEff : Cardinal);</span>
var k,j : Cardinal ; valeurAinserer : Integer ;
begin
    for k := 2 to lgEff do begin
        valeurAinserer := t[k] ;
        j := k ;
        while (j &gt; 1) and (valeurAinserer &lt; t[j-1]) do
        begin
            t[j] := t[j - 1];
            dec(j);
        end{do};
        t[j] := valeurAinserer
    end{do}
end;

<span class="em">procedure afficherTabInt
(const T : TabInt ; lgEff : Cardinal) ;</span>
var k : Cardinal ;
begin
    for k := 1 to lgEff do write(T[k]:4) ;
    writeLn
end ;

<span class="em">procedure initialiserTabInt
(out T:TabInt;out lgEff;Cardinal;
 const TT:array of Integer);</span>
var k : Cardinal ;
begin
    lgEff := high(TT) + 1 ;
    for k := 1 to lgEff do T[k] := TT[k-1] ;
end ;

var A : TabInt ; lg : Cardinal ;
begin
    initialiserTabInt(A,lg,[5,1,4,2,8,3]) ;
    afficherTabInt(A,lg) ;
    writeLn ;
    tri_Insertion(A,lg) ;
    afficherTabInt(A,lg) ;
    readLn
end.</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="lazarus">Lazarus :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p><span class="em">Free Pascal</span> est un compilateur de code source Pascal, acoompagné de nombreux outils. Même s'il accepte d'anciennes versions de Pascal, il est avant tout conçu pour traiter du Pascal Objet. <span class="em">Lazarus</span> est quant à lui un <span class="em">E.D.I.</span></p>
                            <p>Un <span class="em">E.D.I.</span> (cet acronyme est si souvent employé qu'il est en général écrit sous la forme condensée EDI) ou <span class="em">Environnement de Développement Intégré</span> rassemble en une seule application les différents outils nécessaires au développement : un éditeur de code, un débogueur, un compilateur, etc.</p>
                            <p>Lazarus est un E.D.I. qui se sert de Free Pascal comme compilateur sous-jacent. Allié à Free Pascal, il a toujours cherché à s'approcher le plus possible de son grand frère commercial Delphi. S'il est moins puissant que ce dernier, il a certaines qualités propres qui ne sont pas négligeables :</p>
                            <ul>
                                <li>
                                    <p>il est <span class="em">open source</span>, c'est-à-dire que le programmeur a accès au code qui a permis de le générer;</p>
                                </li>
                                <li>
                                    <p>il est lui-même écrit en Pascal;</p>
                                </li>
                                <li>
                                    <p>il intègre les fonctionnalités essentielles d'un langage moderne;</p>
                                </li>
                                <li>
                                    <p>il permet de produire gratuitement toutes sortes d'applications, y compris commerciales;</p>
                                </li>
                                <li>
                                    <p>il fonctionne directement avec bon nombre de machines et de systèmes d'exploitation (dont Windows, Linux et MacOS);</p>
                                </li>
                                <li>
                                    <p>il gère du code exploitable tel que, idépendamment de la plateforme utilisée, selon le principe d'une base de code unique, quel que soit le système d'exploitation visé</p>
                                </li>
                                <li>
                                    <p>il est extensible grâce à un ensemble important de bibliothèques développées parallèlement par une foule de contributeurs;</p>
                                </li>
                                <li>
                                    <p>il bénéficie d'une communauté d'utilisateurs internationale très active (pour les pays francophones, la référence est <a href="https://lazarus.developpez.com/">https://lazarus.developpez.com/</a> où les auteurs de l'ouvrage se retrouvent fréquemment);</p>
                                </li>
                                <li>
                                    <p>il est traduit en français, comme dans plus d'une vingtaine de langues.</p>
                                </li>
                            </ul>
                            <p>Par ailleurs, au-delà de leurs qualités indéniables, nous pensons que Free Pascal et Lazarus permettent de s'amuser à programmer en conservant ce qui avait fait le succès de leurs ancêtres : un langage très proche de la réflexion algorithmique et des outils faciles à exploiter, y compris par un débutant.</p>
                        </li>
                        <li>
                            <h3>Installer Lazarus :</h3>
                            <p>L'installation de l'E.D.I. Lazarus est en général aussi simple que celle de n'importe quelle autre application. C'est la seule phase où le système d'exploitation joue à plein. Avec Windows et Linux, vous devriez être capable de l'effectuer en un rien de temps. Avec MacOS, les opérations devraient prendre plus de temps à cause du nombre d'étapes à accomplir pour une installation complète.</p>
                            <p>Quel que soit votre système d'exploitation, il est vivement conseillé d'installer la toute dernière version <span class="em">stable</span> de Lazarus. Pour cela rendez-vous sur <a href="https://lazarus-ide.org/" target="_blank">le site officiel de Lazarus</a> pour télécharger la version stable correspondant à votre système.</p>
                            <p>L'installation sous d'autres systèmes d'exploitation est prévue par les concepteurs de Free Pascal et de Lazarus, mais, pour l'instant, nous nous sommes limotés aux trois systèmes les plus fréquemment utilisés sur PC.</p>
                        </li>
                        <li>
                            <h3>Organisation générale de l'interface de Lazarus :</h3>
                            <ol>
                                <li>
                                    <h4>Premier lancement de Lazarus :</h4>
                                    <p>L'installation de Lazarus terminée, quel que soit le système d'exploitation utilisé, lancez son exécution. La première fois, une fenêtre de vérification de la <span class="em">configuration</span> peut s'afficher. Sur les versions antérieures à la version 2.2.2 de Lazarus, cet affichage était systématique.</p>
                                    <p>Voici les répertoires utilisés lorsque Lazarus est installé en laissant les options par défaut :</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Sections</th>
                                                <th>Windows</th>
                                                <th>Linux</th>
                                                <th>MacOS</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td class="em">Lazarus</td>
                                                <td>C:\lazarus</td>
                                                <td>/usr/bin/lazarus</td>
                                                <td>/usr/local/share/lazarus</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Compilateur</td>
                                                <td>C:\lazarus\fpc\3.2.2\bin\x86_64-win64\fpc.exe</td>
                                                <td>/usr/bin/fpc</td>
                                                <td>/usr/local/share/fpc</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Codes sources de FPC</td>
                                                <td>C:\lazarus\fpc\3.2.2\source</td>
                                                <td>/usr/lib/fpc/src</td>
                                                <td>/user/local/share/fpcsrc</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Make</td>
                                                <td>C:\lazarus\fpc\3.2.2\bin\x86_64-win64\make.exe</td>
                                                <td>/usr/bin/make</td>
                                                <td>/usr/bin/make</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Débogueur</td>
                                                <td>C:\lazarus\mingw\x86_64-xin64\bin\gdb.exe</td>
                                                <td>/usr/bin/gdb</td>
                                                <td>(dépend de votre installation)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Lorsque tout est correct, cliquez sur le bouton "Démarrer l'EDI" en bas à droite.</p>
                                    <p>À partir de maintenant, les différence entre les systèmes d'exploitation deviennent négligeables. Vous pourrez donc vous concentrer sur la programmation, les mains dans le cambouis et le cerveau en pleine ébullition !</p>
                                </li>
                                <li>
                                    <h4>La fenêtre principale :</h4>
                                    <p>En haut de l'écran se présente une large fenêtre nommée "EDI Lazaus v2.2.2 - project1". C'est la <span class="em">fenêtre principale</span> de Lazarus, qui est toujours visible.</p>
                                    <figure>
                                        <img src="../images/fenetre_principale_Lazarus.png" alt="">
                                        <figcaption>Fenêtre principale de Lazarus</figcaption>
                                    </figure>
                                    <p>Cette fenêtre présente :</p>
                                    <ul>
                                        <li>
                                            <p>une barre de <span class="em">menus</span> (de "Fichier" à "Aide");</p>
                                        </li>
                                        <li>
                                            <p>à gauche, des icônes réparties en deux bandes : ce sont des <span class="em">boutons de raccourcis</span> qui évitent de naviguer dans les menus pour les fonctionnalités les plus courantes</p>
                                        </li>
                                        <li>
                                            <p>à droite, les onglets de la palette des composants (par la suite, la "palette de composants" sera souvent appelée plus simplement la "palette") : chaque bouton illustré par une icone représente un outil appelé <span class="em">composant</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Un <span class="em">composant</span> d'application est un élément prêt à l'emploi, comme une liste déroulante, une grille, un bouton, un calendrier, etc. Lazarus en propose d'origine plus de deux cents, d'où la nécessité de les regrouper par familles dans la palette.</p>
                                </li>
                                <li>
                                    <h4>La fiche de travail :</h4>
                                    <p>La <span class="em">fiche</span> en cours de conception est la fenêtre vide remplie de petits points que vous voyez sous la fenêtre principale et qui porte le titre de "Form1".</p>
                                    <img src="../images/fiche_initiale_mode_conception_Lazarus.png" alt="">
                                    <p>Cette <span class="em">fiche de travail</span> est un outil puissant qui permet de composer une grande partie de l'apparence de l'application finale. Elle recueillera, lors de la phase de <span class="em">conception</span>, les composants nécessaires à l'application en cours de réalisation. À l'<span class="em">exécution</span>, elle ne montrera plus les points qui servent de guide lors de la conception.</p>
                                    <p>La <span class="em">conception</span> est la phase de préparation durant laquelle le programmeur dépose les composants nécessaires sur la fiche de travail à l'emplacement voulu, établit la valeur de leurs propriétés et rédige le code nécessaire au fonctionnement de l'ensemble.</p>
                                    <p>L'<span class="em">exécution</span> est l'étape durant laquelle le code est exécuté après avoir été compilé. Les composants prennent alors l'apparence qu'ils ont dans toute application, à savoir un mélange entre le style fixé par le système d'exploitation et l'aspect que leur impose le code créé.</p>
                                    <p>La fiche de départ est appelée <span class="em">fiche principale</span> c'est toujours à partir d'elle qu'elle démarre une application. D'autres fiches peuvent compléter la fiche principale et être utilisées selon les besoins.</p>
                                    <p>Une <span class="em">fiche</span> est en fait un composant particulier dont le nom de base est <span class="html">TForm</span>. Voilà pourquoi une fiche est parfois aussi appelée une "<span class="em">forme</span>".</p>
                                </li>
                                <li>
                                    <h4>L'inspecteur d'objets :</h4>
                                    <p>À gauche de votre espace de travail se tient une fenêtre nommée <span class="em">inspecteur d'objets</span>.</p>
                                    <p>L'<span class="em">inspecteur d'objets</span> est un lieu d'observation essentiel, qui permet de définir l'aspect visuel et le comportement des composants.</p>
                                    <figure>
                                        <img src="../images/inspecteur_objets_Lazarus.png" alt="">
                                        <figcaption>L'inspecteur d'objets</figcaption>
                                    </figure>
                                    <p>Cette fenêtre est divisée en deux parties.</p>
                                    <p>La partie supérieure ("Composants") décrit sous la forme d'une arborescence la hiérarchie des composants déposés sur la fiche de travail. Celui en cours d'examen y apparaît en surbrillance. Pour le moment n'y figure que la fiche de travail par défaut "Form1".</p>
                                    <p>La partie inférieure est divisée en quatre onglets dont seuls les deux premiers nous intéresseront.</p>
                                    <p>L'onglet "Propriétés" permet d'examiner ey de modifier les <span class="em">propriétés</span> du composant actif.</p>
                                    <p>Une <span class="em">propriété</span> représente un attribut du composant : elle concerne entre autres son aspect, sa position ou ses dimensions. Par exemple, de nombreux composants possèdent une propriété <span class="em">Visible</span> qui indique si le composant sera visible ou non à l'exécution.</p>
                                    <p>Dans l'inspecteur d'objets, les propriétés sont rangées <span class="em">par ordre alphabétique</span> ce qui facilite leur recherche.</p>
                                    <p>L'onglet "Événements" permet d'ajouter des comportements spécifiques liés aux <span class="em">événements</span>. Pour traiter un événement, il faut en effet prévoir le code à exécuter dans le gestionnaire qui lui correspond.</p>
                                    <p>Pour rappel, un <span class="em">événement</span> est une réaction à une action de l'utilisateur (par exemple, lorsqu'il déplace sa souris), à une condition interne de l'application ou à un message du système d'exploitation lui-même.</p>
                                    <p>L'<span class="em">inspecteur d'objets</span> est si utilisé qu'une touche est dédiée à son affichage. Il suffit en effet de presser la touche <span class="em">F11</span> pour le rendre visible. Vous pouvez aussi utiliser l'option "Inspecteur d'objets" du menu "Voir" pour le même résultat.</p>
                                </li>
                                <li>
                                    <h4>L'éditeur de source :</h4>
                                    <p>Au centre de l'environnement de travail, vous disposez de l'<span class="em">éditeur de source :</span></p>
                                    <figure>
                                        <img src="../images/editeur_source_Lazarus.png" alt="">
                                        <figcaption>L'éditeur de source</figcaption>
                                    </figure>
                                    <p>Comme son nom l'indique, cette fenêtre contient l'<span class="em">éditeur</span>, c'est-à-dire l'outil de rédaction du code informatique nécessaire à l'application. Ce code étant à l'origine de l'application, il est appelé <span class="em">code source</span> ou plus simplement <span class="em">source</span>.</p>
                                    <p>L'<span class="em">éditeur de source</span> est une sorte de traitement de texte dont toutes les fonctionnalités tendent à faciliter la saisie et la correction du code. Par exemple, il utilise la <span class="em">coloration syntaxique</span> pour distinguer des catégories d'éléments.</p>
                                    <p>Les fichiers à éditer les plus courants sont les <span class="em">unités</span>.</p>
                                    <p>L'<span class="em">unité</span> constitue la brique de base d'un projet. Elle adopte une structure particulière dont nous étudierons l'organisation plus tard. À chaque unité correspond un fichier unique.</p>
                                    <p>Par défaut, la première unité s'appelle "unit1" et correspond à la fiche "Form1". Une unité contient le code en Pascal nécessaire pour accomplir les tâches qui lui incombent.</p>
                                    <p>Si une fiche est toujours accompagnée d'une unité, la réciproque n'est pas vraie : vous pourrez créer des unités d'utilitaires qui n'ont pas besoin d'être présents sur une fenêtre, mais qu'il vous paraîtra utile de regrouper. Par exemple, une unité contiendra des fonctions mathématiques et une autre des outils pour le dessin.</p>
                                    <p>L'éditeur est capable de gérer plusieurs fichiers indiqués par des ongleys portant leur nom. Vous pourrez par conséquent naviguer facilement d'un fichier à l'autre, tout simplement en cliquant sur l'onglet visé.</p>
                                    <p>La <span class="em">commutation d'une fiche à son unité</span> (et réciproquement) s'opère par une pression sur la touche <span class="em">F12</span> ou par l'option "Commuter Fiche/Unité" du menu "Voir". Si aucune fiche n'est rattachée à l'unité en cours, cette option est désactivée.</p>
                                    <figure>
                                        <img src="../images/organisation_generale_EDI.png" alt="">
                                        <figcaption>Organisation générale de l'E.D.I.</figcaption>
                                    </figure>
                                    <p>L'illustration ci-dessus reprend les quatre éléments fondamentaux de l'E.D.I. en montrant les liens qui les unissent au <span class="em">projet informatique</span> qui sera bientôt le vôtre. Les interactions entre les unités n'ont pas été représentées. Ce projet comprend des fiches accompagnées de leur unité (ici, au nombre de trois), ainsi que des unités d'outils sans fiches (ici, deux).</p>
                                    <p>Le <span class="em">projet</span> est l'ensemble des fichiers personnalisés rattachés à la production d'une application particulière. Il existe en effet plusieurs fichiers utilisés. Certains sont propres à l'application en cours de développement et d'autres font partie de Lazarus, de Free Pascal ou des éventuels outils complémentaires que vous aurez installés. Ces derniers fichiers sont permanents est stockés dans des dossiers spécifiques.</p>
                                </li>
                            </ol>
                            <p>La <span class="em">fenêtre principale</span>, la <span class="em">fiche de conception</span>, l'<span class="em">inspecteur d'objets</span> et l'<span class="em">éditeur de source</span> sont les quatre outils indispensables à tout développement avec Lazarus. S'il en existe bien d'aytres, l'E.D.I. perdrait tout intérêt sans ceux-là.</p>
                            <p>Vous voici donc maître du tableau de bord. Il vous reste à piloter Lazarus et à découvrir la puissance de son moteur; à savoir Free Pascal !</p>
                        </li>
                        <li>
                            <h3>Une application de bienvenue :</h3>
                            <p>Après l'installation et la découverte du tableau de bord, il est enfin temps de faire un tout petit tour de conduire accompagnée.</p>
                            <p>Précisons d'emblée que les programmes que vous apprendrez à écrire ici seront essentiellement des <span class="em">applications graphiques</span>.</p>
                            <p>Les <span class="em">applications graphiques</span> sont celles que vous utilisez probablement tous les jours. Elles font appel au <span class="em">système de fenêtrage</span> ainsi qu'à des <span class="em">contrôles</span> (des éléments visuels tels que boutons, boîtes listes, cases à cocher, etc.) que l'utilisateur peut sélectionner par différents biais (clavier, souris, doigt...).</p>
                            <p>La première d'entre elles se pliera à la tradition en programmation qui veut que l'apprenti(e) développeur(se) commence par réaliser une application de bienvenue. Ce genre d'application minimaliste s'inscrit dans la tradition des petits programmes de test et a été inauguré par Brian Kernighan et Dennis Ritchie dans leur ouvrage "The C Programming Language" (voir <a href="https://fr.wikipedia.org/wiki/Hello_world" target="_blank">https://fr.wikipedia.org/wiki/Hello_world</a> pour des informations complémentaires).</p>
                            <p>Nous sommes sûrs que vous avez hâte de passer à l'action ! Stop ! Arrêt sur image... Concevoir un loigiciel, ce n'est pas se jeter tête baissée et commencer à coder tout de suite, même si l'envie en est pressante. "Hou, les vilains rabat-joie !", direz-vous. Nous avons conscience de votre frustration, mais vous nous remercierez un jour, soyez-en assuré(e).</p>
                            <p>Avant toute chose, il vous faut prendre le temps de la réflexion :</p>
                            <ul>
                                <li>
                                    <p>Que doit faire mon logiciel ? Ainsi-je bien analysé tous les besoins exprimés par mon "client" ? Lui ai-je bien, avant cela, posé les bonnes questions pour qu'il les exprime ?</p>
                                </li>
                                <li>
                                    <p>Quelles plateformes et technologies suis-je obligé(e) d'utiliser ou puis-je éventuellement choisir ?</p>
                                </li>
                                <li>
                                    <p>Existe-t-il du code tout fait ou des composants utilisables pour me permettre de gagner du temps ?</p>
                                </li>
                                <li>
                                    <p>Comment organiser mon code source et le découper en blocs logiques ?</p>
                                </li>
                                <li>
                                    <p>Comment faciliter une évolution future du logiciel, l'ajout de nouvelles fonctionnalités ?</p>
                                </li>
                            </ul>
                            <p>Une fois que vous aurez une idée précise de la conception de votre logiciel, vous pourrez commencer à écrire du code. Mais le processus de réflexion sera loin d'êtrer terminé : pour chaque traitement, il faudra chercher le meilleur algorithme, peut-être regrouper certaines actions, identifier les endroits où il sera primordial d'optimiser la vitesse de traitement, etc.</p>
                            <p>Il est vrai qsue toutes cces concidérations vous concerneront beaucoup plus tard, mais il ne sera pas inutile de les garder dans un coin de votre esprit durant la réalisation des petits exercices de cette page.</p>
                            <p>Faites-nous plaisir en vous efforçant de suivre ce conseil : avant d'écrire en Pascal, formulez le problème en <span class="em">français</span>, traduisez-le en <span class="em">pseudo-code</span> et couchez-le sur papier. Le passage au Pascal ne sera alors plus qu'une formalité.</p>
                            <p>Le <span class="em">pseudo-code</span> est une façon d'écrire un algorithme dans un langage proche du langage courant, mais légèrement formalisé. Il est couramment employé en algorithme pour résoudre un problème avant sa transposition dans un langage informatique particulier.</p>
                            <ol>
                                <li>
                                    <h4>Concevoir l'application :</h4>
                                    <p>L'application à concevoir est rudimentaire puisqu'il s'agit tout simplement d'afficher "Bonjour, monde !" sur la fenêtre principale. Il se trouve d'ailleurs qu'il existe une sérieuse candisate pour cette tâche, à savoir la propriété <span class="html">Caption</span> de la fiche, qui permet de changer sa barre de titre.</p>
                                    <p>Pour élaborer notre application, nous partirons de la fiche par défaut de Lazarus.</p>
                                    <p>Depuis l'onglet "Propriétés" de l'inspecteur d'objets, cherchez <span class="em">Caption</span> dans la liste des propriétés de la fiche (rappelez-vous que les propriétés d'un composant sont rangées par ordre alphabétique). Modifiez sa valeur en "Bonjour, monde !", comme montré ci-après, et appuyez sur la touche <span class="em">Enter</span> pour valider le changement :</p>
                                    <figure>
                                        <img src="../images/modification_propriete_Lazarus.png" alt="">
                                        <figcaption>Modification d'une propriété</figcaption>
                                    </figure>
                                </li>
                                <li>
                                    <h4>Créer un projet :</h4>
                                    <p>En premier lieu, si nous avions pas de projet ouvert, nous allons créer une nouvelle application.</p>
                                    <p>Pour créer le projet qui lui correspond, choisissez le menu "Projet" de Lazarus puis sélectionnez "Nouveau projet..." :</p>
                                    <figure>
                                        <img src="../images/creation_projet_Lazarus.png" alt="">
                                        <figcption>La création d'un projet</figcption>
                                    </figure>
                                    <p>Si une boîte de dialogue vous demande si vous désirez enregistrer votre travail, cliquez simplement sur le choix correspondant à votre situation.</p>
                                    <p>La boîte de dialogue correspondant à la création d'un projet va alors apparaître :</p>
                                    <figure>
                                        <img src="../images/boite_creation_projet_Lazarus.png" alt="">
                                        <figcaption>La boîte de création d'un projet</figcaption>
                                    </figure>
                                    <p>Comme sur l'image ci-dessus, choisissez "Application" puis cliquez sur "OK". Tout ancien travail disparaît et vous vous retrouvez devant l'environnement de travail de vos début.</p>
                                    <p>Dans le point suivant, on va sauver ce squelette d'application dans un dossier spécifique. Ensuite, la création du projet sera terminée.</p>
                                </li>
                                <li>
                                    <h4>Sauvegarder le projet en cours :</h4>
                                    <p>La sauvegarde du projet en cours est très simple elle aussi. Il s'agit d'une étape essentielle, car rien n'est plus désagréable que de perdre des heures de travail. Pour le moment, ce serait loin d'être le cas, mais les bonnes habitudes sont à prendre dès maintenant !</p>
                                    <p>Tout d'abord, créez un dossier spécifique pour le projet (par exemple, <span class="em">01 - Bonjour</span>). En effet, un projet étant toujours constitué de plusieurs fichiers, il serait risqué d'enregistrer votre travail directement sur le bureau ou dans des dossiers partagés : chaque projet doit avoir son propre dossier.</p>
                                    <p>Depuis la fenêtre principale de Lazarus, allez dans "Enregistrer le projet" du menu "Projet".</p>
                                    <p>Pour <span class="em">tout sauvegarder</span>, vous pouvez aussi cliquer sur l'icône avec les doubles disquettes dans la barre d'outils de la fenêtre principale de Lazarus ou utiliser la combinaison de touches <span class="em">CTRL + MAJ + S</span>.</p>
                                    <p>Une première boîte de dialogue vous demande d'entrer un nom de fichier pour le projet. L'extension .lpi correspond à <span class="em">Lazarus Project Information</span>, indiquant ainsi que le fichier contient les informations relatives à un projet Lazarus. Ce nom sera également le nom du fichier de l'exécutable de votre application.</p>
                                    <p>Choisissez le dossier que vous avez créé pour votre projet et tapez <span class="em">BonjorMonde</span> comme nom de fichier (son extension sera automatiquement <span class="html">.lpi</span>).</p>
                                    <p>Une seconde boîte de dialogue vous demande de saisir un nom pour l'unité : c'est le fichier qui contiendra le code source de votre fiche et dont l'extension sera <span class="html">.pas</span> (pour <span class="em">PAScal</span>). Tapez <span class="em">ufrmPrincipale</span> comme nom d'unité. Ce nom d'unité devient aussi, sans autre intervention de votre part, le nom ajouté après le mot <span class="html">unit</span> au tout début du source dans l'éditeur de code.</p>
                                    <p>Cette <span class="em">identité entre le nom de l'unité et le nom du fichier</span> sans son extension est obligatoire. Les deux ne peuvent contenir ni espaces ni caractères accentués.</p>
                                    <p>Une mauvaise idée serait de conserver les noms fournis par défaut par Lazarus : le temps gagné serait largement perdu lorsque vous voudriez retrouver ce que vous avez fait, tous les projets et toutes les fiches portant alors des noms similaires, sans indiquer leur fonction. Adoptez donc des <span class="em">noms aussi expliite que possible</span> !</p>
                                    <p>Il est imposible d'ignorer la propriété <span class="em">Name</span>, car elle est commune à tous les composants. C'est elle qui fournit un nom spécifique à un objet.</p>
                                    <p>Ce nom doit être un <span class="em">identificateur</span> correct.</p>
                                    <p>L'<span class="em">identificateur</span> est le nom qui permet d'identifier sans ambiguïté chaque élément d'un projet. C'était par exemple le cas du nom de l'unité <span class="em">ufrmPrincipale</span>.</p>
                                    <p>Un identificateur doit commencer par une lettre non accentuée et uniquement contenir des caractères alphabétiques (A à Z, en majuscules ou minuscules, non accentués),  des chiffres (0 à 9), ainsi que le caractère de soulignement (_).</p>
                                    <p>Remarsue : Le Pascal Objet ne fait <span class="em">pas de différence entre les majuscules et les minuscules</span>. Par conséquent, Ab est pour lui identique à aB. D'autre part, il est <span class="em">interdit de choisir comme identificateur un des mots réservés</span> du Pascal Objet.</p>
                                    <p>Par défaut, le nom d'une fiche est de la forme <span class="em">FormX</span> où <span class="em">X</span> est un nombre entier. Ainsi, <span class="em">Form1</span> est celui de la première fiche créée. Ce nom proposé par Lazarus n'indiquant rien sur sa fonction, il est vivement conseillé de l'adapter à son rôle dans le programme. Des noms comme <span class="em">Principale</span>, <span class="em">Impression</span> et <span class="em">Options</span> seront plus parlants que <span class="em">Form1</span>, <span class="em">Form2</span> ou <span class="em">Form3</span>, surtout lorsque le temps sera passé par là pour détruire sournoisement quelques neurones et synapses !</p>
                                    <p>Par convention, les <span class="em">identificateurs</span> suivent la technique appelée <span class="em">camel case</span>, c'est-à-dire que chaque mot qui forme l'identificateur commence par une majuscuele suivie de minuscules (par exemple : <span class="em">CalculDuLoyer</span>).</p>
                                    <p>Pour les composants (dont les fiches), afin de bien les distinguer des autres éléments, nous avons choisi la variante <span class="em">lower camel case</span> selon laquelle le premier mot est entièrement en minuscules. Ainsi, une fiche sera nommée avec un préfixe en minuscules <span class="em">frm</span> (pour <span class="em">Form</span>) suivi de son nom. Par exemple, la fiche principale sera nommée <span class="em">frmPrincipale</span>.</p>
                                    <p>L'unité qui se rapporte à la fiche portera le même nom que la fiche, mais précédé d'un <span class="em">u</span> pour unité. Voilà l'explication du nom <span class="em">ufrmPrincipale</span> donné à l'unité de notre première application.</p>
                                    <p>Pour prendre de bonnes habitudes, renommez la fiche de l'application de bienvenue grâce à sa propriété <span class="em">Name</span>en lui donnant la valeur <span class="em">frmPrincipale</span>. Appuyez sur la touche <span class="em">Enter</span> afin de valider ce changement.</p>
                                    <p>Une fois l'ensemble validé, le projet est sauvegardé.</p>
                                </li>
                                <li>
                                    <h4>Compiler et exécuter l'application :</h4>
                                    <p>Lancez la compilation et l'exécution de l'application en choisissant l'option "Exécuter" du menu "Exécuter", en cliquant l'icône avec un triangle vert ou encore en pressant sur la touche <span class="em">F9</span>.</p>
                                    <p>Voici une capture de l'application en cours d'exécution :</p>
                                    <figure>
                                        <img src="../images/application_bienvenue_Lazarus.png" alt="">
                                        <figcaption>Application de bienvenue</figcaption>
                                    </figure>
                                    <p>Bravo ! Vous avez écrit votre première application en Pascal Objet !</p>
                                    <p>Lors de la compilation est apparue, en bas de l'écran, une fenêtre de lazarus intitulée "Messages". La <span class="em">fenêtres des messages</span> permet notamment de visualiser les erreurs de syntaxe dans l'éditeur de code. Elle indique également le résultat, les avertissements et les conseils fournis par le compilateur Free Pascal lors de la compilation de vos applications.</p>
                                    <figure>
                                        <img src="../images/2etats_fenetre_messages_Lazarus.png" alt="">
                                        <figcaption>Deux états de la fenêtre des messages</figcaption>
                                    </figure>
                                    <p>Sur l'illustration ci-dessus, la fenêtre a été capturée lors d'une erreur de compilation, puis après une compilation réussie.</p>
                                    <p>Vous pouvez toujours faire apapraître la fenêtre des messages grâce à <span class="em">l'option "Messages" du menu "Voir"</span>.</p>
                                    <p>Peut-être vous sentez-vous frustré(e) de n'avoir rien d'autre à faire... Constatez malgré cette frustration que l'application a rempli le (maigre) rôle qui lui était imparti. Après tout, nous ne lui avions demandé que de saluer le monde !</p>
                                    <p>Cependant, à bien y réfléchir, ce qui s'est produit est plutôt mystérieux. Si vous vous rendez dans le dossier où a été configuré le projet, vous y trouverez entre autres un exécutable : alros que nous n'avons fait que modifier une propriété, d'où provient cet exécutable autonome complet ? Quelles énigmes se cachent derrière les autres fichiers présents ?</p>
                                    <p>De plus, bien que sans prétention, notre application dispose d'emblée de quelques fonctionnalités remarquables. Pour les découvrir, déplacez, redimensionnez, cachez et faites réapparaître sa fenêtre d'exécution. Sans une seule ligne de code de votre part, elle possède déjà les propriétés de n'importe quelle fenêtre ! Comment tout ceka est-il possible ?</p>
                                    <p>Pas plus que votre ordinateur ne démarre par miracle, il n'existe de magie en programmation. En plus, le petit tour promis s'accompagne d'une heureuse confirmation de ce que nous avions annoncé : Lazarus et Free Pascal prennent en charge de nombreux aspects de l'élaboration d'une application, en particulier ce qui ressort de la communication avec le système d'exploitation.</p>
                                    <p>À ce stade de votre apprentissage, retenez qu'un E.D.I. vous évite d'accomplir des tâches aussi rébarbatives et complexes que de synchroniser les parties constitutives d'une application, construire une fenêtre ou s'occuper de son comportement de base.</p>
                                </li>
                                <li>
                                    <h4>Arrêter une application :</h4>
                                    <p>Pour retourner au poste de pilotage, fermez cette première application. Une fenêtre vous indique que son exécution a été interrompue. Vous pouvez désactiver ce comportement en cliquant sur le bouton intitulé "Ne plus montrer ce message" ou le conserver en cliquant sur "OK". Dans les deux cas, vous voici de nouveau en mesure de travailler.</p>
                                    <p>L'<span class="em">interruption de l'application</span> est également accessible en cliquant sur l'icône en forme de carré rouge, particulièrement utile si elle ne parvenait pas à être fermée d'une autre manière. Vous pouvez aussi utiliser la combinaison de touches <span class="em">CTRL + F2</span> ou encore passer par l'option "Arrêter" du menu "Exécuter".</p>
                                </li>
                                <li>
                                    <h4>Ouvrir un projet :</h4>
                                    <p>Savoir sauvegarder un projet n'aurait pas de sens sans pouvoir le rouvrir ! Pour ce faire, allez dans l'option "Ouvrir un projet..." du menu "Projet" et choisissez le fichier qui porte le nom du projet visé.</p>
                                    <p>Pour <span class="em">ouvrir un projet</span>, vous pouvez aussi utiliser la combinaison de touches <span class="em">CTRL + F11</span>.</p>
                                    <p>Par ailleurs, l'option "Ouvrir un projet récent" du menu "Projet" donne accès aux derniers projets utilisés.</p>
                                    <p>Il est encore possible de cliquer sur l'icône du dossier ouvert dans la barre d'outils de la fenêtre principale de Lazarus, mais en faisant attention de bien choisir un fichier avec l'extension .lpi, comme lors de la sauvegarde.</p>
                                    <p>Voici, par exemple, le fichier .lpi correspondant à une application personnelle nommée "MadameMonsieur" :</p>
                                    <figure>
                                        <img src="../images/ouverture_projet_Lazarus.png" alt="">
                                        <figcaption>Ouverture d'un projet</figcaption>
                                    </figure>
                                    <p>Il se peut que Lazarus vous propose de sauvegarder les changements intervenus dans l'éditeur depuis votre dernière sauvegarde. Répondez "Non" à cette question puisqu'il n'y a pas de travail important en cours.</p>
                                    <p>Un <span class="em">fichier modifié lors de la session en cours est marqué par un astérisque</span> avant son nom dans l'onglet correspondant de l'éditeur de source. D'autre part, l'icône de la double disquette correspondant à la sauvegardée est colorée en cas de modification et grise dans le cas contraire.</p>
                                    <p>Notez toutefois qu'il est toujours de <span class="em">votre responsabilité de décider si les changements sont à conserver ou non</span>. En général, la réponse est "Oui" à la question posée par Lazarus, à moins que vous décidiez de perdre le travail effectué récemment...</p>
                                    <p>Après ouverture, le projet choisi est affiché dans l'état où il était lors de sa dernière utilisation.</p>
                                    <p>Vous connaissez désormais quelques-unes des étapes pour créer vos propres applications. Soyez bienvenu(e) dans le monde de la programmation !</p>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>