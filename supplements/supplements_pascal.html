<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Pascal - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#elements_langage">Éléments du langage</a></li>
                        <li><a href="#entete_partie_declaration">En-tête et partie déclaration</a></li>
                        <li><a href="#partie_instruction">Partie instruction</a></li>
                        <li><a href="#types">Types</a></li>
                        <li><a href="#instructions_structurees">Instructions structurées</a></li>
                        <li><a href="#type_string">Type string (chaînes courtes)</a></li>
                        <li><a href="#fonctions_procedures">Fonctions et procédures</a></li>
                        <li><a href="#tableaux">Tableaux (Array)</a></li>
                        <li><a href="#lazarus">Lazarus</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Pascal :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage Pascal a été créé dans les années 1970 à Züricg par le professeur suisse Niklaus Wirth, avec pour objectif principal de favoriser la clarté, la lisibilité et la fiabilité du code. Il tire son nom du mathématicien, physicien, inventeur et philosophe français Blaise Pascal (1623-1662).</p>
                    <p>Pascal est un langage de programmation impératif et structuré, largement utilisé dans les milieux académiques et éducatifs, ainsi que dans le développement de logiciels système, d'applications scientifiques et d'ensembles d'outils.</p>
                    <p>Il se distingue par sa syntaxe formelle, ses structures de contrôle claires telles que les boucles et les structures conditionnelles, ainsi que par ses types de données statiquement typés. Ces caractéristiques en font un langage idéal pour l'apprentissage des concepts fondamentaux de la programmation.</p>
                    <p>Pascal a influencé de nombreux autres langages de programmation, notamment Ada, Modula-2 et Delphi. Bien que son utilisation ait décliné dans le monde professionnel au profit de langage plus modernes, il reste un choix populaire pour l'enseignement de la programmation en raison de sa simplicité et de sa lisibilité.</p>
                    <p>Si vous faites une recherche sur le langage Pascal, vous verrez systématiquement cités <span class="em">Turbo Pascal</span>, <span class="em">Free Pascal</span>, <span class="em">Lazarus</span> et <span class="em">Delphi</span>.</p>
                    <p>Le premier est en quelque sorte l'ancêtre des trois autres : <span class="em">Turbo Pascal</span>, édité par Borland, a fait les beaux jours du langage Pascal sur MS-DOS, puis sur les premières versions de Windows.</p>
                    <p>Le successeur de Turbo Pascal a été (et toujoursk malgré successifs de Borland) <span class="em">Delphi</span>. Des extensions ont été ajoutées au langage qui s'appelle désormais le <span class="em">Pascal Objet</span> (cette appelation tient au fait que le Pascal moderne a intégré les principes de la Programmation Orientée Objet dont nous parlerons en temps utile). De plus, la conception des applications se fait visuellement et plus rapidement : on parle de <span class="em">RAD</span> pour <span class="em">Rapid Application Development</span> ("Développement rapide d'application"). Delphi est à présent inclus dans la suite appelée <span class="eem">RAD Studio</span>.</p>
                    <p>Parallèlement à la mise au point de Turbo Pascal, au début des années 1990, une équipe de développeurs a créé une alternative libre et gratuite au produit phare de Borland : FPK Pascal, devenu <span class="em">Free Pascal</span>, parfois abrégé en <span class="em">FPC</span>. Lui aussi compile du Pascal Objet.</p>
                    <p>Lorsque Delphi s'est installé sur le marché des outils de développement, s'est bâtie sur Free Pascal l'alternative livre et gratuite <span class="em">Lazarus</span>.</p>
                    <p>Tous ces outils de développement permettent de compiler du langage Pascal. Avec Turbo Pascal et Free Pascal, vous écrivez vous-même tout le code n'écessaire; avec Lazarus et Delphi, une partie est automatiquement générée lorsque vous déposez et modifiez des composants prêts à l'emploi sur des fiches.</p>
                    <ol>
                        <li>
                            <h3>Pourquoi apprendre le Pascal aujourd'hui ?</h3>
                            <p>Si par curiosité vous parcourez des forums de discussion sur la programmation, vous risquez de tomber sur des réflexions qui ne vous encourageront pas à apprendre le langage Pascal. Étant donné qu'il a longtemps étét enseigné comme langage de base de programmation dans les écoles, le Pascal est resté, dans l'esprit de certains, un langage pour débutants ou développeurs amateurs.</p>
                            <p>Eh bien, c'est totalement faux ! Les première versions du système Macintosh d'Apple, des programmes pour les missions spatiales Apollo et des logiciels comme Photoshop, Skype, Kaspersky, Jabber, SpyBot ou Everest ont été initialement écrits en Pascal. Savez-vous, par exemple, qu'un logiciel de composition musicale aussi célèbre que FL Studio est écrit en Pascal ? Et ce rapide inventaire ne comprend pas de plus en plus d'applications créées pour les smartphones ! En fait, dans le monde du développement professionel, le Pascal navigue toujours dans les dix à quinze langages les plus utilisés (citons les plus courants : C (avec ses dérivés C++, C#, Objective-C), Java, PHP, JavaScript, Python, Perl, Ruby, Basic, Lisp et Assembleur...). C'est tout simplement qu'il a su évoluer et intégrer les acquis d'une programmation moderne.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="elements_langage">Éléments du langage :</h2>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Un programme Pascal est écrit sous la forme d'une suite de lignes de texte. La longueur d'une ligne ne fait pas partie des spécifications du Pascal.</p>
                            <p>Un programme Pascal est composé :</p>
                            <ul>
                                <li>
                                    <p><span class="em">d'éléments du langage</span> (les plus petits éléments significatifs - tokens) séparés (si nécessaire par)</p>
                                </li>
                                <li>
                                    <p>un ou plusieurs <span class="em">séparateurs</span>.</p>
                                </li>
                            </ul>
                            <p>Un séparateur est :</p>
                            <ul>
                                <li>
                                    <p>soit un <span class="em">caractère inerte</span> : <span class="em">le caractère espace</span> (valeur ASCII 32) et <span class="em">tous les caractères de contrôle</span> (valeurs ASCII de 0 à 31)</p>
                                </li>
                                <li>
                                    <p>soit un <span class="em">commentaire</span>; les commentaires (qui ne peuvent être imbriqués) sont ignorés par le compilateur; ils aident seulement à la lisibilité de vos programmes.</p>
<pre><code>{ceci est un commentaire}
(* ceci également *)
// et ceci est un commentaire en ligne</code></pre>
                                    <p class="em">Un commentaire comportant le symbole $ immédiatement après l'accolade ouvrante est une directive de compilation.</p>
                                    <p class="em">Ainsi, dans l'environnement Delphi 4, la directive {$APPTYPE CONSOLE} signifie au compilateur que le programme devra correspondre à une application console.</p>
<pre><code>Program Hello ;
<span class="em">{$APPTYPE CONSOLE}</span>
begin
    writeLn('Hello, World…') ;
    <span class="em">readLn</span>
end.</code></pre>
                                </li>
                            </ul>
                            <p>Les éléments du langage comprennent :</p>
                            <ul>
                                <li>
                                    <p>les symboles spéciaux et les mots réservés</p>
                                </li>
                                <li>
                                    <p>les identificateurs</p>
                                </li>
                                <li>
                                    <p>les nombres</p>
                                </li>
                                <li>
                                    <p>les constantes chaînes de caractères</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Symboles spéciaux et mots réservés :</h3>
                            <p>Les symboles spéciaux et les mots réservés sont des caractères ou des suites de caractères ayant une ou plusieurs significations fixées par le langage.</p>
                            <ol>
                                <li>
                                    <h4>Symboles spéciaux :</h4>
                                    <ul>
                                        <li>
                                            <p>+</p>
                                        </li>
                                        <li>
                                            <p>*</p>
                                        </li>
                                        <li>
                                            <p>/</p>
                                        </li>
                                        <li>
                                            <p>=</p>
                                        </li>
                                        <li>
                                            <p>&lt;</p>
                                        </li>
                                        <li>
                                            <p>&gt;</p>
                                        </li>
                                        <li>
                                            <p>[</p>
                                        </li>
                                        <li>
                                            <p>]</p>
                                        </li>
                                        <li>
                                            <p>.</p>
                                        </li>
                                        <li>
                                            <p>,</p>
                                        </li>
                                        <li>
                                            <p>(</p>
                                        </li>
                                        <li>
                                            <p>)</p>
                                        </li>
                                        <li>
                                            <p>:</p>
                                        </li>
                                        <li>
                                            <p>;</p>
                                        </li>
                                        <li>
                                            <p>'</p>
                                        </li>
                                        <li>
                                            <p>^</p>
                                        </li>
                                        <li>
                                            <p>@</p>
                                        </li>
                                        <li>
                                            <p>{</p>
                                        </li>
                                        <li>
                                            <p>}</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>$</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>&lt;=</p>
                                        </li>
                                        <li>
                                            <p>&gt;=</p>
                                        </li>
                                        <li>
                                            <p>&lt;&gt;</p>
                                        </li>
                                        <li>
                                            <p>:=</p>
                                        </li>
                                        <li>
                                            <p>..</p>
                                        </li>
                                        <li>
                                            <p>(*)</p>
                                        </li>
                                        <li>
                                            <p>*)</p>
                                        </li>
                                        <li>
                                            <p>(.)</p>
                                        </li>
                                        <li>
                                            <p>.)</p>
                                        </li>
                                        <li>
                                            <p>//</p>
                                        </li>
                                        <li>
                                            <p>&amp;</p>
                                        </li>
                                    </ul>
                                    <p>Exemple :</p>
                                    <p>Le symbole <span class="em">&lt;=</span> représente un opérateur. Il est d'ailleurs surchargé, ce qui signifie qu'il possède plusieurs significations. Suivant le contexte, il symbolise l'opération inférieur ou égal ou l'opération sous-ensemble de.</p>
                                </li>
                                <li>
                                    <h4>Mots réservés :</h4>
                                    <p>Les mots réservés ou mots clés font partie du langage Pascal; ils ne peuvent en aucun cas être redéfinis et possèdent une signification standard prédéfinie. En voici la liste :</p>
                                    <ul>
                                        <li>
                                            <p>and</p>
                                        </li>
                                        <li>
                                            <p>array</p>
                                        </li>
                                        <li>
                                            <p>begin</p>
                                        </li>
                                        <li>
                                            <p>case</p>
                                        </li>
                                        <li>
                                            <p>const</p>
                                        </li>
                                        <li>
                                            <p>div</p>
                                        </li>
                                        <li>
                                            <p>do</p>
                                        </li>
                                        <li>
                                            <p>downto</p>
                                        </li>
                                        <li>
                                            <p>else</p>
                                        </li>
                                        <li>
                                            <p>End</p>
                                        </li>
                                        <li>
                                            <p>file</p>
                                        </li>
                                        <li>
                                            <p>for</p>
                                        </li>
                                        <li>
                                            <p>function</p>
                                        </li>
                                        <li>
                                            <p>goto</p>
                                        </li>
                                        <li>
                                            <p>if</p>
                                        </li>
                                        <li>
                                            <p>in</p>
                                        </li>
                                        <li>
                                            <p>label</p>
                                        </li>
                                        <li>
                                            <p>mod</p>
                                        </li>
                                        <li>
                                            <p>nil</p>
                                        </li>
                                        <li>
                                            <p>not</p>
                                        </li>
                                        <li>
                                            <p>of</p>
                                        </li>
                                        <li>
                                            <p>or</p>
                                        </li>
                                        <li>
                                            <p>packed</p>
                                        </li>
                                        <li>
                                            <p>procedure</p>
                                        </li>
                                        <li>
                                            <p>program</p>
                                        </li>
                                        <li>
                                            <p>record</p>
                                        </li>
                                        <li>
                                            <p>repeat</p>
                                        </li>
                                        <li>
                                            <p>set</p>
                                        </li>
                                        <li>
                                            <p>then</p>
                                        </li>
                                        <li>
                                            <p>to</p>
                                        </li>
                                        <li>
                                            <p>type</p>
                                        </li>
                                        <li>
                                            <p>until</p>
                                        </li>
                                        <li>
                                            <p>var</p>
                                        </li>
                                        <li>
                                            <p>while</p>
                                        </li>
                                        <li>
                                            <p>with</p>
                                        </li>
                                    </ul>
                                    <p>Le Pascal Objet en allonge la liste :</p>
                                    <ul>
                                        <li>
                                            <p>As</p>
                                        </li>
                                        <li>
                                            <p>asm</p>
                                        </li>
                                        <li>
                                            <p>class</p>
                                        </li>
                                        <li>
                                            <p>constructor</p>
                                        </li>
                                        <li>
                                            <p>destructor</p>
                                        </li>
                                        <li>
                                            <p>dispinterface</p>
                                        </li>
                                        <li>
                                            <p>except</p>
                                        </li>
                                        <li>
                                            <p>exports</p>
                                        </li>
                                        <li>
                                            <p>finalization</p>
                                        </li>
                                        <li>
                                            <p>implementation</p>
                                        </li>
                                        <li>
                                            <p>inherited</p>
                                        </li>
                                        <li>
                                            <p>initialization</p>
                                        </li>
                                        <li>
                                            <p>inline</p>
                                        </li>
                                        <li>
                                            <p>interface</p>
                                        </li>
                                        <li>
                                            <p>is</p>
                                        </li>
                                        <li>
                                            <p>library</p>
                                        </li>
                                        <li>
                                            <p>object</p>
                                        </li>
                                        <li>
                                            <p>out</p>
                                        </li>
                                        <li>
                                            <p>finally</p>
                                        </li>
                                        <li>
                                            <p>unit</p>
                                        </li>
                                        <li>
                                            <p>property</p>
                                        </li>
                                        <li>
                                            <p>raise</p>
                                        </li>
                                        <li>
                                            <p>resourcestring</p>
                                        </li>
                                        <li>
                                            <p>shl</p>
                                        </li>
                                        <li>
                                            <p>shr</p>
                                        </li>
                                        <li>
                                            <p>string</p>
                                        </li>
                                        <li>
                                            <p>threadvar</p>
                                        </li>
                                        <li>
                                            <p>try</p>
                                        </li>
                                        <li>
                                            <p>uses</p>
                                        </li>
                                        <li>
                                            <p>xor</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Identificateurs :</h3>
                            <p>Les identificateurs symbolisent les constantes, les champs (d'enregistrement) les unités, les bibliothèques et les paquets. Nous en avons déjà étudié la syntaxe. Pascal contient des identificateurs (directives) standards dotés de sognifications prédéfinies. Contrairement aux mots réservés, vous "pouvez" les redéfinir...</p>
                            <ul>
                                <li>
                                    <p>absolute</p>
                                </li>
                                <li>
                                    <p>abstract</p>
                                </li>
                                <li>
                                    <p>assembler</p>
                                </li>
                                <li>
                                    <p>automated</p>
                                </li>
                                <li>
                                    <p>Cdel</p>
                                </li>
                                <li>
                                    <p>contains</p>
                                </li>
                                <li>
                                    <p>default</p>
                                </li>
                                <li>
                                    <p>At</p>
                                </li>
                                <li>
                                    <p>dispid</p>
                                </li>
                                <li>
                                    <p>dynamic</p>
                                </li>
                                <li>
                                    <p>export</p>
                                </li>
                                <li>
                                    <p>external</p>
                                </li>
                                <li>
                                    <p>far</p>
                                </li>
                                <li>
                                    <p>implements</p>
                                </li>
                                <li>
                                    <p>forward</p>
                                </li>
                                <li>
                                    <p>on</p>
                                </li>
                                <li>
                                    <p>index</p>
                                </li>
                                <li>
                                    <p>message</p>
                                </li>
                                <li>
                                    <p>name</p>
                                </li>
                                <li>
                                    <p>near</p>
                                </li>
                                <li>
                                    <p>nodefault</p>
                                </li>
                                <li>
                                    <p>reintroduce</p>
                                </li>
                                <li>
                                    <p>override</p>
                                </li>
                                <li>
                                    <p>safecall</p>
                                </li>
                                <li>
                                    <p>pascal</p>
                                </li>
                                <li>
                                    <p>private</p>
                                </li>
                                <li>
                                    <p>protected</p>
                                </li>
                                <li>
                                    <p>public</p>
                                </li>
                                <li>
                                    <p>published</p>
                                </li>
                                <li>
                                    <p>overload</p>
                                </li>
                                <li>
                                    <p>read</p>
                                </li>
                                <li>
                                    <p>Readonly</p>
                                </li>
                                <li>
                                    <p>register</p>
                                </li>
                                <li>
                                    <p>resident</p>
                                </li>
                                <li>
                                    <p>stdcall</p>
                                </li>
                                <li>
                                    <p>stored</p>
                                </li>
                                <li>
                                    <p>virtual</p>
                                </li>
                                <li>
                                    <p>requires</p>
                                </li>
                                <li>
                                    <p>write</p>
                                </li>
                                <li>
                                    <p>writeonly</p>
                                </li>
                            </ul>
                            <p>Rappelons le diagramme de Conway pour l'écriture des identificateurs :</p>
                            <img src="../images/diagramme_Conway_ecriture_identificateurs.png" alt="">
                            <p>Un identificateur peut avoir une taille quelconque mais seuls les 255 (<span class="em">63 pour les anciens compilateurs</span>) premiers caractères sont significatifs.</p>
                        </li>
                        <li>
                            <h3>Nombres :</h3>
                            <p>Les nombres avec décimales ou exposants sont des constantes de type réel. Les autres nombres sont des entiers. Les valeurs doivent se trouver à l'intérieur de l'intervalle du plus grand type prédéfini entier ou réel.</p>
                            <p>Les nombres hexadécimaux sont des entiers et ils doivent être compris entre $00000000 et $FFFFFFFF.</p>
                            <ul>
                                <li>
                                    <p>Un nombre entier en notation décimale se compose d'une suite de chiffres éventuellement précédés d'un signe (exemple : 46). En notation hexadécimale, il se compose en plus, des lettres de A à F (ou a à f); il est alors préfixé par le signe $ (exemple : $2E).</p>
                                    <p>Notation décimale :</p>
                                    <img src="../images/notation_decimale_Pascal.png" alt="">
                                    <p>Notation hexadécimale :</p>
                                    <img src="../images/notation_hexadecimale_Pascal.png" alt="">
                                </li>
                                <li>
                                    <p>Un nombre réel doit contenir un point décimal ou un exposant - ou bien les deux.</p>
                                    <p>S'il contient un point décimal, celui doit figurer entre deux chiffres (exemple : 46.0).</p>
                                    <p>Et en notation scientifique : 0.46 E2 (se lit 0.46 fois dix à la puissance 2)</p>
                                    <img src="../images/notation_scientifique_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Notez que les nombres entiers sont des quantités exactes, alors que les nombres réels correspondent à des approximations.</p>
                        </li>
                        <li>
                            <h3>Chaînes de caractères :</h3>
                            <p>Une chaîne de caractères est une suite éventuellement vide de caractères délimitée par des apostrophes.</p>
                            <p>Pascal Objet offre la possibilité d'insérer dans les chaînes de caractères des caractères de contrôle (le signe dièse suivi directement d'une constante entière dans l'intervalle 0..255 représente le caractère ASCII correspondant).</p>
                            <p>UneMethode chaîne de caractères doit s'écrire sur une seule ligne.</p>
                            <img src="../images/chaines_caracteres_Pascal.png" alt="">
                            <p>(*) tous les caractères sauf l'apostrophe et le retour chariot.</p>
<pre><code>'Exemple d''une chaîne'
''	{chaîne vide}
''''	{chaîne comprenant une apostrophe}
#7#7'Debout !'#7#7
'Ligne 1'#13'Ligne 2'</code></pre>
                            <p>Dans un programme Pascal, on peut utiliser indifféremment majuscules et miniscules. Dans une chaîne, où les caractères se représentent eux-mêmes, il existe une différence entre une lettre minuscule et la majuscule correspondante. Le caractère espace (#32) n'y est pas considéré comme un séparateur et les caractères accentués peuvent y être employés.</p>
                        </li>
                        <li>
                            <h3>Un exemple de programme Pascal :</h3>
                            <p>Considérons le programme Pascal qui traduit le premier algorithme du chapitre précédent et retrouvons les éléments de langage.</p>
<pre><code>PROGRAM Premier_Programme_Pascal ;
{édition de la longueur de la circonférence d'un cercle }

{$APPTYPE CONSOLE}		// cfr. Delphi 4

CONST PI = 3.14159 ;
VAR   rayon,circonference : REAL ;

BEGIN 
    write('Rayon : ') ;
    readLn(rayon) ;
    circonference := 2 * PI * rayon ;
    writeLn('Circonférence : ',circonference) ;
    readLn
END.</code></pre>
                            <p><span class="em">symboles spéciaux :</span> ; = ( ) * , := . : { }</p>
                            <p><span class="em">mots réservés :</span> PROGRAM CONST VAR BEGIN END</p>
                            <p><span class="em">identificateurs standard :</span> write readlin writeln</p>
                            <p><span class="em">identificateurs :</span></p>
                            <ul>
                                <li>
                                    <p>de programme : Premier_Programme_Pascal</p>
                                    <li>
                                        <p>de constante : PI</p>
                                    </li>
                                    <li>
                                        <p>de variable : rayon circonference</p>
                                    </li>
                                </li>
                            </ul>
                            <p><span class="em">commentaires :</span> {édition ... cercle}</p>
                            <p><span class="em">directive de compilation :</span> {$APPTYPE CONSOLE}</p>
                            <p><span class="em">chaînes de caractères :</span> 'Rayon : ' 'Circonférence : '</p>
                            <p><span class="em">nombre entier :</span>2</p>
                            <p><span class="em">nombre réel :</span>3.14259</p>
                            <p class="em">Remarque : très souvent, dans la suite du cours, nous omettrons la directive de compilation (ainsi que le readLn final). Il est bien certain cependant, que dans l'environnement Delphi 4, vous devrez l'insérer si vous désirez construire une application console !</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="entete_partie_declaration">En-tête et partie déclaration :</h2>
                    <ol>
                        <li>
                            <h3>Structure générale d'un programme :</h3>
                            <p>Un programme Pascal est constitué d'un en-tête de programme suivi par un bloc de programme.</p>
                            <p>Le bloc est divisé en une partie déclaration dans laquelle sont définis tous les objets locaux au programme, et une partie instructions qui spécifie les actions à exécuter sur ces objets. Ainsi, toute variable apparaissant dans une instruction doit avoir été déclarée au préalable dans une déclaration de variable.</p>
                            <img src="../images/structure_generale_programme_Pascal.png" alt="">
                            <p>Reprenons notre premier programme Pascal et tentons d'en découvrir la structure générale.</p>
                            <img src="../images/premier_programme_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Partie déclaration :</h3>
                            <p>La partie déclaration peut elle-même être divisée en plusieurs déclarations : de labels, de constantes, de types, de variables, de procédures et de fonctions. Contraitrement au Pascal Objet, le Pascal standard impose que ces déclarations - si elles existent - se fassent une seule fois et dans un certain ordre. Cette façon de procéder manque de souplesse.</p>
                            <img src="../images/partie_declaration_Pascal.png" alt="">
                            <p class="em">Remarque : La partie déclaration peut être absente, comme  dans l'exemple suivant :</p>
<pre><code>program qui_ne_fait_rien ;
BEGIN
END.</code></pre>
                            <p>Nous ne nous intéresserons dans les paragraphes suivants qu'aux déclarations de constantes et de variables.</p>
                        </li>
                        <li>
                            <h3>Déclaration des constantes :</h3>
                            <p>On devrait parler plutôt de définition de constante; celle-ci permet d'introduire un identificateur comme synonyme d'une expression constante. Une expression constante est une expression qui peut être évaluée lors de la compilation, sans qu'il soit nécessaire d'exécuter le programme.</p>
                            <p>Exemples :</p>
<pre><code>const PI = 3.14159 ;
      MESSAGE = 'Hello, world' ;
      CARACT = 'F' ;
      NBRCAR = ORD('Z') - ORD('A') + 1 ;
      MIN = 1 ;
      MAX = 100 ;
      CENTRE = (MAX - MIN) DIV 2 ;</code></pre>
                            <img src="../images/declaration_constantes" alt="">
                            <p>Il existe des identificateurs de constantes standard comme MAXINT qui représente le plus grand entier (INTEGER). Sa valeur, dans une implémentation 32 bits, est +2147483647 soit 2<sup>31</sup> - 1.</p>
                            <p>L'utilisation d'identificateurs de constante rend un programme plus lisible, facilite sa documentation et certaines modifications.</p>
                            <p>Remarques :</p>
                            <ul>
                                <li>
                                    <p>Les fonctions standard suivntes sont autorisées dans les expressions constantes : <span class="html">Abs</span>, <span class="html">Addr</span>, <span class="html">Chr</span>, <span class="html">Hi</span>, <span class="html">high</span>, <span class="html">Length</span>, <span class="html">Lo</span>, <span class="html">Low</span>, <span class="html">Odd</span>, <span class="html">Ord</span>, <span class="html">Pred</span>, <span class="html">Ptr</span>, <span class="html">Round</span>, <span class="html">SizeOf</span>, <span class="html">Succ</span>, <span class="html">Swap</span>, <span class="html">Trunc</span>.</p>
                                </li>
                                <li>
                                    <p>Notre Pascal possède un identificateur prédéclaré <span class="html">pi</span>. Il s'agit non d'une constante, mais d'une fonction arithmétique qui renvoie la valeur <span class="em">3.141592653587932385</span>. Si, comme dans notre exemple, nous avons redéclaré <span class="em">pi</span>, nous n'avons plus accès à cette fonction.</p>
                                </li>
                                <li>
                                    <p>Il permte la définition de constantes typées. Une constante typée est une variable spécifiant une valeur initiale et qui ne peut pas être mdoifiée.</p>
<pre><code>const max : integer = 100 ;
    titre : string = 'Les constantes typées' ;</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Déclaration des variables :</h3>
                            <p>Déclarer une variable, c'est donner un nom à une variable. C'est aussi lui associer un type ce qui détermine les valeurs qu'elle peut prendre, les opérations dont elle peut faire l'objet et son encombrement mémoire.</p>
                            <p>Chaque variable ne peut faire l'objet que d'une seule déclaration dans une partie déclarative donnée. Cette déclaration implique la réservation, <span class="em">si c'est approprié</span>, d'une place en mémoire. Rappelons qu'en Pascal, les variables ne possèdent pas de valeur initiale définie. Les variables déclarées dans le bloc du programme sont appelées variables globales; ce sont les seules que nous connaissons pour l'instant.</p>
                            <p>Une déclaration de variables consiste en une liste d'idnetificateurs de variables et un type associé.</p>
                            <img src="../images/declaration_variables_Pascal.png" alt="">
                            <p><span class="html">&lt;type&gt;</span> représente soit un identificateur de type, soit un descripteur de type.</p>
                            <p>Exemples :</p>
<pre><code>var racine, quotient : REAL ;
    compteur, x, y : INTEGER ;
    reponse : CHAR ;
    trouve, continue : BOOLEAN ;</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="partie_instruction">Partie instruction :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La partie instruction définit les instructions ou actions algorithmiques exécutées dans le bloc.</p>
                            <img src="../images/partie_instruction_Pascal.png" alt="">
                            <p>Délimitée par les mots réservés <span class="html">begin</span> et <span class="html">end</span>, la partie instruction se compose d'une instruction ou d'une suite d'instructions séparées par <span class="em">;</span>. Le point-virgule, en Pascal, est un séparateur d'instructions, alors que dans d'autres langages, il termine une instruction. Dans l'exemple du programme <span class="em">qui_ne_fait_rien</span>, l'instruction était l'instruction vide.</p>
                        </li>
                        <li>
                            <h3>Instructions simples :</h3>
                            <p>Il en existe de quatre sortes en Pascal :</p>
                            <ul>
                                <li>
                                    <p>instructin d'affectation</p>
                                </li>
                                <li>
                                    <p>appel de procédure</p>
                                </li>
                                <li>
                                    <p>instruction goto</p>
                                </li>
                                <li>
                                    <p>instruction vide</p>
                                </li>
                            </ul>
                            <ol>
                                <li>
                                    <h4>L'instruction d'affectation :</h4>
                                    <p>L'instruction d'affectation remplace la valeur d'une variable par une nouvelle valeur. Cette nouvelle valeur est spécifiée par une expression qui doit être du même type ou du moins d'un type compatible avec le type de la variable.</p>
<pre><code>&lt;variable&gt; := &lt;expression&gt;</code></pre>
                                    <p>Exemple :</p>
                                    <p>LDA : <span class="em">circonference &lt;--- 2 * pi * rayon</span></p>
                                    <p>Pascal : <span class="em">circonference := 2 * pi * rayon</span></p>
                                </li>
                                <li>
                                    <h4>L'instruction de procédure :</h4>
                                    <p>Une procédure est un sous-programme qui produit un effet. Il en existe des prédéclarées que vous pouvez appeler par des instructions de procédure. Il suffiit, pour ce faire, de spécifier l'identificateur de procédure ainsi que les paramètres nécessaires. Nous nous intéresserons aux procédures de lecture (entrées) et d'écriture (sorties).</p>
                                    <ul>
                                        <li>
                                            <p>À l'instruction LDA <span class="em">lire</span> correspond les procédures <span class="html">read</span> et <span class="html">readln</span>,</p>
                                        </li>
                                        <li>
                                            <p>Et à l'instruction <span class="em">écrire</span> les procédures <span class="html">write</span> et <span class="html">writeln</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="types">Types :</h2>
                    <ol>
                        <li>
                            <h3>Valeurs, variables et types :</h3>
                            <p>De manière générale, les programmes expriment des calculs sur des <span class="em">valeurs</span>. Cependant, les valeurs ne sont pas le seul genre d'objet qui apparaissent dans les programmes algorithmiques. En effet, les valeurs produites par l'exécution séquentielle des programmes peuvent être à mémoriser explicitement pour une utilisation ultérieure. Pour ce faire, un deuxième genre d'objet est nécessaire : les variables. Ces objets ont non seulement des propriétés logiques, mais aussi une représentation physique : les valeurs sont représentées par des emplacements en mémoire (chaque emplacement correspond à une adresse). Tous ces objets, c'est l'évidence, ne possèdent pas les mêmes propriétés : les nombres réels ne se manipulent pas comme les nombres entiers, les opérateurs relationnels produisent des valeurs logiques, les valeurs diffèrent des variables...</p>
                            <p>Quel que soit leur genre, tous ces objets ont leurs propriétés propres que l'on caractérise par un <span class="em">type</span>.</p>
                            <p>Les langages algorithmiques associent aux objets en général et aux valeurs en particulier des types. Chaque type spécifie :</p>
                            <ul>
                                <li>
                                    <p>un ensemble d'objets, par ex. des valeurs entières,</p>
                                </li>
                                <li>
                                    <p>un ensemble de propriété que ces objets doivent satisfaire <span class="em">et</span></p>
                                </li>
                                <li>
                                    <p>un ensemble d'opérations qui utilisent ces objets comme opérandes ou les produisent comme résultats.</p>
                                </li>
                            </ul>
                            <p>Ainsi, à chaque objet sera associé un type, et tous les objets d'un même type auront des propriétés communes, caractéristiques de ce type.</p>
                            <p>Dans le langage courant, nous disons qu'une valeur tel qu'une valeur tel que 12345 ou une variable x sont de type entier ... qu'en Pascal on définit par l'identificateur de type INTEGER. En toute rigueur, cela est inexact.</p>
                            <p>Une valeur entière et une variable entière sont deux objets qui ont des propriétés bien différentes :</p>
                            <ul>
                                <li>
                                    <p>12345 appartient au type INTEGER.</p>
                                    <p>À ce type correspond un ensemble de valeurs entières, des propriétés (<span class="em">ces valeurs sont ordonnées</span>) et des opérations (<span class="em">l'addition, la soustraction ...</span>).</p>
                                </li>
                                <li>
                                    <p>par contre, x dénote une variable entière qu'on devrait spécifier de type VAR INTEGER. Les opérations que nous connaissons sur de telles variables sont :</p>
                                    <ul>
                                        <li>
                                            <p>sa déclaration (var x : Integer;)</p>
                                        </li>
                                        <li>
                                            <p>l'affectation (x:= 12345)</p>
                                        </li>
                                        <li>
                                            <p>la prise de valeur (y := x +3)</p>
                                        </li>
                                    </ul>
                                    <p>À gauche du signe d'affectatipn, x dénote une variable et est de type VAR INTEGER. Il en est de même à droite, mais il doit être clair que l'addition + 3 est à effectuer sur la <span class="em">valeur</span> de cette variable. l'opération <span class="em">prise de valeur</span> est ici à effectuer bien qu'aucun opérateur ne la désigne : elle est implicitement spécifiée par le contexte.</p>
                                    <p>On appelle <span class="em">opération implicite</span> une opération à laquelle ne correspond aucun opérateur. L'opération prise de valeur est donc une opération implicite auquel correspond une transformation de type VAR INTEGER &#8594; INTEGER.</p>
                                    <p>Remarque : vous pouvez écrire <span class="em">z := w</span> ou <span class="em">z := (w)</span> mais non <span class="em">(z) := w</span> !</p> 
                                </li>
                            </ul>
                            <p>Les langages algoirithmiques sont définis de telle sorte que toutes les valeurs d'un type T donné puissent être représentées par des chaînes de bits de même taille. Il s'ensuit que toutes les variables du type T peuvent être représentées par des emplacements mémoire de même taille et que chacun de ces emplacements pourra contebur la représentation de n'importe quelle valeur du type T.</p>
                            <p>Il doit bien être évident cependant qu'à chaque classe de valeurs va correspondre une classe de variables de même structure. Dans la suite de ce cours, nous parlerons par abus de langage, d'une variable de type INTEGER par exemple, vius saurez ce que cela recouvre implicitement. Rappelons que contrairement à une variable, une valeur telle 12345 est supposée exister en dehors de toute exécution.</p>
                            <p>Un littéral (12345), une expression (12000+345), une constante (CONST N = 12345), un identificateur de variable après l'opération de prise de valeur peuvent dénoter la même valeur.</p>
                            <p>Lorsque nous parlons de variables, il peut s'agir, selon le contexte, des variables algorithmiques, de variables de programme ou de variables d'état. Une variable d'état est caractérisée comme une variable de programme par un identificateur et un type. Elle est par contre la seule pour laquelle nous pouvons parler d'allocation mémoire et de valeur. Cependant, par référence aux variables d'état, nous dirons d'une variable de programme qu'elle est... <span class="em">déclarée</span> lorsque sont connus identificateur et son type, <span class="em">définie</span> lorsqu'elle est déclarée et que l'on peut faire référence à son allocation physique en mémoire, <span class="em">initialisée</span> lorsqu'elle est définie et qu'une valeur lui a été associée (d'après Cardon et Charras).</p>
                        </li>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Il existe en Pascal Objet sept classes majeures de types.</p>
                            <img src="../images/classes_majeures_types_Pascal.png" alt="">
                            <p>Ces différentes classes sont décrites dans la suite du cours. Nous nous intéresserons dans ce chapitre aux types simples.</p>
                        </li>
                        <li>
                            <h3>Types simples :</h3>
                            <p>Les types simples sont comme leurs noms l'indiquent les types de base; pour la plupart, ce sont ceux que l'on trouve tout faits sur les ordinateurs. Ces types sont des types de valeurs simples, c'est-à-dire qui ne sont pas considérés, dans un langage donné, comme composées d'éléments discernables. Les valeurs simples sont les valeurs les plsu classiques, en particulier les nombres.</p>
                            <p>Le langage Pascal sépare les types simples en deux classes :</p>
                            <ul>
                                <li>
                                    <p>d'une part les types réels et</p>
                                </li>
                                <li>
                                    <p>d'autre part les types scalaires.</p>
                                </li>
                            </ul>
                            <p>Un type scalaire (étymologiquement scalaire signifie échelle) caractérise un ensemble fini et ordonné de valeurs. On parle aussi de type discret ou ordinal. À chaque valeur d'un type scalaire est associé un rang qui est une valeur entière (ORDINALE). Sauf dans le cas des types entiers (le rang d'un élément de type entier est la valeur de l'élément lui-même), la première valeur de tous les types scalaires est de rang 0, la suivante 1 et ainsi de suite.</p>
                            <p>Chaque valeur a un prédécesseur sauf la première et un successeur sauf la dernière (cfr ORD, PRED, SUCC).</p>
                            <p>Il existe des types simples scalaires standards (<span class="em">prédéclarés</span>) comme les types INTEGER, CHAR et BOOLEAN. D'autres doivent être <span class="em">déclarés</span> par l'utilisateur : ce sont les types énumérés et intervalle.</p>
                            <p>Tous les types scalaires partagent les propriétés suivantes :</p>
                            <p>Les fonctions standards <span class="html">low</span> et <span class="html">high</span> peuvent être appliquées à un tyê scalaire ou à une référence de variable d'un type scalaire. La fonction low renvoie la borne inférieure alors que la fonction high renvoie la borne sdupérieure de l'intervalle du type scalaire en question.</p>
                            <dl>
                                <dt>Ord, fonction</dt>
                                <dd>
                                    <p>Ord renvoie le rang d'une expression ordinale.</p>
                                    <p><span class="em">Unité :</span> System</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Ord(X):Longint;</p>
                                    <p><span class="em">Description :</span> La fonction Ord renvoie le rang d'une expression de type scalaire. X est une expression de type scalaire. Le résultat est de type Longint, sa valeur indiquant le rang de X.</p>
                                </dd>
                                <dt>Succ, fonction</dt>
                                <dd>
                                    <p>Succ renvoie le successeur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Succ(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le successeur de X.</p>
                                </dd>
                                <dt>Pred, fonction</dt>
                                <dd>
                                    <p>Pred renvoie le prédécesseur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Pred(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le prédécesseur de X.</p>
                                </dd>
                            </dl>
                        </li>
                        <li>
                            <h3>Les types réels :</h3>
                            <p>Classiquement, il n'existait en Pascal qu'un seul type réel : le type REAL.</p>
                            <p>Quelle définition nous en donne N.WIRTH ?</p>
                            <p>"Une valeur de type REAL est un élément du sous-ensemble des nombres réels que l'on peut représenter sur une machine donnée ...".</p>
                            <p>Actuellement, il existe six types réels fondamentaux : <span class="html">Real48</span>, <span class="html">Single</span>, <span class="html">Double</span>, <span class="html">Extended</span>, <span class="html">Comp</span> et <span class="html">Currency</span>... et un type réel générique : <span class="html">Real</span> (<span class="em">équivalent à Double</span>). À chacun de ces types réels correspond un intervalle et une précision spécifiques, indiqués dans le tableau ci-dessous (manuel de référence) :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Intervalle</th>
                                        <th>Chiffres significatifs</th>
                                        <th>Taille en octets</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Real48</td>
                                        <td>2.9 x 10<sup>-39</sup>..1.7 x 10<sup>38</sup></td>
                                        <td>11-12</td>
                                        <td>6</td>
                                    </tr>
                                    <tr>
                                        <td>Single</td>
                                        <td>1.5 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>7-8</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>Double</td>
                                        <td>5.0 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>15-16</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Extended</td>
                                        <td>3.4 x 10<sup>-4932</sup>..1.1 x 10<sup>4932</sup></td>
                                        <td>19-20</td>
                                        <td>10</td>
                                    </tr>
                                    <tr>
                                        <td>Comp</td>
                                        <td>-2<sup>63</sup>+1..2<sup>63</sup>-1</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Currency</td>
                                        <td>-922337203685477.5808..922337203685477.5807</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Le type Comp (Computational) est un entier de 64 bits qui contient les valeurs intégrales comprises entre -9 223 372 036 854 775 808 et 9 223 372 036 854 775 807 (-2<sup>63</sup> à 2<sup>63</sup>-1).</p>
                            <p>Le type Currency est un type de données à virgule fixe recommandé pour les calculs monétaires. Il est stocké en tant qu'entier scalaire de 64 bits avec les quatre chiffres les moins significatifs représentant implicitement qutre décimales. L'intervalle de valeurs de Currency est compris entre -922 337 203 685 477,5808 et 922 337 203 685 477,5807. Combinés avec d'autres types réels dans des affectations et des expressions, les valeurs de type Currency sont automatiquement graduées en divisant ou en multipliant par 10 000. Puisque les nombres stockés au format Currency sont des représentations exactes, les opérations sur les valeurs Currency ne sont pas sujettes à des erreurs d'arrondi.</p>
                            <p><span class="em">Remarque :</span> Le type Real48 qui correspond à l'ancien type Real est fourni pour assurer une compatibilité avec les versions précédentes de Pascal. Comme son format de stockage n'est pas natif dans la gamme CPU d'Intel, les opérations sur des valeurs de ce type sont plus lentes que d'autres types de calcul en virgule flottante. Les types Single, Double et Extended correspondent aux formats natifs des processeurs Intel Pentium, de précision simple, double et étendue.</p>
                            <p>Mathématiquement, le type réel comporte un nombre infini de valeurs. Dans tout ordinateur, cependant, une information de type réel est codée sur un nombre limité de bits. Entre deux valeurs de type réel, il n'existe pas toujours une valeur de type réel. L'arithmétique utilisée avec des valeurs de type réel peut conduire à des résultats légèrement faussés en raison des erreurs d'arrondi. Si les types entiers sont des types exacts, les types réels sont par essence des approximations ... et peuvent donc introduire des problèmes de précision et de portabilité. Les nombres réels sont représentés en notation à virgule flottante? Ils se composent d'une partie fractionnaire (la mantisse) que multiplie un exposant. Le nombre de chiffres significatifs de la mantisse et l'intervalle de valeurs possibles pour l'exposant déterminent l'intervalle et la précision du type réel.</p>
                            <p class="em">Remarque : Toutes les opérations arithmétiques sur des valeurs de type réel sont exécytées avec l'intervalle et la précision du type EXTENDED. Cette plus grande précision permet de réduire les erreurs d'arrondi, et la largeur de l'intervalle permet de réduire les risques de dépassements de capacité positifs et négatifs.</p>
                            <h4>Comparaison de réels :</h4>
                            <p>Du fait que les valeurs de type réel sont des approximations, les résultats de comparaisons de valeurs de types réels différents ne sont pas toujours conformes à l'attente.</p>
<pre><code>//...
var
    x : Single ;
    y : Double ;
    r : Real ;

begin
    x := 1 / 3 ;
    y := 1 /3 ;
    writeln(x : y) ;    // FALSE
    r := 1 / 3 ;
    writeln(r = 1 / 3) ;    // FALSE
    // ...
end.</code></pre>
                            <p>Le premier writeln affichera FALSE. Cette "inexactitude" vient de ce que la précision de x est de 7 à 8 chiffres, alors que celle de y est de 15 à 16 chiffres. Ainsi, lorsque ces deux valeurs sont converties en type extended, elles ne coïncident que sur 7 ou 8 chiffres. De la même manière, le deuxième writeln affichera FALSE puisque le résultat de 1/3 est calculé avec 20 chiffres significatifs.</p>
<pre><code>//...
var
    s : Single ; d : Double ; e : extended ;
begin
    s := 1 / 3 ; d := 1 / 3 ; e := 1 / 3 ;
    writeln(s : 20 : 17) ;  // 0.33333334326744080
    writeln(d : 20 : 17) ;  // 0.33333333333333331
    writeln(e : 20 : 17) ;  // 0.33333333333333333
    //...
end.</code></pre>
                            <h4>Opérations :</h4>
                            <p>Un certain nombre d'opérateurs arithmétiques binaires correspondent aux types réels.</p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Opérateurs</th>
                                        <th>Opérations</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>+</td>
                                        <td>addition réelle</td>
                                    </tr>
                                    <tr>
                                        <td>-</td>
                                        <td>soustraction réelle</td>
                                    </tr>
                                    <tr>
                                        <td>*</td>
                                        <td>multiplication réelle</td>
                                    </tr>
                                    <tr>
                                        <td>/</td>
                                        <td>division réelle</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="em">Il est à remarquer que pour l'addition, la soustraction et la multiplication réelle, il suffit qu'un des opérandes soit de type réel (l'autre pouvant être de type entier).</p>
                            <p class="em">Pour la division réelle (/), il est même permis que les deux opérandes soient de type entier; le résultat est évidemment toujours de type réel. Rappelons que le dénominateur doit être différent de zéro.</p>
                            <p>Comme pour le type entier, il existe deux opérateurs arithmétiques unaires : l'opérateur identité de signe (+) et l'opérateur inversion de signe (-).</p>
                            <p>-(-8.3) est équivalent à +8.3 ou 8.3.</p>
                            <p>Les opérateurs relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type réel; le type du résultat est évidemment booléen. Signalons pour terminer qu'un des opérandes peut être de type entier et l'autre d'un type réel.</p>
                        </li>
                        <li>
                            <h3>Types scalaires prédéclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Types entiers :</h4>
                                    <p>Pascal Objet distingue sept types fondamentaux (<span class="em">ne dépendant ni du processeur, ni du système d'exploitation</span>). Chacun d'eux représente un sous-ensemble particulier de valeurs entières.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format (en bits)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>SHORTINT</td>
                                                <td>-128..+127</td>
                                                <td>8 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>SMALLINT</td>
                                                <td>-32768..32767</td>
                                                <td>16 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGINT</td>
                                                <td>-2147483648..2147483647</td>
                                                <td>32 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>INT64</td>
                                                <td>-2<sup>63</sup>..2<sup>63</sup>-1</td>
                                                <td>64 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>BYTE</td>
                                                <td>0..255</td>
                                                <td>8 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>WORD</td>
                                                <td>0..65535</td>
                                                <td>16 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGWORD</td>
                                                <td>0..4294967295</td>
                                                <td>32 (non signé)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les types entiers génériques sont <span class="html">Integer</span> et <span class="html">Cardinal</span>. L'intervalle et le format sont ceux qui permettent les calculs entiers les plus rapides en tenant compte du processeur et du système d'exploitation sous-jacent.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-32768..32767</td>
                                                <td>16-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..65535</td>
                                                <td>16-bits non signé</td>
                                            </tr>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-2147483648..214743647</td>
                                                <td>32-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..4294967295</td>
                                                <td>32-bits non signé</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les propriétés de l'arithmétique ordinaire ne s'appliquent que dans la mesure où le résultat de l'opération reste dans le domaine, c'est-à-dore qu'il n'y ait pas de <span class="em">dépassement de capacité</span>. Cette restriction mise à part, toute opération sur des données entières est exacte.</p>
                                    <p>Les opérateurs suivants s'appliquent à des opérandes de type entier et produisent un résultat entier.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateurs</th>
                                                <th>Opérations</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>+</td>
                                                <td>addition entière</td>
                                            </tr>
                                            <tr>
                                                <td>-</td>
                                                <td>soustraction entière</td>
                                            </tr>
                                            <tr>
                                                <td>*</td>
                                                <td>multiplication entière</td>
                                            </tr>
                                            <tr>
                                                <td>DIV</td>
                                                <td>division entière</td>
                                            </tr>
                                            <tr>
                                                <td>MOD</td>
                                                <td>modulo (reste de la division entière)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les opérateurs DIV et MOD exigent que le second opérande soit différent de zéro.</p>
                                    <p>Les opérateur relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type entier; le type du résultat est évidemment booléen.</p>
                                    <p>Il existe également des opérations logiques qui s'appliquent à des entiers pour donner des entiers. Ces "entiers" doivent cependant s'interpréter comme des <span class="em">chaînes de bits</span>.</p>
                                    <p>Les opérations <span class="em">I shl J</span> et <span class="em">I shr J</span> décalent la valeur I de J bits vers la gauche pour shl, et vers la droite pour shr. Le résultat est du même type entier que I.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Types des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not</td>
                                                <td>négation binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shl</td>
                                                <td>décalage à gauche binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shr</td>
                                                <td>décalage à droite binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                        </tbody>
                                    </table>
<pre><code>program TestBin;
{$APPTYPE CONSOLE}

const ZERO : Cardinal = 0 ;
var  masque , x : Cardinal ;

begin
        write('valeur positive : ') ;
        readLn(x) ;

        masque := not(not ZERO shr 1) ;
        repeat
                if (x and masque) &lt;&gt; ZERO
                    then write('1')
                    else write('0')
                {fi} ;
                masque := masque shr 1
        until masque = ZERO ;
        writeLn   ;
        readLn
end.</code></pre>
                                    <img src="../images/TestBin.png" alt="">
                                </li>
                                <li>
                                    <h4>Type CHAR :</h4>
                                    <p>Le type CHAR comprend l'ensemble des caractères disponibles. Malheureusement il n'existe pas d'ensemble de caractères qui soit accepté par tous les ordinateurs. La définition du Pascal standard ne donne donc que des conventions générales.</p>
                                    <p>Ainsi, l'ordre des caractères doit préserver l'ordre alphabétique des lettres et l'ordre numérique des chiffres : <span class="em">'a' &lt; 'b'</span> et <span class="em">'0' &lt; '9'</span>.</p>
                                    <p>Les valeurs de type CHAR sont pourvues d'un nombre ordinal qui est un entier non négatif et qui traduit le rang de chaque caractère. L'implémentation qui est la nôtre a été décrite au chapitre 3. Le caract!re 'A' y possède le numéro d'ordre 65, 'B' 66, ... 'a' 95 et 'b' 96 ...</p>
                                    <p>Les opérateurs relationnels s'appliquent à des opérandes de type CHAR. Dans notre environnement, l'expression (<span class="em">'A' &lt; 'a'</span>) a la valeur TRUE.</p>
                                    <p>Toutes ces propriétés nous rappellent bien que le type de caracyère générique.</p>
                                    <p>Les types de caractères fondamentaux sont AnsiChar et WideChar.</p>
                                    <p>Les valeurs du type AnsiChar sont les caractères (en octets), rangés dans l'ordre du jeu de caractères ANSI étendu.</p>
                                    <p>Les valeurs du type WideChar sont les caractères (en mots), rangés dans l'ordre du jeu Unicode. Les 256 premiers caractères du jeu Unicode correspondent aux caractères ANSI.</p>
                                </li>
                                <li>
                                    <h4>Type BOOLEAN :</h4>
                                    <p>Une valeur booléenne est une des valeurs logiques "vrai" ou "faux" que l'on notera par les identificateurs de constantes prédéfinis TRUE et FALSE.</p>
                                    <p>Les opérateurs booléens sont :</p>
                                    <ul>
                                        <li>
                                            <p>la conjonction logique (AND)</p>
                                        </li>
                                        <li>
                                            <p>la disjonction logique (OR)</p>
                                        </li>
                                        <li>
                                            <p>la négation (NOT)</p>
                                        </li>
                                        <li>
                                            <p>le Pascal Objet ajoute l'opérateur XOR qui correspond au <span class="em">ou exclusif logique</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Ces opérateurs "opèrent" entre variables, constantes et expressions de types booléens.</p>
                                    <h5>Opérations booléennes :</h5>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Type des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not (unaire)</td>
                                                <td>négation logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Si p et q sont des variables booléennes, on a :</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>p</th>
                                                <th>q</th>
                                                <th>p AND q</th>
                                                <th>p OR q</th>
                                                <th>p XOR q</th>
                                                <th>NOT p</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les autres fonctions logiques (il y en a seize en tout !) peuvent être construites grâce aux opérateurs de relation.</p>
                                    <h5>Lois de de Morgan :</h5>
                                    <p>Les lois de de Morgan sont souvent très utiles si l'on désire, par exemple, passer d'une condition de continuation à la condition de terminaison inverse.</p>
                                    <p>NOT (p OR q) = NOT p AND NOT q</p>
                                    <p>NOT (p AND q) = NOT p OR NOT q</p>
                                    <p>Exemple : le complémentaire de l'expression booléenne <span class="em">(x &gt;= 15) OR (y &lt; 4)</span> est <span class="em">(x &lt; 15) AND (y &gt;= 4)</span>.</p>
                                    <p>Le type booléen est ordonné; il est en effet prédéfini de façon à ce que FALSE &lt; TRUE. AU niveau format interne des données, un type booléen est stocké comme un octet qui peut prendre la valeur 0 (FALSE) et 1 (TRUE).</p>
                                    <p>En fait, le type booléen est un type énuméré.</p>
                                    <p>Comme le type booléen est un type scalaire ordonné, nous pouvons définir simplement toutes les fonctions logiques.</p>
                                    <p>Si p et q sont deux booléens :</p>
                                    <p>p &lt;= q définit l'implication</p>
                                    <p>p = q définit l'équivalence</p>
                                    <p>p &lt;&gt; q définit le ou exclusif</p>
                                    <h5>Entrées-Sorties :</h5>
                                    <p>S'il est possible d'imprimer une valeur booléenne, il est par contre impossible de lire <span class="em">directement</span> un booléen !</p>
<pre><code>program TestBool;
{$APPTYPE CONSOLE}

var nbre1, nbre2 : Integer ;
    croissant    : Boolean ;
begin
        write(' Entrez deux entiers : ') ;
        readLn(nbre1,nbre2) ;
        croissant := nbre1 &lt;= nbre2 ;
        writeln('ordre croissant : ', croissant) ;

        readLn
end.</code></pre>
                                    <img src="../images/TestBool.png" alt="">
                                    <p>Remarques : l'instruction test := Nbre1 &lt; Nbre2 est péférable à l'instruction conditionnelle :</p>
<pre><code>if Nbre1  &lt;=  Nbre2
    then test := true
    else test := false
{fi}</code></pre>
                                    <p>Signalons enfin que les types ByteBool, WordBool et LongBool existent pour proposer une compatibilité avec l'environnement Windows et certains langages.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Types scalaires déclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Type énuméré :</h4>
                                    <p>Nous pouvons définir un nouveau type simple en énumérant toutes les valeurs distinctes qui le composent. Les valeurs de ce nouveau type sont représentées par des identificateurs et sont donc des constantes du nouveau type.</p>
                                    <p>La définition d'un type énuméré de la forme :</p>
<pre><code>Type enum = (c1,c2,...,cn) ;</code></pre>
                                    <ul>
                                        <li>
                                            <p><span class="em">enum</span> est l'identificateur du nouveau type.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">c1,c2,...,cn</span> sont les nouveaux identificateurs de constantes.</p>
                                        </li>
                                    </ul>
                                    <p>Exemples :</p>
<pre><code>Type Tcouleur = (BLEU,JAUNE,VERT,ROUGE) ;
     Tjour = (LU,MA,ME,JE,VE,SA,DI) ;
     TAssaisonnement = (HUILE,VINAIGRE,SEL,POIVRE) ;
     Tchoix = (AM,STRAM,GRAM) ;
     Tnote = (UT,RE,MI,FA,SOL,LA,SI) ;</code></pre>
                                    <p>La définition de chacun de ces types introduit :</p>
                                    <ul>
                                        <li>
                                            <p>un nouvel identificateur de type (<span class="em">TChoix</span> par ex.)</p>
                                        </li>
                                        <li>
                                            <p>l'ensemble des identificateurs dénotant les valeurs de ce nouveau type (AM,STRAM,GRAM).</p>
                                        </li>
                                    </ul>
                                    <p>Nous pouvons dès lors utiliser ces identificateurs comme des constantes.</p>
                                    <p>Les identificateurs qui dénotent les valeurs d'un nouveau type correspondent à des constantes et s'utilisent comme telles. Il convient évidemment de ne déclarer une constante que dans une seule déclaration de type. Ainsi, les déclarations suivantes sont <span class="em">erronées</span> :</p>
<pre><code>Type Fruit = (pomme,orange,pore) ;
     Color = (bleu,rouge,orange) ;</code></pre>
                                    <p>Suppons les déclarations de variables suivantes :</p>
<pre><code>var col1, col2 : TCouleur;
    ch : TChoix;
    n : TNote;</code></pre>
                                    <p>nous pouvons écrire :</p>
<pre><code>col1 := ROUGE ;  // col1 := TCouleur(3) ;
col2 := VERT ;  // col2 := TCouleur(2) ;
n := FA ;   // n := TNote(3) ;
ch := GRAM ;    // ch := TChoix(2) ;</code></pre>
                                    <p>Comme dans tout type scalaire, il existe un ordre; cet ordre est déterminé par l'ordre d'écriture des identificateurs de constantes dans la déclarative.</p>
<pre><code>BLEU &lt; JAUNE &lt; VERT &lt; ROUGE</code></pre>
                                    <h5>Format interne des données :</h5>
                                    <p>Les scalaires énumérés ayant moins de 256 valeurs possibles sont rangés dans un seul octet (sinon deux). Cet octet contient la valeur ordinale de la variable; la valeur ordinale correspond au rang. Le rang d'une constante énumérée est déterminé par sa position dans la séquence d'énumération, la première constante ayant le rang 0. Aussi le rang (valeur ordinale) de <span class="em">jaune</span> est <span class="em">1</span> et celui de <span class="em">rouge</span> est <span class="em">3</span>.</p>
                                    <p>Une variable de type <span class="em">TCouleur</span> (exemple <span class="em">col1</span>) pourra prendre une des quatre valeurs : BLEU, JAUNE, VERT ou ROUGE. Le domaine du type <span class="em">TCouleur</span> correspond bien à un ensemble fini et ordonné (type SCALAIRE).</p>
                                    <p>Les opérateurs relationnels (=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=) peuvent s'appliquer à tous les types énumérés tant que les deux opérandes sont de même type.</p>
                                    <p><span class="em">(col1 &lt;= col2)</span> est une expression booléenne.</p>
                                    <p><span class="em">Remarque : À propos de booléen, signalons que le type boolean est en fait un type énuméré prédéclaré : <span class="html">Type boolean = (false,true)</span></span>.</p>
                                    <p>Les fonctions standards comme ORD, PRED, SUCC peuvent être utilisées avec des arguments de type scalaire et donc énuméré.</p>
                                    <p>Les variables de type énuméré pourront également être utilisées comme compteur de boucle ou sélecteurs de cas.</p>
                                    <p>Les variables et les valeurs d'un type énuméré ne sont pas acceptées par writeln, read et readln...</p>
                                    <p>Les langages de programmation qui permettent la définition de types énumérés nous offrent un mécanisme simple d'ABSTRACTION; il contient de les utiliser toutes les fois où cela est possible. D'une part, cela augmente la lisibilité de vos programmes, d'autre part cela renforce le typage de vos données. Un typage sévère assure que chaque objet a un ensemble bien défini de valeurs et qu'un ensemble bien défini d'opérations s'applique à ces objets : cela empêche les confusions entre des concepts logiquement différents.</p>
                                    <p>Dans des langages plus anciens, il est souvent nécessaire d'implémenter des concepts comme les types énumérés à l'aide de types plus primitifs tels que les entiers et de donner des valeurs telles 0, 1, 2 et 3 à des vakeurs comme bleu, jaune, vert et rouge. Des affectations accidentelles comme col1 := col2 + 10 ne peuvent alors être détectées par le compilateur (il y a pourtant une double erreur : au niveau de l'oépration + et au niveau du domaine des valeurs).</p>
                                </li>
                                <li>
                                    <h4>Type intervalle :</h4>
                                    <p>On constate souvent qu'une variable doit prendre ses valeurs dans un intervalle de valeurs bien déterminé. Il est alors intéressant de définir un nouveau type (sous-type), caractérisé par un ensemble de valeurs qui est un sous-ensemble de valeurs d'un autre type de base, type associé ou type hôte.</p>
                                    <p>Un type de données peuvent être défini comme un intervalle d'un autre type scalaire déjà défini. Cette définition donne la plus petite et la plus grande valeur de l'intervalle. La première constante spécifie la borne inférieure et ne dois pas être plus grande que la deuxième constante, la borne supérieure (ces deux constantes sont du même type scalaire).</p>
                                    <p>Un type intervalle conserve toutes les priorités du type scalaire associé; il n'y a aucun moyen de restreindre l'ensemble des opérations du type de base ! Il n'est restreint que dans l'échelle de ses valeurs; c'est pourquoi on peut parler de <span class="em">sous-type</span>.</p>
                                    <p>Exemples :</p>
<pre><code>type TJour = (LU,MA,ME,JE,VE,SA,DI) ;
     THeure = 0..60 ;
     TMajuscule = 'A'..'Z' ;
     Travail = LU..VE ;</code></pre>
                                    <p>Le type Travail est un sous-type du type TJour qui doit être défini préalablement.</p>
                                    <p>Si nous déclarons <span class="em">var h : THeure ;</span>, l'affectation <span class="em">h := 15</span> est correcte alors que <span class="em">h := 90</span> ne l'est pas.</p>
                                    <p>Pascal permet lors de la déclaration de variables, l'utilisation de descripteurs de type à la place d'identificateurs de type :</p>
<pre><code>var x : 17..87 ;</code></pre>
                                    <p>plutôt que :</p>
<pre><code>type TInter = 17..87 ;
var x : TInter ;</code></pre>
                                    <p>Nous vous déconseillons un tel raccourci, et même nous vous conseillons la forme déclaratice suivante :</p>
<pre><code>const MAX = 87 ;
      MIN = 17 ;
type TInter = MIN..MAX ;
var x : TInter ;</code></pre>
                                    <p class="em">Remarques : Supposons les déclarations de variables suivantes :</p>
<pre><code>var x : TInter ;
    y : Integer ;</code></pre>
                                    <p class="em">Nous l'avons signalé, une affectation tel que <span class="html">x := 15000</span> est incorrecte; elle sera décelée par le compilateur : il s'agit d'un <span class="html">CONTRÔLE STTAIQUE</span> c'est-à-dire liké au texte.</p>
                                    <p class="em">Par contre l'affectation <span class="html">x := y</span> est parfaitement légale du point de vue syntaxique. Bien sûr, à l'exécution, la valeur de la variable y peut être ou non dans l'intervalle MIN..MAX. Si cette valeur y est comprise, tout va bien; sinon une erreur doit être signalée. Il s'agit alors d'un <span class="html">CONTRÔLE DYNAMIQUE</span> c'est-à-dire lié à l'exécution. L'affectation <span class="html">y := x</span> marchera évidemment toujours.</p>
                                    <p class="em">Pascal Objet n'introduit pas <span class="html">automatiquement</span> des tests de validité à l'exécution. Il convient, pour ce faire, d'activer la vérification des limites.</p>
                                    <q class="em">Une déclaration de type intervalle n'introduit pas vraiment de nouveau type mais plutôt un sous-type, c'est-à-dire un sous-ensemble défini au moyen d'une constrainte (la restriction ne s'appliquant qu'aux valeurs).</q>
                                    <p class="em">Le rang de chaque valeur d'un intervalle est celui qu'elle a dans le type de base.</p>
                                    <img src="../images/type_intervalle_Pascal.png" alt="">
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Procédures et fonctions standards :</h3>
                            <p>Vous connaissez déjà des procédires prédéclarées comme write et writeln.</p>
                            <p>Pascal Objet propose les procédures de décrémentation (dec) et d'incrémentation (inc).</p>
                            <p>Si x est une variable de type scalaire et n une expression facultative de type entier alors :</p>
                            <ul>
                                <li>
                                    <p>dec(x) correspond à l'instruction x := x - 1</p>
                                </li>
                                <li>
                                    <p>dec(x,n) correspond à l'instruction x := x - n</p>
                                </li>
                                <li>
                                    <p>inc(x) correspond à l'instruction x := x + 1</p>
                                </li>
                                <li>
                                    <p>inc(x,n) correspond à l'instruction x := x + n</p>
                                </li>
                            </ul>
                            <p>Les procédures dec et inc génèrent un code optimisé.</p>
                            <p>Une foncion est un sous-prgramme qui renvoie une valeur; d'un point de vue syntaxique et sémantique, une fonction correspond à une expression.</p>
                            <p>Il existe ainsi une série de fonctions mathématiques prédéfinies qui facilitent la programmation en Pascal :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Fonction</th>
                                        <th>Valeur</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>abs(x)</td>
                                        <td>valeur absolue de x</td>
                                    </tr>
                                    <tr>
                                        <td>arcTan(x)</td>
                                        <td>arc dont la tangente est x</td>
                                    </tr>
                                    <tr>
                                        <td>cos(x)</td>
                                        <td>cosinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>exp(x)</td>
                                        <td>exponentielle de x : e<sup>x</sup></td>
                                    </tr>
                                    <tr>
                                        <td>frac(x)</td>
                                        <td>partie fractionnaire de x</td>
                                    </tr>
                                    <tr>
                                        <td>int(x)</td>
                                        <td>partie entière de x</td>
                                    </tr>
                                    <tr>
                                        <td>ln(x)</td>
                                        <td>logarithme naturel de x</td>
                                    </tr>
                                    <tr>
                                        <td>pi</td>
                                        <ts>valeur de pi</ts>
                                    </tr>
                                    <tr>
                                        <td>sin(x)</td>
                                        <td>sinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqr(x)</td>
                                        <td>carré de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqrt(x)</td>
                                        <td>racine carrée de x</td>
                                    </tr>
                                </tbody>
                            </table>
<pre><code>program TestFonctionsArithmetiques ;
{$APPTYPE CONSOLE}

var r : Real ;
    i : Integer ;

begin
    i := abs(-123) ;
    r := sqr(12.3) ;
    writeln(i) ;               	{123}
    writeln(r:8:4) ;	 		{151.2900}
    writeln(sqrt(r):8:4) ;	 	{ 12.3000}

    readLn
end.</code></pre>
                        </li>
                        <li>
                            <h3>Règles de priorité :</h3>
                            <p>Une expression est une phrase de programme spécifiant un calcul sur un ou des opérandes et dont l'exécution produit un résultat. Telle que nous l'envisageons ici, une expression renvoie une valeur.</p>
                            <p>Dans l'évaluation d'une expression où interviennent plusieurs opérateurs, il convient d'éliminer toute ambiguïté dans l'ordre de réalisation des opérations. Chaque langage définit pour ce faire certaines règles et associé à chaque opérateur une priorité.</p>
                            <p>Le langage Pascak divise l'ensemble des opérateurs en catégories hiérarchiques (du plus prioritaire au moins prioritaire) :</p>
                            <ul>
                                <li>
                                    <p>le moins unaire</p>
                                </li>
                                <li>
                                    <p>les opérateurs not, @</p>
                                </li>
                                <li>
                                    <p>les opérateurs multiplificatifs (*, /, DIV, MOD, AND, SHL, SHR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs additifs (+, -, OR, XOR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs relatinnels (=, &lt;&gt;, &lt;=, &gt;=, &lt;, &gt;, IN, IS ...)</p>
                                </li>
                            </ul>
                            <p>Considérons un opérande entre deux opérateurs :</p>
                            <ul>
                                <li>
                                    <p>Si les opérateurs sont de même priorité, l'opérande sera liée à l'opérateur de gauche sinon au plus prioritaire.</p>
<pre><code>2 + x * 4 &lt;=&gt; 2 + (x * 4) { * plus prioritaire }
3 * x /2 &lt;=&gt; (3 * x) / 2 { même priorité =&gt; opérateur de gauche }</code></pre>
                                </li>
                                <li>
                                    <p>Afin de traiter leur résultat comme un seul opérande, les expressions contenues entre parenthèses sont évaluées en premier lieu. Nous vous conseillons d'utiliser les parenthèses.</p>
                                    <p>Exemple :</p>
                                    <p>Si on attribue respectivement aux variables entières a, b et c les valeurs 8, 15 et -4, comment sera évaluée l'expression numérique suivante :</p>
<pre><code>2 * ((a mod 5) * (4 + (b -3) / sqr (c + 2)))</code></pre>
                                    <img src="../images/regles_priorites_Pascal.png" alt="">
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="instructions_structurees">Instructions structurées :</h2>
                    <p class="em">Nous allons au cours de ce chapitre étudier deux nouvelles instructions structurées : l'instruction "FOR" qui est une répétitive et l'instruction "CASE" qui est une conditionnelle particulière.</p>
                    <ul>
                        <li>
                            <p>L'instruction IF dans le choix entre deux éventualités selon la valeur booléenne d'une expression. L'instruction CASE, ou instruction de sélection, permet de choisir entre n éventualités selon la valeur discrète d'une expression appelée expression de sélection. Cette instruction permettra donc à votre programme d'effectuer - sous certaines conditions - un choix parmi plusieurs possibilités sans devoir employer des quantités d'instructions IF.</p>
                        </li>
                        <li>
                            <p>L'instruction FOR s'utilisera lorsque l'on désirera lorsque l'on désirera un certain traitement un nombre précis de fois.</p>
                        </li>
                    </ul>
                    <p>Ces deux instructions ont en commun le fait qu'elles sont à la fois limitées et puissantes.</p>
                    <p>Une autre caractéristique commune est le fait qu'elles ne sont pas "standardisées". D'un langage algorithmique à l'autre et même parfois d'une implémentation à l'autre d'un même langage, des variantes significatives existent.</p>
                    <p>Proposer dans ce cas une forme générale de ces instructions en L.D.A est difficile. Tout au plus, pouvons-nous proposer une traduction L.D.A des instructions "CASE" et "FOR" Pascal !</p>
                    <p>Par exemple :</p>
<pre><code>cas où (expression de sélection) vaut
    v1 : traitement1
    v2 : traitement2
    ... : ...
    autres cas : traitementN
fincas

pour Vc allant de Vi à Vf par pas de +1 faire
    traitement
fpour</code></pre>
                    <p>Avant de passer à l'étude détaillée de ces deux instructions, il peut être intéressant de signaler qu'il existe dans certains langages une instruction de sélection généralisée sans sélecteur que l'on nomme choix multiple.</p>
                    <p>La forme L.D.A du choix multiple pourrait être la suivante :</p>
<pre><code>cas où
        condition1 : traitement1
        condition2 : traitement2
        ...
        autre cas : traitementN
fincas</code></pre>
                    <p>Dans un choix multiple, les conditions sont mutuellement exclusives. Cette instruction peut être facilement simulée en Pascal :</p>
<pre><code>if expr1
    then instruction1
    else
        if expr2
            then instruction2
            else
                if expr3
                    then instruction3
                    else instructionN</code></pre>
                    <p>Pour éviter une cascade inutile de tests, on a tout intérêt à ordonner les tests dans le sens des probabilités décroissantes. Il n'y a, de plus, aucune raison d'imbriquer les instructions...</p>
<pre><code>if expr1 then instruction1
else if expr2   then instruction2
else if expr3   then instruction3
else    instructionN</code></pre>
                    <ol>
                        <li>
                            <h3>Instruction CASE :</h3>
                            <p>L'instruction CASE est utilisée pour choisir une action parmi plusieurs suivant la valeur d'une expression.</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_CASE_Pascal.png" alt="">
                            <p>Exemples :</p>
<pre><code>...
case abs(k) of
    0 : p := 0 ;
    1..5,7 : begin
                p := m - 1
                m := 0
             end ;
    else{case} p := m + 1
end{case}
...</code></pre>
<pre><code>case caract of
    'a', 'e', 'i', 'o', 'u', 'y' : writeln('voyelle minuscule') ;
    'A', 'E', 'I', 'O', 'U', 'Y' : writeln('voyelle majuscule') ;
    'b'..'d', 'f'..'h', 'j'..'n', 'p'..'t', 'v'..'x', 'z' : writeln('consonnes minuscules') ;
    'B'..'D', 'F'..'H', 'J'..'N', 'P'..'T', 'V'..'X', 'Z' : writeln('consonnes majuscules') ;
    '0'..'9' : writeln('chiffres')
    else{case} writeln('autres caractères ...')
end{case} ;
...</code></pre>
                            <h4>Sémantique :</h4>
                            <p>L'exécution de cette instruction conditionnelle commence par celle de l'expression de sélection qui produit une valeur V d'un type scalaire. Le choix de la liste de choix qui contient cette valeur V parmi les sélecteurs de sa liste de sélecteurs est sélectionné et l'action correspondante est exécutée.</p>
                            <p>Les sélecteurs sont aussi appelés étiquettes de cas ou encore constantes de cas; ces sélecteurs sont en effet des constantes.</p>
                            <p>Ils doivent être <span class="em">uniques</span> et d'un type scalaire compatible avec le type de l'expression de sélection. <span class="em">Dans les réalisations anciennes, Pascal Objet imposait que l'expression de sélection soit d'un type scalaire dont les bornes étaient comprises entre certaines valeurs (-32768 et 32767).</span></p>
                            <p>Que se passe-t-il si aucun des sélecteurs ne correspond à la valeur de sélection ?</p>
                            <ul>
                                <li>
                                    <p>Si la partie ELSE (autre choix) est présente, l'instruction correspondante est exécutée,</p>
                                </li>
                                <li>
                                    <p>sinon aucune instruction n'est exécutée et le traitement se poursuit par l'exécution de l'instruction (si elle existe) qui suit l'instruction CASE.</p>
                                </li>
                            </ul>
                            <p class="em">Remarques :</p>
                            <ul>
                                <li>
                                    <p class="em">En Pascal, l'instruction case possède cependant certains défauts. En absence d'une clause else, le fait qu'aucune des constantes de cas ne soit égale à la valeur de l'expression de sélection devrait constituer une ereeur.</p>
                                </li>
                                <li>
                                    <p class="em">Autre remarque qui est une constation : le else d'une instruction case peut être précédé d'un point-virgule (;) et le délimiteur final d'une construction case est le mot réservé end (auquel ne correspond aucun begin !).</p>
                                </li>
                                <li>
                                    <p class="em">Pour les différencier de leurs autres utilisations, il peut être utile d'ajouter un commentaire à ces mots réservés (cfr exemple ci-dessus else{case} et end{case}).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Instruction FOR :</h3>
                            <p>L'instruction for indique qu'une instruction (le corps de la répétitive) doit être exécutée un nombre précis de fois, pendant qu'une variable de contrôle progresse au sein d'une intervalle de valeurs discrètes.</p>
                            <p>La variable de contrôle progresse donc entre deux valeurs fixées : la valeur initiale et la valeur finale, et cette progression est soit ascendante (TO), soit descendante (DOWNTO).</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_FOR_Pascal.png" alt="">
                            <p>L'emploi du mot réservé to provoque l'incrémentation d'une unité à la fois de la variable de contrôle à chaque tour de boucle, alors que l'emploi de downto en provoque la décrémentation.</p>
                            <p>L'instruction n'est pas exécutée si, en utilisant la clause to, la valeur initiale est strictement supérieure à la valeur finale ou si, en utilisant la clause downto, la valeur initiale est strictement inférieure à la valeur finale.</p>
                            <p>La variable de contrôle est une variable (<span class="em">déclarée dans le bloc contenant l'instruction for</span>) de type scalaire et les valeurs initiales et finales sont des expressions de type compatible avec la variable de contrôle.</p>
                            <p>L'instruction suivante provoquera l'affichage des valeurs de 1 à 10 :</p>
<pre><code>for compteur := 1 to 10 do write(compteur:4)</code></pre>
                            <p>Celle-ci lit n entiers et effectue leur somme :</p>
<pre><code>somme := 0 ;
for compteur := 1 to n do
    begin
        readln(nbre) ;
        somme := somme + nbre
    end ;
...</code></pre>
                            <p>Voici, comme dernier exemple un programme dont l'exécution provoquera l'affichage des jours de la semaine.</p>
<pre><code>program AfficherJourSemaine ;
{$APPTYPE CONSOLE}

type TJour = (LU,MA,ME,JE,VE,SA,DI) ;

var j : TJour ;

begin
    for j := LU TO DI DO
    case j of
        LU : writeln('lundi') ;
        MA : writeln('mardi') ;
        ME : writeln('mercredi') ;
        JE : writeln('jeudi') ;
        VE : writeln('vendredi') ;
        SA : writeln('samedi');
        DI : writeln('dimanche')
    end{case}  ;

    readLn
end.</code></pre>
                            <p>Dans de nombreux ouvrages, on retrouve l'assertion suivant laquelle l'instruction :</p>
<pre><code>for indice := expr1 to expr2 do instruction</code></pre>
                            <p>est équivalente aux instructions suivantes :</p>
<pre><code>indice := expr1 ;
while indice &lt;= expr2 do
    begin
        instruction ;
        inc(indice)
    end</code></pre>
                            <p>Il convient de relativiser cette "équivalence".</p>
                            <p>La définition du langage Pascal impose certaines restrictions au sujet de l'instruction FOR :</p>
                            <ul>
                                <li>
                                    <p>La valeur de la variable de contrôle ne peut en aucun cas être modifiée dans l'instruction qui correspond au corps de la boucle (<span class="em">Pascal Objet permet la modification de la variable de contrôle dans le corps de la boucle ! Ne profitez pas de ce laxisme coupable !</span>).</p>
                                </li>
                                <li>
                                    <p>La valeur finale est déterminée une seule fois lors de l'entrée dans la boucle for. Ainsi si expr2 correspondait à la valeur d'une certaine variable Vf, la modification de la valeur de Vf dans le corps de la boucle ne changerait pas le nombre de répétitions.</p>
                                </li>
                                <li>
                                    <p>À la sortie (normale) de l'instruction for, la valeur de la variable de contrôle est indéfinie.</p>
                                </li>
                            </ul>
                            <p>Dans le manuel de référence, l'instruction <span class="em">for v:= expr1 to expr2 do Corps</span> est dite équivalente à :</p>
<pre><code>begin
    temp1 := expr1 ;
    temp2 := expr2 ;
    if temp1 &lt;= temp2 then
        begin
            V := temp1 ;
            Corps ;
            while V &lt;&gt; temp2 do
                begin
                    V := succ(V) ;
                    Corps
                end
        end
end</code></pre>
                            <p>temp1 et temp2 sont des variables temporaires du même type que la variable de contrôle V et qui n'apparaissent nulle part ailleurs dans le programme.</p>
                            <p>Cette équivalence est <span class="em">logique</span> et l'utilisation du for générera un <span class="em">code optimisé</span> !</p>
                            <p>Application :</p>
                            <ul>
                                <li>
                                    <p>Justifiez cette équivalence.</p>
                                </li>
                                <li>
                                    <p>Réécrire les programmes du chapitre 4 où l'utilisation de l'instruction for est souhaitable.</p>
                                </li>
                            </ul>
                            <p class="em">Remarque : Curieusement, à partir de la version du Pascal Objet qui correspond à Delphi 4, la réalisation du for a changé et l'équivalence présentée ici a disparu du manuel de référence. La valeur non significative de la variable de contrôle est "égale" à succ(temp2) si l'itération a eu lieu !</p>
                            <p>Exercices :</p>
<pre><code>program WhileFor;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 31 ;
    EXPR2 : Cardinal = 39 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;

    EXPR2 := 39 ;
    k := EXPR1 ;
    while k &lt;= EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2) ;
            inc(k)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;
    readLn
end.</code></pre>
                            <img src="../images/WhileFor_Pascal.png" alt="">
<pre><code>program breakContinue;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 1 ;
    EXPR2 : Cardinal = 9 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then continue ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4)
    end ;
    writeLn ;

    k := EXPR1 ;
    while k &lt;= EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then
        begin
            inc(k) ;     // sinon vous bouclez !!!
            continue
        end  ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4) ;
        inc(k)
    end ;
    writeLn ;

    readLn
end.</code></pre>
                            <img src="../images/breakContinue_Pascal.png" alt="">
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="type_string">Type string (chaînes courtes) :</h2>
                    <p>Il existe aujourd'hui plusieurs types chaîne.</p>
                    <p>Sans parler des chaînes à zéro terminal, le Pascal Objet gère les types chaînes prédéfinis suivants (<span class="em">manuel de référence</span>) :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Longueur maximum</th>
                                <th>Mémoire nécessaire</th>
                                <th>Utilisation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ShortString</td>
                                <td>255 caractères</td>
                                <td>de 2 à 256 octets</td>
                                <td>string classique</td>
                            </tr>
                            <tr>
                                <td>AnsiString</td>
                                <td>~2<sup>31</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères sur 8 bits</td>
                            </tr>
                            <tr>
                                <td>WideString</td>
                                <td>~2<sup>30</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères Unicode;</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Nous nous intéresserons dans ce chapitre au type <span class="em">string classique</span> qui correspond dans les dernières versions du langage aux chaînes courtes (ShortString). <span class="em">Dans l'état par défaut {$H+}, le compilateur interprète <span class="html">string</span> comme désignant AnsiString. Utilisez la directive <span class="html">{$H-}</span> pour que string soit interprété comme désignant ShortString.</span></p>
                    <p>Nous reviendrons plus tard aux autres types chaînes et, spécialement, aux chaînes longues qui est <q>le type le mieux adapté aux utilisations les plus diverses</q>.</p>
                    <p>Une valeur de type string ou chaînes de caractères est une séquence de caractères de taille variable. Le nombre réel de caractères dans une chaîne peut varier dynamiquement - au cours de l'exécution -, entre 0 et une limite supérieure définie.</p>
                    <p>Les constantes chaînes de caractères sont évidemment compatibles avec les types chaînes de caractères.</p>
                    <ol>
                        <li>
                            <h3>Définition d'un type chaîne de caractères :</h3>
<pre><code>&lt;identificateur&gt; = string [E]</code></pre>
                            <p>L'entier <span class="em">E</span> spécifiant la taille maximale est une constante entière tel que <span class="em">1 &lt;= E &lt; 255</span>.</p>
                            <p>Mprsque l'attribut de taille n'est pas déclaré, il vaut 255 par défaut.</p>
                            <p>Exemple :</p>
<pre><code>type str20 = STRING[20];
     str8 = STRING[8]
     ligne = STRING[80];
     AnyString = STRING;</code></pre>
                            <p>Seules les variables possèdent un type string spécifique, pas les valeurs.</p>
                            <p>Soient les déclarations suivantes :</p>
<pre><code>var ch1 : str8;
    ch2 : str20;
    ch : AnyString;</code></pre>
                            <p>L'exécution de ces déclarations réservera 9 octets pour <span class="em">ch1</span>, 21 pour <span class="em">ch2</span> et 256 octets pour <span class="em">ch</span>. Une chaîne de caractères occupe en effet un octet de plus que son nombre de caractères maximum. Le premier octet contient le caractère dont le rang équivaut à la longueur courante de la chaîne.</p>
                            <p>Lors de l'affectation de la valeur d'une expression chaîne à une variable d'un certain type string, si la longueur maximum de la variable chaîne est dépassée, les caractères en trop sont éliminés.</p>
                            <p>Exemple :</p>
<pre><code>...
ch2 := 'BONJOUR MONDE !';
ch1 := ch2;
writeln(ch2);   {BONJOUR MONDE !}
writeln(ch1);   {BONJOUR}</code></pre>
                            <p class="em">Remarquez :</p>
                            <ul>
                                <li>
                                    <p class="em">que les types chaînes de caractères sont compatibles (puisque ch2 est une valeur chaîne) :</p>
<pre><code>ch1 := ch2</code></pre>
                                </li>
                                <li>
                                    <p class="em">et que l'on peut écrire une expression chaîne et lire une variable chaîne.</p>
<pre><code>...
write('Entre votre nom : ');
readln(ch);
writeln('Bonjour ', ch);
...</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Comment accéder aux éléménts d'une chaîne ?</h3>
                            <p>Nous n'avons pas encore étudié le type tableau. Signalons néanmoins que le type chaîne peut être assimilé à un type tableau possédant des caractéristiques spéciales.</p>
                            <p>Une variable d'un type chaîne pourrait être considérée comme une suite, une liste finie de variables char que l'on aurait regroupées sous un nom. Les éléments de cette liste sont rangés en des positions mémoire successives et sont repérés respectivement par un ensemble d'indices consistant en un certain nombre d'entiers consécutifs.</p>
                            <p>L'expression d'indice (de type BYTE) doit être compris dans l'intervalle 0..E où E est la longueur déclarée de la variable chaîne. Rappelons que le premier caractère d'une variable d'un type chaîne (celui qui correspond à l'indice 0) traduit en fait la longueur courante de la chaîne.</p>
                            <p>La référence à un élément d'une variable chaîne de caractères est réalisée par une référence à la variable chaîne suivie entre crochets par l'expression d'indice qui indique la position de l'élément au sein de la variable chaîne.</p>
                            <p>Exemple :</p>
                            <p>Soit la déclaration :</p>
<pre><code>var s:string[9];</code></pre>
                            <p>Après exécution de l'instruction :</p>
<pre><code>s := 'CHAINES';</code></pre>
                            <p>nous pouvons représenter la variable s de la manière suivante :</p>
                            <img src="../images/chaines_caracteres_Pascal_1.png" alt="">
                            <p><span class="em">writeln(s[2])</span> affichera le caractère '<span class="em">H</span>'.</p>
<pre><code>Program anagramme  ;
{$APPTYPE CONSOLE}

var s : string[9]  ;
    tampon : char  ;
begin
    s := 'CHAINES'   ;
    tampon := s[1]   ;
    s[1]   := s[6]   ;
    s[6]   := s[3]   ;
    s[3]   := s[2]   ;
    s[2]   := tampon ;
    writeln (s)	;      {ECHINAS}

    readLn
end.</code></pre>
                            <p>Vous ne pouvez cependant pas allonger une chaîne par cette méthode.</p>
                            <p><span class="em">s[8] := 'E'</span> n'ajoutera pas de 'E' à la fin de 'ECHINAS'.</p>
                            <p>Pour <span class="em">allonger</span> une chaîne, il faudra utiliser <span class="em">l'opérateur de concaténation (+)</span>.</p>
                            <p><span class="em">s := s + 'E'</span> ajoutera un 'E' à la fin de 'ECHINAS'.</p>
                        </li>
                        <li>
                            <h3>Comparaison de chaînes :</h3>
                            <p>Les opérateurs relationnels <span class="em">=</span>, <span class="em">&lt;&gt;</span>, <span class="em">&lt;</span>, <span class="em">&gt;</span>, <span class="em">&gt;=</span>, <span class="em">&lt;=</span> comparent deux chaînes de caractères. "L'ordre entre deux chaînes est déterminé par les relations d'ordre entre les valeurs des caractères situés en même position dans chacune des chaînes". Comme toutes les valeurs chaînes de caractères sont compatibles, toutes les chaînes peuvent être comparées.</p>
                            <ul>
                                <li>
                                    <p>Si les chaînes ne possèdent pas la même longueur, les caractères de la plus longue chaîne qui ne possèdent pas de correspondant sont considérés comme ayant une valeur supérieure.</p>
                                    <p>Ainsi l'expression <span class="em">'PASCAL' &lt; 'PASCALE'</span> a la valeur true et l'expression <span class="em">'PASCAL ' = 'PASCAL'</span> a la valeur false.</p>
                                    <p>Il est évident que <span class="em">'XZ' &gt; 'XWXYZ'</span> !</p>
                                </li>
                                <li>
                                    <p>Les chaînes vides ('') correspondent à la plus petite valeur et ne peuvent être égales qu'à d'autres chaînes vides.</p>
                                </li>
                                <li>
                                    <p>Signalons enfin qu'une valeur de type char est considérée comme une valeur chaîne de caractères de longueur 1; nous pouvons donc comparer une valeur de type char à une valeur de type chaîne.</p>
<pre><code>if s &lt; 'H'
    then ...</code></pre>
                                </li>
                            </ul>
                            <q class="em">Les fonctions standard high et low acceptent les identificateurs de type chaîne courte et les variables de ces types. High renvoie la longueur maximum du type de chaîne courte alors que low renvoie zéro.</q>
<pre><code>program lowhighstr;
{$APPTYPE CONSOLE}

type Str30 = string[30] ;
var  nom : Str30 ;
begin
    nom := 'TinTin' ;
    writeLn(low(nom)) ;          {0}
    writeLn(high(STr30)) ;       {30}

    readln
end.</code></pre>
                        </li>
                        <li>
                            <h3>Quelques fonctions prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>COPY(&lt;expr.chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">chaine := COPY(ch,p,n)</span></p>
                                    <p>La fonction <span class="html">COPY</span> renvoie une chaîne contenant <span class="em">n</span> caractères de <span class="em">ch</span> à partir de la position <span class="em">p</span>. Si <span class="em">p</span> est supérieur à la longueur de <span class="em">ch</span>, une chaîne vide est renvoyée et si <span class="em">n</span> indique un nombre de caractères qui dépasse la fin de la chaîne <span class="em">ch</span>, seuls les caractères inclus dans la chaîne sont renvoyés.</p>
<pre><code>program test_copy; 
{$APPTYPE CONSOLE}

var ch1,ch2,ch3,ch4:string;
begin
    ch1:='ABCDEFGH'    ;
    ch2:=COPY(ch1,2,3) ;
    ch3:=COPY(ch1,6,5) ;
    ch4:=COPY(ch1,10,4);
    writeLn(ch2);		{BCD}
    writeLn(ch3);		{FGH}
    writeLn(ch4);		{chaîne vide}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>CONCAT(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;,...) :</h4>
                                    <p>Exemple : <span class="em">chaine := CONCAT(ch1,ch2,ch3)</span></p>
                                    <p>La fonction <span class="html">CONCAT</span> renvoie une chaîne de <span class="em">ch1</span>, <span class="em">ch2</span>, <span class="em">ch3</span>. Si sa longueur dépasse 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractères.</p>
                                    <p><span class="em">CONCAT('AB','CDE','F')</span> retourne <span class="em">'ABCDEF'</span>.</p>
                                    <p class="em">Remarque : Pascal propose également l'opérateur + pour traduire l'opération de concaténation. Le type du résultat est le type chaîne de caractères et les types opérandes peuvent être chaîne de caractères ou caractère.</p>
                                    <p class="em">L'expression <span class="html">'AB'+'CDE'+'F'</span> a également la valeur <span class="html">'ABCDEF'</span>.</p>
                                </li>
                                <li>
                                    <h4>LENGTH(&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">longueur := LENGTH(ch)</span></p>
                                    <p>La fonction <span class="html">LENGTH</span> renvoie un entier représentant la longueur effective de la chaîne <span class="em">ch</span>.</p>
                                    <p class="em">Remarque : Le premier octet d'une chaîne contient - indirectement - la longueur courante de la chaîne; elle contient en fait le caractère dont le rang est égal à la longueur courante. Si <span class="html">ch := 'ABCDE'</span> alors <span class="html">ORD(ch[0])</span> est égal à la valeur 5.</p>
                                </li>
                                <li>
                                    <h4>POS(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">position := POS(ss,ch)</span></p>
                                    <p>La fonction <span class="html">POS</span> renvoie un entier (BYTE) représentant la position du premier caractère de <span class="em">ss</span> dans <span class="em">ch</span>.</p>
                                    <p>Si <span class="em">ss</span>n'est pas trouvé, la valeur renvoyée par <span class="em">POS</span> est 0. Cette fonction recherche donc la première occurence d'une sous-chaîne dans une chaîne.</p>
                                    <p>Exemple : <span class="em">POS('SITI', 'POSITION')</span> retourne <span class="em">3</span> et <span class="em">POS('ST', 'POSITION')</span> retourne <span class="em">0</span>.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Quelques procédures prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>DELETE(&lt;variable chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">DELETE(VarStr,p,n)</span></p>
                                    <p>La procédure <span class="html">DELETE</span> supprime <span class="em">n</span> caractères à la valeur de la variable <span class="em">VarStr</span> à partir de la position <span class="em">p</span>.</p>
                                    <p>Si <span class="em">p</span> est supérieur à la longueur de la chaîne <span class="em">VarStr</span>, aucun caractère n'est supprimé. Si <span class="em">n</span> indique plus de caractères qu'il n'en reste à partir de <span class="em">p</span>, seule la fin de la chaîne correspondant à <span class="em">VarStr</span> est effacée.</p>
<pre><code>program  test_delete ; 
{$APPTYPE CONSOLE}

var ch : string[10] ;
begin
    ch := 'ABCDEFGH' ;
    delete(ch,20,3) ;
    writeln(ch) ;			{ABCDEFGH}
    delete(ch,6,10) ;
    writeln(ch) ;           {ABCDE}
    delete(ch,2,2) ;
    writeln(ch)  ;			{ADE}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>INSERT(&lt;expr.chaîne&gt;,&lt;variable chaîne&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">INSERT(ch,VarStr,p)</span></p>
                                    <p>La procédure <span class="html">INSERT</span> insère l'expression chaîne <span class="em">ch</span> dans <span class="em">VarStr</span> en position <span class="em">p</span>.</p>
                                    <p>Lorsque <span class="em">p</span> est supérieure à la longueur courante de <span class="em">Varstr</span>, <span class="em">ch</span> est concaténée à <span class="em">VarStr</span>.</p>
                                    <p>Si la somme de la longueur de l'expression chaîne et de la longueur courante de la variable chaîne dépasse la longueur maximale de cette dernière, il y a évidemment "troncature" après insertion.</p>
<pre><code>program test_insert ; 
{$APPTYPE CONSOLE}

var ch : string[15] ;

begin
    ch := 'ABCDE' ;
    insert('fghijk',ch,10) ;
    writeln(ch) ;                    	{ABCDEfghijk}
    insert('xyz',ch,3) ;
    writeln(ch) ;                    	{ABxyzCDEfghijk}
    insert('mnopq',ch,7) ;
    writeln(ch) ;                     {ABxyzCmnopqDEfg}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>Str et val :</h4>
<pre><code>STR (&lt;expr.numérique [:expr.entière [:expr.entière]]&gt;;&lt;variable chaîne&gt;)</code></pre>
                                    <p>Exemple : <span class="em">STE(NombreReel:taille:NbreDec,VarStr)</span></p>
                                    <p>La procédure <span class="html">STR</span>convertit NombreReel en une chaîne de caractères en respectant les paramètres de formatage <span class="em">taille</span> et <span class="em">NbreDec</span>.</p>
                                    <p>L'expression numérique à convertir est une expression de type entier ou réel. L'effet est identique à un appel à la procédure standard write pourvues des mêmes paramètres, excepté que la chaîne résultante est chargée dans <span class="em">VarStr</span> au lieu d'être écrite dans un fichier texte.</p>
<pre><code>VAL (&lt;expr.chaîne&gt;,&lt;variable num.&gt;,&lt;variable entière&gt;)</code></pre>
                                    <p>Exemple : <span class="em">VAL(s,N,erreur)</span></p>
                                    <p>La procédure <span class="html">VAL</span> convertit une chaîne de caractères représentant une quantité en une valeur numérique. Plus précisément, si <span class="em">s</span> est une expression de type chaîne et N une variable d'un type entier ou réel, alors <span class="em">VAL</span> convertit - si possible - <span class="em">s</span> en une valeur numérique et charge le résultat dans <span class="em">N</span>.</p>
                                    <p>Si vous désirez convertir une chaîne qui représente une quantité entière, nous vous conseillons de déclarer <span class="em">N</span> de type longint, d'effectuer le contrôle des domaines de validité et enfin d'affecter la valeur entière renvoyée. La variable <span class="em">erreur</span> a la valeur zéro si tout c'est bien passé.</p>
                                    <p>Remarque : Toutes les fonctions et procédures présentées ici se trouvent dans l'unité System. Il existe également des routines de gestion de chaînes dans l'unité SysUtils.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Fonction Copy :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Copy(S:String;Index,Count:Integer):String;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Copy renvoie une sous-chaîne d'une chaîne.</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières. Copy renvoie une chaîne de Count caractères en commençant à S[Index].</p>
                            <p>Si Index est plus grand que la longueur de S, Copy renvoie une chaîne vide.</p>
                            <p>Si Count spécifie davantage de caractères qu'il y en a de disponibles, seuls les caractères de S[Index] jusqu'à la fin de S sont renvoyés.</p>
                            <p>Exemple :</p>
<pre><code>var S: string;
begin
    S := 'ABCDEF';
    S := Copy(S, 2, 3);	{ 'BCD' }
end;</code></pre>
<pre><code>function _copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        if p &lt;= lg then
        begin
            if n &gt; lg-p+1 then n := lg-p+1 {fi} ;
            for k := p to p+n-1 
            do Result := Result + ch[k] {od}
        end
    {fi}
end ;</code></pre>
<pre><code>function __copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        k := 0 ;
        while (k+p &lt;= lg) and (k &lt; n) do
            begin
                Result := Result + ch[k+p] ;
                inc(k)
            end
        {od}
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Delete :</h3>
                            <p>Routines de gestion de chaîne (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Delete(var S:string;Index,Count:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Delete supprime une sous-chaîne de Count caractères de la chaîne S en commençant à partir de S[Index].</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières.</p>
                            <p>Si Index est plus grand que la longueur de S, aucun caractère n'est supprimé. Si Count spécifie davantage de caractères qu'il y en a de disponibles après S[Index], Delete supprime le reste de la chaîne.</p>
                            <p>Exemple :</p>
<pre><code>var s: string;
begin
    s := 'Honest Abe Lincoln';
    Delete(s,8,4);
    Canvas.TextOut(10, 10, s); { 'Honest Lincoln' }
end;</code></pre>
<pre><code>procedure _delete(var ch : String ; p,n : Byte) ;
begin
    ch := CONCAT(copy(ch,1,p-1),copy(ch,p+n,length(ch)-n-p+1))
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Insert :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Insert(Source:String;var S:String,Index:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Insert fusionne une sous-chaîne dans une chaîne en commençant au point spécifié.</p>
                            <p>Source est une expression de type chaîne. S est une variable de type chaîne de longueur quelconque et Index une expression entière.</p>
                            <p>Insert insère Source dans S à la position S[index]. Si la chaîne résultante excède 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractère.</p>
                            <p class="em">Exemple :</p>
<pre><code>var
    S: string;
begin
S := 'Honest Lincoln';
Insert('Abe ', S, 8);      { 'Honest Abe Lincoln' }
end;</code></pre>
<pre><code>procedure _insert(ss:String;var ch:String; p:Byte) ;
begin
        ch := copy(ch,1,p-1)+ss+copy(ch,p,length(ch)-p+1)
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Fonction Pos :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité : </span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Pos(Substr:string;S:string):Byte;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Pos recherche une sous-chaîne dans une chaîne.</p>
                            <p>Substr et S sont des expressions de type chaîne.</p>
                            <p>Pos recherche Substr dans S et renvoie une valeur entière donnant l'indice du premier caractère de Substr dans S.</p>
                            <p>Si Substr n'est pas trouvée, Pos renvoie zéro.</p>
                            <p class="em">Exemple :</p>
<pre><code>var S: string;
begin
    S := '   123.5';
    { Convertit les espaces en zéros }
    while Pos(' ', S) &gt; 0 do  S[Pos(' ', S)] := '0';
end;</code></pre>
<pre><code>function _pos(ss,ch : String) : Integer ;
var lgch,lgss,k,ich,iss : Integer ;
begin
        lgch := length(ch) ;
        lgss := length(ss) ;
        result := 0 ;
        k := 1 ;
        while(k + lgss - 1 &lt;= lgch) do
        begin
            ich := k ;
            iss := 1 ;
            while (is&lt;=lgss)and(ch[ich]=ss[iss]) do
            begin
                    inc(ich) ;
                    inc(iss) ;
            end ;
            if iss &gt; lgss then
            begin
                Result := k ;
                break
            end ;
            inc(k)
        end
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Routines de gestion de chaînes :</h3>
                            <dl>
                                <dt>AnsiCompareStr</dt>
                                <dd>Effectue une comparaison de distinction majuscule/minuscule entre deux chaînes.</dd>
                                <dt>AnsiCompareText</dt>
                                <dd>Effectue une comparaison de deux chaînes sans distinction majuscule/miniscules.</dd>
                                <dt>AnsiLowerCase</dt>
                                <dd>Convertit des caractères en minuscules.</dd>
                                <dt>AnsiUpperCase</dt>
                                <dd>Convertit des caractères en majuscules.</dd>
                                <dt>CompareStr</dt>
                                <dd>Réalise une comparaison de deux chaînes en distinguant les minuscules des majuscules.</dd>
                                <dt>CompareText</dt>
                                <dd>Réalise une comparaison de deux chaînes en ne distinguant pas les minuscules des majuscules.</dd>
                                <dt>Concat</dt>
                                <dd>Concaténation de plusieurs chaînes de caractères.</dd>
                                <dt>Copy</dt>
                                <dd>Renvoie une partie d'une chaîne de caractères.</dd>
                                <dt>Delete</dt>
                                <dd>Supprime une partie d'une chaîne de caractères.</dd>
                                <dt>Insert</dt>
                                <dd>Insère une sous-chaîne dans une chaîne.</dd>
                                <dt>IntToHex</dt>
                                <dd>Convertit un entier en valeur hexadécimale.</dd>
                                <dt>IntToStr</dt>
                                <dd>Convertit un entier en une chaîne.</dd>
                                <dt>IsValidIdent</dt>
                                <dd>Renvoie True (Vrai) si la chaîne donnée est un identificateur valide.</dd>
                                <dt>Length</dt>
                                <dd>Renvoie la taille dynamique d'une chaîne.</dd>
                                <dt>LowerCase</dt>
                                <dd>Transforme en minuscules la chaîne donnée.</dd>
                                <dt>Pos</dt>
                                <dd>Recherche une sous-chaîne dans une chaîne.</dd>
                                <dt>Str</dt>
                                <dd>Convertit une valeur numérique en une chaîne.</dd>
                                <dt>StrToInt</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>StrToIntDef</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>UpperCase</dt>
                                <dd>Transforme en majuscule la chaîne donnée.</dd>
                                <dt>Val</dt>
                                <dd>Convertit une chaîne en sa représentation numérique.</dd>
                            </dl>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="fonctions_procedures">Fonctions et procédures :</h2>
                    <blockquote>
                        <p>"Si d'un point de vue philosophique les procédures permettent de définir une nouvelle instruction, d'un point de vue pratique elles nous donnent la possibilité d'utiliser la méthode d'analyse descendante (raffinements successifs). On peut ainsi se concentrer d'abord sur ce que l'on doit faire (et le nommer) avant de réfléchir à la façon dont on va le faire. Le Quoi faire ? avant le Comment faire ?, c'est bien cela la philosophie de l'abalyse descendante.</p>
                        <p>C'est ce que l'on nomme parfois l'abstraction procédurale.</p>
                        <p>De la même façon, on peut vouloir faire abstraction des détails d'un calcul complexe. D'un point de vue philosophique tout autant que pratique, les fonctions nous permettent de définir de nouveaux opérateurs du langage.</p>
                        <p>Le mécanisme d'abstraction procédurale est essentiel dans la conception d'un logiciel que l'on veut modulaire et fiable. L'essence même de ce mécanisme réside dans le fait que l'on peut utiliser une procédure ou une fonction sans se soucier de la façon dont elle est implémentée. Cela n'est possible que si nous savons ce que fait la procédure, c'est-à-dire que nous connaissons la syntaxe et la sémantique de son utilisation.</p>
                        <p>Si cette procédure est prédéfinie, à nous de nous ajuster à ses spécifications; si nous écrivons nous-mêmes la procédure, nous aurons à en déterminer la syntaxe et la sémantique d'appel."</p>
                    </blockquote>
                    <p>H. Paul HAIDUK.</p>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La résolution d'un problème passe souvent par sa décomposition en sous-problèmes et par la résolution de chacun d'eux.</p>
                            <p>Cette décomposition d'une tâche complexe en tâches élémentaires est un des concepts fondamentaux de la programmation structurée. On parle alors de développement de programmes par raffinements successifs.</p>
                            <p>En Pascal, les modules ainsi créés sont des sous-programmes qui sont soit des procédures, soit des fonctions.</p>
                            <p>Cette modularité de programmes permet :</p>
                            <ul>
                                <li>
                                    <p>une meilleure qualité de programmation</p>
                                </li>
                                <li>
                                    <p>une mise au point aisée</p>
                                </li>
                                <li>
                                    <p>une facilité de maintenance.</p>
                                </li>
                            </ul>
                            <p>Le Pascal, nous le savons, offre un certain nombre d'outils de base qui sont les procédures et fonctions standards : <span class="html">ABS</span>, <span class="html">SUCC</span>, <span class="html">SQR</span>, <span class="html">CHR</span>, <span class="html">COPY</span>, <span class="html">DELETE</span>, <span class="html">POS</span> ...</p>
                            <p>Une procédure ou une fonction apparaissent comme la définition d'un traitement.</p>
                            <p>Cependant, une fonction est assimilable à une <span class="em">valeur</span> et une procédure à une <span class="em">instruction</span>.</p>
                            <p>Ce sont en fait des sous-programmes écrits en langage machine et incorporés au Pascal. Nous ne connaissons de ces outils que les modes d'emploi.</p>
                            <p>Le langage Pascal permet de créer ses propres fonctions et procédures.</p>
                        </li>
                        <li>
                            <h3>Les fonctions :</h3>
                            <ol>
                                <li>
                                    <h4>Rappel mathématique :</h4>
                                    <p>En mathématique, l'utilisation d'une fonction f permet d'obtenir la valeur f(x<sub>0</sub>) de la fonction pour une valeur x<sub>0</sub> de la variable.</p>
                                    <p>Soit la fonction f(x) = x<sup>2</sup> - 2x + 3, nous aurons f(2) = 3, f(5) = 18, ...</p>
                                </li>
                                <li>
                                    <h4>Fonctions en Pascal :</h4>
                                    <p>En Pascal, une fonction se définit comme une structure de programme autonome dont le but consiste à calculer puis renvoyer une valeur. Le type du résultat à retourner est une valeur qui peut être de tout type sauf d'un type fichier.</p>
                                    <img src="../images/fonctions_Pascal.png" alt="">
                                    <p>Considérons le programme suivant dans lequel nous utilisons les fonctions standard <span class="html">sin</span> et <span class="html">upcase</span>. Cette fonction renvoie le sinus de son argulent, qui représente un angle exprimé en radians. Comme la valeur retournée est de type Extended, on dit que la fonction <span class="html">sin</span> est de type Extended. Le programme fait également appel à une autre fonction standard : la fonction <span class="html">upcase</span> qui convertit en majuscule un caractère. Si le caractère passé en argument à la fonction n'appartient pas à l'étendue 'a'..'z', la fonction renvoie la valeur caractère non affectée.</p>
<pre><code>program sinus;
{$APPTYPE CONSOLE}

var
    angle : Extended ;
    rep  : char ;

begin
    repeat
        write('valeur d''un angle en radians : ') ;
        readLn(angle) ;
        writeLn('valeur du sinus : ',sin(angle):8:2) ;
        write('continue O/N : ') ;
        readLn(rep)
    until upcase(rep) = 'N' ;

    readLn
end.</code></pre>
                                    <p>À chaque répétition, il y a appel de la fonction <span class="em">SIN</span>. Pour chaque valeur de type Extended de l'argument, la fonction <span class="em">SIN</span> retournera la valeur du sinus correspondant.</p>
                                    <p class="em">Exemple d'exécution :</p>
<pre><code>valeur d'un angle en radians : 1.57079
valeur du sinus :     1.00    
continue O/N ? o
valeur d'un angle en radians : 3.14159
valeur du sinus :     0.00
continue O/N ? o
valeur d'un angle en radians : 4.71238 
valeur du sinus :    -1.00
continue O/N ? n</code></pre>
                                    <p>La valeur de la variable angle est, dans notre exemple, l'argument (ou le paramètre effectif) de la fonction. L'argument doit être une valeur d'un type réel, il s'agit d'une expression réelle.</p>
                                    <p>Exemples :</p>
<pre><code>SIN(1.3)
SIN(A) 
SIN(A*PI/2) 
SIN(ABS(X))</code></pre>
                                    <p>Comme une fonction dénote une valeur, nous pourrons l'utiliser au sein d'une expression là où nous mettions une valeur.</p>
<pre><code>y := 3 * SIN(x)   1
writeln(sin(x))</code></pre>
                                    <p>Remarquons que dans le programme sinus, il y a appel à 5 sous-programmes :</p>
                                    <ul>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">write</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">writeLn</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la fonction </p>
                                            <span class="em">sin</span>
                                        </li>
                                        <li>
                                            <p>appel à la fonction <span class="em">upcase</span></p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Déclarations de fonctions :</h3>
                            <p>Une <span class="em">déclaration (de définition)</span> de fonction définit un sous-programme qui, nous l'avons déjà signalé, effectue un certain traitement avant de renvoyer une valeur.</p>
                            <img src="../images/declarations_fonctions_Pascal.png" alt="">
                            <p>Quand vous déclarez une fonction, vous spécifiez son nom, le nombre et le type des paramètres, ainsi que le type de la valeur renvoyée. La simple déclaration d'une fonction qui correspond à son en-tête est parfois appelé son prototype ou sa signature.</p>
<pre><code>function sin(x : Extended) : Extended ;

function upcase(ch : Char) : Char ;</code></pre>
                            <p>Pour définir la fonction, il convient de faire suivre son en-tête du corps de la fonction.</p>
                            <p>Le corps de la fonction est constitué d'un bloc, c'est-à-dire d'une partie déclaration et d'une partie instruction.</p>
                            <p>Dans la partie déclaration seront déclarés et définis tous les objets locaux à la fonction : il pourra s'agir de constantes, types, variables et ... de procédures et fonctions. <span class="em">Une bonne règle de programmation consiste à déclarer localement au sous-programme tout objet dont il n'est jamais fait usage à l'extérieur.</span></p>
                            <p>La partie instruction du corps de la fonction contient les instructions qui seront exécutées lors de l'activation de la fonction. Ce bloc doit contenir au moins une instruction pour affecter une valeur à la variable prédéfinie Result qui est propre à chaque fonction et du type de la fonction. Le résultat de la fonction est la dernière valeur affectée à cette variable spéciale. Si aucune instruction n'affecte de valeur à Result, la fonction retourne une valeur indéfinie. (<span class="em">Anciennement, on utilisait le nom de la fonction à la place de Result</span>).</p>
                        </li>
                        <li>
                            <h3>Paramètres formels et Appel de fonction :</h3>
                            <p>Des valeurs peuvent être passées à des sous-programmes par des paramètres. Ceux-ci fournissent un mécanisme de substitution permettant à la logique d'un sous-programme d'être utilisé avec différentes valeurs initiales, donnant évidemment des résultats différents.</p>
                            <p>Il existe différentes sortes de paramètres !</p>
                            <p>Ceux dont il est question ici sont les <span class="em">paramètres valeur</span>.</p>
                            <p>Une fonction est activée par l'évaluation d'une expression contenant l'appel de la fonction.</p>
                            <p>Cet appel de fonction se fait en écrivant le nom de la fonction doit être faite. Ces paramètres effectifs représentent des <span class="em">valeurs</span>.</p>
                            <p>À chaque appel, les paramètres effectifs sont subtitués aux paramètres formels spécifiés dans l'en-tête de la fonction.</p>
                            <p>L'ordre des paramètres passés est l'ordre d'apparition dans la liste des paramètres formels. Dans ce type de passage, <span class="em">chaque paramètre formel représente une variable locale au sous-programme qui est initialisé à la valeur du paramètre effectif correspondant</span>.</p>
                            <p>Les types des paramètres formels et des paramètres effectifs doivent - c'est l'évidence - être compatibles.</p>
                            <p>Le diagramme syntaxique définissant la liste de paramètres formels (<span class="em">paramètres valeur</span>) devient :</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>Exemples :</p>
                            <p>Si la fonction <span class="html">COPY</span> n'existait pas, il conviendrait de l'écrire nous-même.</p>
                            <p>À quoi ressemblerait le prototype d'une telle fonction ?</p>
                            <p>La fonction <span class="html">COPY</span> renvoie une partie d'une chaîne de caractères. Elle renvoie une chaîne constituée de <span class="em">n</span> caractères à partir de la position <span class="em">p</span>.</p>
                            <img src="../images/parametres_formels_Pascal_1.png" alt="">
                            <p>L'en-tête de la fonction <span class="html">COPY</span> pourrait être :</p>
<pre><code>function COPY (ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres constante :</h3>
                            <p class="em">(Manuel de référence) :</p>
                            <p>Un paramètre constante (const) est semblable à une constante locale ou à une variable en lecture seule. Les paramètres constantes sont semblables aux paramètres valeur à cette différence qu'il n'est pas possible d'affecter une valeur à un paramètre constante dans le corps de la routine, <span class="em">ni de le transmettre comme paramètre var à une autre routine</span>.</p>
                            <p>L'utilisation de <span class="html">const</span> permet au compilateur d'optimiser le code pour les paramètres de type structuré ou chaîne.</p>
                            <p>Le protocole de la fonction copy peut donc s'écrire :</p>
<pre><code>function COPY(<span class="html">const</span> ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Exemples de définitions de fonctions :</h3>
                            <p>En guise d'exercice, nous allons réécrire la fonction upcase ainsi que la fonction uppercase qui renvoie une chaîne en majuscules.</p>
<pre><code>function uppercase(const S : String) : String ;</code></pre>
<pre><code>program majuscule;
{$APPTYPE CONSOLE}

<span class="em">function charMaj(ch : Char) : Char ;
begin
    Result := ch ;
    if (ch &gt;= 'a') and (ch &lt;= 'z') then
        Result := chr( ord(ch) + ord('A') - ord('a') )
    {fi}
end ;

function strMaj(const S : String) : String ;
var k : Cardinal ;
begin
    Resukt := s ;
    for k := 1 to length(Result) do
        Result[k] := charMaj(Result[k]) ;
end ;</span>

var chaine : String ;
begin
    repeat
        write('chaine : ') ;
        readLn(chaine) ;
        if chaine = '' then break ;
        writeLn(strMaj(chaine)) ;
        writeLn(chaine) ;
    until False ;
end .</code></pre>
                            <p>Le programme majuscule correspond à une boucle généralisée. À chaque répétition, il y a appel à la fonction strMaj avec comme argument (paramètre effectif) la valeur courante de la variable chaîne de type String. La valeur de cette variable <span class="em">chaine</span> ne sera pas modifiée par l'exécution de la routine puisque (sémantiquement) c'est la valeur et non la variable qui est transmise !</p>
                            <p class="em">Exemple d'exécution d'une répétition... :</p>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                    <tr>
                                        <td>write('Chaine :') ; readLn(chaine) ;</td>
                                        <td>Chaine : <span class="em">aAzZeErRtTyY ! !</span></td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(strMaj(chaine)) ;</td>
                                        <td class="em">AAZZEERRTTYY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(chaine) ;</td>
                                        <td class="em">aAzZeErRtTyY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Pour chaque appel de la fonction strMaj, il y aura un appel à la fonction prédéfinie length et une suite d'appels à la fonction charMaj (en fait, un appel pour chaque caractère de la valeur String).</p>
                        </li>
                        <li>
                            <h3>Problématique de l'usage des routines :</h3>
                            <p>La structure du programme <span class="em">majuscule</span> reflète (en simplifié) celle de la majorité des programmes. Le programme principal lance successivement un ensemble de sous-programmes, chacun d'eux pouvant lancer ses propres sous-pogrammes...</p>
                            <p>Ce mécanisme d'exécution revient à suspendre l'exécution du programme en cours. Le processus qui s'exécute se suspend par l'appel explicite d'un sous-programme et permet le lancement du processus associé au sous-programme. Lorsque l'exécution de ce sous-programme est terminée, le programme appelant reprend la main, et continue son exécution là où il l'avait suspendue.</p>
                            <img src="../images/problematique_usage_routines.png" alt="">
                            <p>Le concepteur, dans une démarche d'écriture structurée, donne grande importance aux routines. La forme générale de son projet est alors un ensemble de nombreux sous-programmes, chacun étant de taille fort réduite et de fonctionnalité simple, et l'exécution consiste en de nombreux appels de ces sous-programmes.</p>
                            <p>Le programme principal a un rôle de lanceur. Il réalise certaines initialisations, puis passe la main. Dans tous les cas, c'est par lui qui commence l'exécution et également qu'elle se termine.</p>
                        </li>
                        <li>
                            <h3>Bloc et Portée d'une déclaration :</h3>
                            <p>Un bloc est composé d'un ensemble de déclarations suivi d'un ensemble d'instructions. Chaque bloc est contenu dans une déclaration de procédure, de fonction, de programme (ou d'unité).</p>
                            <p>Tous les identificateurs déclarés dans la partie déclaration d'un bloc sont locaux à ce bloc.</p>
                            <p>Une déclaration introduit un nom (identificateur) dans une portée.</p>
                            <q class="em">La <span class="html">portée</span> d'une déclaration est la partie du texte du programme où l'association entre le nom de l'objet déclaré et sa desccription est d'application.</q>
                            <p>On parle aussi parfois du domaine d'application d'une déclaration en lieu et place de la portée d'une déclaration.</p>
                            <p class="em">La portée d'un identificateur déclaré dans une déclaration de constantes, de types, de variables, de procédures ou de fonctions s'étend de l'endroit de la déclaration jusqu'à la fin du bloc courant, en incluant tous les blocs définis à l'intérieur de ce bloc courant.</p>
                            <p>Un identificateur déclaré dans un bloc peut être <span class="em">redéclaré</span> dans un bloc plus interne.</p>
                            <p class="em">Visibilité :</p>
                            <p><span class="em">Une déclaration est visible</span> dans la partie du texte où on peut l'identifier, c'est-à-dire où le nom déclaré peut être écrit et signifier l'objet décrit. Un identificateur est visible là où sa déclaration est visible.</p>
                            <p>Une déclaration peut être visible dans toute l'étendue de sa portée mais peut aussi être <span class="em">masquée</span> par d'autres déclarations dont la portée et la visibilité chevauchent celles de la première déclaration.</p>
                        </li>
                        <li>
                            <h3>Durée de vie :</h3>
                            <p>Les variables et les sous-programmes, contrairement aux types, existent lors de l'exécution du programme <span class="em">&lt; ils occupent une place mémoire</span>.</p>
                            <q class="em">La durée de vie d'un objet est la période durant laquelle cette mémoire lui est allouée.</q>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui est allouée pour toute la durée de l'exécution du programme.</p>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui esr allouée pour toute la durée de l'exécution du programme.</p>
                            <p>Une variable peut avoir une durée de vie <span class="em">temporaire</span>. Elle est alors créée à l'entrée du sous-programme contenant sa déclaration et détruite quand son nom sort de sa portée.</p>
                            <blockquote>
                                <p>durée de DYNAMIQUE (liée à l'exécution du programme)</p>
                                <p>portée = propriété STATIQUE (liée au texte du programme)</p>
                            </blockquote>
                            <p class="em">Variables globales et variables locales (résumé) :</p>
                            <p>Les programmes jusqu'à présent rencontrés étaient constitués d'un seul bloc. Comme on n'y avait déclaré aucun sous-programme, il n'y avait pas d'imbrication de blocs. Les variables étaient toutes des variables globales. Elles avaient été déclarées dans le bloc principal du programme; leur durée de vie était celle du programme.</p>
                            <p>La portée de la déclaration d'une variable globale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc courant c'est-à-dire jusqu'à la fin du programme.</p>
                            <p>Il conviendra de réduire au maximum cette portée... De ce fait, nous ne serons pas tentés d'utiliser des variables globales à l'intérieur des sous-programmes.</p>
                            <p class="em">Une bonne règle de programmation étant de construire des sous-programmes étanches.</p>
                            <p>Les variables déclarées dans un sous-programme auront une durée de vie qui correspondra à l'exécution de ce sous-programme. De telles variables locales.</p>
                            <p>La portée de la déclaration d'une variable locale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc du sous-programme. Il y a cohérence entre la propriété statique de portée et la propriété dynamique de durée de vie.</p>
                            <q>Une fonction doit constituer un tout; elle doit être "<span class="em">étanche</span>", et compréhensible en dehors du contexte dans lequel elle est utilisée. C'est d'ailleurs à ce prix que vous pourrez la réutiliser dans d'autres programmes.</q>
                        </li>
                        <li>
                            <h3>Procédures - Introduction :</h3>
                            <p>Une procédure est destinée à réaliser une action, un traitement. Elle correspond à la notion de sous-programme dans toute sa généralité. Son appel sera assimilable à une <span class="em">instruction</span>.</p>
                            <p>Comme premier exemple, nous pourrions définir une procédure <span class="em">erreur</span> dont l'effet est pour le moins dévasteur.</p>
<pre><code>procedure erreur(const message : String) ;
begin
        writeLn(message) ;
        halt
end ;</code></pre>
                            <p>Cette procédure fait elle-même appel à deux procédures prédéfinies.</p>
                            <p>La procédure d'affichage writeLn et la procédure halt qui exécute une fin anormale de programme !</p>
                            <img src="../images/procedure_affichage_writeLn_Pascal.png" alt="">
                            <p>Nous avons déjà rencontré des procédures dont "l'effet" étaient de modifier des variables. Ainsi la procédure inc permet d'incrémenter la valeur d'une variable. C'est la variable qu'il conviendra de transmettre au sous-programme !</p>
<pre><code>…
{ assert(x=12) }
inc(x) ;
{ assert(x=13) }
…</code></pre>
                            <img src="../images/assert.png" alt="">
                            <p>Pour que la procédure soit un outil général, il convient qu'elle puisse aussi restituer une ou plusieurs valeurs au programme (ou sous-programme) appelant.</p>
                            <p>Un nouveau mode de transmission de paramètres sera alors nécessaire. Nous l'étudierons après avoir précisé la syntaxe d'une délcaration de procédure.</p>
                        </li>
                        <li>
                            <h3>Déclaration (de définition) de procédure :</h3>
                            <p>Une déclaration de procédure associe un identificateur à un bloc d'instructions.</p>
                            <p>L'appel de la procédure se fera par une instruction de procédure; celle-ci spécifie l'identificateur de la procédure, ainsi que les paramètres effectifs, si nécessaire. Quand une procédure est appelée, le contrôle se trouve transféré au début de la procédure. Après avoir exécuté les instructions qui composent le traitement de la procédure, le contrôle retourne automatiquement à l'instruction qui suit l'instruction d'appel de la procédure.</p>
                            <img src="../images/declaration_procedure_Pascal.png" alt="">
                            <p class="em">L'en-tête de la procédure est suivi :</p>
                            <ul>
                                <li>
                                    <p class="em">d'une partie déclaration qui déclare les objets locaux;</p>
                                </li>
                                <li>
                                    <p>des instructions comprises entre begin et end, qui spécifient ce qui doit être exécuté lorsqu'il est fait appel à la procédure.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Paramètres variable :</h3>
                            <p>Répétons-le, un paramètre valeur est simplement une variable locale au sous-programme, qui lors de son activation a été initialisée à la valeur du paramètre effectif correspondant.</p>
                            <p class="em">Si vous transmettez une variable comme paramètre valeur, la routine en crée une copie et les modifications apportées à la copie sont sans effet sur la variable d'origine et sont perdues quand l'exécution du programme revient à l'appel de la routine.</p>
                            <p>Un paramètre variable se comporte, lui, comme une sorte d'alias, un autre nom permettant d'accéder au paramètre effectif qui doit être une variable (référence à une variable).</p>
                            <p class="em">Un paramètre variable dénote une variable !</p>
                            <p>De ce fait, les modifications apportées aux paramètres dans le corps de la routine sont conservées lorsque l'exécution du programme revient à l'appel de la routine et que le nom du paramètre est hors de portée.</p>
                            <p>Rappelez-vous qu'un identificateur de variable représente en fait l'adresse symbolique de la case mémoire correspondant à la variable désignée. Le paramètre formel variable est dans la procédure un nouveau nom pour la variable référencée par le paramètre effectif. Ainsi, le paramètre formel et le paramètre effectif font référence à la même case mémoire.</p>
                            <p>En conséquence, modifier le paramètre formel dans un sous-programme, c'est en fait modifier le paramètre effectif correspondant.</p>
                            <p>On comprend alors pourquoi cette technique est utilisée pour les paramètres de retour (lorsqu'une valeur doit être renvoyée à l'appelant d'une procédure) et pourquoi paramètres formels et effectifs doivent être de types rigoureusement identiques.</p>
                            <p>Une liste de paramètres par adresse est précédée du mot réservé var.</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>L'exemple classique suivant bien la différence entre les deux types de paramètres.</p>
<pre><code>program val_var ; 
{$APPTYPE CONSOLE}

procedure echange_local( a,b : integer ) ; 
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ; 

<span class="em">procedure echange( var a,b : integer ) ;
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ;</span>
    
var x,y : integer ; 
    
begin 
    x := 1 ; y := 2 ; 
    writeln(x:8,y:8) ;              {       1       2} 
    echange_local(x,y) ; 
    writeln(x:8,y:8) ;              {       1       2}     
    echange(x,y) ; 
    writeln(x:8,y:8) ;              {       2       1} 

    readLn     
end.</code></pre>
                        </li>
                        <li>
                            <h3>Une nouveauté : les paramètres out :</h3>
                            <p>(Manuel de référence) :</p>
                            <p class="em">Un paramètre de sortie (out) est transmis par adresse comme un paramètre variable. Mais avec un paramètre out, la valeur initiale de la variable référencée n'est pas prise en compte par la routine à laquelle elle est transmise. Le paramètre out n'est utilisé qu'en sortie; il indique simplement à la routine où placer la valeur en sortie sans spécifier de valeur en entrée.</p>
                            <p class="em">Soit, par exemple, l'en-tête de procédure suivant :</p>
<pre><code>procedure ExtraitInfos(out Info: UnTypeEnreg);</code></pre>
                            <p class="em">Quand vous appelez <span class="html">ExtraitInfos</span>, vous devez lui transmettre une variable de type <span class="html">UnTypeEnreg</span> :</p>
<pre><code>var MonEnreg: UnTypeEnreg;

...
ExtraitInfos(MonEnreg);</code></pre>
                            <p class="em">Mais vous n'utilisez pas <span class="html">MonEnreg</span> pour transmettre des données à la procédure <span class="html">ExtraitInfos</span>; <span class="html">MonEnreg</span> sert simplemeent de conteneur où <span class="html">ExtraitInfos</span> stocke les informations qu'elle génère. L'appel de <span class="html">ExtraitInfos</span> libère immédiatement la mémoire utilisée par <span class="em">MonEnreg</span>, avant que le contrôle du programme ne passe à la procédure.</p>
                            <p class="em">Les paramètres <span class="html">Out</span> sont fréquememment utilisés avec les modèles d'objets distribués comme <span class="html">COM</span> ou <span class="html">COBRA</span>. De plus, vous devez utiliser des paramètres <span class="html">out</span> pour transmettre une variable non initialisée à une routine.</p>
                        </li>
                        <li>
                            <h2>Transfert de paramètre :</h2>
                            <p>Les paramètres sont transmis aux procédures et aux fonctions par l'intermédiaire (<span class="em">des registres CPU ou</span>) de la pile, selon la convention d'appel de la routine.</p>
                            <p>Selon une des conventions possibles, les paramètres sont placés, avant l'appel du sous-programme, dans la pile suivant l'ordre de leur déclaration. Juste avant la fin de son exécution, le sous-programme retire tous les paramètres de la pile.</p>
                            <p>La structure d'appel d'une routine pourrait être la suivante :</p>
<pre><code>PUSH		param1
PUSH		param2
        …
PUSH		paramN
CALL 		routine</code></pre>
                            <p>Il n'existe que deux sortes de transmission :</p>
                            <ul>
                                <li>
                                    <p>par valeur,</p>
                                </li>
                                <li>
                                    <p>par référence ou adresse.</p>
                                </li>
                            </ul>
                            <p class="html">Lorsqu'un paramètre est transmis par adresse, un pointeur sur l'emplacement en mémoire de la "valeur" à transmettre est placé dans la pile.</p>
                            <p class="html">Pour une transmission par valeur, c'est la valeur elle-même qui est placée dans la pile.</p>
                            <p class="em">Les paramètres variables (et de sortie) sont toujours transmis par adresse.</p>
                            <p class="em">Les paramètres valeurs (et constantes) sont transmis, suivant leur type et leur taille, par adresse ou par valeur.</p>
                            <p>En général, si le paramètre occupe quelques octets, la valeur est directement placée dans la pile. Sinon, le sous-programme appelé copie la valeur dans une zone de mémoire locale et c'est un pointeur sur cette zone qui est placé dans la pile.</p>
                            <p><span class="em">L'effcicacité des paramètres constantes</span> par rapport aux paramètres valeurs vient de ce que le compilateur n'a pas à générer de copie des paramètres effectifs à l'entrée dans le sous-programme <span class="em">puisque les paramètres constantes ne sont pas modifiables !</span></p>
                        </li>
                        <li>
                            <h3>Laboratoire d'analyse :</h3>
                            <p>Comme petit exercice, analysez le programme suivant :</p>
                            <p class="em">(fonction, procédure et contexte d'appel...)</p>
<pre><code>program test;
{$APPTYPE CONSOLE}

procedure NumString(N:Integer;var S:String) ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        S := '' ;
        repeat
        S := chr(V mod 10 + ord('0')) + S ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then S := '-'+ S
end ;

function NumString(N : Integer) : String ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        Result := '' ;
        repeat
        Result := chr(V mod 10 + ord('0')) + Result ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then REsult := '-'+ Result
end ;

var str : String ;
begin

    NumString(-12345,str) ;
    writeLn(str) ;

    writeLn(NumString(-12345)) ;

    readLn
end .</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="tableaux">Tableaux (Array) :</h2>
                    <h3>1<sup>ère</sup> Partie : Les tableaux en Pascal Objet :</h3>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Lorsqu'un nombre important de variables de même type et surtout associées à une même catégorie d'objet, doit être utilisé dans un programme, il est bien entendu impossible d'envisager d'attribuer un identificateur différent à chaque variable (par exemple le chiffre d'affaires quotidien d'un représentant).</p>
                            <p>Les tableaux permettent de résoudre cette difficulté.</p>
                            <p>Un tableau est une manière assez naturelle de ranger des éléments de même type. Il permet de regrouper ceux-ci dans une structure fixe et d'accéder à chaque élément par le biais d'un indice.</p>
                            <p>On peut considérer une variable tableau comme un tableau de variables.</p>
                        </li>
                        <li>
                            <h3>Définition :</h3>
                            <p>Un tableau est une structure constituée d'un nombre fixe d'éléments du même type qui est appelé type de base ou type composant.</p>
                            <p>Il s'agit donc d'une <span class="em">structure homogène</span>.</p>
                            <p>Nous pouvons construire des tableaux d'entiers, des tableaux de booléens, mais aussi des tableaux de chaînes et pourquoi pas... des tableaux de tableaux !</p>
                            <p>Un tableau est aussi une structure dite <span class="em">à accès aléatoire</span> : à un instant donné, on peut sélectionner n'importe quel composant. Le temps d'accès à un élément est indépendant de la place qu'occupe cet élément dans la structure.</p>
                            <p>Pour désigner, pour référencer un composant, on ajoute entre crochets au nom de la variable de type tableau ce qu'on appelle un indice. Cet indice signale la position de l'élément dans le tableau et doit être une valeur du type défini comme le type d'indice du tableau.</p>
                            <p>Le type de l'indice permet de définir le nombre d'éléments du tableau. En Pascal, les types autorisés pour les indices sont tous les types scalaires.</p>
                            <p>La définition d'un type de tableau <span class="em">TT</span> spécifie à la fois un type de base <span class="em">TB</span> et un type d'indice <span class="em">TI</span>.</p>
<pre><code>Type TT = ARRAY[TI] of TB ;</code></pre>
                            <p>Exemples :</p>
<pre><code>
Type Tab1_20Real = ARRAY [1..20] of Real ;
     Tab0_255Boolean = ARRAY [byte] of Boolean ;

var t1,t2 : Tab1_20Real ;
t3,t4 : Tab0_255Boolean ;

Type Tetat = (travail,conge,recuperation,in¬defini) ;
     Tjour = (lun,mar,mer,jeu,ven,sam,dim) ; 
     Tableau = ARRAY [Tjour] of Tetat ;
var t : Tableau ;
...</code></pre>
                            <p>Notez cependant qu'il peut exister des restrictions qui dépendent de la capacité mémoire et non de la définition du langage.</p>
<pre><code>type 	TropGros = array [Longint] of Extended ;
{ erreur  => type de donnée trop grand : dépasse 2Go }</code></pre>
                            <p class="em">Remarque : Le type des composants d'un tableau peut être lui-même d'un type tableau; nous obtenons ainsi des tableaux de tableaux "ou" tableaux multidimensionnels.</p>
<pre><code>
Type Tvecteur = ARRAY [1..3] of Extended ;
     Tmatrice = ARRAY [1..5] of Tvecteur ;
var m : Tmatrice ;</code></pre>
                            <p class="em">Pour référencer l'élément de la matrice correspondant à la i<sup>ème</sup> ligne et à la j<sup>ème</sup> colonne, nous pouvons écrire <span class="html">m[i][j]</span> ou encore <span class="html">m[i,j]</span>.</p>
                            <p class="em">Nous aurions pu définir le type Tmatrice autrement :</p>
<pre><code>Type Tmatrice = ARRAY [1..5] of ARRAY [1..3] od Extended ;
// ou encore
     Tmatrice = ARRAY[1..5,1..3] of Extended ;</code></pre>
                            <p class="em">Ces définitions sont cependant moins souples que la première qui permet une assignation tel que : <span class="html">v := m[k]</span> en supposant que <span class="html">v</span> est une variable de type <span class="html">Tvecteur</span>.</p>
                        </li>
                        <li>
                            <h3>Opérations sur les tableaux :</h3>
                            <p>La seule opération globale sur des tableaux est l'affectation. Celle-ci n'est possible que si les deux tableaux sont rigoureusement de même type.</p>
                            <p>Supposons les déclarations suivantes :</p>
<pre><code>type Tab1 = ARRAY [1..5] of integer ;
     Tab2 = ARRAY [1..5] of integer ;
var t,t1 : Tab1 ;
    t2 : Tab2 ;</code></pre>
                            <p>l'affectation <span class="em">t1 := t</span> est possible alors que l'affectation <span class="em">t1 := t2</span> ne l'est pas car les types <span class="em">tab1</span> et <span class="em">tab2</span> sont distincts !</p>
                            <ul>
                                <li>
                                    <p>Les procédures prédéfinies de lecture et écriture (readln, writeln, ...) ne permettent que de traiter des nombres des chaînes - étant bien entendu qu'il s'agit de variables pour les lectures et d'expressions pour les écritures.</p>
                                    <p>Il conviendra donc de lire ou d'écrire successivement chaque élément du tableau.</p>
<pre><code>...
for k := 1 to 5 do
    begin
        write('t[',k,'] = ');
        readln(t[k])
    end;
...</code></pre>
                                </li>
                                <li>
                                    <p>Les opérations réalisables sur un élément de tableaux sont celles réalisables sur le type composant. Ainsi, dans notre exemple, <span class="em">t1[3]</span> est assimilable à une variable entière. Il s'agit d'une <span class="em">extension de la notion de variable</span> : un composant d'une variable de type structuré est une référence à une variable et correspond donc à un emplacement adressable.</p>
                                    <p>Au niveau représentation en mémoire, un tableau est stocké comme une séquence de variables adjacentes de même type que le type de base du tableau.</p>
                                    <img src="../images/operations_tableaux_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Lorsque les fonctions <span class="html">low</span> et <span class="html">high</span> sont appliquées à un identificateur de type tableau ou une référence d'un type tableau, elles retournent les bornes inférieures et supérieure du type d'indice du tableau.</p>
<pre><code>program highlow ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     TabA_ZInt = array[TMajuscule] of Integer ;
     Tab1_10Int = array[TIndex] of Integer ;
var M : TabA_ZInt ;
    L : Tab1_10Int ;
begin
    writeln(low(TabA_zInt):8,low(M):8) ;
    writeln(high(TabA_zInt):8,high(M):8) ;
    writeln(low(Tab1_10Int):8,low(L):8) ;
    writeln(high(Tab1_10Int):8,high(L):8) ;
    readLn
end.</code></pre>
                            <img src="../images/highlow_Pascal.png" alt="">
                            <p>Exemple :</p>
<pre><code>program testab ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     Tableau = array[Tindex] of TMajuscule ;
    
procedure afficheTableau(const T : Tableau) ;
var k : TIndex ;
begin
    for k := low(T) to high(T) do
        writeln('T[',k:2,'] = ',T[k]) ;
    writeln
end ;

function genereTableau : Tableau ;
var k : TIndex ;
begin
    for k := low(Result) to high(Result) do
        Result[k] := char(65 + random(26))
end ;

procedure echange(var x,y : TMajuscule) ;
var tmp : TMajuscule ;
begin
    tmp := x ; x := y ; y : tmp
end ;

var Tab : Tableau ;
begin
    randomize ; tab := genereTableau ;
    afficheTableau(tab) ;
    echange(tab[1],tab[10]) ; echange(tab[2], tab[9]) ;
    afficheTableau(tab) ;
    readLn
end.</code></pre>
                            <img src="../images/testab_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Constante typée :</h3>
                            <p>Pascal Objet autorise la définition de constantes de type tableau sauf celles qui contiennent des éléments de type fichier.</p>
<pre><code>type TEtat = (actif,passif,attente) ;
     TabEtat : array [TEtat] of String ;
const ETATTOSTR : TabEtat = ('actif','passif','attente') ;</code></pre>
                            <p>La constante tableau <span class="em">ETATTOSTR</span> peut être utilisée pour convertir les valeurs du type énuméré <span class="em">TEtat</span> en leur représentation sous forme de chaîne de caractères.</p>
<pre><code>type TCarre = array[1..3,1..4] of Integer ;
const UNCARRE : TCarre = ( (1,2,3,4) , (5,6,7,8) , (9,10,11,12) ) ;</code></pre>
                            <img src="../images/constante_typee_Pascal.png" alt="">
<pre><code>procedure afficheCarre(const C:TCarre) ;
var j,k : Byte ;
begin
    for j := 1 to 3 do begin
        for k := 1 to 4 do
            write(C[j,k]:4)
        {od} ;
    end{do} ;
    writeln
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres tableaux ouverts :</h3>
                            <p>Les paramètres tableaux ouverts permettent de transmettre à un même sous-programme des tableaux de tailles différentes.</p>
                            <p>Un paramètre formel déclaré avec la syntaxe <span class="html">array of T</span> où T est un identificateur de type est un paramètre tableau ouvert. Le paramètre effectif correspondant doit être une variable de type T (<span class="em">tableau à une dimension</span>) ou un tableau dont les éléments sont de type T.</p>
                            <p>À l'intérieur du sous-programme, tout se passe comme si le paramètre formel avait été déclaré...</p>
<pre><code>array [0..N-1] of T</code></pre>
                            <p>où <span class="em">N</span> est le nombre d'éléments du paramètre effectif. Il y a mise en correspondance entre l'intervalle des indices du paramètre effectif et l'intervalle du paramètre formel, soit l'intervalle <span class="em">0..N-1</span>.</p>
                            <p>Il existe une restriction : un paramètre tableau ouvert n'est accessible qu'élément par élément. Lorsqu'elle est appliquée à un paramètre tableau ouvert, la fonction <span class="html">low</span> renvoie <span class="em">0</span> et la fonction <span class="html">high</span> renvoie <span class="em">N-1</span>.</p>
<pre><code>function sommerTabInt(const T : array of Integer):Integer;
var k : Cardinal ;
begin
    Result := 0 ;
    for k := low(T) to high(T) do inc(Resylt,T[k])
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Constructeurs de tableaux ouverts (Guide du langage Pascal Objet) :</h3>
                            <p>Lorsqu'un paramètre formel est un paramètre valeur ou un paramètre constant de type tableau ouvert, le paramètre effectif correspondant dans l'appel du sous-programme peut être un constructeur de tableaux ouverts.</p>
                            <p>Un constructeur de tableau ouvert est constitué d'une ou plusieurs expressions, séparées par des virgules, et encadrées de crochets. Chaque expression doit être compatible en terme d'affectation avec le type des éléments du paramètre tableau ouvert.</p>
                            <p>L'utilisation d'un constructeur d'un tableau ouvert revient à créer une variable tableau temporaire et à initialiser ses éléments avec les valeurs fournies par la liste des expressions.</p>
<pre><code>program Opentab;
{$APPTYPE CONSOLE}

procedure afficherTabInt(const T : array of Integer) ;
var k : cardinal ;
begin
    for k := low(T) to high(T) do write(T[k]:4) ;
    writeln
end ;

function sommerTabInt(const T : array of Integer):Integer;
var k : Cardinal ;
begin
    Result := 0 ;
    for k := low(T) to high(T) do inc(Result,T[k])
end ;

var k : Cardinal ;
begin
    afficherTabInt([1,2,3,4,5]) ;
    writeln(sommerTabInt([1,2,3,4,5])) ;
    afficherTabInt([6,7,8]) ;
    writeln(sommerTabInt([6,7,8])) ;
    readLn
end.</code></pre>
                            <img src="../images/Opentab_Pascal.png" alt="">
                        </li>
                    </ol>
                    <h3>2<sup>ème</sup> Partie : Algorithmes :</h3>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Nous présentons à présent la construction de quelques algorithmes itératifs portant sur les tableaux. Si l'on excepte la recherche dichotomique, nous nous intéresserons ici aux situations où l'on traite les éléments d'un tableau de manière séquentielle. Nous pouvons dès lors interpréter le tableau comme la représentation d'une séquence de longueur fixe et nous ramener à des schémas itératifs déjà étudiés.</p>
                            <p class="em">Description de l'état dans un parcours séquentiel d'un tableau :</p>
                            <img src="../images/description_etat_parcours_sequentiel_tableau_Pascal.png" alt="">
                            <p>À titre d'exemple, nous présentons la fonction maximum qui renvoie la valeur maximum d'un tableau d'entiers. (La construction de l'algorithme est une simple adaptation de ce qui a été étudié précédemment pour les séquences d'entiers.)</p>
<pre><code>function maximum(const T : array of Integer) : Integer ;
var k : Cardinal ;
begin
    Result := T[0] ;
    for k := 1 to high(T) do
        if T[k] &gt; Result
            then Result := T[k]
        {fi}
    {od}
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Tri :</h3>
                            <p>On définit le tri comme un processus de rangement d'un ensemble de rangement d'un ensemble donné d'objets dans un certain ordre. En triant un ensemble de données, on facilite les recherches ultérieures sur les membres de cet ensemble.</p>
                            <p>On classe les méthodes de tri en deux catégories :</p>
                            <ul>
                                <li>
                                    <p>les tris internes (tris de tableaux)</p>
                                </li>
                                <li>
                                    <p>les tris externes (tris de fichiers).</p>
                                </li>
                            </ul>
                            <p>Nous nous intéresserons ici à quelques méthodes de tris internes.</p>
                            <ol>
                                <li>
                                    <h4>Tri par extraction ou par sélection :</h4>
                                    <p class="em">Principe :</p>
                                    <ol>
                                        <li>
                                            <p>Sélection de l'élément de plus basse clé</p>
                                        </li>
                                        <li>
                                            <p>Échange de cet élément avec le premier élément</p>
                                        </li>
                                        <li>
                                            <p>Répétition de ces opérations avec les n-1 éléments restants, puis avec les n-2, ... jusqu'à ce qu'il ne reste qu'un seul élément : le plus grand.</p>
                                        </li>
                                    </ol>
                                    <p class="em">Simulation :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td></td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td></td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td></td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td></td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td></td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>M</td>
                                                <td>P</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procedure tri_extraction(var T : array of Integer) ;
var k,j,indMin : Cardinal ;
begin
    for k := low(T) to high(T)-1 do begin
        indMin := k ;
        for j := k+1 to high(T) do
            if T[j] &lt; T[indMin] then indMin := j {fi}
        {od} ;
        if k &lt;&gt; indMin then echanger(T[indMin],T[k]) {fi}
    end{do}
end ;</code></pre>
                                </li>
                                <li>
                                    <h4>Tri par insertion :</h4>
                                    <p class="em">Principe :</p>
                                    <p>Conceptuellement, la suite des éléments est divisée en deux suites :</p>
                                    <ul>
                                        <li>
                                            <p>une suite déjà triée (suite destination)</p>
                                            <p>t<sub>0</sub>..t<sub>k-1</sub></p>
                                        </li>
                                        <li>
                                            <p>une suite des éléments à insérer (suite source)</p>
                                            <p>t<sub>k</sub>..t<sub>n-1</sub></p>
                                        </li>
                                    </ul>
                                    <p>À chaque étape, on prend le k<sup>ième</sup> élément et on l'insère à sa place dans la suite destination.</p>
                                    <p class="em">Invariant de cet algorithme :</p>
                                    <p>"Après l'étape k, tous les éléments entre la première et la k<sup>ième</sup> position sont triés." Au départ, la suite destination, c'est-à-dire la suite déjà triée est la suite constituée du premier élément.</p>
                                    <p class="em">Simulation :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>S</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td></td>
                                                <td>S</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>L</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                                <td>M</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td></td>
                                                <td>S</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td></td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td>E</td>
                                                <td></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procesure Tri_Insertion (var T : array of Integer) ;
var k,j : Cardinal ; valeurAinserer : Integer ;
begin
    for k := low(T)+1 to high(T) do begin
        valeurAinserer := t[k] ;
        j := k ;
        while (j &gt; low(T)) and (valeurAinserer &lt; t[j - 1]) do begin
            t[j] := t[j - 1];
            dec(j)
        end{do};
        t[j] := valeurAinserer
    end{do}
end;</code></pre>
                                </li>
                                <li>
                                    <h4>Tri par permutations ou tri bulles :</h4>
                                    <p class="em">Principe :</p>
                                    <p>Imaginons que les éléments à trier soient rangés dans un tableau vertical et que les éléments dont les clés sont les plus petites soient "moins lourds" et remontent comme des bulles vers la surface. On effectue des passages successifs sur le tableau de bas en haut. À chaque étape, si deux éléments sont en ordre inverse, on les permute.</p>
                                    <p>La conséquence de cette opération est qu'à la fin du premier passage, l'élément le plus léger remonte jusqu'à la première position du tableau. Au deuxième passage, l'élément ayant la deuxième plus petite clé remonte à la deuxième position du tableau, et ainsi de suite...</p>
                                    <p class="em">Simulation :</p>
                                    <p>1<sup>er</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>E</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>E</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>E</td>
                                                <td>I</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>E</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>E</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>2<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>I</td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>I</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>L</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>3<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>L</td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>L</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>4<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td></td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>S</td>
                                                <td>M</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td>M</td>
                                                <td>S</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>P</td>
                                                <td>P</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>5<sup>ème</sup> passage :</p>
                                    <table class="tableBalises">
                                        <tbody>
                                            <tr>
                                                <td>E</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>I</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>L</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                                <td></td>
                                            </tr>
                                            <tr>
                                                <td>S</td>
                                                <td>P</td>
                                            </tr>
                                            <tr>
                                                <td>P</td>
                                                <td>S</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p class="em">Algorithme :</p>
<pre><code>procudure tri_bulles(var T : array of Integer) ;
var k,j : Cardinal ;
begin
    for k := low(T) to high(T)-1 do
        for j := high(T) downto k+1 do
            if T[j] &lt; T[j-1] then echanger(T[j],t[j-1]) {fi}
        {od}
    {od}
end ;</code></pre>
                                </li>
                                <li>
                                    <h4>Méthodologie :</h4>
                                    <p>Le tri sélection et le tri bulles partagent la même hypothèse inductive.</p>
                                    <p>Les éléments de la partie gauche sont supposés définitevement placés (et donc triés).</p>
                                    <p>Cette hypothèse implique que les éléments de la partie droite (non triée) sont des valeurs supérieures.</p>
                                    <img src="../images/methodologie_tri_selection_tri_bulles_Pascal.png" alt="">
                                    <p>L'itération pourra se terminer lorsque la partie droite se réduira au dernier élément du tableau puisque celui-ci est forcément de valeur supérieure.</p>
                                    <p>Quant à l'initialisation, le plus petit sous-tableau gauche pour lequel l'hypothèse est vérifiée ne peut être (conceptuellement) qu'un sous-tableau vide.</p>
                                    <p>Toutes ces considérations nous donnent l'algorithme suivant :</p>
<pre><code>for k := low(T) to pred(high(T)) do
{ placer en T[k] l'élément minimum du sous-tableau droit T[k..N-1] }</code></pre>
                                    <p>C'est dans la façon de rétablir l'invariant que le tri par sélection et le tri bulles se différentient.</p>
                                    <ul>
                                        <li>
                                            <p>Pour le tri de sélection, on recherche séquentiellement l'indice du minimum dans le sous-tableau droit puis on échange, si nécessaire, l'élément minimum avec la valeur de T[k].</p>
                                            <p>C'est la réalisation du PAS INDUCTIF qui nous permet d'agrandir le sous-tableau gauche correspondant à la séquence des éléments déjà traités et donc définivement bien placés.</p>
<pre><code>indMin := k ;
for j := k+1 to high(T) do
    if T[j] &lt; T[indMin] then indMin := j {fi}
{od} ;
if k &lt;&gt; indMin then echanger(T[indMin],T[k]) {fi}</code></pre>
                                            <img src="../images/tri_selection_Pascal.png" alt="">
                                            <p>Pour le tri bulles, on ramène la valeur minimale en position k par échanges successifs.</p>
<pre><code>for j := high(T) downto k+1 do
    if T[j] &lt; T[j-1] then echanger(T[j],T[j-1]) {fi}
{od}</code></pre>
                                            <img src="../images/tri_bulles_Pascal.png" alt="">
                                            <p>Pour le tri par insertion, l'hypothèse inductive est plus faible puisque nous supposons simplement que les éléments du sous-tableau gauche sont triés. (Cela n'implique pas qu'ils soient définitivement bien placés).</p>
                                            <img src="../images/hypothese_inductive_Pascal.png" alt="">
                                            <p>Le pas inductif va correspondre ici à l'insertion de l'élément T[k] dans le sous-tableau T[0..k].</p>
                                            <p>L'itération se terminera lorsque nous aurons insérer le dernier élément du tableau.</p>
                                            <p>Au niveau de l'initialisation, le plus petit sous-tableau gauche pour lequel l'hypothèse est vérifiée correspond au premier élément.</p>
<pre><code>for k := low(T)+1 to high(T) do
    { insérer T[k] dans T[0..k]  }</code></pre>
                                            <p class="em">Rétablissement de l'invariant :</p>
                                            <img src="../images/retablissement_invariant_Pascal_1.png" alt="">
<pre><code>valeurAinserer := t[k] ;
j := k ;</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_2.png" alt="">
<pre><code>while (j &gt; low(T)) and (valeurAinserer &lt; t[j - 1]) do
    begin
        t[j] := t[j - 1] ;
        dec(j)
end {do} ;</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_3.png" alt="">
<pre><code>t[j] := valeurAinserer</code></pre>
                                            <img src="../images/retablissement_invariant_Pascal_4.png" alt="">
                                            <p><span class="em">Remarque :</span> les trois algorithmes de tri sont de complexité quadratique (N<sup>2</sup>). Nous en étudierons de plus performants : tri rapide, tri fusion, tri par tas.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Recherche :</h3>
                            <p>Soient les déclarations-définitions suivantes :</p>
<pre><code>
const IndMin = 1 ;
      IndMax = 10 ;
type  Item = Integer ;
      TabItem = array [IndMin..IndMax] of Item ;</code></pre>
                            <p>Soient un ensemble d'éléments représenté par un tableau de type <span class="em">TabItem</span>.</p>
                            <p>Le problème est de trouver un élément du tableau qui soit égal à l'argument de recherche <span class="em">el</span>.</p>
                            <p>En Pascal, nous traduirons le module de recherche d'un élément dans un tableau par une fonction booléenne qui retournera la valeur <span class="em">true</span> si la recherche aboutit et <span class="em">false</span> sinon.</p>
                            <p>Cette fonction Pascal correspond en fait à une "procédure fonctionnelle" car elle retourne également l'indice de l'élément recherché. Cela sera réalisé via un paramètre variable dont la valeur sera significative si et seulement si la recherche a abouti.</p>
                            <p>Pour plus de généralité, le module de recherche reçoit également en entrée les valeurs des indices qui délimitent la portion du tableau dans laquelle la recherche doit être effectuée (<span class="em">et, pour plus de simplicité, les valeurs des indices sont des valeurs entières positives</span>).</p>
                            <img src="../images/recherche_Pascal.png" alt="">
                            <ol>
                                <li>
                                    <h4>Recherche séquentielle ou linéaire :</h4>
                                    <p>La méthode la plus simple consiste à explorer séquentiellement le tableau. Si plusieurs composants du tableau correspondent à l'élément recherché, c'est celui d'indice le plus bas (le premier rencontré) qui sera "retourné".</p>
                                    <p>Deux conditions permettent d'arrêter cette recherche linéaire :</p>
                                    <ol>
                                        <li>
                                            <p>on a trouvé l'élément</p>
                                        </li>
                                        <li>
                                            <p>on a parcouru le tableau sans trouver l'élément</p>
                                        </li>
                                    </ol>
                                    <p>L'algorithme devient :</p>
                                    <ul>
                                        <li>
                                            <p>initialiser <span class="em">IndEl</span> à la valeur de <span class="em">IndDeb</span></p>
                                        </li>
                                        <li>
                                            <p>
                                                <span class="em">tant que</span> le tableau n'a pas été totalement parcouru et que l'élément n'a pas été trouvé
                                                <p class="em">faire</p>
                                                <p>continuer la recherche</p>
                                                <p class="Em">ftant</p>
                                            </p>
                                        </li>
                                        <li>
                                            <p>si le tableau n'a pas été vainement parcouru, la fonction retourne la valeur <span class="em">true</span> et la valeur de <span class="em">IndEl</span> correspond à la valeur de l'indice de l'élément recherché, sinon la fonction retourne la valeur <span class="em">false</span>.</p>
                                        </li>
                                    </ul>
                                    <p>La condition "le tableau n'a pas été totalement parcouru" correspond à (<span class="html">IndEl &lt;= IndFin</span>) et la condition "l'élément n'a pas été trouvé" à (<span class="html">t[IndEl] &lt;&gt; el</span>).</p>
                                    <p>Quant à l'action "continuer recherche", elle se traduit par l'incrémentation de <span class="em">IndEl</span> c'est-à-dire par l'instruction <span class="html">inc(IndEl)</span>.</p>
<pre><code>function Recherche_Lineaire
(   const T : TabItem ;
    IndDeb,IndFin : Cardinal ;
    el : item;
    var IndEl : Cardinal
) : Boolean;
{recherche la première occurence de l'item el dans le tableau T entre les indices IndDeb et IndFin, si l'item est trouvé, l'indice correspondant est stocké dans IndEl et la fonction retourne vrai, sinon la fonction retourne faux et la valeur de IndEl est non significative}

begin
    IndEl := IndDeb ;
    while (IndEl &lt;= IndFin) and (t[IndEl] &lt;&gt; el ) do
        inc(IndEl)
    {od} ;
    { (IndEl &gt; IndFin) or (T[IndEl] = el)
       évaluation optimisée
       (IndEl &gt; IndFin) or ( (IndEl &lt;= IndFin) and (T[IndEl] = el) ) }
    Result := IndEl &lt;= IndFin
end;</code></pre>
                                    <p>Il existe une autre version de la recherche linéaire qui utilise une sentinelle que l'on ajoute en fin de tableau. Il suffit d'insérer dans cette emplacement supplémentaire la valeur recherchée... ce qui simplifie la condition de continuation de la boucle de recherche.</p>
<pre><code>while (T[IndEl &lt;&gt; El) do ...</code></pre>
                                </li>
                                <li>
                                    <p>Si les données sont ordonnées (si le tableau est <span class="em">trié</span>), la recherche sera certainement plus efficace (complexité logarithmique). Pensez à l'annuaire téléphonique !</p>
                                    <p>La recherche dichotomique est une méthode de recherche qui fait l'hypoth!se que le tableau est ordonné.</p>
                                    <p>L'idée de base est de prendre l'élément au milieu (<span class="em">t[IndEl]</span>) de la portion de tableau où l'élément à rechercher (<span class="em">el</span>) peut se trouver.</p>
                                    <ul>
                                        <li>
                                            <p>Si cet élément du milieu est égal à <span class="em">el</span>, la recherche est terminée;</p>
                                        </li>
                                        <li>
                                            <p>S'il est inférieur à <span class="em">el</span>, on en déduit que tous les éléments dont l'indice est inférieur ou égal à milieu peuvent être éliminés des recherches futures.</p>
                                        </li>
                                        <li>
                                            <p>Si l'élément du milieu est supérieur à 
                                            <span class="em">el</span>, la recherche se poursuit dans la portion du tableau délimitée par les valeurs d'indice (<span class="em">IndDeb</span>) et (<span class="em">IndEl-1</span>).</p>
                                        </li>
                                    </ul>
                                    <p>Ainsi, à chaque itération, les paramètres <span class="em">IndDeb</span> et <span class="em">IndFin</span> seront les indices "gauche" et "droite" de la portion de tableau dans laquelle on peut encore espérer trouver l'élément recherché.</p>
<pre><code>function Recherche_dichotomique
(   const T : TabItem ;
    IndDeb,IndFin : Cardinal ;
    el : item;
    var IndEl : Cardinal
) : Boolean;
{recherche une occurence de l'item el dans le tableau T entre les indices IndDeb et IndFin; si l'item el est trouvé, l'indice correspondant est stocké dans IndEl et la fonction retourne vrai, sinon la fonction retourne faux et la valeur de IndEl est non significative}
begin
    Result := false
    while (IndDeb &lt;= IndFin) and not Result do begin
        IndEl := (IndDeb + IndFin) div 2;
        if T[IndEl] &lt; el then IndDeb := IndEl + 1
        else if T[IndEl] &gt; el then IndFin := IndEl - 1
        else {T[indEl] = el } Result := True
    end{do}
end;</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Problèmes d'adaptation :</h3>
                            <p>Les procédures de tri ont été présentées de manière générale en utilisant les paramètres tableaux ouverts. Il est bien certain que vous aurez à adapter ces procédures à des types particuliers de tableaux. Un cas fréquent est celui des tableaux dont tous les éléments ne sont pas significatifs et dont l'utilisation nécessite la connaissance de la longueur effective.</p>
<pre><code>program d_adaption ;
{$APPTYPE CONSOLE}

const INDMAX = 100 ;
type TabInt = array[1..INDMAX] of Integer ;

<span class="em">procedure Tri_Insertion
(var T : TabInt ; lgEff : Cardinal);</span>
var k,j : Cardinal ; valeurAinserer : Integer ;
begin
    for k := 2 to lgEff do begin
        valeurAinserer := t[k] ;
        j := k ;
        while (j &gt; 1) and (valeurAinserer &lt; t[j-1]) do
        begin
            t[j] := t[j - 1];
            dec(j);
        end{do};
        t[j] := valeurAinserer
    end{do}
end;

<span class="em">procedure afficherTabInt
(const T : TabInt ; lgEff : Cardinal) ;</span>
var k : Cardinal ;
begin
    for k := 1 to lgEff do write(T[k]:4) ;
    writeLn
end ;

<span class="em">procedure initialiserTabInt
(out T:TabInt;out lgEff;Cardinal;
 const TT:array of Integer);</span>
var k : Cardinal ;
begin
    lgEff := high(TT) + 1 ;
    for k := 1 to lgEff do T[k] := TT[k-1] ;
end ;

var A : TabInt ; lg : Cardinal ;
begin
    initialiserTabInt(A,lg,[5,1,4,2,8,3]) ;
    afficherTabInt(A,lg) ;
    writeLn ;
    tri_Insertion(A,lg) ;
    afficherTabInt(A,lg) ;
    readLn
end.</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="lazarus">Lazarus :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p><span class="em">Free Pascal</span> est un compilateur de code source Pascal, acoompagné de nombreux outils. Même s'il accepte d'anciennes versions de Pascal, il est avant tout conçu pour traiter du Pascal Objet. <span class="em">Lazarus</span> est quant à lui un <span class="em">E.D.I.</span></p>
                            <p>Un <span class="em">E.D.I.</span> (cet acronyme est si souvent employé qu'il est en général écrit sous la forme condensée EDI) ou <span class="em">Environnement de Développement Intégré</span> rassemble en une seule application les différents outils nécessaires au développement : un éditeur de code, un débogueur, un compilateur, etc.</p>
                            <p>Lazarus est un E.D.I. qui se sert de Free Pascal comme compilateur sous-jacent. Allié à Free Pascal, il a toujours cherché à s'approcher le plus possible de son grand frère commercial Delphi. S'il est moins puissant que ce dernier, il a certaines qualités propres qui ne sont pas négligeables :</p>
                            <ul>
                                <li>
                                    <p>il est <span class="em">open source</span>, c'est-à-dire que le programmeur a accès au code qui a permis de le générer;</p>
                                </li>
                                <li>
                                    <p>il est lui-même écrit en Pascal;</p>
                                </li>
                                <li>
                                    <p>il intègre les fonctionnalités essentielles d'un langage moderne;</p>
                                </li>
                                <li>
                                    <p>il permet de produire gratuitement toutes sortes d'applications, y compris commerciales;</p>
                                </li>
                                <li>
                                    <p>il fonctionne directement avec bon nombre de machines et de systèmes d'exploitation (dont Windows, Linux et MacOS);</p>
                                </li>
                                <li>
                                    <p>il gère du code exploitable tel que, idépendamment de la plateforme utilisée, selon le principe d'une base de code unique, quel que soit le système d'exploitation visé</p>
                                </li>
                                <li>
                                    <p>il est extensible grâce à un ensemble important de bibliothèques développées parallèlement par une foule de contributeurs;</p>
                                </li>
                                <li>
                                    <p>il bénéficie d'une communauté d'utilisateurs internationale très active (pour les pays francophones, la référence est <a href="https://lazarus.developpez.com/">https://lazarus.developpez.com/</a> où les auteurs de l'ouvrage se retrouvent fréquemment);</p>
                                </li>
                                <li>
                                    <p>il est traduit en français, comme dans plus d'une vingtaine de langues.</p>
                                </li>
                            </ul>
                            <p>Par ailleurs, au-delà de leurs qualités indéniables, nous pensons que Free Pascal et Lazarus permettent de s'amuser à programmer en conservant ce qui avait fait le succès de leurs ancêtres : un langage très proche de la réflexion algorithmique et des outils faciles à exploiter, y compris par un débutant.</p>
                        </li>
                        <li>
                            <h3>Installer Lazarus :</h3>
                            <p>L'installation de l'E.D.I. Lazarus est en général aussi simple que celle de n'importe quelle autre application. C'est la seule phase où le système d'exploitation joue à plein. Avec Windows et Linux, vous devriez être capable de l'effectuer en un rien de temps. Avec MacOS, les opérations devraient prendre plus de temps à cause du nombre d'étapes à accomplir pour une installation complète.</p>
                            <p>Quel que soit votre système d'exploitation, il est vivement conseillé d'installer la toute dernière version <span class="em">stable</span> de Lazarus. Pour cela rendez-vous sur <a href="https://lazarus-ide.org/" target="_blank">le site officiel de Lazarus</a> pour télécharger la version stable correspondant à votre système.</p>
                            <p>L'installation sous d'autres systèmes d'exploitation est prévue par les concepteurs de Free Pascal et de Lazarus, mais, pour l'instant, nous nous sommes limotés aux trois systèmes les plus fréquemment utilisés sur PC.</p>
                        </li>
                        <li>
                            <h3>Organisation générale de l'interface de Lazarus :</h3>
                            <ol>
                                <li>
                                    <h4>Premier lancement de Lazarus :</h4>
                                    <p>L'installation de Lazarus terminée, quel que soit le système d'exploitation utilisé, lancez son exécution. La première fois, une fenêtre de vérification de la <span class="em">configuration</span> peut s'afficher. Sur les versions antérieures à la version 2.2.2 de Lazarus, cet affichage était systématique.</p>
                                    <p>Voici les répertoires utilisés lorsque Lazarus est installé en laissant les options par défaut :</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Sections</th>
                                                <th>Windows</th>
                                                <th>Linux</th>
                                                <th>MacOS</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td class="em">Lazarus</td>
                                                <td>C:\lazarus</td>
                                                <td>/usr/bin/lazarus</td>
                                                <td>/usr/local/share/lazarus</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Compilateur</td>
                                                <td>C:\lazarus\fpc\3.2.2\bin\x86_64-win64\fpc.exe</td>
                                                <td>/usr/bin/fpc</td>
                                                <td>/usr/local/share/fpc</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Codes sources de FPC</td>
                                                <td>C:\lazarus\fpc\3.2.2\source</td>
                                                <td>/usr/lib/fpc/src</td>
                                                <td>/user/local/share/fpcsrc</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Make</td>
                                                <td>C:\lazarus\fpc\3.2.2\bin\x86_64-win64\make.exe</td>
                                                <td>/usr/bin/make</td>
                                                <td>/usr/bin/make</td>
                                            </tr>
                                            <tr>
                                                <td class="em">Débogueur</td>
                                                <td>C:\lazarus\mingw\x86_64-xin64\bin\gdb.exe</td>
                                                <td>/usr/bin/gdb</td>
                                                <td>(dépend de votre installation)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Lorsque tout est correct, cliquez sur le bouton "Démarrer l'EDI" en bas à droite.</p>
                                    <p>À partir de maintenant, les différence entre les systèmes d'exploitation deviennent négligeables. Vous pourrez donc vous concentrer sur la programmation, les mains dans le cambouis et le cerveau en pleine ébullition !</p>
                                </li>
                                <li>
                                    <h4>La fenêtre principale :</h4>
                                    <p>En haut de l'écran se présente une large fenêtre nommée "EDI Lazaus v2.2.2 - project1". C'est la <span class="em">fenêtre principale</span> de Lazarus, qui est toujours visible.</p>
                                    <figure>
                                        <img src="../images/fenetre_principale_Lazarus.png" alt="">
                                        <figcaption>Fenêtre principale de Lazarus</figcaption>
                                    </figure>
                                    <p>Cette fenêtre présente :</p>
                                    <ul>
                                        <li>
                                            <p>une barre de <span class="em">menus</span> (de "Fichier" à "Aide");</p>
                                        </li>
                                        <li>
                                            <p>à gauche, des icônes réparties en deux bandes : ce sont des <span class="em">boutons de raccourcis</span> qui évitent de naviguer dans les menus pour les fonctionnalités les plus courantes</p>
                                        </li>
                                        <li>
                                            <p>à droite, les onglets de la palette des composants (par la suite, la "palette de composants" sera souvent appelée plus simplement la "palette") : chaque bouton illustré par une icone représente un outil appelé <span class="em">composant</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Un <span class="em">composant</span> d'application est un élément prêt à l'emploi, comme une liste déroulante, une grille, un bouton, un calendrier, etc. Lazarus en propose d'origine plus de deux cents, d'où la nécessité de les regrouper par familles dans la palette.</p>
                                </li>
                                <li>
                                    <h4>La fiche de travail :</h4>
                                    <p>La <span class="em">fiche</span> en cours de conception est la fenêtre vide remplie de petits points que vous voyez sous la fenêtre principale et qui porte le titre de "Form1".</p>
                                    <img src="../images/fiche_initiale_mode_conception_Lazarus.png" alt="">
                                    <p>Cette <span class="em">fiche de travail</span> est un outil puissant qui permet de composer une grande partie de l'apparence de l'application finale. Elle recueillera, lors de la phase de <span class="em">conception</span>, les composants nécessaires à l'application en cours de réalisation. À l'<span class="em">exécution</span>, elle ne montrera plus les points qui servent de guide lors de la conception.</p>
                                    <p>La <span class="em">conception</span> est la phase de préparation durant laquelle le programmeur dépose les composants nécessaires sur la fiche de travail à l'emplacement voulu, établit la valeur de leurs propriétés et rédige le code nécessaire au fonctionnement de l'ensemble.</p>
                                    <p>L'<span class="em">exécution</span> est l'étape durant laquelle le code est exécuté après avoir été compilé. Les composants prennent alors l'apparence qu'ils ont dans toute application, à savoir un mélange entre le style fixé par le système d'exploitation et l'aspect que leur impose le code créé.</p>
                                    <p>La fiche de départ est appelée <span class="em">fiche principale</span> c'est toujours à partir d'elle qu'elle démarre une application. D'autres fiches peuvent compléter la fiche principale et être utilisées selon les besoins.</p>
                                    <p>Une <span class="em">fiche</span> est en fait un composant particulier dont le nom de base est <span class="html">TForm</span>. Voilà pourquoi une fiche est parfois aussi appelée une "<span class="em">forme</span>".</p>
                                </li>
                                <li>
                                    <h4>L'inspecteur d'objets :</h4>
                                    <p>À gauche de votre espace de travail se tient une fenêtre nommée <span class="em">inspecteur d'objets</span>.</p>
                                    <p>L'<span class="em">inspecteur d'objets</span> est un lieu d'observation essentiel, qui permet de définir l'aspect visuel et le comportement des composants.</p>
                                    <figure>
                                        <img src="../images/inspecteur_objets_Lazarus.png" alt="">
                                        <figcaption>L'inspecteur d'objets</figcaption>
                                    </figure>
                                    <p>Cette fenêtre est divisée en deux parties.</p>
                                    <p>La partie supérieure ("Composants") décrit sous la forme d'une arborescence la hiérarchie des composants déposés sur la fiche de travail. Celui en cours d'examen y apparaît en surbrillance. Pour le moment n'y figure que la fiche de travail par défaut "Form1".</p>
                                    <p>La partie inférieure est divisée en quatre onglets dont seuls les deux premiers nous intéresseront.</p>
                                    <p>L'onglet "Propriétés" permet d'examiner ey de modifier les <span class="em">propriétés</span> du composant actif.</p>
                                    <p>Une <span class="em">propriété</span> représente un attribut du composant : elle concerne entre autres son aspect, sa position ou ses dimensions. Par exemple, de nombreux composants possèdent une propriété <span class="em">Visible</span> qui indique si le composant sera visible ou non à l'exécution.</p>
                                    <p>Dans l'inspecteur d'objets, les propriétés sont rangées <span class="em">par ordre alphabétique</span> ce qui facilite leur recherche.</p>
                                    <p>L'onglet "Événements" permet d'ajouter des comportements spécifiques liés aux <span class="em">événements</span>. Pour traiter un événement, il faut en effet prévoir le code à exécuter dans le gestionnaire qui lui correspond.</p>
                                    <p>Pour rappel, un <span class="em">événement</span> est une réaction à une action de l'utilisateur (par exemple, lorsqu'il déplace sa souris), à une condition interne de l'application ou à un message du système d'exploitation lui-même.</p>
                                    <p>L'<span class="em">inspecteur d'objets</span> est si utilisé qu'une touche est dédiée à son affichage. Il suffit en effet de presser la touche <span class="em">F11</span> pour le rendre visible. Vous pouvez aussi utiliser l'option "Inspecteur d'objets" du menu "Voir" pour le même résultat.</p>
                                </li>
                                <li>
                                    <h4>L'éditeur de source :</h4>
                                    <p>Au centre de l'environnement de travail, vous disposez de l'<span class="em">éditeur de source :</span></p>
                                    <figure>
                                        <img src="../images/editeur_source_Lazarus.png" alt="">
                                        <figcaption>L'éditeur de source</figcaption>
                                    </figure>
                                    <p>Comme son nom l'indique, cette fenêtre contient l'<span class="em">éditeur</span>, c'est-à-dire l'outil de rédaction du code informatique nécessaire à l'application. Ce code étant à l'origine de l'application, il est appelé <span class="em">code source</span> ou plus simplement <span class="em">source</span>.</p>
                                    <p>L'<span class="em">éditeur de source</span> est une sorte de traitement de texte dont toutes les fonctionnalités tendent à faciliter la saisie et la correction du code. Par exemple, il utilise la <span class="em">coloration syntaxique</span> pour distinguer des catégories d'éléments.</p>
                                    <p>Les fichiers à éditer les plus courants sont les <span class="em">unités</span>.</p>
                                    <p>L'<span class="em">unité</span> constitue la brique de base d'un projet. Elle adopte une structure particulière dont nous étudierons l'organisation plus tard. À chaque unité correspond un fichier unique.</p>
                                    <p>Par défaut, la première unité s'appelle "unit1" et correspond à la fiche "Form1". Une unité contient le code en Pascal nécessaire pour accomplir les tâches qui lui incombent.</p>
                                    <p>Si une fiche est toujours accompagnée d'une unité, la réciproque n'est pas vraie : vous pourrez créer des unités d'utilitaires qui n'ont pas besoin d'être présents sur une fenêtre, mais qu'il vous paraîtra utile de regrouper. Par exemple, une unité contiendra des fonctions mathématiques et une autre des outils pour le dessin.</p>
                                    <p>L'éditeur est capable de gérer plusieurs fichiers indiqués par des ongleys portant leur nom. Vous pourrez par conséquent naviguer facilement d'un fichier à l'autre, tout simplement en cliquant sur l'onglet visé.</p>
                                    <p>La <span class="em">commutation d'une fiche à son unité</span> (et réciproquement) s'opère par une pression sur la touche <span class="em">F12</span> ou par l'option "Commuter Fiche/Unité" du menu "Voir". Si aucune fiche n'est rattachée à l'unité en cours, cette option est désactivée.</p>
                                    <figure>
                                        <img src="../images/organisation_generale_EDI.png" alt="">
                                        <figcaption>Organisation générale de l'E.D.I.</figcaption>
                                    </figure>
                                    <p>L'illustration ci-dessus reprend les quatre éléments fondamentaux de l'E.D.I. en montrant les liens qui les unissent au <span class="em">projet informatique</span> qui sera bientôt le vôtre. Les interactions entre les unités n'ont pas été représentées. Ce projet comprend des fiches accompagnées de leur unité (ici, au nombre de trois), ainsi que des unités d'outils sans fiches (ici, deux).</p>
                                    <p>Le <span class="em">projet</span> est l'ensemble des fichiers personnalisés rattachés à la production d'une application particulière. Il existe en effet plusieurs fichiers utilisés. Certains sont propres à l'application en cours de développement et d'autres font partie de Lazarus, de Free Pascal ou des éventuels outils complémentaires que vous aurez installés. Ces derniers fichiers sont permanents est stockés dans des dossiers spécifiques.</p>
                                </li>
                            </ol>
                            <p>La <span class="em">fenêtre principale</span>, la <span class="em">fiche de conception</span>, l'<span class="em">inspecteur d'objets</span> et l'<span class="em">éditeur de source</span> sont les quatre outils indispensables à tout développement avec Lazarus. S'il en existe bien d'aytres, l'E.D.I. perdrait tout intérêt sans ceux-là.</p>
                            <p>Vous voici donc maître du tableau de bord. Il vous reste à piloter Lazarus et à découvrir la puissance de son moteur; à savoir Free Pascal !</p>
                        </li>
                        <li>
                            <h3>Une application de bienvenue :</h3>
                            <p>Après l'installation et la découverte du tableau de bord, il est enfin temps de faire un tout petit tour de conduire accompagnée.</p>
                            <p>Précisons d'emblée que les programmes que vous apprendrez à écrire ici seront essentiellement des <span class="em">applications graphiques</span>.</p>
                            <p>Les <span class="em">applications graphiques</span> sont celles que vous utilisez probablement tous les jours. Elles font appel au <span class="em">système de fenêtrage</span> ainsi qu'à des <span class="em">contrôles</span> (des éléments visuels tels que boutons, boîtes listes, cases à cocher, etc.) que l'utilisateur peut sélectionner par différents biais (clavier, souris, doigt...).</p>
                            <p>La première d'entre elles se pliera à la tradition en programmation qui veut que l'apprenti(e) développeur(se) commence par réaliser une application de bienvenue. Ce genre d'application minimaliste s'inscrit dans la tradition des petits programmes de test et a été inauguré par Brian Kernighan et Dennis Ritchie dans leur ouvrage "The C Programming Language" (voir <a href="https://fr.wikipedia.org/wiki/Hello_world" target="_blank">https://fr.wikipedia.org/wiki/Hello_world</a> pour des informations complémentaires).</p>
                            <p>Nous sommes sûrs que vous avez hâte de passer à l'action ! Stop ! Arrêt sur image... Concevoir un loigiciel, ce n'est pas se jeter tête baissée et commencer à coder tout de suite, même si l'envie en est pressante. "Hou, les vilains rabat-joie !", direz-vous. Nous avons conscience de votre frustration, mais vous nous remercierez un jour, soyez-en assuré(e).</p>
                            <p>Avant toute chose, il vous faut prendre le temps de la réflexion :</p>
                            <ul>
                                <li>
                                    <p>Que doit faire mon logiciel ? Ainsi-je bien analysé tous les besoins exprimés par mon "client" ? Lui ai-je bien, avant cela, posé les bonnes questions pour qu'il les exprime ?</p>
                                </li>
                                <li>
                                    <p>Quelles plateformes et technologies suis-je obligé(e) d'utiliser ou puis-je éventuellement choisir ?</p>
                                </li>
                                <li>
                                    <p>Existe-t-il du code tout fait ou des composants utilisables pour me permettre de gagner du temps ?</p>
                                </li>
                                <li>
                                    <p>Comment organiser mon code source et le découper en blocs logiques ?</p>
                                </li>
                                <li>
                                    <p>Comment faciliter une évolution future du logiciel, l'ajout de nouvelles fonctionnalités ?</p>
                                </li>
                            </ul>
                            <p>Une fois que vous aurez une idée précise de la conception de votre logiciel, vous pourrez commencer à écrire du code. Mais le processus de réflexion sera loin d'êtrer terminé : pour chaque traitement, il faudra chercher le meilleur algorithme, peut-être regrouper certaines actions, identifier les endroits où il sera primordial d'optimiser la vitesse de traitement, etc.</p>
                            <p>Il est vrai qsue toutes cces concidérations vous concerneront beaucoup plus tard, mais il ne sera pas inutile de les garder dans un coin de votre esprit durant la réalisation des petits exercices de cette page.</p>
                            <p>Faites-nous plaisir en vous efforçant de suivre ce conseil : avant d'écrire en Pascal, formulez le problème en <span class="em">français</span>, traduisez-le en <span class="em">pseudo-code</span> et couchez-le sur papier. Le passage au Pascal ne sera alors plus qu'une formalité.</p>
                            <p>Le <span class="em">pseudo-code</span> est une façon d'écrire un algorithme dans un langage proche du langage courant, mais légèrement formalisé. Il est couramment employé en algorithme pour résoudre un problème avant sa transposition dans un langage informatique particulier.</p>
                            <ol>
                                <li>
                                    <h4>Concevoir l'application :</h4>
                                    <p>L'application à concevoir est rudimentaire puisqu'il s'agit tout simplement d'afficher "Bonjour, monde !" sur la fenêtre principale. Il se trouve d'ailleurs qu'il existe une sérieuse candisate pour cette tâche, à savoir la propriété <span class="html">Caption</span> de la fiche, qui permet de changer sa barre de titre.</p>
                                    <p>Pour élaborer notre application, nous partirons de la fiche par défaut de Lazarus.</p>
                                    <p>Depuis l'onglet "Propriétés" de l'inspecteur d'objets, cherchez <span class="em">Caption</span> dans la liste des propriétés de la fiche (rappelez-vous que les propriétés d'un composant sont rangées par ordre alphabétique). Modifiez sa valeur en "Bonjour, monde !", comme montré ci-après, et appuyez sur la touche <span class="em">Enter</span> pour valider le changement :</p>
                                    <figure>
                                        <img src="../images/modification_propriete_Lazarus.png" alt="">
                                        <figcaption>Modification d'une propriété</figcaption>
                                    </figure>
                                </li>
                                <li>
                                    <h4>Créer un projet :</h4>
                                    <p>En premier lieu, si nous avions pas de projet ouvert, nous allons créer une nouvelle application.</p>
                                    <p>Pour créer le projet qui lui correspond, choisissez le menu "Projet" de Lazarus puis sélectionnez "Nouveau projet..." :</p>
                                    <figure>
                                        <img src="../images/creation_projet_Lazarus.png" alt="">
                                        <figcption>La création d'un projet</figcption>
                                    </figure>
                                    <p>Si une boîte de dialogue vous demande si vous désirez enregistrer votre travail, cliquez simplement sur le choix correspondant à votre situation.</p>
                                    <p>La boîte de dialogue correspondant à la création d'un projet va alors apparaître :</p>
                                    <figure>
                                        <img src="../images/boite_creation_projet_Lazarus.png" alt="">
                                        <figcaption>La boîte de création d'un projet</figcaption>
                                    </figure>
                                    <p>Comme sur l'image ci-dessus, choisissez "Application" puis cliquez sur "OK". Tout ancien travail disparaît et vous vous retrouvez devant l'environnement de travail de vos début.</p>
                                    <p>Dans le point suivant, on va sauver ce squelette d'application dans un dossier spécifique. Ensuite, la création du projet sera terminée.</p>
                                </li>
                                <li>
                                    <h4>Sauvegarder le projet en cours :</h4>
                                    <p>La sauvegarde du projet en cours est très simple elle aussi. Il s'agit d'une étape essentielle, car rien n'est plus désagréable que de perdre des heures de travail. Pour le moment, ce serait loin d'être le cas, mais les bonnes habitudes sont à prendre dès maintenant !</p>
                                    <p>Tout d'abord, créez un dossier spécifique pour le projet (par exemple, <span class="em">01 - Bonjour</span>). En effet, un projet étant toujours constitué de plusieurs fichiers, il serait risqué d'enregistrer votre travail directement sur le bureau ou dans des dossiers partagés : chaque projet doit avoir son propre dossier.</p>
                                    <p>Depuis la fenêtre principale de Lazarus, allez dans "Enregistrer le projet" du menu "Projet".</p>
                                    <p>Pour <span class="em">tout sauvegarder</span>, vous pouvez aussi cliquer sur l'icône avec les doubles disquettes dans la barre d'outils de la fenêtre principale de Lazarus ou utiliser la combinaison de touches <span class="em">CTRL + MAJ + S</span>.</p>
                                    <p>Une première boîte de dialogue vous demande d'entrer un nom de fichier pour le projet. L'extension .lpi correspond à <span class="em">Lazarus Project Information</span>, indiquant ainsi que le fichier contient les informations relatives à un projet Lazarus. Ce nom sera également le nom du fichier de l'exécutable de votre application.</p>
                                    <p>Choisissez le dossier que vous avez créé pour votre projet et tapez <span class="em">BonjorMonde</span> comme nom de fichier (son extension sera automatiquement <span class="html">.lpi</span>).</p>
                                    <p>Une seconde boîte de dialogue vous demande de saisir un nom pour l'unité : c'est le fichier qui contiendra le code source de votre fiche et dont l'extension sera <span class="html">.pas</span> (pour <span class="em">PAScal</span>). Tapez <span class="em">ufrmPrincipale</span> comme nom d'unité. Ce nom d'unité devient aussi, sans autre intervention de votre part, le nom ajouté après le mot <span class="html">unit</span> au tout début du source dans l'éditeur de code.</p>
                                    <p>Cette <span class="em">identité entre le nom de l'unité et le nom du fichier</span> sans son extension est obligatoire. Les deux ne peuvent contenir ni espaces ni caractères accentués.</p>
                                    <p>Une mauvaise idée serait de conserver les noms fournis par défaut par Lazarus : le temps gagné serait largement perdu lorsque vous voudriez retrouver ce que vous avez fait, tous les projets et toutes les fiches portant alors des noms similaires, sans indiquer leur fonction. Adoptez donc des <span class="em">noms aussi expliite que possible</span> !</p>
                                    <p>Il est imposible d'ignorer la propriété <span class="em">Name</span>, car elle est commune à tous les composants. C'est elle qui fournit un nom spécifique à un objet.</p>
                                    <p>Ce nom doit être un <span class="em">identificateur</span> correct.</p>
                                    <p>L'<span class="em">identificateur</span> est le nom qui permet d'identifier sans ambiguïté chaque élément d'un projet. C'était par exemple le cas du nom de l'unité <span class="em">ufrmPrincipale</span>.</p>
                                    <p>Un identificateur doit commencer par une lettre non accentuée et uniquement contenir des caractères alphabétiques (A à Z, en majuscules ou minuscules, non accentués),  des chiffres (0 à 9), ainsi que le caractère de soulignement (_).</p>
                                    <p>Remarsue : Le Pascal Objet ne fait <span class="em">pas de différence entre les majuscules et les minuscules</span>. Par conséquent, Ab est pour lui identique à aB. D'autre part, il est <span class="em">interdit de choisir comme identificateur un des mots réservés</span> du Pascal Objet.</p>
                                    <p>Par défaut, le nom d'une fiche est de la forme <span class="em">FormX</span> où <span class="em">X</span> est un nombre entier. Ainsi, <span class="em">Form1</span> est celui de la première fiche créée. Ce nom proposé par Lazarus n'indiquant rien sur sa fonction, il est vivement conseillé de l'adapter à son rôle dans le programme. Des noms comme <span class="em">Principale</span>, <span class="em">Impression</span> et <span class="em">Options</span> seront plus parlants que <span class="em">Form1</span>, <span class="em">Form2</span> ou <span class="em">Form3</span>, surtout lorsque le temps sera passé par là pour détruire sournoisement quelques neurones et synapses !</p>
                                    <p>Par convention, les <span class="em">identificateurs</span> suivent la technique appelée <span class="em">camel case</span>, c'est-à-dire que chaque mot qui forme l'identificateur commence par une majuscuele suivie de minuscules (par exemple : <span class="em">CalculDuLoyer</span>).</p>
                                    <p>Pour les composants (dont les fiches), afin de bien les distinguer des autres éléments, nous avons choisi la variante <span class="em">lower camel case</span> selon laquelle le premier mot est entièrement en minuscules. Ainsi, une fiche sera nommée avec un préfixe en minuscules <span class="em">frm</span> (pour <span class="em">Form</span>) suivi de son nom. Par exemple, la fiche principale sera nommée <span class="em">frmPrincipale</span>.</p>
                                    <p>L'unité qui se rapporte à la fiche portera le même nom que la fiche, mais précédé d'un <span class="em">u</span> pour unité. Voilà l'explication du nom <span class="em">ufrmPrincipale</span> donné à l'unité de notre première application.</p>
                                    <p>Pour prendre de bonnes habitudes, renommez la fiche de l'application de bienvenue grâce à sa propriété <span class="em">Name</span>en lui donnant la valeur <span class="em">frmPrincipale</span>. Appuyez sur la touche <span class="em">Enter</span> afin de valider ce changement.</p>
                                    <p>Une fois l'ensemble validé, le projet est sauvegardé.</p>
                                </li>
                                <li>
                                    <h4>Compiler et exécuter l'application :</h4>
                                    <p>Lancez la compilation et l'exécution de l'application en choisissant l'option "Exécuter" du menu "Exécuter", en cliquant l'icône avec un triangle vert ou encore en pressant sur la touche <span class="em">F9</span>.</p>
                                    <p>Voici une capture de l'application en cours d'exécution :</p>
                                    <figure>
                                        <img src="../images/application_bienvenue_Lazarus.png" alt="">
                                        <figcaption>Application de bienvenue</figcaption>
                                    </figure>
                                    <p>Bravo ! Vous avez écrit votre première application en Pascal Objet !</p>
                                    <p>Lors de la compilation est apparue, en bas de l'écran, une fenêtre de lazarus intitulée "Messages". La <span class="em">fenêtres des messages</span> permet notamment de visualiser les erreurs de syntaxe dans l'éditeur de code. Elle indique également le résultat, les avertissements et les conseils fournis par le compilateur Free Pascal lors de la compilation de vos applications.</p>
                                    <figure>
                                        <img src="../images/2etats_fenetre_messages_Lazarus.png" alt="">
                                        <figcaption>Deux états de la fenêtre des messages</figcaption>
                                    </figure>
                                    <p>Sur l'illustration ci-dessus, la fenêtre a été capturée lors d'une erreur de compilation, puis après une compilation réussie.</p>
                                    <p>Vous pouvez toujours faire apapraître la fenêtre des messages grâce à <span class="em">l'option "Messages" du menu "Voir"</span>.</p>
                                    <p>Peut-être vous sentez-vous frustré(e) de n'avoir rien d'autre à faire... Constatez malgré cette frustration que l'application a rempli le (maigre) rôle qui lui était imparti. Après tout, nous ne lui avions demandé que de saluer le monde !</p>
                                    <p>Cependant, à bien y réfléchir, ce qui s'est produit est plutôt mystérieux. Si vous vous rendez dans le dossier où a été configuré le projet, vous y trouverez entre autres un exécutable : alros que nous n'avons fait que modifier une propriété, d'où provient cet exécutable autonome complet ? Quelles énigmes se cachent derrière les autres fichiers présents ?</p>
                                    <p>De plus, bien que sans prétention, notre application dispose d'emblée de quelques fonctionnalités remarquables. Pour les découvrir, déplacez, redimensionnez, cachez et faites réapparaître sa fenêtre d'exécution. Sans une seule ligne de code de votre part, elle possède déjà les propriétés de n'importe quelle fenêtre ! Comment tout ceka est-il possible ?</p>
                                    <p>Pas plus que votre ordinateur ne démarre par miracle, il n'existe de magie en programmation. En plus, le petit tour promis s'accompagne d'une heureuse confirmation de ce que nous avions annoncé : Lazarus et Free Pascal prennent en charge de nombreux aspects de l'élaboration d'une application, en particulier ce qui ressort de la communication avec le système d'exploitation.</p>
                                    <p>À ce stade de votre apprentissage, retenez qu'un E.D.I. vous évite d'accomplir des tâches aussi rébarbatives et complexes que de synchroniser les parties constitutives d'une application, construire une fenêtre ou s'occuper de son comportement de base.</p>
                                </li>
                                <li>
                                    <h4>Arrêter une application :</h4>
                                    <p>Pour retourner au poste de pilotage, fermez cette première application. Une fenêtre vous indique que son exécution a été interrompue. Vous pouvez désactiver ce comportement en cliquant sur le bouton intitulé "Ne plus montrer ce message" ou le conserver en cliquant sur "OK". Dans les deux cas, vous voici de nouveau en mesure de travailler.</p>
                                    <p>L'<span class="em">interruption de l'application</span> est également accessible en cliquant sur l'icône en forme de carré rouge, particulièrement utile si elle ne parvenait pas à être fermée d'une autre manière. Vous pouvez aussi utiliser la combinaison de touches <span class="em">CTRL + F2</span> ou encore passer par l'option "Arrêter" du menu "Exécuter".</p>
                                </li>
                                <li>
                                    <h4>Ouvrir un projet :</h4>
                                    <p>Savoir sauvegarder un projet n'aurait pas de sens sans pouvoir le rouvrir ! Pour ce faire, allez dans l'option "Ouvrir un projet..." du menu "Projet" et choisissez le fichier qui porte le nom du projet visé.</p>
                                    <p>Pour <span class="em">ouvrir un projet</span>, vous pouvez aussi utiliser la combinaison de touches <span class="em">CTRL + F11</span>.</p>
                                    <p>Par ailleurs, l'option "Ouvrir un projet récent" du menu "Projet" donne accès aux derniers projets utilisés.</p>
                                    <p>Il est encore possible de cliquer sur l'icône du dossier ouvert dans la barre d'outils de la fenêtre principale de Lazarus, mais en faisant attention de bien choisir un fichier avec l'extension .lpi, comme lors de la sauvegarde.</p>
                                    <p>Voici, par exemple, le fichier .lpi correspondant à une application personnelle nommée "MadameMonsieur" :</p>
                                    <figure>
                                        <img src="../images/ouverture_projet_Lazarus.png" alt="">
                                        <figcaption>Ouverture d'un projet</figcaption>
                                    </figure>
                                    <p>Il se peut que Lazarus vous propose de sauvegarder les changements intervenus dans l'éditeur depuis votre dernière sauvegarde. Répondez "Non" à cette question puisqu'il n'y a pas de travail important en cours.</p>
                                    <p>Un <span class="em">fichier modifié lors de la session en cours est marqué par un astérisque</span> avant son nom dans l'onglet correspondant de l'éditeur de source. D'autre part, l'icône de la double disquette correspondant à la sauvegardée est colorée en cas de modification et grise dans le cas contraire.</p>
                                    <p>Notez toutefois qu'il est toujours de <span class="em">votre responsabilité de décider si les changements sont à conserver ou non</span>. En général, la réponse est "Oui" à la question posée par Lazarus, à moins que vous décidiez de perdre le travail effectué récemment...</p>
                                    <p>Après ouverture, le projet choisi est affiché dans l'état où il était lors de sa dernière utilisation.</p>
                                    <p>Vous connaissez désormais quelques-unes des étapes pour créer vos propres applications. Soyez bienvenu(e) dans le monde de la programmation !</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Gestion d'une base de données MySQL avec les composants natifs de Lazarus :</h3>
                            <p>Dans cette partie, vous apprendrez à gérer une base de données MySQL en utilisant les composants natifs de Lazarus (SQLdb).</p>
                            <p>Trois exemples d'applications, de complexité croissante, vous sont proposés. Ils vont de l'utilisation exclusive de contrôles spécialisés en base de données à celle de contrôles classiques. Quelques petits exercices (facultatifs) vous mettront au défi.</p>
                            <ol>
                                <li>
                                    <h4>Introduction :</h4>
                                    <p><span class="em">MySQL</span> est un système de gestion de base de données performant très largement utilisé. Il est actuellement la propriété de la société <span class="em">Oracle</span>; sa déclinaison communautraire <span class="em">MariaDB</span>, sous licence GPL, est de plus en plus répandue dans le monde du libre.</p>
                                    <p>Je vais, sans prétention, vous guider à la réalisation de vos premières applications utilisant une base de données MySQL, sous Lazarus.</p>
                                    <p>Comme illustration, nous allons simuler ici la gestion d'une petite société de location de voitures.</p>
                                    <p>Si vous voulez installer rapidement un petit serveur vous permettant de réaliser les applications ci-après, vous pouvez opter pour une solution tout-en-un, par exemple :</p>
                                    <ul>
                                        <li>
                                            <p><a href="https://www.wampserver.com" target="_blank">WAMP sous Windows</a>;</p>
                                        </li>
                                        <li>
                                            <p><a href="https://ubuntu.com/server/docs/lamp-applications" target="_blank">LAMP sous Linux</a>;</p>
                                        </li>
                                        <li>
                                            <p><a href="https://www.apachefriends.org/fr/download.html" target="_blank">XAMP sous MacOS</a>.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <h4>Création de la base de données de test :</h4>
                                    <p>Avant toute chose, créons la base de données qui servira dans les exemples suivants.</p>
                                    <p>J'ai pris le parti d'utiliser l'interface de gestion <a href="https://www.phpmyadmin.net/" target="_blank">PHPMyAdmin</a>, qui permet de visualier très facilement le résultat des actions que nous entreprendrons. Pour vous simplifier les choses, vous pouvez coller directement les commandes SQL dans l'onglet <span class="em">SQL de PHPMyAdmin</span>; ce n'est toutefois pas une obligation et vous pouvez aussi exécuter à la main les différentes par le biais de l'interface.</p>
                                    <ol>
                                        <li>
                                            <h5>Création de la base :</h5>
                                            <p>Commençons donc par créer notre base de données. Dans l'onglet <span class="em">SQL</span>, recopiez ou collez la commande suivante :</p>
<pre><code>CREATE DATABASE location CHARACTER SET 'utf8';</code></pre>
                                            <img src="../images/create_database_Lazarus_1.png" alt="">
                                            <p>Cliquez sur <span class="em">Exécuter</span> et vérifiez que la nouvelle base de données est bien créée :</p>
                                            <img src="../images/create_database_Lazarus_2.png" alt="">
                                            <p>Le message de réussiye sur fond vert et l'ajout de l'entrée <span class="em">location</span> dans la colonne de gauche attesetent la réussite de l'opération.</p>
                                        </li>
                                        <li>
                                            <h5>Création d'un utilisateur :</h5>
                                            <p>Il n'est jamais conseillé de travailler, dans quel système que ce soit, sauf lorsque c'est indispensable, avec des privilèges d'administrateur. C'est le cas avec MySQL et la première chose que nous allons faire est de créer un utilisateur qui aura spécifiquement accès à notre base de données, et à aucune autre.</p>
<pre><code>CREATE USER 'mysqmdvp'@'%' IDENTITIFIED BY 'passmysqldvp'; GRANT ALL PRIVILEGES ON location.* TO 'mysqldvp'@'%' IDENTITIFIED BY 'passmysqldvp' REQUIRE NONE WITH GRANT OPTION;</code></pre>
                                            <p>Par cette commande, l'utilisateur <span class="em">mysqldvp</span> a été créé et il a accès à la base de données <span class="em">location</span> et à ses tables moyennant le mot de passe <span class="em">passmysqldvp</span>. Vous pouvez bien sûr définir un autre nom d'utilisateur et un autre mot de passe.</p>
                                            <p>Si votre serveur MySQL tourne sur votre machine, vous pouvez remplacer <span class="em">'mysqldvp'@'%'</span> par <span class="em">'mysqldvp'@'localhost'</span>.</p>
                                        </li>
                                        <li>
                                            <h5>Création des tables :</h5>
                                            <p>Dans la liste des bases de données, à gauche, cliquez sur <span class="em">location</span> ou collez la commande suivante dans l'onglet <span class="em">SQL</span> :</p>
<pre><code>USE location;</code></pre>
                                            <p>Dans l'onglet <span class="em">SQL</span> de <span class="em">location</span>, nous allons créer des tables dans la base de données.</p>
                                            <p>Nous avons besoin de trois tables :</p>
                                            <ul>
                                                <li>
                                                    <p>la liste des voitures;</p>
                                                </li>
                                                <li>
                                                    <p>le répertoire des clients;</p>
                                                </li>
                                                <li>
                                                    <p>la liste des locations.</p>
                                                </li>
                                            </ul>
                                            <p>La liste des voitires contiendra les colonnes suivantes :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>Nom de colonnes</th>
                                                        <th>Type</th>
                                                        <th>Commentaires</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td class="em">Plaque</td>
                                                        <td>VARCHAR(12)</td>
                                                        <td>Plaque d'immatriculation</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Marque</td>
                                                        <td>VARCHAR(20)</td>
                                                        <td>Marque du véhicule</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Modele</td>
                                                        <td>VARCHAR(20)</td>
                                                        <td>Modèle</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Cylindree</td>
                                                        <td>SMALLINT</td>
                                                        <td>La cylindrée en cm³</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Transmission</td>
                                                        <td>CHAR(1)</td>
                                                        <td><span class="em">M</span> pour boîte manuelle, <span class="em">A</span> pour automatique</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Prix</td>
                                                        <td>FLOAT</td>
                                                        <td>Coût d'une journée de location</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Le répertoir client contiendra les colonnes suivantes :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>Nom de colonne</th>
                                                        <th>Type</th>
                                                        <th>Commentaires</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td class="em">IdClient</td>
                                                        <td>SMALLINT</td>
                                                        <td>Numéro client unique</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Nom</td>
                                                        <td>VARCHAR(40)</td>
                                                        <td>Le nom du client</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Prenom</td>
                                                        <td>VARCHAR(40)</td>
                                                        <td>Son prénom</td>
                                                    </tr>
                                                    <tr>
                                                        <td>CodePostal</td>
                                                        <td>VARCHAR(10)</td>
                                                        <td>Code postal</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Localite</td>
                                                        <td>VARCHAR(50)</td>
                                                        <td>Localité de résidence</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Rue</td>
                                                        <td>VARCHAR(80)</td>
                                                        <td>Adresse</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Numero</td>
                                                        <td>VARCHAR(10)</td>
                                                        <td>Numéro de maison</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Telephone</td>
                                                        <td>VARCHAR(40)</td>
                                                        <td>Numéro de téléphone</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Email</td>
                                                        <td>VARCHAR(50)</td>
                                                        <td>Adresse mail</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Et voici les colonnes de la liste des locations :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>Nom de colonne</th>
                                                        <th>Type</th>
                                                        <th>Commentaires</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td class="em">IdLocation</td>
                                                        <td>SMALLINT</td>
                                                        <td>Numéro d'ordre unique</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="em">IdClient</td>
                                                        <td>SMALLINT</td>
                                                        <td>Numéro du client</td>
                                                    </tr>
                                                    <tr>
                                                        <td class="em">Plaque</td>
                                                        <td>VARCHAR(12)</td>
                                                        <td>Plaque de la voiture louée</td>
                                                    </tr>
                                                    <tr>
                                                        <td>DateDebut</td>
                                                        <td>DATETIME</td>
                                                        <td>Date et heure de début</td>
                                                    </tr>
                                                    <tr>
                                                        <td>DateFin</td>
                                                        <td>DATETIME</td>
                                                        <td>Date et heure de fin prévue</td>
                                                    </tr>
                                                    <tr>
                                                        <td>DateRentree</td>
                                                        <td>DATETIME</td>
                                                        <td>Date de rentrée effective du véhicule (pour surtaxe)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Assurance</td>
                                                        <td>BOOL</td>
                                                        <td>Indique si une assurance complémentaire a été prise</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>La plaque d'immatriculation et le numéro client étant uniques, ils sont désignés comme <span class="em">clés primaires</span> dans tables respectives et sont utilisés comme <span class="em">clés étrangères</span> dans la table <span class="em">Locations</span>.</p>
                                            <p>Collez la commande suivante pour créer la table <span class="em">Voitures</span> :</p>
<pre><code>CREATE TABLE Voitures (
    Plaque VARCHAR(12) NOT NULL,
    Marque VARCHAR(20) NOT NULL,
    Modele VARCHAR(20) NOT NULL,
    Cylindree SMALLINT NOT NULL,
    Transmission CHAR(1) NOT NULL,
    Prix FLOAT NOT NULL,
    PRIMARY KEY (Plaque)
);</code></pre>
                                            <p>Puis celle-ci pour créer le répertoire des clients (table <span class="em">Clients</span>) :</p>
<pre><code>CREATE TABLE Clients (
    IdClient SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    Nom VARCHAR(40) NOT NULL,
    Prenom VARCHAR(40) NOT NULL,
    CodePostal VARCHAR(10),
    Localite VARCHAR(50),
    Rue VARCHAR(80),
    Numero VARCHAR(10),
    Telephone VARCHAR(40) NOT NULL,
    Email VARCHAR(50),
    PRIMARY KEY (idClient)
);</code></pre>
                                            <p>Et enfin pour la table <span class="em">Locations</span> :</p>
<pre><code>CREATE TABLE Locations (
    IdLocation SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    IdClient SMALLINT UNSIGNED NOT NULL,
    Plaque VARCHAR(12) NOT NULL,
    DateDebut DATETIME NOT NULL,
    DateFin DATETIME NOT NULL,
    DateRentree DATETIME,
    Assurance BOOL NOT NULL,
    PRIMARY KEY (IdLocation)
);</code></pre>
                                            <p>Établissons une relation entre la table <span class="em">Locations</span> et les deux autres tables, par le biais des clés étrangères <span class="em">IdClient</span> (table <span class="em">Clients</span>) et <span class="em">Plaque</span> (table <span class="em">Voitures</span>) :</p>
<pre><code>ALTER TABLE Locations ADD (
    CONSTRAINT FK_Locations_Voitures
    FOREIGN KEY (Plaque)
    REFERENCES Voitures (Plaque)
);
ALTER TABLE Locations ADD (
    CONSTRAINT FK_Locations_clients
    FOREIGN KEY (IdClient)
    REFERENCES Clients(IdClient)
);</code></pre>
                                            <p>Dans PHPMyAdmin, allez dans le sous-menu <span class="em">Concepteur</span> du menu <span class="em">Plus</span> de notre base de données <span class="em">location</span>, pour vérifier que les relations sont correctes entre les trois tables :</p>
                                            <img src="../images/concepteur_Lazarus.png" alt="">
                                        </li>
                                        <li>
                                            <h5>Création des données :</h5>
                                            <p>Notre base de données est prête à être alimentée. Pour gagner du temps, nous allons y créer par script quelques voitures et quelques clients.</p>
                                            <p>D'abord une dizaine de voitures :</p>
<pre><code>INSERT INTO Voitures VALUES('AB-612-BV', 'BMW', '135i Coupé', 3000, 'A', '30.00');
INSERT INTO Voitures VALUES('AC-811-CK', 'Citroën', 'C3', 1600, 'M', '20.00');
INSERT INTO Voitures VALUES('BN-101-AR', 'Citroën', 'C3', 1600, 'M', '20.00');
INSERT INTO Voitures VALUES('AB-555-RB', 'Citroën', 'C3', 1600, 'M', '20.00');
INSERT INTO Voitures VALUES('BU-435-GH', 'Citroën', 'C4 Coupe 2.0VTS', 2000, 'A', '27.50');
INSERT INTO Voitures VALUES ('AM-398-ER', 'Daihatsu', 'Sirion', 1300, 'M', '17.25');
INSERT INTO Voitures VALUES ('CB-135-RK', 'Fiat', '500 1.2 8V Lounge SS', 1200, 'M', '17.00');
INSERT INTO Voitures VALUES ('AM-400-SU', 'Ford', 'Focus ST', 2000, 'M', '23.00');
INSERT INTO Voitures VALUES ('AM-436-FD', 'Ford', 'Taurus SHO', 3500, 'A', '36.25');
INSERT INTO Voitures VALUES ('CU-004-MP', 'Volkswagen', 'New Beetle', 2000, 'M', '27.50');</code></pre>
                                            <p>Puis quelques clients :</p>
<pre><code>INSERT INTO Clients VALUES (1, 'Van Steenbrugge', 'Stefaan', 'B2020', 'Antwerpen (Belgique)', 'De Bosschaertstraat', '30', '3222012345', '');
INSERT INTO Clients VALUES (2, 'Leclercq', 'Jean-Jacques', '68200', 'Mulhouse', 'Avenue Aristide Briand', '37', '33389337878', 'jj.leclercq@monfai.fr');
INSERT INTO Clients VALUES (3, 'Lamoureux', 'Gabriel', '69008', 'Lyon', 'Rue Professeur Beauvisage', '163', '33472985404', 'gaby.lamoureux@monfai.fr');
INSERT INTO Clients VALUES (4, 'Loumrhari', 'Mohamed', '55270', 'Varennes-en-Argonne', 'Rue Louis XVI', '12', '33329807101', '');
INSERT INTO Clients VALUES (5, 'Mispelter', 'Yves', 'CH1002', 'Lausanne (Suisse)', 'Place de la Palud', '2', '41213152555', 'yves.mispelter@myprovider.ch');
INSERT INTO Clients VALUES (6, 'Zidane', 'Yasmina', '13014', 'Marseille', 'Rue Paul Coxe', '72', '33491095656', 'yasmina.z@monfai.fr');
INSERT INTO Clients VALUES (7, 'Patulacci', 'Stéphane', '20304', 'Ajaccio', 'Avenue Antoine Serafini', '', '33495515253', '');
INSERT INTO Clients VALUES (8, 'Matombo Nguza Aniomba', 'Honorine', '13008', 'Marseille', 'Rue du Commandant Rolland', '125', '33491553778', '');
INSERT INTO Clients VALUES (9, 'Filucco', 'Martial', '59000', 'Lille', '', '', '33320495000', '');</code></pre>
                                            <p>Nous avons enfin un peu de matière pour commencer les divers exemples suivants.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Exemple 1 : affichage simple du contenu d'une table :</h4>
                                    <p>Dans Lazarus, créez un projet de type <span class="em">Application</span>. Dans l'inspecteur d'objets, renommez la fiche principale (<span class="em">Form1</span> par défaut) en <span class="em">MainForm</span>.</p>
                                    <ol>
                                        <li>
                                            <h5>TMySQLConnection :</h5>
                                            <p>Dans la palette de composants, cherchez l'onglet <span class="em">SQLdb</span>, qui contient une série de composants permettant de se connecter à différents systèmes de bases de données. Parmi ceux-ci figurent une série de <span class="em">connecteurs</span> pour différentes versions de MySQL; ils sont représentés par des petits dauphins.</p>
                                            <p>Un <span class="em">connecteur</span> va se charger d'assurer la connexion avec le système de bases de données. C'est à lui qu'il faudra fournir le <span class="em">nom de l'hôte</span> qui héberge la base de données, le <span class="em">nom de la base de données</span> ainsi que le <span class="em">nom d'utilisateur</span> et le <span class="em">mot de passe</span> permettant d'y accéder.</p>
                                            <p>Cliquez sur le connecteur qui correspond à votre version de MySQL et déposez un composant sur votre fiche vierge. Ce composant ne sera pas visible à l'exécution du programme, donc vous pouvez le placer n'importe où sur la fiche. Comme votre version de MySQL n'est peut-être pas la même que celle que j'utilise au moment de la rédaction de ces lignes, renommez le composant en <span class="em">MySQLConnection</span> en changeant sa propriété <span class="em">Name</span>; ainsi, toute référence de version aura disparu.</p>
                                            <p>Pour ce projet, nous allons fortement simplifier les choses et définir les noms d'hôte, de base de données, d'utilisateur et le mot de passe directement dans les propriétés du connecteur.</p>
                                            <p class="em html">Dans une application sérieuse, ces propriétés seront définies au cours du programme.</p>
                                            <p>Définissez les propriétés suivantes dans l'inspecteur d'objets :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>Propriété</th>
                                                        <th>Valeur</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>HostName</td>
                                                        <td><span class="em">192.168.0.1</span> (dans ma configuration) ou <span class="em">localhost</span> (si votre serveur MySQL tourne sur votre machine)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>DatabaseName</td>
                                                        <td>location</td>
                                                    </tr>
                                                    <tr>
                                                        <td>UserName</td>
                                                        <td>mysqldvp</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Password</td>
                                                        <td>passmysqldvp</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>Quel connecteur pour MariaDB ?</h5>
                                            <p>Comme cela a été évoqué dans l'introduction, <span class="em">MariaDB</span> est une déclinaison libre de MySQL de plus en plus présente sur le marché des SGBD.</p>
                                            <p>Dans l'onglet <span class="em">SQLdb</span> de la palette de composants, vous ne trouvez que des références aux versions de MySQL, alors quel connecteur choisir lorsque le serveur vous retourne la version 10.1 de MariaDB ? Jusqu'à la 5.5, les numéros de version coïncidaient, ensuite ils divergent :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>MySQL</th>
                                                        <th>MariaDB</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>5.1 à 5.5</td>
                                                        <td>5.1 à 5.5</td>
                                                    </tr>
                                                    <tr>
                                                        <td>5.6</td>
                                                        <td>10.0</td>
                                                    </tr>
                                                    <tr>
                                                        <td>5.7</td>
                                                        <td>10.1</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </li>
                                        <li>
                                            <h5>TSQLTransaction :</h5>
                                            <p>À présent, nous avons besoin d'un composant qui va s'occuper de la <span class="em">transaction</span> avec la base de données.</p>
                                            <p>Dans l'onglet <span class="em">SQLdb</span>, cliquez sur l'icône <span class="em">TSQLTransaction</span> et déposez un composant à côté de votre connecteur.</p>
                                            <p>Cliquez sur le premier composant <span class="em">MySQLConnection</span>; dans l'inspecteur d'objets, cherchez la propriété <span class="em">Transaction</span> et choisissez le composant que vous venez d'ajouter dans la liste déroulante des transactions (<span class="em">SQLTransaction1</span>).</p>
                                            <p>Si vous inspectez les propriétés du composant <span class="em">SQLTransaction</span>, vous pouvez voir que lazarus a automatiquement établi un lien avec le connecteur et avec la base de données.</p>
                                        </li>
                                        <li>
                                            <h5>TSQLQuery :</h5>
                                            <p>Maintenant, il faut ajouter sur la fiche, à côté des deux premiers composants, un autre composant invisible, <span class="em">TSQLQuery</span> (toujours dans l'onglet <span class="em">SQLdb</span>). Il va relayer les <span class="em">commandes SQL</span> vers la base de données et héberger les données entrantes et sortantes dans un <span class="em">dataset</span>.</p>
                                            <p>Initialisez la propriété <span class="em">Database</span> de ce nouveau composant en choisissant <span class="em">MySQLConnection</span> dans la liste déroulante.</p>
                                            <p>Nous disposons à présents de tous les outils nécessaires pour communiquer avec notre base de données.</p>
                                        </li>
                                        <li>
                                            <h5>TDataSource :</h5>
                                            <p>Nous allons afficher le contenu d'une table, par exemple, celle des voitures. Pour ce faire, nous utiliserons un composant <span class="em">TDBGrid</span>, qui ets un <span class="em">tableau</span> spécialisé dans l'affichage de données issues d'une base de données.</p>
                                            <p>Ce tableau ne peut fonctionner seul; il doit êtree couplé à un <span class="em">TDataSource</span>, qui va servir d'<span class="em">intermédiaire entre le dataset et les contrôles</span> tels que le DBGrid.</p>
                                            <p>Cherchez l'onglet <span class="em">DataAccess</span>, cliquez sur le <span class="em">TDataSource</span> (normalement, le tout premier de la série) et déposez-en un exemplaire à côté des trois composants déjà installés (comme eux, il restera invisible).</p>
                                            <p>Dans l'inspecteur d'objets, sa propriétés <span class="em">DataSet</span> doit être initialisée à <span class="em">SQLQuery1</span> dans la liste déroulande.</p>
                                        </li>
                                        <li>
                                            <h5>TDBGrid :</h5>
                                            <p>reste le tableau qui, lui, sera bien visible lors de l'exécution de l'application. Dans l'onglet <span class="em">Data Controls</span>, le <span class="em">TDBGrid</span> est l'un des derniers. Déposez-le sur votre fiche et augmentez ses dimensions :</p>
                                            <img src="../images/TDBGrid_Lazarus.png" alt="">
                                            <p>La propriété <span class="em">DataSource</span> du DBGrid doit être initialisée à <span class="em">DataSource1</span>, que nous avons déposé sur la fiche juste avant.</p>
                                        </li>
                                        <li>
                                            <h5>Commande d'affichage d'une table :</h5>
                                            <p>Bien, bien. Ce que nous voulons faire, c'est afficher dans notre tableau le contenu de la table <span class="em">Voitures</span>. La commande SQL que nous devrons exécuter sera :</p>
<pre><code>SELECT * FROM Voitures;</code></pre>
                                            <p>Cette commande sera affectée à la propriété <span class="em">SQL.Text</span> du composant <span class="em">SQLQuery1</span>.</p>
                                            <p>Pour commander l'affichage de la table, ajoutez un simple bouton (de l'onglet <span class="em">Standard</span>). Dans l'inspecteur d'objets, initialisez sa propriété <span class="em">Caption</span> à "Afficher". Dans l'onglet <span class="em">Événements</span> du composant, cliquez sur les trois points en regard de l'événement <span class="em">OnClick</span> - cela créera une méthode évenementielle dans le code source.</p>
                                            <p class="em">Information : Un double-clic sur la case vide à côté de l'événement a le même résultat.</p>
                                            <p>Voici le contenu de cette méthode :</p>
<pre><code>procedure TMainForm.ButtonClick(Sender: TObject);
begin
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SELECT * FROM Voitures;';
    SQLQuery1.Open;
end;</code></pre>
                                        </li>
                                        <li>
                                            <h5>Fermeture propre de l'application :</h5>
                                            <p>Nous devons également prévoir la déconnexion propre de notre application à la base de données. Sélectionnez la fiche et, dans l'onglet <span class="em">Événements</span> de l'inspecteur d'objets, cliquez sur les trois points en regard d'<span class="em">OnClose</span>.</p>
                                            <p>Voici le code de la méthode événementielle créée :</p>
<pre><code>procedure TMainForm.FormClose(Sender: Tobject; var CloseAction: TCloseAction);
begin
    SQLQuery1.Close;
    SQLTransaction1.Active := False;
    SQLTransaction1.Connected := False;
end;</code></pre>
                                            <p>Il est temps de sauvegarder le projet. Nommez-le (par exemple) <span class="em">mysql01</span>, et enregistrez-le dans un répertoire du même nom.</p>
                                        </li>
                                        <li>
                                            <h5>Compilation et exécution :</h5>
                                            <p>Vérifions à présent que nous avons bien travaillé. Compilez et exécutez votre programme; si vous n'avez pas commis d'erreur, le fait de presser sur le bouton <span class="em">Afficher</span> remplit le DBGrid avec la liste des voitures :</p>
                                            <img src="../images/compilation_execution_Lazarus.png" alt="">
                                            <p>Nous notons au passage que la gestion des caractères accentués (notre base de données a été créée avec le jeu de caractères <span class="em">UTF8</span>) n'est pas correcte. Pour y remédier, dans l'inspecteur d'objets, il faut initialiser la propriété <span class="em">CharSet</span> du connecteur <span class="em">MySQLConnection</span> à <span class="em">UTF8</span>.</p>
                                            <p class="em">Information : On s'attendrait à priori à trouver une liste déroulante avec tous les jeux de caractères disponibkes, mais il n'en est rien : la valeur "UTF8" doit être introduite au clavier.</p>
                                        </li>
                                        <li>
                                            <h5>Code complet de l'exemple 1 :</h5>
<pre><code>unit Main;

{$mode objfpc}{$H+}

interface

uses
    Classes, SysUtils, mysql56conn, sqldb, db, FileUtil, Forms, Controls,
    Graphics, Dialogs, DBGrids, StdCtrls;

type

    { TMainForm }

    TMainForm = class(TForm)
    Button1: TButton;
    DataSource1: TDataSource;
    DBGrid1: TDBGrid;
    MySQLConnection: TMySQL56Connection;
    SQLQuery1: TSQLQuery;
    SQLTransaction1: TSQLTransaction;
    procedure Button1Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var CloseAction: TCloseAction);
    private
    { private declarations }
    public
    { public declarations }
    end;

var
    MainForm: TMainForm;

implementation

{$R *.lfm}

{ TMainForm }

procedure TMainForm.Button1Click(Sender: TObject);
(* Exécution de la requête d'affichage de la table *)
begin
    SQLQuery1.Close;
    SQLQuery1.SQL.Text:= 'SELECT * FROM Voitures;';
    SQLQuery1.Open;
end;
procedure TMainForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
(* Déconnexion propre de la base de données *)
begin
    SQLQuery1.Close;
    SQLTransaction1.Active:= False;
    MySQLConnection.Connected:= False;
end;
end.</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Exemple 2 : édition d'une table au choix :</h4>
                                    <p>Notre premier exemple nous a permis de nous familiariser avec les composants nécessaires à la communication avec une base de données MySQL.</p>
                                    <p>Nous allons créer un second projet un peu plus élaboré, qui va nous permettre de sélectionner une des tables, de l'afficher dans un DBGrid et d'en modifier le contenu.</p>
                                    <p>Créez un nouveau projet de type <span class="em">Application</span>.</p>
                                    <p>Dans l'inspecteur d'objets, renommez la fiche principale (<span class="em">Form1</span> par défaut) en <span class="em">MainForm</span>. Agrandissez la taille de la fiche. Déposez-y, tout comme dans le premir exemple, les composants invisibles qui permettent de communiquer avec la base de données :</p>
                                    <ul>
                                        <li>
                                            <p>un connecteur de la bonne version, que vous renommez directement en <span class="em">MySQLConnection</span>;</p>
                                        </li>
                                        <li>
                                            <p>un <span class="em">TSQLTransaction</span>;</p>
                                        </li>
                                        <li>
                                            <p>un <span class="em">TSQLQuery</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Cette fois, les propriétés <span class="em">HostName</span>, <span class="em">DatabaseName</span> et <span class="em">Password</span> de <span class="em">MySQLConnection</span> restent vierges de toute valeur initiale; la propriété <span class="em">Transaction</span> doit être initialisée à <span class="em">SQLTransaction1</span> et la propriété <span class="em">CharSet</span> doit être initialisée à <span class="em">UTF8</span>. La propriété <span class="em">Database</span> de <span class="em">SQLQuery1</span> doit être initialisée à <span class="em">MySQLConnection</span>.</p>
                                    <ol>
                                        <li>
                                            <h5>Mot de passe de connexion :</h5>
                                            <p>Nous allons faire en sorte que l'utilisateur du programme tape, au début du programme, le mot de passe permettant de se connecter à la base de données. Nous allons faire cela au momement où la fenêtre de l'application reçoit le focus.</p>
                                            <p>Cliquez, dans l'inspecteur d'objets, sur la fiche elle-même, et allez dans l'onglet <span class="em">Événements</span>. Cliquez sur les trois points en regard de l'événement <span class="em">OnActivate</span>, ce qui aura pour effet de créer dans le code source la méthode événementielle <span class="em">FormActivate</span>.</p>
                                            <p>Voici le contenu de cette méthode :</p>
<pre><code>procedure TMainForm.FormActivate(Sender: TObject);
var
    LPassword : String;
begin
    MySQLConnection.HostName := '192.168.0.1';
    MySQLConnection.DatabaseName := 'location';
    MySQLConnection.UserName := 'mysqldvp';
    if InputQuery('Connexion à la base de données', 'Tapez votre mot de passe :', True, LPassword)
        then
            begin
                MySQLConnection.Password := LPassword;
                try
                    MySQLConnection.Connected := True;
                    SQLTransaction1.Active := True;
                except
                    on e: EDatabaseError do
                        begin
                            MessageDlg('Erreur de connexion à la base de données.'#10#13'Le mot de passe est peut-être incorrect ?'#10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Close;
                        end;
                    end;
            end
    else   (* Pas de mot de passe : fin de programme *)
        Close;
end;</code></pre>
                                            <p>Ajoutez également l'unité <span class="em">db</span> à la clause <span class="em">uses</span> (pour <span class="em">EDatabaseError</span>).</p>
                                            <p>Détaillons tout cela. Pour commencer, nous initialisons les propriétés <span class="em">HostName</span>, <span class="em">DatabaseName</span> et <span class="em">UserName</span> di connecteur. Le mot de passe est demandé au moyen d'un dialogue <span class="em">InputQuery</span>. Si l'utilisateur annule l'entrée du mot de passe, le programme se ferme sans autre forme de procès; s'il entre un mot de passe erroné, l'exception déclenchée par le connecteur est interceptée dans le bloc <span class="em">try...except</span>, un message d'erreur est affiché et l'application est fermée.</p>
                                            <p>Avant de réaliser nos premiers tests à ce stade, n'oublions pas de faire en sorte que la connexion à la base de données soit proprement coupée à la fermeture du programme. Comme dans le premier exemple, créez une méthode événementielle pour l'événement <span class="em">OnClose</span> :</p>
<pre><code>procedure TMainForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
begin
    SQLQuery1.Close;
    if SQLTransaction1.Active
        then
            SQLTransaction1.Active := False;
    if MySQLConnection.Connected
        then
            MySQLConnection.Connected := False;
end;</code></pre>
                                            <p>Enregistrez le projet, en l'appelant <span class="em">mysql02</span> et en l'enregistrant dans un nouveau répertoire du même nom.</p>
                                            <p>Compilez le programme et exécutez-le depuis l'EDI Lazarus. vous constatez qu'une fenêtre vierge apapraît et qu'immédiatement le dialogue <span class="em">InputQuery</span> vous demande le mot de passe :</p>
                                            <img src="../images/InputQuery_Lazarus_1.png" alt="">
                                            <p>Si vous tapez le mot de passe correct ("passmysqldvp", rappelez-vous), la fenêtre de l'application (qui ne contient rien de visible pour l'instant) reste ouverte; si vous cliquez sur <span class="em">Cancel</span>, l'application se ferme et si vous tapez exprès un mot de passe erroné, un message d'erreur apparaît :</p>
                                            <img src="../images/InputQuery_Lazarus_2.png" alt="">
                                            <p>Tien, mais ce n'est pas le message d'erreur que nous avons prévu dans la méthode <span class="em">FormActivate</span> ? En effet, mais si vous cliquez sur le bouton <span class="em">Continuer</span>, celui que nous avions prévu apparaît bien :</p>
                                            <img src="../images/InputQuery_Lazarus_3.png" alt="">
                                            <p>Pourquoi ? Tout simplement parce que le premier message d'erreur est renvoyé par le débogueur, qui lève le premier l'exception.</p>
                                            <p>Plutôt que d'exécuter le programme depuis l'EDI, utilisez l'exécutable qui a été créé dans le répertoire <span class="em">mysql02</span>.</p>
                                            <p>Exécutez-le et faites l'expérience d'entrer un mot de passe erroné : c'est bien le message d'erreur que nous avons prévu qui s'affiche, puisque l'exécution du programme n'est plus encadrée par le débogueur.</p>
                                            <ol>
                                                <li>
                                                    <h6>Affichage de l'erreur renvoyée par le système :</h6>
                                                    <p>Notre message d'erreur n'est pas très précis, car il apparaît identiquement si le mot de passe est erroné et si, par exemple, le serveur est inaccessible ou la base de données inexistante.</p>
                                                    <p>Pour pouvoir identifier plus précisément l'erreur qui s'est produite, il faut lever une exception descendante de <span class="em">EDatabaseError : ESQLDatabaseError</span>. Dans les propriétés de ce type d'exception se trouvent un code etdes messages propres à MySQL.</p>
                                                    <p class="em">Information : Une liste des erreurs possibles est consultable dans la <a href="https://dev.mysql.com/doc/refman/5.5/en/error-messages-server.html" target="_blank">référence de MySQL en ligne</a>.</p>
                                                    <p>Voici une version plus élaborée de notre méthode de login :</p>
<pre><code>procedure TMainForm.FormActivate(Sender: TObject);
(* Lecture du mot de passe et connexion à la base de données *)
var
    LPassword : String;
begin
    (* Données de la connexion *)
    MySQLConnection.HostName := '192.168.0.1';
    MySQLConnection.DatabaseName := 'location';
    MySQLConnection.UserName := 'mysqldvp';
    (* Lecture du mot de passe *)
    if InputQuery('Connexion à la base de données', 'Tapez votre mot de passe :', True, LPassword)
        then
            begin
                (* Connexion à la base de données *)
                MySQLConnection.Password := LPassword;
                try
                    MySQLConnection.Connected := True;
                    SQLTransaction1.Active := True;
                except
                    on e: ESQLDatabaseError do
                        begin   (* Erreur renvoyée par MySQL : fin de programme *)
                            MessageDlg('Erreur de connexion à la base de données :'#10#10#13 + IntToStr(e.ErrorCode) + ' : ' + e.Message + #10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Close;
                        end;
                    on e: EDatabaseError do
                        begin   (* Erreur de connexion : fin de programme *)
                            MessageDlg('Erreur de connexion à la base de données.'#10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Close;
                        end;
                end;
            end
        else   (* Pas de mot de passe : fin de programme *)
            Close;
end;</code></pre>
                                                    <p>Par exemple, si la base de données n'existe pas :</p>
                                                    <img src="../images/erreur_systeme_Lazarus.png" alt="">
                                                    <p>La gestion de l'exception <span class="em">EDatabaseError</span> suit celle de <span class="em">ESQLDatabaseError</span>. Le principe général est de gérer en cascade les exceptions de la plus spécialisée à la moins spécialisée : ainsi, si la connexion au serveur MySQL est possible, les erreurs MySQL seront traitées en priorité (<span class="em">ESQLDatabaseError</span>).</p>
                                                    <p>Remarque : Vous avez certainement aperçu que les messages d'erreur sont en anglais, la langue par défaut de Lazarus. Pour obtenir les messages en français, je vous renvoie au <a href="http://gilles-vasseur.developpez.com/tutoriels/lazarus-traduction/" target="_blank">tutoriel de Gilles Vasseur sur l'internationalisation d'une application</a>.</p>
                                                </li>
                                            </ol>
                                        </li>
                                        <li>
                                            <h5>Récupération de la liste des tables :</h5>
                                            <p>À présent, nous allons faire en sorte que l'utilisateur puisse choisir une des tables contenues dans la base de données pour en afficher le contenu.</p>
                                            <p>Sélectionnez un composant <span class="em">TListBox</span> dans l'onglet <span class="em">Standard</span> et déposez-le en bas et à gauche sur la fiche du projet. Dans l'inspecteur d'objets, renommez sa propriété <span class="em">Name</span> en <span class="em">lbTables</span>.</p>
                                            <p>Dans l'éditeur de source, allez dans la déclaration du type <span class="em">TMainForm</span> (que Lazarus a automatiquement déclaré ainsi lorsque vous avez appelé <span class="em">MainForm</span> votre fiche principale). Dans la section <span class="em">private</span>, ajoutez cette procédure :</p>
<pre><code>procedure ShowTables;</code></pre>
                                            <p>Pressez la combinaison de touches <span class="em">Shift + CTRL + C</span> pour que Lazarus crée la procédure dans la section <span class="em">implementation</span> et complétez cette dernière :</p>
<pre><code>procedure TMainForm.ShowTables;
begin
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SHOW TABLES;';
    SQLQuery1.Open;
    while not SQLQuery1.EOF do
        begin
            lbTables.Items.Add(SQLQuery1.Fields[0].AsString);
            SQLQuery1.Next;
        end;
    (* Sélection du premier élément *)
    if SQLQuery1.RecordCount &gt; 0
        then
            lbTables.ItemIndex := 0;
end;</code></pre>
                                            <p>Tout d'abord, la commande SQL qui permet de retourner la liste des tables d'une base de données est <span class="html">SHOW TABLES;</span>.</p>
                                            <p>Cette commande est passée au composant <span class="em">SQLQuery1</span> dans sa propriété <span class="em">SQL.Text</span> (comme nous avions fait dans notre premier exemple) et est exécutée dans la méthode <span class="em">Open</span>. Ensuite, nous bouclons pour que chaque nom de table retourné par la requête soit ajouté dans la listbox <span class="em">lbTables</span>.</p>
                                            <p>Placez l'appel de cette méthode privée <span class="em">ShowTables</span> dans le bloc <span class="em">try</span> de la méthode événementielle <span class="em">FormActivate</span> de la fiche principale :</p>
<pre><code>procedure TMainForm.FormActivate(Sender: TObject);
var
    LPassword : String;
begin
    { . . . }
    if InputQuery('Connexion à la base de données', 'Tapez votre mot de passe :', True, LPassword)
        then
            begin
                MySQLConnection.Password := LPassword;
                try
                    MySQLConnection.Connected := True;
                    SQLTransaction1.Active := True;
                    ShowTables;   // ***** AJOUT *****
                except
                    { . . . }
                end;
            end
        else   (* Pas de mot de passe : fin de programme *)
            Close;
end;</code></pre>
                                            <p>Vous pouvez faire un test d'exécution à ce stade, pour vérifier que la liste des tables est bien chargée dans la listbox :</p>
                                            <img src="../images/recuperation_liste_tables_Lazarus.png" alt="">
                                        </li>
                                        <li>
                                            <h5>Affichage du contenu de la table sélectionnée :</h5>
                                            <p>Comme dans le premier exemple, nous allons afficher le contenu d'une table dans un composant <span class="em">TDBGrid</span>, de l'onglet <span class="em">Data Controls</span>, que vous déposez en haut et à gauche de votre fiche principale, et dont vous agrandissez la largeur jusqu'à la limite droite de la fiche et la hauteur jusquà un peu au-dessus de la listbox.</p>
                                            <p>L'utilisation du DBGrid nous conduit à ajouter également un composant <span class="em">TDataSource</span>, de l'onglet <span class="em">Data Access</span> :</p>
                                            <img src="../images/contenu_table_Lazarus_1.png" alt="">
                                            <p>Toujours comme dans l'exemple 1, la propriété <span class="em">DataSet</span> du <span class="em">TDataSource</span> doit être affectée à <span class="em">SQLQuery1</span>, et la propriété <span class="em">DataSource</span> du <span class="em">TDBGrid</span> à <Span class="em">DataSource1</Span>.</p>
                                            <p>Dans l'inspecteur d'objets, sélectionnez la listbox <span class="em">lbTables</span>, allez dans l'onglet <span class="em">Événements</span>, trouvez l'élément <span class="em">OnSelectionChange</span> et cliquez sur les trois points en regard de celui-ci pour créer une méthode événementielle qui s'exécutera à chaque changement de choix de table :</p>
<pre><code>procedure TMainForm.lbTablesSelectionChange(Sender: TObject; User: boolean);
begin
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SELECT * FROM ' + lbTables.GetSelectedText + ';';
    SQLQuery1.Open;
end;</code></pre>
                                            <p>Simplement, la requête <span class="html">SELECT * FROM</span> est complétée par le nom de la table sélectionnée dans la listbox.</p>
                                            <p>Testez l'application en l'état :</p>
                                            <img src="../images/contenu_table_Lazarus_2.png" alt="">
                                            <p>Le fait de sélectionner une autre table charge automatiquement son contenu dans la DBGrid.</p>
                                            <p class="em">Remarque : Si vous êtes très attentif(ve), vous verrez très fugacement apparaître la liste des tales dans le DBGrid, juste avant que le contenu de la première table s'affiche. C'est dû au fait que le DBGrid, via le DataSource, affiche le contenu du dataset du SQLQuery. Pour éviter cette brève apparition, il aurait fallu ne pas lier le DBGrid au DataSource dans ses propriétés et ajouter cette instruction juste après l'exécution de <span class="html">ShowTables</span> (dans la méthode <span class="html">FormActivate</span>) : <span class="html">DbGrid1.DataSource := DataSource1;</span>.</p>
                                        </li>
                                        <li>
                                            <h5>Permettre de modifier les données :</h5>
                                            <p>Nous avons laissé un peu de place entre le bord supérieur de la listbox et le bord inférieur du DBGrid pour pouvoir y insérer une barre d'outils de navigation : un composant <span class="em">TDBNavigator</span> (que l'on trouve au début de l'onglet <span class="em">Data Controls</span>). Centrez-le ou donnez-lui la même largeur que le DBGrid :</p>
                                            <img src="../images/modifier_donnees_Lazarus.png" alt="">
                                            <p>Affectez <span class="em">DataSource1</span> à sa propriété <span class="em">DataSource</span>. Dans l'inspecteur d'objets, vous pouvez choisir quels boutons vous voulez afficher dans le DBNavigator, dans sa propriété <span class="em">VisibleButtons</span>. Décochez notamment le boutton <span class="em">nbRefresh</span>, qui n'a aucune utilité dans notre exemple.</p>
                                            <p>Exécutez à nouveau l'application et expérimentez la navigation avec les boutons verts, mais aussi l'insertion de lignes, la suppresion, etc. Vous pouvez y aller franchement et tout casser : les modifications que vous faites affectent juste le contenu du DBGrid, mais pas la base de données elle-même. D'ailleurs, si vous changez votre choix de table dans la listbox, vous voyez qu'à chaque réaffichage la table est restaurée dans son étét d'origine.</p>
                                            <p>La dernière étape va être d'enregistrer les modifications dans la base de données.</p>
                                            <p class="em">Attention, ne martyrisez pas trop la base de données dans les tests que vous ferez dorénavant, car nous en aurons encore besoin pour la suite.</p>
                                            <p>Nous allons donc écrire une méthode privée qui va s'occuper de mettre à jour les données des tables dans la base. Cette méthode sera appelée à chaque fois que l'on changera de table dans la listbox, ainsi qu'à la ferneture de l'application.</p>
                                            <p>Retournez dans l'éditeur de source et ajoutez cette méthode dans la section <span class="em">private</span> de <span class="em">TMainForm</span> :</p>
<pre><code>procedure CommitChanges;</code></pre>
                                            <p>Un petit <span class="em">Shift + CTRL + C</span> pour son implémentation :</p>
<pre><code>procedure TMainForm.CommitChanges;
begin
    if SQLTransaction1.Active
        then
            try
                SQLQuery1.ApplyUpdates;
                SQLTransaction1.Commit;
            except
                on e: EDatabaseError do
                    MessageDlg('Erreur d''enregistrement des modifications', mtError, [mbOk], 0);
            end;
end;</code></pre>
                                            <p>Appelons-la dans la méthode événementielle qui répond au changement de table dans la listbox :</p>
<pre><code>procedure TMainForm.lbTablesSectionChange(Sender: TObject; User: boolean);
begin
    CommitChanges;   // ***** AJOUT *****
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SELECT * FROM ' + lbTables.GetSelectedText + ';';
    SQLQuery1.Open;
end;</code></pre>
                                            <p>Et dans la méthode qui répond à la fermeture de la fiche principale :</p>
<pre><code>procedure TMainForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
begin
    CommitChanges;   // ***** AJOUT *****
    SQLQuery1.Close;
    if SQLTransaction1.Active
        then
            SQLTransaction1.Active := False;
    if MySQLConnection.Connected
        then
            MySQLConnection.Connected := False;
end;</code></pre>
                                            <p>Testez l'application ainsi modifiée (encore une fois, en y allant mollo pour garder utilisable la base de données). Inspectez le contenu de la base avec phpMyAdmin : vous constaterez que toutes les modifications y ont bien été répercutées.</p>
                                        </li>
                                        <li>
                                            <h5>Code complet de l'exemple 2 :</h5>
<pre><code>unit Main;

{$mode objfpc}{$H+}

interface

uses
    Classes, SysUtils, mysql56conn, sqldb, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls, Grids, DBGrids, DbCtrls, db;

type

    { TMainForm }

    TMainForm = class(TForm)
        DataSource1: TDataSource;
        DBGrid1: TDBGrid;
        DBNavigator1: TDBNavigator;
        lbTables: TListBox;
        MySQLConnection: TMySQL56Connection;
        SQLQuery1: TSQLQuery;
        SQLTransaction1: TSQLTransaction;
        procedure FormActivate(Sender: TObject);
        procedure FormClose(Sender: TObject; var CloseAction: TCloseAction);
        procedure lbTablesSelectionChange(Sender: TObject; User: boolean);
    private
        { private declarations }
        procedure ShowTables;
        procedure CommitChanges;
    public
        { public declarations }
    end;

var
    MainForm: TMainForm;

implementation

{$R *.lfm}

{ TMainForm }

procedure TMainForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
(* Fermeture propre de la connexion avant la fin de programme *)
begin
    (* Enregistrement des éventuelles modifications *)
    CommitChanges;
    (* Fermeture de la connexion *)
    SQLQuery1.Close;
    if SQLTransaction1.Active
        then
            SQLTransaction1.Active := False;
    if MySQLConnection.Connected
        then
            MySQLConnection.Connected := False;
end;

procedure TMainForm.lbTablesSelectionChange(Sender: TObject; User: boolean);
(* Sélection d'une table dans la listbox *)
begin
    (* Enregistrement des éventuelles modifications *)
    CommitChanges;
    (* Chargement des données de la table choisie *)
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SELECT * FROM ' + lbTables.GetSelectedText + ';';
    SQLQuery1.Open;
end;

procedure TMainForm.ShowTables;
(* Chargement de la liste des tables dans la listbox *)
begin
    SQLQuery1.Close;
    SQLQuery1.SQL.Text := 'SHOW TABLES;';
    SQLQuery1.Open;
    while not SQLQuery1.EOF do
        begin
            lbTables.Items.Add(SQLQuery1.Fields[0].AsString);
            SQLQuery1.Next;
        end;
    if SQLQuery1.RecordCount &gt; 0
        then
            lbTables.ItemIndex := 0;
end;

procedure TMainForm.CommitChanges;
(* Enregistrement des modifications *)
begin
    if SQLTransaction1.Active
        then
            try
                SQLQuery1.ApplyUpdates;
                SQLTransaction1.Commit;
            except
                on e: EDatabaseError do
                    begin
                        MessageDlg('Erreur d''enregistrement des modifications', mtError, [mbOk], 0);
                    end;
            end;
end;

procedure TMainForm.FormActivate(Sender: TObject);
(* Lecture du mot de passe et connexion à la base de données *)
var
    LPassword : String;
begin
    (* Données de la connexion *)
    MySQLConnection.HostName := '192.168.0.1';
    MySQLConnection.DatabaseName := 'location';
    MySQLConnection.UserName := 'mysqldvp';
    (* Lecture du mot de passe *)
    if InputQuery('Connexion à la base de données', 'Tapez votre mot de passe :', True, LPassword)
        then
            begin
                (* Connexion à la base de données *)
                MySQLConnection.Password := LPassword;
                try
                    MySQLConnection.Connected := True;
                    SQLTransaction1.Active := True;
                    ShowTables;
                except
                    on e: EDatabaseError do
                        begin   (* Erreur de connexion : fin de programme *)
                            MessageDlg('Erreur de connexion à la base de données.'#10#13'Le mot de passe est peut-être incorrect ?'#10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Close;
                        end;
                    end;
            end
            else   (* Pas de mot de passe : fin de programme *)
                Close;
end;

end.</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <h4>Exemple 3 : une application complète :</h4>
                                    <p>Nous pourrions déjà arrêter là : vous avez découvert les composants natifs de Lazarus permettant de créer des applications utilisant une base de données et vous pourrez sans trop de difficultés appliquer les principes vus pour MySQL à d'autres systèmes de bases de données. Mais nous allons essayer d'aller un peu plus loin, en découvrant d'autres contrôles spécialisés, en voyant comment modifier les données dans des contrôles classiques (non spécialisés dans les bases de données), et comment regrouper le traitement des données dans une unité d'un type un peu particulier : un <span class="em">DataModule</span>. Nous parlerons également de l'intérêt de centraliser la génération des requêtes SQL dans une <span class="em">interface</span>.</p>
                                    <ol>
                                        <li>
                                            <h5>Création du projet :</h5>
                                            <p>Commençons par le commencement :</p>
                                            <ul>
                                                <li>
                                                    <p>créez un nouveau projet de type <span class="em">Application</span>;</p>
                                                </li>
                                                <li>
                                                    <p>renommez l'unité <span class="em">Unit1</span> en <span class="em">Main</span>;</p>
                                                </li>
                                                <li>
                                                    <p>renommez la fiche principale en <span class="em">MainForm</span> (qui devient automatiquement de type <span class="em">TMainForm</span>);</p>
                                                </li>
                                                <li>
                                                    <p>changez sa propriété <span class="em">Caption</span> (son titre) en, par exemple, "Location de voitures";</p>
                                                </li>
                                                <li>
                                                    <p>enregistrez le projet sous le nom <span class="em">mysql03</span>, dans un nouveau répertoire du même nom.</p>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <h5>Unité de type DataModule :</h5>
                                            <p>Les deux premiers exemples étaient de minuscules applications, qui ne sont pas très difficiles à comprendre, ni à déboguer, pour un développeir qui les découvre. Lorsque l'on crée des applications de plus grande ampleur, ces aspects (comprendre et déboguer) prennent toute leur importance et il faut que vous aussi vous vous y retrouviez facilement si vous devez en assurer la maintenance dans le futur.</p>
                                            <p>Nous allons faire en sorte que tout le traitement en rapport avec la base de données soit regroupé à part, et Lazarus possède un type particulier d'unité adapté à cela : le <span class="em">DataModule</span>. Ce type d'unité est l'endroit idéal pour déposer des composants invisibles, comme ceux que nous avons utilisés précédemment, mais ce n'est pas limitatif.</p>
                                            <p class="em">Attention, ce manière de faire pourrait aussi faciliter la migration d'une application vers un autre système de gestion de base de données.</p>
                                            <p>Allez dans le menu <span class="em">Fichier</span>, <span class="em">Nouveau</span>, <span class="em">Module de données</span> et cliquez sur <span class="em">OK</span> pour ajouter une unité DataModule :</p>
                                            <img src="../images/DataModule_Lazarus_1.png" alt="">
                                            <p>La nouvelle unité créée présente une fiche similaire à une fiche normale de type <span class="em">TForm</span>. Renommez tout de suite l'unité en <span class="em">DataAccess</span>.</p>
                                            <p>Depuis l'onglet de composants <span class="em">SQLdb</span>, déposez sur la fiche un composant <span class="em">TMySQLxxConnection</span> correspondant à votre version, et un composant <span class="em">TSQLTransaction</span>. Renommez-les respectivement <span class="em">SQLConnection</span> et <span class="em">SQLTransaction</span>, et assignez <span class="em">SQLConnection</span> à la propriété <span class="em">Database</span> de <span class="em">SQLTransaction</span>. N'oubliez pas d'inscrire <span class="em">UTF8</span> dans la propriété <span class="em">CharSet</span> de <span class="em">SQLConnection</span>.</p>
                                            <p>Allez dans le menu <span class="em">Projet</span>, <span class="em">Options du projet</span> et cliquez sur l'entrée <span class="em">Fiches</span>. Vous constatez que la fiche principale et le datamodule sont automatiquement créés au démarrage de l'application. C'est très bien ainsi, hormis qu'ils ne sont pas créés dans le bon ordre : vous comprendrez très bite pourquoi le datamodule doit être créé avant la fiche principale. Mettez <span class="em">DataModule1</span> en surbillance et faites-le monter en tête de liste à l'aide de la petite flèche verte à gauche. Tant que vous y êtes, décochez la case <span class="em">Créer automatiquement les nouvelles fiches</span> au bas du dialogue : nous n'aurons pas besoin que toutes les autres fiches de l'application soient créées au démarrage.</p>
                                            <img src="../images/DataModule_Lazarus_2.png" alt="">
                                            <p>Cliquez sur <span class="em">OK</span>. Ouvez l'inspecteur de projet, par le biais du menu <span class="Em">Projet</span>, <span class="em">Inspecteur de projet</span> :</p>
                                            <img src="../images/DataModule_Lazarus_3.png" alt="">
                                            <p>Le projet est pour l'instant composé d'un programme principal, <span class="em">mysql03.lpr</span>, et de deux unités, <span class="em">main.pas</span> et <span class="em">dataaccess.pas</span>. Double-cliquez sur le programme principal : dans son code source, vous voyez que le datamodule est bien créé avant la fiche principale :</p>
<pre><code>program mysql03;

{$mode objfpc}{$H+}

uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
    cthreads,
    {$ENDIF}{$ENDIF}
    Interfaces, // this includes the LCL widgetset
    Forms,
    DataAccess,
    Main
        { you can add units after this };
{$R *.res}
begin
    RequireDerivedFormResource:=True;
    Application.Initialize;
    Application.CreateForm(TDataModule1, DataModule1);
    Application.CreateForm(TMainForm, MainForm);
    Application.Run;
end.</code></pre>
                                            <p>Nous avons mentionné, au début de cet exemple, que l'utilisation du datamodule pourrait faciliter la migration de notre application vers un autre système de gestion de base de données, comme SQLite ou PostgreSQL. Alors nous allons jouer le jeu et y regrouper <span class="em">tout ce qui est propre à MySQL</span>.</p>
                                            <p>Nous allons d'abord y inclure les méthodes de connexion (avec la demande de mot de passe) et de déconnexion que nous avions développées dans l'exemple 2.</p>
                                            <p>Cliquez sur l'onglet du code source de l'unité <span class="em">DataAccess</span> et ajoutez, dans la section <span class="em">public</span> de la classe <span class="em">TDataModule1</span>, ces deux méthodes :</p>
<pre><code>function Login : Boolean;
procedure Logoff;</code></pre>
                                            <p>Pressez la combinaison de touches <span class="em">Shift + CTRL + C</span>, afin que Lazarus crée les deux méthodes dans la section <span class="em">implementation</span>.</p>
                                            <p>Recopiez dans la méthode <span class="em">Login</span> le code de connexion contenu dans la méthode <span class="em">FormActivate</span> de l'exemple 2, et dans la méthode <span class="em">Logoff</span> le contenu de la méthode <span class="em">FormClose</span>.</p>
<pre><code>function TDataModule1.Login: Boolean;
(* Demande du mot de passe et connexion à la base de données *)
var
    LPassword : String;
begin
    Result := True;
    SQLConnection.HostName := '192.168.0.1';
    SQLConnection.DatabaseName := 'location';
    SQLConnection.UserName := 'mysqldvp';
    if InputQuery('Connexion à la base de données', 'Tapez votre mot de passe :', True, LPassword)
        then
            begin
                SQLConnection.Password := LPassword;
                try
                    SQLConnection.Connected := True;
                    SQLTransaction.Active := True;
                except
                    on e : ESQLDatabaseError do
                        begin   (* Erreur renvoyée par MySQL : fin de programme *)
                            MessageDlg('Erreur de connexion à la base de données :'#10#10#13 + IntToStr(e.ErrorCode) + ' : ' + e.Message + #10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Result := False;;
                        end;
                    on e : EDatabaseError do
                        begin   (* Erreur de connexion : fin de programme *)
                            MessageDlg('Erreur de connexion à la base de données.'#10#10#13'Fin de programme.', mtError, [mbOk], 0);
                            Result := False;;
                        end;
                end;
            end
        else
            Result := False;
end;

procedure TDataModule1.Logoff;
(* Déconnexion de la base de données *)
begin
    if SQLTransaction.Active
        then
            SQLTransaction.Active := False;
    if SQLConnection.Connected
        then
            SQLConnection.Connected := False;
end;</code></pre>
                                            <p>Pour que le compilateur trouve la fonction <span class="em">InputQuery</span>, ajoutez l'unité <span class="em">Dialogs</span> à la clause <span class="em">uses</span> du datamodule, et ajoutez l'unité <span class="em">db</span> pour le type <span class="em">EDatabaseError</span>.</p>
                                            <p>Retournez dans l'unité <span class="em">Main</span> et pressez <span class="em">F12</span> pour afficher la fiche principale. Dans l'inspecteur d'objets, dans l'onglet <span class="em">Événements</span>, descendez sur l'événement <span class="em">OnShow</span> et cliquez sur les trois points correspondants. Cela va créer la méthode <span class="em">TMainForm.FormShow</span> dans la section implémentation. C'est à cet endroit que nous allons appeler la méthode de login que nous avons implémentée dans le datamodule :</p>
<pre><code>procedure TMainForm.FormShow(Sender: TObject);
(* Demande de mot de passe *)
begin
if DataModule1.Login
    then
        begin
            ShowMessage('Login couronné de succès !');
        end
    else
        Close;
end;</code></pre>
                                            <p>Faites la même chose avec l'événement <span class="em">OnClose</span> :</p>
<pre><code>procedure TMainForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
(* Fermeture propre de la connexion à la base de données *)
begin
    DataModule1.Logoff;
end;</code></pre>
                                            <p>Il ne faut pas oublier d'ajouter l'unité <span class="em">DataAccess</span> à la clause <span class="em">uses</span> de l'unité <span class="em">Main</span>, sinon le compilateur dira qu'il ne connaît ni <span class="em">Login</span> ni <span class="em">Logoff</span>.</p>
                                            <p>Vous pouvez compiler et exécuter votre application à ce stade, pour vérifier que la connexion est bien couronnée de succès.</p>
                                            <p>Bon, il est temps de définir à quoi va ressembler et ce que va faire notre application de gestion de location de voitures.</p>
                                            <p>Nous aurons une fenêtre principale, qui va contenir la liste des locations :</p>
                                            <img src="../images/DataModule_Lazarus_4.png" alt="">
                                            <p>Un dialogue permettra de gérer la liste des voitures disponibles :</p>
                                            <img src="../images/DataModule_Lazarus_5.png" alt="">
                                            <p>Un autre, similaire, sera consacré à la liste des clients :</p>
                                            <img src="../images/DataModule_Lazarus_6.png" alt="">
                                            <p>Dans un dialogue, on pourra créer une nouvelle location :</p>
                                            <img src="../images/DataModule_Lazarus_7.png" alt="">
                                            <p>Ce dialogue servira également à modifier une location existante.</p>
                                            <p>Pour terminer, nous sortirons une facture à l'aide d'un générateur de rapports.</p>
                                            <p>Nous avons du pain sur la planche ! Créons tout de suite le dialogue de gestion des voitures.</p>
                                        </li>
                                        <li>
                                            <h5>Utilisation des composants spécialisés :</h5>
                                            <p>Dans les deux premiers exemples, vous avez déjà découvert les composants <span class="em">TDBGrid</span> et <span class="em">TDBNavigator</span>. Nous allons encore nous en servir, mais nous allons aussi utiliser d'autres composants spécialisés comme <span class="em">TDBEdit</span> et <span class="em">TDBRadioGroup</span>. Si vous parcourez l'onglet <span class="em">Data Controls</span> de la palette, vous trouvez toute une panoplie de composants : mémo, liste déroulante, etc. Avec ceux que nous allons voir ici, vous devriez être à même de les utiliser tous par la suite.</p>
                                            <p>L'utilisation de tous ces composants spécialisés impose de mettre en service, comme dans les deux premiers exemples, un <span class="em">TSQLQuery</span> et un <span class="em">TDataSource</span>. Et à quel endroit allons-nous les placer ? Dans le datamodule, bien sûr !</p>
                                            <p class="em">Attentions, nous assignerons un <span class="html">TSQLQuery</span> et, éventuellement, un <span class="html">TDataSource</span> à chaque table de la base de données.</p>
                                            <p>Cliquez sur l'onglet du code source de l'unité <span class="em">DataAccess</span> puis pressez <span class="em">F12</span>. Sur la fiche <span class="em">DataModule1</span>, déposez donc un exemplaire de chacun de ces deux composants (le <Span class="em">TSQLQuery</Span> depuis l'onglet <span class="em">SQLdb</span> et le <span class="em">TDataSource</span> depuis l'onglet <span class="em">DataAccess</span>). Renommez-les respectivement <span class="em">SQLQueryVoitures</span> et <span class="em">DataSourceVoitures</span>. La propriété <span class="em">Database</span> du premier doit être initialisée à <span class="em">SQLConnection</span> et la propriété <span class="em">DataSet</span> du second à <span class="em">SLQueryVoitures</span>.</p>
                                            <p>Tant que nous sommes dans l'inspecteur d'objets, nous allons définir les différents champs de la table <span class="em">Voitures</span> dans les propriétés de <span class="Em">SQLQueryVoitures</span>. Repérez la propriété <span class="em">FieldDefs</span> et cliquez sur les trois points en regard. Un dialogue va s'ouvrir, dans lequel vous allez ajouter successivement les champs en cliquant sur le bouton "+" :</p>
                                            <img src="../images/utilisation_composants_specialises_Lazarus.png" alt="">
                                            <p>Pour chaque champ, vous allez définir dans l'inspecteur d'objets les propriétés <span class="em">Name</span>, <span class="em">DataType</span> et, éventuellement, <span class="em">Size</span>. Voici la liste de ces propriétés :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th>Name</th>
                                                        <th>DataType</th>
                                                        <th>Size</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>Plaque</td>
                                                        <td>ftString</td>
                                                        <td>12</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Marque</td>
                                                        <td>ftString</td>
                                                        <td>20</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Modele</td>
                                                        <td>ftString</td>
                                                        <td>20</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Cylindree</td>
                                                        <td>ftInteger</td>
                                                        <td>0</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Transmission</td>
                                                        <td>ftFixedChar</td>
                                                        <td>1</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Prix</td>
                                                        <td>ftFloat</td>
                                                        <td>0</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>Créons à présent une nouvelle fiche, à l'aide du second bouton de la barre d'outils. Concomitamment, une nouvelle unité est créée : renommez-la <span class="em">Voitures</span> et enregistrez-la sous le nom <span class="em">voitures.pas</span>. Dans l'explorateur d'objets, changez la propriété <span class="em">Name</span> de la fiche en <span class="em">CarForm</span> et indiquez son titre (par exemple, "Liste des voitures") dans la propriété <span class="em">Caption</span>.</p>
                                            <p>Cliquez sur l'onglet de composants <span class="Em">Data Controls</span> de la palette. Depuis cet onglet, déposez sur la fiche les composants énumérés ci-après.</p>
                                            <p class="em">Attention, ne faites pas trop vite le lien entre les composants que vous allez déposer et le <span class="html">TDataSource</span> : si vous le faites, Lazarus vous bloquera lorsque vous voudrez assigner aux contrôles les champs de la table <span class="em">Voitures</span>.Donc définissez d'abord toutes les autres propriétés de vos contrôles et finissez par leur propriété <span class="em">DataSource</span>.</p>
                                            <ol>
                                                <li>
                                                    <h6>TDBGrid :</h6>
                                                    <p>Nommez-le <span class="em">dbgVoitures</span> dans sa propriété <span class="em">Name</span> et dimensionnez-le à 424 pixels de largeur (<span class="em">Width</span>) sur 240 pixels de hauteur (<span class="em">Height</span>). La propriété <span class="em">Scrollbars</span> peut être fixée à <span class="em">ssAutoVertical</span>.</p>
                                                    <p>Cliquez sur les trois points en regard de la propriété <span class="em">Columns</span> : un assistant va vous aider à créer les différentes colonnes du DBGrid. Cliquez chaque fois sur le bouton "+" pour ajouter une colonne et éditez les propriétés de celle-ci dans l'inspecteur d'objets.</p>
                                                    <img src="../images/TDBGrid_Lazarus_1.png" alt="">
                                                    <p>Tous les titres (propriété <span class="em">Title/Alignment</span>) étant centrés (<span class="em">taCenter</span>), voici les propriétés des différentes colonnes à ajouter :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>FieldName</th>
                                                                <th>Caption</th>
                                                                <th>Width + MaxSize</th>
                                                                <th>Alignment</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>Plaque</td>
                                                                <td>Plaque</td>
                                                                <td>79</td>
                                                                <td>taCenter</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Marque</td>
                                                                <td>Marque</td>
                                                                <td>80</td>
                                                                <td>taLeftJustify</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Modele</td>
                                                                <td>Modèle</td>
                                                                <td>110</td>
                                                                <td>taLeftJustify</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Cylindree</td>
                                                                <td>Cyl.</td>
                                                                <td>45</td>
                                                                <td>taCenter</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Transmission</td>
                                                                <td>Trans.</td>
                                                                <td>45</td>
                                                                <td>taCenter</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Prix</td>
                                                                <td>€/jour</td>
                                                                <td>45</td>
                                                                <td>taCenter</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Pour terminer les réglages, il faut modifier les propriétés suivantes :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Propriété</th>
                                                                <th>Valeur</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>Options/dgIndicator</td>
                                                                <td>False</td>
                                                            </tr>
                                                            <tr>
                                                                <td>FixedCols</td>
                                                                <td>0</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Comme nous l'avons mentionné juste avant de commencer le dépôt des composants sur la fiche, nous terminons par la propriété <span class="em">DataSource</span> du DBGrid, que nous assignons à <span class="em">DataModule1.DataSourceVoitures</span>.</p>
                                                    <p class="em">Remarque : Nous pourrions penser que le fait de faire un lien entre un composant de la fiche et un datasource qui se trouve dans un datamodule entraînerait de la part de Lazarus la déclaration de ce datamodule dans la clause <span class="em">uses</span> de l'unité de la fiche. Il n'en est rien : c'est à nous de le faire. Ajoutez donc l'unité <span class="em">DataAccess</span> à la clause <span class="em">uses</span> de l'unité <span class="em">Voitures</span>.</p>
                                                </li>
                                                <li>
                                                    <h6>TDBNavigator :</h6>
                                                    <p>Nous restons pour l'instant en terrain connu, car nous allons déposer sur la fiche un composant <span class="em">TDBNavigator</span>. C'est lui qui s'occupera de la navigation dans la table et de toutes les modifications de données.</p>
                                                    <p>Déposez-le à droite du DBGrid, nommez-le <span class="em">dbnVoitures</span> (propriété <span class="em">Name</span>), changez sa propriété <span class="em">Direction</span> à <span class="em">nbdVertical</span> (pour qu'il s'affiche verticalement), réglez sa largeur et sa hauteur pour qu'il vienne se coller le long de la bordure de droite du DBGrid :</p>
                                                    <img src="../images/TDBNavigator_Lazarus.png" alt="">
                                                    <p>Fixez enfin sa propriété <span class="em">DataSource</span> à <span class="em">DataModule1.DataSourceVoitures</span>.</p>
                                                </li>
                                                <li>
                                                    <h6>TDBEdit :</h6>
                                                    <p>Nous allons à présent ("enfin", direz-vous peu-être) découvrir un nouveau composant spécialisé : le <span class="em">TDBEdit</span>. Il s'agit, comme son nom l'indique, d'un champ d'édition qui sera lié à un champ d'une table de base de données. Nous allons en déposer plusieurs, en dessous du DBGrid, acoompagnés de classiques <span class="em">TLabels</span> (de l'onglet <span class="em">Standard</span>) :</p>
                                                    <img src="../images/TDBEdit_Lazarus.png" alt="">
                                                    <p>Leurs propriétés respectives <span class="em">Name</span> et <span class="em">Caption</span> (pour les <span class="em">TLabel</span>) seront fixées comme suit :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Name (TLabel)</th>
                                                                <th>Caption (TLabel)</th>
                                                                <th>Name (TDBEdit)</th>
                                                                <th>DataField (TDBEdit)</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>lblPlaque</td>
                                                                <td>&amp;Plaque</td>
                                                                <td>dbePlaque</td>
                                                                <td>Plaque</td>
                                                            </tr>
                                                            <tr>
                                                                <td>lblMarque</td>
                                                                <td>Mar&amp;que</td>
                                                                <td>dbeMarque</td>
                                                                <td>Marque</td>
                                                            </tr>
                                                            <tr>
                                                                <td>lblModele</td>
                                                                <td>Mo&amp;dèle</td>
                                                                <td>dbeModele</td>
                                                                <td>Modele</td>
                                                            </tr>
                                                            <tr>
                                                                <td>lblCylindree</td>
                                                                <td>&amp;Cylindrée</td>
                                                                <td>dbeCylindree</td>
                                                                <td>Cylindree</td>
                                                            </tr>
                                                            <tr>
                                                                <td>lblPrix</td>
                                                                <td>€/&amp;jour</td>
                                                                <td>dbePrix</td>
                                                                <td>Prix</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Élargissez les deux <span class="em">TDBEdit</span> correspondant à la marque et modèle de voiture, pour laisser suffisamment de place au texte qui s'y placera.</p>
                                                    <p>Sélectionnez les cinq <span class="em">TDBEdit</span>, en pressant la touche <span class="em">Shift</span> tout en cliquant sur les compsants, et assignez d'un seul coup <span class="em">DataModule1.DataSourceVoitures</span> à leur propriété <span class="em">DataSource</span>.</p>
                                                </li>
                                                <li>
                                                    <h6>TDBRadioGroup :</h6>
                                                    <p>Le champ <span class="em">Transmission</span> de la table <span class="dm">Voitures</span> indique si la voiture est équi^ée d'une transmission automatique ou manuelle; ce champ est destiné à recevoir la valeur "A" ou "M". Très naturellement, nous allons confier cette alternative à deux boutons radio, au sein d'un composant <span class="em">TDBRadioGroup</span>.</p>
                                                    <p>Depuis l'onglet <span class="em">Data Controls</span> (toujours le même), déposez à droite, en dessous du DBGrid, un composant <span class="em">TDBRadioGroup</span>, que vous renommez directement <span class="em">dbrgTransmission</span>. Sa propriété <span class="em">Caption</span> devient "Transmission" et sa taille 90 (<span class="em">Width</span>) par 73 (<span class="em">Height</span>). Fort logiquement, vous assignerez à la propriété <span class="em">DataField</span> le nom de champ <span class="em">Transmission</span>.</p>
                                                    <p>Dans l'inspecteur d'objets, cliquez sur les trois points qui correspondent à la propriété <span class="Em">Items</span> du composant : un assistant va vous permettre d'énumérer les options qui seront proposées dans le groupe de boutons radio. Ce ne sera pas très long, puisque les valeurs possibles sont "A" et "M" :</p>
                                                    <img src="../images/TDBRadioGroup_Lazarus.png" alt="">
                                                    <p>Nous terminons, comme chaque fois, par la propriété <span class="em">DataSource</span> du composant, qui est initialisée elle aussi à <span class="em">DataModule1.DataSourceVoitures</span>.</p>
                                                </li>
                                                <li>
                                                    <h6>Finalisation de la fiche :</h6>
                                                    <p>Nous avons terminé le dépôt de tous les composants spécialisés sur la fiche. Nous allons la finaliser et la tester.</p>
                                                    <p>Il reste de place, en bas et à droite de la fiche, pour ajouter deux boutons classiques : le premier, que nous renommerons en <span class="em">btnEnregistrer</span> et dont nous initialiserons la propriété <span class="em">Caption</span> à "&amp;Enregistrer", et le second, que nous appellerons <span class="em">btnAnnuler</span> et dont la propriété <span class="em">Caption</span> sera "A&amp;nnuler". Réglez la taille de la fiche pour obtenir quelque chose de joli :</p>
                                                    <img src="../images/finalisation_fiche_Lazarus.png" alt="">
                                                    <p>Le but de notre fiche sera de permettre à l'utilisateur de modifier le contenu de la table <span class="em">Voitures</span> de la base de données. Dès que notre dialogue s'affichera, toutes les voitures devront être chargées dans le DBGrid. Vous connaissez à présent la requête SQL qui permet de le faire :</p>
    <pre><code>SELECT * FROM Voitures;</code></pre>
                                                    <p>Mais ! Rappelez-vous, nous avons pris le parti, dans cette application, de regrouper toute l'interface avec la base de données dans le datamodule. Nous n'allons donc pas implémenter notre requête dans le code de notre fiche, mais bien dans celui du datamodule.</p>
                                                    <p>Dans l'inspecteur d'objets, sélectionnez la fiche <span class="em">CarForm</span> elle-même, cliquez sur l'onglet <span class="em">Événements</span>, puis sur les trois points en regard de l'événement <span class="em">OnShow</span>. Complétez la méthode créée par Lazarus comme ceci :</p>
    <pre><code>procedure TCarForm.FormShow(Sender: TObject);
    (* Chargement de la liste des voitures *)
    begin
        DataModule1.ChargementVoitures;
    end;</code></pre>
                                                    <p>Nous confions donc le chargement de la table à une méthode <span class="em">ChargementVoitures</span>, que nous n'avons pas encore écrite dans le datamodule. Nous le ferons juste après.</p>
                                                    <p>Les deux boutons que nous avons ajoutés en dernier vont permettre à l'utilisateur d'enregistrer les modifications, ou bien de quitter le dialogue sans les enregistrer. Nous allons créer une propriété <span class="em">Enregistre</span> (nous aimerions écrire "Enregistré" mais les caractères accentués ne sont pas - pas encore ? - autorisés dans la syntaxe du Pascal) pour notre fiche, de type booléen, qui va permettre de savoir si les données ont bien été enregistrées au moment de fermer le dialogue.</p>
                                                    <p>Créez un champ <span class="em">FEnregistre</span> dans la section <span class="em">strict private</span> de la fiche, ainsi que la propriété dont nous venons de parler et son setter :</p>
    <pre><code>type
    
        { TCarForm }
    
        TCarForm = class(TForm)
            btnEnregistrer: TButton;
            btnAnnuler: TButton;
            dbePlaque: TDBEdit;
            dbeMarque: TDBEdit;
            dbeModele: TDBEdit;
            dbeCylindree: TDBEdit;
            dbePrix: TDBEdit;
            dbgVoitures: TDBGrid;
            DBNavigator1: TDBNavigator;
            dbrgTransmission: TDBRadioGroup;
            lblPlaque: TLabel;
            lblMarque: TLabel;
            lblModele: TLabel;
            lblCylindree: TLabel;
            lblPrix: TLabel;
            procedure FormShow(Sender: TObject);
            // DÉBUT DE L'AJOUT
        strict private
            FEnregistre : Boolean;
        private
            procedure SetEnregistre (AValue : Boolean);
        public
            property Enregistre : Boolean read FEnregistre write SetEnregistre;
            // FIN DE L'AJOUT
        end;</code></pre>
                                                    <p>N'oublions pas d'initialiser cette propriété à <span class="em">False</span> dès l'affichage du dialogue :</p>
    <pre><code>procedure TCarForm.FormShow(Sender: TObject);
    (* Chargement de la liste des voitures *)
    begin
        // AJOUT :
        Enregistre := False;
        // FIN AJOUT
        DataModule1.ChargementVoitures;
    end;</code></pre>
                                                    <p>Voici le code du setter :</p>
    <pre><code>procedure TCarForm.SetEnregistre (AValue : Boolean);
    (* Setter de la propriété Enregistre *)
    begin
        if FEnregistre = AValue
            then
                Exit;
        FEnregistre := AValue;
    end;</code></pre>
                                                    <p>Faisons en sorte que l'utilisateur reçoive un message de confirmation, s'il veut fermer le dialogue sans que les données soient enregistrées. Cela se fera en réponse à l'événement <span class="em">OnCloseQuery</span> (cliquez sur les trois points en regard de cet événement, dans l'inspecteur d'objets) :</p>
    <pre><code>procedure TCarForm.FormCloseQuery (Sender : TObject; var CanClose : Boolean);
    (* Demande éventuelle de confirmation de fermeture sans enregistrer *)
    begin
        if Enregistre
            then
                CanClose := True
            else
                CanClose := (MessageDlg('Voulez-vous fermer sans enregistrer ?', mtConfirmation, [mbYes, mbNo], 0) = mrYes);
    end;</code></pre>
                                                    <p>Il nous reste juste à implémenter les méthodes qui vont réagir à un clic sur les boutons "Enregistrer" et "Annuler". Cliquez successivement sur les trois points qui correspondent à l'événement <span class="em">OnClick</span> des deux boutons, et complétez les méthodes comme ceci :</p>
    <pre><code>procedure TCarForm.btnEnregistrerClick(Sender: TObject);
    (* Enregistre les modifications dans la base de données *)
    begin
        Enregistre := DataModule1.SauvegardeVoitures;
        Close;
    end;
    
    procedure TCarForm.btnAnnulerClick(Sender: TObject);
    (* Ferme la fenêtre sans enregistrer *)
    begin
        Close;
    end;</code></pre>
                                                    <p>Vous le voyez, nous allons également tout de suite devoir écrire une méthode <span class="em">SauvegardeVoitures</span> dans le datamodule.</p>
                                                </li>
                                                <li>
                                                    <h6>Méthodes de chargement et de sauvegarde des onnées dans le datamodule :</h6>
                                                    <p>Allons-y, dans notre datamodule, et créons-y les deux méthodes publiques dont nous avons besoin. Il nous faudra une troisième méthode privée, que nous appelerons <span class="em">Commit</span>, qui sera chargée d'enregistrer toutes les modifications définitivement dans la base de données.</p>
    <pre><code>type
        { TDataModule1 }
        TDataModule1 = class(TDataModule)
          DataSourceVoitures: TDataSource;
          SQLConnection: TMySQL56Connection;
          SQLQueryVoitures: TSQLQuery;
          SQLTransaction: TSQLTransaction;
        private
          // AJOUT :
          function Commit : Boolean;
          // FIN AJOUT
        public
          function Login : Boolean;
          procedure Logoff;
          // AJOUT :
          procedure ChargementVoitures;
          function SauvegardeVoitures : Boolean;
          // FIN AJOUT
        end;</code></pre>
                                                    <p>Après un <span class="em">Shift + CTRL + C</span>, voici le code à implémenter :</p>
    <pre><code>function TDataModule1.Commit: Boolean;
    (* Sauvegarde des changements dans la base de données *)
    begin
        Result := True;
        if SQLTransaction.Active
            then
                try
                    SQLTransaction.Commit;
                except
                    on e: ESQLDatabaseError do
                        begin   (* Erreur renvoyée par MySQL *)
                        MessageDlg('Erreur n° ' +
                                    IntToStr(e.ErrorCode) + ' : ' + e.Message,
                                    mtError, [mbOk], 0);
                        Result := False;
                        end;
                    on e: EDatabaseError do
                    begin   (* Erreur générale *)
                        MessageDlg('Erreur de sauvegarde des données', mtError, [mbOk], 0);
                        Result := False;
                    end;
                end
            else
                Result := False;
    end;
    
    procedure TDataModule1.ChargementVoitures;
    (* Chargement des voitures *)
    begin
        with SQLQueryVoitures do
            begin
                Close;
                SQL.Text := 'SELECT * FROM Voitures;';
                Open;
            end;
    end;
    
    function TDataModule1.SauvegardeVoitures: Boolean;
    (* Sauvegarde de la table Voitures *)
    begin
        SQLQueryVoitures.ApplyUpdates;
        Result := Commit;
    end;</code></pre>
                                                    <p>Il n'y a rien de nouveau, à ce niveau, par rapport aux deux premiers exemples.</p>
                                                </li>
                                                <li>
                                                    <h6>Test de la fiche :</h6>
                                                    <p>Vous êtes sans doute tout excité(e) à l'idée de tester le dialogue de modification des voitures que vous avez créé.</p>
                                                    <p>Retournez dans l'unité de la fiche principale. On pourrait trouver mille et un événements pour afficher le dialogue (un bouton sur la fiche principale, une réponse à un clic de souris sur la fenêtre, etc.). J'ai opté pour un menu.</p>
                                                    <p>Dans l'onglet <span class="em">Standard</span>, choisissez un <span class="em">TMainMenu</span> et déposez-le sur la fiche. Renommez-le éventuellement <span class="em">MainMenu</span> (propriété <span class="em">Name</span>). Cliquez sur les trois points à droite de sa propriété <span class="em">Items</span>, pour ouvrir l'assistant de conception.</p>
                                                    <p>Un seul item est présent dans l'éditeur de menu. Dans l'inspecteur d'objets, changez sa propriété <span class="em">Name</span> en <span class="em">mnuFichier</span> et sa propriété <span class="em">Caption</span> en "&amp;Fichier". Faites un clic droit sur l'item dans l'assistant, puis choisissez <span class="em">Créer un sous-menu</span>. Cliquez sur le nouvel item créé et, dans l'inspecteur d'objets renommez-le <span class="em">mnuFichierVoitures</span>, avec comme caption "Gérer les &amp;voitures".</p>
                                                    <img src="../images/test_fiche_Lazarus.png" alt="">
                                                    <p>Une fois que c'est fait, fermez l'assistant. Dans l'inspecteur d'objets, sélectionnez le tout dernier item qui vient d'être céé; dans l'onglet <span class="em">Événements</span>, cliquez sur les trois points à droite de l'événement <span class="em">OnClick</span> et complétez la nouvelle créée.</p>
    <pre><code>procedure TMainForm.mnuFichierVoituresClick(Sender: TObject);
    (* Gestion de la liste des voitures *)
    var
        LCarForm : TCarForm;    (* Dialogue de gestion des voitures *)
    begin
        LCarForm := TCarForm.Create(Self);
        try
            LCarForm.ShowModal;
        finally
            FreeAndNil(LCarForm);
        end;
    end;</code></pre>
                                                    <p>N'oubliez pas d'ajouter l'unité <span class="em">Voitures</span> à la clause <span class="em">uses</span> de l'unité <span class="em">Main</span>.</p>
                                                    <p>Cette fois, nous sommes prêts : compilez et exécutez l'application.</p>
                                                    <p>Entrez le mot de passe dans le premier dialogue :</p>
                                                    <img src="../images/test_fiche_Lazarus_1.png" alt="">
                                                    <p>Le petit message nous informe que la connexion à la base de données est couronnée de succès :</p>
                                                    <img src="../images/test_fiche_Lazarus_2.png" alt="">
                                                    <p>La fenêtre principale est bien vide pour l'instant (nous allons rapidement la remplir), juste le menu principal :</p>
                                                    <img src="../images/test_fiche_Lazarus_3.png" alt="">
                                                    <p>Dans le menu <span class="em">Fichier</span>, vous choisissez l'item <span class="em">Gérer les voitures</span>. La fiche que nous voulons tester apparaît :</p>
                                                    <img src="../images/test_fiche_Lazarus_4.png" alt="">
                                                    <p>Parcourez le DBGrid et voyez comme tous les contrôles que nous avons déposés sur la fiche se mettent à jour automatiquement. Faites l'expérience d'en modifier un, cliquez sur la petite coche ("Post") du DBNavigator et voyez comment le champ se met à jour dans le DBGrid. Faites ce que vous voulez; pensez simplement que lorsque vous aurez cliqué sur <span class="em">Enregistrer</span>, vos modifications seront injectées dans la base de données.</p>
                                                </li>
                                                <li>
                                                    <h6>Exercice : réaliser le dialogue de gestion des clients :</h6>
                                                    <p>Je vous propose un exercice, à ce stade : avec ce que vous venez de voir, vous devriez être capable de réaliser seul(e) le dialogue de gestion des clients, avec des composants spécialisés. Le principe est identique à celui des voitures.</p>
                                                    <p>Petites précisions :</p>
                                                    <ul>
                                                        <li>
                                                            <p>appelez votre fiche <span class="em">CustomerForm</span> et l'unité <span class="em">Clients</span></p>
                                                        </li>
                                                        <li>
                                                            <p>n'affichez pas toutes les colonnes dans le DBGrid, sous peine d'avoir une fiche très, très large. Vous pouvez vous contenter des noms et prénoms.</p>
                                                        </li>
                                                    </ul>
                                                    <p>La solution (du moins, une solution possible) se trouvera dans le code complet du projet, que vous trouverez tout à la fin.</p>
                                                </li>
                                            </ol>
                                        </li>
                                        <li>
                                            <h5>Une interface pour définir les requêtes SQL :</h5>
                                            <p>Dans le souci de bien structurer notre application, nous avons centralisé l'interfaçage avec la base de données dans un datamodule. Nous allons encore aller un cran plus loin, en regroupant tout ce qui a trait à la syntaxe SQL dans une unité séparée.</p>
                                            <p>SQL (acronyme de Structured Query Language), est un langage normalisé, devenu pratiquement universel, permettant d'exploiter un très grand nombre de bases de données. Chaque système de gestion de bases de données, malheureusement, ajoute çà et là de petites variantes, ou développe des extensions propres qui complètent le langage SQL de base.</p>
                                            <p>Si nous voulons que notre application puisse aisément être transposée à un autre SGBD (par exemple, de MySQL à SQLite), nous n'avons qu'à modifier la syntaxe de nos requêtes, et le reste de l'application, hormis le connecteur, pourra rester pratiquement inchangé.</p>
                                            <p>Nous allons déclarer une <span class="em">interface</span>, qui va contenir toutes les requêtes utiles pour notre application. Pour chaque nouvelle syntaxe, il faudra déclarer une classe particulière qui sera <span class="em">obligée</span> d'implémenter toutes les requêtes définies dans l'interface.</p>
                                            <p>À l'aide du tout premier bouton de la barre d'outils de Lazarus, créez une nouvelle unité, que vous enregistrez immédiatement sous le nom <span class="em">sql.pas</span>.</p>
                                            <p>Dans la section <span class="em">type</span>, créez une interface <span class="em">ISQLSyntax</span> :</p>
<pre><code>type

    ISQLSyntax = interface

    end;</code></pre>
                                            <p>À l'aide de la combinaison de touches <span class="em">Shift + CTRL + G</span>, créez automatiquement un GUID :</p>
<pre><code>type

    ISQLSyntax = interface

        ['{4AF51BFD-D53D-43F7-9A36-17E859D467CE}']

    end;</code></pre>
                                            <p>La seule requête SQL que nous ayons utilisée jusqu'à présent est celle qui sélectionne toutes les voitures dans la table <span class="em">Voitures</span>. Créez une première fonction <span class="em">SelectionVoituresToutes</span> :</p>
<pre><code>type

    { ISQLSyntax }
  
    ISQLSyntax = interface
  
      ['{238542C2-ADA2-46BC-9138-4D270BEB85D0}']
      
      function SelectionVoituresToutes : String;
        (* Requête de sélection de toutes les voitures *)
    
    end;</code></pre>
                                            <p>Pressez la combinaison de touches <span class="em">Shift + CTRL + C</span> : il ne se passe... rien. En effet, les méthodes déclarées dans l'interface sont uniquement implémentées dans une classe descendante.</p>
                                            <p>Toute classe descendante de cette interdace sera donc obligée d'implémenter la fonction <span class="em">SelectionVoituresToutes</span>. Nous allons créer une classe pour la syntaxe MySQL :</p>
<pre><code>TMySQLSyntax = class(TInterfaceObject, ISQLSyntax)
    function SelectionVoituresToutes : String;
end;</code></pre>
                                            <p>Cette fois, pressez <span class="em">Shift + CTRL + C</span> et complétez la méthode dans la section implémentation :</p>
<pre><code>function TMySQLSyntax.SelectionVoituresToutes : String;
(* Requête de sélection de toutes les voitures *)
begin
    Result := 'SELECT * FROM Voitures;';
end;</code></pre>
                                            <p>Déclarez une variable de type <span class="em">TMySQLSyntax</span> dans la partie interface de l'unité :</p>
<pre><code>var
    SQLSyntax : TMySQLSyntax;   (* Syntaxe propre à MySQL *)</code></pre>
                                            <p>N'oubliez pas d'ajouter l'unité <span class="em">SQL</span> à la clause <span class="em">uses</span>.</p>
                                            <p>À présent, réfléchissons à l'endroit où nus allons instancier la classe <span class="em">TMySQLSyntax</span>. À quel moment en aurons-nous besoin ? À chaque fois qu'une commande SQL devra être générée, c'est-à-dire à peu près partout dans l'application. Donc le meilleur enroit est de la créer au moment de l'affichage de la fenêtre principale, après le login, puis de la libérer à la fermeture de l'application. Il faut donc modifier les méthodes <span class="em">FormShow</span> et <span class="em">FormClose</span> de la fiche principale (dans l'unité <span class="em">Main</span>) :</p>
<pre><code>procedure TMainForm.FormShow(Sender: TObject);
(* Demande de mot de passe *)
begin
if DataModule1.Login
    then
        begin
            // DÉBUT DE L'AJOUT
            (* Initialisation de la classe de syntaxe SQL *)
            SQLSyntax := TMySQLSyntax.Create;
            // FIN DE L'AJOUT

            ShowMessage('Login couronné de succès !');
        end
    else
        Close;
end;

procedure TMainForm.FormClose (Sender : TObject; var CloseAction : TCloseAction);
(* Fermeture propre de la connexion à la base de données *)
begin
    // DÉBUT DE L'AJOUT
    (* Libération des commandes SQL *)
    SQLSyntax.Free;
    // FIN DE L'AJOUT
    (* Déconnexion *)
    DataModule1.Logoff;
end;</code></pre>
                                            <p>Encore une fois, ajoutez l'unité <span class="em">SQL</span> à la clause <span class="em">uses</span> de l'unité <span class="em">Main</span>.</p>
                                        </li>
                                        <li>
                                            <h5>Utilisation d'un TDBGrid sans TDBNavigator :</h5>
                                            <p>Nous allons nous occuper de notre fenêtre principale, qui est bien vide pour l'instant. Ele contiendra la liste des locations, mais aussi différents filtres permettant de n'afficher que les locations répondant à différents critères.</p>
                                            <ol>
                                                <li>
                                                    <h6>TDBGrid :</h6>
                                                    <p>La liste des locations sera contenue dans un DBGrid dont les colonnes seront les suivantes :</p>
                                                    <ul>
                                                        <li>
                                                            <p>les nom et prénom du client;</p>
                                                        </li>
                                                        <li>
                                                            <p>la plaque de la voiture;</p>
                                                        </li>
                                                        <li>
                                                            <p>la marqye de la voiture;</p>
                                                        </li>
                                                        <li>
                                                            <p>son modèle;</p>
                                                        </li>
                                                        <li>
                                                            <p>la date de début de location;</p>
                                                        </li>
                                                        <li>
                                                            <p>la date de fin prévue;</p>
                                                        </li>
                                                        <li>
                                                            <p>la date de rentrée de la voiture à l'issue de la location.</p>
                                                        </li>
                                                    </ul>
                                                    <p>J'ai décidé d'afficher le nom et le prénom du client dans une seule colonne. Pour ce faire, une solution est d'ajouter dans la table <span class="em">Clients</span> un champ supplémentaire. En réalité, nous n'avons pas besoin de créer une colonne qui contiendra en permanence des données : nous allons créer une colonne <span class="em">virtuelle</span>, dont le contenu sera <span class="em">calculé</span> à partir des colonnes <span class="em">Nom</span> et <span class="em">Prénom</span> (qui ne peuvent être nulles, ainsi que nous les avons conçues).</p>
                                                    <p>Direction le navigateur web et PHPMyAdmin : dans l'onglet <span class="em">SQL</span>, collez la commande suivante :</p>
<pre><code>ALTER TABLE Clients ADD NomPrenom VARCHAR(81) AS ( CONCAT(Nom,' ',Prenom) ) VIRTUAL;</code></pre>
                                                    <p>Cette nouvelle colonne <span class="em">NomPrenom</span> ne prendra aucune place dans la base de données, et nous pourrons nous en servir pour afficher ensemble le nom et le prénom de chaque client.</p>
                                                    <p>Direction le datamodule : cliquez sur l'onglet de l'unité <span class="em">DataAccess</span> et pressez <span class="em">F12</span>.</p>
                                                    <p>Déposez sur la fiche un nouveau composant <span class="em">TSQLQuery</span> et un nouveau <span class="em">TDataSource</span>, que vous renommez tout de suite respectivement <span class="em">SQLQueryMain</span> et <span class="em">DataSourceMain</span>. Vous connaissez la musique : assignez <span class="em">SQLConnection</span> à la propriété <span class="em">Database</span> du SQLQuery et <span class="em">SQLQueryMain</span> à la propriété <span class="em">DataSet</span> du DataSource.</p>
                                                    <p>En cliquant sur les trois points en regard de la propriété <span class="em">FieldDefs</span> du SQLQuery, définissez les différents champs à l'aide de l'assistant :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Name</th>
                                                                <th>DataType</th>
                                                                <th>Size</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>IdLocation</td>
                                                                <td>ftWord</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>IdClient</td>
                                                                <td>ftWord</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Plaque</td>
                                                                <td>ftString</td>
                                                                <td>12</td>
                                                            </tr>
                                                            <tr>
                                                                <td>DateDebut</td>
                                                                <td>ftDateTime</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>DateFin</td>
                                                                <td>ftDateTime</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>DateRentree</td>
                                                                <td>ftDateTime</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Assurance</td>
                                                                <td>ftSmallInt</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Plaque_1</td>
                                                                <td>ftString</td>
                                                                <td>12</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Marque</td>
                                                                <td>ftString</td>
                                                                <td>20</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Modele</td>
                                                                <td>ftString</td>
                                                                <td>20</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Cylindree</td>
                                                                <td>ftInteger</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Transmission</td>
                                                                <td>ftFixedChar</td>
                                                                <td>1</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Prix</td>
                                                                <td>ftFloat</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>IdClient_1</td>
                                                                <td>ftWord</td>
                                                                <td>0</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Nom</td>
                                                                <td>ftString</td>
                                                                <td>40</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Prenom</td>
                                                                <td>ftString</td>
                                                                <td>40</td>
                                                            </tr>
                                                            <tr>
                                                                <td>CodePostal</td>
                                                                <td>ftString</td>
                                                                <td>10</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Localite</td>
                                                                <td>ftString</td>
                                                                <td>50</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Rue</td>
                                                                <td>ftString</td>
                                                                <td>80</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Numero</td>
                                                                <td>ftString</td>
                                                                <td>10</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Telephone</td>
                                                                <td>ftString</td>
                                                                <td>40</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Email</td>
                                                                <td>ftString</td>
                                                                <td>50</td>
                                                            </tr>
                                                            <tr>
                                                                <td>NomPrenom</td>
                                                                <td>ftString</td>
                                                                <td>81</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Êtes-vous surpris(e) par le nombre de champs ? C'est normal : la table <span class="em">Locations</span> fait référence aux tables <span class="em">Voitures</span> et <span class="em">Clients</span>, par ses clés étrangères, et dans toute requête de sélection nous ferons ce que l'on appelle une <span class="em">jointure</span>. Laissez-moi le bénéfice du doute pendant quelques minutes encore.</p>
                                                    <p>Revenez à la fiche principale, en cliquant sur l'onglet <span class="em">Main</span> et en pressant <span class="em">F12</span>.</p>
                                                    <p>Élargissez franchement la fiche et déposez-y un composant <span class="em">TDBGrid</span>, que vous renommez <span class="em">dbgMain</span> et dont vous fixez la taille à 784 x 312.</p>
                                                    <p>À l'aidce de l'assistant de création de colonnes (que vous exécutez en cliquant sur les trois points en regard de la propriété <span class="em">Columns</span>, dans l'inspecteur d'objets), créez les colonnes suivantes :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Titre (<span class="em">Title</span>)</th>
                                                                <th>Taille (<span class="em">Width</span>)</th>
                                                                <th>Champ (<span class="em">FieldName</span>)</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>Client</td>
                                                                <td>240</td>
                                                                <td>NomPrenom</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Plaque</td>
                                                                <td>80</td>
                                                                <td>Plaque</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Marque</td>
                                                                <td>80</td>
                                                                <td>Marque</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Modèle</td>
                                                                <td>110</td>
                                                                <td>Modele</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Début</td>
                                                                <td>80</td>
                                                                <td>DateDebut</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Fin</td>
                                                                <td>80</td>
                                                                <td>DateFin</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Rentrée</td>
                                                                <td>80</td>
                                                                <td>DateRentree</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>pour obtenir un affichage correct dans les trois colonnes de dates, assignez à leur propriété <span class="em">DisplayFormat</span> la valeur suivante : "dd"/"mm"/"yyyy".</p>
                                                    <p>Pour terminer, affectez <span class="em">DataModule1.DataSourceMain</span> à la propriété <span class="em">DataSource</span> du DBGrid.</p>
                                                </li>
                                                <li>
                                                    <h6>Filtres :</h6>
                                                    <p>Est-il intéressant d'afficher l'entièreté des locations, c'est-à-dire passées, présentes et futures ? Pas tellement, alors nous allons ajouter des <span class="em">filtres</span> sur la fenêtre principale.</p>
                                                    <p>À droite du DBGrid, déposez deux <span class="em">TLabel</span> (onglet <span class="em">Standard</span>) et deux <span class="em">TDataEdit</span> (onglet <span class="em">Misc</span>) :</p>
                                                    <img src="../images/filtres_Lazarus.png" alt="">
                                                    <p>Renommez-les respectivement <span class="em">lblFiltreDateDebut</span> et <span class="em">lblFiltreDateFin</span>, pour les <span class="em">TLabel</span>, et <span class="em">deFiltreDateDebut</span> et <span class="em">deFiltreDateFin</span> pour les <span class="em">TDataEdit</span>. Fixez les propriétés <span class="em">Caption</span> des labels à "Date de début :" et "Date de fin :".</p>
                                                    <p>Il nous faut fixer le format des deux composants d'édition de date : dans l'inspecteur d'objets, leur propriété <span class="em">DateOrder</span> doit être assignée à <span class="em">doDMY</span>. Vous voyez que le contrôle d'édition lié est automatiquement configuré par Lazarus en "__/___/____", pour permettre d'afficher la date au format "jj/mm/aaaa" auquel nous sommes habitués.</p>
                                                    <p>Nous allons ajouter un autre filtre, en dessous des deux que nous venons de créer, permettant de n'afficher que les locations pour lesquelles une assurance complémentaire a été contractée par le client. Il s'agira d'une simple case à cocher (composant <span class="em">TCheckBox</span>), que m'on trouve dans l'onglet <span class="em">Standard</span>.</p>
                                                    <p>Assignez <span class="em">cbFiltreAssurance</span> à sa propriété <span class="em">Name</span> et "Assure complémentaire" à sa propriété <span class="em">Caption</span>.</p>
                                                    <p>Nous allons faire en sorte qu'au démarrage de l'application, les filtres sur la date de début et la date de fin soient fixés à un mois dans le passé et un mois dans le futur. Dans le code source de l'unité <span class="em">Main</span>, ajoutez ce code à la méthode <span class="em">FormShow</span> :</p>
<pre><code>procedure TMainForm.FormShow(Sender: TObject);
(* Demande de mot de passe *)
begin
if DataModule1.Login
    then
        begin
            (* Initialisation de la classe de syntaxe SQL *)
            SQLSyntax := TMySQLSyntax.Create;
            (* Initialisation des filtres de dates *)
            // DÉBUT DE L'AJOUT
            deFiltreDateDebut.Date := IncDay(Today, -30);
            deFiltreDateFin.Date := IncDay(Today, 30);
            // FIN DE L'AJOUT
        end
    else
        Close;
end;</code></pre>
                                                    <p>Ajoutez également l'unité <span class="em">DateUtils</span> à la clause <span class="em">uses</span> de l'unité.</p>
                                                </li>
                                                <li>
                                                    <h6>Requête SQL de sélection :</h6>
                                                    <p>Penchons-nous à présent sur la requête SQL qui va nous permettre de charger le DBGrid en tenant compte des filtres.</p>
                                                    <p>Dans l'unité <span class="em">SQL</span>, nous ajoutons une fonction à l'interface <span class="em">ISQLSyntax</span> :</p>
<pre><code>function SelectionLocationsFiltre (
    (* Requête de sélection de locations avec critères *)
    const ADateDebut, ADateFin : TDateTime;   (* Dates de début et de fin *)
    const AAssurance : Boolean                (* Avec assurance complémentaire *)
    ) : String;</code></pre>
                                                    <p>Comme prévu, nous passons comme paramètres à la fonction de début et de fin, ainsi que l'option d'affichage de l'assurance complémentaire.</p>
                                                    <p>Ajoutez identiquement cette fonction à la classe <span class="em">TMySQLSyntax</span> qui dérive de l'interface. À l'aide de la combinaison de touches habituelle <span class="em">Shift + CTRL + C</span>, créez l'implémentation de cette fonction et complétez-la comme suit :</p>
<pre><code>function TMySQLSyntax.SelectionLocationsFiltre (const ADateDebut, ADateFin : TDateTime; const AAssurance : Boolean) : String;
(* Requête de sélection de locations avec critères *)
begin
    Result := 'SELECT * FROM Locations' +
                ' INNER JOIN Voitures ON Locations.Plaque = Voitures.Plaque' +
                ' INNER JOIN Clients ON Locations.IdClient = Clients.IdClient' +
                ' WHERE DateDebut &gt;= ''' + DateToStr(ADateDebut, FormatDate) + '''' +
                ' AND DateFin &lt;= ''' + DateToStr(ADateFin, FormatDate) + ''' AND Assurance = ';
    if AAssurance
        then
            Result := Result + '''1'';'
        else
            Result := Result + '''0'';';
end;</code></pre>
                                                    <p>Nous avons beacuoup de choses à dire à propos de cette requête.</p>
                                                    <p>Tout d'abord, je vous ai annoncé un plus haut que nous allions recourir à une <span class="em">jointure</span>. Cette technique permet d'inclure à la requête différentes tables auxquelles il est fait référence, par le biais des clés étangères, dans la table sur laquelle s'effectue la requête. C'est ainsi que la table <span class="em">Locations</span> fait référence à la table <span class="em">Clients</span> par son champ <span class="em">IdClient</span>, et à la table <span class="em">VOitures</span> par son champ <span class="em">Plaque</span>. La requête de sélection joint donc la table <span class="em">Voitures</span> par la commande SQL <span class="html">INNER JOIN Voitures ON Locations.Plaque = Voitures.Plaque</span> et la table <span class="em">Clients</span> par la commande <span class="html">INNER JOIN Clients ON Locations.IdClient = Clients.IdClient</span>.</p>
                                                    <p>Ensuite, c'est dans la clause <span class="html">WHERE</span> que nous effectuons les tests sur les différents filtres.</p>
                                                    <p>Une chose importante : il faut que les dates de début et de fin soient incluses dans la requête sous forme de texte, dans un format reconnu par MySQL.</p>
                                                    <p class="em">Remarque : Ce format de date n'a rien à voir avec le format <span class="html">doDMY</span> que nous avons fixé pour les deux <span class="html">TDataEdit</span>.</p>
                                                    <p>Nous allons donc ajouter à l'interface <span class="em">ISQLSyntax</span> une fonction <span class="em">FormatDate</span> qui va retourner une structure de type <span class="em">TFormatSettings</span> utilisable par la fonction de conversion <span class="em">DateToStr</span> :</p>
<pre><code>function FormatDate : TFormatSettings;
    (* Format de date et le séparateur compatibles avec le SGBD *)</code></pre>
                                                    <p>Si vous avez la curiosité de regarder la déclaration du type <span class="em">TFormatSettings</span>, vous verrez qu'il contient une vingtaine de champs. Seuls deux d'entre eux nous intéressent pour assurer la compatibilité du format de date avec MySQL :</p>
                                                    <ul>
                                                        <li>
                                                            <p><span class="em">DateSeparator</span>;</p>
                                                        </li>
                                                        <li>
                                                            <p><span class="em">ShortDateFormat</span>.</p>
                                                        </li>
                                                    </ul>
                                                    <p>Voici l'implémentation de la fonction <span class="em">FormatDate</span> dans la classe <span class="em">TMySQLSyntax</span> :</p>
<pre><code>function TMySQLSyntax.FormatDate: TFormatSettings;
(* Formats de date et de séparateur compatibles avec le SGBD *)
begin
    Result.DateSeparator := '-';
    Result.ShortDateFormat := 'yyyy-mm-dd';
end;</code></pre>
                                                    <p>Vous voyez que la base de données est configurée pour travailler avec un fomat de date anglo-saxon.</p>
                                                    <p>Il reste un petit détail à mentionner, à propos du filtre sur l'assurance complémentaire : le booléen passé en paramètre doit être transformé en valeur 0 ou 1.</p>
                                                </li>
                                                <li>
                                                    <h6>Chargement du DBGrid :</h6>
                                                    <p>Nous y sommes presque : le DBGrid est prêt, la requête SQL de sélection est écrite, il ne nous reste plus qu'à créer une méthode qui va charger le DBGrid.</p>
                                                    <p>Pour respecter notre logique, cette méthode se trouvera dans le datamodule. Hop, un clic sur l'onglet <span class="em">DataAccess</span> dans l'éditeur de source !</p>
                                                    <p>Dans la section <span class="em">public</span> du datamodule, créez la procédure suivante :</p>
<pre><code>procedure ChargementLocations (const Requete : String);</code></pre>
                                                    <p>Voici son implémentation :</p>
<pre><code>procedure TDataModule1.ChargementLocations (const Requete: String);
(* Charge la table des locations *)
begin
    SQLQueryMain.Close;
    SQLQueryMain.SQL.Text := Requete;
    SQLQueryMain.Open;
end;</code></pre>
                                                    <p>La requête passée comme paramètre sera celle que nous venons de créer.</p>
                                                    <p>Retournez dans l'unité <span class="em">Main</span> et ajoutez à la méthode <span class="em">FormShow</span> :</p>
<pre><code>procedure TMainForm.FormShow(Sender: TObject);
(* Demande de mot de passe *)
begin
if DataModule1.Login
    then
        begin
            (* Initialisation de la classe de syntaxe SQL *)
            SQLSyntax := TMySQLSyntax.Create;
            (* Initialisation des filtres de dates *)
            deFiltreDateDebut.Date := IncDay(Today, -30);
            deFiltreDateFin.Date := IncDay(Today, 30);
            // DÉBUT DE L'AJOUT
            (* Chargement de la liste des locations *)
            DataModule1.ChargementLocations(SQLSyntax.SelectionLocationsFiltre(deFiltreDateDebut.Date, deFiltreDateFin.Date, cbFiltreAssurance.Checked));
            // FIN DE L'AJOUT
        end
    else
        Close;
end;</code></pre>
                                                    <p>De cette manière, dès l'apparition de la fenêtre principale de l'application, s'affichera la liste des locations répondant aux filtres par défaut.</p>
                                                    <p>Je suis sûr que vous avez envie de tester votre programme. Oui, mais ! Il n'y a encore aucune location dans la base de données, donc le DBGrid sera vide. Faisons donc l'exercice de créer quelques locations directement dans la base, à l'aide de PHPMyAdmin. Ce faisant, nous visualiserons, d'ailleurs, la jointure avec les voitures et les clients.</p>
                                                    <p>Rendez-vous dans votre navigateur et connectez-vous à la base de données. Sélectionnez, dans la colonne de gauche de PHPMyAdmin, la table <span class="em">locations</span>, et cliquez à droite, sur l'onglet <span class="em">Insérer</span>.</p>
                                                    <p>Laissez vide la première colonne, <span class="em">IdLocation</span> : il s'agit d'un index qui sera incrémenté. Dans la liste déroulante du champ <span class="em">IdClient</span>, choisissez l'identificateur d'un client; dans celle du champ <span class="em">Plaque</span>, choisissez l'un des véhicules. Ces deux valeurs font le lien avec les deux autres tables, c'est à ce niveau que s'effectue la jointure. Définissez également une date de début et de fin (choisissez des dates proches d'aujourd'hui, car rappelez-vous, par défaut les filtres sont réglés à un mois dans le passé et un mois dans le futur), et inscrivez 0 ou 1 comme valeur pour le champ <span class="em">Assurance</span> :</p>
                                                    <img src="../images/Chargement_DBGrid_Lazarus_1.png" alt="">
                                                    <p>Cliquez sur le bouton <span class="em">Excuter</span> pour créer la location.</p>
                                                    <p>Vous pouvez répéter l'opération une ou deux fois, histoire d'avoir quelque chose à afficher dans le DBGrid de l'application.</p>
                                                    <p>À présent, vous êtes prêt(e) à exécuter votre programme. Allez-y !</p>
                                                    <img src="../images/Chargement_DBGrid_Lazarus_2.png" alt="">
                                                    <p>Yes !</p>
                                                    <p>Réfléchissons encore un peu avant d'aller fêter cela. À chaque fois qu'une modification va être apportée à l'un des filtres, il faudra actualiser le contenu du DBGrid. Par conséquent, nous devons exécuter la méthode <span class="em">DataModule1.SelectionLocationsFiltre</span> en réponse à tout événement <span class="em">OnChange</span> d'un filtre.</p>
                                                    <p>Ce sera vite fait. Sélectionnez successivement les deux <span class="em">TDataEdit</span> et le <span class="em">TCheckBox</span>; dans l'inspecteur d'objets, cliquez sur l'onglet <span class="em">Événements</span> puis sur les trois points correspondant à l'événement <span class="em">OnChange</span>. Complétez les trois méthodes événementielles créées par le même code :</p>
<pre><code>procedure TMainForm.deFiltreDateDebutChange(Sender: Tobject);
(* Modification au filtre : mise à jour du contenu du DBGrid *)
begin
    DataModule1.ChargementLocations(SQLSyntax.SelectionLocationsFiltre(deFiltreDateDebut.Date, deFiltreDateFin.Date, cbFiltreAssurance.Checked));
end;

procedure TMainForm.cbFiltreAssuranceChange(Sender: Tobject);
(* Modification au filtre : mise à jour du contenu du DBGrid *)
begin
    DataModule1.ChargementLocations(SQLSyntax.SelectionLocationsFiltre(deFiltreDateDebut.Date, deFiltreDateFin.Date, cbFiltreAssurance.Checked));
end;

procedure TMainForm.deFiltreDateFinChange(Sender: Tobject);
(* Modification au filtre : mise à jour du contenu du DBGrid *)
begin
    DataModule1.ChargementLocations(SQLSyntax.SelectionLocationsFiltre(deFiltreDateDebut.Date, deFiltreDateFin.Date, cbFiltreAssurance.Checked));
end;</code></pre>
                                                </li>
                                                <li>
                                                    <h6>Exercice : ajouter un filtre pour n'afficher que les locations en cours :</h6>
                                                    <p>Je vous propose comme exercice d'ajouter un filtre pour que seules les locations en cours (dont la date de rentrée est vide) s'affichent dans le DBGrid. Utilisez une case à cocher et réfléchissez bien à ce qu'il faut modifier dans la requête SQL.</p>
                                                    <p class="em">Remarque : Une valeur NULL ne se compare pas comme n'importe quelle valeur. Pour la tester, on peut utiliser la syntaxe <span class="html">Champ IS NULL</span> ou <span class="html">Champ IS NOT NULL</span>.</p>
                                                    <p>Une proposition de solution se trouve dans le code source complet de l'application.</p>
                                                </li>
                                                <li>
                                                    <h6>Des boutons classiques pour l'ajout, la modification et la suppression :</h6>
                                                    <p>Nous avons pris le parti de ne pas utiliser de <span class="em">TDBNavigator</span>, et donc d'utiliser le DBGrid comme une listbox classique. Nous allons par conséquent substituer des boutons normaux à ceux du DBNavigator.</p>
                                                    <p>En dessous des filtres, ajoutez trois composants de type <span class="em">TButton</span> (onglet <span class="em">Standard</span>) :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Nom (<span class="em">Name</span>)</th>
                                                                <th>Libellé (<span class="em">Caption</span>)</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>btnAjouter</td>
                                                                <td>&amp;Nouvelle location</td>
                                                            </tr>
                                                            <tr>
                                                                <td>btnModifier</td>
                                                                <td>&amp;Modifier la location</td>
                                                            </tr>
                                                            <tr>
                                                                <td>btnSupprimer</td>
                                                                <td>&amp;Supprimer la location</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Afin que le DBGrid se comporte comme une simple listbox, nous devons y désactiver les possibilités d'édition des données et faire en sorte que la sélection porte sur une ligne entière (et non plus sur une seule cellule). Sélectionnez-le et réglez les propriétés suivantes dans l'inspecteur d'objets :</p>
                                                    <table class="tableBalises">
                                                        <thead>
                                                            <tr>
                                                                <th>Propriété</th>
                                                                <th>Valeur</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>ReadOnly</td>
                                                                <td>True</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Options / dgDisableDelete</td>
                                                                <td>True</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Options / dgDisableInsert</td>
                                                                <td>True</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Options / dgEditing</td>
                                                                <td>False</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Options / dgRowHighlight</td>
                                                                <td>True</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Options / dgRowSelect</td>
                                                                <td>True</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    <p>Maintenant, vous pouvez aller faire une pause bien méritée. Rechargez bien vos batteries et ne buvez pas trop, car ce qui va suivre va nécessiter toute votre attention.</p>
                                                </li>
                                            </ol>
                                        </li>
                                        <li>
                                            <h5>Utilisation de composants non spécialisés :</h5>
                                            <p>Créez une nouvelle fiche à l'aide du second bouton de la barre d'outils de Lazarus. Remplacez son nom <span class="em">Form1</span> par <span class="em">NewLeasingForm</span>, ce qui transformera automatiquement son type en <span class="em">TnewLeasingForm</span>. Assignez "Location" à sa propriété <span class="em">Caption</span>. Tant que vous y êtes, donnez-lui comme dimensions 508 pixels (<span class="em">Width</span>) sur 181 pixels (<span class="em">Height</span>).</p>
                                            <p>Cette fiche constituera le dialogue de création d'une nouvelle location. Comme nous sommes prévoyants, nous créerons la fiche de manière à ce qu'elle puisse facilment être utilisée pour modifier une location existante, dans une classe descendante.</p>
                                            <p>Enregistrez-la et donnez à la nouvelle unité le nom <span class="em">Locations</span>.</p>
                                            <p>Nous allons déposer sur la fiche une série de contrôles classiques, c'est-à-dire non spécialisés dans les bases de données.</p>
                                            <p>À partir du coin supérieur gauche, déposez quatre <span class="em">TLabel</span> l'un en dessous de l'autre :</p>
                                            <table class="tableBalises">
                                                <thead>
                                                    <tr>
                                                        <th class="em">Name</th>
                                                        <th class="em">Caption</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>lblClient</td>
                                                        <td>Client :</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lblVoiture</td>
                                                        <td>Voiture :</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lblDateDebut</td>
                                                        <td>Date de début :</td>
                                                    </tr>
                                                    <tr>
                                                        <td>lblDateFin</td>
                                                        <td>Date de fin :</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <p>En regard de ces quatre labels, déposez les quatre composants suivants :</p>
                                            <ul>
                                                <li>
                                                    <p>deux <span class="em">TComboBox</span> (onglet <span class="em">Standard</span>), respectivement nommés <span class="em">deDateDebut</span> et <span class="em">deDateFin</span>.</p>
                                                </li>
                                                <li>
                                                    <p>deux <span class="em">TDateEdit</span> (onglet <span class="em">Misc</span>), respectivement nommés <span class="em">deDateDebut</span> et <span class="em">deDateFin</span>.</p>
                                                </li>
                                            </ul>
                                            <p>Les deux <span class="em">TComboBox</span> contiendront la liste des clients et des voitures. Les deux <span class="em">TDateEdit</span>, eux, permettront de définir les dates de débit et de fin de location. Fixez leur propriété <span class="em">DateOrder</span> à <span class="em">doDMY</span> et cochez leur propriété <span class="em">DefaultToday</span> : ainsi, par défaut ils contiendront la date du jour.</p>
                                            <p>À droite des <span class="em">TDateEdit</span>, déposez un <span class="em">TCheckBox</span> (onglet <span class="em">Standard</span>), que vous renommez <span class="em">cbAssurance</span> et dont vous initialisez la propriété <span class="em">Caption</span> à "Assurance +".</p>
                                            <p>En dessous de cette case à cocher, déposez un autre <span class="em">TLabel</span> nommé <span class="em">lblEstimationPrix</span>, contenant "Estimation du prix (€) :" dans sa propriété <span class="em">Caption</span>, et enfin un <span class="em">TStaticText</span> (de l'onglet <span class="em">Additional</span>), nommé <span class="em">stEstimationPrix</span>, dont vous effacez la propriété <span class="em">Caption</span> et vous fixez la propriété <span class="em">Alignment</span> à <span class="em">taCenter</span>.</p>
                                            <p>La fiche devrait ressembler à ceci :</p>
                                            <img src="../images/utilisation_composants_non_specialises_Lazarus_1.png" alt="">
                                            <p>Dans l'espace libre à droite, nous allons déposer divers contrôles permettant de filtrer les voitures qui se trouveront dans la liste.</p>
                                            <p>D'abord, au milieu de l'espace vide, un <span class="em">TLabel</span>, nommé <span class="em">lblCylindree</span>, qui affiche "Cylindrée", et dont la propriété <span class="em">FontStyle</span> est initialisée à <span class="em">[fsUnderline]</span> (pour souligner le texte).</p>
                                            <p>Ensuite, deux <span class="em">TLabel</span> l'un à côté de l'autre, nommés <span class="em">lblCylindreeMin</span> et <span class="em">lblCylindreeMax</span>, dont les propriétés <span class="em">Caption</span> sont respectivement "Min" et "Max". En dessous de ces labels, deux <span class="em">TSpinEdit</span> (onglet <span class="em">Misc</span>), respectivemment nommés <span class="em">seCylindreeMin</span> et <span class="em">seCylindreeMax</span>. Ces deux composants permettront de fixer les limites inférieure et supérieure de cylindrée des voitures de la liste. Il faut définir leurs bornes minimale et maximale (propriétés <span class="em">MinValue</span> et <span class="em">MaxValue</span> : <span class="em">500</span> et <span class="em">9900</span> pour le premier, <span class="em">600</span> et <span class="em">10000</span> pour le second), ainsi que la valeur qui sera incrémentée ou décrémentée à chaque pas, la propriété <span class="em">Increment</span>, que nous fixons à <span class="em">100</span>. Par défaut, nous leur assignons comme valeur de départ <span class="em">1000</span> et <span class="em">2000</span>, dans leur propriété <span class="em">Value</span>. La largeur des deux <span class="em">TSpinEdit</span> sera fixée à 64.</p>
                                            <p>Nous allons remplir l'espace restant à droite avec un filtre sur la transmission. Dans la palette <span class="em">Standard</span>, sélectionnez un <span class="em">TRadioGroup</span> et déposez-en un sous les <span class="em">TSpinEdit</span>, en adaptant sa largeur et sa hauteur pour occuper l'espace libre tout en restant aligné avec les autres contrôles (autant que ça soit joli, n'est-ce pas !). Renommez-le <span class="em">rgTransmission</span>.</p>
                                            <p>Nous déposons dans le <span class="em">TRadioGroup</span> trois boutons radio (<span class="em">TRadioButton</span>, de l'onglet <span class="em">Standard</span>), dont Lazarus fera automatiquement un groupe. Les trois boutons sont nommés <span class="em">rbTransmissionX</span>, <span class="em">rbTransmissionM</span> et <span class="em">rbTransmissionA</span>, et leurs propriétés <span class="em">Caption</span> sont assignées à "Les deux", "Manuelle" et "Automatique". Vous devinez aisément que le premier bouton radio ne filtrera pas les voitures sur le critère de la transmission, et que les deux autres filtreront les boîtes manuelles ou automatiques. Si Lazarus ne l'a pas fait automatiquement, cochez la propriété <span class="em">btnEnregistrer</span> et <span class="em">btnAnnuler</span>, avec comme propriété <span class="em">Caption</span> "&amp;Engreistrer" et "A&amp;nnuler".</p>
                                            <p>Nous avons terminé la conception de notre fiche :</p>
                                            <img src="../images/utilisation_composants_non_specialises_Lazarus_2.png" alt="">
                                            <p>Vous avez sûrement hâte d'afficher le nouveau dialogue, même vide. Retournez dans la fiche principale (unité <span class="em">Main</span>), pressez <span class="em">F12</span>, sélectionnez le bouton <span class="em">btnAjouter</span> dans l'inspecteur d'objets, allez dans l'onglet <span class="em">Événements</span> et cliquez sur les trois points pour créer une méthode qui répondra à l'événement <span class="em">OnClick</span>. Ajoutez l'unité <span class="em">Locations</span> à la clause <span class="em">uses</span> de l'unité <span class="em">Main</span>.</p>
                                            <p>Sans surprise, voici le code d'affichage du dialogue :</p>
<pre><code>procedure TMainForm.btnAjouterClick (Sender : TObject);
(* Ajout d'une nouvelle location *)
var
    LNewLeasingForm : TNewLeasingForm;   (* Dialogue de collecte des données *)
begin
    LNewLeasingForm := TNewLeasingForm.Create(Self);
    try
        LNewLeasingForm.ShowModal;
    finally
        FreeAndNil(LNewLeasingForm);
    end;
    (* Mise à jour de la liste des locations affichée *)
    DataModule1.ChargementLocations(SQLSyntax SelectionLocationsFiltre(deFiltreDateDebut.Date, deFiltreDateFin.Date,cbFiltreAssurance.Checked, cbFiltreEnCours.Checked));</code></pre>
                                            <p>Le dialogue ne contient aucun composant orienté bases de données, c'était le but que nous nous étions fixé. Comment alors faire le lien avec la base de données ?</p>
                                            <ol>
                                                <li>
                                                    <h6>Chargemements des clients et des voitures dans des TComboBox :</h6>
                                                    <p>Pour la liste des clients et des voitures, nous allons utiliser une fonctionnalité bien pratique des comboboxes : à chaque élément de la liste peut être attaché un objet quelconque. Considérons la déclaration de la méthode <span class="em">AddItem</span>, qui est héritée de la classe <span class="em">TCustomComboBox</span> :</p>
<pre><code>procedure TCustomComboBox.AddItem (
    const Item: String;
    AnObject: TObject
    ); virtual;</code></pre>
                                                    <p>Le paramètre <span class="em">Item</span> contient la chaîne de caractères à afficher et <span class="em">AnObject</span> sera un objet lié à l'élément, qui pourra contenir des données supplémentaires.</p>
                                                    <p>Réfléchissons : en plus de son nom, qui va être affiché dans la combobox des clients, de quelles données supplémentaires avons-nous besoin pour un client ? De pas grand-chose, en fait, juste son identificateur, dans la table <span class="em">Clients</span> de la base de données (la clé primaire de la table). Et pour une voiture ? Là, c'est plus compliqué, car il y a différentes caractéristiques d'une voiture qui sont concernées par les filtres de notre boîte de dialogue : la cylindrée et la transmission. Le prix par jour est également requis pour le calcul de l'estimation du coût de la location. Et nous aurons également besoin de l'identificateur de la voiture dans la table <span class="em">Voitures</span>, qui est sa plaque d'immatriculation.</p>
                                                    <p>Dans l'unité <span class="em">DataAccess</span>, nous créons deux classes <span class="em">TCBClient</span> et <span class="em">TCBVoiture</span> ("CB" faisant référence aux comboboxes auxquelles elles sont destinées) :</p>
<pre><code>type

    { TCBClient }
  
    TCBClient = class
      (* Données invisibles d'un élément de combobox contenant la liste des clients *)
      strict private
        FIdClient : Integer;
      public
        property IdClient : Integer read FIdClient;
        constructor Create (const AIdClient : Integer);
    end;

    { TCBVoiture }
    
    TCBVoiture = class
      (* Données invisibles d'un élément de combobox contenant la liste des voitures *)
      strict private
        FPlaque : String;
        FCylindree : Integer;
        FTransmission : Char;
        FPrix : Real;
      public
        property Plaque : String read FPlaque;
        property Cylindree : Integer read FCylindree;
        property Transmission : Char read FTransmission;
        property Prix : Real read FPrix;
        constructor Create (const APlaque : String;
                            const ACylindree : Integer;
                            const ATransmission : Char;
                            const APrix : Real);
    end;</code></pre>
                                                    <p>Voici le code des deux méthodes <span class="em">Create</span> :</p>
<pre><code>constructor TCBClient.Create (const AIdClient : Integer);
(* Initialisation des champs *)
begin
    FIdClient := AIdClient;
end;
constructor TCBVoiture.Create (const APlaque : String;
                                const ACylindree : Integer;
                                const ATransmission : Char;
                                const APrix : Real);
(* Initialisation des champs *)
begin
    FPlaque := APlaque;
    FCylindree := ACylindree;
    FTransmission := ATransmission;
    FPrix := APrix;
end;</code></pre>
                                                    <p>Nous confions au datamodule le soin de charger les clients et les voitures dans les comboboxes correspondantes. Dans sa section <span class="em">public</span>, créez les deux méthodes suivantes :</p>
<pre><code>procedure ChargementCBClients (var ComboBox : TComboBox);
procedure ChargementCBVoitures (var ComboBox : TComboBox;
                                const Requete : String);</code></pre>
                                                    <p>Grâce à la combinaison de touches <span class="em">Shift + CTRL + C</span>, créez leur implémentation et complétez le code comme suit :</p>
<pre><code>procedure TDataModule1.ChargementCBClients (var ComboBox : TComboBox);
(* Remplit une combobox avec les noms et prénoms des clients. Chaque élément est constitué d'un texte visible et de données invisibles *)
var
    LNomPrenom : String;   (* Texte visible d'un élément *)
begin
    ChargementClients(SQLSyntax.SelectionClientsTous);
    with SQLQueryClients do
    while not EOF do
        begin
        LNomPrenom := FieldByName('Nom').AsString + ' ' + FieldByName('Prenom').AsString;
        ComboBox.AddItem(LNomPrenom, TCBClient.Create(FieldByName('IdClient').AsInteger));
        Next;
        end;
end;

procedure TDataModule1.ChargementCBVoitures (var ComboBox : TComboBox; const Requete : String);
(* Charge une combobox avec les voitures correspondant à la requête. Chaque élément est constitué d'un texte visible et de données invisibles *)
var
    LVoiture : String;   (* Texte visible d'un élément *)
begin
    ComboBox.Clear;
    ChargementVoitures(Requete);
    with SQLQueryVoitures do
    while not EOF do
        begin
            LVoiture := '[' + FieldByName('Plaque').AsString + '] ' + FieldByName('Marque').AsString + ' ' + FieldByName('Modele').AsString;
            ComboBox.AddItem(LVoiture, TCBVoiture.Create(FieldByName('Plaque').AsString, FieldByName('Cylindree').AsInteger, (FieldByName('Transmission').AsString)[1], FieldByName('Prix').AsFloat));
            Next;
        end;
end;</code></pre>
                                                </li>
                                                <li>
                                                    <h6>Requêtes de sélection des voitures et des clients :</h6>
                                                    <p>Ne compilez pas le projet à ce stade, sous peine d'obtenir des erreurs de compilation. Il faut d'abord ajouter l'unité <span class="em">StdCtrls</span> à la clause <span class="em">uses</span> de l'unité (pour que le compilateur connaisse le type <span class="em">TcomboBox</span>). Ensuite, les méthodes <span class="em">ChargementClients</span> et <span class="em">ChargementVoitures</span>, qui avaient été définies plus tôt, doivent être légèrement modifiées pour accepter comme paramètre une autre requête que <span class="em">SelectionClientsTous</span> et <span class="em">SelectionVoituresToutes</span>.</p>
                                                    <p>Nous partons du principe que tous les clients seront chargés dans la liste, et que donc une requête <span class="html">SELECT *</span> tout simple sera suffisante pour remplir le <span class="em">TSQLQuery</span> des clients. Par contre, la requête de sélection des voitures devra répondre aux différents filtres de la boîte de dialogue.</p>
                                                    <p>Dans le datamodule, modifiez la déclaration des méthodes <span class="em">ChargementClients</span> et <span class="em">ChargementVoitures</span> :</p>
<pre><code>procedure ChargementClients (const Requete : String);
procedure ChargementVoitures (const Requete : String);</code></pre>
                                                    <p>Et leur implémentation :</p>
<pre><code>procedure TDataModule1.ChargementClients (const Requete : String);
(* Chargement des clients *)
begin
    with SQLQueryClients do
    begin
        Close;
        SQL.Text := Requete;
        Open;
    end;
end;

procedure TDataModule1.ChargementVoitures (const Requete : String);
(* Chargement des voitures *)
begin
    with SQLQueryVoitures do
    begin
        Close;
        SQL.Text := Requete;
        Open;
    end;
end;</code></pre>
                                                    <p>La modification consiste à passer la requête à exécuter comme paramètre, ce qui rend d'usage beaucoup plus général les deux méthodes.</p>
                                                    <p>Cela signifie que nous devons également modifier les appels antérieurs à ces méthodes :</p>
                                                    <ul>
                                                        <li>
                                                            <p>la méthode <span class="em">TCarForm.FormShow</span> (de l'unité <span class="em">Voitures</span>) :</p>
<pre><code>procedure TCarForm.FormShow(Sender: TObject);
(* Chargement de la liste des voitures *)
begin
    Enregistre := False;
    DataModule1.ChargementVoitures(SQLSyntax.SelectionVoituresToutes);
end;</code></pre>
                                                        </li>
                                                        <li>
                                                            <p>la méthode <span class="em">TCustomerForm.FormShow</span>.</p>
                                                        </li>
                                                    </ul>
                                                    <p>Dans ces deux unités, il faudra rajouter l'unité <span class="em">SQL</span> dans la clause <span class="em">uses</span>.</p>
                                                    <p>Allons maintenant implémenter le chargement des deux comboboxes dans notre dialogue <span class="em">TNewLeasingForm</span>. Dans l'éditeur de source, sélectionnez l'onglet <span class="em">Locations</span> et pressez <span class="em">F12</span>. Dans l'inspecteur d'objets, allez dans l'onglet <span class="em">Événements</span> et cliquez sur les trois points correspondant à l'événement <span class="em">OnShow</span>. Lazarus crée une nouvelle méthode <span class="em">FormShow</span>, que vous complétez comme suit :</p>
<pre><code>procedure TNewLeasingForm.FormShow (Sender: TObject);
(* Chargement des contrôles *)
begin
    (* Listes des clients et des voitures *)
    DataModule1.ChargementCBClients(cbClients);
    DataModule1.ChargementCBVoitures(cbVoitures, RequeteSelectionVoituresFiltre);
end;</code></pre>
                                                    <p>On voit tout de suite qu'il faudra créer la méthode <span class="em">RequeteSelectionVoituresFiltre</span>; gardons cela deux minutes dans un coin de notre esprit, il faut tout d'abord avoir le réflexe de libérer les objets invisibles qui sont liés aux éléments des comboboxes, à la ferneture du dialogue.</p>
                                                    <p>Cliquez sur les trois points de l'événement <span class="em">OnClose</span>, puis complétez le code :</p>
<pre><code>procedure TNewLeasingForm.FormClose(Sender: TObject; var CloseAction: TCloseAction);
(* Détruit les objets passés comme paramètres aux comboboxes *)
var
    Li : Integer;
begin
    for Li := 0 to (cbClients.Items.Count - 1) do
    TCBClient(cbClients.Items.Objects[Li]).Free;
    for Li := 0 to (cbVoitures.Items.Count - 1) do
    TCBVoiture(cbVoitures.Items.Objects[Li]).Free;
end;</code></pre>
                                                    <p>Pour compiler, l'unité <span class="em">DataAccess</span> doit être ajoutée à la clause <span class="em">uses</span>.</p>
                                                    <p>Occupons-nous de cette méthode <span class="em">RequeteSelectionVoituresFiltre</span> dont nous avons postposé la création. Ajoutez cette déclaration dans la section <span class="em">private</span> de la classe <span class="em">TNewLeasingForm</span> :</p>
<pre><code>function RequeteSelectionVoituresFiltre : String;</code></pre>
                                                    <p>Voici son implémentation :</p>
<pre><code>function TNewLeasingForm.RequeteSelectionVoituresFiltre: String;
(* Construit la requête de sélection des voitures pour la combobox *)
var
    LTransmission : String;
begin
    if rbTransmissionM.Checked
        then
            LTransmission := 'M'
        else
            if rbTransmissionA.Checked
                then
                    LTransmission := 'A'
                else
                    LTransmission := '';
    Result := SQLSyntax.SelectionVoituresFiltre(seCylindreeMin.Value, seCylindreeMax.Value, LTransmission);
end;</code></pre>
                                                    <p>Cette méthode ne construit pas directement la requête SQL, elle définit les paramètres à passer à une méthode de la classe <span class="em">TmySQLSyntax</span>, que nous allons tout de suite créer.</p>
                                                    <p>Direction l'unité <span class="em">SQL</span> et notre interface <span class="em">ISQLSyntax</span>. Ajoutez-y la déclaration suivante :</p>
<pre><code>function SelectionVoituresFiltre (
(* Requête de sélection de voitures avec critères *)
const ACylindreeMin, ACylindreeMax : Integer;   (* Cylindrées minimale et maximale *)
const ATransmission : String                    (* Transmission : "A" ou "M" *)
) : String;</code></pre>
                                                    <p>Dans la déclaration du type <span class="em">TMySQLSyntax</span>, ajoutez-la aussi :</p>
<pre><code>function SelectionVoituresFiltre (const ACylindreeMin, ACylindreeMax : Integer; const ATransmission : String) : String;</code></pre>
                                                    <p>Un petit <span class="em">Shift + CTRL + C</span> puis complétez :</p>
<pre><code>function TMySQLSyntax.SelectionVoituresFiltre (const ACylindreeMin, ACylindreeMax : Integer; const ATransmission : String) : String;
(* Requête de sélection de voitures avec critères *)
begin
    Result := 'SELECT * FROM Voitures WHERE Cylindree >= ''' + IntToStr(ACylindreeMin) + ''' AND Cylindree <= ''' + IntToStr(ACylindreeMax) + '''';
    if ATransmission &lt;&gt; ''
        then
            Result := Result + ' AND Transmission = ''' + ATransmission + '''';
    Result := Result + ';';
end;</code></pre>
                                                    <p>La requête <span class="html">SELECT</span> construite teste les bornes inférieure et supérieure de la cylindrée et introduit un test sur la transmission uniquement si le paramètre <span class="em">ATransmission</span> n'est pas une chaîne vide.</p>
                                                </li>
                                                <li>
                                                    <h6>Indices des client et voiture courants :</h6>
                                                    <p>Comme il s'agit d'une nouvelle location, par défaut ce sont les premiers éléments (d'indice 0) des deux comboboxes qui sont sélectionnés lorsque s'affiche le dialogue. Cependant, comme la liste des voitures va être rechargée à chaque fois que les filtres seront modifiés, il faudra garder en mémoire l'indice de la voiture sélectionnée pour la resélectionner après (si elle correspond, bien sûr, toujours aux critères).</p>
                                                    <p>Ensuite, rappelez-vous que nous avions prévu de concevoir notre fiche de manière à pouvoir servir de parent à une fiche descendante qui permettrait de modifier une location. Par conséquent, à l'affichage de la fiche, le client et la voiture de la location à modifier devront être sélectionnés. Alors autant prévoir tout de suite de gérer, également, l'indice de la personne.</p>
                                                    <p>La conservation des deux indices se fera dans deux propriétés.</p>
                                                    <p>Dans la déclaration du type <span class="em">TNewLeasingForm</span> avant la section <span class="em">private</span>, créez une section <span class="em">strict private</span> et déclarez-y les deux champs suivants :</p>
<pre><code>strict private
    FIndexClient : Integer;
    FIndexVoiture : Integer;</code></pre>
                                                    <p>Dans la section <span class="em">public</span>, créez les deux propriétés suivantes :</p>
<pre><code>public
    property IndexClient : Integer read FIndexClient write SetIndexClient;  (* Index du client actuellement sélectionné *)
property IndexVoiture : Integer read FIndexVoiture write SetIndexVoiture;   (* Index de la voiture actuellement sélectionnée *)</code></pre>
                                                    <p>Créez leurs setters dans la section <span class="em">private</span> :</p>
<pre><code>private
    procedure SetIndexClient (AValue : Integer);
    procedure SetIndexVoiture (AValue : Integer);</code></pre>
                                                    <p>Voici le code source des setters :</p>
<pre><code>procedure TNewLeasingForm.SetIndexClient (AValue : Integer);
(* Setter de la propriété IndexClient *)
begin
    if FIndexClient = AValue
        then
            Exit;
    FIndexClient := AValue;
end;

procedure TNewLeasingForm.SetIndexVoiture (AValue : Integer);
(* Setter de la propriété IndexVoiture *)
begin
    if FIndexVoiture = AValue
        then
            Exit;
    FIndexVoiture := AValue;
end;</code></pre>
                                                    <p>Initialisons les deux propriétés dans la méthode <span class="em">FormShow</span> :</p>
<pre><code>procedure TNewLeasingForm.FormShow(Sender: TObject);
(* Chargement des contrôles *)
begin
    (* Listes des clients et des voitures *)
    DataModule1.ChargementCBClients(cbClients);
    DataModule1.ChargementCBVoitures(cbVoitures, RequeteSelectionVoituresFiltre);
    // DÉBUT DE L'AJOUT
    (* Éléments sélectionnés dans les deux comboboxes *)
    IndexClient := 0;
    IndexVoiture := 0;
    cbClients.ItemIndex := IndexClient;
    cbVoitures.ItemIndex := IndexVoiture;
    // FIN DE L'AJOUT
end;</code></pre>
                                                    <p class="em">Remarque : Nous savons déjà que, dans la fiche ascendante qui permettra de modifier une location, ces deux indices seront initialisés non pas à 0 mais à ceux correspondant au client et à la voiture de la location.</p>
                                                    
                                                </li>
                                            </ol>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>