<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Pascal - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#elements_langage">Éléments du langage</a></li>
                        <li><a href="#entete_partie_declaration">En-tête et partie déclaration</a></li>
                        <li><a href="#partie_instruction">Partie instruction</a></li>
                        <li><a href="#types">Types</a></li>
                        <li><a href="#instructions_structurees">Instructions structurées</a></li>
                        <li><a href="#type_string">Type string (chaînes courtes)</a></li>
                        <li><a href="#fonctions_procedures">Fonctions et procédures</a></li>
                        <li><a href="#tableaux">Tableaux (Array)</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Pascal :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Le langage Pascal a été créé dans les années 1960 par le professeur suisse Niklaus Wirth, avec pour objectif principal de favoriser la clarté, la lisibilité et la fiabilité du code. Il tire son nom du mathématicien et philosophe Blaise Pascal.</p>
                    <p>Pascal est un langage de programmation impératif et structuré, largement utilisé dans les milieux académiques et éducatifs, ainsi que dans le développement de logiciels système, d'applications scientifiques et d'ensembles d'outils.</p>
                    <p>Il se distingue par sa syntaxe formelle, ses structures de contrôle claires telles que les boucles et les structures conditionnelles, ainsi que par ses types de données statiquement typés. Ces caractéristiques en font un langage idéal pour l'apprentissage des concepts fondamentaux de la programmation.</p>
                    <p>Pascal a influencé de nombreux autres langages de programmation, notamment Ada, Modula-2 et Delphi. Bien que son utilisation ait décliné dans le monde professionnel au profit de langage plus modernes, il reste un choix populaire pour l'enseignement de la programmation en raison de sa simplicité et de sa lisibilité.</p>
                </article>
                <article>
                    <h2 id="elements_langage">Éléments du langage :</h2>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Un programme Pascal est écrit sous la forme d'une suite de lignes de texte. La longueur d'une ligne ne fait pas partie des spécifications du Pascal.</p>
                            <p>Un programme Pascal est composé :</p>
                            <ul>
                                <li>
                                    <p><span class="em">d'éléments du langage</span> (les plus petits éléments significatifs - tokens) séparés (si nécessaire par)</p>
                                </li>
                                <li>
                                    <p>un ou plusieurs <span class="em">séparateurs</span>.</p>
                                </li>
                            </ul>
                            <p>Un séparateur est :</p>
                            <ul>
                                <li>
                                    <p>soit un <span class="em">caractère inerte</span> : <span class="em">le caractère espace</span> (valeur ASCII 32) et <span class="em">tous les caractères de contrôle</span> (valeurs ASCII de 0 à 31)</p>
                                </li>
                                <li>
                                    <p>soit un <span class="em">commentaire</span>; les commentaires (qui ne peuvent être imbriqués) sont ignorés par le compilateur; ils aident seulement à la lisibilité de vos programmes.</p>
<pre><code>{ceci est un commentaire}
(* ceci également *)
// et ceci est un commentaire en ligne</code></pre>
                                    <p class="em">Un commentaire comportant le symbole $ immédiatement après l'accolade ouvrante est une directive de compilation.</p>
                                    <p class="em">Ainsi, dans l'environnement Delphi 4, la directive {$APPTYPE CONSOLE} signifie au compilateur que le programme devra correspondre à une application console.</p>
<pre><code>Program Hello ;
<span class="em">{$APPTYPE CONSOLE}</span>
begin
    writeLn('Hello, World…') ;
    <span class="em">readLn</span>
end.</code></pre>
                                </li>
                            </ul>
                            <p>Les éléments du langage comprennent :</p>
                            <ul>
                                <li>
                                    <p>les symboles spéciaux et les mots réservés</p>
                                </li>
                                <li>
                                    <p>les identificateurs</p>
                                </li>
                                <li>
                                    <p>les nombres</p>
                                </li>
                                <li>
                                    <p>les constantes chaînes de caractères</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Symboles spéciaux et mots réservés :</h3>
                            <p>Les symboles spéciaux et les mots réservés sont des caractères ou des suites de caractères ayant une ou plusieurs significations fixées par le langage.</p>
                            <ol>
                                <li>
                                    <h4>Symboles spéciaux :</h4>
                                    <ul>
                                        <li>
                                            <p>+</p>
                                        </li>
                                        <li>
                                            <p>*</p>
                                        </li>
                                        <li>
                                            <p>/</p>
                                        </li>
                                        <li>
                                            <p>=</p>
                                        </li>
                                        <li>
                                            <p>&lt;</p>
                                        </li>
                                        <li>
                                            <p>&gt;</p>
                                        </li>
                                        <li>
                                            <p>[</p>
                                        </li>
                                        <li>
                                            <p>]</p>
                                        </li>
                                        <li>
                                            <p>.</p>
                                        </li>
                                        <li>
                                            <p>,</p>
                                        </li>
                                        <li>
                                            <p>(</p>
                                        </li>
                                        <li>
                                            <p>)</p>
                                        </li>
                                        <li>
                                            <p>:</p>
                                        </li>
                                        <li>
                                            <p>;</p>
                                        </li>
                                        <li>
                                            <p>'</p>
                                        </li>
                                        <li>
                                            <p>^</p>
                                        </li>
                                        <li>
                                            <p>@</p>
                                        </li>
                                        <li>
                                            <p>{</p>
                                        </li>
                                        <li>
                                            <p>}</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>$</p>
                                        </li>
                                        <li>
                                            <p>#</p>
                                        </li>
                                        <li>
                                            <p>&lt;=</p>
                                        </li>
                                        <li>
                                            <p>&gt;=</p>
                                        </li>
                                        <li>
                                            <p>&lt;&gt;</p>
                                        </li>
                                        <li>
                                            <p>:=</p>
                                        </li>
                                        <li>
                                            <p>..</p>
                                        </li>
                                        <li>
                                            <p>(*)</p>
                                        </li>
                                        <li>
                                            <p>*)</p>
                                        </li>
                                        <li>
                                            <p>(.)</p>
                                        </li>
                                        <li>
                                            <p>.)</p>
                                        </li>
                                        <li>
                                            <p>//</p>
                                        </li>
                                        <li>
                                            <p>&amp;</p>
                                        </li>
                                    </ul>
                                    <p>Exemple :</p>
                                    <p>Le symbole <span class="em">&lt;=</span> représente un opérateur. Il est d'ailleurs surchargé, ce qui signifie qu'il possède plusieurs significations. Suivant le contexte, il symbolise l'opération inférieur ou égal ou l'opération sous-ensemble de.</p>
                                </li>
                                <li>
                                    <h4>Mots réservés :</h4>
                                    <p>Les mots réservés ou mots clés font partie du langage Pascal; ils ne peuvent en aucun cas être redéfinis et possèdent une signification standard prédéfinie. En voici la liste :</p>
                                    <ul>
                                        <li>
                                            <p>and</p>
                                        </li>
                                        <li>
                                            <p>array</p>
                                        </li>
                                        <li>
                                            <p>begin</p>
                                        </li>
                                        <li>
                                            <p>case</p>
                                        </li>
                                        <li>
                                            <p>const</p>
                                        </li>
                                        <li>
                                            <p>div</p>
                                        </li>
                                        <li>
                                            <p>do</p>
                                        </li>
                                        <li>
                                            <p>downto</p>
                                        </li>
                                        <li>
                                            <p>else</p>
                                        </li>
                                        <li>
                                            <p>End</p>
                                        </li>
                                        <li>
                                            <p>file</p>
                                        </li>
                                        <li>
                                            <p>for</p>
                                        </li>
                                        <li>
                                            <p>function</p>
                                        </li>
                                        <li>
                                            <p>goto</p>
                                        </li>
                                        <li>
                                            <p>if</p>
                                        </li>
                                        <li>
                                            <p>in</p>
                                        </li>
                                        <li>
                                            <p>label</p>
                                        </li>
                                        <li>
                                            <p>mod</p>
                                        </li>
                                        <li>
                                            <p>nil</p>
                                        </li>
                                        <li>
                                            <p>not</p>
                                        </li>
                                        <li>
                                            <p>of</p>
                                        </li>
                                        <li>
                                            <p>or</p>
                                        </li>
                                        <li>
                                            <p>packed</p>
                                        </li>
                                        <li>
                                            <p>procedure</p>
                                        </li>
                                        <li>
                                            <p>program</p>
                                        </li>
                                        <li>
                                            <p>record</p>
                                        </li>
                                        <li>
                                            <p>repeat</p>
                                        </li>
                                        <li>
                                            <p>set</p>
                                        </li>
                                        <li>
                                            <p>then</p>
                                        </li>
                                        <li>
                                            <p>to</p>
                                        </li>
                                        <li>
                                            <p>type</p>
                                        </li>
                                        <li>
                                            <p>until</p>
                                        </li>
                                        <li>
                                            <p>var</p>
                                        </li>
                                        <li>
                                            <p>while</p>
                                        </li>
                                        <li>
                                            <p>with</p>
                                        </li>
                                    </ul>
                                    <p>Le Pascal Objet en allonge la liste :</p>
                                    <ul>
                                        <li>
                                            <p>As</p>
                                        </li>
                                        <li>
                                            <p>asm</p>
                                        </li>
                                        <li>
                                            <p>class</p>
                                        </li>
                                        <li>
                                            <p>constructor</p>
                                        </li>
                                        <li>
                                            <p>destructor</p>
                                        </li>
                                        <li>
                                            <p>dispinterface</p>
                                        </li>
                                        <li>
                                            <p>except</p>
                                        </li>
                                        <li>
                                            <p>exports</p>
                                        </li>
                                        <li>
                                            <p>finalization</p>
                                        </li>
                                        <li>
                                            <p>implementation</p>
                                        </li>
                                        <li>
                                            <p>inherited</p>
                                        </li>
                                        <li>
                                            <p>initialization</p>
                                        </li>
                                        <li>
                                            <p>inline</p>
                                        </li>
                                        <li>
                                            <p>interface</p>
                                        </li>
                                        <li>
                                            <p>is</p>
                                        </li>
                                        <li>
                                            <p>library</p>
                                        </li>
                                        <li>
                                            <p>object</p>
                                        </li>
                                        <li>
                                            <p>out</p>
                                        </li>
                                        <li>
                                            <p>finally</p>
                                        </li>
                                        <li>
                                            <p>unit</p>
                                        </li>
                                        <li>
                                            <p>property</p>
                                        </li>
                                        <li>
                                            <p>raise</p>
                                        </li>
                                        <li>
                                            <p>resourcestring</p>
                                        </li>
                                        <li>
                                            <p>shl</p>
                                        </li>
                                        <li>
                                            <p>shr</p>
                                        </li>
                                        <li>
                                            <p>string</p>
                                        </li>
                                        <li>
                                            <p>threadvar</p>
                                        </li>
                                        <li>
                                            <p>try</p>
                                        </li>
                                        <li>
                                            <p>uses</p>
                                        </li>
                                        <li>
                                            <p>xor</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Identificateurs :</h3>
                            <p>Les identificateurs symbolisent les constantes, les champs (d'enregistrement) les unités, les bibliothèques et les paquets. Nous en avons déjà étudié la syntaxe. Pascal contient des identificateurs (directives) standards dotés de sognifications prédéfinies. Contrairement aux mots réservés, vous "pouvez" les redéfinir...</p>
                            <ul>
                                <li>
                                    <p>absolute</p>
                                </li>
                                <li>
                                    <p>abstract</p>
                                </li>
                                <li>
                                    <p>assembler</p>
                                </li>
                                <li>
                                    <p>automated</p>
                                </li>
                                <li>
                                    <p>Cdel</p>
                                </li>
                                <li>
                                    <p>contains</p>
                                </li>
                                <li>
                                    <p>default</p>
                                </li>
                                <li>
                                    <p>At</p>
                                </li>
                                <li>
                                    <p>dispid</p>
                                </li>
                                <li>
                                    <p>dynamic</p>
                                </li>
                                <li>
                                    <p>export</p>
                                </li>
                                <li>
                                    <p>external</p>
                                </li>
                                <li>
                                    <p>far</p>
                                </li>
                                <li>
                                    <p>implements</p>
                                </li>
                                <li>
                                    <p>forward</p>
                                </li>
                                <li>
                                    <p>on</p>
                                </li>
                                <li>
                                    <p>index</p>
                                </li>
                                <li>
                                    <p>message</p>
                                </li>
                                <li>
                                    <p>name</p>
                                </li>
                                <li>
                                    <p>near</p>
                                </li>
                                <li>
                                    <p>nodefault</p>
                                </li>
                                <li>
                                    <p>reintroduce</p>
                                </li>
                                <li>
                                    <p>override</p>
                                </li>
                                <li>
                                    <p>safecall</p>
                                </li>
                                <li>
                                    <p>pascal</p>
                                </li>
                                <li>
                                    <p>private</p>
                                </li>
                                <li>
                                    <p>protected</p>
                                </li>
                                <li>
                                    <p>public</p>
                                </li>
                                <li>
                                    <p>published</p>
                                </li>
                                <li>
                                    <p>overload</p>
                                </li>
                                <li>
                                    <p>read</p>
                                </li>
                                <li>
                                    <p>Readonly</p>
                                </li>
                                <li>
                                    <p>register</p>
                                </li>
                                <li>
                                    <p>resident</p>
                                </li>
                                <li>
                                    <p>stdcall</p>
                                </li>
                                <li>
                                    <p>stored</p>
                                </li>
                                <li>
                                    <p>virtual</p>
                                </li>
                                <li>
                                    <p>requires</p>
                                </li>
                                <li>
                                    <p>write</p>
                                </li>
                                <li>
                                    <p>writeonly</p>
                                </li>
                            </ul>
                            <p>Rappelons le diagramme de Conway pour l'écriture des identificateurs :</p>
                            <img src="../images/diagramme_Conway_ecriture_identificateurs.png" alt="">
                            <p>Un identificateur peut avoir une taille quelconque mais seuls les 255 (<span class="em">63 pour les anciens compilateurs</span>) premiers caractères sont significatifs.</p>
                        </li>
                        <li>
                            <h3>Nombres :</h3>
                            <p>Les nombres avec décimales ou exposants sont des constantes de type réel. Les autres nombres sont des entiers. Les valeurs doivent se trouver à l'intérieur de l'intervalle du plus grand type prédéfini entier ou réel.</p>
                            <p>Les nombres hexadécimaux sont des entiers et ils doivent être compris entre $00000000 et $FFFFFFFF.</p>
                            <ul>
                                <li>
                                    <p>Un nombre entier en notation décimale se compose d'une suite de chiffres éventiellement précédés d'un signe (exemple : 46). En notation hexadécimale, il se compose en plus, des lettres de A à F (ou a à f); il est alors préfixé par le signe $ (exemple : $2E).</p>
                                    <p>Notation décimale :</p>
                                    <img src="../images/notation_decimale_Pascal.png" alt="">
                                    <p>Notation hexadécimale :</p>
                                    <img src="../images/notation_hexadecimale_Pascal.png" alt="">
                                </li>
                                <li>
                                    <p>Un nombre réel doit contenir un point décimal ou un exposant - ou bien les deux.</p>
                                    <p>S'il contient un point décimal, celui doit figurer entre deux chiffres (exemple : 46.0).</p>
                                    <p>Et en notation scientifique : 0.46 E2 (se lit 0.46 fois dix à la puissance 2)</p>
                                    <img src="../images/notation_scientifique_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Notez que les nombres entiers sont des quantités exactes, alors que les nombres réels correspondent à des approximations.</p>
                        </li>
                        <li>
                            <h3>Chaînes de caractères :</h3>
                            <p>Une chaîne de caractères est une suite éventuellement vide de caractères délimitée par des apostrophes.</p>
                            <p>Pascal Objet offre la possibilité d'insérer dans les chaînes de caractères des caractères de contrôle (le signe dièse suivi directement d'une constante entière dans l'intervalle 0..255 représente le caractère ASCII correspondant).</p>
                            <p>UneMethode chaîne de caractères doit s'écrire sur une seule ligne.</p>
                            <img src="../images/chaines_caracteres_Pascal.png" alt="">
                            <p>(*) tous les caractères sauf l'apostrophe et le retour chariot.</p>
<pre><code>'Exemple d''une chaîne'
''	{chaîne vide}
''''	{chaîne comprenant une apostrophe}
#7#7'Debout !'#7#7
'Ligne 1'#13'Ligne 2'</code></pre>
                            <p>Dans un programme Pascal, on peut utiliser indifféremment majuscules et miniscules. Dans une chaîne, où les caractères se représentent eux-mêmes, il existe une différence entre une lettre minuscule et la majuscule correspondante. Le caractère espace (#32) n'y est pas considéré comme un séparateur et les caractères accentués peuvent y être employés.</p>
                        </li>
                        <li>
                            <h3>Un exemple de programme Pascal :</h3>
                            <p>Considérons le programme Pascal qui traduit le premier algorithme du chapitre précédent et retrouvons les éléments de langage.</p>
<pre><code>PROGRAM Premier_Programme_Pascal ;
{édition de la longueur de la circonférence d'un cercle }

{$APPTYPE CONSOLE}		// cfr. Delphi 4

CONST PI = 3.14159 ;
VAR   rayon,circonference : REAL ;

BEGIN 
    write('Rayon : ') ;
    readLn(rayon) ;
    circonference := 2 * PI * rayon ;
    writeLn('Circonférence : ',circonference) ;
    readLn
END.</code></pre>
                            <p><span class="em">symboles spéciaux :</span> ; = ( ) * , := . : { }</p>
                            <p><span class="em">mots réservés :</span> PROGRAM CONST VAR BEGIN END</p>
                            <p><span class="em">identificateurs standard :</span> write readlin writeln</p>
                            <p><span class="em">identificateurs :</span></p>
                            <ul>
                                <li>
                                    <p>de programme : Premier_Programme_Pascal</p>
                                    <li>
                                        <p>de constante : PI</p>
                                    </li>
                                    <li>
                                        <p>de variable : rayon circonference</p>
                                    </li>
                                </li>
                            </ul>
                            <p><span class="em">commentaires :</span> {édition ... cercle}</p>
                            <p><span class="em">directive de compilation :</span> {$APPTYPE CONSOLE}</p>
                            <p><span class="em">chaînes de caractères :</span> 'Rayon : ' 'Circonférence : '</p>
                            <p><span class="em">nombre entier :</span>2</p>
                            <p><span class="em">nombre réel :</span>3.14259</p>
                            <p class="em">Remarque : très souvent, dans la suite du cours, nous omettrons la directive de compilation (ainsi que le readLn final). Il est bien certain cependant, que dans l'environnement Delphi 4, vous devrez l'insérer si vous désirez construire une application console !</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="entete_partie_declaration">En-tête et partie déclaration :</h2>
                    <ol>
                        <li>
                            <h3>Structure générale d'un programme :</h3>
                            <p>Un programme Pascal est constitué d'un en-tête de programme suivi par un bloc de programme.</p>
                            <p>Le bloc est divisé en une partie déclaration dans laquelle sont définis tous les objets locaux au programme, et une partie instructions qui spécifie les actions à exécuter sur ces objets. Ainsi, toute variable apparaissant dans une instruction doit avoir été déclarée au préalable dans une déclaration de variable.</p>
                            <img src="../images/structure_generale_programme_Pascal.png" alt="">
                            <p>Reprenons notre premier programme Pascal et tentons d'en découvrir la structure générale.</p>
                            <img src="../images/premier_programme_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Partie déclaration :</h3>
                            <p>La partie déclaration peut elle-même être divisée en plusieurs déclarations : de labels, de constantes, de types, de variables, de procédures et de fonctions. Contraitrement au Pascal Objet, le Pascal standard impose que ces déclarations - si elles existent - se fassent une seule fois et dans un certain ordre. Cette façon de procéder manque de souplesse.</p>
                            <img src="../images/partie_declaration_Pascal.png" alt="">
                            <p class="em">Remarque : La partie déclaration peut être absente, comme  dans l'exemple suivant :</p>
<pre><code>program qui_ne_fait_rien ;
BEGIN
END.</code></pre>
                            <p>Nous ne nous intéresserons dans les paragraphes suivants qu'aux déclarations de constantes et de variables.</p>
                        </li>
                        <li>
                            <h3>Déclaration des constantes :</h3>
                            <p>On devrait parler plutôt de définition de constante; celle-ci permet d'introduire un identificateur comme synonyme d'une expression constante. Une expression constante est une expression qui peut être évaluée lors de la compilation, sans qu'il soit nécessaire d'exécuter le programme.</p>
                            <p>Exemples :</p>
<pre><code>const PI = 3.14159 ;
      MESSAGE = 'Hello, world' ;
      CARACT = 'F' ;
      NBRCAR = ORD('Z') - ORD('A') + 1 ;
      MIN = 1 ;
      MAX = 100 ;
      CENTRE = (MAX - MIN) DIV 2 ;</code></pre>
                            <img src="../images/declaration_constantes" alt="">
                            <p>Il existe des identificateurs de constantes standard comme MAXINT qui représente le plus grand entier (INTEGER). Sa valeur, dans une implémentation 32 bits, est +2147483647 soit 2<sup>31</sup> - 1.</p>
                            <p>L'utilisation d'identificateurs de constante rend un programme plus lisible, facilite sa documentation et certaines modifications.</p>
                            <p>Remarques :</p>
                            <ul>
                                <li>
                                    <p>Les fonctions standard suivntes sont autorisées dans les expressions constantes : <span class="html">Abs</span>, <span class="html">Addr</span>, <span class="html">Chr</span>, <span class="html">Hi</span>, <span class="html">high</span>, <span class="html">Length</span>, <span class="html">Lo</span>, <span class="html">Low</span>, <span class="html">Odd</span>, <span class="html">Ord</span>, <span class="html">Pred</span>, <span class="html">Ptr</span>, <span class="html">Round</span>, <span class="html">SizeOf</span>, <span class="html">Succ</span>, <span class="html">Swap</span>, <span class="html">Trunc</span>.</p>
                                </li>
                                <li>
                                    <p>Notre Pascal possède un identificateur prédéclaré <span class="html">pi</span>. Il s'agit non d'une constante, mais d'une fonction arithmétique qui renvoie la valeur <span class="em">3.141592653587932385</span>. Si, comme dans notre exemple, nous avons redéclaré <span class="em">pi</span>, nous n'avons plus accès à cette fonction.</p>
                                </li>
                                <li>
                                    <p>Il permte la définition de constantes typées. Une constante typée est une variable spécifiant une valeur initiale et qui ne peut pas être mdoifiée.</p>
<pre><code>const max : integer = 100 ;
    titre : string = 'Les constantes typées' ;</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Déclaration des variables :</h3>
                            <p>Déclarer une variable, c'est donner un nom à une variable. C'est aussi lui associer un type ce qui détermine les valeurs qu'elle peut prendre, les opérations dont elle peut faire l'objet et son encombrement mémoire.</p>
                            <p>Chaque variable ne peut faire l'objet que d'une seule déclaration dans une partie déclarative donnée. Cette déclaration implique la réservation, <span class="em">si c'est approprié</span>, d'une place en mémoire. Rappelons qu'en Pascal, les variables ne possèdent pas de valeur initiale définie. Les variables déclarées dans le bloc du programme sont appelées variables globales; ce sont les seules que nous connaissons pour l'instant.</p>
                            <p>Une déclaration de variables consiste en une liste d'idnetificateurs de variables et un type associé.</p>
                            <img src="../images/declaration_variables_Pascal.png" alt="">
                            <p><span class="html">&lt;type&gt;</span> représente soit un identificateur de type, soit un descripteur de type.</p>
                            <p>Exemples :</p>
<pre><code>var racine, quotient : REAL ;
    compteur, x, y : INTEGER ;
    reponse : CHAR ;
    trouve, continue : BOOLEAN ;</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="partie_instruction">Partie instruction :</h2>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La partie instruction définit les instructions ou actions algorithmiques exécutées dans le bloc.</p>
                            <img src="../images/partie_instruction_Pascal.png" alt="">
                            <p>Délimitée par les mots réservés <span class="html">begin</span> et <span class="html">end</span>, la partie instruction se compose d'une instruction ou d'une suite d'instructions séparées par <span class="em">;</span>. Le point-virgule, en Pascal, est un séparateur d'instructions, alors que dans d'autres langages, il termine une instruction. Dans l'exemple du programme <span class="em">qui_ne_fait_rien</span>, l'instruction était l'instruction vide.</p>
                        </li>
                        <li>
                            <h3>Instructions simples :</h3>
                            <p>Il en existe de quatre sortes en Pascal :</p>
                            <ul>
                                <li>
                                    <p>instructin d'affectation</p>
                                </li>
                                <li>
                                    <p>appel de procédure</p>
                                </li>
                                <li>
                                    <p>instruction goto</p>
                                </li>
                                <li>
                                    <p>instruction vide</p>
                                </li>
                            </ul>
                            <ol>
                                <li>
                                    <h4>L'instruction d'affectation :</h4>
                                    <p>L'instruction d'affectation remplace la valeur d'une variable par une nouvelle valeur. Cette nouvelle valeur est spécifiée par une expression qui doit être du même type ou du moins d'un type compatible avec le type de la variable.</p>
<pre><code>&lt;variable&gt; := &lt;expression&gt;</code></pre>
                                    <p>Exemple :</p>
                                    <p>LDA : <span class="em">circonference &lt;--- 2 * pi * rayon</span></p>
                                    <p>Pascal : <span class="em">circonference := 2 * pi * rayon</span></p>
                                </li>
                                <li>
                                    <h4>L'instruction de procédure :</h4>
                                    <p>Une procédure est un sous-programme qui produit un effet. Il en existe des prédéclarées que vous pouvez appeler par des instructions de procédure. Il suffiit, pour ce faire, de spécifier l'identificateur de procédure ainsi que les paramètres nécessaires. Nous nous intéresserons aux procédures de lecture (entrées) et d'écriture (sorties).</p>
                                    <ul>
                                        <li>
                                            <p>À l'instruction LDA <span class="em">lire</span> correspond les procédures <span class="html">read</span> et <span class="html">readln</span>,</p>
                                        </li>
                                        <li>
                                            <p>Et à l'instruction <span class="em">écrire</span> les procédures <span class="html">write</span> et <span class="html">writeln</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="types">Types :</h2>
                    <ol>
                        <li>
                            <h3>Valeurs, variables et types :</h3>
                            <p>De manière générale, les programmes expriment des calculs sur des <span class="em">valeurs</span>. Cependant, les valeurs ne sont pas le seul genre d'objet qui apparaissent dans les programmes algorithmiques. En effet, les valeurs produites par l'exécution séquentielle des programmes peuvent être à mémoriser explicitement pour une utilisation ultérieure. Pour ce faire, un deuxième genre d'objet est nécessaire : les variables. Ces objets ont non seulement des propriétés logiques, mais aussi une représentation physique : les valeurs sont représentées par des emplacements en mémoire (chaque emplacement correspond à une adresse). Tous ces objets, c'est l'évidence, ne possèdent pas les mêmes propriétés : les nombres réels ne se manipulent pas comme les nombres entiers, les opérateurs relationnels produisent des valeurs logiques, les valeurs diffèrent des variables...</p>
                            <p>Quel que soit leur genre, tous ces objets ont leurs propriétés propres que l'on caractérise par un <span class="em">type</span>.</p>
                            <p>Les langages algorithmiques associent aux objets en général et aux valeurs en particulier des types. Chaque type spécifie :</p>
                            <ul>
                                <li>
                                    <p>un ensemble d'objets, par ex. des valeurs entières,</p>
                                </li>
                                <li>
                                    <p>un ensemble de propriété que ces objets doivent satisfaire <span class="em">et</span></p>
                                </li>
                                <li>
                                    <p>un ensemble d'opérations qui utilisent ces objets comme opérandes ou les produisent comme résultats.</p>
                                </li>
                            </ul>
                            <p>Ainsi, à chaque objet sera associé un type, et tous les objets d'un même type auront des propriétés communes, caractéristiques de ce type.</p>
                            <p>Dans le langage courant, nous disons qu'une valeur tel qu'une valeur tel que 12345 ou une variable x sont de type entier ... qu'en Pascal on définit par l'identificateur de type INTEGER. En toute rigueur, cela est inexact.</p>
                            <p>Une valeur entière et une variable entière sont deux objets qui ont des propriétés bien différentes :</p>
                            <ul>
                                <li>
                                    <p>12345 appartient au type INTEGER.</p>
                                    <p>À ce type correspond un ensemble de valeurs entières, des propriétés (<span class="em">ces valeurs sont ordonnées</span>) et des opérations (<span class="em">l'addition, la soustraction ...</span>).</p>
                                </li>
                                <li>
                                    <p>par contre, x dénote une variable entière qu'on devrait spécifier de type VAR INTEGER. Les opérations que nous connaissons sur de telles variables sont :</p>
                                    <ul>
                                        <li>
                                            <p>sa déclaration (var x : Integer;)</p>
                                        </li>
                                        <li>
                                            <p>l'affectation (x:= 12345)</p>
                                        </li>
                                        <li>
                                            <p>la prise de valeur (y := x +3)</p>
                                        </li>
                                    </ul>
                                    <p>À gauche du signe d'affectatipn, x dénote une variable et est de type VAR INTEGER. Il en est de même à droite, mais il doit être clair que l'addition + 3 est à effectuer sur la <span class="em">valeur</span> de cette variable. l'opération <span class="em">prise de valeur</span> est ici à effectuer bien qu'aucun opérateur ne la désigne : elle est implicitement spécifiée par le contexte.</p>
                                    <p>On appelle <span class="em">opération implicite</span> une opération à laquelle ne correspond aucun opérateur. L'opération prise de valeur est donc une opération implicite auquel correspond une transformation de type VAR INTEGER &#8594; INTEGER.</p>
                                    <p>Remarque : vous pouvez écrire <span class="em">z := w</span> ou <span class="em">z := (w)</span> mais non <span class="em">(z) := w</span> !</p> 
                                </li>
                            </ul>
                            <p>Les langages algoirithmiques sont définis de telle sorte que toutes les valeurs d'un type T donné puissent être représentées par des chaînes de bits de même taille. Il s'ensuit que toutes les variables du type T peuvent être représentées par des emplacements mémoire de même taille et que chacun de ces emplacements pourra contebur la représentation de n'importe quelle valeur du type T.</p>
                            <p>Il doit bien être évident cependant qu'à chaque classe de valeurs va correspondre une classe de variables de même structure. Dans la suite de ce cours, nous parlerons par abus de langage, d'une variable de type INTEGER par exemple, vius saurez ce que cela recouvre implicitement. Rappelons que contrairement à une variable, une valeur telle 12345 est supposée exister en dehors de toute exécution.</p>
                            <p>Un littéral (12345), une expression (12000+345), une constante (CONST N = 12345), un identificateur de variable après l'opération de prise de valeur peuvent dénoter la même valeur.</p>
                            <p>Lorsque nous parlons de variables, il peut s'agir, selon le contexte, des variables algorithmiques, de variables de programme ou de variables d'état. Une variable d'état est caractérisée comme une variable de programme par un identificateur et un type. Elle est par contre la seule pour laquelle nous pouvons parler d'allocation mémoire et de valeur. Cependant, par référence aux variables d'état, nous dirons d'une variable de programme qu'elle est... <span class="em">déclarée</span> lorsque sont connus identificateur et son type, <span class="em">définie</span> lorsqu'elle est déclarée et que l'on peut faire référence à son allocation physique en mémoire, <span class="em">initialisée</span> lorsqu'elle est définie et qu'une valeur lui a été associée (d'après Cardon et Charras).</p>
                        </li>
                        <li>
                            <h3>Introduction :</h3>
                            <p>Il existe en Pascal Objet sept classes majeures de types.</p>
                            <img src="../images/classes_majeures_types_Pascal.png" alt="">
                            <p>Ces différentes classes sont décrites dans la suite du cours. Nous nous intéresserons dans ce chapitre aux types simples.</p>
                        </li>
                        <li>
                            <h3>Types simples :</h3>
                            <p>Les types simples sont comme leurs noms l'indiquent les types de base; pour la plupart, ce sont ceux que l'on trouve tout faits sur les ordinateurs. Ces types sont des types de valeurs simples, c'est-à-dire qui ne sont pas considérés, dans un langage donné, comme composées d'éléments discernables. Les valeurs simples sont les valeurs les plsu classiques, en particulier les nombres.</p>
                            <p>Le langage Pascal sépare les types simples en deux classes :</p>
                            <ul>
                                <li>
                                    <p>d'une part les types réels et</p>
                                </li>
                                <li>
                                    <p>d'autre part les types scalaires.</p>
                                </li>
                            </ul>
                            <p>Un type scalaire (étymologiquement scalaire signifie échelle) caractérise un ensemble fini et ordonné de valeurs. On parle aussi de type discret ou ordinal. À chaque valeur d'un type scalaire est associé un rang qui est une valeur entière (ORDINALE). Sauf dans le cas des types entiers (le rang d'un élément de type entier est la valeur de l'élément lui-même), la première valeur de tous les types scalaires est de rang 0, la suivante 1 et ainsi de suite.</p>
                            <p>Chaque valeur a un prédécesseur sauf la première et un successeur sauf la dernière (cfr ORD, PRED, SUCC).</p>
                            <p>Il existe des types simples scalaires standards (<span class="em">prédéclarés</span>) comme les types INTEGER, CHAR et BOOLEAN. D'autres doivent être <span class="em">déclarés</span> par l'utilisateur : ce sont les types énumérés et intervalle.</p>
                            <p>Tous les types scalaires partagent les propriétés suivantes :</p>
                            <p>Les fonctions standards <span class="html">low</span> et <span class="html">high</span> peuvent être appliquées à un tyê scalaire ou à une référence de variable d'un type scalaire. La fonction low renvoie la borne inférieure alors que la fonction high renvoie la borne sdupérieure de l'intervalle du type scalaire en question.</p>
                            <dl>
                                <dt>Ord, fonction</dt>
                                <dd>
                                    <p>Ord renvoie le rang d'une expression ordinale.</p>
                                    <p><span class="em">Unité :</span> System</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Ord(X):Longint;</p>
                                    <p><span class="em">Description :</span> La fonction Ord renvoie le rang d'une expression de type scalaire. X est une expression de type scalaire. Le résultat est de type Longint, sa valeur indiquant le rang de X.</p>
                                </dd>
                                <dt>Succ, fonction</dt>
                                <dd>
                                    <p>Succ renvoie le successeur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Succ(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le successeur de X.</p>
                                </dd>
                                <dt>Pred, fonction</dt>
                                <dd>
                                    <p>Pred renvoie le prédécesseur de l'argument.</p>
                                    <p><span class="em">Unité :</span> Sytem</p>
                                    <p><span class="em">Catégorie :</span> routines ordinales</p>
                                    <p class="html">function Pred(X);</p>
                                    <p><span class="em">Description :</span> X est une expression de type scalaire. Le résultat, de même type que X, est le prédécesseur de X.</p>
                                </dd>
                            </dl>
                        </li>
                        <li>
                            <h3>Les types réels :</h3>
                            <p>Classiquement, il n'existait en Pascal qu'un seul type réel : le type REAL.</p>
                            <p>Quelle définition nous en donne N.WIRTH ?</p>
                            <p>"Une valeur de type REAL est un élément du sous-ensemble des nombres réels que l'on peut représenter sur une machine donnée ...".</p>
                            <p>Actuellement, il existe six types réels fondamentaux : <span class="html">Real48</span>, <span class="html">Single</span>, <span class="html">Double</span>, <span class="html">Extended</span>, <span class="html">Comp</span> et <span class="html">Currency</span>... et un type réel générique : <span class="html">Real</span> (<span class="em">équivalent à Double</span>). À chacun de ces types réels correspond un intervalle et une précision spécifiques, indiqués dans le tableau ci-dessous (manuel de référence) :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Intervalle</th>
                                        <th>Chiffres significatifs</th>
                                        <th>Taille en octets</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Real48</td>
                                        <td>2.9 x 10<sup>-39</sup>..1.7 x 10<sup>38</sup></td>
                                        <td>11-12</td>
                                        <td>6</td>
                                    </tr>
                                    <tr>
                                        <td>Single</td>
                                        <td>1.5 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>7-8</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>Double</td>
                                        <td>5.0 x 10<sup>-45</sup>..3.4 x 10<sup>38</sup></td>
                                        <td>15-16</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Extended</td>
                                        <td>3.4 x 10<sup>-4932</sup>..1.1 x 10<sup>4932</sup></td>
                                        <td>19-20</td>
                                        <td>10</td>
                                    </tr>
                                    <tr>
                                        <td>Comp</td>
                                        <td>-2<sup>63</sup>+1..2<sup>63</sup>-1</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                    <tr>
                                        <td>Currency</td>
                                        <td>-922337203685477.5808..922337203685477.5807</td>
                                        <td>19-20</td>
                                        <td>8</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Le type Comp (Computational) est un entier de 64 bits qui contient les valeurs intégrales comprises entre -9 223 372 036 854 775 808 et 9 223 372 036 854 775 807 (-2<sup>63</sup> à 2<sup>63</sup>-1).</p>
                            <p>Le type Currency est un type de données à virgule fixe recommandé pour les calculs monétaires. Il est stocké en tant qu'entier scalaire de 64 bits avec les quatre chiffres les moins significatifs représentant implicitement qutre décimales. L'intervalle de valeurs de Currency est compris entre -922 337 203 685 477,5808 et 922 337 203 685 477,5807. Combinés avec d'autres types réels dans des affectations et des expressions, les valeurs de type Currency sont automatiquement graduées en divisant ou en multipliant par 10 000. Puisque les nombres stockés au format Currency sont des représentations exactes, les opérations sur les valeurs Currency ne sont pas sujettes à des erreurs d'arrondi.</p>
                            <p><span class="em">Remarque :</span> Le type Real48 qui correspond à l'ancien type Real est fourni pour assurer une compatibilité avec les versions précédentes de Pascal. Comme son format de stockage n'est pas natif dans la gamme CPU d'Intel, les opérations sur des valeurs de ce type sont plus lentes que d'autres types de calcul en virgule flottante. Les types Single, Double et Extended correspondent aux formats natifs des processeurs Intel Pentium, de précision simple, double et étendue.</p>
                            <p>Mathématiquement, le type réel comporte un nombre infini de valeurs. Dans tout ordinateur, cependant, une information de type réel est codée sur un nombre limité de bits. Entre deux valeurs de type réel, il n'existe pas toujours une valeur de type réel. L'arithmétique utilisée avec des valeurs de type réel peut conduire à des résultats légèrement faussés en raison des erreurs d'arrondi. Si les types entiers sont des types exacts, les types réels sont par essence des approximations ... et peuvent donc introduire des problèmes de précision et de portabilité. Les nombres réels sont représentés en notation à virgule flottante? Ils se composent d'une partie fractionnaire (la mantisse) que multiplie un exposant. Le nombre de chiffres significatifs de la mantisse et l'intervalle de valeurs possibles pour l'exposant déterminent l'intervalle et la précision du type réel.</p>
                            <p class="em">Remarque : Toutes les opérations arithmétiques sur des valeurs de type réel sont exécytées avec l'intervalle et la précision du type EXTENDED. Cette plus grande précision permet de réduire les erreurs d'arrondi, et la largeur de l'intervalle permet de réduire les risques de dépassements de capacité positifs et négatifs.</p>
                            <h4>Comparaison de réels :</h4>
                            <p>Du fait que les valeurs de type réel sont des approximations, les résultats de comparaisons de valeurs de types réels différents ne sont pas toujours conformes à l'attente.</p>
<pre><code>//...
var
    x : Single ;
    y : Double ;
    r : Real ;

begin
    x := 1 / 3 ;
    y := 1 /3 ;
    writeln(x : y) ;    // FALSE
    r := 1 / 3 ;
    writeln(r = 1 / 3) ;    // FALSE
    // ...
end.</code></pre>
                            <p>Le premier writeln affichera FALSE. Cette "inexactitude" vient de ce que la précision de x est de 7 à 8 chiffres, alors que celle de y est de 15 à 16 chiffres. Ainsi, lorsque ces deux valeurs sont converties en type extended, elles ne coïncident que sur 7 ou 8 chiffres. De la même manière, le deuxième writeln affichera FALSE puisque le résultat de 1/3 est calculé avec 20 chiffres significatifs.</p>
<pre><code>//...
var
    s : Single ; d : Double ; e : extended ;
begin
    s := 1 / 3 ; d := 1 / 3 ; e := 1 / 3 ;
    writeln(s : 20 : 17) ;  // 0.33333334326744080
    writeln(d : 20 : 17) ;  // 0.33333333333333331
    writeln(e : 20 : 17) ;  // 0.33333333333333333
    //...
end.</code></pre>
                            <h4>Opérations :</h4>
                            <p>Un certain nombre d'opérateurs arithmétiques binaires correspondent aux types réels.</p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Opérateurs</th>
                                        <th>Opérations</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>+</td>
                                        <td>addition réelle</td>
                                    </tr>
                                    <tr>
                                        <td>-</td>
                                        <td>soustraction réelle</td>
                                    </tr>
                                    <tr>
                                        <td>*</td>
                                        <td>multiplication réelle</td>
                                    </tr>
                                    <tr>
                                        <td>/</td>
                                        <td>division réelle</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="em">Il est à remarquer que pour l'addition, la soustraction et la multiplication réelle, il suffit qu'un des opérandes soit de type réel (l'autre pouvant être de type entier).</p>
                            <p class="em">Pour la division réelle (/), il est même permis que les deux opérandes soient de type entier; le résultat est évidemment toujours de type réel. Rappelons que le dénominateur doit être différent de zéro.</p>
                            <p>Comme pour le type entier, il existe deux opérateurs arithmétiques unaires : l'opérateur identité de signe (+) et l'opérateur inversion de signe (-).</p>
                            <p>-(-8.3) est équivalent à +8.3 ou 8.3.</p>
                            <p>Les opérateurs relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type réel; le type du résultat est évidemment booléen. Signalons pour terminer qu'un des opérandes peut être de type entier et l'autre d'un type réel.</p>
                        </li>
                        <li>
                            <h3>Types scalaires prédéclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Types entiers :</h4>
                                    <p>Pascal Objet distingue sept types fondamentaux (<span class="em">ne dépendant ni du processeur, ni du système d'exploitation</span>). Chacun d'eux représente un sous-ensemble particulier de valeurs entières.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format (en bits)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>SHORTINT</td>
                                                <td>-128..+127</td>
                                                <td>8 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>SMALLINT</td>
                                                <td>-32768..32767</td>
                                                <td>16 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGINT</td>
                                                <td>-2147483648..2147483647</td>
                                                <td>32 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>INT64</td>
                                                <td>-2<sup>63</sup>..2<sup>63</sup>-1</td>
                                                <td>64 (signé)</td>
                                            </tr>
                                            <tr>
                                                <td>BYTE</td>
                                                <td>0..255</td>
                                                <td>8 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>WORD</td>
                                                <td>0..65535</td>
                                                <td>16 (non signé)</td>
                                            </tr>
                                            <tr>
                                                <td>LONGWORD</td>
                                                <td>0..4294967295</td>
                                                <td>32 (non signé)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les types entiers génériques sont <span class="html">Integer</span> et <span class="html">Cardinal</span>. L'intervalle et le format sont ceux qui permettent les calculs entiers les plus rapides en tenant compte du processeur et du système d'exploitation sous-jacent.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Intervalle</th>
                                                <th>Format</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-32768..32767</td>
                                                <td>16-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..65535</td>
                                                <td>16-bits non signé</td>
                                            </tr>
                                            <tr>
                                                <td>INTEGER</td>
                                                <td>-2147483648..214743647</td>
                                                <td>32-bits signé</td>
                                            </tr>
                                            <tr>
                                                <td>CARDINAL</td>
                                                <td>0..4294967295</td>
                                                <td>32-bits non signé</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les propriétés de l'arithmétique ordinaire ne s'appliquent que dans la mesure où le résultat de l'opération reste dans le domaine, c'est-à-dore qu'il n'y ait pas de <span class="em">dépassement de capacité</span>. Cette restriction mise à part, toute opération sur des données entières est exacte.</p>
                                    <p>Les opérateurs suivants s'appliquent à des opérandes de type entier et produisent un résultat entier.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateurs</th>
                                                <th>Opérations</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>+</td>
                                                <td>addition entière</td>
                                            </tr>
                                            <tr>
                                                <td>-</td>
                                                <td>soustraction entière</td>
                                            </tr>
                                            <tr>
                                                <td>*</td>
                                                <td>multiplication entière</td>
                                            </tr>
                                            <tr>
                                                <td>DIV</td>
                                                <td>division entière</td>
                                            </tr>
                                            <tr>
                                                <td>MOD</td>
                                                <td>modulo (reste de la division entière)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les opérateurs DIV et MOD exigent que le second opérande soit différent de zéro.</p>
                                    <p>Les opérateur relationnels (= &lt;&gt; &lt; &lt;= &gt;= &gt;) s'appliquent également avec des opérandes de type entier; le type du résultat est évidemment booléen.</p>
                                    <p>Il existe également des opérations logiques qui s'appliquent à des entiers pour donner des entiers. Ces "entiers" doivent cependant s'interpréter comme des <span class="em">chaînes de bits</span>.</p>
                                    <p>Les opérations <span class="em">I shl J</span> et <span class="em">I shr J</span> décalent la valeur I de J bits vers la gauche pour shl, et vers la droite pour shr. Le résultat est du même type entier que I.</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Types des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not</td>
                                                <td>négation binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shl</td>
                                                <td>décalage à gauche binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                            <tr>
                                                <td>shr</td>
                                                <td>décalage à droite binaire</td>
                                                <td>entier</td>
                                                <td>entier</td>
                                            </tr>
                                        </tbody>
                                    </table>
<pre><code>program TestBin;
{$APPTYPE CONSOLE}

const ZERO : Cardinal = 0 ;
var  masque , x : Cardinal ;

begin
        write('valeur positive : ') ;
        readLn(x) ;

        masque := not(not ZERO shr 1) ;
        repeat
                if (x and masque) &lt;&gt; ZERO
                    then write('1')
                    else write('0')
                {fi} ;
                masque := masque shr 1
        until masque = ZERO ;
        writeLn   ;
        readLn
end.</code></pre>
                                    <img src="../images/TestBin.png" alt="">
                                </li>
                                <li>
                                    <h4>Type CHAR :</h4>
                                    <p>Le type CHAR comprend l'ensemble des caractères disponibles. Malheureusement il n'existe pas d'ensemble de caractères qui soit accepté par tous les ordinateurs. La définition du Pascal standard ne donne donc que des conventions générales.</p>
                                    <p>Ainsi, l'ordre des caractères doit préserver l'ordre alphabétique des lettres et l'ordre numérique des chiffres : <span class="em">'a' &lt; 'b'</span> et <span class="em">'0' &lt; '9'</span>.</p>
                                    <p>Les valeurs de type CHAR sont pourvues d'un nombre ordinal qui est un entier non négatif et qui traduit le rang de chaque caractère. L'implémentation qui est la nôtre a été décrite au chapitre 3. Le caract!re 'A' y possède le numéro d'ordre 65, 'B' 66, ... 'a' 95 et 'b' 96 ...</p>
                                    <p>Les opérateurs relationnels s'appliquent à des opérandes de type CHAR. Dans notre environnement, l'expression (<span class="em">'A' &lt; 'a'</span>) a la valeur TRUE.</p>
                                    <p>Toutes ces propriétés nous rappellent bien que le type de caracyère générique.</p>
                                    <p>Les types de caractères fondamentaux sont AnsiChar et WideChar.</p>
                                    <p>Les valeurs du type AnsiChar sont les caractères (en octets), rangés dans l'ordre du jeu de caractères ANSI étendu.</p>
                                    <p>Les valeurs du type WideChar sont les caractères (en mots), rangés dans l'ordre du jeu Unicode. Les 256 premiers caractères du jeu Unicode correspondent aux caractères ANSI.</p>
                                </li>
                                <li>
                                    <h4>Type BOOLEAN :</h4>
                                    <p>Une valeur booléenne est une des valeurs logiques "vrai" ou "faux" que l'on notera par les identificateurs de constantes prédéfinis TRUE et FALSE.</p>
                                    <p>Les opérateurs booléens sont :</p>
                                    <ul>
                                        <li>
                                            <p>la conjonction logique (AND)</p>
                                        </li>
                                        <li>
                                            <p>la disjonction logique (OR)</p>
                                        </li>
                                        <li>
                                            <p>la négation (NOT)</p>
                                        </li>
                                        <li>
                                            <p>le Pascal Objet ajoute l'opérateur XOR qui correspond au <span class="em">ou exclusif logique</span>.</p>
                                        </li>
                                    </ul>
                                    <p>Ces opérateurs "opèrent" entre variables, constantes et expressions de types booléens.</p>
                                    <h5>Opérations booléennes :</h5>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>Opérateur</th>
                                                <th>Opération</th>
                                                <th>Type des opérandes</th>
                                                <th>Type du résultat</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>not (unaire)</td>
                                                <td>négation logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>and</td>
                                                <td>et logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>or</td>
                                                <td>ou logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                            <tr>
                                                <td>xor</td>
                                                <td>ou exclusif logique</td>
                                                <td>booléen</td>
                                                <td>booléen</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Si p et q sont des variables booléennes, on a :</p>
                                    <table class="tableBalises">
                                        <thead>
                                            <tr>
                                                <th>p</th>
                                                <th>q</th>
                                                <th>p AND q</th>
                                                <th>p OR q</th>
                                                <th>p XOR q</th>
                                                <th>NOT p</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                                <td>TRUE</td>
                                            </tr>
                                            <tr>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>FALSE</td>
                                                <td>TRUE</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Les autres fonctions logiques (il y en a seize en tout !) peuvent être construites grâce aux opérateurs de relation.</p>
                                    <h5>Lois de de Morgan :</h5>
                                    <p>Les lois de de Morgan sont souvent très utiles si l'on désire, par exemple, passer d'une condition de continuation à la condition de terminaison inverse.</p>
                                    <p>NOT (p OR q) = NOT p AND NOT q</p>
                                    <p>NOT (p AND q) = NOT p OR NOT q</p>
                                    <p>Exemple : le complémentaire de l'expression booléenne <span class="em">(x &gt;= 15) OR (y &lt; 4)</span> est <span class="em">(x &lt; 15) AND (y &gt;= 4)</span>.</p>
                                    <p>Le type booléen est ordonné; il est en effet prédéfini de façon à ce que FALSE &lt; TRUE. AU niveau format interne des données, un type booléen est stocké comme un octet qui peut prendre la valeur 0 (FALSE) et 1 (TRUE).</p>
                                    <p>En fait, le type booléen est un type énuméré.</p>
                                    <p>Comme le type booléen est un type scalaire ordonné, nous pouvons définir simplement toutes les fonctions logiques.</p>
                                    <p>Si p et q sont deux booléens :</p>
                                    <p>p &lt;= q définit l'implication</p>
                                    <p>p = q définit l'équivalence</p>
                                    <p>p &lt;&gt; q définit le ou exclusif</p>
                                    <h5>Entrées-Sorties :</h5>
                                    <p>S'il est possible d'imprimer une valeur booléenne, il est par contre impossible de lire <span class="em">directement</span> un booléen !</p>
<pre><code>program TestBool;
{$APPTYPE CONSOLE}

var nbre1, nbre2 : Integer ;
    croissant    : Boolean ;
begin
        write(' Entrez deux entiers : ') ;
        readLn(nbre1,nbre2) ;
        croissant := nbre1 &lt;= nbre2 ;
        writeln('ordre croissant : ', croissant) ;

        readLn
end.</code></pre>
                                    <img src="../images/TestBool.png" alt="">
                                    <p>Remarques : l'instruction test := Nbre1 &lt; Nbre2 est péférable à l'instruction conditionnelle :</p>
<pre><code>if Nbre1  &lt;=  Nbre2
    then test := true
    else test := false
{fi}</code></pre>
                                    <p>Signalons enfin que les types ByteBool, WordBool et LongBool existent pour proposer une compatibilité avec l'environnement Windows et certains langages.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Types scalaires déclarés :</h3>
                            <ol>
                                <li>
                                    <h4>Type énuméré :</h4>
                                    <p>Nous pouvons définir un nouveau type simple en énumérant toutes les valeurs distinctes qui le composent. Les valeurs de ce nouveau type sont représentées par des identificateurs et sont donc des constantes du nouveau type.</p>
                                    <p>La définition d'un type énuméré de la forme :</p>
<pre><code>Type enum = (c1,c2,...,cn) ;</code></pre>
                                    <ul>
                                        <li>
                                            <p><span class="em">enum</span> est l'identificateur du nouveau type.</p>
                                        </li>
                                        <li>
                                            <p><span class="em">c1,c2,...,cn</span> sont les nouveaux identificateurs de constantes.</p>
                                        </li>
                                    </ul>
                                    <p>Exemples :</p>
<pre><code>Type Tcouleur = (BLEU,JAUNE,VERT,ROUGE) ;
     Tjour = (LU,MA,ME,JE,VE,SA,DI) ;
     TAssaisonnement = (HUILE,VINAIGRE,SEL,POIVRE) ;
     Tchoix = (AM,STRAM,GRAM) ;
     Tnote = (UT,RE,MI,FA,SOL,LA,SI) ;</code></pre>
                                    <p>La définition de chacun de ces types introduit :</p>
                                    <ul>
                                        <li>
                                            <p>un nouvel identificateur de type (<span class="em">TChoix</span> par ex.)</p>
                                        </li>
                                        <li>
                                            <p>l'ensemble des identificateurs dénotant les valeurs de ce nouveau type (AM,STRAM,GRAM).</p>
                                        </li>
                                    </ul>
                                    <p>Nous pouvons dès lors utiliser ces identificateurs comme des constantes.</p>
                                    <p>Les identificateurs qui dénotent les valeurs d'un nouveau type correspondent à des constantes et s'utilisent comme telles. Il convient évidemment de ne déclarer une constante que dans une seule déclaration de type. Ainsi, les déclarations suivantes sont <span class="em">erronées</span> :</p>
<pre><code>Type Fruit = (pomme,orange,pore) ;
     Color = (bleu,rouge,orange) ;</code></pre>
                                    <p>Suppons les déclarations de variables suivantes :</p>
<pre><code>var col1, col2 : TCouleur;
    ch : TChoix;
    n : TNote;</code></pre>
                                    <p>nous pouvons écrire :</p>
<pre><code>col1 := ROUGE ;  // col1 := TCouleur(3) ;
col2 := VERT ;  // col2 := TCouleur(2) ;
n := FA ;   // n := TNote(3) ;
ch := GRAM ;    // ch := TChoix(2) ;</code></pre>
                                    <p>Comme dans tout type scalaire, il existe un ordre; cet ordre est déterminé par l'ordre d'écriture des identificateurs de constantes dans la déclarative.</p>
<pre><code>BLEU &lt; JAUNE &lt; VERT &lt; ROUGE</code></pre>
                                    <h5>Format interne des données :</h5>
                                    <p>Les scalaires énumérés ayant moins de 256 valeurs possibles sont rangés dans un seul octet (sinon deux). Cet octet contient la valeur ordinale de la variable; la valeur ordinale correspond au rang. Le rang d'une constante énumérée est déterminé par sa position dans la séquence d'énumération, la première constante ayant le rang 0. Aussi le rang (valeur ordinale) de <span class="em">jaune</span> est <span class="em">1</span> et celui de <span class="em">rouge</span> est <span class="em">3</span>.</p>
                                    <p>Une variable de type <span class="em">TCouleur</span> (exemple <span class="em">col1</span>) pourra prendre une des quatre valeurs : BLEU, JAUNE, VERT ou ROUGE. Le domaine du type <span class="em">TCouleur</span> correspond bien à un ensemble fini et ordonné (type SCALAIRE).</p>
                                    <p>Les opérateurs relationnels (=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=) peuvent s'appliquer à tous les types énumérés tant que les deux opérandes sont de même type.</p>
                                    <p><span class="em">(col1 &lt;= col2)</span> est une expression booléenne.</p>
                                    <p><span class="em">Remarque : À propos de booléen, signalons que le type boolean est en fait un type énuméré prédéclaré : <span class="html">Type boolean = (false,true)</span></span>.</p>
                                    <p>Les fonctions standards comme ORD, PRED, SUCC peuvent être utilisées avec des arguments de type scalaire et donc énuméré.</p>
                                    <p>Les variables de type énuméré pourront également être utilisées comme compteur de boucle ou sélecteurs de cas.</p>
                                    <p>Les variables et les valeurs d'un type énuméré ne sont pas acceptées par writeln, read et readln...</p>
                                    <p>Les langages de programmation qui permettent la définition de types énumérés nous offrent un mécanisme simple d'ABSTRACTION; il contient de les utiliser toutes les fois où cela est possible. D'une part, cela augmente la lisibilité de vos programmes, d'autre part cela renforce le typage de vos données. Un typage sévère assure que chaque objet a un ensemble bien défini de valeurs et qu'un ensemble bien défini d'opérations s'applique à ces objets : cela empêche les confusions entre des concepts logiquement différents.</p>
                                    <p>Dans des langages plus anciens, il est souvent nécessaire d'implémenter des concepts comme les types énumérés à l'aide de types plus primitifs tels que les entiers et de donner des valeurs telles 0, 1, 2 et 3 à des vakeurs comme bleu, jaune, vert et rouge. Des affectations accidentelles comme col1 := col2 + 10 ne peuvent alors être détectées par le compilateur (il y a pourtant une double erreur : au niveau de l'oépration + et au niveau du domaine des valeurs).</p>
                                </li>
                                <li>
                                    <h4>Type intervalle :</h4>
                                    <p>On constate souvent qu'une variable doit prendre ses valeurs dans un intervalle de valeurs bien déterminé. Il est alors intéressant de définir un nouveau type (sous-type), caractérisé par un ensemble de valeurs qui est un sous-ensemble de valeurs d'un autre type de base, type associé ou type hôte.</p>
                                    <p>Un type de données peuvent être défini comme un intervalle d'un autre type scalaire déjà défini. Cette définition donne la plus petite et la plus grande valeur de l'intervalle. La première constante spécifie la borne inférieure et ne dois pas être plus grande que la deuxième constante, la borne supérieure (ces deux constantes sont du même type scalaire).</p>
                                    <p>Un type intervalle conserve toutes les priorités du type scalaire associé; il n'y a aucun moyen de restreindre l'ensemble des opérations du type de base ! Il n'est restreint que dans l'échelle de ses valeurs; c'est pourquoi on peut parler de <span class="em">sous-type</span>.</p>
                                    <p>Exemples :</p>
<pre><code>type TJour = (LU,MA,ME,JE,VE,SA,DI) ;
     THeure = 0..60 ;
     TMajuscule = 'A'..'Z' ;
     Travail = LU..VE ;</code></pre>
                                    <p>Le type Travail est un sous-type du type TJour qui doit être défini préalablement.</p>
                                    <p>Si nous déclarons <span class="em">var h : THeure ;</span>, l'affectation <span class="em">h := 15</span> est correcte alors que <span class="em">h := 90</span> ne l'est pas.</p>
                                    <p>Pascal permet lors de la déclaration de variables, l'utilisation de descripteurs de type à la place d'identificateurs de type :</p>
<pre><code>var x : 17..87 ;</code></pre>
                                    <p>plutôt que :</p>
<pre><code>type TInter = 17..87 ;
var x : TInter ;</code></pre>
                                    <p>Nous vous déconseillons un tel raccourci, et même nous vous conseillons la forme déclaratice suivante :</p>
<pre><code>const MAX = 87 ;
      MIN = 17 ;
type TInter = MIN..MAX ;
var x : TInter ;</code></pre>
                                    <p class="em">Remarques : Supposons les déclarations de variables suivantes :</p>
<pre><code>var x : TInter ;
    y : Integer ;</code></pre>
                                    <p class="em">Nous l'avons signalé, une affectation tel que <span class="html">x := 15000</span> est incorrecte; elle sera décelée par le compilateur : il s'agit d'un <span class="html">CONTRÔLE STTAIQUE</span> c'est-à-dire liké au texte.</p>
                                    <p class="em">Par contre l'affectation <span class="html">x := y</span> est parfaitement légale du point de vue syntaxique. Bien sûr, à l'exécution, la valeur de la variable y peut être ou non dans l'intervalle MIN..MAX. Si cette valeur y est comprise, tout va bien; sinon une erreur doit être signalée. Il s'agit alors d'un <span class="html">CONTRÔLE DYNAMIQUE</span> c'est-à-dire lié à l'exécution. L'affectation <span class="html">y := x</span> marchera évidemment toujours.</p>
                                    <p class="em">Pascal Objet n'introduit pas <span class="html">automatiquement</span> des tests de validité à l'exécution. Il convient, pour ce faire, d'activer la vérification des limites.</p>
                                    <q class="em">Une déclaration de type intervalle n'introduit pas vraiment de nouveau type mais plutôt un sous-type, c'est-à-dire un sous-ensemble défini au moyen d'une constrainte (la restriction ne s'appliquant qu'aux valeurs).</q>
                                    <p class="em">Le rang de chaque valeur d'un intervalle est celui qu'elle a dans le type de base.</p>
                                    <img src="../images/type_intervalle_Pascal.png" alt="">
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Procédures et fonctions standards :</h3>
                            <p>Vous connaissez déjà des procédires prédéclarées comme write et writeln.</p>
                            <p>Pascal Objet propose les procédures de décrémentation (dec) et d'incrémentation (inc).</p>
                            <p>Si x est une variable de type scalaire et n une expression facultative de type entier alors :</p>
                            <ul>
                                <li>
                                    <p>dec(x) correspond à l'instruction x := x - 1</p>
                                </li>
                                <li>
                                    <p>dec(x,n) correspond à l'instruction x := x - n</p>
                                </li>
                                <li>
                                    <p>inc(x) correspond à l'instruction x := x + 1</p>
                                </li>
                                <li>
                                    <p>inc(x,n) correspond à l'instruction x := x + n</p>
                                </li>
                            </ul>
                            <p>Les procédures dec et inc génèrent un code optimisé.</p>
                            <p>Une foncion est un sous-prgramme qui renvoie une valeur; d'un point de vue syntaxique et sémantique, une fonction correspond à une expression.</p>
                            <p>Il existe ainsi une série de fonctions mathématiques prédéfinies qui facilitent la programmation en Pascal :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Fonction</th>
                                        <th>Valeur</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>abs(x)</td>
                                        <td>valeur absolue de x</td>
                                    </tr>
                                    <tr>
                                        <td>arcTan(x)</td>
                                        <td>arc dont la tangente est x</td>
                                    </tr>
                                    <tr>
                                        <td>cos(x)</td>
                                        <td>cosinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>exp(x)</td>
                                        <td>exponentielle de x : e<sup>x</sup></td>
                                    </tr>
                                    <tr>
                                        <td>frac(x)</td>
                                        <td>partie fractionnaire de x</td>
                                    </tr>
                                    <tr>
                                        <td>int(x)</td>
                                        <td>partie entière de x</td>
                                    </tr>
                                    <tr>
                                        <td>ln(x)</td>
                                        <td>logarithme naturel de x</td>
                                    </tr>
                                    <tr>
                                        <td>pi</td>
                                        <ts>valeur de pi</ts>
                                    </tr>
                                    <tr>
                                        <td>sin(x)</td>
                                        <td>sinus de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqr(x)</td>
                                        <td>carré de x</td>
                                    </tr>
                                    <tr>
                                        <td>sqrt(x)</td>
                                        <td>racine carrée de x</td>
                                    </tr>
                                </tbody>
                            </table>
<pre><code>program TestFonctionsArithmetiques ;
{$APPTYPE CONSOLE}

var r : Real ;
    i : Integer ;

begin
    i := abs(-123) ;
    r := sqr(12.3) ;
    writeln(i) ;               	{123}
    writeln(r:8:4) ;	 		{151.2900}
    writeln(sqrt(r):8:4) ;	 	{ 12.3000}

    readLn
end.</code></pre>
                        </li>
                        <li>
                            <h3>Règles de priorité :</h3>
                            <p>Une expression est une phrase de programme spécifiant un calcul sur un ou des opérandes et dont l'exécution produit un résultat. Telle que nous l'envisageons ici, une expression renvoie une valeur.</p>
                            <p>Dans l'évaluation d'une expression où interviennent plusieurs opérateurs, il convient d'éliminer toute ambiguïté dans l'ordre de réalisation des opérations. Chaque langage définit pour ce faire certaines règles et associé à chaque opérateur une priorité.</p>
                            <p>Le langage Pascak divise l'ensemble des opérateurs en catégories hiérarchiques (du plus prioritaire au moins prioritaire) :</p>
                            <ul>
                                <li>
                                    <p>le moins unaire</p>
                                </li>
                                <li>
                                    <p>les opérateurs not, @</p>
                                </li>
                                <li>
                                    <p>les opérateurs multiplificatifs (*, /, DIV, MOD, AND, SHL, SHR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs additifs (+, -, OR, XOR ...)</p>
                                </li>
                                <li>
                                    <p>les opérateurs relatinnels (=, &lt;&gt;, &lt;=, &gt;=, &lt;, &gt;, IN, IS ...)</p>
                                </li>
                            </ul>
                            <p>Considérons un opérande entre deux opérateurs :</p>
                            <ul>
                                <li>
                                    <p>Si les opérateurs sont de même priorité, l'opérande sera liée à l'opérateur de gauche sinon au plus prioritaire.</p>
<pre><code>2 + x * 4 &lt;=&gt; 2 + (x * 4) { * plus prioritaire }
3 * x /2 &lt;=&gt; (3 * x) / 2 { même priorité =&gt; opérateur de gauche }</code></pre>
                                </li>
                                <li>
                                    <p>Afin de traiter leur résultat comme un seul opérande, les expressions contenues entre parenthèses sont évaluées en premier lieu. Nous vous conseillons d'utiliser les parenthèses.</p>
                                    <p>Exemple :</p>
                                    <p>Si on attribue respectivement aux variables entières a, b et c les valeurs 8, 15 et -4, comment sera évaluée l'expression numérique suivante :</p>
<pre><code>2 * ((a mod 5) * (4 + (b -3) / sqr (c + 2)))</code></pre>
                                    <img src="../images/regles_priorites_Pascal.png" alt="">
                                </li>
                            </ul>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="instructions_structurees">Instructions structurées :</h2>
                    <p class="em">Nous allons au cours de ce chapitre étudier deux nouvelles instructions structurées : l'instruction "FOR" qui est une répétitive et l'instruction "CASE" qui est une conditionnelle particulière.</p>
                    <ul>
                        <li>
                            <p>L'instruction IF dans le choix entre deux éventualités selon la valeur booléenne d'une expression. L'instruction CASE, ou instruction de sélection, permet de choisir entre n éventualités selon la valeur discrète d'une expression appelée expression de sélection. Cette instruction permettra donc à votre programme d'effectuer - sous certaines conditions - un choix parmi plusieurs possibilités sans devoir employer des quantités d'instructions IF.</p>
                        </li>
                        <li>
                            <p>L'instruction FOR s'utilisera lorsque l'on désirera lorsque l'on désirera un certain traitement un nombre précis de fois.</p>
                        </li>
                    </ul>
                    <p>Ces deux instructions ont en commun le fait qu'elles sont à la fois limitées et puissantes.</p>
                    <p>Une autre caractéristique commune est le fait qu'elles ne sont pas "standardisées". D'un langage algorithmique à l'autre et même parfois d'une implémentation à l'autre d'un même langage, des variantes significatives existent.</p>
                    <p>Proposer dans ce cas une forme générale de ces instructions en L.D.A est difficile. Tout au plus, pouvons-nous proposer une traduction L.D.A des instructions "CASE" et "FOR" Pascal !</p>
                    <p>Par exemple :</p>
<pre><code>cas où (expression de sélection) vaut
    v1 : traitement1
    v2 : traitement2
    ... : ...
    autres cas : traitementN
fincas

pour Vc allant de Vi à Vf par pas de +1 faire
    traitement
fpour</code></pre>
                    <p>Avant de passer à l'étude détaillée de ces deux instructions, il peut être intéressant de signaler qu'il existe dans certains langages une instruction de sélection généralisée sans sélecteur que l'on nomme choix multiple.</p>
                    <p>La forme L.D.A du choix multiple pourrait être la suivante :</p>
<pre><code>cas où
        condition1 : traitement1
        condition2 : traitement2
        ...
        autre cas : traitementN
fincas</code></pre>
                    <p>Dans un choix multiple, les conditions sont mutuellement exclusives. Cette instruction peut être facilement simulée en Pascal :</p>
<pre><code>if expr1
    then instruction1
    else
        if expr2
            then instruction2
            else
                if expr3
                    then instruction3
                    else instructionN</code></pre>
                    <p>Pour éviter une cascade inutile de tests, on a tout intérêt à ordonner les tests dans le sens des probabilités décroissantes. Il n'y a, de plus, aucune raison d'imbriquer les instructions...</p>
<pre><code>if expr1 then instruction1
else if expr2   then instruction2
else if expr3   then instruction3
else    instructionN</code></pre>
                    <ol>
                        <li>
                            <h3>Instruction CASE :</h3>
                            <p>L'instruction CASE est utilisée pour choisir une action parmi plusieurs suivant la valeur d'une expression.</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_CASE_Pascal.png" alt="">
                            <p>Exemples :</p>
<pre><code>...
case abs(k) of
    0 : p := 0 ;
    1..5,7 : begin
                p := m - 1
                m := 0
             end ;
    else{case} p := m + 1
end{case}
...</code></pre>
<pre><code>case caract of
    'a', 'e', 'i', 'o', 'u', 'y' : writeln('voyelle minuscule') ;
    'A', 'E', 'I', 'O', 'U', 'Y' : writeln('voyelle majuscule') ;
    'b'..'d', 'f'..'h', 'j'..'n', 'p'..'t', 'v'..'x', 'z' : writeln('consonnes minuscules') ;
    'B'..'D', 'F'..'H', 'J'..'N', 'P'..'T', 'V'..'X', 'Z' : writeln('consonnes majuscules') ;
    '0'..'9' : writeln('chiffres')
    else{case} writeln('autres caractères ...')
end{case} ;
...</code></pre>
                            <h4>Sémantique :</h4>
                            <p>L'exécution de cette instruction conditionnelle commence par celle de l'expression de sélection qui produit une valeur V d'un type scalaire. Le choix de la liste de choix qui contient cette valeur V parmi les sélecteurs de sa liste de sélecteurs est sélectionné et l'action correspondante est exécutée.</p>
                            <p>Les sélecteurs sont aussi appelés étiquettes de cas ou encore constantes de cas; ces sélecteurs sont en effet des constantes.</p>
                            <p>Ils doivent être <span class="em">uniques</span> et d'un type scalaire compatible avec le type de l'expression de sélection. <span class="em">Dans les réalisations anciennes, Pascal Objet imposait que l'expression de sélection soit d'un type scalaire dont les bornes étaient comprises entre certaines valeurs (-32768 et 32767).</span></p>
                            <p>Que se passe-t-il si aucun des sélecteurs ne correspond à la valeur de sélection ?</p>
                            <ul>
                                <li>
                                    <p>Si la partie ELSE (autre choix) est présente, l'instruction correspondante est exécutée,</p>
                                </li>
                                <li>
                                    <p>sinon aucune instruction n'est exécutée et le traitement se poursuit par l'exécution de l'instruction (si elle existe) qui suit l'instruction CASE.</p>
                                </li>
                            </ul>
                            <p class="em">Remarques :</p>
                            <ul>
                                <li>
                                    <p class="em">En Pascal, l'instruction case possède cependant certains défauts. En absence d'une clause else, le fait qu'aucune des constantes de cas ne soit égale à la valeur de l'expression de sélection devrait constituer une ereeur.</p>
                                </li>
                                <li>
                                    <p class="em">Autre remarque qui est une constation : le else d'une instruction case peut être précédé d'un point-virgule (;) et le délimiteur final d'une construction case est le mot réservé end (auquel ne correspond aucun begin !).</p>
                                </li>
                                <li>
                                    <p class="em">Pour les différencier de leurs autres utilisations, il peut être utile d'ajouter un commentaire à ces mots réservés (cfr exemple ci-dessus else{case} et end{case}).</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Instruction FOR :</h3>
                            <p>L'instruction for indique qu'une instruction (le corps de la répétitive) doit être exécutée un nombre précis de fois, pendant qu'une variable de contrôle progresse au sein d'une intervalle de valeurs discrètes.</p>
                            <p>La variable de contrôle progresse donc entre deux valeurs fixées : la valeur initiale et la valeur finale, et cette progression est soit ascendante (TO), soit descendante (DOWNTO).</p>
                            <p>Syntaxe :</p>
                            <img src="../images/instruction_FOR_Pascal.png" alt="">
                            <p>L'emploi du mot réservé to provoque l'incrémentation d'une unité à la fois de la variable de contrôle à chaque tour de boucle, alors que l'emploi de downto en provoque la décrémentation.</p>
                            <p>L'instruction n'est pas exécutée si, en utilisant la clause to, la valeur initiale est strictement supérieure à la valeur finale ou si, en utilisant la clause downto, la valeur initiale est strictement inférieure à la valeur finale.</p>
                            <p>La variable de contrôle est une variable (<span class="em">déclarée dans le bloc contenant l'instruction for</span>) de type scalaire et les valeurs initiales et finales sont des expressions de type compatible avec la variable de contrôle.</p>
                            <p>L'instruction suivante provoquera l'affichage des valeurs de 1 à 10 :</p>
<pre><code>for compteur := 1 to 10 do write(compteur:4)</code></pre>
                            <p>Celle-ci lit n entiers et effectue leur somme :</p>
<pre><code>somme := 0 ;
for compteur := 1 to n do
    begin
        readln(nbre) ;
        somme := somme + nbre
    end ;
...</code></pre>
                            <p>Voici, comme dernier exemple un programme dont l'exécution provoquera l'affichage des jours de la semaine.</p>
<pre><code>program AfficherJourSemaine ;
{$APPTYPE CONSOLE}

type TJour = (LU,MA,ME,JE,VE,SA,DI) ;

var j : TJour ;

begin
    for j := LU TO DI DO
    case j of
        LU : writeln('lundi') ;
        MA : writeln('mardi') ;
        ME : writeln('mercredi') ;
        JE : writeln('jeudi') ;
        VE : writeln('vendredi') ;
        SA : writeln('samedi');
        DI : writeln('dimanche')
    end{case}  ;

    readLn
end.</code></pre>
                            <p>Dans de nombreux ouvrages, on retrouve l'assertion suivant laquelle l'instruction :</p>
<pre><code>for indice := expr1 to expr2 do instruction</code></pre>
                            <p>est équivalente aux instructions suivantes :</p>
<pre><code>indice := expr1 ;
while indice &lt;= expr2 do
    begin
        instruction ;
        inc(indice)
    end</code></pre>
                            <p>Il convient de relativiser cette "équivalence".</p>
                            <p>La définition du langage Pascal impose certaines restrictions au sujet de l'instruction FOR :</p>
                            <ul>
                                <li>
                                    <p>La valeur de la variable de contrôle ne peut en aucun cas être modifiée dans l'instruction qui correspond au corps de la boucle (<span class="em">Pascal Objet permet la modification de la variable de contrôle dans le corps de la boucle ! Ne profitez pas de ce laxisme coupable !</span>).</p>
                                </li>
                                <li>
                                    <p>La valeur finale est déterminée une seule fois lors de l'entrée dans la boucle for. Ainsi si expr2 correspondait à la valeur d'une certaine variable Vf, la modification de la valeur de Vf dans le corps de la boucle ne changerait pas le nombre de répétitions.</p>
                                </li>
                                <li>
                                    <p>À la sortie (normale) de l'instruction for, la valeur de la variable de contrôle est indéfinie.</p>
                                </li>
                            </ul>
                            <p>Dans le manuel de référence, l'instruction <span class="em">for v:= expr1 to expr2 do Corps</span> est dite équivalente à :</p>
<pre><code>begin
    temp1 := expr1 ;
    temp2 := expr2 ;
    if temp1 &lt;= temp2 then
        begin
            V := temp1 ;
            Corps ;
            while V &lt;&gt; temp2 do
                begin
                    V := succ(V) ;
                    Corps
                end
        end
end</code></pre>
                            <p>temp1 et temp2 sont des variables temporaires du même type que la variable de contrôle V et qui n'apparaissent nulle part ailleurs dans le programme.</p>
                            <p>Cette équivalence est <span class="em">logique</span> et l'utilisation du for générera un <span class="em">code optimisé</span> !</p>
                            <p>Application :</p>
                            <ul>
                                <li>
                                    <p>Justifiez cette équivalence.</p>
                                </li>
                                <li>
                                    <p>Réécrire les programmes du chapitre 4 où l'utilisation de l'instruction for est souhaitable.</p>
                                </li>
                            </ul>
                            <p class="em">Remarque : Curieusement, à partir de la version du Pascal Objet qui correspond à Delphi 4, la réalisation du for a changé et l'équivalence présentée ici a disparu du manuel de référence. La valeur non significative de la variable de contrôle est "égale" à succ(temp2) si l'itération a eu lieu !</p>
                            <p>Exercices :</p>
<pre><code>program WhileFor;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 31 ;
    EXPR2 : Cardinal = 39 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;

    EXPR2 := 39 ;
    k := EXPR1 ;
    while k &lt;= EXPR2 do
        begin
            write(k:4) ;
            dec(EXPR2,2) ;
            inc(k)
        end ;
    writeLn ; 
    writeLn(EXPR2) ; 
    writeLn ;
    readLn
end.</code></pre>
                            <img src="../images/WhileFor_Pascal.png" alt="">
<pre><code>program breakContinue;
{$APPTYPE CONSOLE}

var EXPR1 : Cardinal = 1 ;
    EXPR2 : Cardinal = 9 ;
    k : Cardinal ;

begin
    for k := EXPR1 to EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then continue ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4)
    end ;
    writeLn ;

    k := EXPR1 ;
    while k &lt;= EXPR2 do
    begin
        write(k:4) ;
        if k = 4 then
        begin
            inc(k) ;     // sinon vous bouclez !!!
            continue
        end  ;
        write(k:4) ;
        if k = 7 then break ;
        write(k:4) ;
        inc(k)
    end ;
    writeLn ;

    readLn
end.</code></pre>
                            <img src="../images/breakContinue_Pascal.png" alt="">
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="type_string">Type string (chaînes courtes) :</h2>
                    <p>Il existe aujourd'hui plusieurs types chaîne.</p>
                    <p>Sans parler des chaînes à zéro terminal, le Pascal Objet gère les types chaînes prédéfinis suivants (<span class="em">manuel de référence</span>) :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Longueur maximum</th>
                                <th>Mémoire nécessaire</th>
                                <th>Utilisation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ShortString</td>
                                <td>255 caractères</td>
                                <td>de 2 à 256 octets</td>
                                <td>string classique</td>
                            </tr>
                            <tr>
                                <td>AnsiString</td>
                                <td>~2<sup>31</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères sur 8 bits</td>
                            </tr>
                            <tr>
                                <td>WideString</td>
                                <td>~2<sup>30</sup> caractères</td>
                                <td>de 4 octets à 2 Go</td>
                                <td>Caractères Unicode;</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Nous nous intéresserons dans ce chapitre au type <span class="em">string classique</span> qui correspond dans les dernières versions du langage aux chaînes courtes (ShortString). <span class="em">Dans l'état par défaut {$H+}, le compilateur interprète <span class="html">string</span> comme désignant AnsiString. Utilisez la directive <span class="html">{$H-}</span> pour que string soit interprété comme désignant ShortString.</span></p>
                    <p>Nous reviendrons plus tard aux autres types chaînes et, spécialement, aux chaînes longues qui est <q>le type le mieux adapté aux utilisations les plus diverses</q>.</p>
                    <p>Une valeur de type string ou chaînes de caractères est une séquence de caractères de taille variable. Le nombre réel de caractères dans une chaîne peut varier dynamiquement - au cours de l'exécution -, entre 0 et une limite supérieure définie.</p>
                    <p>Les constantes chaînes de caractères sont évidemment compatibles avec les types chaînes de caractères.</p>
                    <ol>
                        <li>
                            <h3>Définition d'un type chaîne de caractères :</h3>
<pre><code>&lt;identificateur&gt; = string [E]</code></pre>
                            <p>L'entier <span class="em">E</span> spécifiant la taille maximale est une constante entière tel que <span class="em">1 &lt;= E &lt; 255</span>.</p>
                            <p>Mprsque l'attribut de taille n'est pas déclaré, il vaut 255 par défaut.</p>
                            <p>Exemple :</p>
<pre><code>type str20 = STRING[20];
     str8 = STRING[8]
     ligne = STRING[80];
     AnyString = STRING;</code></pre>
                            <p>Seules les variables possèdent un type string spécifique, pas les valeurs.</p>
                            <p>Soient les déclarations suivantes :</p>
<pre><code>var ch1 : str8;
    ch2 : str20;
    ch : AnyString;</code></pre>
                            <p>L'exécution de ces déclarations réservera 9 octets pour <span class="em">ch1</span>, 21 pour <span class="em">ch2</span> et 256 octets pour <span class="em">ch</span>. Une chaîne de caractères occupe en effet un octet de plus que son nombre de caractères maximum. Le premier octet contient le caractère dont le rang équivaut à la longueur courante de la chaîne.</p>
                            <p>Lors de l'affectation de la valeur d'une expression chaîne à une variable d'un certain type string, si la longueur maximum de la variable chaîne est dépassée, les caractères en trop sont éliminés.</p>
                            <p>Exemple :</p>
<pre><code>...
ch2 := 'BONJOUR MONDE !';
ch1 := ch2;
writeln(ch2);   {BONJOUR MONDE !}
writeln(ch1);   {BONJOUR}</code></pre>
                            <p class="em">Remarquez :</p>
                            <ul>
                                <li>
                                    <p class="em">que les types chaînes de caractères sont compatibles (puisque ch2 est une valeur chaîne) :</p>
<pre><code>ch1 := ch2</code></pre>
                                </li>
                                <li>
                                    <p class="em">et que l'on peut écrire une expression chaîne et lire une variable chaîne.</p>
<pre><code>...
write('Entre votre nom : ');
readln(ch);
writeln('Bonjour ', ch);
...</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Comment accéder aux éléménts d'une chaîne ?</h3>
                            <p>Nous n'avons pas encore étudié le type tableau. Signalons néanmoins que le type chaîne peut être assimilé à un type tableau possédant des caractéristiques spéciales.</p>
                            <p>Une variable d'un type chaîne pourrait être considérée comme une suite, une liste finie de variables char que l'on aurait regroupées sous un nom. Les éléments de cette liste sont rangés en des positions mémoire successives et sont repérés respectivement par un ensemble d'indices consistant en un certain nombre d'entiers consécutifs.</p>
                            <p>L'expression d'indice (de type BYTE) doit être compris dans l'intervalle 0..E où E est la longueur déclarée de la variable chaîne. Rappelons que le premier caractère d'une variable d'un type chaîne (celui qui correspond à l'indice 0) traduit en fait la longueur courante de la chaîne.</p>
                            <p>La référence à un élément d'une variable chaîne de caractères est réalisée par une référence à la variable chaîne suivie entre crochets par l'expression d'indice qui indique la position de l'élément au sein de la variable chaîne.</p>
                            <p>Exemple :</p>
                            <p>Soit la déclaration :</p>
<pre><code>var s:string[9];</code></pre>
                            <p>Après exécution de l'instruction :</p>
<pre><code>s := 'CHAINES';</code></pre>
                            <p>nous pouvons représenter la variable s de la manière suivante :</p>
                            <img src="../images/chaines_caracteres_Pascal_1.png" alt="">
                            <p><span class="em">writeln(s[2])</span> affichera le caractère '<span class="em">H</span>'.</p>
<pre><code>Program anagramme  ;
{$APPTYPE CONSOLE}

var s : string[9]  ;
    tampon : char  ;
begin
    s := 'CHAINES'   ;
    tampon := s[1]   ;
    s[1]   := s[6]   ;
    s[6]   := s[3]   ;
    s[3]   := s[2]   ;
    s[2]   := tampon ;
    writeln (s)	;      {ECHINAS}

    readLn
end.</code></pre>
                            <p>Vous ne pouvez cependant pas allonger une chaîne par cette méthode.</p>
                            <p><span class="em">s[8] := 'E'</span> n'ajoutera pas de 'E' à la fin de 'ECHINAS'.</p>
                            <p>Pour <span class="em">allonger</span> une chaîne, il faudra utiliser <span class="em">l'opérateur de concaténation (+)</span>.</p>
                            <p><span class="em">s := s + 'E'</span> ajoutera un 'E' à la fin de 'ECHINAS'.</p>
                        </li>
                        <li>
                            <h3>Comparaison de chaînes :</h3>
                            <p>Les opérateurs relationnels <span class="em">=</span>, <span class="em">&lt;&gt;</span>, <span class="em">&lt;</span>, <span class="em">&gt;</span>, <span class="em">&gt;=</span>, <span class="em">&lt;=</span> comparent deux chaînes de caractères. "L'ordre entre deux chaînes est déterminé par les relations d'ordre entre les valeurs des caractères situés en même position dans chacune des chaînes". Comme toutes les valeurs chaînes de caractères sont compatibles, toutes les chaînes peuvent être comparées.</p>
                            <ul>
                                <li>
                                    <p>Si les chaînes ne possèdent pas la même longueur, les caractères de la plus longue chaîne qui ne possèdent pas de correspondant sont considérés comme ayant une valeur supérieure.</p>
                                    <p>Ainsi l'expression <span class="em">'PASCAL' &lt; 'PASCALE'</span> a la valeur true et l'expression <span class="em">'PASCAL ' = 'PASCAL'</span> a la valeur false.</p>
                                    <p>Il est évident que <span class="em">'XZ' &gt; 'XWXYZ'</span> !</p>
                                </li>
                                <li>
                                    <p>Les chaînes vides ('') correspondent à la plus petite valeur et ne peuvent être égales qu'à d'autres chaînes vides.</p>
                                </li>
                                <li>
                                    <p>Signalons enfin qu'une valeur de type char est considérée comme une valeur chaîne de caractères de longueur 1; nous pouvons donc comparer une valeur de type char à une valeur de type chaîne.</p>
<pre><code>if s &lt; 'H'
    then ...</code></pre>
                                </li>
                            </ul>
                            <q class="em">Les fonctions standard high et low acceptent les identificateurs de type chaîne courte et les variables de ces types. High renvoie la longueur maximum du type de chaîne courte alors que low renvoie zéro.</q>
<pre><code>program lowhighstr;
{$APPTYPE CONSOLE}

type Str30 = string[30] ;
var  nom : Str30 ;
begin
    nom := 'TinTin' ;
    writeLn(low(nom)) ;          {0}
    writeLn(high(STr30)) ;       {30}

    readln
end.</code></pre>
                        </li>
                        <li>
                            <h3>Quelques fonctions prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>COPY(&lt;expr.chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">chaine := COPY(ch,p,n)</span></p>
                                    <p>La fonction <span class="html">COPY</span> renvoie une chaîne contenant <span class="em">n</span> caractères de <span class="em">ch</span> à partir de la position <span class="em">p</span>. Si <span class="em">p</span> est supérieur à la longueur de <span class="em">ch</span>, une chaîne vide est renvoyée et si <span class="em">n</span> indique un nombre de caractères qui dépasse la fin de la chaîne <span class="em">ch</span>, seuls les caractères inclus dans la chaîne sont renvoyés.</p>
<pre><code>program test_copy; 
{$APPTYPE CONSOLE}

var ch1,ch2,ch3,ch4:string;
begin
    ch1:='ABCDEFGH'    ;
    ch2:=COPY(ch1,2,3) ;
    ch3:=COPY(ch1,6,5) ;
    ch4:=COPY(ch1,10,4);
    writeLn(ch2);		{BCD}
    writeLn(ch3);		{FGH}
    writeLn(ch4);		{chaîne vide}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>CONCAT(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;,...) :</h4>
                                    <p>Exemple : <span class="em">chaine := CONCAT(ch1,ch2,ch3)</span></p>
                                    <p>La fonction <span class="html">CONCAT</span> renvoie une chaîne de <span class="em">ch1</span>, <span class="em">ch2</span>, <span class="em">ch3</span>. Si sa longueur dépasse 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractères.</p>
                                    <p><span class="em">CONCAT('AB','CDE','F')</span> retourne <span class="em">'ABCDEF'</span>.</p>
                                    <p class="em">Remarque : Pascal propose également l'opérateur + pour traduire l'opération de concaténation. Le type du résultat est le type chaîne de caractères et les types opérandes peuvent être chaîne de caractères ou caractère.</p>
                                    <p class="em">L'expression <span class="html">'AB'+'CDE'+'F'</span> a également la valeur <span class="html">'ABCDEF'</span>.</p>
                                </li>
                                <li>
                                    <h4>LENGTH(&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">longueur := LENGTH(ch)</span></p>
                                    <p>La fonction <span class="html">LENGTH</span> renvoie un entier représentant la longueur effective de la chaîne <span class="em">ch</span>.</p>
                                    <p class="em">Remarque : Le premier octet d'une chaîne contient - indirectement - la longueur courante de la chaîne; elle contient en fait le caractère dont le rang est égal à la longueur courante. Si <span class="html">ch := 'ABCDE'</span> alors <span class="html">ORD(ch[0])</span> est égal à la valeur 5.</p>
                                </li>
                                <li>
                                    <h4>POS(&lt;expr.chaîne&gt;,&lt;expr.chaîne&gt;) :</h4>
                                    <p>Exemple : <span class="em">position := POS(ss,ch)</span></p>
                                    <p>La fonction <span class="html">POS</span> renvoie un entier (BYTE) représentant la position du premier caractère de <span class="em">ss</span> dans <span class="em">ch</span>.</p>
                                    <p>Si <span class="em">ss</span>n'est pas trouvé, la valeur renvoyée par <span class="em">POS</span> est 0. Cette fonction recherche donc la première occurence d'une sous-chaîne dans une chaîne.</p>
                                    <p>Exemple : <span class="em">POS('SITI', 'POSITION')</span> retourne <span class="em">3</span> et <span class="em">POS('ST', 'POSITION')</span> retourne <span class="em">0</span>.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Quelques procédures prédéfinies sur les chaînes de caractères :</h3>
                            <ol>
                                <li>
                                    <h4>DELETE(&lt;variable chaîne&gt;,&lt;expr.entière&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">DELETE(VarStr,p,n)</span></p>
                                    <p>La procédure <span class="html">DELETE</span> supprime <span class="em">n</span> caractères à la valeur de la variable <span class="em">VarStr</span> à partir de la position <span class="em">p</span>.</p>
                                    <p>Si <span class="em">p</span> est supérieur à la longueur de la chaîne <span class="em">VarStr</span>, aucun caractère n'est supprimé. Si <span class="em">n</span> indique plus de caractères qu'il n'en reste à partir de <span class="em">p</span>, seule la fin de la chaîne correspondant à <span class="em">VarStr</span> est effacée.</p>
<pre><code>program  test_delete ; 
{$APPTYPE CONSOLE}

var ch : string[10] ;
begin
    ch := 'ABCDEFGH' ;
    delete(ch,20,3) ;
    writeln(ch) ;			{ABCDEFGH}
    delete(ch,6,10) ;
    writeln(ch) ;           {ABCDE}
    delete(ch,2,2) ;
    writeln(ch)  ;			{ADE}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>INSERT(&lt;expr.chaîne&gt;,&lt;variable chaîne&gt;,&lt;expr.entière&gt;) :</h4>
                                    <p>Exemple : <span class="em">INSERT(ch,VarStr,p)</span></p>
                                    <p>La procédure <span class="html">INSERT</span> insère l'expression chaîne <span class="em">ch</span> dans <span class="em">VarStr</span> en position <span class="em">p</span>.</p>
                                    <p>Lorsque <span class="em">p</span> est supérieure à la longueur courante de <span class="em">Varstr</span>, <span class="em">ch</span> est concaténée à <span class="em">VarStr</span>.</p>
                                    <p>Si la somme de la longueur de l'expression chaîne et de la longueur courante de la variable chaîne dépasse la longueur maximale de cette dernière, il y a évidemment "troncature" après insertion.</p>
<pre><code>program test_insert ; 
{$APPTYPE CONSOLE}

var ch : string[15] ;

begin
    ch := 'ABCDE' ;
    insert('fghijk',ch,10) ;
    writeln(ch) ;                    	{ABCDEfghijk}
    insert('xyz',ch,3) ;
    writeln(ch) ;                    	{ABxyzCDEfghijk}
    insert('mnopq',ch,7) ;
    writeln(ch) ;                     {ABxyzCmnopqDEfg}

    readLn
end.</code></pre>
                                </li>
                                <li>
                                    <h4>Str et val :</h4>
<pre><code>STR (&lt;expr.numérique [:expr.entière [:expr.entière]]&gt;;&lt;variable chaîne&gt;)</code></pre>
                                    <p>Exemple : <span class="em">STE(NombreReel:taille:NbreDec,VarStr)</span></p>
                                    <p>La procédure <span class="html">STR</span>convertit NombreReel en une chaîne de caractères en respectant les paramètres de formatage <span class="em">taille</span> et <span class="em">NbreDec</span>.</p>
                                    <p>L'expression numérique à convertir est une expression de type entier ou réel. L'effet est identique à un appel à la procédure standard write pourvues des mêmes paramètres, excepté que la chaîne résultante est chargée dans <span class="em">VarStr</span> au lieu d'être écrite dans un fichier texte.</p>
<pre><code>VAL (&lt;expr.chaîne&gt;,&lt;variable num.&gt;,&lt;variable entière&gt;)</code></pre>
                                    <p>Exemple : <span class="em">VAL(s,N,erreur)</span></p>
                                    <p>La procédure <span class="html">VAL</span> convertit une chaîne de caractères représentant une quantité en une valeur numérique. Plus précisément, si <span class="em">s</span> est une expression de type chaîne et N une variable d'un type entier ou réel, alors <span class="em">VAL</span> convertit - si possible - <span class="em">s</span> en une valeur numérique et charge le résultat dans <span class="em">N</span>.</p>
                                    <p>Si vous désirez convertir une chaîne qui représente une quantité entière, nous vous conseillons de déclarer <span class="em">N</span> de type longint, d'effectuer le contrôle des domaines de validité et enfin d'affecter la valeur entière renvoyée. La variable <span class="em">erreur</span> a la valeur zéro si tout c'est bien passé.</p>
                                    <p>Remarque : Toutes les fonctions et procédures présentées ici se trouvent dans l'unité System. Il existe également des routines de gestion de chaînes dans l'unité SysUtils.</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Fonction Copy :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Copy(S:String;Index,Count:Integer):String;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Copy renvoie une sous-chaîne d'une chaîne.</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières. Copy renvoie une chaîne de Count caractères en commençant à S[Index].</p>
                            <p>Si Index est plus grand que la longueur de S, Copy renvoie une chaîne vide.</p>
                            <p>Si Count spécifie davantage de caractères qu'il y en a de disponibles, seuls les caractères de S[Index] jusqu'à la fin de S sont renvoyés.</p>
                            <p>Exemple :</p>
<pre><code>var S: string;
begin
    S := 'ABCDEF';
    S := Copy(S, 2, 3);	{ 'BCD' }
end;</code></pre>
<pre><code>function _copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        if p &lt;= lg then
        begin
            if n &gt; lg-p+1 then n := lg-p+1 {fi} ;
            for k := p to p+n-1 
            do Result := Result + ch[k] {od}
        end
    {fi}
end ;</code></pre>
<pre><code>function __copy(ch : String;p,n : Byte) : String ;
var   k,lg : Byte ;
begin
        Result := '' ;
        lg := length(ch) ;
        k := 0 ;
        while (k+p &lt;= lg) and (k &lt; n) do
            begin
                Result := Result + ch[k+p] ;
                inc(k)
            end
        {od}
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Delete :</h3>
                            <p>Routines de gestion de chaîne (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Delete(var S:string;Index,Count:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Delete supprime une sous-chaîne de Count caractères de la chaîne S en commençant à partir de S[Index].</p>
                            <p>S est une expression de type chaîne. Index et Count sont des expressions entières.</p>
                            <p>Si Index est plus grand que la longueur de S, aucun caractère n'est supprimé. Si Count spécifie davantage de caractères qu'il y en a de disponibles après S[Index], Delete supprime le reste de la chaîne.</p>
                            <p>Exemple :</p>
<pre><code>var s: string;
begin
    s := 'Honest Abe Lincoln';
    Delete(s,8,4);
    Canvas.TextOut(10, 10, s); { 'Honest Lincoln' }
end;</code></pre>
<pre><code>procedure _delete(var ch : String ; p,n : Byte) ;
begin
    ch := CONCAT(copy(ch,1,p-1),copy(ch,p+n,length(ch)-n-p+1))
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Procédure Insert :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité :</span> System</p>
                            <p class="em">Déclaration :</p>
<pre><code>procedure Insert(Source:String;var S:String,Index:Integer);</code></pre>
                            <p class="em">Description :</p>
                            <p>La procédure Insert fusionne une sous-chaîne dans une chaîne en commençant au point spécifié.</p>
                            <p>Source est une expression de type chaîne. S est une variable de type chaîne de longueur quelconque et Index une expression entière.</p>
                            <p>Insert insère Source dans S à la position S[index]. Si la chaîne résultante excède 255 caractères, elle est tronquée après le 255<sup>ème</sup> caractère.</p>
                            <p class="em">Exemple :</p>
<pre><code>var
    S: string;
begin
S := 'Honest Lincoln';
Insert('Abe ', S, 8);      { 'Honest Abe Lincoln' }
end;</code></pre>
<pre><code>procedure _insert(ss:String;var ch:String; p:Byte) ;
begin
        ch := copy(ch,1,p-1)+ss+copy(ch,p,length(ch)-p+1)
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Fonction Pos :</h3>
                            <p>Routines de gestion de chaînes (de type Pascal).</p>
                            <p><span class="em">Unité : </span>System</p>
                            <p class="em">Déclaration :</p>
<pre><code>function Pos(Substr:string;S:string):Byte;</code></pre>
                            <p class="em">Description :</p>
                            <p>La fonction Pos recherche une sous-chaîne dans une chaîne.</p>
                            <p>Substr et S sont des expressions de type chaîne.</p>
                            <p>Pos recherche Substr dans S et renvoie une valeur entière donnant l'indice du premier caractère de Substr dans S.</p>
                            <p>Si Substr n'est pas trouvée, Pos renvoie zéro.</p>
                            <p class="em">Exemple :</p>
<pre><code>var S: string;
begin
    S := '   123.5';
    { Convertit les espaces en zéros }
    while Pos(' ', S) &gt; 0 do  S[Pos(' ', S)] := '0';
end;</code></pre>
<pre><code>function _pos(ss,ch : String) : Integer ;
var lgch,lgss,k,ich,iss : Integer ;
begin
        lgch := length(ch) ;
        lgss := length(ss) ;
        result := 0 ;
        k := 1 ;
        while(k + lgss - 1 &lt;= lgch) do
        begin
            ich := k ;
            iss := 1 ;
            while (is&lt;=lgss)and(ch[ich]=ss[iss]) do
            begin
                    inc(ich) ;
                    inc(iss) ;
            end ;
            if iss &gt; lgss then
            begin
                Result := k ;
                break
            end ;
            inc(k)
        end
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Routines de gestion de chaînes :</h3>
                            <dl>
                                <dt>AnsiCompareStr</dt>
                                <dd>Effectue une comparaison de distinction majuscule/minuscule entre deux chaînes.</dd>
                                <dt>AnsiCompareText</dt>
                                <dd>Effectue une comparaison de deux chaînes sans distinction majuscule/miniscules.</dd>
                                <dt>AnsiLowerCase</dt>
                                <dd>Convertit des caractères en minuscules.</dd>
                                <dt>AnsiUpperCase</dt>
                                <dd>Convertit des caractères en majuscules.</dd>
                                <dt>CompareStr</dt>
                                <dd>Réalise une comparaison de deux chaînes en distinguant les minuscules des majuscules.</dd>
                                <dt>CompareText</dt>
                                <dd>Réalise une comparaison de deux chaînes en ne distinguant pas les minuscules des majuscules.</dd>
                                <dt>Concat</dt>
                                <dd>Concaténation de plusieurs chaînes de caractères.</dd>
                                <dt>Copy</dt>
                                <dd>Renvoie une partie d'une chaîne de caractères.</dd>
                                <dt>Delete</dt>
                                <dd>Supprime une partie d'une chaîne de caractères.</dd>
                                <dt>Insert</dt>
                                <dd>Insère une sous-chaîne dans une chaîne.</dd>
                                <dt>IntToHex</dt>
                                <dd>Convertit un entier en valeur hexadécimale.</dd>
                                <dt>IntToStr</dt>
                                <dd>Convertit un entier en une chaîne.</dd>
                                <dt>IsValidIdent</dt>
                                <dd>Renvoie True (Vrai) si la chaîne donnée est un identificateur valide.</dd>
                                <dt>Length</dt>
                                <dd>Renvoie la taille dynamique d'une chaîne.</dd>
                                <dt>LowerCase</dt>
                                <dd>Transforme en minuscules la chaîne donnée.</dd>
                                <dt>Pos</dt>
                                <dd>Recherche une sous-chaîne dans une chaîne.</dd>
                                <dt>Str</dt>
                                <dd>Convertit une valeur numérique en une chaîne.</dd>
                                <dt>StrToInt</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>StrToIntDef</dt>
                                <dd>Convertit une chaîne en un entier.</dd>
                                <dt>UpperCase</dt>
                                <dd>Transforme en majuscule la chaîne donnée.</dd>
                                <dt>Val</dt>
                                <dd>Convertit une chaîne en sa représentation numérique.</dd>
                            </dl>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="fonctions_procedures">Fonctions et procédures :</h2>
                    <blockquote>
                        <p>"Si d'un point de vue philosophique les procédures permettent de définir une nouvelle instruction, d'un point de vue pratique elles nous donnent la possibilité d'utiliser la méthode d'analyse descendante (raffinements successifs). On peut ainsi se concentrer d'abord sur ce que l'on doit faire (et le nommer) avant de réfléchir à la façon dont on va le faire. Le Quoi faire ? avant le Comment faire ?, c'est bien cela la philosophie de l'abalyse descendante.</p>
                        <p>C'est ce que l'on nomme parfois l'abstraction procédurale.</p>
                        <p>De la même façon, on peut vouloir faire abstraction des détails d'un calcul complexe. D'un point de vue philosophique tout autant que pratique, les fonctions nous permettent de définir de nouveaux opérateurs du langage.</p>
                        <p>Le mécanisme d'abstraction procédurale est essentiel dans la conception d'un logiciel que l'on veut modulaire et fiable. L'essence même de ce mécanisme réside dans le fait que l'on peut utiliser une procédure ou une fonction sans se soucier de la façon dont elle est implémentée. Cela n'est possible que si nous savons ce que fait la procédure, c'est-à-dire que nous connaissons la syntaxe et la sémantique de son utilisation.</p>
                        <p>Si cette procédure est prédéfinie, à nous de nous ajuster à ses spécifications; si nous écrivons nous-mêmes la procédure, nous aurons à en déterminer la syntaxe et la sémantique d'appel."</p>
                    </blockquote>
                    <p>H. Paul HAIDUK.</p>
                    <ol>
                        <li>
                            <h3>Introduction :</h3>
                            <p>La résolution d'un problème passe souvent par sa décomposition en sous-problèmes et par la résolution de chacun d'eux.</p>
                            <p>Cette décomposition d'une tâche complexe en tâches élémentaires est un des concepts fondamentaux de la programmation structurée. On parle alors de développement de programmes par raffinements successifs.</p>
                            <p>En Pascal, les modules ainsi créés sont des sous-programmes qui sont soit des procédures, soit des fonctions.</p>
                            <p>Cette modularité de programmes permet :</p>
                            <ul>
                                <li>
                                    <p>une meilleure qualité de programmation</p>
                                </li>
                                <li>
                                    <p>une mise au point aisée</p>
                                </li>
                                <li>
                                    <p>une facilité de maintenance.</p>
                                </li>
                            </ul>
                            <p>Le Pascal, nous le savons, offre un certain nombre d'outils de base qui sont les procédures et fonctions standards : <span class="html">ABS</span>, <span class="html">SUCC</span>, <span class="html">SQR</span>, <span class="html">CHR</span>, <span class="html">COPY</span>, <span class="html">DELETE</span>, <span class="html">POS</span> ...</p>
                            <p>Une procédure ou une fonction apparaissent comme la définition d'un traitement.</p>
                            <p>Cependant, une fonction est assimilable à une <span class="em">valeur</span> et une procédure à une <span class="em">instruction</span>.</p>
                            <p>Ce sont en fait des sous-programmes écrits en langage machine et incorporés au Pascal. Nous ne connaissons de ces outils que les modes d'emploi.</p>
                            <p>Le langage Pascal permet de créer ses propres fonctions et procédures.</p>
                        </li>
                        <li>
                            <h3>Les fonctions :</h3>
                            <ol>
                                <li>
                                    <h4>Rappel mathématique :</h4>
                                    <p>En mathématique, l'utilisation d'une fonction f permet d'obtenir la valeur f(x<sub>0</sub>) de la fonction pour une valeur x<sub>0</sub> de la variable.</p>
                                    <p>Soit la fonction f(x) = x<sup>2</sup> - 2x + 3, nous aurons f(2) = 3, f(5) = 18, ...</p>
                                </li>
                                <li>
                                    <h4>Fonctions en Pascal :</h4>
                                    <p>En Pascal, une fonction se définit comme une structure de programme autonome dont le but consiste à calculer puis renvoyer une valeur. Le type du résultat à retourner est une valeur qui peut être de tout type sauf d'un type fichier.</p>
                                    <img src="../images/fonctions_Pascal.png" alt="">
                                    <p>Considérons le programme suivant dans lequel nous utilisons les fonctions standard <span class="html">sin</span> et <span class="html">upcase</span>. Cette fonction renvoie le sinus de son argulent, qui représente un angle exprimé en radians. Comme la valeur retournée est de type Extended, on dit que la fonction <span class="html">sin</span> est de type Extended. Le programme fait également appel à une autre fonction standard : la fonction <span class="html">upcase</span> qui convertit en majuscule un caractère. Si le caractère passé en argument à la fonction n'appartient pas à l'étendue 'a'..'z', la fonction renvoie la valeur caractère non affectée.</p>
<pre><code>program sinus;
{$APPTYPE CONSOLE}

var
    angle : Extended ;
    rep  : char ;

begin
    repeat
        write('valeur d''un angle en radians : ') ;
        readLn(angle) ;
        writeLn('valeur du sinus : ',sin(angle):8:2) ;
        write('continue O/N : ') ;
        readLn(rep)
    until upcase(rep) = 'N' ;

    readLn
end.</code></pre>
                                    <p>À chaque répétition, il y a appel de la fonction <span class="em">SIN</span>. Pour chaque valeur de type Extended de l'argument, la fonction <span class="em">SIN</span> retournera la valeur du sinus correspondant.</p>
                                    <p class="em">Exemple d'exécution :</p>
<pre><code>valeur d'un angle en radians : 1.57079
valeur du sinus :     1.00    
continue O/N ? o
valeur d'un angle en radians : 3.14159
valeur du sinus :     0.00
continue O/N ? o
valeur d'un angle en radians : 4.71238 
valeur du sinus :    -1.00
continue O/N ? n</code></pre>
                                    <p>La valeur de la variable angle est, dans notre exemple, l'argument (ou le paramètre effectif) de la fonction. L'argument doit être une valeur d'un type réel, il s'agit d'une expression réelle.</p>
                                    <p>Exemples :</p>
<pre><code>SIN(1.3)
SIN(A) 
SIN(A*PI/2) 
SIN(ABS(X))</code></pre>
                                    <p>Comme une fonction dénote une valeur, nous pourrons l'utiliser au sein d'une expression là où nous mettions une valeur.</p>
<pre><code>y := 3 * SIN(x)   1
writeln(sin(x))</code></pre>
                                    <p>Remarquons que dans le programme sinus, il y a appel à 5 sous-programmes :</p>
                                    <ul>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">write</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la procédure d'affichage <span class="em">writeLn</span></p>
                                        </li>
                                        <li>
                                            <p>appel à la fonction </p>
                                            <span class="em">sin</span>
                                        </li>
                                        <li>
                                            <p>appel à la fonction <span class="em">upcase</span></p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Déclarations de fonctions :</h3>
                            <p>Une <span class="em">déclaration (de définition)</span> de fonction définit un sous-programme qui, nous l'avons déjà signalé, effectue un certain traitement avant de renvoyer une valeur.</p>
                            <img src="../images/declarations_fonctions_Pascal.png" alt="">
                            <p>Quand vous déclarez une fonction, vous spécifiez son nom, le nombre et le type des paramètres, ainsi que le type de la valeur renvoyée. La simple déclaration d'une fonction qui correspond à son en-tête est parfois appelé son prototype ou sa signature.</p>
<pre><code>function sin(x : Extended) : Extended ;

function upcase(ch : Char) : Char ;</code></pre>
                            <p>Pour définir la fonction, il convient de faire suivre son en-tête du corps de la fonction.</p>
                            <p>Le corps de la fonction est constitué d'un bloc, c'est-à-dire d'une partie déclaration et d'une partie instruction.</p>
                            <p>Dans la partie déclaration seront déclarés et définis tous les objets locaux à la fonction : il pourra s'agir de constantes, types, variables et ... de procédures et fonctions. <span class="em">Une bonne règle de programmation consiste à déclarer localement au sous-programme tout objet dont il n'est jamais fait usage à l'extérieur.</span></p>
                            <p>La partie instruction du corps de la fonction contient les instructions qui seront exécutées lors de l'activation de la fonction. Ce bloc doit contenir au moins une instruction pour affecter une valeur à la variable prédéfinie Result qui est propre à chaque fonction et du type de la fonction. Le résultat de la fonction est la dernière valeur affectée à cette variable spéciale. Si aucune instruction n'affecte de valeur à Result, la fonction retourne une valeur indéfinie. (<span class="em">Anciennement, on utilisait le nom de la fonction à la place de Result</span>).</p>
                        </li>
                        <li>
                            <h3>Paramètres formels et Appel de fonction :</h3>
                            <p>Des valeurs peuvent être passées à des sous-programmes par des paramètres. Ceux-ci fournissent un mécanisme de substitution permettant à la logique d'un sous-programme d'être utilisé avec différentes valeurs initiales, donnant évidemment des résultats différents.</p>
                            <p>Il existe différentes sortes de paramètres !</p>
                            <p>Ceux dont il est question ici sont les <span class="em">paramètres valeur</span>.</p>
                            <p>Une fonction est activée par l'évaluation d'une expression contenant l'appel de la fonction.</p>
                            <p>Cet appel de fonction se fait en écrivant le nom de la fonction doit être faite. Ces paramètres effectifs représentent des <span class="em">valeurs</span>.</p>
                            <p>À chaque appel, les paramètres effectifs sont subtitués aux paramètres formels spécifiés dans l'en-tête de la fonction.</p>
                            <p>L'ordre des paramètres passés est l'ordre d'apparition dans la liste des paramètres formels. Dans ce type de passage, <span class="em">chaque paramètre formel représente une variable locale au sous-programme qui est initialisé à la valeur du paramètre effectif correspondant</span>.</p>
                            <p>Les types des paramètres formels et des paramètres effectifs doivent - c'est l'évidence - être compatibles.</p>
                            <p>Le diagramme syntaxique définissant la liste de paramètres formels (<span class="em">paramètres valeur</span>) devient :</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>Exemples :</p>
                            <p>Si la fonction <span class="html">COPY</span> n'existait pas, il conviendrait de l'écrire nous-même.</p>
                            <p>À quoi ressemblerait le prototype d'une telle fonction ?</p>
                            <p>La fonction <span class="html">COPY</span> renvoie une partie d'une chaîne de caractères. Elle renvoie une chaîne constituée de <span class="em">n</span> caractères à partir de la position <span class="em">p</span>.</p>
                            <img src="../images/parametres_formels_Pascal_1.png" alt="">
                            <p>L'en-tête de la fonction <span class="html">COPY</span> pourrait être :</p>
<pre><code>function COPY (ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres constante :</h3>
                            <p class="em">(Manuel de référence) :</p>
                            <p>Un paramètre constante (const) est semblable à une constante locale ou à une variable en lecture seule. Les paramètres constantes sont semblables aux paramètres valeur à cette différence qu'il n'est pas possible d'affecter une valeur à un paramètre constante dans le corps de la routine, <span class="em">ni de le transmettre comme paramètre var à une autre routine</span>.</p>
                            <p>L'utilisation de <span class="html">const</span> permet au compilateur d'optimiser le code pour les paramètres de type structuré ou chaîne.</p>
                            <p>Le protocole de la fonction copy peut donc s'écrire :</p>
<pre><code>function COPY(<span class="html">const</span> ch : string; p,n : integer) : string ;</code></pre>
                        </li>
                        <li>
                            <h3>Exemples de définitions de fonctions :</h3>
                            <p>En guise d'exercice, nous allons réécrire la fonction upcase ainsi que la fonction uppercase qui renvoie une chaîne en majuscules.</p>
<pre><code>function uppercase(const S : String) : String ;</code></pre>
<pre><code>program majuscule;
{$APPTYPE CONSOLE}

<span class="em">function charMaj(ch : Char) : Char ;
begin
    Result := ch ;
    if (ch &gt;= 'a') and (ch &lt;= 'z') then
        Result := chr( ord(ch) + ord('A') - ord('a') )
    {fi}
end ;

function strMaj(const S : String) : String ;
var k : Cardinal ;
begin
    Resukt := s ;
    for k := 1 to length(Result) do
        Result[k] := charMaj(Result[k]) ;
end ;</span>

var chaine : String ;
begin
    repeat
        write('chaine : ') ;
        readLn(chaine) ;
        if chaine = '' then break ;
        writeLn(strMaj(chaine)) ;
        writeLn(chaine) ;
    until False ;
end .</code></pre>
                            <p>Le programme majuscule correspond à une boucle généralisée. À chaque répétition, il y a appel à la fonction strMaj avec comme argument (paramètre effectif) la valeur courante de la variable chaîne de type String. La valeur de cette variable <span class="em">chaine</span> ne sera pas modifiée par l'exécution de la routine puisque (sémantiquement) c'est la valeur et non la variable qui est transmise !</p>
                            <p class="em">Exemple d'exécution d'une répétition... :</p>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                    <tr>
                                        <td>write('Chaine :') ; readLn(chaine) ;</td>
                                        <td>Chaine : <span class="em">aAzZeErRtTyY ! !</span></td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(strMaj(chaine)) ;</td>
                                        <td class="em">AAZZEERRTTYY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>writeLn(chaine) ;</td>
                                        <td class="em">aAzZeErRtTyY ! !</td>
                                    </tr>
                                    <tr>
                                        <td>...</td>
                                        <td>...</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Pour chaque appel de la fonction strMaj, il y aura un appel à la fonction prédéfinie length et une suite d'appels à la fonction charMaj (en fait, un appel pour chaque caractère de la valeur String).</p>
                        </li>
                        <li>
                            <h3>Problématique de l'usage des routines :</h3>
                            <p>La structure du programme <span class="em">majuscule</span> reflète (en simplifié) celle de la majorité des programmes. Le programme principal lance successivement un ensemble de sous-programmes, chacun d'eux pouvant lancer ses propres sous-pogrammes...</p>
                            <p>Ce mécanisme d'exécution revient à suspendre l'exécution du programme en cours. Le processus qui s'exécute se suspend par l'appel explicite d'un sous-programme et permet le lancement du processus associé au sous-programme. Lorsque l'exécution de ce sous-programme est terminée, le programme appelant reprend la main, et continue son exécution là où il l'avait suspendue.</p>
                            <img src="../images/problematique_usage_routines.png" alt="">
                            <p>Le concepteur, dans une démarche d'écriture structurée, donne grande importance aux routines. La forme générale de son projet est alors un ensemble de nombreux sous-programmes, chacun étant de taille fort réduite et de fonctionnalité simple, et l'exécution consiste en de nombreux appels de ces sous-programmes.</p>
                            <p>Le programme principal a un rôle de lanceur. Il réalise certaines initialisations, puis passe la main. Dans tous les cas, c'est par lui qui commence l'exécution et également qu'elle se termine.</p>
                        </li>
                        <li>
                            <h3>Bloc et Portée d'une déclaration :</h3>
                            <p>Un bloc est composé d'un ensemble de déclarations suivi d'un ensemble d'instructions. Chaque bloc est contenu dans une déclaration de procédure, de fonction, de programme (ou d'unité).</p>
                            <p>Tous les identificateurs déclarés dans la partie déclaration d'un bloc sont locaux à ce bloc.</p>
                            <p>Une déclaration introduit un nom (identificateur) dans une portée.</p>
                            <q class="em">La <span class="html">portée</span> d'une déclaration est la partie du texte du programme où l'association entre le nom de l'objet déclaré et sa desccription est d'application.</q>
                            <p>On parle aussi parfois du domaine d'application d'une déclaration en lieu et place de la portée d'une déclaration.</p>
                            <p class="em">La portée d'un identificateur déclaré dans une déclaration de constantes, de types, de variables, de procédures ou de fonctions s'étend de l'endroit de la déclaration jusqu'à la fin du bloc courant, en incluant tous les blocs définis à l'intérieur de ce bloc courant.</p>
                            <p>Un identificateur déclaré dans un bloc peut être <span class="em">redéclaré</span> dans un bloc plus interne.</p>
                            <p class="em">Visibilité :</p>
                            <p><span class="em">Une déclaration est visible</span> dans la partie du texte où on peut l'identifier, c'est-à-dire où le nom déclaré peut être écrit et signifier l'objet décrit. Un identificateur est visible là où sa déclaration est visible.</p>
                            <p>Une déclaration peut être visible dans toute l'étendue de sa portée mais peut aussi être <span class="em">masquée</span> par d'autres déclarations dont la portée et la visibilité chevauchent celles de la première déclaration.</p>
                        </li>
                        <li>
                            <h3>Durée de vie :</h3>
                            <p>Les variables et les sous-programmes, contrairement aux types, existent lors de l'exécution du programme <span class="em">&lt; ils occupent une place mémoire</span>.</p>
                            <q class="em">La durée de vie d'un objet est la période durant laquelle cette mémoire lui est allouée.</q>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui est allouée pour toute la durée de l'exécution du programme.</p>
                            <p>La durée de vie d'un objet est dite <span class="em">permanente</span> si cette mémoire lui esr allouée pour toute la durée de l'exécution du programme.</p>
                            <p>Une variable peut avoir une durée de vie <span class="em">temporaire</span>. Elle est alors créée à l'entrée du sous-programme contenant sa déclaration et détruite quand son nom sort de sa portée.</p>
                            <blockquote>
                                <p>durée de DYNAMIQUE (liée à l'exécution du programme)</p>
                                <p>portée = propriété STATIQUE (liée au texte du programme)</p>
                            </blockquote>
                            <p class="em">Variables globales et variables locales (résumé) :</p>
                            <p>Les programmes jusqu'à présent rencontrés étaient constitués d'un seul bloc. Comme on n'y avait déclaré aucun sous-programme, il n'y avait pas d'imbrication de blocs. Les variables étaient toutes des variables globales. Elles avaient été déclarées dans le bloc principal du programme; leur durée de vie était celle du programme.</p>
                            <p>La portée de la déclaration d'une variable globale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc courant c'est-à-dire jusqu'à la fin du programme.</p>
                            <p>Il conviendra de réduire au maximum cette portée... De ce fait, nous ne serons pas tentés d'utiliser des variables globales à l'intérieur des sous-programmes.</p>
                            <p class="em">Une bonne règle de programmation étant de construire des sous-programmes étanches.</p>
                            <p>Les variables déclarées dans un sous-programme auront une durée de vie qui correspondra à l'exécution de ce sous-programme. De telles variables locales.</p>
                            <p>La portée de la déclaration d'une variable locale s'étend de l'endroit de sa déclaration jusqu'à la fin du bloc du sous-programme. Il y a cohérence entre la propriété statique de portée et la propriété dynamique de durée de vie.</p>
                            <q>Une fonction doit constituer un tout; elle doit être "<span class="em">étanche</span>", et compréhensible en dehors du contexte dans lequel elle est utilisée. C'est d'ailleurs à ce prix que vous pourrez la réutiliser dans d'autres programmes.</q>
                        </li>
                        <li>
                            <h3>Procédures - Introduction :</h3>
                            <p>Une procédure est destinée à réaliser une action, un traitement. Elle correspond à la notion de sous-programme dans toute sa généralité. Son appel sera assimilable à une <span class="em">instruction</span>.</p>
                            <p>Comme premier exemple, nous pourrions définir une procédure <span class="em">erreur</span> dont l'effet est pour le moins dévasteur.</p>
<pre><code>procedure erreur(const message : String) ;
begin
        writeLn(message) ;
        halt
end ;</code></pre>
                            <p>Cette procédure fait elle-même appel à deux procédures prédéfinies.</p>
                            <p>La procédure d'affichage writeLn et la procédure halt qui exécute une fin anormale de programme !</p>
                            <img src="../images/procedure_affichage_writeLn_Pascal.png" alt="">
                            <p>Nous avons déjà rencontré des procédures dont "l'effet" étaient de modifier des variables. Ainsi la procédure inc permet d'incrémenter la valeur d'une variable. C'est la variable qu'il conviendra de transmettre au sous-programme !</p>
<pre><code>…
{ assert(x=12) }
inc(x) ;
{ assert(x=13) }
…</code></pre>
                            <img src="../images/assert.png" alt="">
                            <p>Pour que la procédure soit un outil général, il convient qu'elle puisse aussi restituer une ou plusieurs valeurs au programme (ou sous-programme) appelant.</p>
                            <p>Un nouveau mode de transmission de paramètres sera alors nécessaire. Nous l'étudierons après avoir précisé la syntaxe d'une délcaration de procédure.</p>
                        </li>
                        <li>
                            <h3>Déclaration (de définition) de procédure :</h3>
                            <p>Une déclaration de procédure associe un identificateur à un bloc d'instructions.</p>
                            <p>L'appel de la procédure se fera par une instruction de procédure; celle-ci spécifie l'identificateur de la procédure, ainsi que les paramètres effectifs, si nécessaire. Quand une procédure est appelée, le contrôle se trouve transféré au début de la procédure. Après avoir exécuté les instructions qui composent le traitement de la procédure, le contrôle retourne automatiquement à l'instruction qui suit l'instruction d'appel de la procédure.</p>
                            <img src="../images/declaration_procedure_Pascal.png" alt="">
                            <p class="em">L'en-tête de la procédure est suivi :</p>
                            <ul>
                                <li>
                                    <p class="em">d'une partie déclaration qui déclare les objets locaux;</p>
                                </li>
                                <li>
                                    <p>des instructions comprises entre begin et end, qui spécifient ce qui doit être exécuté lorsqu'il est fait appel à la procédure.</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h3>Paramètres variable :</h3>
                            <p>Répétons-le, un paramètre valeur est simplement une variable locale au sous-programme, qui lors de son activation a été initialisée à la valeur du paramètre effectif correspondant.</p>
                            <p class="em">Si vous transmettez une variable comme paramètre valeur, la routine en crée une copie et les modifications apportées à la copie sont sans effet sur la variable d'origine et sont perdues quand l'exécution du programme revient à l'appel de la routine.</p>
                            <p>Un paramètre variable se comporte, lui, comme une sorte d'alias, un autre nom permettant d'accéder au paramètre effectif qui doit être une variable (référence à une variable).</p>
                            <p class="em">Un paramètre variable dénote une variable !</p>
                            <p>De ce fait, les modifications apportées aux paramètres dans le corps de la routine sont conservées lorsque l'exécution du programme revient à l'appel de la routine et que le nom du paramètre est hors de portée.</p>
                            <p>Rappelez-vous qu'un identificateur de variable représente en fait l'adresse symbolique de la case mémoire correspondant à la variable désignée. Le paramètre formel variable est dans la procédure un nouveau nom pour la variable référencée par le paramètre effectif. Ainsi, le paramètre formel et le paramètre effectif font référence à la même case mémoire.</p>
                            <p>En conséquence, modifier le paramètre formel dans un sous-programme, c'est en fait modifier le paramètre effectif correspondant.</p>
                            <p>On comprend alors pourquoi cette technique est utilisée pour les paramètres de retour (lorsqu'une valeur doit être renvoyée à l'appelant d'une procédure) et pourquoi paramètres formels et effectifs doivent être de types rigoureusement identiques.</p>
                            <p>Une liste de paramètres par adresse est précédée du mot réservé var.</p>
                            <img src="../images/parametres_formels_Pascal.png" alt="">
                            <p>L'exemple classique suivant bien la différence entre les deux types de paramètres.</p>
<pre><code>program val_var ; 
{$APPTYPE CONSOLE}

procedure echange_local( a,b : integer ) ; 
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ; 

<span class="em">procedure echange( var a,b : integer ) ;
var x : integer ; 
begin 
    x := a ; 
    a := b ; 
    b := x 
end ;</span>
    
var x,y : integer ; 
    
begin 
    x := 1 ; y := 2 ; 
    writeln(x:8,y:8) ;              {       1       2} 
    echange_local(x,y) ; 
    writeln(x:8,y:8) ;              {       1       2}     
    echange(x,y) ; 
    writeln(x:8,y:8) ;              {       2       1} 

    readLn     
end.</code></pre>
                        </li>
                        <li>
                            <h3>Une nouveauté : les paramètres out :</h3>
                            <p>(Manuel de référence) :</p>
                            <p class="em">Un paramètre de sortie (out) est transmis par adresse comme un paramètre variable. Mais avec un paramètre out, la valeur initiale de la variable référencée n'est pas prise en compte par la routine à laquelle elle est transmise. Le paramètre out n'est utilisé qu'en sortie; il indique simplement à la routine où placer la valeur en sortie sans spécifier de valeur en entrée.</p>
                            <p class="em">Soit, par exemple, l'en-tête de procédure suivant :</p>
<pre><code>procedure ExtraitInfos(out Info: UnTypeEnreg);</code></pre>
                            <p class="em">Quand vous appelez <span class="html">ExtraitInfos</span>, vous devez lui transmettre une variable de type <span class="html">UnTypeEnreg</span> :</p>
<pre><code>var MonEnreg: UnTypeEnreg;

...
ExtraitInfos(MonEnreg);</code></pre>
                            <p class="em">Mais vous n'utilisez pas <span class="html">MonEnreg</span> pour transmettre des données à la procédure <span class="html">ExtraitInfos</span>; <span class="html">MonEnreg</span> sert simplemeent de conteneur où <span class="html">ExtraitInfos</span> stocke les informations qu'elle génère. L'appel de <span class="html">ExtraitInfos</span> libère immédiatement la mémoire utilisée par <span class="em">MonEnreg</span>, avant que le contrôle du programme ne passe à la procédure.</p>
                            <p class="em">Les paramètres <span class="html">Out</span> sont fréquememment utilisés avec les modèles d'objets distribués comme <span class="html">COM</span> ou <span class="html">COBRA</span>. De plus, vous devez utiliser des paramètres <span class="html">out</span> pour transmettre une variable non initialisée à une routine.</p>
                        </li>
                        <li>
                            <h2>Transfert de paramètre :</h2>
                            <p>Les paramètres sont transmis aux procédures et aux fonctions par l'intermédiaire (<span class="em">des registres CPU ou</span>) de la pile, selon la convention d'appel de la routine.</p>
                            <p>Selon une des conventions possibles, les paramètres sont placés, avant l'appel du sous-programme, dans la pile suivant l'ordre de leur déclaration. Juste avant la fin de son exécution, le sous-programme retire tous les paramètres de la pile.</p>
                            <p>La structure d'appel d'une routine pourrait être la suivante :</p>
<pre><code>PUSH		param1
PUSH		param2
        …
PUSH		paramN
CALL 		routine</code></pre>
                            <p>Il n'existe que deux sortes de transmission :</p>
                            <ul>
                                <li>
                                    <p>par valeur,</p>
                                </li>
                                <li>
                                    <p>par référence ou adresse.</p>
                                </li>
                            </ul>
                            <p class="html">Lorsqu'un paramètre est transmis par adresse, un pointeur sur l'emplacement en mémoire de la "valeur" à transmettre est placé dans la pile.</p>
                            <p class="html">Pour une transmission par valeur, c'est la valeur elle-même qui est placée dans la pile.</p>
                            <p class="em">Les paramètres variables (et de sortie) sont toujours transmis par adresse.</p>
                            <p class="em">Les paramètres valeurs (et constantes) sont transmis, suivant leur type et leur taille, par adresse ou par valeur.</p>
                            <p>En général, si le paramètre occupe quelques octets, la valeur est directement placée dans la pile. Sinon, le sous-programme appelé copie la valeur dans une zone de mémoire locale et c'est un pointeur sur cette zone qui est placé dans la pile.</p>
                            <p><span class="em">L'effcicacité des paramètres constantes</span> par rapport aux paramètres valeurs vient de ce que le compilateur n'a pas à générer de copie des paramètres effectifs à l'entrée dans le sous-programme <span class="em">puisque les paramètres constantes ne sont pas modifiables !</span></p>
                        </li>
                        <li>
                            <h3>Laboratoire d'analyse :</h3>
                            <p>Comme petit exercice, analysez le programme suivant :</p>
                            <p class="em">(fonction, procédure et contexte d'appel...)</p>
<pre><code>program test;
{$APPTYPE CONSOLE}

procedure NumString(N:Integer;var S:String) ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        S := '' ;
        repeat
        S := chr(V mod 10 + ord('0')) + S ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then S := '-'+ S
end ;

function NumString(N : Integer) : String ; overload ;
var V : Integer ;
begin
        V := abs(N) ;
        Result := '' ;
        repeat
        Result := chr(V mod 10 + ord('0')) + Result ;
        V := V div 10
        until V = 0 ;
        if N &lt; 0 then REsult := '-'+ Result
end ;

var str : String ;
begin

    NumString(-12345,str) ;
    writeLn(str) ;

    writeLn(NumString(-12345)) ;

    readLn
end .</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="tableaux">Tableaux (Array) :</h2>
                    <ol>
                        <li>
                            <h3>Généralités :</h3>
                            <p>Lorsqu'un nombre important de variables de même type et surtout associées à une même catégorie d'objet, doit être utilisé dans un programme, il est bien entendu impossible d'envisager d'attribuer un identificateur différent à chaque variable (par exemple le chiffre d'affaires quotidien d'un représentant).</p>
                            <p>Les tableaux permettent de résoudre cette difficulté.</p>
                            <p>Un tableau est une manière assez naturelle de ranger des éléments de même type. Il permet de regrouper ceux-ci dans une structure fixe et d'accéder à chaque élément par le biais d'un indice.</p>
                            <p>On peut considérer une variable tableau comme un tableau de variables.</p>
                        </li>
                        <li>
                            <h3>Définition :</h3>
                            <p>Un tableau est une structure constituée d'un nombre fixe d'éléments du même type qui est appelé type de base ou type composant.</p>
                            <p>Il s'agit donc d'une <span class="em">structure homogène</span>.</p>
                            <p>Nous pouvons construire des tableaux d'entiers, des tableaux de booléens, mais aussi des tableaux de chaînes et pourquoi pas... des tableaux de tableaux !</p>
                            <p>Un tableau est aussi une structure dite <span class="em">à accès aléatoire</span> : à un instant donné, on peut sélectionner n'importe quel composant. Le temps d'accès à un élément est indépendant de la place qu'occupe cet élément dans la structure.</p>
                            <p>Pour désigner, pour référencer un composant, on ajoute entre crochets au nom de la variable de type tableau ce qu'on appelle un indice. Cet indice signale la position de l'élément dans le tableau et doit être une valeur du type défini comme le type d'indice du tableau.</p>
                            <p>Le type de l'indice permet de définir le nombre d'éléments du tableau. En Pascal, les types autorisés pour les indices sont tous les types scalaires.</p>
                            <p>La définition d'un type de tableau <span class="em">TT</span> spécifie à la fois un type de base <span class="em">TB</span> et un type d'indice <span class="em">TI</span>.</p>
<pre><code>Type TT = ARRAY[TI] of TB ;</code></pre>
                            <p>Exemples :</p>
<pre><code>
Type Tab1_20Real = ARRAY [1..20] of Real ;
     Tab0_255Boolean = ARRAY [byte] of Boolean ;

var t1,t2 : Tab1_20Real ;
t3,t4 : Tab0_255Boolean ;

Type Tetat = (travail,conge,recuperation,in¬defini) ;
     Tjour = (lun,mar,mer,jeu,ven,sam,dim) ; 
     Tableau = ARRAY [Tjour] of Tetat ;
var t : Tableau ;
...</code></pre>
                            <p>Notez cependant qu'il peut exister des restrictions qui dépendent de la capacité mémoire et non de la définition du langage.</p>
<pre><code>type 	TropGros = array [Longint] of Extended ;
{ erreur  => type de donnée trop grand : dépasse 2Go }</code></pre>
                            <p class="em">Remarque : Le type des composants d'un tableau peut être lui-même d'un type tableau; nous obtenons ainsi des tableaux de tableaux "ou" tableaux multidimensionnels.</p>
<pre><code>
Type Tvecteur = ARRAY [1..3] of Extended ;
     Tmatrice = ARRAY [1..5] of Tvecteur ;
var m : Tmatrice ;</code></pre>
                            <p class="em">Pour référencer l'élément de la matrice correspondant à la i<sup>ème</sup> ligne et à la j<sup>ème</sup> colonne, nous pouvons écrire <span class="html">m[i][j]</span> ou encore <span class="html">m[i,j]</span>.</p>
                            <p class="em">Nous aurions pu définir le type Tmatrice autrement :</p>
<pre><code>Type Tmatrice = ARRAY [1..5] of ARRAY [1..3] od Extended ;
// ou encore
     Tmatrice = ARRAY[1..5,1..3] of Extended ;</code></pre>
                            <p class="em">Ces définitions sont cependant moins souples que la première qui permet une assignation tel que : <span class="html">v := m[k]</span> en supposant que <span class="html">v</span> est une variable de type <span class="html">Tvecteur</span>.</p>
                        </li>
                        <li>
                            <h3>Opérations sur les tableaux :</h3>
                            <p>La seule opération globale sur des tableaux est l'affectation. Celle-ci n'est possible que si les deux tableaux sont rigoureusement de même type.</p>
                            <p>Supposons les déclarations suivantes :</p>
<pre><code>type Tab1 = ARRAY [1..5] of integer ;
     Tab2 = ARRAY [1..5] of integer ;
var t,t1 : Tab1 ;
    t2 : Tab2 ;</code></pre>
                            <p>l'affectation <span class="em">t1 := t</span> est possible alors que l'affectation <span class="em">t1 := t2</span> ne l'est pas car les types <span class="em">tab1</span> et <span class="em">tab2</span> sont distincts !</p>
                            <ul>
                                <li>
                                    <p>Les procédures prédéfinies de lecture et écriture (readln, writeln, ...) ne permettent que de traiter des nombres des chaînes - étant bien entendu qu'il s'agit de variables pour les lectures et d'expressions pour les écritures.</p>
                                    <p>Il conviendra donc de lire ou d'écrire successivement chaque élément du tableau.</p>
<pre><code>...
for k := 1 to 5 do
    begin
        write('t[',k,'] = ');
        readln(t[k])
    end;
...</code></pre>
                                </li>
                                <li>
                                    <p>Les opérations réalisables sur un élément de tableaux sont celles réalisables sur le type composant. Ainsi, dans notre exemple, <span class="em">t1[3]</span> est assimilable à une variable entière. Il s'agit d'une <span class="em">extension de la notion de variable</span> : un composant d'une variable de type structuré est une référence à une variable et correspond donc à un emplacement adressable.</p>
                                    <p>Au niveau représentation en mémoire, un tableau est stocké comme une séquence de variables adjacentes de même type que le type de base du tableau.</p>
                                    <img src="../images/operations_tableaux_Pascal.png" alt="">
                                </li>
                            </ul>
                            <p>Lorsque les fonctions <span class="html">low</span> et <span class="html">high</span> sont appliquées à un identificateur de type tableau ou une référence d'un type tableau, elles retournent les bornes inférieures et supérieure du type d'indice du tableau.</p>
<pre><code>program highlow ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     TabA_ZInt = array[TMajuscule] of Integer ;
     Tab1_10Int = array[TIndex] of Integer ;
var M : TabA_ZInt ;
    L : Tab1_10Int ;
begin
    writeln(low(TabA_zInt):8,low(M):8) ;
    writeln(high(TabA_zInt):8,high(M):8) ;
    writeln(low(Tab1_10Int):8,low(L):8) ;
    writeln(high(Tab1_10Int):8,high(L):8) ;
    readLn
end.</code></pre>
                            <img src="../images/highlow_Pascal.png" alt="">
                            <p>Exemple :</p>
<pre><code>program testab ;
{$APPTYPE CONSOLE}
const IndMin = 1 ;
      IndMax = 10 ;
type TMajuscule = 'A'..'Z' ;
     TIndex = IndMin..IndMax ;
     Tableau = array[Tindex] of TMajuscule ;
    
procedure afficheTableau(const T : Tableau) ;
var k : TIndex ;
begin
    for k := low(T) to high(T) do
        writeln('T[',k:2,'] = ',T[k]) ;
    writeln
end ;

function genereTableau : Tableau ;
var k : TIndex ;
begin
    for k := low(Result) to high(Result) do
        Result[k] := char(65 + random(26))
end ;

procedure echange(var x,y : TMajuscule) ;
var tmp : TMajuscule ;
begin
    tmp := x ; x := y ; y : tmp
end ;

var Tab : Tableau ;
begin
    randomize ; tab := genereTableau ;
    afficheTableau(tab) ;
    echange(tab[1],tab[10]) ; echange(tab[2], tab[9]) ;
    afficheTableau(tab) ;
    readLn
end.</code></pre>
                            <img src="../images/testab_Pascal.png" alt="">
                        </li>
                        <li>
                            <h3>Constante typée :</h3>
                            <p>Pascal Objet autorise la définition de constantes de type tableau sauf celles qui contiennent des éléments de type fichier.</p>
<pre><code>type TEtat = (actif,passif,attente) ;
     TabEtat : array [TEtat] of String ;
const ETATTOSTR : TabEtat = ('actif','passif','attente') ;</code></pre>
                            <p>La constante tableau <span class="em">ETATTOSTR</span> peut être utilisée pour convertir les valeurs du type énuméré <span class="em">TEtat</span> en leur représentation sous forme de chaîne de caractères.</p>
<pre><code>type TCarre = array[1..3,1..4] of Integer ;
const UNCARRE : TCarre = ( (1,2,3,4) , (5,6,7,8) , (9,10,11,12) ) ;</code></pre>
                            <img src="../images/constante_typee_Pascal.png" alt="">
<pre><code>procedure afficheCarre(const C:TCarre) ;
var j,k : Byte ;
begin
    for j := 1 to 3 do begin
        for k := 1 to 4 do
            write(C[j,k]:4)
        {od} ;
    end{do} ;
    writeln
end ;</code></pre>
                        </li>
                        <li>
                            <h3>Paramètres tableaux ouverts :</h3>
                            <p>Les paramètres tableaux ouverts permettent de transmettre à un même sous-programme des tableaux de tailles différentes.</p>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>

</html>