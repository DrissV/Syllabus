<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Git et GitHub - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#intro_git_github">Introduction</a></li>
                        <li><a href="#git">Git</a></li>
                        <li><a href="#modeles_versionning">Les modèles de versioning</a></li>
                        <li><a href="#github">GitHub</a></li>
                        <li><a href="#installaton_git">Installer Git</a></li>
                        <li><a href="#demarrer_depot_git">Démarrer le dépôt Git</a></li>
                        <li><a href="#renommer_fichier_git">Renommer le fichier Git</a></li>
                        <li><a href="#branche">Les branches</a></li>
                        <li><a href="#rebaser">Rebaser</a></li>
                        <li><a href="#utilisation_github">Utilisation de GitHub</a></li>
                        <li><a href="#copier_depot_clone_fork">Clone vs Fork</a></li>
                        <li><a href="#creer_branche_thematique_branche_principale">Créer une branche thématique</a></li>
                        <li><a href="#pull_request">Pull request</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Git :</h1>
                    <p>Cette page est l'ensemble des dix pages du <a href="https://www.pierre-giraud.com/git-github-apprendre-cours/" target="_blank">cours de Pierre Giraud sur Git et GitHub</a>.</p>
                </article>
                <article>
                    <h2 id="intro_git_github">Apprendre à utiliser Git et GitHub :</h2>
                    <p>Dans ce cours, nous allons commencer par expliquer ce qu'est Git. Pour cela, nous allons définir ce qu'est un système de gestion de version et comprendre en quoi Git est différent des autres systèmes de gestion de version et pourquoi il est si populaire.</p>
                    <p>Nous allons ensuite découvrir les fonctionnalités principales de Git et apprendre à les utiliser. ous apprendrons notamment à créer un nouveau dépôt Git avec la commande <span class="html">git init</span> ou à cloner un dépôt existant avec <span class="html">git clone</span>, à observer l'état d'un projet avec <span class="html">git status</span>, à ajouter des fichiers à l'index avec <span class="html">git add</span>, à valider des modifications avec <span class="html">git commit</span>, etc.</p>
                    <p>Nous étudierons également le système de branches de Git qui est l'un des composants qui rendent ce système de version très puissant et flexible.</p>
                    <p>Finalement, nous découvrivrons GitHub et apprendrons à gérer nos différents dépôts et à travailler sur des dépôts hébergés.</p>
                    <h2 id="git">Qu'est-ce que Git ?</h2>
                    <p>Git est un logiciel de versioning créé en 2005 par Linus Torvalds, le créateur de Linux.</p>
                    <p>Un logiciel de versioning, ou logiciel de gestion de version est un logiciel qui permet de conserver une historique des modifications effectuées sur un projet afin de pouvoir rapidement identifier les changements effectués et de revenir à une ancienne version en cas de problème.</p>
                    <p>Les logiciels de gestion de versions sont quasiment incontournables aujourd'hui car ils facilitent grandement la gestion de projets et car ils permettent de travailler en équipe de manière beaucoup plus efficace.</p>
                    <p>Parmi les logiciels de gestion de versions, Git est le leader incontesté et il est donc indispensable pour tout développeur de savoir utiliser Git.</p>
                    <h2>À quoi sert concrètement un système de gestion de version ?</h2>
                    <p>Imaginez que vous possédiez un site web. À chaque fois que vous voulez modifier quelque chose sur le site ou tester une fonctionnalité, vous êtes obligé d'effectuer une sauvegarde du site avant l'implémentation afin de pouvoir le restaurer si quelque chose se passe mal.</p>
                    <p>Jusqu'ici, le procédé est contraignant car vous allez devoir effectuer une sauvegarde complète et restaurer la sauvegarde en cas de problème mais cela ne semble pas très complexe ni insurmontable.</p>
                    <p>Imaginez maintenant que vous soyez 10 à travailler sur le même site web, en vous occupant chacun de développer des fonctionnalités différentes mais qui peuvent être liées entre elles. L'organisation du travail est ici beaucoup plus complexe puisqu'il va falloir s'assurer :</p>
                    <ul>
                        <li>Que les fonctionnalités sur lesquelles travailent un développeur ne rentrent pas en conflit avec les fonctionnalités sur lesquelles travaillent des autres développeurs;</li>
                        <li>Que chaque développeur sache sur quoi travaillent les autres développeurs afin de travailler correctement;</li>
                        <li>Que chaque développeur possède une version actualisée du site pour tester et implémenter ses fonctionnalités.</li>
                    </ul>
                    <p>Ici, l'idée la plus logique serait de mettre en place un serveur distant qui contiendrait l'historique des modifications faites pour chaque développeur afin que chacun ait accès aux avancées des autres. Chaque déveoppeur pourrait également copier l'intégralité du contenu du serveur pour travailler en local sur sa machine. On vient ainsi de créer un système de gestion de version décentralisé rudimentaire.</p>
                    <p>Grosso-modo, les logiciels de versioning et Git en particulier vont nous permettre d'effectuer ces opérations mais de manière beaucoupplus robuste et avec de nombreuses fonctionnalités supplémentaires très utiles (possibilité de synchroniser son dossier local avec le serveur, connexion aux autres projets et mise à jour des différences automatisée, etc.</p>
                    <p>Git permet de coordonner le travail entre plusieurs personnes en conservant un historique des changements effectués sur des fichiers.</p>
                    <p>Git permet à différentes versions d'un même fichier de coexister. Les développeurs travaillant avec Git ont accès à l'historique des modifications pour l'intégralité du projet et peuvent ainsi savoir quels changements ont été fait par rapport à leur version des fichiers, qui a fait ces changements, etc.</p>
                    <h2 id="modeles_versioning">Les deux modèles des logiciels de gestion de version : modèle centralisé vs modèle décentralisé :</h2>
                    <p>Les logiciels de gestion de version sont aujourd'hui tous construits sur l'un des deux modèles suivants : le modèle centralisé ou le modèle décentralisé encore appelé modèle distribué.</p>
                    <p>Le principe de base d'un modèle centralisé est la centralisation du code source lié au projet : la source du code du projet est hébergé sur un serveur distant central et les différents utilisateurs doivent se connecter à ce serveur pour travailler sur ce code.</p>
                    <p>Dans un modèle distribué, le principe de base est oppsé : le code source du projet est toujours hébergé sur un serveur distant mais chaque utilisateur est invité à télécharger et à héberger l'intégralité du code source du projet sur sa propre machine.</p>
                    <p>Le modèle distribué a été popularisé par Git et présente différents avantages notables par rapport au modèle centralisé :</p>
                    <ul>
                        <li>Simplicité/flexibilité du travail : Comme chaque utilisateur peut héberger le code du projet, on n'a plus besoin d'être constamment connecté à un serveur central et on peut donc travailler en ligne sur sa propre machine;</li>
                        <li>Sécurité : Comme chaque utilisateur possède le code complet d'un projet, on peut  utiliser la copie du projet d'un utilisateur comme back-up en cas de corruption du serveur central.</li>
                    </ul>
                    <h2 id="github">Qu'est-ce que GitHub ?</h2>
                    <p>Git est un logiciel de gestion de version. Git va nous permettre d'enregistrer les modifications effectuées sur un projet et de pouvoir retourner à une version précédente du projet.</p>
                    <p>Dans le langage des systèmes de gestion de version, la copie de l'intégralité des fichiers d'un projet et de leur version située sur le serveur central est appelé un dépôt. Git appelle également cela "repository" ou "repo" en abrégé.</p>
                    <p>GitHub est un service en ligne qui permet d'héberger des dépôts ou repo Git. C'est le plys grand hébergeur de dépôts Git du monde.</p>
                    <p>Pour récapituler, et afin d'être bien clair sur ce point : Git est un logiciel de gestion de version tandis que GitHub est un service en ligne d'hébergement de dépôts Git qui fait office de serveur central pour ces dépôts.</p>
                    <p>Nous verrons comment utiliser GitHub en détail dans ce cours après avoir appris à utiliser Git.</p>
                    <h2 id="utiliser_git">Utiliser Git : ligne de commande, console et interface graphique :</h2>
                    <p>On peut utiliser différents types d'interfaces pour intsaller et pour utiliser Git. Dans ce cours, nous allons utiliser la console et donc un langage en lignes de commande plutôt qu'une interface graphique. Nous faisons ce choix pour différentes raisons :</p>
                    <ul>
                        <li>Utliser la ligne de commande est le seul moyen d'avoir accès à toutes les commandes Git;</li>
                        <li>Toutes les personnes vont avoir accès aux mêmes commandes avec la ligne de commande, ce qui signifie que tout le monde pourra suivre ce cours de la même façon;</li>
                        <li>Si vous savez comment utiliser la version en ligne de commande, vous saurez utiliser n'importe quelle autre interface graphique.</li>
                    </ul>
                    <p>Commençons donc par rapidement présenter la console. Une console est une interface qui nous permet d'envoyer des commandes, c'est-à-dire des ordres directement à notre système (notre ordinateur) afin qu'il les exécute. La console, c'est cet écran noir qui nous paraît très intimidant au premier abord :</p>
                    <img src="../images/git-console-terminal.png" alt="console Git">
                    <p>Pour envoyer des commandes à notre système, nous utilisons un langage qui dépend du système utilisé. La plupart des commandes s'écrivent sur une ligne, d'où le terme de "langage en lignes de commande".</p>
                    <p>Au début de l'informatique, les opérations se faisaient toutes en ligne de commande. Ensuite, des interfaces graphiques pour utilisateurs (GUI) ont été développées afin de rendre l'informatique plus accessible à tous. L'interface graphique utilisateur correspond à tout ce que vous voyez lorsque vous regardez votre ordinateur (les dossiers et fichiers sous forme d'icônes, etc.) et aux opérations auxquelles vous avez accès (ouvrir le fichier, le supprimer, le renommer, ...).</p>
                    <p>La particularité des interfaces graphique utilisateur par rapport à la console est qu'elles utilisent principalement la souris pour les opérations là où la console force les utilisateurs à n'utiliser que le clavier pour envoyer des commandes. Cependant, en arrière plan, ce sont les mêmes opérations qui se passent lorsqu'on utilise une GUI ou la console.</p>
                    <p>L'interface graphique utilisateur n'est finalement là que pour apporter un niveau d'abstraction supplémentaire pour l'utilisateur par rapport au langage machine et pour faciliter l'utilisation des ordinateurs.</p>
                    <p>La question est donc : pourquoi utiliser la console plutôt que notre interface graphique utilisateur ? Tout simplement car certaines opérations sont beaucoup plus simples à réaliser via la console. Pour l'utilisation de Git, je vous renvoie aux raisons mentionnées ci-dessus.</p>
                    <p>On va donc pouvoir utiliser la console pour envoyer des ordres à notre système d'opération et pour effectuer différentes opérations courantes comme la création d'un dossier ou d'un fichier, sa suppression, le renommage, etc. et également utiliser la console pour exécuter les commandes spécifiques de Git après l'avoir installé.</p>
                    <p>Les commandes de Git vont une nouvelle fois être les mêmes pour tous les systèmes (Windows, Mac OS, etc.). Les commandes liées aux opérations sur le système comme la création d'un dossier vont elles pouvoir différentes d'un système à l'autre.</p>
                    <p>Pour ma part, j'utilise un Mac depuis des années et utilise donc des commandes UNIX tout comme Linux. Si vous utilisez Windows, je vous invite à installer un logiciel vous permettant d'avoir accès aux commandes UNIX ou à complètement changer de système d'opératuib si vous le pouvez. Pour ce cours, les différences de système ne devraient pas être gênantes car nous allons nous focaliser sur les commandes Git qui sont les mêmes pour tous, mais cela vous sera utile dans votre vie de développeur.</p>
                    <p>Commençons par ouvrir la console ensemble. Si vous êtes sous Mac, vous allez utiliser l'application Terminal disponible dans Applications &#8594; Utilitaires &#8594; Terminal. Si vous êtes sous Windows, vous allez utiliser l'Invite de commande (cmd) ou PowerShell selon la version que vous possédez.</p>
                    <img src="../images/git-console-terminal.png" alt="console Git">
                    <p>Arrivé ici, vous allez pouvoir taper toutes sortes de commandes pour demander à votre système d'effectuer des opérations. Notez que la plupart des commandes qu'on va taper vont être dépendantes de notre emplacement dans le système. Par exemple, pour ajouter un dossier sur notre bureau, il va déjà falloir naviguer jusqu'au bureau via notre console.</p>
                    <p>À titre d'informaion, les commandes (UNIX) de base à connaître sont les suivantes :</p>
                    <ul>
                        <li>La commande <span class="em">pwd</span> affiche le nom et chemin du répertoire courant. Elle permet de savoir où on se situe sur notre machine;</li>
                        <li>La commande <span class="em">ls</span> affiche la liste des fichiers et répertoires dans un répertoire;</li>
                        <li>La commande <span class="em">cd</span> permet de changer de répertoire, c'est-à-dire de se déplacer d'un répertoire à un autre;</li>
                        <li>La commande <span class="em">mkdir</span> permet de créer un nouveau répertoire (ou "dossier");</li>
                        <li>La commande <span class="em">touch</span> permet de créer un fichier;</li>
                        <li>La commande <span class="em">mv</span> permet de renommer ou de déplacer des fichiers.</li>
                    </ul>
                    <p>Si vous désirez en savoir plus sur les commandes UNIX, je vous invite à lire le cours sur le <a href="https://www.pierre-giraud.com/shell-bash/" target="_blank">shell Bash</a>.</p>
                    <p>Voilà tout pour cepetit aparté sur la ligne de commande qui devrait vous permettre de comprendre beaucoup plus rapidement et plus facilement la suite de ce cours.</p>
                    <h2 id="installation_git">Installation de Git :</h2>
                    <p>Entrons dans le vif du sujet et passons immédiatement à l'installation du logiciel Git. La façon la plus simple d'installer Git est de télécharger la dernière version sur le site officiel <a href="https://www.pierre-giraud.com/git-github-apprendre-cours/installer-git/%E2%80%9Chttp://git-scm.com/downloads%22" target="http://git-scm.com/downloads" target="_blank">http://git-scm.com/downloads</a>, d'ouvrir le fichier téléchargé et de suivre les instructions à l'écran en laissant toutes les valeurs par défaut.</p>
                    <p>Si vous êtes sous Windows, téléchargez plutôt la version de Git présente sur <a href="https://gitforwindows.org/" target="_blank">https://gitforwindows.org/</a>. Cette version inclut un outil permettant d'émuler le comportement de Bash (le langage utilisé par Mac et Linux) et donc d'avoir accès aux mêmes commandes que moi.</p>
                    <p>Note : il est possible que la version de Git installée ne soit pas exactement la même que moi. Cela n'a aucune incidence et vous pouvez continuer à suivre le cours.</p>
                    <h2 id="parametrage_git">Paramétrage de Git :</h2>
                    <p>Une fois Git installé, nous allons paramétrer le logiciel afin d'enregistrer certaines données pour ne pas avoir à les fournir à nouveau plus tard.</p>
                    <p>Nous allons notamment ici renseigner un nom d'utilisateur et une adresse mail que Git devra utiliser ensuite.</p>
                    <p>Pour faire cela, nous allons utiliser notre première commande Git qui est la commande <span class="html">git config</span>. Cette commande permet de voir et modifier les variables de configuration qui contrôlent tous les aspects de l'apparence et du comportement de Git.</p>
                    <p>Nous allons également passer une option <span class="html">--global</span> à notre commande. Les options permettent de personnaliser le comportement par défaut de certaines commandes. Les options permettent de personnaliser le comportement par défaut de certaines commandes. Ici, l'option <span class="html">--global</span> va nous permettre d'indiquer à Git que le nom d'utilisateur et l'adresse mail renseignés doivent être utilisés globalement (c'est-à-dire pour tout projet Git).</p>
                    <p>On va donc taper les commandes suivantes : <span class="html">git config --global user.name "Pierre Giraud"</span> et <span class="html">git config --global user.email pierre.giraud@edhec.com</span> à la suite pour renseigner un nom et une adresse email. Bien évidemment, utilisez votre propre nom et votre propre adresse email.</p>
                    <img src="../images/git-config-configuration.png" alt="console Git - git config --global">
                    <p>Pour vous assurer que vos informations ont bien été enregistrées, vous pouvez taper <span class="html">git config user.name</span> et <span class="html">git config user.email</span>. Les informations entrées devraient être renvoyées.</p>
                    <img src="../images/git-config-configuration-affichage.png" alt="console Git - git config">
                    <p>Voilà tout pour la configuration. Notez que certaines commandes Git ouvrent un éditeur, notamment celle qui vous demandent de saisir du texte. L'éditeur par défaut utilisé par Git est l'éditeur système qui est généralement Vi ou Vim.</p>
                    <p>J'utiliserai l'éditeur par défaut pour ce cours. Si vous souhaitez configurer un éditeur différent, vous pouvez entrer la commande <span class="html">git config --global core.editor nom_de_votre_editeur</span>.</p>
                    <h2 id="demarrer_depot_git">Démarrer un dépôt Git :</h2>
                    <p>Un "dépôt" correspond à la copie et à l'importation de l'ensemble des fichiers d'un projet dans Git. Il exise deux façons de créer un dépôt Git :</p>
                    <ul>
                        <li>On peut importer un répertoire déjà existant dans Git;</li>
                        <li>On peut cloner un dépôt Git déjà existant.</li>
                    </ul>
                    <p>Nous allons voir comment faire cela dans la suite de ce cours. Avant cela, je pense qu'il est bon de comprendre comment Git conçoit la gestion des informations ainsi que le fonctionnement général de Git.</p>
                    <h2 id="gestion_informations_git">La gestion des informations selon Git :</h2>
                    <p>La façon dont Git considère les données est assez différente de la plupart des autres systèmes de gestion de version.</p>
                    <p>Git pense les données à la manière d'un flux d'instantanés ou "snapshots". Grosso modo, à chaque qu'on va valider ou enregistrer l'état d'un projet dans Git, il va prendre un instantané du contenu de l'espace de travail à ce moment et va enregistrer une référence à cet instantané pour qu'on puisse y accéder par la suite.</p>
                    <p>Chaque instanté est stocké dans une base de donnée locale, c'est-à-dire une base de donnée située sur notre propre machine.</p>
                    <p>Le fait que l'on dispose de l'historique complet d'un projet localement fait que la grande majorité des opérations de Git peuvent être réalisées localement, c'est-à-dire sans avoir à être connecté à un serveur central distant. Cela rend les opérations beaucoup plus rapides et le travail de manière générale beaucoup plus agréable.</p>
                    <h2 id="etats_fichiers">Les états des fichiers :</h2>
                    <p>Comment Git fait-il pour suivre les modifications sur les ficiers d'un projet ? Pour comprendre cela, il faut savoir qu'un fichier peut avoir deux grands états dans Git : il peut être sous suivi de version ou non suivi.</p>
                    <p>Un fichier possède l'état "suivi" s'il appartenait au dernier instantané capturé par Git, c'est-à-dire s'il est enregistré en base. Tout fichier qui n'appartenait pas au dernier instantané et qui n'a pas été indexé et "non suivi".</p>
                    <p>Lorsqu'on démarre un dépôt Git en important un répertoire déjà existant depuis notre machine, les fichiers sont au départ tous non suivis. On va donc déjà devoir demander à Git de les indexer et de les valider (les enregistrer en base). Lorsqu'on clone un dépôt Git déjà existant, c'est différent puisqu'on copie tout l'historique du projet et donc les fichiers sont tous déjà suivis par défaut.</p>
                    <p>Ensuite, chaque fichier suivi peut avoir l'un de ces trois états :</p>
                    <ul>
                        <li>Modifié ("modified");</li>
                        <li>Indexé ("staged");</li>
                        <li>Validé ("committed").</li>
                    </ul>
                    <p>Lors du démarrage d'un dépôt Git à partir d'un dépôt local, on demande à Git de valider l'ensemble des fichiers du projet. Un fichier est "validé" lorsqu'il est stocké dans la base de donnée locale. Lors du clonage d'un dépôt déjà existant, les fichiers sont enregistrés par défaut en base et ils sont donc validés par défaut.</p>
                    <p>Ensuite, lorsqu'on va travailler sur notre projet, on va certainement ajouter de nouveaux fichiers ou modifier des fichiers existants. Les fichiers modifiés vont être considérés comme "modifiés" par Git tandis que les nouveaux fichiers vont être "non suivis". Un fichier modifié est considéré comme "modifié" par Git tant qu'il n'a pas été indexé.</p>
                    <p>On dit qu'on "indexe" lorsqu'on indique à Git que le fichier modifié ou que le nouveau fichier doit faire partie du prochain instantané dans sa version actuelle.</p>
                    <p>Enfin, lorsqu'on demande à Git de prendre l'instantané, c'est-à-dire lorsqu'on lui demande d'enregistrer en base l'état du projet actuel (c'est-à-dire l'ensemble des fichiers indexés et non modifiés), les fichiers faisant partie de l'instantané sont à nouveau considérés comme "validés" et le cycle peut recommencer.</p>
                    <h2 id="zones_travail">Les zones de travail :</h2>
                    <p>Les états de fichiers sont liés à des zones de travail dans Git. En fonction de son état, un fichier va pouvoir apparaître dans telle ou telle zone de travail. Tout projet Git  est composé de trois sections : le répertoire de travail (working tree), la zone d'index (staging area) et le répertoire Git (repository).</p>
                    <p>Le répertoire de travail ou "working tree" correspond à une extraction unique ("checkout") d'une version du projet. Les fichiers sont extraits de la base de données compressée située dans le répertoire Git et sont placés sur le disque afin qu'on puisse les utiliser ou les modifier.</p>
                    <p>La zone d'index ou "staging area" correspond à un simple fichier, généralement situé dans le répertoire Git, qui stocke les informations concernant ce qui fera partie du prochain instantané ou du prochain "commit".</p>
                    <p>Le répertoire Git est l'endroit où Git stocke les méta-données et la base de données des objets de votre projet. C'est la partie principale ou le coeur de Git.</p>
                    <p>Le processus de travail va ainsi être le suivant : nous allons travailler sur nos fichiers dans le répertoire de travail. Lorsqu'on modifie ou crée un fichier, on peut ensuite choisir de l'indexer. Tant qu'un fichier n'est pas indexé, il possède l'état modifié ou est non suivi si c'est un nouveau fichier. Dès qu'il est indexé i.e que son nom est ajouté à la zone d'index, il possède l'état indexé. Finalement, on va valider ("commit") la version indexée de nos fichiers pour les ajouter au répertoire Git.</p>
                    <p>Pour retenir ces informations, vous pouvez vous aider des schémas ci-dessous (source : git-scm.com).</p>
                    <img src="../images/etat-fichier-git.png" alt="état de fichier Git">
                    <img src="../images/zone-travail-git.png" alt="zone de travail Git">
                    <h2 id="creer_depot_git">Créer un dépôt Git à partir d'un répertoire existant :</h2>
                    <p>Lorsqu'on démarre avec Git, on a souvent déjà des projets en cours stockés localement sur notre machine ou sur serveur distant et pour lesquels on aimerait implémenter un système de gestion de version.</p>
                    <p>Dans ce cas là, nous allons pouvoir importer l'ensemble des ressources d'un projet dans Git. Pour la suite de cette leçon, je vais créer un répertoire "projet-git" qui se trouve sur mon bureau et qui contient deux fichiers texte vides "fichier1.txt" et "README.text". Ce répertoire va me servir de base pour les exemples qui vont suivre (ce sera le répertoire importé).</p>
                    <p>Je vous invite à créerle même répertoire sur votre machine. Vous pouvez le faire soit à la main, soit en utilisant la ligne de commandes comme ci-dessous (attention, toute mon installation et mon système sont en anglais, il est possible que vous ayez à remplacer "desktop" par "bureau" entre autres) :</p>
                    <img src="../images/bash-cd-mkdir-touch.png" alt="Bash cd mkdir touch">
                    <p>La commande <span class="em">cd</span> sert à de placer dans un répertoire. Dès qu'on est sur le bureau, on utilise <span class="Em">mkdir</span> pour créer un répertoire vide qu'on appelle "projet-git". On se place dans ce répertoire et on crée deux fichiers texte grâce à la commandeBash <span class="em">touch</span>. On utilise enfin <span class="em">ls</span> pour afficher le contenu du répertoire et s'assurer que tout a bien fonctionné.</p>
                    <p>Pour initialiser un dépôt Git, on utilise ensuite la commande <span class="html">git init</span> comme ci-dessous. Cela crée un sous répertoire <span class="em">.git</span> qui contient un ensemble de fichiers qui vont permettre à un dépôt Git de fonctionner.</p>
                    <img src="../images/git-init.png" alt="git init">
                    <p>Lorsqu'on utilise <span class="html">git init</span>, Git nous renvoie un message en nous informant que le dépôt Git a bien été initialisé et qu'il est vide. C'est tout à fait normal puisque nous n'avons encore versionné aucun fichier (nous n'avons ajouté aucun fichier du répertoire en base).</p>
                    <p>On peut utiliser ici la commande <span class="html">git status</span> pour déterminer l'état des fichiers de notre répertoire. Cette commande est extrêmement utile et c'est une de celles que j'utilise le plus personnellement :</p>
                    <img src="../images/git-status.png" alt="git status">
                    <p>Ici, <span class="html">git status</span> nous informe que notre projet possède deux fichiers qui ne sont pas sous suivi de version ("untracked") et qui sont les fichiers "README.txt" et "fichier1.txt". Il nous dit aussi qu'aucun fichier n'a été validé ("commit") en base pour le moment ni ajouté pour validation. La commande <span class="html">git status</span> nous informe également sur la branche sur laquelle on se trouve ("master" ici). Nous reparlerons des branches plus tard.</p>
                    <p>L'étape suivante va donc ici être d'indexer nos fichiers afin qu'ils puissent ensuite être validés, c'est-à-dire ajoutés en base et qu'on puisse ainsi avoir un premier historique de version.</p>
                    <p>Pour indexer des fichiers, on utilise la commande <span class="html">git add</span>. On peut lui passer un nom de fichier pour indexer le fichier en question, le nom d'un répertoire pour indexer tous les fichiers du répertoire d'un coup ou encore un "fileglob" pour ajouter tous les fichiers correspondant au schéma fourni.</p>
                    <p>Les fileglobs utilisent les extensions de chemin de fichier. Grosso-modo, cela signifie que certains caractères comme <span class="em">*</span> et <span class="em">?</span> vont posséder une signification spéciale et nous permettre de créer des schémas de correspondances. Le caractère <span class="em">*</span> par exemple correspond à n'importe quel caractère. Lorsque j'écris <span class="html">git add *.txt</span>, je demande finalement à Git d'ajouter à l'index tous les fichiers du projet qui possèdent une extension <span class="em">.txt</span> quelque soit leur nom.</p>
                    <img src="../images/git-add.png" alt="git add">
                    <p>Si on relance une commande <span class="html">gt status</span>, on obtient les informations suivantes :</p>
                    <img src="../images/git-add-status.png" alt="git add status">
                    <p><span class="html">git status</span> nous dit qu'on a maintenant deux nouveaux fichiers ajoutés à l'index. La commande <span class="html">git add</span> permet en fait de faire plusieurs choses : elle permet d'indexer des fichiers déjà sous suivi de version et de placer sous suivi des fichiers non suivi (en plus de les indexer).</p>
                    <p>Ici, on est certains que nos deux nouveaux fichiers ont bien été ajoutés à l'index puisqu'ils apparaissent dans la section "changes to be committed" ("modifications à valider").</p>
                    <p>Pour valider ces fichiers et les ajouter en base, on va maintenant utiliser la commande <span class="html">git commit</span> comme cela :</p>
                    <img src="../images/git-commit.png" alt="git commit">
                    <p>Lorsqu'on utilise <span class="html">git commit</span> sans argument, une nouvelle fenêtre s'ouvre en utilisant l'éditeur par défaut qui est dans la majorité des cas VIM.</p>
                    <img src="../images/git-commit-message-vim.png" alt="git commit message vim">
                    <p>Ici, on nous demande d'ajouter un message avec notre commit. Bien documenter chaque commit permet aux auteurs et aux différents contributeurs à un projet de rapidement comprendre les modifications et de pouvoir les valider. C'est une part essentielle de Git. Ici, j'ajoute simplement le message "Version initiale du projet".</p>
                    <p>Une fois le message entré, si votre éditeur est bien VIM, il faut appuyer sur la touche <span class="html">esc"</span> pour sortir du mode insertion puis taper <span class="html">:wq</span> et <span class="html">entree</span> pour valider et quitter ou <span class="html">:x</span> et <span class="html">entree</span> ou tout simplement <span class="html">ZZ</span>.</p>
                    <p>Une fois sorti de VIM, un message s'affiche avec des informations sur le commit effectué.</p>
                    <img src="../images/git-commit-informations.png" alt="git commit informaions">
                    <p>On nous informe ici qu'on se situe sur la branche master, qu'il s'agit du premier commit (root-commit) et on nous donne sa somme de contrôle (4ed866e) qui permet de l'identifier de manière unique. On nous dit également que deux fichiers ont été modifiés et que 0 lignes ont été ajoutées ou supprimées dans ces fichiers.</p>
                    <p>Si on effectue à nouveau un <span class="html">git status</span>, voici le message renvoyé :</p>
                    <img src="../images/git-status-apres-commit.png" alt="git status après commit">
                    <p>Git nous informe désormais qu'il n'y a plus aucun fichier à vider, ce qui signifie que tous les fichiers sont sous suivi de version et sont enregistrés en base et qu'aucune modification n'a été approtée à ces fichiers depuis le dernier commit.</p>
                    <h2 id="cloner_depot">Cloner un dépôt Git :</h2>
                    <p>La deuxième façon de démarrer un dépôt Git est de cloner localement un dépôt Git déjà existant. Pour cela, on va utiliser la commande <span class="html">git clone</span>.</p>
                    <p>En pratique, dans la grande majorité des cas, nous clonerons des dépôts Git distants, c'est-à-dire des dépôts hébergés sur serveur distants pour pouvoir contribuer à ces projets.</p>
                    <p>Cependant, nous pouvons également cloner des dépôts locaux. Nous parlerons des dépôts distants et apprendrons à les cloner lorsqu'on abordera GitHub. Pour le moment, contentons nous d'essayer de cloner notre dépôt "projet+git" tout juste créé.</p>
                    <p>Pour cela, on va se placer sur le bureau. Comme je suis pour le moment situé dans mon répertoire "projet-git", j'utilise la commande Bash <span class="html">cd ..</span> pour atteindre le répertoire parent 'c'est-à-dire mon bureau).</p>
                    <p>J'utilise ensuite la commande <span class="html">git clone</span> en lui passant d'abord le chemin complet du projet à cloner (qui correspond à son nom dans notre cas puisque le répertoire du projet est également sur le bureau) ouis le chemin complet du clone qui doit être créé. On va choisir de créer le clone sur le bureau par simplicité et on va donc simplement passer un nom à nouveau. Appelons le clone "projet-git-2" par exemple comme ceci :</p>
                    <img src="../images/git-clone-local.png" alt="git clone local">
                    <p>On peut <span class="em">cd</span> dans le répertoire du projet et effetuer un ultime <span class="html">git status</span> pour s'assurer de l'état des fichiers du répertoire :</p>
                    <img src="../images/git-clone-local-status.png" alt="git clone local status">
                    <p>Comme vous pouvez le voir, le dépôt a bien été cloné puisque les fichiers du répertoire projet-git-2 sont déjà bien tous sous suivi de version et sont stockés en base.</p>
                    <h2 id="fichiers_projet_actualiser">Ajouter ou modifier des fichiers dans un projet et actualiser notre dépôt Git :</h2>
                    <p>À ce niveau, nous avons donc d'un côté notre projet contenant un ensemble de ficheirs et de ressources sur lesquelles on travaille ainsi qu'un dépôt Git qui sert à gérer les différentes versions de notre projet.</p>
                    <p>En continuant à travailler sur notre projet, nous allons être amenés à ajouter, modifier, voire supprimer des fichiers. On va indiquer tous ces changements à Git pour qu'il conserve un historique des versions auquel on pourra ensuite accéder pour revenir à un état précédent du projet (dans le cas où une modification entraîne un bogue par exemple ou n'amène pas le résultat souhaité).</p>
                    <p>À chaque fois qu'on souhaite enregistrer une modification de fichier ou un ajout de fichier dans le dépôt Git, on va devoir utiliser les commandes <span class="html">git add</span> et <span class="html">git commit</span> comme on a pu le faire précédemment.</p>
                    <p>J'attire ici votre attention sur un point important : le commit (la validation / l'enregistrement en base de données) d'un fichier se basera sur l'état de ce fichier au moment du <span class="html">git add</span>.</p>
                    <p>Cela signifie que si vous effectuez une commande <span class="html">git add</span> sur un fichier, puis vous modifiez à nouveau le fichier, puis vous effectez un <span class="html">git commit</span>, c'est le fichier dans son état au moment du dernier <span class="html">git add</span> qui sera validé et les dernières modifications ne seront donc pas enregistrées dans le dépôt Git.</p>
                    <p>Si vous souhaitez enregistrer toujours la dernière version d'un fichier, pensez donc bien toujours à effectuer un <span class="html">git add</span> juste avant un <span class="html">git commit</span>. Pour mettre en un coup les fichier modifiés et déjà sous souvi dans la zone d'index puis pour les valider, vous pouvez également utiliser <span class="html">git commit</span> avec une option <span class="html">-a</span> comme ceci : <span class="html">git commit -a</span>. Cela vous dispense d'avoir à taper <span class="html">git add</span>.</p>
                    <h2 id="supprimer_fichier_projet">Supprimer un fichier d'un projet et/ou l'exclure du suivi de version Git :</h2>
                    <p>Concernant la suppression de fichisers, il existe plusieurs situations possibles en fonction de ce que vous souhaitez réellement faire : voulez-vous simplement exclure un fichier du suivi de version mais le conserver dans votre projet ou également le supprimer du projet ?</p>
                    <p>Avant tout, notez que simplement supprimer un fichier de votre dossier avec une commande Bash <span class="em">rm</span> par exemple ne suffira pas pour que Git oublie ce fichier : il apparaîtra dans chaque <span class="html">git status</span> dans une section "changes not stages for commit" (modifications qui ne seront pas validées).</p>
                    <p>On peut s'en assurer en faisant le test. Pour cela, commençons par ajouter un nouveau fichier dans notre répertoire "projet-git". On peut faire cela avec une commande Bash <span class="html">touch</span>.</p>
                    <img src="../images/ajout-fichier-touch.png" alt="ajout fichier touch">
                    <img src="../images/touch-git-status.png" alt="touch git status">
                    <p>Comme le fichier vient tout juste d'être ajouté, on va devoir l'indexer pour qu'il soit sous suivi puis le valider.</p>
                    <img src="../images/git-add-comit-nouveau-fichier.png" alt="git add comit nouveau fichier">
                    <p>Ici, j'utilise la commande <span class="html">git commit</span> avec une option <span class="html">-m</span> qui me permet de renseigner directement le message lié à mon commit plutôt que de devoir le faire dans VIM.</p>
                    <p>Le fichier est désormais sous suivi et la dernière version est enregistrée en base. Essayons maintenant de l'effacer avec une commande <span class="em">rm</span> par exemple et tapons un nouveau <span class="html">git status</span> :</p>
                    <img src="../images/rm-bash-git-status.png" alt="rm bash git status">
                    <p>Comme vous pouvez le voir, Git continue de suivre le fichier et la suppression simple du fichier ne sera pas validée comme changement par Git.</p>
                    <p>Pour supprimer un fichier et l'exclure du suivi de version, nous allons utiliser la commande <span class="html">git rm</span> (et non pas simplement une commande Bash <span class="em">rm</span>).</p>
                    <img src="../images/reajout-fichier-touch-git-status.png" alt="reajout fichier touch git status">
                    <img src="../images/git-rm.png" alt="git rm">
                    <img src="../images/git-rm-commit.png" alt="git rm commit">
                    <p>Pour simplement exlure un fichier du suivi Git mais le conserver dans le projet, on va utiliser la même commande <span class="html">git rm</span> mais avec cette fois-ci une option <span class="html">--cached</span>.</p>
                    <img src="../images/ajout-fichier-touch-2.png" alt="ajout fichier touch 2">
                    <img src="../images/git-rm-cached-abandon-suivi.png" alt="git rm cached abandon suivi">
                    <img src="../images/git-rm-cached-status.png" alt="git rm cached status">
                    <img src="../images/git-rm-cached-commit.png" alt="git rm cached commit">
                    <p>Ici, le fichier a bien été exclu du suivi Git mais existe toujours dans notre projet. On va ensuite pouvoir modifier ce fichier (lui ajouter du texte par exemple) comme n'importe quel fichier et Git ne se préoccupera pas des modifications.</p>
                    <img src="../images/verification-commande-git-rm-cached.png" alt="vérification git rm cached">
                    <h2 id="retirer_fichier_zone_index_git">Retirer un fichier de la zone d'index de Git:</h2>
                    <p>Le contenu de la zone d'index est ce qui sera proposé lors du prochain commit. Imaginons qu'on ait ajouté un fichier à la zone d'index par erreur. Pour retirer un fichier de l'index, on peut utiliser <span class="html">git reset HEAD nom-du-fichier</span>.</p>
                    <p>À la différence de <span class="html">git rm</span>, le fichier continuera d'être suivi par Git. Seulement, le fichier dans sa version actuelle va être retiré de l'index et ne fera donc pas partie du prochain commit.</p>
                    <p>Regardez plutôt l'exemple ci-dessous :</p>
                    <img src="../images/git-reset-retrait-zone-index.png" alt="git reset retrait zone index">
                    <p>Ici, on ajoute le fichier fichier2.txt à l'index et on le passe donc sous suivi de version. On valide cela avec <span class="html">git commit</span> puis on modifie le contenu de notre fichier et on ajoute la dernière version de notre fichier à la zone d'index pour qu'il fasse partie du prochain commit. Finalement, on change d'idée et on veut retirer cette version de la zone d'index. On fait cela avec <span class="html">git reset HEAD fichier2.txt</span>.</p>
                    <h2 id="empecher_indexation_fichiers_git">Empêcher l'indexation de certains fichiers dans Git :</h2>
                    <p>Lorsqu'on dispose d'un projetet qu'on souhaite utiliser Git pour effectuer un suivi de version, il est courant qu'on souhaite exclure certains fichiers du suivi de version comme certains fichiers générés automatiquement, des fichiers de configuration, des fichiers sensibles, etc.</p>
                    <p>On peut informer Git des fichiers qu'on ne souhaite pas indexer en créant un fichier <span class="html">.gitignore</span> et en ajoutant les différents  fichiers qu'on souhaite ignorer. Notez qu'on peut égalemnt mentionner des schémas de noms pour exclure tous les fichiers correspondant à ce schéma et qu'on peut même exclure le contenu entier d'un répertoire en écrivant le chemin du répertoire suivi d'un slash.</p>
                    <h2 id="renommer_fichier_git">Renommer un fichier dans Git :</h2>
                    <p>On peut également renommer un fichier de notre projet depuis Git en utilisant cette fois-ci une commande <span class="html">git mv ancien-nm-fichier nouveau-nom-fichier</span>.</p>
                    <p>On peut par exemple renommer notre fichier "README.txt" en "LISEZMOI.txt" de la manière suivante:</p>
                    <img src="../images/git-mv-renommage-fichier.png" alt="git mv renommage fichier">
                    <p>Le fichier a bien été renommé dans notre répertoire et le changement est prêt à être validé dans le prochain commit.</p>
                    <h2 id="consulter_historique_modifications_git">Consulter l'historique des modifications Git :</h2>
                    <p>La manière la plus simple de consuter l'historique des modifications Git est d'utiliser la commande <span class="html">git log</span>. Cette commande affiche la liste des commits réalisés du plus récent au plus ancien. Par défaut, chaque commit est affiché avec sa somme de contrôle SHA-1, le nom et l'e-mail de l'auteur, la date et le message du commit.</p>
                    <img src="../images/git-log.png" alt="git log">
                    <p>La commande <span class="html">git log</span> supporte également de nombreuses options. Certaines vont pouvoir être très utiles comme par exemple les options <span class="html">-p</span>, <span class="html">--pretty</span>, <span class="html">--since</span> ou <span class="html">--author</span>.</p>
                    <p>Utiliser <span class="html">git log -p</span> permet d'afficher explicitement les différences introduites entre chaque validation.</p>
                    <img src="../images/git-log-option-p.png" alt="git log option p">
                    <p>L'option <span class="html">--pretty</span> permet, avec sa valeur <span class="html">oneline</span>, d'afficher chaque commit sur une seule ligne ce qui peut faciliter la lecture dans le cas où de nombreux commits ont été réalisés.</p>
                    <img src="../images/git-log-pretty.png" alt="git log pretty">
                    <p>L'option <span class="html">--since</span> permet de n'afficher que les modifications depuis une certaine date (on peut lui fournir différents formats de date comme <span class="em">2.weeks</span> ou <span class="em">2019-10-10</span> par exemple).</p>
                    <p>L'option <span class="html">--author</span> permet de n'afficher que les commits d'un auteur en particulier.</p>
                    <h2 id="ecraser_remplacer_commit">Écraser et remplacer un commit :</h2>
                    <p>Parfois, on voudra annuler une validation (un commit), notamment lorsque la validation a été faite en oubliant des fichiers ou sur les mauvaises versions de fichiers.</p>
                    <p>La façon la plus simple d'écraser un commit est d'utiliser la commande <span class="html">git commit</span> avec l'option <span class="html">--amend</span>. Cela va pousser un nouveau commit qui va remplacer le précédent en l'écrasant.</p>
                    <p>Par exemple, dans notre projet, on peut imaginer qu'on souhaite commit les changements  effectués précédemment sur le fichier README.txt qu'on souhaite également réintégrer le fichier fichier2.txt dans l'index.</p>
                    <p>Pour cela, on effectue un <span class="html">git commit</span> :</p>
                    <img src="../images/git-commit-amend-exemple.png" alt="git commit amend exemple">
                    <p>Ici, on s'aperçoit après coup qu'on a oublié de réintégrer le fichier fichier2.txt. On peut utiliser une commande <span class="html">git add</span> puis <span class="html">git commit --amend</span> pour remplacer le commit précédent :</p>
                    <img src="../images/git-commit-amend-commande.png" alt="git commit amend commande">
                    <p>Note : l'éditeur par défaut va s'ouvrir pour vous permettre de modifier le message du commit si vous le souhaitez.</p>
                    <h2 id="annuler_modifications_fichier">Annuler des modifications apportées à un fichier :</h2>
                    <p>L'un des principaux intérêts d'utiliser un logiciel de gestion de vision est de pouvoir "roll back", c'est-à-dire de pouvoir revenir à un état antérieur enregistré d'un projet.</p>
                    <p>Après un commit, on va continuer à travailler sur nos fichiers et à les modifier. Parfois, certaines modifications ne vont pas apporter les comportements espérés et on voudra revenir à l'état du fichier du dernier instantané Git (c'est-à-dire au dernier état enregistré). On va pouvoir faire cela avec la commande générale <span class="html">git checkout -- nom-du-fichier</span> ou la nouvelle commande spécialisée <span class="html">git restore</span>.</p>
                    <p>Imaginons qu'on modifie le texte de notre fichier LISEZMOI.txt avec une commande <span class="html">echo</span> et <span class="html">&gt;&gt;</span>.</p>
                    <img src="../images/git-restore-exemple.png" alt="git restore exemple">
                    <p>On se rend ensuite compte que ce texte ne convient pas et on souhaite revenir à l'état du fichier tel qu'il a été enregistré pour la dernière fois dans Git.Pour cela, on utilise simplement <span class="html">git restore LISEZMOI.txt</span>.</p>
                    <img src="../images/git-restore-commande.png" alt="git restore commande">
                    <h2 id="branche">Qu'est-ce qu'une branche ?</h2>
                    <p>Créer une branche, c'est en quelque sorte comme créer une "copie" de votre projet pour développer et tester de nouveles fonctionnalités sans impacter le projet de base.</p>
                    <p>Dans la plupart des système de contrôle de version, justement, une copie physique de la totalité du répertoire de travail est effectuée, ce qui rend la création de branches contraignante et en fait une opération lourde.</p>
                    <p>Git a une approche totalement différente des branches qui rend la création de nouveles branches et la fusion de branche très facile à réaliser. Une branche, dans Git, est simplement un pointeur vers un commit (une branche n'est qu'un simple fichier contenant les 40 caractères de l'empreinte SHA-1 du commit sur lequel elle pointe).</p>
                    <p>Pour rappel, lorsqu'on effectue un commit, Git stocke en fait un objet <span class="html">commit</span> qui contient les nom et prénom de l'auteur du commit, le message renseigné lors de la création du commit ainsi qu'un pointeur vers l'instantané du contenu indexé et des pointeurs vers le ou les commits précédant directement le commit courant.</p>
                    <p>Un pointeur est un objet qui contient l'adresse d'une donnée stockée quelque part. On peut utiliser le pointeur pour accéder à la donnée en question.</p>
                    <p>La branche par défaut dans Git s'appelle <span class="html">master</span>. Cette branche <span class="html">master</span> va se déplacer automatiquement à chaque nouveau commit pour pointer sur le dernier commit effectué tant qu'on reste sur cette branche.</p>
                    <p>Notez que la branche <span class="html">master</span> n'est pas une branche spéciale pour Git : ele est traitée de la même façon que les autres branches. L'idée est que lorsqu'on tape une commande <span class="html">git init</span>, une branche est automatiquement créée et que le nom donné à cette branche par Git par défaut est "master". On pourrait très bien la renommer ensuite mais ça ne présente généralement aucun intérêt.</p>
                    <p>En résumé, une branche est un pointeur vers un commit en particulier. Un commit est un objet qui contient un pointeur vers l'instantané du contenu indexé ainsi que des pointeurs vers le ou les commits le précédant directement.</p>
                    <p>Ainsi, créer une nouvelle branche dans Git crée simplement un nouveau pointeur plutôt que de recopier l'intégralité du répertoire de travail.</p>
                    <h2 id="creer_nouvelle_branche">Créer une nouvelle branche :</h2>
                    <p>Pour créer une nouvelle branche, on utilise la commande <span class="html">git branch nom-de-la-branche</span>. Cette syntaxe va créer un nouveau pointeur vers le dernier commit effectué (le commit courant). À ce stade, vous allez donc avoir deux branches (deux pointeurs) vers le dernier commit : la branche master et la branche tout juste créée.</p>
                    <img src="../images/git-branch.png" alt="git branch">
                    <img src="../images/git-branch-ilustration.jpg" alt="git branch illustration">
                    <p>Pour déterminer quel pointeur vous utilisez, c'est-à-dire sur quelle branche vous vous trouvez, Git utilise un autre pointeur spécial appelé <span class="html">HEAD</span>. <span class="html">HEAD</span> pointe sur la branche master par défaut. Notez que la commande <span class="html">git branch</span> permet de créer une nouvelle branche mais ne déplace pas <span class="html">HEAD</span>.</p>
                    <p>Nous allons donc devoir déplacer explicitement <span class="html">HEAD</span> pour indiquer à Git qu'on souhaite basculer sur une autre branche. On utilise pour cela la commande <span class="html">git checkout</span> suivi du nom de la branche sur laquelle on souhaite basculer.</p>
                    <img src="../images/git-checkout.png" alt="git checkout">
                    <img src="../images/git-checkout-illustration.jpg" alt="git checkout illustration">
                    <p>Note : On peut également utiliser <span class="html">git checkout -b</span> pour créer une branche et basculer immédiatement dessus. Cela est l'équivalent d'utiliser <span class="html">git branch</span> puis <span class="html">git checkout</span>.</p>
                    <p><span class="html">HEAD</span> pointe maintenant vers notre branche <span class="html">test</span>. Si on effectue un nouveau commit, la branche <span class="html">test</span> va avancer automatiquement tandis que <span class="html">master</span> va toujours pointer sur le commit précédent. C'est en effet la branche sur laquelle on se situe lors d'un commit qui va pointer sur ce commit.</p>
                    <img src="../images/git-head-branche.png" alt="git HEAD branche">
                    <img src="../images/git-head-branche-illustration.jpg" alt="git HEAD branche illustration">
                    <h2 id="basculer_branches">Basculer entre les branches :</h2>
                    <p>On peut revenir sur notre branche <span class="html">master</span> en tapant à nouveau une commande <span class="html">git checkout master</span>. Cela replace le pointeur <span class="html">HEAD</span> sur la branche <span class="html">master</span> et restaure le répertoire de travail dans l'état de l'instantané pointé par le commit sur lequel pointe <span class="html">master</span>.</p>
                    <img src="../images/git-checkout-master.png" alt="git checkout master">
                    <img src="../images/git-checkout-master-illustration.jpg" alt="git checkout master illustration">
                    <p>Si on modifie alors le répertoire de travail et qu'on effectue un nouveau commit, les deux branches <span class="html">master</span> et <span class="html">test</span> vont diverger. On va donc avoir deux branches pointant vers des instantanés qui ont enregistré le projet dans deux états différents.</p>
                    <img src="../images/git-branche-diverge.png" alt="git branche diverge">
                    <img src="../images/git-branches-diverge-illustration.jpg" alt="git branche diverge illustration">
                    <h2 id="fusion_rebasage_git">Fusion et rebasage avec Git :</h2>
                    <p>Précédemment, on a vu comment créer différentes branches pour un projet. Généralement, on va créer de nouvelles branches pour travailler sur de nouvelles fonctionnalités pour notre projet sans impacter la ligne de développement principale (représentée par notre branche principale).</p>
                    <p>On va donc développer nos fonctionnalités sur des branches connexes et les tester jusqu'à ce qu'on soit sûrs qu'il n'y a pas de problème et on va finalement réintégrer ces fonctionnalités développées au sein de notre ligne de développement principale.</p>
                    <p>Pour faire cela, il va falloir rapatrier le contenu des branches créées dans la branche principale. On peut faire ça de deux manières avec Git : en fusionnant les branches ou en rebasant.</p>
                    <h2 id="fusionner_branches">Fusionner des branches :</h2>
                    <p>Commençons par nous concentrer sur la fusion de branches.</p>
                    <p>Précédemment, on avait fini avec deux branches <span class="html">master</span> et <span class="html">test</span> divergentes. On parle de divergence car les deux branches possèdent un ancêtre commit en commun mais pointent chacune vers de nouveaux commits qui peuvent correspondre à des modifications différentes d'un même fichier du projet.</p>
                    <p>Revenons un peu en arrière pour commencer avec un cas plussimple et imaginons que notre projet soit dans cet état :</p>
                    <img src="../images/fusion-branches-git-exemple.jpg" alt="fusion branches git exemple">
                    <p>Ici, on a une branche <span class="html">test</span> qui pointe sur un commit commitN+1 et une branche <span class="html">master</span> qui pointe sur un commit commitN. commitN est l'ancêtre direct de commitN+1 et il n'y a donc pas de problème de divergence.</p>
                    <p>Pour fusionner nos deux branches, on va se placer sur <span class="html">master</span> avec une commande <span class="html">git checkout</span> puis taper une commande <span class="html">git merge</span> avec le nom de la branche qu'on souhaite fusionner avec <span class="html">master</span>.</p>
                    <p>Dans ce cas, "fusionner" nos deux branches revient finalement à faire avancer <span class="html">master</span> au niveau du commit pointé par <span class="html">test</span>. C'est exactement ce que fait Git et c'est ce qu'on appelle un "fast forward" (avance rapide).</p>
                    <p>Il ne nous reste alors plus qu'à effacer notre branche <span class="html">test</span>. On peut faire cela en utilisant la commande <span class="html">git branch -d</span>.</p>
                    <p>Reprenons maintenant la situation précédente avec deux branches dont les historiques divergent. On peut représenter cette situation comme cela :</p>
                    <img src="../images/git-branches-diverge-fusion-rebasage.jpg" alt="git branches diverge fusion rebasage">
                    <p>Pour fusionner deux branches ici on va à nouveau se placer dans laquelle on souhaite fusionner puis effectuer un <span class="html">git merge</span>.</p>
                    <p>Ici, comme la situation est plus complexe, il me semble intéressant d'expliquer comment Git fait pour fusionner les branches. Dans ce cas, Git réalise une fusion en utilisant 3 sources : le dernier commit commun aux deux branches et le dernier commit de chaque branche.</p>
                    <p>Cette fois-ci, plutôt que de simplement faire un fast forward, Git crée automatiquement un nouvel instantané dont le contenu est le résultat de la fusion ainsi qu'un commit qui pointe sur cet instantané. Ce commit s'appelle un commit de fusion et est spécial puisqu'il possède plusieurs parents.</p>
                    <p>Notez que dans le cas d'une fusion à trois sources, il se peut qu'il y ait des conflits. Cela va être notamment le cas si une même partie d'un fichier a été modifiée de différentes manières dans les différentes branches. Dans ce cas, lors de la fusion, Git nous alertera du conflit et nous demander de le résoudre avant de terminer la fusion des branches.</p>
                    <p>On peut utiliser une commande <span class="html">git status</span> pour voir précisément quels fichiers sont à l'origine du conflit. Imaginons par exemple que nos deux branches possèdent un fichier LISEZMOI.txt et que les deux fichiers LISEZMOI.txt possèdent des textes différents. Git va automatiquement "fusionner" les contenus des deux fichiers de base à la suite l'un de l'autre avec des indicateurs de séparation.</p>
                    <p>On peut alors ouvrir le fichier à la main et choisir ce qu'on conserve (en supprimant les parties qui ne nous intéressent pas par exemple). Dès qu'on a terminé l'édition, on va taper une commande <span class="html">git add</span> pour marquer le conflit comme résolu. On n'aura alors plus qu'effectuer un <span class="html">git commit</span> pour terminer le commit de fusion.</p>
                    <h2 id="rebaser">Rebaser :</h2>
                    <p>Git nous fournit deux moyens de rapatrier le travail effectué sur une branche vers une autre : on peut fusionner ou rebaser. Nous allons maintenant nous intéresser au rebasage, comprendre les différences entre la fusion et le rebasage et voir dans quelle situation utiliser une opération plutôt qu'une autre.</p>
                    <p>Reprenons notre exemple précédent avec nos deux branches divergentes.</p>
                    <img src="../images/git-branches-diverge-fusion-rebasage.jpg" alt="git branches diverge fusion rebasage">
                    <p>Plutôt que d'effectuer une fusion à trois sources, on va pouvoir rebaser les modifications validées dans commitN+1 dans notre branche <span class="html">master</span>. On utilise la commande <span class="html">git rebase</span> pour récupérer les modifications validées sur une branche et les rejouer sur une autre.</p>
                    <p>Dans ce cas, Git part à nouveau du dernier commit commun aux deux branches (l'ancêtre commun le plus récent) puis récupère les modifications effectuées sur la branche vers laquelle on souhaite rebaser notre travail dans l'ordre dans lequel elles ont été introduites.</p>
                    <img src="../images/git-branches-rebase.jpg" alt="git branches rebase">
                    <p>Le résultat final est le même qu'avec une fusion mais l'historique est plus clair puisque toutes les modifications apparaissent en série même si elles ont eu lieu en parallèle. Rebaser rejoue les modifications d'une ligne de commits sur une autre dans l'ordre d'apparition, alors que la fusion joint et fusionne les deux têtes.</p>
                    <p>Gardez cependant à l'esprit que rebaser équivaut à supprimer des commits existants pour en créer de nouveaux (qui sont similaires de par leur contenu mais qui sont bien des entités différentes). Pour cette raison, vous ne devez jamais rebaser des commits qui ont déjà été poussés sur un dépôt public.</p>
                    <p>En effet, imaginons la situation suivante :</p>
                    <ol>
                        <li>Vous poussez des commits sur un dépôt public;</li>
                        <li>Des personnes récupèrent ces commits et se basent dessus pour travailler;</li>
                        <li>Vous utilisez un <span class="html">git rebase</span> pour "réécrire" ces commits et les poussez à nouveau.</li>
                    </ol>
                    <p>Dans ce cas, des problèmes vont se poser puisque les gens qui ont travaillé à partir des commits de départ ne vont pas les retrouver dans le projet s'ils veulent récupérer les mises à jour et lorsqu'ils vont pousser leur modification sur le dépôt public les commits effacés vont être réintroduits ce qui va créer un historique très confus et potentiellement des conflits.</p>
                    <h2 id="utilisation_github">Découverte et utilisation de GitHub :</h2>
                    <p>GitHub est la plus grande plateforme d'hébergement de projets Git au monde. Vous serez probablement amené à travailler avec GitHub et il est donc important de comprendre comment ce service fonctionne.</p>
                    <p>Commencez déjà par noter que GitHub est un outil gratuitpour héberger du code open source, et propose également des plans payants pour les projets de code privés.</p>
                    <p>Pour utiliser GitHub, il suffit de créer un compte gratuitement sur le site <a href="https://github.com" target="_blank">https://github.com</a>.</p>
                    <p>Le grand intérêt de GitHub est de faciliter la collaboration à une échelle planétaire sur les projets : n'importe qui va pouvoir récupérer des projets et y contribuer (sauf si le propriétaire du projet ne le permet pas bien entendu).</p>
                    <p>Sur GitHub, nous allons en effet notamment pouvoir cloner des projets (dépôts) publics, dupliquer ("fork") des projets ou encore contribuer à des projets en proposant des modifications ("pull request").</p>
                    <h2 id="contribuer_projet_github_copier">Contribuer à un projet avec GitHub ou le copier :</h2>
                    <p>Sur GitHub, nous allons pouvoir contribuer aux projets publics d'autres personnes ou créer nos propres dépôts publics afin que d'autres personnes contribuent à nos propres projets. Commençons déjà par nous familiariser avec l'aspect contributeur de GitHub.</p>
                    <p>GitHub est une gigantesque plateforme collaborative qui héberge des dépôts Git. Pour rechercher des dépôts auxquels contribuer ou pour rechercher des fonctionnalités intéressantes qu'on aimerait récupérer, on peut aller dansl'onglet "explore" ou chercher un dépôt en particulier grâce à la barre de recherche en haut du site.</p>
                    <img src="../images/depot-github-explore.png" alt="dépôt GitHub explore">
                    <p>Les étapes pour contribuer à un projet (le cycle de travail) vont toujours les mêmes :</p>
                    <ol>
                        <li>On copie un projet sur notre espace GitHub;</li>
                        <li>On crée une branche thématique à partir de master;</li>
                        <li>On effectue nos modifications/améliorations au projet;</li>
                        <li>On pousse ensuite la branche locale vers le projet qu'on a copié sur GitHub et on ouvre une requête de tirage depuis GitHub;</li>
                        <li>Le propriétaire du projet choisit alors de refuser nos modifications ou de les fusionner dans le projet d'origine;</li>
                        <li>On met à jour notre version du projet en récupérant les dernière modifications à partir du projet d'origine.</li>
                    </ol>
                    <h2 id="copier_depot_clone_fork">Copier un dépôt : clone vs fork :</h2>
                    <p>Pour copier un dépôt (repository) GitHub sur nos machines, il suffit d'utiliser l'option "clone URL" de GitHub pour récupérer le lien du repo puis d'utiliser la commande <span class="html">git clone [URL]</span> dans notre console.</p>
                    <p>On peut également utiliser l'option "fork" de GitHub. Un fork est une copie d'un dépôt distant qui nous permet d'effectuer des modifications sans affecter le projet original.</p>
                    <img src="../images/fork-depot-github.png" alt="fork dépôt GitHub">
                    <p>La différence entre un fork et un clone est que lorsqu'on fork une connexion existe entre notre fork (notre copie) et le projet original. Cela permet notamment de pouvoir très simplement contribuer au projet original en utilisant des pull requests, c'est-à-dire en poussant nos modifications vers le dépôt distant afin qu'elles puissent être examinées par l'auteur du projet original.</p>
                    <p>Lorsqu'on clone un projet, on ne va pas pouvoir ensuite récupérer les changements à partir du projet d'origine ni contribuer à ce projet à moins que le propriétaire du projet d'origine ne nous accorde des droits spéciaux (privilèges).</p>
                    <p>Le fork est une fonctionnalité très utile puisqu'elle permet à n'importe quelle personne de pouvoir dupliquer un projet et de contribuer à ce projet tout en garantissant à l'auteur du projet l'intégrité du projet original car ce sera à lui de valider ou pas les différentes pull requests (requêtes de tirage) des contributeurs.</p>
                    <h2 id="creer_branche_thematique_branche_principale">Créer une branche thématique à partir de la branche principale :</h2>
                    <p>Pour contribuer à un projet, on va donc très souvent le copier en le forkant. Cela créeune copie du projet dans notre espace GitHub. On va ensuite créer une branche thématique et effectuer nos modifications.</p>
                    <p>Pour cela, une fois sur la page du projet forké dans notre espace personnel Git, on va cliquer sur le bouton de liste "branch" et ajouter un nom pour créer une nouvelle branche.</p>
                    <img src="../images/creer-branche-thematique-github.png" alt="créer branche thématique GitHub">
                    <p>Rappelez-vous qu'on utilise les branches pour expérimenter et apporter des modifications sans polluer notre branche principale (master par défaut). Lorsqu'on crée une branche à partir de la branche master, on effectue une copie (un instantané ou snapshot) de master telle qu'elle était à ce moment-là. Si quelqu'un d'autre apporte des modifications à la branche principale pendant qu'on travaille sur notre branche, il faudra qu'on récupère ces mises à jour.</p>
                    <p>Note importante : on peut également bien évidemment cloner le projet localement (sur notre machine) afin de pouvoir travailler dessus hors connexion puis renvoyer ensuite les modifications vers notre projet forké. Dans cette partie, je vais cependant me concentrer sur ce qu'il est possible de faire depuis GitHub seulement.</p>
                    <h2 id="effectuer_modifications_projet">Effectuer des modifications au projet :</h2>
                    <p>Pour modifier un fichier, on va cliquer sur le fichier en question puis sur l'icône en forme de crayon à droite. Cela ouvre un éditeur.</p>
                    <img src="../images/modifier-depot-github.png" alt="modifier dépôt GitHub">
                    <img src="../images/modifier-depot-github-editeur.png" alt="modifier dépôt GitHub éditeur">
                    <p>On peut alors modifier les fichiers puis commit nos modifications dès qu'on les juge satisfaisantes. Pour cela, il suffit de renseigner un message de commit et de cliquer sur le bouton "commit changes" en bas de la page.</p>
                    <img src="../images/modifier-depot-github-commit.png" alt="modifier dépôt GitHub commit">
                    <h2 id="pull_request">Pousser nos modifications : pull request :</h2>
                    <p>Une fois qu'on a terminé nos modifications, on va pouvoir les proposer. Pour cela, on va ouvrir une requête de tirage ou "pull request".</p>
                    <p>Pour effectuer un pull reques, on clique sur l'onglet "pull requests" puis sur "compare & pull request" ou sur "new pull request".</p>
                    <img src="../images/github-pull-request.png" alt="GitHub pull request">
                    <p>Effectuer une requête de tirage correspond à demander à quelqu'un d'examiner et d'extraire votre contribution et de la fusionner dans sa branche. Les demandes d'extraction montrent des différences de contenu des deux branches. Les modifications, ajouts et soustractions sont affichés en vert et en rouge.</p>
                    <p>Suite à un pull request, le propriétaire du projet examine notre contribution et une discussion peut s'engager s'il souhaite qu'on effectue d'autres modifications.</p>
                    <h2 id="fusionner_pull_request">Fusionner notre pull request :</h2>
                    <p>La dernière étape du processus de travail correspond à fusionner notre branche thématique dans notre branche principale afin de réincorporer les changements effectués et d'avoir une branche principale à jour.</p>
                    <p>Pour cela, on peut cliquer sur le bouton "merge request" suite à notre pull request.</p>
                    <h2 id="creer_depot_github">Créer un dépôt GitHub :</h2>
                    <p>La deuxième face de GitHub correspond à la création de dépôt sur GitHub afin que des gens collaborent dessus. Pour créer un nouveau dépôt sur GitHub, il suffit cliquer sur l'icône "+" située en haut à droite puis sur "new repository". Une page s'ouvre vous permettant de créer un nouveau dépôt.</p>
                    <p>Note : vous pouvez également importer un dépôt en cliquant sur "import repository".</p>
                    <img src="../images/creer-depot-github.png" alt="créer un dépôt GitHub">
                    <p>Sur la page de création de dépôt, vous devez renseigner un nom et une description pour le dépôt. Vous avez également une option "Initialise with a README", qui vous permet de cloner votre dépôt sur votre machine. Cette option està cocher uniquement dans le cas où vous n'avez pas encore créé le dépôt en question sur votre machine.</p>
                    <h2 id="github_git_inversement">De GitHub à Git et inversement :</h2>
                    <p>GitHub permet de contribuer simplement à des projets ou de laisser les gens contribuer à ces propres projets.</p>
                    <p>La plupart des gens qui utilisent GitHub vont cependant souvent préférer travailler hors ligne (en local; sur leur machine) plutôt que de devoir être constamment connecté à GitHub et de devoir passer par cette plateforme pour effectuer toutes les opérations.</p>
                    <p>Pour travailler localement, il suffit de cloner un projet après l'avoir forké. On va ensuite pouvoir effectuer nos différentes modifications sur notre machine.</p>
                    <p>Pour synchroniser les modifications faites depuis notre machine avec notre dépôt distant (dépôt GitHub), il suffit de faire un <span class="html">git commit</span> depuis le dépôt local et de push (envoyer) les modifications sur le dépôt GitHub à l'aide de la commande <span class="html">git push [nom-distant] [nom-local]</span>. Taper <span class="html">git push origin master</span> par exemple revient à envoyer les modifications situées dans ma branche master vers origin.</p>
                    <p>Pour récupérer en local les dernières modifications du dépôt GitHub, on va utiliser la commande <span class="html">git pull [nom-distant] [nom-local]</span>.</p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
    </body>
</html>