<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Software Security - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>

        <div id="menu">
            <nav role="navigation" aria-label="Menu secondaire">
                <ol>
                    <li><a href="../supplements.html">Retour au sommaire</a></li>
                    <li><a href="#comprendre_menaces_modeles_attaques">Comprendre les menaces et les modèles d'attaques</a></li>
                    <li><a href="#typologie_menaces">Typologie des menaces</a></li>
                    <li><a href="#definitions_cles">Définitions clés</a></li>
                    <li><a href="#failles_vulnerabilites_logiciels">Failles et vulnérabilités des logiciels</a></li>
                    <li><a href="#faille_securite">Faille de sécurité</a></li>
                    <li><a href="#reduire_vulnerabilites_logicielles">Réduire les vulnérabilités logicielles</a></li>
                    <li><a href="#programmation_defensive">Programmation défensive</a></li>
                    <li><a href="#lab1">Lab 1 : Environnement d'exécution</a></li>
                    <li><a href="#gcc">GCC</a></li>
                    <li><a href="#OWASP_Top10_Lab_Setup">OWASP Top 10 Lab Setup</a></li>
                    <li><a href="laboC">Labo C - Compilation, édition de liens, debugging & sécurité mémoire</a></li>
                </ol>
            </nav>
            
            <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
            <aside id="aside" role="complementary">
                <p>Liens utiles :</p>
                <ul>
                    <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                </ul>
            </aside>
        </div>
        
        <main id="container" role="main" tabindex="-1">
            <section id="mainSection">
                <article>
                    <h1>Software Security :</h1>
                </article>
                <article>
                    <h2 id="comprendre_menaces_modeles_attaques">Comprendre les menaces et les modèles d'attaques :</h2>
                    <p><q lang="en">You can't defend what you don't understand</q></p>
                    <p>Exemple : Threat Modeling, STRIDE, DREAD, MITRE ATT&CK</p>
                    <h3>Pourquoi comprendre les menaces ?</h3>
                    <ol>
                        <li>
                            <h4>Anticiper au lieu de subir :</h4>
                            <p>Comprendre les menaces, c'est <span class="em">penser comme un attaquant</span> pour anticiper les vecteurs d'exploitation possibles. Cela permet de :</p>
                            <ul>
                                <li>
                                    <p>Identifier les <span class="em">actifs critiques</span> avant qu'ils ne soient ciblés.</p>
                                </li>
                                <li>
                                    <p>Réduire les <span class="em">surfaces d'attaque</span> avant même la mise en production.</p>
                                </li>
                                <li>
                                    <p>Prioriser les contrôles de sécurité selon les <span class="em">risques réels</span>.</p>
                                </li>
                            </ul>
                            <p>Exemple : Une application Web sans analyse de menace risque d'ignorer que des formulaires d'authentification peuvent subir du brute force ou du credential stuffing.</p>
                        </li>
                        <li>
                            <h4>Intégrer la sécurité dès la conception (Shift Left) :</h4>
                            <p>Comprendre les menaces permet de <span class="em">concevoir un logiciel résilient</span> dès les premières phases du SDLC.</p>
                            <ul>
                                <li>
                                    <p>Les <span class="em">architectes</span> peuvent modéliser les menaces via <span class="em">DFD + STRIDE</span>.</p>
                                </li>
                                <li>
                                    <p>Les <span class="em">développeurs</span> peuvent intégrer des contre-mesures directement dans le code.</p>
                                </li>
                                <li>
                                    <p>Les <span class="em">testeurs</span> peuvent dériver des scénarios de test à partir des menaces connues.</p>
                                </li>
                                <li>
                                    <p>Outils utilisés :</p>
                                    <p>OWASP Threat Dragon, Microsoft Threat Modeling Tool, IriusRisk</p>
                                    <p>MITRE ATT&CK (pour mapping des TTP)</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Améliorer la priorisation et la gestion des risques :</h4>
                            <p>Comprendre les menaces aide à <span class="em">hiérarchiser les efforts de sécurité</span>.</p>
                            <p>Toutes les vulnérabilités ne se valent pas : une faille de configuration mineure n'a pas le même impact qu'une injection RCE.</p>
                            <p>Exemple pratique :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Vulnérabilité</th>
                                        <th>Impact</th>
                                        <th>Probabilité</th>
                                        <th>Risque global</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>XSS sur page interne</td>
                                        <td>Moyen</td>
                                        <td>Faible</td>
                                        <td>Moyen</td>
                                    </tr>
                                    <tr>
                                        <td>Insecure Deserialization</td>
                                        <td class="em">Élevé</td>
                                        <td>Moyen</td>
                                        <td class="em">Élevé</td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <h4>Favoriser la communication inter-équipes :</h4>
                            <p>Les modèles de menaces servent de langage commun entre Développeurs, Architectes, DevOps/SecOps et Auditeurs et RSSI</p>
                            <p>Cela favorise la culture sécurité et réduit les malentendus : tout le monde parle en termes de menace, impact, scénario d'attaque, contre-mesure.</p>
                        </li>
                        <li>
                            <h4>Se conformer aux normes et référentiels :</h4>
                            <p>Les frameworks exigent une compréhension claire des menaces :</p>
                            <ul>
                                <li>
                                    <p>ISO 27034 (Application Security).</p>
                                </li>
                                <li>
                                    <p>NIST SSDF (Secure Software Development Framework).</p>
                                </li>
                                <li>
                                    <p>OWASP SAMM (Threat Assessment).</p>
                                </li>
                                <li>
                                    <p>NIS2 / ENISA Guidelines (Supply chain threat modeling).</p>
                                </li>
                            </ul>
                            <p>Sans modélisation de menace, il est impossible de démontrer la conformité à ces cadres.</p>
                        </li>
                        <li>
                            <h4>Réduire les coûts de correction :</h4>
                            <p>Une menace identifiée <span class="em">tôt</span> coûte 30 à 100 fois moins cher à corriger qu'en production.</p>
                            <p>Exemple :</p>
                            <p>Correction d'un XSS détecté à la conception &#8594; 100€</p>
                            <p>Correction après compromission &#8594; 10000€ +</p>
                            <img src="../images/cout_correction_defaut_phase_developpement.PNG" alt="">
                            <p>SRC : IBM System Science Institute : Relative Cost of Fixing Defects</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="typologie_menaces">Typologie des menaces :</h2>
                    <ul>
                        <li>
                            <p>Attaques <span class="em">logicielles</span> : injection, corruption mémoire, logique métier</p>
                        </li>
                        <li>
                            <p>Attaques <span class="em">infrastructurelles</span> : réseau, système, container</p>
                        </li>
                        <li>
                            <p>Attaques <span class="em">supply chain / open source</span> : Exemples réels : SolarWinds, Log4Shell, XZ backdoor</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="definitions_cles">Définitions clés :</h2>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Élément</th>
                                <th>Définition</th>
                                <th>Exemple concret</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="em">Actif</td>
                                <td>Ce qu'on cherche à protéger (donnée, service, identité, code)</td>
                                <td>Base de données clients</td>
                            </tr>
                            <tr>
                                <td class="em">Menace</td>
                                <td>Intention ou événement malveillant exploitant une faille</td>
                                <td>Attaquant injectant du code SQL</td>
                            </tr>
                            <tr>
                                <td class="em">Vulnérabilité</td>
                                <td>Faiblesse technique ou logique exploitable</td>
                                <td>Entrée utilisateur non filtrée</td>
                            </tr>
                            <tr>
                                <td class="em">Impact</td>
                                <td>Conséquence si la menace se réalise</td>
                                <td>Vol de données, compromission</td>
                            </tr>
                            <tr>
                                <td class="em">Risque</td>
                                <td>Combinaison probabilité x impact</td>
                                <td>Risque élevé de fuite de données</td>
                            </tr>
                        </tbody>
                    </table>
                    <img src="../images/chaine_logique_menace_risque.PNG" alt="">
                    <h3>Common Weakness Enumeration - Top 25 -2024 :</h3>
                    <div>
                        <img src="../images/CWE_MITRE_TOP_25_2024.PNG" alt="" class="float_left">
                        <p>Table 1</p>
                        <p>CWE/MITRE TOP 25 Most Dangerous Software Weaknesses (2024)</p>
                    </div>
                </article>
                <article>
                    <h2 id="failles_vulnerabilites_logiciels">Failles et vulnérabilités des logiciels :</h2>
                    <p>Les failles critiques de sécurité des applications web comprennent 5 failles liées à un code non sécurisé :</p>
                    <ul>
                        <li>
                            <p>Entrées non validées (en C)</p>
                        </li>
                        <li>
                            <p>Cross-site scripting</p>
                        </li>
                        <li>
                            <p>Buffer overflow (en C)</p>
                        </li>
                        <li>
                            <p>Failles d'injection</p>
                        </li>
                        <li>
                            <p>Gestion incorrecte des erreurs</p>
                        </li>
                    </ul>
                    <p>Ces failles sont le résultat d'une vérification et d'une validation insuffisante des données et des codes d'erreur dans les programmes.</p>
                    <p>La prise de conscience de ces problèmes est une première étape essentielle pour écrire un code plus sécurisé.</p>
                    <p>Il est important de souligner la nécessité pour les développeurs de se pencher sur ces failles préoccuppantes et connues.</p>
                    <figure>
                        <img src="../images/failles_vulnerabilites_logiciels.PNG" alt="">
                        <figcaption>Source : <a href="https://gbhackers.com" target="_blank">https://gbhackers.com</a></figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="faille_securite">Faille de sécurité :</h2>
                    <p>Chaque faille représente un écart entre l'intention du développeur et le comportement réel du logiciel face à un attaquant.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_type.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                    <p>Chaque faille représente un écart entre l'intention du développeur et le comportement réel du logiciel face à un attaquant. Selon le site <a href="https://www.cvedetails.com" target="_blank">www.cvedetails.com</a> en 2024, le total des failles recensées était de 40303.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_type_year.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                    <p>En 2024, le total des failles recensées était de 40303, dont 7443 XSS et 2645 SQLi. Début octobre 2025, on recense 36705 failles et, à la fin de l'année 2025, on projette un nombre de failles proches de 50000.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_types_categories.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="reduire_vulnerabilites_logicielles">Réduire les vulnérabilités logicielles :</h2>
                    <p>Le framework NIST SSDF présente une série d'approches visant à réduire le nombre de vulnérabilités logicielles (voir NIST-SP 800-218).</p>
                    <p>Il recommande :</p>
                    <ul>
                        <li>
                            <p>D'empêcher les vulnérabilités avant qu'elles ne surviennent en utilisant des méthodes améliorées pour spécifier et développer les logiciels.</p>
                        </li>
                        <li>
                            <p>De détecter les vulnérabilités avant qu'elles ne puissent être exploitées en utilisant des techniques de test plus efficaces.</p>
                        </li>
                        <li>
                            <p>De réduire l'impact des vulnérabilités en développant des architectures logicielles plus résilientes.</p>
                        </li>
                    </ul>
                    <h3>NIST-SP 800-218 :</h3>
                    <img src="../images/NIST-SP_800-218.PNG" alt="">
                    <p><a href="../files/nist.sp.800-218.ssdf-table.xlsx">Tableau NIST-SP 800-218 (en Excel)</a></p>
                    <h3>Qualité et fiabilité des logiciels :</h3>
                    <ul>
                        <li>
                            <p>Éviter toute défaillance accidentelle résultant d'une entrée théoriquement aléatoire et imprévue, ou d'une imprévue, ou d'une intéraction non contrôlée avec le système, ou utiliser un code incorrect (logique incorrecte).</p>
                        </li>
                        <li>
                            <p>Améliorer à l'aide d'un design structuré et de tests afin d'identifier et éliminer autant de bugs que possible dans un programme.</p>
                        </li>
                        <li>
                            <p>La préoccupation ne porte pas sur le nombre de bugs, mais sur la fréquence à laquelle ils se déclenchent.</p>
                        </li>
                    </ul>
                    <h3>Failles et vulnérabilités :</h3>
                    <ul>
                        <li>
                            <p>L'attaquant cible spécifiquement les bugs qui provoquent une défaillance pouvant être exploitée (par l'attaquant).</p>
                        </li>
                        <li>
                            <p>Déclenchées par des entrées qui diffèrent considérablement de ce qui est habituellement attendues.</p>
                        </li>
                        <li>
                            <p>Peu susceptible d'être identifié par les méthodes d'analyse courantes.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="programmation_defensive">Programmation défensive :</h2>
                    <ul>
                        <li>
                            <p>Concevoir et mettre en oeuvre des logiciels de manière à ce qu'ils continuent de fonctionner même lorsqu'ils sont attaqués.</p>
                        </li>
                        <li>
                            <p>Exige de prêter attention à tous les aspects de l'exécution du programme, à l'environnement et au type de données qu'il traite.</p>
                        </li>
                        <li>
                            <p>Le logiciel est capable de détecter les conditions erronées résultant d'une attaque.</p>
                        </li>
                        <li>
                            <p>Également appelé "programmation sécurisée".</p>
                        </li>
                        <li>
                            <p>La règle d'or est de ne jamais présumer de quoi que ce soit, de vérifier toutes les hypothèses et de gérer tous les états d'erreur possibles.</p>
                        </li>
                        <li>
                            <p>Les programmeurs émettent souvent des hypothèses sur le type d'entrées qu'un programme recevra et l'environnement dans lequel il s'exécutera.</p>
                            <p>Ces hypothèses doivent être validées par le programme et toutes les défaillances potentielles doivent être gérées avec sécurité.</p>
                        </li>
                        <li>
                            <p>Nécissite un changement de mentalité par rapport aux pratiques de programmation traditionnelles.</p>
                            <p>Les programmeurs doivent comprendre comment les défaillances peuvent se produire et les mesures à prendre pour réduire le risque qu'elles se produisent dans leurs programmes.</p>
                        </li>
                        <li>
                            <p>Danger !!! Les conflits avec les pressions commerciales visant à réduire au maximum les délais de développement afin de maximiser l'avantage concurrentiel.</p>
                        </li>
                    </ul>
                    <h3>Environnement d'un programme :</h3>
                    <img src="../images/environnement_programme.PNG" alt="">
                    <ul>
                        <li>
                            <p>Pratique !</p>
                        </li>
                        <li>
                            <p>Préparation d'un environnement de test !</p>
                        </li>
                        <li>
                            <p>Chaîne de compilation en C.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="lab1">Lab 1 : Environnement d'exécution :</h2>
                    <p>Objectif : comprendre comment un programme vit en mémoire.</p>
                    <p>Qu'est-ce qu'un environnement d'exécution ?</p>
                    <p>C'est un ensemble des ressources allouées à un programme (mémoire, registres CPU, pile, tas...).</p>
                    <h3>Vue d'ensemble de la mémoire d'un processus :</h3>
                    <img src="../images/vue_ensemble_memoire_processus.PNG" alt="">
                    <h3>Les registres CPU :</h3>
                    <img src="../images/registres_CPU.PNG" alt="">
                    <h3>Vue d'ensemble de la mémoire d'un processus :</h3>
                    <img src="../images/vue_ensemble_memoire_processus.PNG" alt="">
                    <h3>Le segment de code :</h3>
                    <ul>
                        <li>
                            <p>Contient les instructions compilées du programme.</p>
                        </li>
                        <li>
                            <p>En lecture seule.</p>
                        </li>
                        <li>
                            <p>Exemple : sections ELF (.text, .rodata).</p>
                        </li>
                        <li>
                            <p>Exercice : compiler et vérifier les sections dans un exécutable (<span class="em">readelf</span>, <span class="em">objdump</span>).</p>
                        </li>
                    </ul>
                    <h3>Les segments de données (Data & BSS) :</h3>
                    <ul>
                        <li>
                            <p>Data : variables globales initialisées.</p>
                        </li>
                        <li>
                            <p>BSS : variables non initialisées.</p>
                        </li>
                        <li>
                            <p>Exemple C :</p>
<pre><code>int global_init = 10; // Data
int global_uninit; // BSS</code></pre>
                        </li>
                    </ul>
                    <h3>Le tas (Heap) :</h3>
                    <ul>
                        <li>
                            <p>Zone mémoire dynamique (malloc, calloc, new...).</p>
                        </li>
                        <li>
                            <p>Croît vers le haut.</p>
                        </li>
                        <li>
                            <p>Vulnérabilités : Heap overflow, Use-After-Free, Double Free.</p>
                        </li>
                    </ul>
                    <h3>La pile (Stack) :</h3>
                    <ul>
                        <li>
                            <p>Stocke les variables locales et le contexte d'appel.</p>
                        </li>
                        <li>
                            <p>Croît vers le bas.</p>
                        </li>
                        <li>
                            <p>Structure d'une stack frame :</p>
                            <img src="../images/pile_stack.PNG" alt="">
                            <img src="../images/pile_stack_1.PNG" alt="">
                        </li>
                    </ul>
                    <h3>Les registres CPU :</h3>
                    <ul>
                        <li>
                            <p>EIP/RIP : pointeur d'instruction</p>
                        </li>
                        <li>
                            <p>ESP/RSP : pointeur de pile</p>
                        </li>
                        <li>
                            <p>EBP/RBP : base frame</p>
                        </li>
                        <li>
                            <p>EAX, EBX... : registres de travail</p>
                        </li>
                        <li>
                            <p>Exemple ASM :</p>
                            <div>
                                <img src="../images/registres_CPU_1.PNG" class="float_right" alt="">
<pre><code>push ebp
mov ebp, esp
sub esp, 0x10
mov eax, [ebp+8]
leave
ret</code></pre>
                            </div>
                        </li>
                    </ul>
                    <h3>Stack vs Heap :</h3>
                    <ul>
                        <li>
                            <p>Stack : allocation auto, rapide, taille limitée, vulnérable aux overflows.</p>
                        </li>
                        <li>
                            <p>Heap : allocation dynamique, grande, lente, vulnérable aux use-after-free.</p>
                        </li>
                    </ul>
                    <h3>Mécanismes de protection mémoire :</h3>
                    <ul>
                        <li>
                            <p>ASLR : randomisation des adresses</p>
                        </li>
                        <li>
                            <p>DEP/NX bit : empêche exécution sur pile/tas.</p>
                        </li>
                        <li>
                            <p>Stack canaries : détecte les écrasements de pile.</p>
                        </li>
                    </ul>
                    <h3>Étude pratique :</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int global = 5;
int main() {
    int local = 10;
    int *p = malloc(sizeof(int));
    *p = 20;
    printf("%p %p %p\n", &amp;global, &amp;local, p);
    free(p);
}</code></pre>
                    <h3>Exemple pratique : sections mémoire d'un programme C :</h3>
                    <p>Voici un exemple simple en C illustrant les différentes sections mémoire :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*gcc -o env_mem_demo env_mem_demo.c
./env_mem_demo */

int global_init = 42; // Segment Data
int global_uninit; // Segment BSS

void function_demo() {
    int local_var = 5; // Stack
    int *heap_var = malloc(sizeof(int));
    *heap_var = 99; // Heap

    printf("Adresse Code (function_demo) : %p\n", function_demo);
    printf("Adresse Data (global_init) : %p\n", &amp;global_init);
    printf("Adresse BSS (global_uninit) : %p\n", &amp;global_uninit);
    printf("Adresse Stack (local_var) : %p\n", &amp;local_var);
    printf("Adresse Heap (*heap_var) : %p\n", heap_var);

    free(heap_var);
}

int main() {
    function_demo();
    return 0;
}</code></pre>
                    <h3>Analyse et visualisation mémoire :</h3>
                    <ul>
                        <li>
                            <p>Exemple de sortie de commande :</p>
<pre><code>$ size env_mem_demo
text data bss dec  hex filename
1024 12   8   1044 414 env_mem_demo</code></pre>
                            <p>`.text` : code exécutable (instructions)</p>
                            <p>`.data` : variables globales initialisées</p>
                            <p>`.bss` : variables globales non initialisées</p>
                        </li>
                        <li>
                            <p>Heap : mémoire dynamique via malloc()</p>
                        </li>
                        <li>
                            <p>Stack : variables locales et adresses de retour</p>
                        </li>
                    </ul>
                    <h3>Conclusion :</h3>
                    <ul>
                        <li>
                            <p>L'environnement d'exécution est la base de la sécurité mémoire.</p>
                        </li>
                        <li>
                            <p>Comprendre le CPU, la pile et le tas.</p>
                        </li>
                        <li>
                            <p>Indispensable pour debugging, reverse engineering et exploitation.</p>
                        </li>
                    </ul>
                    <h4>Les différents fichiers du labo 1 sont :</h4>
                    <ol>
                        <li>
                            <p>Le fichier `<span class="em">env_mem_demo.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* gcc -o env_mem_demo env_mem_demo.c
./env_mem_demo */

int global_init = 42; // Segment Data
int global_uninit; // Segment BSS

void function_demo() {	
    int local_var = 5; // Stack
    int *heap_var = malloc(sizeof(int));
    *heap_var = 99; // Heap

    printf("Adresse Code (function_demo) : %p\n", function_demo);
    printf("Adresse Data (global_init) : %p\n", &amp;global_init);
    printf("Adresse BSS (global_uninit) : %p\n", &amp;global_uninit);
    printf("Adresse Stack (local_var) : %p\n", &amp;local_var);
    printf("Adresse Heap (*heap_var) : %p\n", heap_var);

    free(heap_var);
}

int main() {
    function_demo();
    return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">banner.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void print_banner(const char *name) {
    char buffer[16];
    strcpy(buffer, name); // vulnérable
    printf("Hello, %s", buffer);
}

int main(int argc, char *argv[]) {
    int secret = 0x41424344;
    print_banner(argv[1]);
    printf("Secret after call: 0x%X", secret);
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">mem_layout_demo.c</span>` :</p>
<pre><code>/* mem_layout_demo.c
* Petit programme pédagogique pour afficher adresses mémoire
* (text / rodata / data / bss / heap / stack / adresses de fonctions).
*
* Compilez avec : gcc -g -O0 mem_layout_demo.c -o mem_layout_demo
* (l'option -g permet l'inspection avec gdb ; -O0 évite les optimisations qui
*  déplaceraient ou supprimeraient certaines variables locales).
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Segments globaux */
int initialized_global = 0x11223344;   /* segment .data (initialisé) */
int uninitialized_global;              /* segment .bss (non-initialisé) */

const char *const_string = "Hello, readonly data (rodata)";

void callee(int depth);

/* fonction utile pour afficher adresses de fonctions */
void dummy_function(void) { /* vide */ }

int main(void) {
    int local_main = 0xdeadbeef;      /* variable locale (stack) */
    void *heap_ptr = malloc(64);      /* alloue sur le heap */

    printf("=== Disposition mémoire (exemple) ===\n\n");

    /* adresses du segment code / fonctions */
    printf("Adresse de la fonction main()      : %p\n", (void*)main);
    printf("Adresse de la fonction callee()    : %p\n", (void*)callee);
    printf("Adresse de dummy_function()        : %p\n", (void*)dummy_function);

    /* rodata / data / bss */
    printf("\nSegments statiques:\n");
    printf(" Adresse de la chaîne (rodata)     : %p -&gt; \"%s\"\n", (void*)const_string, const_string);
    printf(" Adresse initialized_global (.data) : %p -&gt; 0x%X\n", (void*)&initialized_global, initialized_global);
    printf(" Adresse uninitialized_global (.bss) : %p -&gt; 0x%X\n", (void*)&uninitialized_global, uninitialized_global);

    /* heap et stack */
    printf("\nHeap & Stack:\n");
    printf(" Adresse heap (malloc 64 bytes)     : %p\n", heap_ptr);
    printf(" Adresse variable locale main (stack): %p -&gt; 0x%X\n", (void*)&local_main, local_main);

    /* adresse retour approximative (non portable mais pédagogique) */
    void *ret_addr = __builtin_return_address(0);
    printf("\nAdresse de retour (valeur fournie par __builtin_return_address(0)) : %p\n", ret_addr);

    /* appeler callee qui fera afficher adresses supplémentaires (empilement) */
    callee(1);

    free(heap_ptr);
    return 0;
}

void callee(int depth) {
    int local_callee = 0xfeedface;
    printf("\n-- dans callee(depth=%d) --\n", depth);
    printf(" Adresse local callee (stack)       : %p -&gt; 0x%X\n", (void*)&local_callee, local_callee);
    printf(" Adresse return (callee) via builtin: %p\n", __builtin_return_address(0));

    if (depth &lt; 2) {
        /* récursion contrôlée pour montrer plusieurs frames */
        callee(depth + 1);
    }
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">vuln.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void secret() {
    printf("Bravo !  - vous avez decouvert secret()!\n");
    fflush(stdout);
}

void vuln() {
    char buf[16];
    printf("Tapez quelque chose:\n");
    fgets(buf, 512, stdin); // vulnérabilité intentionelle overflow
    printf("Vous avez introduit : %s\n", buf);
}

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    vuln();
    return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">lab1_buffer_overflow.md</span>` :</p>
<pre><code># Lab 1 — Buffer Overflow (C)
## Objectifs
- Comprendre la pile, ret address overwrite
## Environnement
- Compiler: `<span class="em">gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie</span>`
# -z execstack est une option du linker ELF (Linux) qui demande une pile exécutable.
# Sous Windows (format PE) la notion est différente et lld/ld du toolchain MinGW ne reconnaît pas le-z.
- Outils: <span class="em">gdb</span>, <span class="em">pwntools</span>
## Étapes (résumé)
1. Trouver offset (pattern_create/pattern_offset)
2. Overwrite retour avec adresse de `<span class="em">secret()</span>`
3. Vérifier protections (ASLR) et disabled protections pour la démo</code></pre>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="gcc">GCC :</h2>
                    <p>Pour utiliser GCC avec MinGW, il faut d'abord installer <a href="https://code.visualstudio.com/download" target="_blank">Visual Studio Code</a> et installer <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank">l'extension C/C++ pour VS Code</a>.</p>
                    <p>Ensuite, vous devez télécharger et installer la dernière version du logiciel <a href="https://www.msys2.org/" target="_blank">MSYS2</a>. Notez que MSYS2 requiert la version 64 bits de Windows 8.1 ou plus récent.</p>
                    <p>Une fois l'installation finie, dans le nouveau terminal, installer la toolchain MinGW-w64 en exécutant la commande suivante :</p>
<pre><code>pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain</code></pre>
                    <p>Il faut accepter la sélection par défaut de paquets et procéder à l'installation.</p>
                    <p>Troisièmement, il faut ajouter le répertoire <span class="em">bin</span> de MinGW-w64 dans la variable d'environnement <span class="em">PATH</span> Windows en ajoutant <span class="em">C:\msys64\ucrt64\bin</span>.</p>
                    <p>Enfin, on doit vérifier que les outils MinGW-w64 sont correctement installés et disponibles avec les commandes suivants dans un nouveau terminal :</p>
<pre><code>gcc --version</code></pre>
                    <p>Le GCC (GNU Compiler Collection) est une suite de compilateurs open source créée par le projet GNU.</p>
                    <p>C'est l'un des outils les plus utiisés pour compiler du code source (langage C, C++, Objective-C, Ada, Fortran, Go, etc.) en binaire exécutable (machine code).</p>
<pre><code>g++ --version</code></pre>
                    <p>g++ est la version C++ du compilateur GCC. En réalité, g++ fait partie de GCC, mais il active automatiquement la compilation C++ et le linkage des bibliothèques standard C++ (libstdc++).</p>
<pre><code>gdb --version</code></pre>
                    <p>Le GDB (GNu Debugger) est un débogueur utilisé pour analyser, corriger, et comprendrel'exécution d'un programme C ou C++.</p>
                    <p>Voici les différentes fonctionnalités à l'intérieur de GDB :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Commandes</th>
                                <th>Explications</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="em">break main</td>
                                <td>Met un point d'arrêt à main()</td>
                            </tr>
                            <tr>
                                <td class="em">run</td>
                                <td>Lance le programme</td>
                            </tr>
                            <tr>
                                <td class="em">step</td>
                                <td>Avance une instruction</td>
                            </tr>
                            <tr>
                                <td class="em">print variable</td>
                                <td>Affiche la valeur d'une variable</td>
                            </tr>
                            <tr>
                                <td class="em">continue</td>
                                <td>Continue jusqu'au prochain breakpoint</td>
                            </tr>
                            <tr>
                                <td class="em">quit</td>
                                <td>Quitte</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Pour accéder à l'aide de GCC, il y a plusieurs méthodes possibles :</p>
                    <ul>
                        <li>
<pre><code>man gcc</code></pre>
                            <p>C'est la vraie documentation complète (le "manuel Unix"). Mais elle est trop longue et détaillée, souvent trop verbeuse pour un usage rapide.</p>
                            <p>Il faut avoir les pages de manuel installées (<span class="em">sudo apt install manpages-dev</span> sur Debian/Ubuntu par exemple).</p>
                        </li>
                        <li>
<pre><code>gcc --help</code></pre>
                            <p>Cette commande affiche les options les plus courantes, divisées par sections (linking, warnings, optimization...).</p>
                            <p>C'est beaucoup plus lisible que <span class="em">man gcc</span> pour un usage rapide.</p>
                        </li>
                        <li>
<pre><code>gcc -Q --help=optimizers</code></pre>
                            <p>Cette commande liste toutes les optimisations possibles (activées ou non selon ton niveau <span class="em">-o</span>).</p>
                        </li>
                        <li>
<pre><code>info gcc</code></pre>
                            <p>Cette commande ouvre la documentation GNU "info", structurée et plus navigable que <span class="em">man</span>.</p>
                        </li>
                    </ul>
                    <p>Les principales options de GCC lors d'une compilation basique sont :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Option</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="em">-c</td>
                                <td>Compile uniquement en fichier objet (.o), sans édition de liens</td>
                            </tr>
                            <tr>
                                <td class="em">-o &lt;fichier&gt;</td>
                                <td>Spécifie le nom de sortie</td>
                            </tr>
                            <tr>
                                <td class="em">-g</td>
                                <td>Génère les symboles de débogage (pour gdb, valgrind, etc.)</td>
                            </tr>
                            <tr>
                                <td class="em">-Wall</td>
                                <td>Active un grand nombre d'avertissements</td>
                            </tr>
                            <tr>
                                <td class="em">-Wextra</td>
                                <td>Active encore plus d'avertissements</td>
                            </tr>
                            <tr>
                                <td class="em">-std=c11</td>
                                <td>Force une norme précise du langage C</td>
                            </tr>
                            <tr>
                                <td class="em">-pedantic</td>
                                <td>Vérifie le respect strict de la norme</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Les options d'optimisation <span class="em">-O</span> sont :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Option</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><span class="em">-O0</span> (lettre O + chiffre zéro)</td>
                                <td>
                                    <p>Aucune optimisation.</p>
                                    <p>&#8594; Chaque instruction du code C correspond presque directement à une instruction machine.</p>
                                    <p>&#10003; Idéal pour le débogage.</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="em">-O1</td>
                                <td>Optimisations légères (élimine du code inutile, réduit les sauts inutiles).</td>
                            </tr>
                            <tr>
                                <td class="em">-O2</td>
                                <td>
                                    <p>Optimisations plus poussées mais sûres.</p>
                                    <p>&#8594; Par défaut pour la plupart des compilations standards.</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="em">-O3</td>
                                <td>
                                    <p>Optimisations agressives (déroulage de boucles, inlining forcé, etc.).</p>
                                    <p>&#9888; Peut rendre le débogage plus difficile.</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="em">-Os</td>
                                <td>Optimise pour la taille du binaire plutôt que la vitesse.</td>
                            </tr>
                            <tr>
                                <td class="em">-Ofast</td>
                                <td>
                                    <p>Active <span class="em">-O3</span> + certaines optimisations non standards (peut ignorer des règles IEEE sur les floats).</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h2 id="OWASP_Top10_Lab_Setup">OWASP TOP 10 Lab Setup :</h2>
                    <h3>Objectif :</h3>
                    <p>Mettre en place un <span class="em">laboratoire pratique</span> pour comprendre, exploiter et corriger les vulnérabilités les plus courantes selon <span class="em">l'OWASP Top 10</span>.</p>
                    <h3>Prérequis :</h3>
                    <p>Outils nécessaires :</p>
                    <ul>
                        <li>
                            <p><span class="em">OS</span> : Linux / Mac OS / Windows WSL2</p>
                        </li>
                        <li>
                            <p><span class="em">Docker</span> et <span class="em">Docker Compose</span></p>
                        </li>
                        <li>
                            <p><span class="em">Navigateur</span> : Firefox / Chrome</p>
                        </li>
                        <li>
                            <p><span class="em">Éditeur</span> : VSCode ou PyCharm</p>
                        </li>
                        <li>
                            <p>(Optionnel) <span class="em">Burp Suite Community Edition</span></p>
                        </li>
                    </ul>
                    <h3>Architecture du Lab :</h3>
                    <p>Chaque vulnérabilité est isolée dans un container ou un dossier distinct.</p>
                    <img src="../images/architecture_owasp_lab.PNG" alt="">
                    <h3>Environements vulnérables:</h3>
                    <ol>
                        <li>
                            <h4>DVWA - Damn Vulnerable Web Application :</h4>
                            <ul>
                                <li>
                                    <p><span class="em">Cible</span> : Injection SQL, XSS, File Upload, CSRF, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">URL</span> : http://localhost:8080</p>
                                </li>
                                <li>
                                    <p><span class="em">Docker run</span> :</p>
<pre><code>docker run -d -p 8080:80 --name dvwa vulnerables/web-dvwa</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>OWASP Juice Shop :</h4>
                            <ul>
                                <li>
                                    <p><span class="em">Cible</span> : Broken Auth, Sensitive Data Exposure, Injection, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">URL</span> : http://localhost:3000</p>
                                </li>
                                <li>
                                    <p><span class="em">Docker run</span> :</p>
<pre><code>docker run -d -p 3000:3000 --name juice-shop bkimminich/juice-shop</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>WebGoat + WebWolf :</h4>
                            <ul>
                                <li>
                                    <p><span class="em">Cible</span> : Advanced OWASP lessons (Java, API, Auth, Crypto)</p>
                                </li>
                                <li>
                                    <p><span class="em">URL</span> : http://localhost:8081/WebGoat</p>
                                </li>
                                <li>
                                    <p><span class="em">Docker run</span> :</p>
<pre><code>docker run -d -p 8081:8080 --name webgoat webgoat/webgoat</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Multillidae II :</h4>
                            <ul>
                                <li>
                                    <p><span class="em">Cible</span> : OWASP Top 10 complet + API + vulnérabilités business logic</p>
                                </li>
                                <li>
                                    <p><span class="em">URL</span> : http://localhost:8090</p>
                                </li>
                                <li>
                                    <p><span class="em">Docker run</span> :</p>
<pre><code>docker run -d -p 8090:80 --name multillidae citizenstig/nowasp</code></pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3>Docker Compose simplifié :</h3>
                    <p>Crée un fichier <span class="em">docker-compose.yml</span> :</p>
<pre><code>version: '3'
services:
  dvwa:
    image: vulnerables/web-dvwa
    ports:
        - "8080:80"
  juice-shop:
    image: bkimminich/juice-shop
    ports:
        - "3000:3000"
  webgoat:
    image: webgoat/webgoat
    ports:
        - "8081:8080"
  mutillidae:
    image: citizenstig/nowasp
    ports:
        - "8090:80"</code></pre>
                    <p>Lancer :</p>
<pre><code>docker compose up -d</code></pre>
                    <h3>Schénarios de pratiques OWASP Top 10 :</h3>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>OWASP Top 10</th>
                                <th>Application</th>
                                <th>Exemple d'exercice</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>A01 - Broken Access Control</td>
                                <td>Juice Shop</td>
                                <td>Accès à un profil admin via IDOR</td>
                            </tr>
                            <tr>
                                <td>A02 - Cryptographic Failures</td>
                                <td>WebGoat</td>
                                <td>Mauvais stockage de mot de passe</td>
                            </tr>
                            <tr>
                                <td>A03 - Injection</td>
                                <td>DVWA</td>
                                <td>Injection SQL et Command Injection</td>
                            </tr>
                            <tr>
                                <td>A04 - Insecure Design</td>
                                <td>Mutillidae</td>
                                <td>Mauvaise logique d'authentification</td>
                            </tr>
                            <tr>
                                <td>A05 - Security Misconfiguration</td>
                                <td>DVWA</td>
                                <td>Exposition des pages d'admin</td>
                            </tr>
                            <tr>
                                <td>A06 - Vulnerable & Outdated Components</td>
                                <td>WebGoat</td>
                                <td>Exploitation de dépendances</td>
                            </tr>
                            <tr>
                                <td>A07 - Identification & Auth Failures</td>
                                <td>Juice Shop</td>
                                <td>Session hijacking</td>
                            </tr>
                            <tr>
                                <td>A08 - Software & Data Integrity Failures</td>
                                <td>WebGoat</td>
                                <td>Manipulation de code signé</td>
                            </tr>
                            <tr>
                                <td>A09 - Logging & Monitoring Failures</td>
                                <td>Mutillidae</td>
                                <td>Attaques non détectées</td>
                            </tr>
                            <tr>
                                <td>A10 - SSRF</td>
                                <td>Juice Shop / DVWA</td>
                                <td>Accès à ressource interne</td>
                            </tr>
                        </tbody>
                    </table>
                    <h3>Documentation pour les étudiants :</h3>
                    <p><span class="em">GUIDE.md</span> (avec toutes les sections) :</p>
                </article>
                <article>
                    <h2 id="laboC">Labo C - Compilation, édition de liens, debugging & sécurité mémoire :</h2>
                    <p>Les fichiers du Labo C sont :</p>
                    <ol>
                        <li>
                            <p>Le fichier `<span class="em">README.md</span>` est :</p>
<pre><code># Labo C - Compilation, Édition de liens, Debugging & Sécurité mémoire

Ce laboratoire complet en langage C permet d'apprendre :

- Le processus de compilation (`.c → .o`)
- L'édition de liens (archives statiques `.a`, bibliothèques `.so`)
- L'analyse des binaires (`nm`, `objdump`, `readelf`, `file`)
- Le debugging avancé avec `gdb`
- L'observation des sections mémoire (stack / heap / .text / GOT / PLT)
- Les vulnérabilités mémoire :
  - Stack buffer overflow
  - Heap Use-After-Free
  - Format String
  - Overwrite de fonction (function pointer)
  - Ret2libc / ROP (initiation)
- Les mécanismes de protection :
  - ASLR, PIE
  - NX
  - Stack canaries
  - RELRO

 **IMPORTANT**  
Toutes les manipulations sont à exécuter **uniquement dans une VM isolée**.

---

# 1. Arborescence

src/
main.c
util.c / util.h
mathlib.c / mathlib.h
vuln.c / vuln.h
heap.c
fmtstr.c
Makefile

---

# 2. Compilation

## Tout compiler

Génère :

- `bin/main` : programme principal
- `bin/vuln_nosafe` : version vulnérable (sans protections)
- `lib/libmath.a` : archive statique
- `lib/libmath.so` : bibliothèque partagée

---

# 3. Utilisation

./bin/main vuln "AAAA"
./bin/main callfp
./bin/main heap "HELLO"
./bin/main fmt "%p %p %p"

Version vulnérable pour exploitation :

./bin/vuln_nosafe vuln $(python3 -c "print('A'*200)")

---

# 4. Analyse des binaires

nm -C bin/main
nm -C lib/libmath.a
readelf -h bin/main
objdump -d bin/main | less
objdump -d lib/libmath.so | less

---

# 5. Debugging GDB

gdb --args bin/main vuln AAAAAAAAAA
(gdb) break vuln_input
(gdb) run
(gdb) info frame
(gdb) disassemble
(gdb) x/40x $rsp

---

# 6. Exercices sécurité

### Buffer overflow (stack)
- Calculer l'offset jusqu'au RIP
- Overwrite du retour pour exécuter `secret_admin()`
- Comparer comportements avec / sans PIE et stack-protector

### Overwrite d'un function pointer
- Trouver l'adresse de `global_fp`
- L'écraser via un overflow

### Format String
- Lire la stack via `%p %p %p ...`
- Écrire en mémoire via `%n`

### Heap Use-After-Free
- Observer réutilisation de chunk
- Corrompre données réallouées

### Ret2libc (initiation)
- Trouver l'adresse de `system()` dans libc
- Construire un payload simple

---

# 7. Protections & durcissement

Construire un binaire protégé :

gcc -g -O2 -fstack-protector-strong -D_FORTIFY_SOURCE=2 -Wl,-z,relro,-z,now -fPIE -pie -o main_hardened src/*.c

Désactiver ASLR temporairement (root) :

echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

Ou exécuter sans ASLR :

setarch uname -m -R ./bin/vuln_nosafe

---

# 8. Avertissement

Ce labo ne doit être utilisé **que pour l'apprentissage**.  
Ne jamais appliquer ces techniques hors environnement autorisé.

---

# 9. Mots de l'Auteur

Labo conçu pour la formation *Software Security / Sécurité logicielle*.</code></pre>
                            <p>Un fichier <span class="em">.a</span> est une archive qui contient des objets compilés (<span class="em">.o</span>). Ces objets sont composés directement dans le binaire final au moment du linking.</p>
                            <p>Un fichier <span class="em">.so</span> (shared object) est chargé à l'exécution, pas intégré au binaire.</p>
                            <p>Pour utiliser la commande <span class="em">file</span>, soit on utilise Git Bash pour Windows ou sinon l'installe via MSYS2 avec la commande suivante :</p>
<pre><code>pacman -S file</code></pre>
                            <p>Ou alors utiliser la commande <span class="em">certutil -dump</span> dans Windows pour fournir le type MIME.</p>
                            <p>Windows n'a pas d'équivalent direct de <span class="em">readelf</span> parce qu'il n'utilise pas ELF. Mais tu peux analyser un binaire PE avec <span class="em">dumpbin</span>.</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>readelf</th>
                                        <th>dumpbin</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>readelf -h</td>
                                        <td>dumpbin /headers</td>
                                    </tr>
                                    <tr>
                                        <td>readelf -s</td>
                                        <td>dumpbin /symbols</td>
                                    </tr>
                                    <tr>
                                        <td>readelf -r</td>
                                        <td>dumpbin /imports</td>
                                    </tr>
                                    <tr>
                                        <td>readelf -d</td>
                                        <td>dumpbin /exports</td>
                                    </tr>
                                </tbody>
                            </table>
<pre><code>gcc util.c -o util.o</code></pre>
                            <p>La commande précédente lance une erreur car il manque le paramètre <span class="em">-c</span> afin de compiler. Cela donne ceci :</p>
<pre><code>gcc -c util.c -o util.o</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">Makefile</span>` est :</p>
<pre><code>CC = gcc
CFLAGS = -g -Wall -fno-omit-frame-pointer
SRC = src
OBJDIR = obj

all: bin/main bin/vuln_nosafe lib/libmath.a lib/libmath.so

$(OBJDIR):
	mkdir -p $(OBJDIR)

$(OBJDIR)/util.o: $(SRC)/util.c $(SRC)/util.h | $(OBJDIR)
	$(CC) $(CFLAGS) -c $&lt; -o $@

$(OBJDIR)/mathlib.o: $(SRC)/mathlib.c $(SRC)/mathlib.h | $(OBJDIR)
	$(CC) $(CFLAGS) -fPIC -c $&lt; -o $@

$(OBJDIR)/vuln.o: $(SRC)/vuln.c $(SRC)/vuln.h | $(OBJDIR)
	$(CC) $(CFLAGS) -c $&lt; -o $@

$(OBJDIR)/heap.o: $(SRC)/heap.c | $(OBJDIR)
	$(CC) $(CFLAGS) -c $&lt; -o $@

$(OBJDIR)/fmtstr.o: $(SRC)/fmtstr.c | $(OBJDIR)
	$(CC) $(CFLAGS) -c $&lt; -o $@

lib/libmath.a: $(OBJDIR)/mathlib.o
	mkdir -p lib
	ar rcs $@ $^

lib/libmath.so: $(SRC)/mathlib.c
	mkdir -p lib
	$(CC) -shared -fPIC -o $@ $&lt;

bin/main: $(OBJDIR)/util.o $(OBJDIR)/vuln.o $(OBJDIR)/heap.o $(OBJDIR)/fmtstr.o $(SRC)/main.c lib/libmath.a
	mkdir -p bin
	$(CC) $(CFLAGS) -no-pie -o $@ $(OBJDIR)/util.o $(OBJDIR)/vuln.o $(OBJDIR)/heap.o $(OBJDIR)/fmtstr.o $(SRC)/main.c -Llib -lmath -Wl,-rpath,'$$ORIGIN/../lib'

bin/vuln_nosafe: $(SRC)/vuln.c $(SRC)/util.c $(SRC)/main.c
	mkdir -p bin
	$(CC) -g -fno-stack-protector -z execstack -no-pie -o $@ $(SRC)/main.c $(SRC)/vuln.c $(SRC)/util.c -Llib -lmath -Wl,-rpath,'$$ORIGIN/../lib'

clean:
	rm -rf obj bin lib</code></pre>
                            <p>Voici quelques explications :</p>
<pre><code>CC = gcc <span class="em">&#8594; compilateur utilisé</span>
CFLAGS = -g -Wall -fno-omit-frame-pointer
<span class="em"># -g &#8594; inclut les symboles de debug</span>
<span class="em"># -Wall &#8594; active tous les warnings</span>
<span class="em"># -fno-omit-frame-pointer &#8594; nécessaire pour l'analyse en debug/gdb/exploit</span>
SRC = src <span class="em">&#8594; dossier où sont les sources</span>
OBJDIR = obj <span class="em">&#8594; dossier où seront placés les .o</span></code></pre>
                            <p><span class="em">make</span> pour construire le programme principal <span class="em">bin/main</span>, une version vulnérable <span class="em">bin/vuln_no-safe</span>, la lib statique, la lib dynamique.</p>
                            <p>Pour installer <span class="em">make</span> sur Windows, on peut utiliser la commande :</p>
<pre><code>pacman -S make</code></pre>
<pre><code>$(OBJDIR):
    mkdir -p $(OBJDIR)</code></pre>
                            <p>Make crée automatiquement le dossier obj avant de compiler.</p>
                            <p>Chaque règle compile un fichier <span class="em">.c</span> du dossier <span class="em">src/</span> en <span class="em">.o</span> dans <span class="em">obj/</span>.</p>
                            <p>L'option <span class="em">-fPIC</span> est nécessaire pour créer une bibliothèque partagée (<span class="em">.so</span>).</p>
<pre><code>lib/libmath.a: $(OBJDIR)/mathlib.o
    mkdir -p lib
    ar rcs $@ $&lt;</code></pre>
                            <p>Ce code crée une biblio statique (<span class="em">.a</span>), <span class="em">lib/libmath.a</span>, qui contient <span class="em">mathlib.o</span> et qui utilise <span class="em">ar</span> pour créer l'archive.</p>
                            <p><span class="em">$@</span> représente le fichier à construire, c'est-à-dire la cible de la règle. Ici, <span class="em">$@ = lib/libmath.a</span>.</p>
                            <p><span class="em">$&lt;</span> représente la première dépendance après le deux-points, c'est-à-dire le premier fichier listé dans les dépendances. Ici, <span class="em">$&lt; = obj/mathlib.o</span>.</p>
                            <p><span class="em">$^</span> représente toutes les dépendances (sans duplicata).</p>
                            <p><span class="em">$+</span> représente toutes les dépendances (avec duplicata).</p>
                            <p><span class="em">$?</span> représente les dépendances plus récentes que la cible.</p>
<pre><code>lib/libmath.so: $(SRC)/mathlib.c
    mkdir -p lib
    $(CC) -shared -fPIC -o $@ $&lt;</code></pre>
                            <p>Ce code crée compile directement mathlib.c (pas libmath.o, mais possible) et produit une bibliothèque partagée <span class="em">libmath.so</span>.</p>
<pre><code>clean:
    rm -rf obj bin lib</code></pre>
                            <p>Ce code supprime tout ce qui a été généré.</p>
                            <p>On peut installer ollydbg avec la commande suivante :</p>
<pre><code>sudo apt install ollydbg</code></pre>
                            <p>Pour mettre à jor MSYS2 avant d'installer des paquets :</p>
<pre><code>pacman -Syu</code></pre>
                            <p>Fermer le terminal et dans le nouveau terminal :</p>
<pre><code>pacman -u</code></pre>
                            <p>Pour installer GCC dans MSYS2 :</p>
<pre><code>pacman -S mingw-w64-x86_64-gcc</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">util.h</span>` est :</p>
<pre><code>#ifndef UTIL_H
#define UTIL_H

void print_banner(void);

#endif</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">util.c</span>` est :</p>
<pre><code>#include "util.h"
#include &lt;stdio.h&gt;

void print_banner(void) {
    puts("=== Labo C : compilation & sécurité ===");
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">mathlib.h</span>` est :</p>
<pre><code>#ifndef MATHLIB_H
#define MATHLIB_H

int add(int a, int b);
int secret(void);

#endif</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">mathlib.c</span>` est :</p>
<pre><code>#include "mathlib.h"
#include &lt;stdio.h&gt;

int add(int a, int b) {
    return a + b;
}

int secret(void) {
    puts("You reached secret()");
    return 42;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">vuln.h</span>` est :</p>
<pre><code>#ifndef VULN_H
#define VULN_H

void vuln_input(char *s);
void call_funcptr(void);

#endif</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">vuln.c</span>` est :</p>
<pre><code>#include "vuln.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void secret_admin() {
    puts("Secret admin function: privileged action!");
}

void (*global_fp)() = NULL;

void vuln_input(char *s) {
    char buf[64];
    strcpy(buf, s);  // vulnérabilité volontaire
    printf("You entered: %s\n", buf);
}

void call_funcptr(void) {
    if (global_fp) {
        puts("Calling function pointer global_fp()");
        global_fp();
    } else {
        puts("global_fp is NULL");
    }
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">fmtstr.c</span>` est :</p>
<pre><code>#include &lt;stdio.h&gt;

void fmt_demo(char *user) {
    char buf[128];
    snprintf(buf, sizeof(buf), user);  // vuln format string volontaire
    printf("formatted: %s\n", buf);
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">heap.c</span>` est :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void heap_demo(const char *input) {
    char *p = malloc(64);
    if (!p) return;
    strcpy(p, "initial");
    printf("Before free: %s\n", p);
    free(p);

    // Use-after-free volontaire
    printf("After free (UAF): %s\n", p);

    if (input) {
        char *q = malloc(64);
        if (!q) return;
        strcpy(q, input);
        printf("New chunk content: %s\n", q);
        free(q);
    }
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">main.c</span>` est :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "util.h"
#include "mathlib.h"
#include "vuln.h"

void heap_demo(const char *input);
void fmt_demo(char *user);

int main(int argc, char **argv) {
    print_banner();
    printf("add(2,3) = %d\n", add(2,3));
    printf("secret() addr maybe: %p\n", (void*)secret);

    if (argc &gt;= 2) {
        if (!strcmp(argv[1], "vuln") &amp;&amp; argc &gt;= 3) {
            vuln_input(argv[2]);
        }
        else if (!strcmp(argv[1], "callfp")) {
            call_funcptr();
        }
        else if (!strcmp(argv[1], "heap") &amp;&amp; argc &gt;= 3) {
            heap_demo(argv[2]);
        }
        else if (!strcmp(argv[1], "fmt") &amp;&amp; argc &gt;= 3) {
            fmt_demo(argv[2]);
        }
        else {
            printf("Usage: %s [vuln &lt;str&gt; | callfp | heap &lt;str&gt; | fmt &lt;fmt&gt;]\n", argv[0]);
        }
    } else {
        printf("No action specified. Try: vuln, callfp, heap, fmt\n");
    }
    return 0;
}</code></pre>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>