<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Software Security - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>

        <div id="menu">
            <nav role="navigation" aria-label="Menu secondaire">
                <ol>
                    <li><a href="../supplements.html">Retour au sommaire</a></li>
                    <li><a href="#comprendre_menaces_modeles_attaques">Comprendre les menaces et les modèles d'attaques</a></li>
                    <li><a href="#typologie_menaces">Typologie des menaces</a></li>
                    <li><a href="#definitions_cles">Définitions clés</a></li>
                    <li><a href="#failles_vulnerabilites_logiciels">Failles et vulnérabilités des logiciels</a></li>
                    <li><a href="#faille_securite">Faille de sécurité</a></li>
                    <li><a href="#reduire_vulnerabilites_logicielles">Réduire les vulnérabilités logicielles</a></li>
                    <li><a href="#programmation_defensive">Programmation défensive</a></li>
                    <li><a href="#lab1">Lab 1 : Environnement d'exécution</a></li>
                </ol>
            </nav>
            
            <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
            <aside id="aside" role="complementary">
                <p>Liens utiles :</p>
                <ul>
                    <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                </ul>
            </aside>
        </div>
        
        <main id="container" role="main" tabindex="-1">
            <section id="mainSection">
                <article>
                    <h1>Software Security :</h1>
                </article>
                <article>
                    <h2 id="comprendre_menaces_modeles_attaques">Comprendre les menaces et les modèles d'attaques :</h2>
                    <p><q lang="en">You can't defend what you don't understand</q></p>
                    <p>Exemple : Threat Modeling, STRIDE, DREAD, MITRE ATT&CK</p>
                    <h3>Pourquoi comprendre les menaces ?</h3>
                    <ol>
                        <li>
                            <h4>Anticiper au lieu de subir :</h4>
                            <p>Comprendre les menaces, c'est <span class="em">penser comme un attaquant</span> pour anticiper les vecteurs d'exploitation possibles. Cela permet de :</p>
                            <ul>
                                <li>
                                    <p>Identifier les <span class="em">actifs critiques</span> avant qu'ils ne soient ciblés.</p>
                                </li>
                                <li>
                                    <p>Réduire les <span class="em">surfaces d'attaque</span> avant même la mise en production.</p>
                                </li>
                                <li>
                                    <p>Prioriser les contrôles de sécurité selon les <span class="em">risques réels</span>.</p>
                                </li>
                            </ul>
                            <p>Exemple : Une application Web sans analyse de menace risque d'ignorer que des formulaires d'authentification peuvent subir du brute force ou du credential stuffing.</p>
                        </li>
                        <li>
                            <h4>Intégrer la sécurité dès la conception (Shift Left) :</h4>
                            <p>Comprendre les menaces permet de <span class="em">concevoir un logiciel résilient</span> dès les premières phases du SDLC.</p>
                            <ul>
                                <li>
                                    <p>Les <span class="em">architectes</span> peuvent modéliser les menaces via <span class="em">DFD + STRIDE</span>.</p>
                                </li>
                                <li>
                                    <p>Les <span class="em">développeurs</span> peuvent intégrer des contre-mesures directement dans le code.</p>
                                </li>
                                <li>
                                    <p>Les <span class="em">testeurs</span> peuvent dériver des scénarios de test à partir des menaces connues.</p>
                                </li>
                                <li>
                                    <p>Outils utilisés :</p>
                                    <p>OWASP Threat Dragon, Microsoft Threat Modeling Tool, IriusRisk</p>
                                    <p>MITRE ATT&CK (pour mapping des TTP)</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h4>Améliorer la priorisation et la gestion des risques :</h4>
                            <p>Comprendre les menaces aide à <span class="em">hiérarchiser les efforts de sécurité</span>.</p>
                            <p>Toutes les vulnérabilités ne se valent pas : une faille de configuration mineure n'a pas le même impact qu'une injection RCE.</p>
                            <p>Exemple pratique :</p>
                            <table class="tableBalises">
                                <thead>
                                    <tr>
                                        <th>Vulnérabilité</th>
                                        <th>Impact</th>
                                        <th>Probabilité</th>
                                        <th>Risque global</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>XSS sur page interne</td>
                                        <td>Moyen</td>
                                        <td>Faible</td>
                                        <td>Moyen</td>
                                    </tr>
                                    <tr>
                                        <td>Insecure Deserialization</td>
                                        <td class="em">Élevé</td>
                                        <td>Moyen</td>
                                        <td class="em">Élevé</td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <h4>Favoriser la communication inter-équipes :</h4>
                            <p>Les modèles de menaces servent de langage commun entre Développeurs, Architectes, DevOps/SecOps et Auditeurs et RSSI</p>
                            <p>Cela favorise la culture sécurité et réduit les malentendus : tout le monde parle en termes de menace, impact, scénario d'attaque, contre-mesure.</p>
                        </li>
                        <li>
                            <h4>Se conformer aux normes et référentiels :</h4>
                            <p>Les frameworks exigent une compréhension claire des menaces :</p>
                            <ul>
                                <li>
                                    <p>ISO 27034 (Application Security).</p>
                                </li>
                                <li>
                                    <p>NIST SSDF (Secure Software Development Framework).</p>
                                </li>
                                <li>
                                    <p>OWASP SAMM (Threat Assessment).</p>
                                </li>
                                <li>
                                    <p>NIS2 / ENISA Guidelines (Supply chain threat modeling).</p>
                                </li>
                            </ul>
                            <p>Sans modélisation de menace, il est impossible de démontrer la conformité à ces cadres.</p>
                        </li>
                        <li>
                            <h4>Réduire les coûts de correction :</h4>
                            <p>Une menace identifiée <span class="em">tôt</span> coûte 30 à 100 fois moins cher à corriger qu'en production.</p>
                            <p>Exemple :</p>
                            <p>Correction d'un XSS détecté à la conception &#8594; 100€</p>
                            <p>Correction après compromission &#8594; 10000€ +</p>
                            <img src="../images/cout_correction_defaut_phase_developpement.PNG" alt="">
                            <p>SRC : IBM System Science Institute : Relative Cost of Fixing Defects</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="typologie_menaces">Typologie des menaces :</h2>
                    <ul>
                        <li>
                            <p>Attaques <span class="em">logicielles</span> : injection, corruption mémoire, logique métier</p>
                        </li>
                        <li>
                            <p>Attaques <span class="em">infrastructurelles</span> : réseau, système, container</p>
                        </li>
                        <li>
                            <p>Attaques <span class="em">supply chain / open source</span> : Exemples réels : SolarWinds, Log4Shell, XZ backdoor</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="definitions_cles">Définitions clés :</h2>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Élément</th>
                                <th>Définition</th>
                                <th>Exemple concret</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="em">Actif</td>
                                <td>Ce qu'on cherche à protéger (donnée, service, identité, code)</td>
                                <td>Base de données clients</td>
                            </tr>
                            <tr>
                                <td class="em">Menace</td>
                                <td>Intention ou événement malveillant exploitant une faille</td>
                                <td>Attaquant injectant du code SQL</td>
                            </tr>
                            <tr>
                                <td class="em">Vulnérabilité</td>
                                <td>Faiblesse technique ou logique exploitable</td>
                                <td>Entrée utilisateur non filtrée</td>
                            </tr>
                            <tr>
                                <td class="em">Impact</td>
                                <td>Conséquence si la menace se réalise</td>
                                <td>Vol de données, compromission</td>
                            </tr>
                            <tr>
                                <td class="em">Risque</td>
                                <td>Combinaison probabilité x impact</td>
                                <td>Risque élevé de fuite de données</td>
                            </tr>
                        </tbody>
                    </table>
                    <img src="../images/chaine_logique_menace_risque.PNG" alt="">
                    <h3>Common Weakness Enumeration - Top 25 -2024 :</h3>
                    <div>
                        <img src="../images/CWE_MITRE_TOP_25_2024.PNG" alt="" class="float_left">
                        <p>Table 1</p>
                        <p>CWE/MITRE TOP 25 Most Dangerous Software Weaknesses (2024)</p>
                    </div>
                </article>
                <article>
                    <h2 id="failles_vulnerabilites_logiciels">Failles et vulnérabilités des logiciels :</h2>
                    <p>Les failles critiques de sécurité des applications web comprennent 5 failles liées à un code non sécurisé :</p>
                    <ul>
                        <li>
                            <p>Entrées non validées (en C)</p>
                        </li>
                        <li>
                            <p>Cross-site scripting</p>
                        </li>
                        <li>
                            <p>Buffer overflow (en C)</p>
                        </li>
                        <li>
                            <p>Failles d'injection</p>
                        </li>
                        <li>
                            <p>Gestion incorrecte des erreurs</p>
                        </li>
                    </ul>
                    <p>Ces failles sont le résultat d'une vérification et d'une validation insuffisante des données et des codes d'erreur dans les programmes.</p>
                    <p>La prise de conscience de ces problèmes est une première étape essentielle pour écrire un code plus sécurisé.</p>
                    <p>Il est important de souligner la nécessité pour les développeurs de se pencher sur ces failles préoccuppantes et connues.</p>
                    <figure>
                        <img src="../images/failles_vulnerabilites_logiciels.PNG" alt="">
                        <figcaption>Source : <a href="https://gbhackers.com" target="_blank">https://gbhackers.com</a></figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="faille_securite">Faille de sécurité :</h2>
                    <p>Chaque faille représente un écart entre l'intention du développeur et le comportement réel du logiciel face à un attaquant.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_type.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                    <p>Chaque faille représente un écart entre l'intention du développeur et le comportement réel du logiciel face à un attaquant. Selon le site <a href="https://www.cvedetails.com" target="_blank">www.cvedetails.com</a> en 2024, le total des failles recensées était de 40303.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_type_year.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                    <p>En 2024, le total des failles recensées était de 40303, dont 7443 XSS et 2645 SQLi. Début octobre 2025, on recense 36705 failles et, à la fin de l'année 2025, on projette un nombre de failles proches de 50000.</p>
                    <figure>
                        <img src="../images/vulnerabilities_by_types_categories.PNG" alt="">
                        <figcaption>Source : <a href="https://www.cvedetails.com/vulnerabilities-by-types.php" target="_blank">https://www.cvedetails.com/vulnerabilities-by-types.php</a></figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="reduire_vulnerabilites_logicielles">Réduire les vulnérabilités logicielles :</h2>
                    <p>Le framework NIST SSDF présente une série d'approches visant à réduire le nombre de vulnérabilités logicielles (voir NIST-SP 800-218).</p>
                    <p>Il recommande :</p>
                    <ul>
                        <li>
                            <p>D'empêcher les vulnérabilités avant qu'elles ne surviennent en utilisant des méthodes améliorées pour spécifier et développer les logiciels.</p>
                        </li>
                        <li>
                            <p>De détecter les vulnérabilités avant qu'elles ne puissent être exploitées en utilisant des techniques de test plus efficaces.</p>
                        </li>
                        <li>
                            <p>De réduire l'impact des vulnérabilités en développant des architectures logicielles plus résilientes.</p>
                        </li>
                    </ul>
                    <h3>NIST-SP 800-218 :</h3>
                    <img src="../images/NIST-SP_800-218.PNG" alt="">
                    <p><a href="../files/nist.sp.800-218.ssdf-table.xlsx">Tableau NIST-SP 800-218 (en Excel)</a></p>
                    <h3>Qualité et fiabilité des logiciels :</h3>
                    <ul>
                        <li>
                            <p>Éviter toute défaillance accidentelle résultant d'une entrée théoriquement aléatoire et imprévue, ou d'une imprévue, ou d'une intéraction non contrôlée avec le système, ou utiliser un code incorrect (logique incorrecte).</p>
                        </li>
                        <li>
                            <p>Améliorer à l'aide d'un design structuré et de tests afin d'identifier et éliminer autant de bugs que possible dans un programme.</p>
                        </li>
                        <li>
                            <p>La préoccupation ne porte pas sur le nombre de bugs, mais sur la fréquence à laquelle ils se déclenchent.</p>
                        </li>
                    </ul>
                    <h3>Failles et vulnérabilités :</h3>
                    <ul>
                        <li>
                            <p>L'attaquant cible spécifiquement les bugs qui provoquent une défaillance pouvant être exploitée (par l'attaquant).</p>
                        </li>
                        <li>
                            <p>Déclenchées par des entrées qui diffèrent considérablement de ce qui est habituellement attendues.</p>
                        </li>
                        <li>
                            <p>Peu susceptible d'être identifié par les méthodes d'analyse courantes.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="programmation_defensive">Programmation défensive :</h2>
                    <ul>
                        <li>
                            <p>Concevoir et mettre en oeuvre des logiciels de manière à ce qu'ils continuent de fonctionner même lorsqu'ils sont attaqués.</p>
                        </li>
                        <li>
                            <p>Exige de prêter attention à tous les aspects de l'exécution du programme, à l'environnement et au type de données qu'il traite.</p>
                        </li>
                        <li>
                            <p>Le logiciel est capable de détecter les conditions erronées résultant d'une attaque.</p>
                        </li>
                        <li>
                            <p>Également appelé "programmation sécurisée".</p>
                        </li>
                        <li>
                            <p>La règle d'or est de ne jamais présumer de quoi que ce soit, de vérifier toutes les hypothèses et de gérer tous les états d'erreur possibles.</p>
                        </li>
                        <li>
                            <p>Les programmeurs émettent souvent des hypothèses sur le type d'entrées qu'un programme recevra et l'environnement dans lequel il s'exécutera.</p>
                            <p>Ces hypothèses doivent être validées par le programme et toutes les défaillances potentielles doivent être gérées avec sécurité.</p>
                        </li>
                        <li>
                            <p>Nécissite un changement de mentalité par rapport aux pratiques de programmation traditionnelles.</p>
                            <p>Les programmeurs doivent comprendre comment les défaillances peuvent se produire et les mesures à prendre pour réduire le risque qu'elles se produisent dans leurs programmes.</p>
                        </li>
                        <li>
                            <p>Danger !!! Les conflits avec les pressions commerciales visant à réduire au maximum les délais de développement afin de maximiser l'avantage concurrentiel.</p>
                        </li>
                    </ul>
                    <h3>Environnement d'un programme :</h3>
                    <img src="../images/environnement_programme.PNG" alt="">
                    <ul>
                        <li>
                            <p>Pratique !</p>
                        </li>
                        <li>
                            <p>Préparation d'un environnement de test !</p>
                        </li>
                        <li>
                            <p>Chaîne de compilation en C.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="lab1">Lab 1 : Environnement d'exécution :</h2>
                    <p>Objectif : comprendre comment un programme vit en mémoire.</p>
                    <p>Qu'est-ce qu'un environnement d'exécution ?</p>
                    <p>C'est un ensemble des ressources allouées à un programme (mémoire, registres CPU, pile, tas...).</p>
                    <h3>Vue d'ensemble de la mémoire d'un processus :</h3>
                    <img src="../images/vue_ensemble_memoire_processus.PNG" alt="">
                    <h3>Les registres CPU :</h3>
                    <img src="../images/registres_CPU.PNG" alt="">
                    <h3>Vue d'ensemble de la mémoire d'un processus :</h3>
                    <img src="../images/vue_ensemble_memoire_processus.PNG" alt="">
                    <h3>Le segment de code :</h3>
                    <ul>
                        <li>
                            <p>Contient les instructions compilées du programme.</p>
                        </li>
                        <li>
                            <p>En lecture seule.</p>
                        </li>
                        <li>
                            <p>Exemple : sections ELF (.text, .rodata).</p>
                        </li>
                        <li>
                            <p>Exercice : compiler et vérifier les sections dans un exécutable (<span class="em">readelf</span>, <span class="em">objdump</span>).</p>
                        </li>
                    </ul>
                    <h3>Les segments de données (Data & BSS) :</h3>
                    <ul>
                        <li>
                            <p>Data : variables globales initialisées.</p>
                        </li>
                        <li>
                            <p>BSS : variables non initialisées.</p>
                        </li>
                        <li>
                            <p>Exemple C :</p>
<pre><code>int global_init = 10; // Data
int global_uninit; // BSS</code></pre>
                        </li>
                    </ul>
                    <h3>Le tas (Heap) :</h3>
                    <ul>
                        <li>
                            <p>Zone mémoire dynamique (malloc, calloc, new...).</p>
                        </li>
                        <li>
                            <p>Croît vers le haut.</p>
                        </li>
                        <li>
                            <p>Vulnérabilités : Heap overflow, Use-After-Free, Double Free.</p>
                        </li>
                    </ul>
                    <h3>La pile (Stack) :</h3>
                    <ul>
                        <li>
                            <p>Stocke les variables locales et le contexte d'appel.</p>
                        </li>
                        <li>
                            <p>Croît vers le bas.</p>
                        </li>
                        <li>
                            <p>Structure d'une stack frame :</p>
                            <img src="../images/pile_stack.PNG" alt="">
                            <img src="../images/pile_stack_1.PNG" alt="">
                        </li>
                    </ul>
                    <h3>Les registres CPU :</h3>
                    <ul>
                        <li>
                            <p>EIP/RIP : pointeur d'instruction</p>
                        </li>
                        <li>
                            <p>ESP/RSP : pointeur de pile</p>
                        </li>
                        <li>
                            <p>EBP/RBP : base frame</p>
                        </li>
                        <li>
                            <p>EAX, EBX... : registres de travail</p>
                        </li>
                        <li>
                            <p>Exemple ASM :</p>
                            <div>
                                <img src="../images/registres_CPU_1.PNG" class="float_right" alt="">
<pre><code>push ebp
mov ebp, esp
sub esp, 0x10
mov eax, [ebp+8]
leave
ret</code></pre>
                            </div>
                        </li>
                    </ul>
                    <h3>Stack vs Heap :</h3>
                    <ul>
                        <li>
                            <p>Stack : allocation auto, rapide, taille limitée, vulnérable aux overflows.</p>
                        </li>
                        <li>
                            <p>Heap : allocation dynamique, grande, lente, vulnérable aux use-after-free.</p>
                        </li>
                    </ul>
                    <h3>Mécanismes de protection mémoire :</h3>
                    <ul>
                        <li>
                            <p>ASLR : randomisation des adresses</p>
                        </li>
                        <li>
                            <p>DEP/NX bit : empêche exécution sur pile/tas.</p>
                        </li>
                        <li>
                            <p>Stack canaries : détecte les écrasements de pile.</p>
                        </li>
                    </ul>
                    <h3>Étude pratique :</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int global = 5;
int main() {
    int local = 10;
    int *p = malloc(sizeof(int));
    *p = 20;
    printf("%p %p %p\n", &amp;global, &amp;local, p);
    free(p);
}</code></pre>
                    <h3>Exemple pratique : sections mémoire d'un programme C :</h3>
                    <p>Voici un exemple simple en C illustrant les différentes sections mémoire :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*gcc -o env_mem_demo env_mem_demo.c
./env_mem_demo */

int global_init = 42; // Segment Data
int global_uninit; // Segment BSS

void function_demo() {
    int local_var = 5; // Stack
    int *heap_var = malloc(sizeof(int));
    *heap_var = 99; // Heap

    printf("Adresse Code (function_demo) : %p\n", function_demo);
    printf("Adresse Data (global_init) : %p\n", &amp;global_init);
    printf("Adresse BSS (global_uninit) : %p\n", &amp;global_uninit);
    printf("Adresse Stack (local_var) : %p\n", &amp;local_var);
    printf("Adresse Heap (*heap_var) : %p\n", heap_var);

    free(heap_var);
}

int main() {
    function_demo();
    return 0;
}</code></pre>
                    <h3>Analyse et visualisation mémoire :</h3>
                    <ul>
                        <li>
                            <p>Exemple de sortie de commande :</p>
<pre><code>$ size env_mem_demo
text data bss dec  hex filename
1024 12   8   1044 414 env_mem_demo</code></pre>
                            <p>`.text` : code exécutable (instructions)</p>
                            <p>`.data` : variables globales initialisées</p>
                            <p>`.bss` : variables globales non initialisées</p>
                        </li>
                        <li>
                            <p>Heap : mémoire dynamique via malloc()</p>
                        </li>
                        <li>
                            <p>Stack : variables locales et adresses de retour</p>
                        </li>
                    </ul>
                    <h3>Conclusion :</h3>
                    <ul>
                        <li>
                            <p>L'environnement d'exécution est la base de la sécurité mémoire.</p>
                        </li>
                        <li>
                            <p>Comprendre le CPU, la pile et le tas.</p>
                        </li>
                        <li>
                            <p>Indispensable pour debugging, reverse engineering et exploitation.</p>
                        </li>
                    </ul>
                    <h4>Les différents fichiers du labo 1 sont :</h4>
                    <ol>
                        <li>
                            <p>Le fichier `<span class="em">en_mem_demo.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* gcc -o env_mem_demo env_mem_demo.c
./env_mem_demo */

int global_init = 42; // Segment Data
int global_uninit; // Segment BSS

void function_demo() {	
	int local_var = 5; // Stack
	int *heap_var = malloc(sizeof(int));
	*heap_var = 99; // Heap

	printf("Adresse Code (function_demo) : %p\n", function_demo);
	printf("Adresse Data (global_init) : %p\n", &amp;global_init);
	printf("Adresse BSS (global_uninit) : %p\n", &amp;global_uninit);
	printf("Adresse Stack (local_var) : %p\n", &amp;local_var);
	printf("Adresse Heap (*heap_var) : %p\n", heap_var);

	free(heap_var);
}

int main() {
	function_demo();
	return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">banner.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void print_banner(const char *name) {
	char buffer[16];
	strcpy(buffer, name); // vulnérable
	printf("Hello, %s", buffer);
}

int main(int argc, char *argv[]) {
	int secret = 0x41424344;
	print_banner(argv[1]);
	printf("Secret after call: 0x%X", secret);
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">mem_layout_demo.c</span>` :</p>
<pre><code>/* mem_layout_demo.c
 * Petit programme pédagogique pour afficher adresses mémoire
 * (text / rodata / data / bss / heap / stack / adresses de fonctions).
 *
 * Compilez avec : gcc -g -O0 mem_layout_demo.c -o mem_layout_demo
 * (l'option -g permet l'inspection avec gdb ; -O0 évite les optimisations qui
 *  déplaceraient ou supprimeraient certaines variables locales).
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Segments globaux */
int initialized_global = 0x11223344;   /* segment .data (initialisé) */
int uninitialized_global;              /* segment .bss (non-initialisé) */

const char *const_string = "Hello, readonly data (rodata)";

void callee(int depth);

/* fonction utile pour afficher adresses de fonctions */
void dummy_function(void) { /* vide */ }

int main(void) {
    int local_main = 0xdeadbeef;      /* variable locale (stack) */
    void *heap_ptr = malloc(64);      /* alloue sur le heap */

    printf("=== Disposition mémoire (exemple) ===\n\n");

    /* adresses du segment code / fonctions */
    printf("Adresse de la fonction main()      : %p\n", (void*)main);
    printf("Adresse de la fonction callee()    : %p\n", (void*)callee);
    printf("Adresse de dummy_function()        : %p\n", (void*)dummy_function);

    /* rodata / data / bss */
    printf("\nSegments statiques:\n");
    printf(" Adresse de la chaîne (rodata)     : %p -&gt; \"%s\"\n", (void*)const_string, const_string);
    printf(" Adresse initialized_global (.data) : %p -&gt; 0x%X\n", (void*)&initialized_global, initialized_global);
    printf(" Adresse uninitialized_global (.bss) : %p -&gt; 0x%X\n", (void*)&uninitialized_global, uninitialized_global);

    /* heap et stack */
    printf("\nHeap & Stack:\n");
    printf(" Adresse heap (malloc 64 bytes)     : %p\n", heap_ptr);
    printf(" Adresse variable locale main (stack): %p -&gt; 0x%X\n", (void*)&local_main, local_main);

    /* adresse retour approximative (non portable mais pédagogique) */
    void *ret_addr = __builtin_return_address(0);
    printf("\nAdresse de retour (valeur fournie par __builtin_return_address(0)) : %p\n", ret_addr);

    /* appeler callee qui fera afficher adresses supplémentaires (empilement) */
    callee(1);

    free(heap_ptr);
    return 0;
}

void callee(int depth) {
    int local_callee = 0xfeedface;
    printf("\n-- dans callee(depth=%d) --\n", depth);
    printf(" Adresse local callee (stack)       : %p -&gt; 0x%X\n", (void*)&local_callee, local_callee);
    printf(" Adresse return (callee) via builtin: %p\n", __builtin_return_address(0));

    if (depth &lt; 2) {
        /* récursion contrôlée pour montrer plusieurs frames */
        callee(depth + 1);
    }
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">vuln.c</span>` :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void secret() {
    printf("Bravo !  - vous avez decouvert secret()!\n");
    fflush(stdout);
}

void vuln() {
    char buf[16];
    printf("Tapez quelque chose:\n");
    fgets(buf, 512, stdin); // vulnérabilité intentionelle overflow
    printf("Vous avez introduit : %s\n", buf);
}

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    vuln();
    return 0;
}</code></pre>
                        </li>
                        <li>
                            <p>Le fichier `<span class="em">lab1_buffer_overflow.md</span>` :</p>
<pre><code># Lab 1 — Buffer Overflow (C)
## Objectifs
- Comprendre la pile, ret address overwrite
## Environnement
- Compiler: `<span class="em">gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie</span>`
- Outils: <span class="em">gdb</span>, <span class="em">pwntools</span>
## Étapes (résumé)
1. Trouver offset (pattern_create/pattern_offset)
2. Overwrite retour avec adresse de `<span class="em">secret()</span>`
3. Vérifier protections (ASLR) et disabled protections pour la démo</code></pre>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>