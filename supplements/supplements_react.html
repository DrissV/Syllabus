<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>React - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#transmation_HTML_React">Transformation d'un simple fichier HTML en app React</a></li>
                        <li><a href="#premier_composant">Création du premier composant</a></li>
                        <li><a href="#initialisation_JSX">Initialisation au JSX</a></li>
                        <li><a href="#Create_React_App">Create React App</a></li>
                        <li><a href="#organisation_code">Organisation du code</a></li>
                        <li><a href="#stylisation_app">Stylisation de l'application</a></li>
                        <li><a href="#decouverte_attribut_style">Découverte de l'attribut style</a></li>
                        <li><a href="#utilisation_images">Utilisation des images</a></li>
                        <li><a href="#iteration_contenu">Itération sur le contenu</a></li>
                        <li><a href="#contextualisation_contenu_composants">Contextualisation du contenu des composants</a></li>
                        <li><a href="#familiarisation_props">Familirisation avec les props</a></li>
                        <li><a href="#maitrise_evenements_React">Maîtrise des événements en React</a></li>
                        <li><a href="#creation_formulaires_React">Création de formulaires avec React</a></li>
                        <li><a href="#stateful_components">Les stateful components</a></li>
                        <li><a href="#useState">useState</a></li>
                        <li><a href="#remonter_etat_maj_composants_enfants">Remonter l'état et le mettre à jour depuis les composants enfants</a></li>
                        <li><a href="#useEffect">useEffect</a></li>
                        <li><a href="#regles_useEffect">Les règles de useEffect</a></li>
                        <li><a href="#creation_application_React_complete">Création d'une application React complète</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>React :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Vous avez sûrement déjà entendu parler de React.</p>
                    <p>Utilisée par les entreprises géantes de la Tech comme Facebook, X ou Netflix, il s'agit de l'une des bibliothèques JavaScript les plus populaires pour construire des interfaces web. Son approche par composants réutilisables en fait un outil particulièrement modulaire pour développer vos applications.</p>
                    <p>Lorsqu'on parle de frameworks JavaScript, les noms de React, Vue.js et Angular ne sont jamais bien loin. Et il en existe d'autres (Ember, Meteor, Backbone...). Chacun a ses spécificités, ses avantages et ses inconvénients.</p>
                    <p>React est un projet open-source, distribué sous la licence MIT et piloté par Facebook. Leurs produits web et mobile tels que Facebook, Messenger, Instagram, reposent en grande partie sur cette technologie. Comme React est open-source, vous pouvez accéder au code source <a href="https://github.com/facebook/react" target="_blank">directement sur GitHub</a>, proposer une feature, ou même notifier d'un problème (issue).</p>
                    <p>L'ambition de React est de <span class="em">créer des interfaces utilisateurs</span>, avec un outil <span class="em">rapide</span> et <span class="em">modulaire</span>. L'idée principale derrière React est que vous vous construisez votre application à partir de composants. <span class="em">Un composant regroupe à la fois le HTML, le JS et le CSS</span>, créés sur mesure pour vos besoins, et que vous poubez <span class="em">réutiliser</span> pour construire des interfaces utilisateurs.</p>
                    <p><a href="https://fr.reactjs.org/docs/getting-started.html" target="_blank">Sur sa documentation</a>, React se présente comme "une bibliothèque JavaScript pour créer des interfaces utilisateurs." Pourtant, depuis tout à l'heure je vous parle de framework. En fait, <span class="em">la frontière entre framework et bibliothèque reste assez fine</span>, surtout dans le cas de React; et il n'est pas simple de séparer parfaitement l'un de l'autre.</p>
                    <p>Pour faire simple, vous pouvez vous dire qu'un <span class="em">framework</span> est un ensemble d'outils ultra complets permettant de <span class="em">créer une application de A à Z</span> et fournissant les outils nécessaires au développement d'une application. Alors qu'une <span class="em">bibliothèque s'ajoute à une partie</span> de votre application.</p>
                    <figure>
                        <img src="../images/framework_bibliotheque_React.png" alt="">
                        <figcaption>Les bibliothèques et les frameworks interagissent différemment avec le code.</figcaption>
                    </figure>
                    <p>Angular, par exemple, qui permet de créer une solution complète où tous les outils sont déjà fournis, comme une solution dédiée au routing ou bien aux appels API, est un framework, pour lequel on attend de vous de respecter une certaine architure.</p>
                    <p>En revanche, avec une bibliothèque, tout est beaucoup plus flexible. La bibliothèqyes vous fournit un ensemble de ressources que vous poubez combiner avec d'autres bibliothèques pour construire votre application.</p>
                    <p>À proprement parler, React... est une bibliothèqye. Mais son écosystème est tellement développé maintenant qu'on peut aussi bien le considérer comme un framexork à part entière.</p>
                    <p>Je vous parlais plus tôt des avanatages/inconvénients de chaque framework. Sans même rentrer dans l'aspect technique, voici quelques-uns des atouts de React :</p>
                    <dl>
                        <dt>Sa communauté :</dt>
                        <dd>Particulièrement active, elle vous facilite la vie. Lorsque vous cherchez votre problème sur Internet, il est quasiment impossible que personne n'ait déjà rencontré le même problème que vous. D'autant plus que React compte de très grosses entreprises parmi ses utilisateurs (Netflix, Twitter, Paypal, Airbnb pour n'en citer que quelques-unes). Vous pouvez être sûr qu'un autre ingéneirur s'est déjà trouvé confronté à votre problème. Par exemple, lorsque vous trouvez une question posée sur <a href="https://stackoverflow.com/" target="_blank">Stack Overflow</a> (en anglais). L'équipe de React répond également aux issues (problèmes) <a href="https://github.com/facebook/react/issues" target="_blank">sur le repository GitHub de React</a> (en anglais). Mais il existe un nombre de newsletters, blogs, chaînes YouTube, créées par des utilisateurs - leur dynamique vous donne toujours envie de tester de nouveaux outils.</dd>
                        <dt>Sa documentation :</dt>
                        <dd>La <a href="https://fr.reactjs.org/" target="_blank">documentation de React</a> est riche, régulièrement mise à jour et intégralement traduite en français.</dd>
                        <dt>Ses opportunités professionnelles :</dt>
                        <dd>Comme il s'agit d'un des frameworks les plus populaires, les opportunités professionnelles sont particulièrement nombreuses. Dans <a href="https://2022.stateofjs.com/fr-FR/libraries/front-end-frameworks/" target="_blank">l'enquête annuelle State of JS de 2022</a>, 100% des personnes déclaraient connaître React, et sur 33338 sondés, 27289 déclaraient utiliser React (qui a d'ailleurs <a href="https://2019.stateofjs.com/awards/" target="_blank">gagné l"Award 2019</a> de la technologie la plus utilisée).</dd>
                    </dl>
                </article>
                <article>
                    <h2 id="transformation_HTML_React">Transformez un simple fichier HTML en app React :</h2>
                    <p>Nous allons maintenant <span class="em">transformer un fichier HTML en app React</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode que je vous montre ici n'est pas une méthode utilisée dans le monde du travail. Il s'agit d'un moyen de vous montrer les bases sans aoir à faire trop de paramétrage, et sans avoir à utiliser trop d'outils tels que Webpack. Ici, nous pouvons nous concentrer sur l'essentiel.</p>
                    </div>
                    <p>Nous allons utiliser des liens CDN (Content Deklivery Network) pour ajouter React à un fichier HTML.</p>
                    <p>On oublie pas d'aller chercher le lien CDN de Babel et on rajoute une autre balise &lt;script&gt; :</p>
<pre><code>&lt;div id="root"&gt;Bonjour&lt;/div&gt;
&lt;script type="text/babel"&gt;
    ReactDom.render(&lt;div&gt;Mon élément remplace le contenu précédent&lt;/div&gt;,
                    document.getElementById('root')
                   )
&lt;/script&gt;</code></pre>
                </article>
                <article>
                    <h2 id="premier_composant">Créez votre premier composant :</h2>
                    <p>Écrivons maintenant <span class="em">notre premier composant</span>.</p>
                    <p>Ici, je vais utiliser des composants qu'on appelle <span class="em">functional components</span> (composants fonction), c'est-à-dire une fonction qui retourne un élément React. Commençons avec cette <span class="em">prem!re fonction</span>, MyComponent :</p>
<pre><code>function MyComponent() {
    return (&lt;div&gt;Hello World !&lt;/div&gt;)
}</code></pre>
                    <p>En copiant ce code dans la partie JS, rien ne se passe. Pas de panique ! C'est normal : il vous reste encore à attacher votre composant React à votre HTML.</p>
                    <p>On va dès mainenant <span class="em">utiliser ReactDOM pour s'atatcher à notre HTML</span>.</p>
                    <p>Dans le code ci-dessous, l'id <span class="em">root</span> permet de préciser où notre app React va vivre dans notre HTML. Ensuite, on va ordonner à ReactDOM de générer (<span class="em">render</span>) notre composant React qui s'appelle MyComponent.</p>
<pre><code>ReactDOM.render(&lt;,MyComponent /&gt;, document.getElementById('root'))</code></pre>
                    <p>Et tadaaa ! Notre composant s'affiche !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe différentes manières de créer des composants en React. Il y a peu de temps encore, la manière la plus utilisée était d'utiliser des composants classes, avec la syntaxe :</p>
<pre><code>class MyComponent extends React.Component</code></pre>
                        <p>Cette manière était la seule pour utiliser des fonctionnalités qui sont au coeur de React. Mais depuis la mise à jour de React 16.8 en 2019, les composants fonctions permettent aussi de gérer tout ça.</p>
                    </div>
                    <p class="em">Les composants sont essentiels dans React.</p>
                    <p>Une interface est toujours constituée de différents éléments : des boutons, des listes, des titres, des sous-tritres. Une fois rassemblés, ces éléments constituent une <span class="em">interface utilisateur ou UI</span>. Si je prends l'exemple de la maquette du site de plantes ci-dessous, vous voyez la barre de menu, le panier, et que pour chaque article, il y a un nom, une photo, une description.</p>
                    <img src="../images/maquette_React.png" alt="">
                    <p>Avec React, chacune de ces parties qu'on va pouvoir réutiliser correspond à un composant. Ils contiennent tout ce qui est nécessaire à leur bon fonctionnement : <span class="em">la structure, les styles et le comportement</span> (par exemple, les actions qui sont déclenchées quand on clique dessus).</p>
                    <p>Les composants nous permettent d'utiliser la même structure de données, et de remplir ces structures avec différents jeux de données. Peu importe le nombre de plantes que vous aurez à mettre dans La maison jungle, vous pourrez les exploiter pour afficher vos données sans aucun effort. Et si dans le futur, vous avez besoin de créer une nouvelle page avec la même présentation, vous pourrez réutiliser le même composant: vous vous rendez compte de la puissance des composants ?</p>
                    <p>C'est donc la mission des développeurs et développeurses React de découper toute interface utilisateur en éléments réutilisables, imbriqués les uns dans les autres. La majorité de nos composants sont eux-mêmes créés en <span class="em">combinant d'autres composants</span> plus simples.</p>
                    <p>Derrière chaque technologie, il y a une logique.</p>
                    <p>Vous savez que le HTML est une suite d'instructions que le navigateur doit suivre pour construire le DOM. Eh bien, <span class="em">react vient directement modifier le DOM pour vous</span> ; il suffit juste de lui donner les instructions de ce que vous souhaitez faire.</p>
                    <p>Pour faire simple : en utilisant <span class="html">React.createElement</span>, React crée d'abord ses éléments dans le DOM virtuel, puis il vient prévenir le DOM au moment de sa créatuibn "Hé, rajoute-moi une balise h1 avec le texte <span class="em">La maison jungle</span> dedans".</p>
<pre><code>&lt;div id="root"&gt;&lt;/div&gt;

const Header = React.createElement('h1', {}, 'La maison jungle')

console.log(Header)

ReactDOM.render(Header, document.getElementById("root"))</code></pre>
                    <p>En faisant un <span class="html">console.log</span> de votre composant, voilà ce que vous obtenez :</p>
                    <figure>
                        <img src="../images/console_log_React.png" alt="">
                        <figcaption>Un console.log de notre premier composant</figcaption>
                    </figure>
                    <p><span class="em">Header</span> est ici un élément React, créé par React. Concrètement, il s'agit d'un gros objet. Chaque composant génère des arborescences d'éléments React et d'autres composants, qui seront ensuite traduits en éléments dans le DOM.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>C'est un peu comme lorsque vous créez en JavaScript un nouvel élément avec <span class="html">document.createElement</span> et que vous l'ajoutez au DOM avec la méthode <span class="html">.appendChild()</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="initialisation_JSX">Initiez-vous au JSX :</h2>
                    <p>Vous avez découvert que les éléments renvoient des objets avec tout un ensemble de propriétés spécifiques, et que React vient les créer avec <span class="em">createElement</span>. Mais vous vous doutez que les développeurs React ne manipulent pas ces objets directement. Non, à la place, ils utilisent le <span class="em">JSX</span>.</p>
                    <p>Il s'agit de l'extension JavaScript créée par React, qui permet d'<span class="em">utiliser notre syntaxe sous forme de tages directement dans le code JavaScript</span>.</p>
                    <p>Lorsqu'on a ça :</p>
<pre><code>function Header() {
    return (&lt;div&gt;
        &lt;h1&gt;La maison jungle&lt;/h1&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>... et qu'on le réutilise avec <span class="em">&lt;Header /&gt;</span>, on pourrait croire qu'il s'agit de HTML. Ça a un peu la même tête, mais il s'agit de JSX ! Eh oui, JSX est la manière la plus compréhensible d'écrire dfes composants React dans une application, et donc la manière qui est quasiment toujours utilisée. Il s'agit d'ailleurs de <span class="em">la sépcificité de React</span> : contrairement aux autres frameworks où on écrit du HTML enrichi, les équipes de React ont créé le JSX, leur propre syntaxe basée sur JavaScript, qui permet de <span class="em">mêler HTML et JS</span>.</p>
                    <p>Comme le HTML, le JSX est un <span class="em">langage à balises</span>. Les touches <span class="html">&lt;</span>, <span class="html">&gt;</span> et <span class="html">/</span> de vos claviers vont donc être souvent utilisées.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>On a bien créé un composant <span class="em">Header</span> et pas <span class="em">header</span>. Il est essentiel de <span class="em">mettre une majuscule à nos composants JSX</span>, sinon React ne saura pas qu'il s'agit d'un composant, et pensera qu'il s'agit juste d'une balise HTML.</p>
                    </div>
                    <h3>Composez vos composants :</h3>
                    <p>Reprenons notre composant <span class="em">&lt;Header /&gt;</span>. Il est un peu tout seul, vous ne trouvez pas ?</p>
                    <p>On va lui ajouter un composant <span class="em">&lt;Description /&gt;</span> :</p>
<pre><code>function Description() {
    return (&lt;p&gt;Ici achetez toutes les plantes dont vous avez toujours rêvé&lt;/p&gt;)
}</code></pre>
                    <p>Et on le rajoute dans le render :</p>
<pre><code>ReactDOM.render(&lt;Header /&gt;&lt;Description /&gt;, document.getElementById("root"))</code></pre>
                    <p>Quoi ?! Rien ne s'affiche sauf un point d'exclamation entouré de rouge : il y a une erreur !</p>
                    <p>Pas de panique, c'est normal : deux composants doivent toujours être <span class="em">wrappés dans un seul composant parent</span>.</p>
                    <p>On peut donc faire :</p>
<pre><code>ReactDOM.render(&lt;div&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/div&gt;, document.getElementById("root"))</code></pre>
                    <p>et le problème est résolu.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>React met également à notre disposition un outil, les Fragments, si on veut wrapper deux composants dans un seul parent sans que le parent apparaisse dans le DOM. Pour ça, vous pouvez faire :</p>
<pre><code>ReactDOM.render(&lt;React.Fragment&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/React.Fragment&gt;, document.getElementById("root"))</code></pre>
                        <p>Nos éléments sont bien wrappés, et si vous inspectez votre page, ce parent n'apparaît pas dans le DOM.</p>
                    </div>
                    <p>Comme je vous l'ai expliqué, le propre de react est de nous encourager à <span class="em">réutiliser nos composants</span>. On va donc structurer notre interface en arborescences de composants.</p>
                    <p>Regroupons notre Titre et notre Description dans une bannière :</p>
<pre><code>function Banner() {
    return (&lt;div&gt;
        &lt;Header /&gt;
        &lt;Description /&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>Vous voyez ? Tout se passe bien comme prévu.</p>
                    <p>Et nous pourrions également les encapsuler, et les utiliser autant de fois que nous le souhaitons comme ci-dessous :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
&lt;/Parent&gt;</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Vous remarquez d'aillez que tous nos composants sont bien fermés. En JSX, <span class="em">toutes les balises doivent être fermées</span>, y compris les éléments HTML autofermants tels que input. On l'écrira de cette manière (en lui ajoutant les attributs souhaités) :</p>
<pre><code>&lt;input /&gt;</code></pre>
                    </div>
                    <h3>Manipulez des données dans vos composants JSX :</h3>
                    <p>En React, les accolades <span class="html">{</span> et <span class="html">}</span> sont également particulièrement utiles. Dès qu'il s'agit d'expressions JavaScript, elles sont écrites entre accolades.</p>
                    <p>Ça nous permet d'<span class="em">appliquer des expressions JavaScript</span> directement dans notre JSX pour :</p>
                    <ul>
                        <li>
                            <p>faire des maths :</p>
<pre><code>&lt;div&gt;La grande réponse sur la vie, l'univers et le reste est { 6 * 7 } &lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>modifier des chaînes de caractères :</p>
<pre><code>&lt;div&gt;{ alexia.toUpperCase() }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>utiliser des <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaires</a> :</p>
<pre><code>&lt;div&gt;{ 2 &gt; 0 ? 'Deux est plus grand que zéro' : 'Ceci n\'apparaîtra jamais' }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Ou même tout simplement pour afficher une variable JS :</p>
                    <ul>
                        <li>
                            <p>pour une string :</p>
<pre><code>&lt;div&gt;{ myTitle }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>pour un nombre :</p>
<pre><code>div&gt;{ 42 }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Par exemple, si on décide de mettre notre texte ou description dans une variable :</p>
<pre><code>function Description() {
    const text = "Ici achetez toutes les plantes dont vous avez toujours rêvées"
    return (&lt;p&gt;{ text }&lt;/p&gt;)
}</code></pre>
                    <p>ça s'affiche bien comme prévu.</p>
                </article>
                <article>
                    <h2 id="Create_React_App">Prenez en main Create React App :</h2>
                    <p>Nous avons appris à utiliser les liens CDN de React, ReactDOM et Babel pour rapidement créer une app React. Mais cette technique n'est quasiment pas utilisée dans la vie de tous les jours d'un développeur.</p>
                    <p>À la place, les développeuses et développeurs utilisent des outils automatisés pour créer une base de code, qui dispose des outils essentiels déjà préconfigurés. Pour vous citer quelques-unes des fonctionnalités de ces outils, ils permettent de :</p>
                    <ul>
                        <li>
                            <p>gérer les différentes dépendances (bibliothèques) utilisées par notre app;</p>
                        </li>
                        <li>
                            <p>optimiser le chargement de notre code dans les navigateurs;</p>
                        </li>
                        <li>
                            <p>importer du CSS et des images;</p>
                        </li>
                        <li>
                            <p>gérer les différentes versions de JavaScript;</p>
                        </li>
                        <li>
                            <p>faciliter l'expérience de développement, en rechargeant la page lorsque le code est modifié.</p>
                        </li>
                    </ul>
                    <h3>Découvrez CRA :</h3>
                    <p>Également créé par les équipes de Facebook, <a href="https://github.com/facebook/create-react-app" target="_blank">Create React App</a> est un outil qui vous aidera à faire tout ce que je viens de citer. S'il existe d'autres outils (<a href="https://nextjs.org/" target="_blank">Next</a>, <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a>, <a href="https://parceljs.org/" target="_blank">Parcel</a>, etc.), Create React App reste la référence, notamment pour les nouveaux utilisateurs de React.</p>
                    <p>Create React App va permettre de <span class="em">générer un squelette de code</span> pour votre application. Il embarque un certain nombre d'<span class="em">outils préconfigurés</span>, tels que Webpack, Babel et ESLint, afin de vous garantie la meilleure expérience de développement possible.</p>
                    <h3>Installez et lancez CRA :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour manipuler Create React App ici, nous allons avoir besoin d'un gestionnaire de paquet (<span class="em">package manager</span>) directement dans le terminal. Ici, je vais utiliser <span class="html">yarn</span>. Si vous utilisez une autre version, telle que npm, je vous conseille de vous référer au <a href="https://github.com/facebook/create-react-app#user-guide" target="_blank">guide d'utilisation de Create React App par Facebook, sur GitHub</a> (en anglais).</p>
                        <p>D'ailleurs, si vous voulez en apprendre davantage sur pourquoi choisir npm ou Yarn, <a href="https://blog.zenika.com/2017/03/13/npm-vs-yarn/" target="_blank">je vous conseille cet excellent article de blog qui compare les deux.</a></p>
                    </div>
                    <p>Pour commencer, placez-vous dans le dossier où vous voulez créer votre projet.</p>
                    <p>Pour initialiser votre projet, nous allons faire :</p>
<pre><code>yarn create react-app la-maison-jungle</code></pre>
                    <p>Grâce à cette commande, vous avez votre premier projet créé avec Create React App !</p>
                    <h3>Découvrez les fichiers :</h3>
                    <p>Maintenant que votre projet est initialisé, il est temps de vous plonger dedans et de partir à l'exploration des fcihiers créés. On rentre dans le projet avec <span class="html">cd la-maison-jungle</span> dans votre terminal.</p>
                    <p>À partir de là, vous pouvez ouvrir votre éditeur de texte préféré pour jeter un oeil.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Votre environnement de travail est particulièrement important. Vous devez vous sentir à l'aise avec les outils que vous utilisez. VS Code vous permet d'installer des extensions qui vous offrent des fonctionnalités supplémentaires. Typiquement, pour un projet React, les extensions Prettier et ESLint sont très utiles !</p>
                    </div>
                    <p>Vous trouverez trois dossiers :</p>
                    <ul>
                        <li>
                            <p><span class="html">node_modules</span> : c'est là que sont installées toutes les <span class="em">dépendances</span> de notre code. Ce dossier peut vite devenir très volumineux.</p>
                        </li>
                        <li>
                            <p><span class="html">public</span> : dans ce dossier, vous trouverez votre <span class="em">fichier</span> <span class="html">index.html</span> et d'autres fichiers relatifs au référencement web de votre page.</p>
                        </li>
                        <li>
                            <p><span class="html">src</span> : vous venez de renrer dans le coeur de l'action. <span class="em">L'essentiel des fichiers que vous créerez et modifierez seront là.</span></p>
                        </li>
                    </ul>
                    <p>Et faisons maintenant un petit tour des fichiers importants :</p>
                    <ul>
                        <li>
                            <p><span class="html">package.json</span> situé à la racine de votre projet, il vous permet de <span class="em">gérer vos dépendances</span> (tous les outils permettant de construire votre projet), vos scripts qui peuvent être exécutés avec <span class="html">yarn</span>, etc. Si vous examinez son contenu, vous pouvez voir des dépendances que vous connaissez : React et ReactDOM :</p>
                            <ul>
                                <li>
                                    <p>vous y trouverez <span class="html">react-scripts</span>, créé par Facebook, qui permet d'installer Webpack, Babel, ESLint et d'autres pour vous faciliter la vie</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>dans <span class="html">/public</span>, vous trouvez <span class="html">index.html</span>. Il s'agit du <span class="em">template de votre application</span>. Il y a plein de lignes de code, mais vous remarquez <span class="html">&lt;div id="root"&gt;&lt;/div&gt;</span> ? Comme précédemment, nous allons y ancrer notre app React</p>
                        </li>
                        <li>
                            <p>dans <span class="html">/src</span>, il y a <span class="html">index.js</span> qui permet d'<span class="em">initialiser notre app React</span>;</p>
                        </li>
                        <li>
                            <p>et enfin, dans <span class="html">/src</span>, vous trouvez <span class="html">App.js</span> qui est <span class="em">notre premier composant React</span>.</p>
                        </li>
                    </ul>
                    <p>Deux fichiers que nous n'utiliserons pas directement mais qui ne font pas de mal à garder :</p>
                    <ul>
                        <li>
                            <p>le <span class="html">README.md</span> qui permet d'afficher une page d'explication si vous mettez votre code sur GitHub, par exemple</p>
                        </li>
                        <li>
                            <p>et le fichier <span class="html">.gitignore</span> qui précise ce qui ne doit pas être mis sur GitHub, typiquement le volumineux dossier des <span class="html">node_modules</span>.</p>
                        </li>
                    </ul>
                    <h3>Choisir une version spécifique de React :</h3>
                    <p>Pour mettre à jour les dépendances, nous allons suivre différentes étapes :</p>
                    <ol>
                        <li>
                            <p>Rendez-vous au fichier <span class="html">package.json</span> dans la section <span class="html">depencies</span>. Modifiez cette section avec le code suivant, correspondant aux dépendances nécessaires à React 17 :</p>
<pre><code>"dependencies": {
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "react-scripts": "4.0.1",
    "web-vitals": "^0.2.4"
},</code></pre>
                        </li>
                        <li>
                            <p>Supprimez le fichier <span class="html">yarn.lock</span> (ou <span class="html">package.lock</span> si vous avez utilisé npm) ainsi que le dossier de nos dépendances <span class="html">node_modules</span>.</p>
                        </li>
                        <li>
                            <p>Dans le dossier <span class="html">src</span>, modifiez le fichier <span class="html">index.js</span> qui a été généré pour la dernière version de React avec le code correspondant à la version de React 17, comme ceci :</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;App /&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
);</code></pre>
                        </li>
                        <li>
                            <p>Lancer la commande <span class="html">yarn</span> pour installer les dépendaces.</p>
                        </li>
                    </ol>
                    <p>Vous pouvez procéder de la même manière pour installer n'importe quelle version spécifique de React dans votre application. En suivant le cheminement ci-dessus vous serez à même de suivre la suite de ce cours sans difficulté.</p>
                    <h3>Prenez en main votre app avec les commandes :</h3>
                    <p>Lorsque vous vous trouvez à la racine de votre projet, vous pouvez exécuter <span class="html">yarn start</span> qui va <span class="em">démarrer votre application en mode développement</span>.</p>
                    <p>Cela vous donne quelque chose comme ça (même si votre adresse IP sera très probablement différente) :</p>
                    <img src="../images/yarn_start_React.png" alt="">
                    <p>Un onglet a dû s'ouvrir dans votre navigateur à l'URL <span class="em">http://localhost:3000/</span>. Si ce n'est pas le cas, ouvrez-le vous-même.</p>
                    <p>Vous avez le magnifique logo de React qui tourne dans votre navigateur.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe d'autres commandes :</p>
                        <ul>
                            <li>
                                <p><span class="html">yarn run build</span> vous permettra de créer un <span class="html">build</span> avec votre code transformé et minifié, si vous devez déployer votre application en production (la mettre en ligne, par exemple);</p>
                            </li>
                            <li>
                                <p><span class="html">yarn test</span> pour exécuter les tests.</p>
                            </li>
                        </ul>
                        <p>Vous pouvez d'ailleurs créer vos propres commandes si vous les ajoutez dans la partie <span class="html">scripts</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="organisation_code">Organisez votre code :</h2>
                    <p>Nous allons maintenant <span class="em">modifier notre base de code</span> pour qu'elle soit plus à l'image de notre projet. Il existe plusieurs manières d'organiser son code, et il est important de réfléchir à comment l'organiser. Ici, nous allons séparer les fichiers selon leur type : composants/style/images, etc.</p>
                    <p>On va commencer par créer un dossier <span class="html">/components</span> dans <span class="html">/src</span>, où nous mettrons tous nos composants. On y glisse <span class="html">App.js</span> et on en profite pour changer le chemin d'import dans <span class="html">index.js</span>. Pour ce qui est des autres fichiers, le plus important est <span class="html">index.js</span> que vous devez garder. Vous pouvez également garder <span class="html">index.css</span>, mais vous pouvez supprimer les autres fichiers.</p>
                    <p>Maintenant, <span class="em">créons notre</span> <span class="html">Banner</span> dans un fichier JavaScript à part dans <span class="html">/components</span> que nous pouvons appeler <span class="html">Banner.js</span>.</p>
<pre><code>function Banner() {
    return &lt;h1&gt;La maison jungle&lt;/h1&gt;
}

export default Banner</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous remarquez la notation <span class="html">export default</span> ? Il s'agit d'une syntaxe prévue dans l'ES6, qui vous épargnera d'utiliser les accolades au moment de l'import.</p>
                    </div>
                    <p>On peut maintenant adapter le code de <span class="html">App.js</span> en supprimant le code de base, et <span class="em">y importer notre</span> <span class="html">Banner</span>.</p>
<pre><code>import Banner from './Banner'

function App() {
    return &lt;Banner /&gt;
}

export default App</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/banner_React.png" alt="">
                        <figcaption>Notre Banner s'affiche dans le navigateur.</figcaption>
                    </figure>
                    <p>Félicitations ! Comme je l'ai déjà mentionné, mais ici, c'est <a href="https://webpack.js.org/" target="_blank">Webpack</a> qui nous permet d'importer notre composant aussi facilement, avec <span class="html">import</span>. Cet outil particulièrement utile est essentiel pour lier les fichiers entre eux, afin qu'ils soient interprétés par le navigateur. Et dire que Create React App nous a permis de l'installer sans faire aucune configuration. Si ça c'est pas de la chance !</p>
                    <figure>
                        <img src="../images/webpack_React.png" alt="">
                        <figcaption>Import vos composants grâce à Webpack</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="stylisation_app">Stylisez votre app :</h2>
                    <p>C'est maintenant le moment d'ajouter un peu de style à nos composants.</p>
                    <h3>Exploitez les classNames :</h3>
                    <p>Comme en HTML, nous pouvons <span class="em">associer des attributs à nos éléments</span>. Les attributs HTML tels que <span class="html">id</span>, <span class="html">href</span> pour un lien &lt;a /&gt;, <span class="html">src</span> pour une balise &lt;img /&gt;, fonctionnent normalement en JSX.</p>
                    <p>En revanche, il existe des mots réservés en JavaScript, tels que <span class="html">class</span>. Pour attribuer du style avec une classe CSS, il suffit pour cela d'utiliser l'attribut <span class="html">className</span>, et de lui préciser une string. D'ailleurs, vous pouvez utiliser plusieurs classes sur un élément en les mettant à la suite, séparées par un espace.</p>
                    <p>Créons dans <span class="html">/src</span> un dossier <span class="html">/styles</span> qui va regrouper nos fichiers CSS. On peut y glisser <span class="html">index.css</span> en n'oubliant pas de modifier le path relatif pour importer <span class="html">index.css</span> dans <span class="html">index.js</span>.</p>
                    <p>Je crée donc mon fichier <span class="html">Banner.css</span> qui va me permettre de <span class="em">styliser mon composant</span>. Ce qui nous donne une organisation comme dans la capture ci-dessous :</p>
                    <figure>
                        <img src="../images/banner_CSS_React.png" alt="">
                        <figcaption>L'arborescence de notre app</figcaption>
                    </figure>
                    <p>Dans <span class="html">Banner.js</span>, je wrappe mon <span class="em">h1</span> dans une div à laquelle je <span class="em">précise la className lmj-banner</span> ("lmj" pour la maison jungle, bien sûr !) :</p>
<pre><code>&lt;div className='lmj-banner'&gt;
    &lt;h1&gt;La maison jungle&lt;/h1&gt;
&lt;/div&gt;</code></pre>
                    <p>Et retour dans notre fichier <span class="html">Banner.css</span>, où on <span class="em">crée la classe correspondante</span> :</p>
<pre><code>.lmj-banner {
    color: black;
    text-align: right;
    padding: 32px;
    border-bottom: solid 3px black;
}</code></pre>
                    <p>Jetons un oeil à notre page dans le navigateur.</p>
                    <p>Rien ne se passe car nous n'avons tout simplement pas <span class="em">importé le fichier</span>. Il suffit de rajouter dans notre fichier <span class="html">Banner.js</span> :</p>
<pre><code>import '../styles/Banner.css'</code></pre>
                    <p>Et ça y est ! Notre style est appliqué !</p>
                    <p>En React comme dans toutes les librairies et tous les frameworks front, <span class="em">l'accessibilité du web est essentielle</span>. Elle est nécessaire pour permettre aux technologies d'assistance et aux personnes en situation de handicap, notamment, d'interpréter les pages web. Pour en savoir plus, je vous conseille "<a href="https://openclassrooms.com/fr/courses/6691346-concevez-un-contenu-web-accessible" target="_blank">Concevez un contenu web accessible</a>", un excellent cours sur ce sujet.</p>
                </article>
                <article>
                    <h2 id="decouverte_attribut_style">Découvrez l'attribut style :</h2>
                    <p>Bonne nouvelle : les éléments React acceptent également l'attribut <span class="html">style</span> pour styliser un composant. À la différence des éléments HTML, pour lesquels cet attribut est également accepté, il faut lui passer un objet en paramètre. On appelle cette méthode du <span class="em">inline style</span> :</p>
<pre><code>import '../styles/Banner.css'

function Banner() {
    return (
        &lt;div
                style={{
                    color: 'black',
                    textAlign: 'right',
                    padding: 32,
                    borderBottom: 'solid 3px solid'
                }}
        &gt;
            &lt;h1&gt;La maison jungle&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>Cet attribut peut être pratique pour tester rapidement quelque chose, mais il n'est pas recommandé d'en faire une utilisation plus poussée. Donc, pour styliser votre application, privilégiez davantage la méthode des classNames, ou d'autres méthodes avec des librairies tierces, par exemple.</p>
                </article>
                <article>
                    <h2 id="utilisation_images">Utilisez des images :</h2>
                    <p>Vous avez peut-être vu le <span class="em">logo.svg</span> de React situé dans <span class="html">/src</span> ?</p>
                    <p>Ici, nous allons faire un peu la même chose. Mais commençons par organiser tout ça.</p>
                    <p>Toujours dans <span class="html">/src</span> , on crée un dossier <span class="html">/assets</span> dans lequel on vient mettre notre fichier <span class="em">logo.png</span> qui voici :</p>
                    <img src="../images/logo.png" alt="">
                    <p>Pour <span class="em">l'importer dans votre code</span>, vous pouvez maintenant faire de la manière suivante . Dans <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'</code></pre>
                    <p>Vous voyez ici, on déclare en fait une variable logo à laquelle on assigne le contenu de notre image.</p>
                    <p>Puis vous pouvez <span class="em">l'utiliser dans un élément img</span>, ce qui nous donne pour notre <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'
import '../styles/Banner.css'

function Banner() {
    const title = 'La maison jungle'
    return (
        &lt;div className='lmj-banner'&gt;
            &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
            &lt;h1 className='lmj-title'&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>En ajoutant un peu de CSS, me voilà avec la bannière telle que je la voulais.</p>
                    <p>Vous avez maintenant une très bonne base de code pour créer votre application, en utilisant du style et des assets directement dans vos composants React.</p>
                </article>
                <article>
                    <h2 id="iteration_contenu">Itérez sur votre contenu :</h2>
                    <p>En code, vous serez très souvent confronté à des listes de données qui présentent la même struture. Bonne nouvelle ! Pas besoin de vous faire des crampes à force de copier-coller : vous pouvez <span class="em">directement itérer sur votre contenu et générer des composants react dessus</span>.</p>
                    <h3>Découvrez votre allié : map() :</h3>
                    <p>La <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/map" target="_blank">méthode JavaScript <span class="html">map()</span></a> passe sur chaque élément d'un tableau. Elle lui applique une fonction, et renvoie un nouveau tableau contenant les résultats de cette fonction appliquée sur chaque élément.</p>
                    <p>Par exemple, pour une fonction qui doublerait la valeur d'un élément, cela donne :</p>
<pre><code>const numbers = [1, 2, 3, 4]
const doubles = numbers.map(x =&gt; x * 2) // [ 2, 4, 6, 8]</code></pre>
                    <p>Dans notre cas, ekke ca biys oerlerrre de <span class="em">prendre une liste de données</span>, et de la <span class="em">transformer en liste de composants</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode <span class="html">map()</span> permet facilement d'itérer sur des données et de retourner un tableau d'éléments. Comme elle, les méthodes <span class="html">forEach()</span>, <span class="html">filter()</span>, <span class="html">reduce()</span>, etc., qui permettent de manipuler des tableaux, seront également vos alliés en React.</p>
                    </div>
                    <p>On va donc créer un composant <span class="html">ShoppingList.js</span> pour notre magain de plantes.</p>
                    <p>Dans ce fichier, on déclare une variable plantList qui <span class="em">contient notre liste de plantes</span> :</p>
<pre><code>const plantList = [
    'monstera',
    'ficus lyrata',
    'pothos argenté',
    'yucca',
    'palmier'
]</code></pre>
                    <p>Et <span class="em">on ajoute en dessous le composant</span> lui-même :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant) => (
                &lt;li&gt;{plant}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Vous voyez : pour chaque entrée du tableau, on retourne un élément <span class="html">&lt;li&gt;</span>.</p>
                    <p>On <span class="em">importe ShoppingList.js dans</span> <span class="html">&lt;App /&gt;</span>. On a notre liste de composants !</p>
                    <p>Mais qu'est-ce que c'est que cette erreur rouge dans ma console ?</p>
                    <p>Oh oh ! Il semblerait que j'aie oublié la prop <span class="html">key</span>.</p>
                    <p>La <a href="https://fr.reactjs.org/docs/lists-and-keys.html" target="_blank">documentation de React</a> est claire sur ce sujet : les <span class="html">key</span> (clés) aident React à <span class="em">identifier quels éléments d'une liste ont changé, ont été ajoutés ou spprimés</span>. Vous devez donner une clé à chaque élément dans un tableau, afin d'apporter aux éléménts une identité stable.</p>
                    <p>Si vous voulez éviter kes bugs, une <span class="html">key</span> doit impérativement respecter deux principes :</p>
                    <ul>
                        <li>
                            <p>Elle doit être <span class="em">unique</span> au sein du tableau.</p>
                        </li>
                        <li>
                            <p>Et <span class="em">stable dans le temps</span> (pour la même donnée source, on aura toujours la même valeur de <span class="html">key=</span>).</p>
                        </li>
                    </ul>
                    <p>Nous avons plusieurs méthodes pour générer une <span class="em">key</span> unique :</p>
                    <ul>
                        <li>
                            <p>La méthode la plus simple et la plus fiable consiste à <span class="em">utiliser l'id associée à votre donnée</span> dans votre base de données.</p>
                        </li>
                        <li>
                            <p>Vous pouvez également trouver un moyen d'<span class="Em">exploiter la valeur de la donnée</span>, si vous avez la certitude qu'elle sera toujours unique, et stable dans le temps.</p>
                        </li>
                        <li>
                            <p>En dernier recours, vous pouvez <span class="em">définir une string et la combiner avec l'index</span> de la data dans votre tableau.</p>
                        </li>
                    </ul>
                    <p>Dans notre cas, puisqu'il n'y a pas d'id associée, on peut faire une combinaison entre l'index et le nom de la plante qui est une string :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant, index) =&gt; (
                &lt;li key={`${plant}-${index}`}&gt;{ plant }&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Cette fois-ci, pas d'erreur dans la console !</p>
                </article>
                <article>
                    <h2 id="contextualisation_contenu_composants">Contextualisez le contenu de vos composants :</h2>
                    <p>React nous permet de faire des listes de composants : un gain de temps énorme dans votre vie de développeur. Mais ce n'est pas tout ! Le JSX nous permet également d'<span class="em">afficher des éléments de manière conditionnelle dans nos composants</span>.</p>
                    <h3>Créez des conditions dans le JSX :</h3>
                    <p>Donc... Nous avons déjà vu <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaire</a>. maintenant qu'on a une app complète pour nous faire la main, moi, ça me donne envie de le mettre en applicationdans notre site de plantes.</p>
                    <p>Dans notre liste de plantes <span class="html">plantList.js</span>, je vais <span class="em">rajouter une catégorie <span class="html">isBestSale</span> correspondant à un <span class="html">booléen</span></span> qui nous indique si notre plante fait partie des meilleures ventes. Ce qui nous donne pour le premier élément :</p>
<pre><code>{
    name: 'monstera',
    category: 'classique',
    id: '1ed',
    isBestSale: true
},</code></pre>
                    <p>Maintenant que nous avons notre booléen, nous allons <span class="em">utiliser un ternaire pour afficher un emoji en fonction</span>. Dans <span class="html">ShoppingList.js</span>, au niveau de l'affichage du nom, je rajoute :</p>
<pre><code>{plantList.map((plant) =&gt; (
    &lt;li key={ plant.id }&gt;
        {plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : &lt;span&gt;👎&lt;/span&gt;}
    &lt;/li&gt;
))}</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/condition_React.png" alt="">
                        <figcaption>Notre condition différencie les meilleures ventes des autres.</figcaption>
                    </figure>
                    <p>Génial ! Ça marche bien !</p>
                    <p>Mais en y repensant, je ne suis pas sûre que ce soit top comme argulent de vente... À la place, n'affichons que le 🔥 pour les meilleures ventes, et rien pour les autres.</p>
                    <p>Pour ça, on peut <span class="em">retourner <span class="html">null</span> dans la condition où on ne veut rien afficher</span> :</p>
<pre><code>{plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : null}</code></pre>
                    <p>Et voilà ! On a ce que l'on voulait !</p>
                    <p>Mais vous savez quoi ? Il existe une manière encore plus simple d'écrirer ça : vous pouvez utiliser <span class="html">&amp;&amp;</span>.</p>
                    <p>Indiquée entre accolades, <span class="html">&amp;&amp;</span> précède un élément JSX et <span class="em">précise que l'élément ne sera généré que si la condition est respectée</span>. On peut donc écrire :</p>
<pre><code>{plant.isBestSale && &lt;span&gt;🔥&lt;/span&gt;}</code></pre>
                    <p>Yes ! Ça fonctionne comme prévu !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous pouvez d'ailleurs chaîner les conditions.</p>
                    </div>
                    <h3>Ouvrez-vous à d'autres méthodes :</h3>
                    <p>React est particulièrement flexible : il existe d'autres méthodes permettant de contextualiser votre contenu.</p>
                </article>
                <article>
                    <h2 id="familisarisation_props">Familiarisez-vous avec les props :</h2>
                    <p>Vous l'avez compris : la réutilisation des composants est au coeur de la logique de react. Mais, pour être réutilisés, les composants requièrent souvent une conviguration. Bonne nouvelle : pour ça, vous allez pouvoir utiliser les props.</p>
                    <h3>Familiarisez-vous avec la syntaxe :</h3>
                    <p>Et si je vous disais que vous avez déjà utilisé une prop ? Eh oui, la prop <span class="html">key</span> sur les listes ! Vous avez donc déjà vu la syntaxe.</p>
                    <p>Revenons à notre site de plantes. Nous allons maintenant créer un nouveau composant qui va être réutilisé. L'idée est de créer une échelle d'arrosage et une échelle de luminosité pour chaque plante.</p>
                    <p>Rouvrons <span class="html">ShoppingList.js</span>, où nous <span class="em">ajoutons les données correspondantes dans <span class="html">plantList</span></span> :</p>
                    <ul>
                        <li>
                            <p>une donnée <span class="em">water</span> qui correspond à l'arrosage conseillé pour chaque plante;</p>
                        </li>
                        <li>
                            <p>et une donnée <span class="em">light</span> qui correspond à l'ensoleillement nécessaire.</p>
                        </li>
                    </ul>
                    <p>Commençons par la lumière : dans chaque item plante, on vient <span class="em">ajouter un composant <span class="html">CareScale</span> et on lui passe la prop value</span> :</p>
<pre><code>&lt;CareScale scalueValue={plant.light} /&gt;</code></pre>
                    <p>Les props sont récupérées dans les <span class="em">paramètres de la fonction qui définit notre composant</span>.</p>
                    <p>Pour <span class="html">CareScale</span>, on aura donc :</p>
<pre><code>function CareScale(props) {µ
    const scaleValue = props.scaleValue
    return &lt;div&gt;{scaleValue}☀️&lt;/div&gt;
}

export default CareScale</code></pre>
                    <p>Mais on avait dit qu'on voulait une échelle de 1 à 3, non ?</p>
                    <p>On va donc <span class="em">partir sur une liste</span>, qu'on peut manuellement.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>function CareScale(props) {
    const scaleValue = props.scaleValue

    const range = [1, 2, 3]

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt;
                scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;☀️&lt;/span&gt; : null
            )}
        </div>
    )
}</code></pre>
                    <p>Félicitations ! Vous venez d'utiliser les <span class="em">props</span> !</p>
                    <p>Les props sont donc des <span class="em">objets que l'on peut récupérer dans les paramètres de notre composant fonction</span>.</p>
                    <p>On va pousser la logique un peu plus loin afin de véritablement paramétrer notre composant.</p>
                    <h3>Créez des paramètres :</h3>
                    <p>Je vais commencer par <span class="em">préciser une <span class="html">prop</span> pour le type que j'appellerai <span class="html">careType</span> pour mon composant <span class="html">CareScale</span> et réutiliser ce composant</span> entre l'ensoleillement et l'arrosage :</p>
<pre><code>&lt;CareScale careType='water' scaleValue={plant.water} /&gt;
&lt;CareScale careType='light' scaleValue={plant.light} /&gt;</code></pre>
                    <p>Il faut maintenant que j'adapte <span class="html">CareScale</span> pour récupérer le <span class="html">careType</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>À partir de maintenant, je vais utiliser une syntaxe qui nous est permise depuis l'ES6 : la <span class="em">déstructuration</span>. Elle permet directement de déclarer une variable et de lui assigner la valeur d'une propriété d'un objet.</p>
                        <p>Ici on peut donc faire :</p>
<pre><code>const {scaleValue, careType} = props
// On évite de multiplier les déclarations qui sans cette syntaxe auraient été :
// const scaleValue = props.scaleValue et
// const careType = props.careType</code></pre>
                        <p>Cela nous permet de <span class="em">déclarer directement nos deux variables</span> <span class="html">scaleValue</span> et <span class="html">careType</span>, et de <span class="em">les assigner aux valeurs</span> passées en propos. On peut même directement l'écrire dans les paramètres :</p>
<pre><code>function CareScale({scaleValue, careType}) {</code></pre>
                    </div>
                    <p>On peut donc maintenant <span class="em">paramétrer notre composant <span class="html">CareScale</span> pour qu'il puisse gérer les données</span> d'arrosage et les données d'ensoleillement :</p>
<pre><code>function CareScale({ scaleValue, careType }) {
    const range = [1, 2, 3]
    
    const scaleType = careType === 'light' ? '☀️' : '💧'

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt; scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;{scaleType}&lt;/span&gt; : null
            )}
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Comme vous l'avez vu ici, nous avons utilisé <span class="em">deux syntaxes différentes pour nos props</span>. Pour <span class="html">scaleType</span>, nous lui avons assigné une <span class="html">string</span>, entre guillemets. En revanche, pour <span class="em">scaleValue</span>, nous lui avons attribué la valeur d'un objet, que nous avons passée entre accolades.</p>
                    <p>En pratique, une prop peut avoir n'importe quelle valeur possible en JavaScript, mais syntaxiquement, en JSX, on n'a en gros que deux possibilités :</p>
                    <ul>
                        <li>
                            <p>un littéral <span class="html">String</span>, matérialisé par des guillemets;</p>
                        </li>
                        <li>
                            <p>ou, pour toute le reste (booléen, number, expression JavaScript, etc.), des accolades <span class="html">{}</span>.</p>
                        </li>
                    </ul>
                    <h3>Faites descendre les données, des parents vers les enfants :</h3>
                    <p>Les props nous permettent de configurer nos composants. Elles répondent à la logique même de React selon laquelle les données descendent à travers notre arborescence de composants : il s'agit d'<span class="em">un flux de données unidirectionnel</span>.</p>
                    <figure>
                        <img src="../images/composants_parents_enfants_React.png" alt="">
                        <figcaption>Les composants parents partagent leurs données avec leurs enfants.</figcaption>
                    </figure>
                    <p>Comme vous pouvez vous en douter, un composant est le parent du composant défini dans le <span class="html">return()</span>.</p>
                    <p>Dans notre exemple, <span class="html">CareScale</span> est l'enfant, et <span class="html">ShoppingList</span> est le parent.</p>
                    <p>Pour les props, vous devez garder deux règles à l'esprit :</p>
                    <ul>
                        <li>
                            <p>Une prop est toujours <span class="em">passée par un composant parent à son enfant</span> : c'est le seul moyen normal de transmission.</p>
                        </li>
                        <li>
                            <p>Une prop est considérée <span class="em">en lecture seule</span> dans le composant qui la reçoit.</p>
                        </li>
                    </ul>
                    <h3>Découvrez la prop technique children :</h3>
                    <p>Il existe des props qui ont un comportement un peu particulier : nous les appelons les <span class="em">props techniques</span>.</p>
                    <p>La syntaxe de cette prop est particulière, puisqu'elle n'est pas fournie à l'aide d'un attribut, mais en <span class="em">imbriquant des composants</span> à l'intérieur du composant concerné.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant1 /&gt;
    &lt;Enfant2 /&gt;
&lt;/Parent&gt;</code></pre>
                    <p>Par exemple, si on <span class="em">utilise <span class="html">children</span> pour réécrire la Banner</span>, cela nous donnerait dans <span class="html">App.js</span> :</p>
<pre><code>&lt;Banner&gt;
    &lt;img src={logo} alt='La maison jungle' /&gt;
    &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
&lt;/Banner&gt;</code></pre>
                    <p>Ici, <span class="em">img</span> et <span class="em">h1</span> sont les noeuds enfants dans le DOM de <span class="html">Banner</span>.</p>
                    <p>Et on peut <span class="em">accéder à ces noeuds enfants de Banner dans ses paramètres</span>, un peu de la même manière qu'on récupérerait des props :</p>
<pre><code>function Banner({ children }) {
    return &lt;div className='lmj-banner'&gt;{children}&lt;/div&gt;
}</code></pre>
                    <p>Cette manière d'utiliser <span class="html">children</span> et particulièrement <span class="em">utile lorsqu'un composant ne connaît pas ses enfants à l'avance</span>, par exemple pour une barre de navigation (Sidebar) ou bien pour une modale.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les <span class="html">props</span> constituent un aspect clé de React. Mais, en les manipulant, vous verrez qu'il peut être très facile de faire des erreurs. Cela vient notamment de la flexibilité de JavaScript, qui fait du <a href="https://developer.mozilla.org/fr/docs/Glossaire/typage_dynamique" target="_blank">typage dynamique</a> (les types <span class="html">string</span>, <span class="html">int</span>, etc.). Pour vous donner un exemple d'erreur classique :</p>
                        <ul>
                            <li>
                                <p>Vous pouvez passer une prop value à un composant.</p>
                            </li>
                            <li>
                                <p>Vous utilisez une liste de valeurs, certaines valeurs sont des strings, d'autres des nombres.</p>
                            </li>
                            <li>
                                <p>Vous appliquez la méthode <span class="html">.toUpperCase()</span> à votre <span class="html">value</span> : <span class="em">boum</span> !</p>
                            </li>
                        </ul>
                        <p>Une erreur ! <span class="html">.toUpperCase()</span> n'existe pas sur un nombre.</p>
                        <p>Pour éviter ce genre d'erreur, je vous conseille d'être extrêmement rigoureux sur le type de props que vous passez à vos composants.</p>
                    </div>
                    <p>Pour cela, React a créé les <span class="em">PropTypes</span>, qui nous permettent de préciser dès le début le type d'une prop, si elle est requise, et de lui attribuer une valeur par défaut.</p>
                </article>
                <article>
                    <h2 id="maitrise_evenements_React">Maîtrisez les évenements en React :</h2>
                    <p>Si vous avez déjà manipulé du JavaScript, vous êtes sûrement déjà familier avec les événements. Bon, vous avez quand même droit à un petit rappel : un événement est une <span class="em">réaction</span> à une <span class="em">action</span> émise par l'utilisateur, comme le clic sur un bouton ou la saisie d'un texte dans un formulaire.</p>
                    <p>Bonne nouvelle pour vous : avec sa syntaxe pratique et concise, React facilite énormément la gestion des événements du DOM.</p>
                    <h3>Familiarisez-vous avec ka syntaxe :</h3>
                    <p>Quelques caractéristiques de la déclaration d'un événement en React :</p>
                    <ul>
                        <li>
                            <p>l'événement s'écrit dans une balise en <span class="em">camelCase</span>;</p>
                        </li>
                        <li>
                            <p>vous <span class="em">déclarez l'événement</span> à capter, et <span class="em">lui passez entre accolades la fonction</span> à appeler;</p>
                        </li>
                        <li>
                            <p>contrairement au JS, dans la quasi totalité des cas, <span class="em">vous n'avez pas besoin d'utiliser <span class="html">addEventListener</span></span>.</p>
                        </li>
                    </ul>
                    <p>Testons ça dès maintenant dans notre code. Dans <span class="html">components/PlantItem.js</span>, je vais <span class="em">déclarer une finction <span class="html">handleClick</span> qui vient faire un log</span> dans notre console :</p>
<pre><code>function handleClick() {
    console.log('Ceci est un clic')
}</code></pre>
                    <p>On <span class="em">ajoute maintenant <span class="html">onClick={handleClick}</span></span> dans la balise <span class="html">li</span> du composant <span class="html">PlantItem</span>. On a donc :</p>
<pre><code>&lt;li className='lmj-plant-item' onClick={handleClick}&gt;
    &lt;img className='img-plant-item-cover' src={cover} alt={`${name} cover`} /&gt;
    {name}
    &lt;div&gt;
        &lt;CareScale careType='water' scaleValue={water} /&gt;
        &lt;CareScale careType='light' scaleValue={light} /&gt;
    &lt;/div&gt;
&lt;/li&gt;</code></pre>
                    <p>J'ouvre la console et ça fonctionne comme prévu !</p>
                    <p>Je vais pousser cet exercice un peu plus loin : on va déclencher une alerte qui affiche le nom de la plante sur laquelle on a cliqué.</p>
                    <p>On <span class="em">passe donc <span class="html">plantName</span> en paramètre</span> de handleClick comme ici :</p>
<pre><code>function handleClick(plantName) {
    alert(`Vous voulez acheter 1 ${plantName} ? Très bon choix 🌱✨`)
}</code></pre>
                    <p>Mais si je clique, ça ne marche pas :</p>
                    <figure>
                        <img src="../images/plantName_React_1.png" alt="">
                        <figcaption>Aucune de nos plantes ne s'appelle 1 [object Object].</figcaption>
                    </figure>
                    <p>En effet, React passe par défaut un objet (que nous aborderons dans quelques minutes), mais ici, nous voulons lui spécifier notre propre argument.</p>
                    <p>Pour cela, c'est très simple : on <span class="em">déclare une fonction directement dans <span class="html">onClick</span></span> (les fonctions fléchées sont très pratiques pour ça). Cette fonction appellera handleClick en lui passant <span class="html">name</span> en paramètre. Donc on a :</p>
<pre><code>onClick={() =&gt; handleClick(name)}</code></pre>
                    <h3>Découvrez les événements synthétiques :</h3>
                    <p>Donc, je vous parlais de l'objet que React passe par défaut en paramètre aux fonctions indiquées en callback des événements. Voyons voir à quoi ça ressemble.</p>
                    <p>Si je <span class="em">récupère le paramètre dans handleClick</span> :</p>
<pre><code>function handleClick(e) {
    console.log('Cecu est mon event :', e)
}</code></pre>
                    <p>j'obtiens ça :</p>
                    <img src="../images/console_log_React_1.png" alt="">
                    <p>Il s'agit en fait d'un <span class="em">événement synthétique</span>. Pour faire bref, il s'agit de la même interface que pour les événements natifs du DOM, sauf qu'ils sont compatibles avec toues les navigateurs.</p>
                    <p>Pratique, n'est-ce pas ?</p>
                    <p>Vous pouvez utiliser les méthodes <span class="html">preventDefault</span> et <span class="html">stopPropagation</span> avec le paramètre dans la fonction passée à l'événement. Dans notre cas, vous auriez pu faire <span class="html">e.preventDefault()</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous voulez en savoir plus sur les événements synthétiques, vous trouverez <a href="https://fr.reactjs.org/docs/events.html" target="_blank">une liste de tous les événemebrs orus eb charge ici</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="creation_formulaires_React">Simplifiez votre création de formulaires avec React :</h2>
                    <p>En React, la gestion des formulaires est simplifiée : on a accès à la valeur très facilement, qu'il s'agisse d'un input checkbox, d'un textarea, ou encore d'un select avec <span class="html">onChange</span>.</p>
                    <p>Il existe deux grandes manières de gérer les formulaires : <span class="em">la manière contrôlée et la manière non contrôlée</span>. J'aborderai assez rapidement la manière non contrôlée, parce qu'elle nécessite moins d'implication de react, et que React encourage l'utilisation des formulaires contrôlés.</p>
                    <h3>Déléguez le contrôle : les formulaires non contrôlés :</h3>
                    <p>Je vous fais une petite démo d'un formulaire non contrôlé. Sur notre app; directement dans <span class="html">App.js</span>, je mets un composant <span class="html">QuestionForm</span> que je vais déclarer dans un fichier à part. Nous allons ajouter un champ pour une question.</p>
                    <p>Donc pour ça, je <span class="em">crée un form</span>, qui englobe mon input :</p>
<pre><code>&lt;form onSubmit={handleSubmit}&gt;
    &lt;input type='text' name='my_input' defaultValue='Tapez votre texte' /&gt;
    &lt;button type='submit'&gt;Entrer&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    <p>Et <span class="em">pour <span class="html">handleSubmit</span></span>, cela donne :</p>
<pre><code>function handleSubmit(e) {
    e.preventDefault()
    alert(e.target['my_input'].value)
}</code></pre>
                    <p>Vous voyez que React me permet de préciser une <span class="html">defaultValue</span> à mon champ input. Ici, j'appelle <span class="html">preventDefault</span>, sinon le <span class="html">submit</span> rafraîchirait la page.</p>
                    <p>Et j'ai bien mon alerte qui se déclenche.</p>
                    <p>Plutôt simple, n'est-ce pas ? Vous déléguez le travail à votre DOM. Effectivement, les formulaires non contrôlés nous permettent de <span class="em">ne pas avoir à gérer trop d'informations</span>. Mais cette approche est un peu moins "React", parce qu'elle ne permet pas de tout faire.</p>
                    <p>À la place, vous pouvez utiliser les composants contrôlés.</p>
                    <h3>Contrôlez vos formulaires :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, pour vous montrer l'utilisation des formulaires contrôlés, je vais avoir besoin d'une notions que nous aborderons prochainement : le state (état). Donc je vais essayer de vous faire un petit brief sans rentrer dans le détail.</p>
                    </div>
                    <p>Le <span class="em">state local</span> nous permet de <span class="html">garder des informations. Ces informations sont spécifiques à un composant et elles proviennent d'une iteraction</span> que l'utilisateur a eue avec le composant.</p>
                    <p>Donc je vais <span class="em">créer ma variable <span class="html">inputValue</span> et la fonction</span> qui va permettre de changer sa valeur dans le state local avec <span class="html">useState</span>.</p>
                    <p>Sachez juste que la ligne de code ci-dessous me permet de déclarer l'état initial pour <span class="html">inputValue</span> et la fonction correspondante pour la modifier, et de lui préciser la valeur par défaut "Posez votre question ici" :</p>
<pre><code>const [inputValue, setInputValue] = useState("Posez votre question ici")</code></pre>
                    <p>J'ai donc mon <span class="html">QuestionForm</span> comme ci-dessous :</p>
<pre><code>import { useState } from 'react'

function QuestionForm() {
    const [inputValue, setInputValue] = useState('Posez votre question ici')
    return (
        &lt;div&gt;
            &lt;textarea
                value={inputValue}
                onChange={(e) =&gt; setInputValue(e.target.value)}
            /&gt;
        &lt;/div&gt;
    )
}

export default QuestionForm</code></pre>
                    <p>Ici, je passe une fonction en callback à <span class="html">onChange</span> pour qu'elle sauvegarde dans mon state local la valeur de mon input. J'accède à la valeur tapée dans l'input avec <span class="html">e.targer.value</span>.</p>
                    <p><span class="html">inputValue</span> a maintenant accès au contenu de mon input à tout moment. Je peux donc <span class="em">créer un bouton qui déclenche une alerte</span> qui affiche le contenu de mon input, comme ici :</p>
<pre><code>&lt;div&gt;
    &lt;textarea
        value={inputValue}
        onChange={(e) =&gt; setInputValue(e.target.value)}
    /&gt;
    &lt;button onClick={() =&gt; alert(inputValue)}&gt;Alertez moi 🚨&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>Et ça marche bien !</p>
                    <h3>Comprenez les avantages des formulaires contrôlés :</h3>
                    <p>Eh bien, cela permet d'<span class="em">interagir directement avec la donnée renseignée par l'utilisateur</span>. Vous pouvez donc afficher un message d'erreur si la donnée n'est pas valide, ou bien la filtrer en interceptant une mauvaise valeur.</p>
                    <p>Si nous décidons qu'il n'est pas autorisé d'utiliser la lettre "f" (bon oui, c'est un peu bizarre), eh bien nous pouvons déclarer une variable :</p>
<pre><code>const isInputError = inputValue.includes('f')</code></pre>
                    <p>et afficher ou non un message d'erreur en fonction de ce booléen :</p>
<pre><code>{isInputError && (
    &lt;div&gt;🔥 Vous n'avez pas le droit d'utiliser la lettre "f" ici.&lt;/div&gt;
)}</code></pre>
                    <p>De la même manière, nous pouvons intercepter une mauvaise valeur entrée par l'utilisateur. Pour cela, il faut déclarer une fonction intermédiaire :</p>
<pre><code>function checkValue(value) {
    if (!value.includes('f')) {
        setInputValue(value)
    }
}</code></pre>
                    <p>et on aplique la modification dans notre fonction callback :</p>
<pre><code>onChange={(e) =&gt; checkValue(e.target.value)}</code></pre>
                    <p>Ici, vous aure be.au marteler votre touche 'f' autant de fois que vous voudrez, la valeur ne s'inscrira pas dans votre input.</p>
                    <p>Vous ne vous en rendez peut-être pas compte pour l'instant, mais ça vous laisse une très grande liberté quant aux validations que vous voulez créer; et en tant que développeur, c'est vraiment très puissant.</p>
                    <p>Quand utiliser le composant contrôlé et quand utiliser sa version non contrôlée ? Eh bien cela dépen des cas. À vous de voir selon vos contraintes. Quand vous avez un composant rapide à faire, qui n'intègre aucuene complexité, un input non contrôlé peut faire l'affaire. À l'inverse, si vous avez des vérifications à faire, il vaudra sûrement mieux passer par un composant contrôlé. Pour ma part, j'ai vu beaucoup plus de composants contrôlés dans les codebases que j'ai pu voir.</p>
                    <p>Sachez qu'il existe également des bibliothèqyes qui vous permettent de gérer les formulaires et leur validation aussi proprement que possible, par exemple <a href="https://react-hook-form.com/" target="_blank">le très bon outil <span class="html">react-hook-form</span></a>.</p>
                    <p>Et voilà, vous êtes maintenant équipé pour interagir avec vos utilisateurs grâce aux événements et aux formulaires.</p>
                </article>
                <article>
                    <h2 id="stateful_components">Découvrez les stateful components :</h2>
                    <p>Le state local est présent à l'intérieur d'un composant et <span class="em">garde sa valeur, même si l'application le re-render</span>. On peut alors dire qu'il <span class="em">stateful</span>.</p>
                    <p>Dans <span class="html">Cart.js</span>, nous allons uniquement <span class="em">permettre aux utilisateurs d'ajouter des monsteras dans leur panier</span>, supprimons donc tout le reste.</p>
                    <p>Commençons par <span class="em">importer <span class="html">useState</span></span> avec :</p>
<pre><code>import { useState } from 'react'</code></pre>
                    <p>Puis, on peut <span class="em">créer un state <span class="html">cart</span></span>. Avec <span class="html">useState</span>, nous devons déclarer en même temps une fonction pour mettre à jour ce state (<span class="html">updateCart</span>), et lui attribuer une valeur initiale, qui sera ici de 0 :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Je vais maintenant pouvoir <span class="em">ajouter un bouton dans mon panier qui permet d'ajouter un monstera</span> avec la fonction que nous venons de déclarer. Ce qui me donne dans <span class="html">Cart.js</span> :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)

    return (
        &lt;div className='lmj-cart'&gt;
            &lt;h2&gt;Panier&lt;/h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Maintenant, si on clique sur "Ajouter", le montant total est modifié en fonction du nombre d'éléments sauvegardés dans le state du panier. Lorsqu'un state est modifié, alors l'affichage du composant est rafraichit et la valeur affichée est actualisée, on dit que le composant est re-render.</p>
                    <p>Bienvenue dans la magie du state ! Notre composant Cart est maintenant devenu un <span class="em">stateful component</span>, grâce à <span class="html">useState</span>.</p>
                    <p>Concrètement, cela veut dire que le composant Cart peut être re-render autant de fois que nécessaire, mais la valeur du panier sera préservée.</p>
                </article>
                <article>
                    <h2 id="useState">Familiarisez-vous avec useState :</h2>
                    <p><span class="html">useState</span> est un hook qui permet d'ajouter le state local React à des composants fonctions.</p>
                    <p>Un hook est <span class="em">une fonction qui permet de "se brancher" (to hook up) sur des fonctionnalités React</span>. On peut d'ailleurs les importer directement depuis React. Après useState, nous verrons un autre hook : <span class="html">useEffect</span>. Il existe d'autres hooks.</p>
                    <p>Nous l'avons déjà utilisé, mais je vous le remets ici :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Investiguons comment est construit notre state cart.</p>
                    <h3>Comprenez les crochets :</h3>
                    <p>Tout d'abord, les crochets <span class="html">[]</span>. Si cette syntaxe peut vous paraître un peu particulière, il s'agit en fait de la même pratique que nous avions vue précédemment : la déstructuration. Sauf qu'ici, ça s'appelle la <span class="em">décomposition</span> parce qu'il s'agit d'un <span class="em">tableau</span> et non d'un objet.</p>
                    <p><span class="html">useState</span> nous <span class="em">renvoie une paire de valeurs dans un tableau de 2 éléments</span>, que nous récupérons dans les variables <span class="em">cart</span> et <span class="em">updateCart</span> dans notre exemple. Le premier élément est la valeur actuelle, et le deuxième est une fonction qui permet de la modifier.</p>
                    <p>Sans la décomposition, nous aurions aussi pu faire :</p>
<pre><code>const cartState = useState(0)
const cart = cartState[0]
const updateCart = cartState[1]</code></pre>
                    <p>Dans un tableau qu'on décompose, nous pouvons librement nommer nos variables. J'aurais tout aussi bien pu faire :</p>
<pre><code>const [coucou, cavabien] = useState(0)</code></pre>
                    <h3>Initialisez votre state :</h3>
                    <p>Intéressons-nous maintenant au paramètre passé entre parenthèses à <span class="em">useState</span> : <span class="html">useState(0)</span>.</p>
                    <p>Comme je vous l'ai dit, il correspond à l'<span class="em">état initial de notre state</span>. Cet état initial peut être un nombre comme ici, une string, un booléen, un tableau ou encore un objet avec plusieurs propriétés.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Il est important de préciser une valeur initiale dans votre state. Sinon, elle sera <span class="em">undefined</span> par défaut, et ce n'est pas un comportement souhaitable : plus vous serez explicite, mieux votre application s'en portera !</p>
                    </div>
                    <h3>Créez plusieurs variables d'état :</h3>
                    <p>Nous allons encore améliorer notre panier. Cette fois-ci, je veux pouvoir <span class="em">choisir de l'afficher ou de le cacher</span>. Pour ça, nous allons utiliser une variable d'état dans notre composant Cart.</p>
                    <p>S'il y en a déjà une, comment en créer une autre ? Pas de panique. Il y a plusieurs moyens de faire. Mais le plus simple est d'utiliser plusieurs variables d'état.</p>
                    <p>Dans notre cas, il suffit de <span class="em">créer une variable <span class="html">isOpen</span> associée avec la fonction <span class="html">setIsOpen</span></span>, et de l'initialiser à false :</p>
<pre><code>const [isOpen, setIsOpen] = useState(false)</code></pre>
                    <p>Pour pouvoir interagir, on crée ensuite :</p>
                    <ul>
                        <li>
                            <p><span class="em">un bouton pour ouvrir</span> le panier qui sera le seul composant retourné par Cart si le panier est fermé;</p>
                        </li>
                        <li>
                            <p>et <span class="em">un bouton pour fermer</span> le panier.</p>
                        </li>
                    </ul>
                    <p>Cela nous donne le code suivant :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)
    const [isOpen, setIsOpen] = useState(false)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button onClick={() =&gt; setIsOpen(false)}&gt;Fermer&lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() => updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    ) : (
        &lt;button onClick={() =&gt; setIsOpen(true)}&gt;Ouvrir le Panier&lt;/button&gt;
    )
}

export default Cart</code></pre>
                    <p>En ajoutant un peu de style, j'ai donc :</p>
                    <figure>
                        <img src="../images/panier_lmj_React.jpg" alt="">
                        <figcaption>Le panier du site de la maison jungle</figcaption>
                    </figure>
                    <p>Vous voyez ? Pas de soucis à créer plusieurs variables d'état dans un même composant !</p>
                    <p>C'est bien beau, nous avons nos composants avec leur state local. Notre panier permet d'ajouter des monsteras, et le total du panier se calcule en fonction.</p>
                    <p>Mais comment faire pour <span class="em">changer le comportement d'un composant en fonction du state d'un autre composant</span> ? Par exemple, si je veux enfin ajouter un lien entre mon <span class="em">Cart</span> et mon composant <span class="em">ShoppingList</span>. Je peux créer un bouton "Ajouter au panier" dans chaque <span class="em">PlantItem</span>... Mais comment faire pour venir compléter mon panier en fonction ?</p>
                </article>
                <article>
                    <h2 id="remonter_etat_maj_composants_enfants">Faites remonter l'état et mettez-le à jour depuis vos composants enfants :</h2>
                    <p>Comme son nom l'indique, un state local... est local. Ni les parents, ni les enfants ne peuvent manipuler le state local d'un composant (ils n'en ont pas la possibilité technique).</p>
                    <p>Pour partager un élément d'état entre plusieurs composants, il faudra <span class="em">faire remonter ces données</span> vers le state local du <span class="em">plus proche composant qui est un parent commun</span>, et y garder le state. À partir de là, il sera possible de :</p>
                    <ul>
                        <li>
                            <p>Faire <span class="em">redescendre</span> ces infos avec des props jusqu'aux composants qui en ont besoin.</p>
                        </li>
                        <li>
                            <p>Faire <span class="em">"remonter" les demandes d'update</span> toujours dans les props. Pour cela, on peut utiliser la fonction de mise à jour du state récupérée dans useState, en la passant en props aux composants qui en ont besoin.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/remonter_maj_parents_props_React.png" alt="">
                        <figcaption>Remonter les mises à jour aux parents dans les props</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous vous demandez peut-être quelles sont les bonnes pratiques : où mettre le state ? Dans le composant parent, ou le composant enfant ? Eh bien, dans la pratique... ça dépend totalement. Il est considéré comme plus propre de garder la logique au maximum dans les composants parents, et que les enfants ne servent qu'à afficher les éléments en props. Mais dans de nombreux cas, il est bien mieux de garder le state dans le composant enfant. Vous apprendrez à le voir avec le temps et l'expérience.</p>
                    </div>
                    <p>Attaquons-nous donc à notre exemple.</p>
                    <p>Je commence à <span class="em">faire remonter <span class="html">cart</span> dans <span class="html">App.js</span></span> :</p>
<pre><code>function App() {
    const [cart, updateCart]  useState(0)

    return (
        &lt;div&gt;
            &lt;Banner&gt;
                &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
                &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
            &lt;/Banner&gt;
            &lt;div className='lmj-layout-inner'&gt;
                &lt;Cart cart={cart} updateCart={updateCart} /&gt;
                &lt;ShoppingList cart={cart} updateCart={updateCart} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}

export default App</code></pre>
                    <p>Et toujours dans <span class="html">App.js</span> dans le JSX, je <span class="em">passe <span class="html">cart</span> ainsi que <span class="html">updateCart</span> en props</span> :</p>
<pre><code>&lt;Cart cart={cart} updateCart={updateCart} /&gt;</code></pre>
                    <p>... <span class="em">que je récupère dans <span class="html">Cart.js</span></span>. Vous vous souvenez de la déstructuration ? Ça nous permet de récupérer notre prop en une ligne.</p>
                    <p>J'en profite pour supprimer mon bouton "Ajouter" dans <span class="html">Cart.js</span>.</p>
                    <p>On a donc un panier un peu vide :</p>
<pre><code>function Cart({ cart, updateCart }) {
    const monsteraPrice = 8
    const [isOpen, setIsOpen] = useState(true)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(false)}
            &gt;
                Fermer
            &lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
            &lt;button onClick={() =&gt;updateCart(0)}&gt;Vider le panier&lt;/button&gt;
        &lt;/div&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Du côté de <span class="html">ShoppingList</span>, je <span class="em">lui passe <span class="html">updateCart</span></span>. Je <span class="em">le récupère ensuite dans <span class="html">ShoppingList.js</span></span>.</p>
                    <p>Je <span class="em">change ensuite ma liste de plantes</span> pour avoir (toujours dans <span class="html">ShoppingList.js</span>) :</p>
<pre><code>function ShoppingList({ cart, updateCart }) {
    // Petite précision : categories permet de récupérer toutes les catégories uniques de plantes.

    const categories = plantList.renduce(
        (acc, elem) =&gt;
            acc.includes(elem.category) ? acc : acc.concat(elem.category),
            []
    )

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Et voilà ! Maintenant, vous pouvez updater votre panier directement en cliquant sur un bouton lié à chaque plante.</p>
                    <p>Vous voyez, ce n'est pas si compliqué, il a suffit de :</p>
                    <ul>
                        <li>
                            <p>faire remonter notre state;</p>
                        </li>
                        <li>
                            <p>faire descendre le contenu de notre state et la fonction pour l'updater;</p>
                        </li>
                        <li>
                            <p>déclencher la mise à jour de notre state avec une interaction utilisateur (ici le clic sur le bouton).</p>
                        </li>
                    </ul>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous sommes sur une petite application : il n'y a qu'une seule page et nous partageons le state directement entre parents et enfants. Mais ça peut vite devenir le bazar pour une plus grosse application. C'est pourquoi la notion de state management va beaucoup plus loin. Il existe des outils dédiés au State Management tels que Flux, Redux ou des solutions natives comme React Context.</p>
                    </div>
                    <p>Nous avons vu comment partager des éléments du state entre plusieurs composants. Nous allons maintenant adapter notre application pour que le panier se comporte de manière un peu plus réaliste.</p>
                    <p>L'idée ici est que <span class="em">notre state stocke quels types</span> de plantes ont été ajoutés, <span class="em">en quelle quantité</span>, et <span class="em">de mettre à jour le montnat total</span> en fonction du prix.</p>
                    <p>Première étape : ajouter le prix à chaque plante dans le fichier <span class="em">plantList.js</span>.</p>
                    <p>Dans le fichier <span class="em">App.js</span>, on modifie le state <span class="em">cart</span> pour que ce soit un tableau comme ceci :</p>
<pre><code>const [cart, updateCart] = useState([])</code></pre>
                    <p>Troisième étape : on modifie le fichier <span class="em">Cart.js</span> pour itérer sur les <span class="em">cart</span> comme ceci :</p>
<pre><code>import { useState } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )
    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        &lt;h2&gt;Panier&lt;/h2&gt;
        {cart.map(({ name, price, amount}, index) =&gt; (
            &lt;div key={`${name}-${index}`}&gt;
                {name} {price}€ x {amount}
            &lt;/div&gt;
        ))}

        &lt;h3&gt;Total : {total}€&lt;/h3&gt;
        &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Enfin, dernière étape : on fait une modification dans le fichier <span class="em">ShoppingList.js</span> pour ajouter la fonction <span class="html">addToCart(...)</span> comme ci-dessous :</p>
<pre><code>import '../styles/ShoppingList.css'

function ShoppingList({ cart, updateCart }) {
    
    const categories = plantList.renduce(
        (acc, plant) =&gt;
            acc.includes(plant.category) ? acc : acc.concat(plant.category),
            []
    )

    function addToCart(name, price) {
        const currentPlantAdded = cart.find((plant) =&gt; plant.name === name)
        if (currentPlantAdded) {
            const cartFilteredCurrentPlant = cart.filter(
                (plant) =&gt; plant.name !== name
            )
            updateCart([
                ...cartFilteredCurrentPlant = cart.filter(
                    (plant) =&gt; plant.name !== name
                )
                updateCart([
                    ...cartFilteredCurrentPlant,
                    { name, price, amount: currentPlantAdded.amount + 1 }
                ])
            ])
        } else {
            updateCart([...cart, { name, price, amount: 1 }])
        }
    }

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; addToCart(name, price)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Notre panier fait maintenant une liste des articles sélectionnés, et met à jour le total en fonction des plantes sélectionnées et de leur prix.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Est-ce que vous avez remarqué que lorsqu'on change le state, on crée un nouvel objet avec le spread operator ? C'est normal : le state est immutable, c'est-à-dire qu'il ne faut pas le modifier directement.</p>
                    </div>
                </article>
                <article>
                    <h2 id="useEffect">Déclenchez des effets avec useEffect :</h2>
                    <p>Est-ce que je vous ai déjà parlé du render (rendu) d'une application React ?</p>
                    <p>Dès qu'une modification intervient dans une prop ou le state, le composant concerné et ses enfants sont re-render.</p>
                    <p>Mais comment faire si on on veut effectuer une action qui ne fait pas partie du return ? Qui intervient après que React a mis à jour le DOM ? Par exemple, si vous voulez déclencher une alerte à chaque fois que votre panier est mis à jour ? Ou bien même pour sauvegarder ce panier à chaque mise à jour ?</p>
                    <p>Eh bien, ces types d'actions s'appellent des effets de bord, et pour cela, nous avons <span class="html">useEffect</span>. Ils nous permettent d'effectuer une action à un moment donné du cycle de vie de nos composants.</p>
                    <p>Disons que je veux <span class="em">créer une alert lorsque j'ajoute une plante à mon panier</span>, et que cette alerte <span class="em">affiche le montant total du panier</span>.</p>
                    <p>Pour ça, une petite ligne de code suffit dans <span class="em">Cart.js</span> :</p>
<pre><code>alert(`J'aurai ${total}€ à payer`)</code></pre>
                    <p>On la met donc directement dans notre composant, avant le <span class="em">return</span>. Mais, quand je clique, ça bloque mon code et ma valeur ne s'affiche qu'une fois que j'ai cliqué sur "OK" !</p>
                    <p>À la place, on va utiliser <span class="html">useEffect</span>.</p>
                    <p><span class="em">Importez-le</span> comme nous l'avons fait avec <span class="html">useState</span> dans <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'</code></pre>
                    <p>et <span class="em">utilisez ce snippet à la place</span> (toujours dans <span class="em">Cart.js</span>) :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
})</code></pre>
                    <p>Ce qui nous donne pour <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )

    useEffect(() =&gt; {
        alert(`J'aurai ${total}€ à payer`)
    })

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        {cart.length &gt; 0 ? (
            &lt;h2&gt;Panier&lt;/h2&gt;
            {cart.map(({ name, price, amount}, index) =&gt; (
                &lt;div key={`${name}-${index}`}&gt;
                    {name} {price}€ x {amount}
                &lt;/div&gt;
            ))}

            &lt;h3&gt;Total : {total}€&lt;/h3&gt;
            &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;            
        ) : (
            &lt;div&gt;Votre panier est vide&lt;/div&gt;
        )}
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Et voilà ! Tout se passe comme espéré, pour la simple et bonne raison que <span class="html">useEffect</span> nous permet d'<span class="em">effectuer notre effet une fois le rendu du composant terminé</span>. Et comme <span class="html">useEffect</span> est directement dans notre composant, nous avons directeemnt accès à notre state, à nos variables, nos props, magique n'est-ce pas ?</p>
                    <p>Quand je ferme mon, mon alerte se déclenche aussi ! Eh bien c'est normal : je vous ai dit que <span class="html">useEffect</span> se déclenche après le rendu. Eh bien il se déclenche après <span class="em">CHAQUE</span> rendu du composant. Sauf si vous...</p>
                    <h3>Précisez quand déclencher une effect avec le tableau de dépendances :</h3>
                    <p>Pour décider précisément quand on veut déclencher un effet, on peut utoliser le tableau de dépendances. Il correspond au deuxième paramètre passé à <span class="html">useEffect</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Petit rappel : le premier paramètre passé à useEffect est une fonction.</p>
                    </div>
                    <p>Cette fonction correspond à l'<span class="em">effet à exécuter</span>. Ici, il s'agit de :</p>
<pre><code>() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}</code></pre>
                    <p>Le deuxième paramètre de <span class="html">useEffect</span> accepte <span class="em">un tableau noté entre crochets</span> : il s'agit du tableau de dépendances.</p>
                    <p>Dans notrre cas, si je veux que l'<span class="em">alerte ne s'affiche que lorsque le total de mon panier change</span>, il me suffit de faire :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}, [total])</code></pre>
                    <p>Vous pouvez mettre n'imprte quelle variable ici. Si vous voulez afficher l'alerte quand le total change OU quand une nouvelle catégorie est sélectionnée, vous pourriez tout à fait :</p>
                    <ul>
                        <li>
                            <p>récupérer la catégorie sélectionnée (en faisant remonter <span class="html">activeCategory</span> et <span class="html">setActiveCategory</span> et en les passant en props);</p>
                        </li>
                        <li>
                            <p>puis mettre <span class="html">[total, activeCategory]</span> dans votre tableau de dépendances.</p>
                        </li>
                    </ul>
                    <p>L'alerte s'affiche bien quand la catégorie change ou bien quand le total change.</p>
                    <p>Est-ce que l'effet est lancé au tout premier render de mon composant ? Oui, l'alerte s'affiche.</p>
                    <p>Comment faire pour exécuter un effet uniquement après le premier render de mon composant ? Par exemple, si je veux récupérer des données sur une API ? Eh bien, dans ce cas, il faut <span class="em">renseigner un tableau de dépendances vide</span> :</p>
<pre><code>useEffect(() =&gt; {
    alert('Bienvenue dans La maison jungle')
}, [])</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>À partir du moment où vous utilisez le tableau de dépendances, faites attention à ne pas ouvlier des dépendances, ou bien à ne pas en laisser qui n'ont plus rien à y faire, pour éviter d'exécuter à des moments inopportuns.</p>
                    </div>
                    <h3>Modifiez le titre de votre onglet :</h3>
                    <p>Bon, moi je commence à en avoir un peu marre de toutes ces alertes. J'ai plutôt envie d'utiliser <span class="html">useEffect</span> pour <span class="em">mettre à jour le titre de l'onglet de mon navigateur</span>.</p>
                    <img src="../images/titre_onglet_React_1.png" alt="">
                    <p>Vous voyez de quoi je parle ?</p>
                    <p>On va donc <span class="em">utiliser <span class="html">document.title</span></span> toujours dans <span class="em">Cart.js</span>, comme ici :</p>
<pre><code>useEffect(() =&gt; {
    document.title = `LMJ : ${total}€ d'achats`
}, [total])</code></pre>
                    <p>Et voilà ! Le litre de notre onglet change en fonction du total de notre panier !</p>
                    <figure>
                        <img src="../images/titre_onglet_React_2.png" alt="">
                        <figcaption>useEffect modifie le titre de notre onglet pour la maison jungle.</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="regles_useEffect">Maîtrisez les règles de useEffect :</h2>
                    <h3>Intégrez les différentes étapes de useEffect :</h3>
                    <p>Repassons sur ce qu'on vient de voir de useEffect :</p>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche à chaque rendu`)
})</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche au premier rendu`)
}, [])</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche la première fois et quand mon panier est mis à jour`)
}, [cart])</code></pre>
                    <p>Il est pssoble d'effectier une action quand React démonte le composant en le retirant du DOM. Dans notre <span class="em">App.js</span>, on rajoute le state :</p>
<pre><code>const [isFooterShown, updateIsFooterShown] = useState(true)

{isFooterShown && &lt;Footer cart={cart} /&gt;}</code></pre>
                    <p>Ensuite, dans notre <span class="em">Footer.js</span>, on utilise le <span class="html">useEffect</span> suivant :</p>
<pre><code>useEffect(() =&gt; {
    return () =&gt;
        console.log(`Cette alerte s'affiche quand Footer est retiré du DOM`)
})</code></pre>
                    <p>Cela nous permet d'effectuer un "nettoyage" de notre effet. En effet, il est indispensable de nettoyer certains effets au <span class="em">unmount</span> (démontage) d'un composant pour éviter les fuites de mémoire, typiquement si on utilise <span class="html">setInterval</span>. Nous n'aurons pas besoin de tels effets pour le moment.</p>
                    <h3>Intégrez quelques règles :</h3>
                    <p>Comme je vous l'ai expliqué précédemment, <span class="html">useEffect</span> est un <span class="em">hook</span>, une fonction qui permet de "se brancher" sur la fonctionnalité des effets de React. Mais quelques règles s'appliquent au hook <span class="html">useEffect</span> :</p>
                    <ul>
                        <li>
                            <p>Appelez toujours <span class="html">useEffect</span> à la <span class="em">racine de votre composant</span>. Vous ne pouvez pas l'appeler à l'intérieur de boucles, de code conditionnel ou de fonctions imbriquées. Ainsi, vous vous assurez d'éviter des erreurs involontaires.</p>
                        </li>
                        <li>
                            <p>Comme pour <span class="html">useState</span>, <span class="html">useEffect</span> est uniquement accessible dans un <span class="em">composant fonction React</span>. Donc ce n'est pas possible de l'utiliser dans un composant classe, ou dans une simple fonction JavaScript.</p>
                        </li>
                    </ul>
                    <p>Par ailleurs, je vous conseille de séparer les différentes actions effectuées dans différents useEffect. Cela est plutôt une bonne pratique qu'une règle.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les hooks sont assez récents. Les développeurs React y ont accès depuis début 2019. Avant, il n'était pas possible d'accéder au state ni aux effets depuis des composants fonctions. Si on voulait utiliser un effet de bord ou l'état local; il fallait forcément passer par un <span class="em">class component</span>. Vous pouvez vous estimer heureux d'avoir accès aux hooks dès le début de votre apprentissage de React, car ils représentent plusieurs avanatages pour les développeurs et développeuses :</p>
                        <ul>
                            <li>
                                <p>ils nécessitent d'écire moins de code;</p>
                            </li>
                            <li>
                                <p>ils sont donc plus faciles à tester;</p>
                            </li>
                            <li>
                                <p>mais également plus lisibles.</p>
                            </li>
                        </ul>
                    </div>
                </article>
                <article>
                    <h2 id="creation_application_React_complete">Créez une application React complète :</h2>
                    <h3>Installez votre app avec Create React App :</h3>
                    <p>Pour initialiser notre application, nous allons utiliser Create React App (CRA).</p>
                    <p>Dans votre terminal, placez-vous dans le dossier où vous souhaitez créer votre projet et faites la commande suivante :</p>
<pre><code>npx create-react-app shiny-agency</code></pre>
                    <h3>Architecturez votre projet par modules :</h3>
                    <p>Maintenant que nous avons la base de notre projet, nous allons pouvoir nous décider sur son architure.</p>
                    <p>Pas de panique ! Ici, je ne vais pas vous parler de patterns complexes. L'idée est juste de suivre des règles logiques et suffisamment claires pour que vous sachiez où placer les fichiers que vous créez, et où retrouver ceux dont vous avez besoin dans votre codebase. D'ailleurs, dans la documentation React <a href="https://fr.reactjs.org/docs/faq-structure.html" target="_blank">sur la structure de fichiers</a>, React laisse la liberté aux développeurs quant à la structure de leur projet.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Lorsque vous utilisez des frameworks tels que <a href="https://nextjs.org/" target="_blank">Next</a> ou <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a> une structure de fichiers toute faite vous sera déjà proposée. je vous conseille d'y jeter un oeil si vous avez l'occassion !</p>
                        <p>Précédemment, nous avions organisé le code de sorte à regrouper les fichiers par type : chaque fiche correspondait à un composant situé dans le dossier <span class="html">/components</span>. Les fichiers CSS, quant à eux, se trouvaient dans le dossier <span class="html">/style</span>, etc.</p>
                        <p>Ici, nous allons organiser nos fichiers en suivant la même logique, sauf qu'il faudra ajouter un dossier pour les "pages", qui regroupera les composants vers lesquels chacune de nos routes renverra (pas de panique si vous ne savez pas ce qu'est une route).</p>
                        <p><span class="em">Commençons</span> donc par créer un dossier <span class="html">/components</span> et un dossier <span class="html">pages</span> dans <span class="html">src</span>. Dans <span class="html">/pages</span>, on créé un dossier <span class="html">Home</span> et l'on y insère <span class="html">App.js</span>, qu'on renomme en <span class="html">index.jsx</span>. On peut ensuite supprimer tous les fichiers que nous n'utiliserons pas.</p>
                        <p>Ce qui nous donne...</p>
<pre><code>├── README.md
├── node_modules
...
├── package.json
├── public
...
├── src
│   ├── index.js
│   ├── components
│   └── pages
│       └── Home
│            └── index.jsx 
└── yarn.lock</code></pre>
                        <p>Ici, pas d'obligation d'utiliser l'extension <span class="html">.jsx</span>. Votre fichier React fonctionnera très bien aussi avec une extension <span class="html">.js</span>, mais puisqu'on peut l'utiliser, autant être explicite, n'est-ce pas ? Ainsi, vous voyez en un coup d'oeil quand votre fichier du React, et quand il n'en contient pas.</p>
                        <p>Ce qui est important pour nous est de pouvoir retrouver rapidement nos fichiers.</p>
                    </div>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>