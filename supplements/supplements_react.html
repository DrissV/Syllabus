<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>React - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#transmation_HTML_React">Transformation d'un simple fichier HTML en app React</a></li>
                        <li><a href="#premier_composant">Création du premier composant</a></li>
                        <li><a href="#initialisation_JSX">Initialisation au JSX</a></li>
                        <li><a href="#Create_React_App">Create React App</a></li>
                        <li><a href="#organisation_code">Organisation du code</a></li>
                        <li><a href="#stylisation_app">Stylisation de l'application</a></li>
                        <li><a href="#decouverte_attribut_style">Découverte de l'attribut style</a></li>
                        <li><a href="#utilisation_images">Utilisation des images</a></li>
                        <li><a href="#iteration_contenu">Itération sur le contenu</a></li>
                        <li><a href="#contextualisation_contenu_composants">Contextualisation du contenu des composants</a></li>
                        <li><a href="#familiarisation_props">Familirisation avec les props</a></li>
                        <li><a href="#maitrise_evenements_React">Maîtrise des événements en React</a></li>
                        <li><a href="#creation_formulaires_React">Création de formulaires avec React</a></li>
                        <li><a href="#stateful_components">Les stateful components</a></li>
                        <li><a href="#useState">useState</a></li>
                        <li><a href="#remonter_etat_maj_composants_enfants">Remonter l'état et le mettre à jour depuis les composants enfants</a></li>
                        <li><a href="#useEffect">useEffect</a></li>
                        <li><a href="#regles_useEffect">Les règles de useEffect</a></li>
                        <li><a href="#creation_application_React_complete">Création d'une application React complète</a></li>
                        <li><a href="#SPA">Single Page Application</a></li>
                        <li><a href="#react_router">React Router</a></li>
                        <li><a href="#navigation_Link">Navigation avec les Link</a></li>
                        <li><a href="#Outlets_pages">Utilisation des Outlets pour afficher certaines parties de la page</a></li>
                        <li><a href="#recuperation_parametres_URL">Récupération des paramètres dans l'URL</a></li>
                        <li><a href="#route_404">Route 404</a></li>
                        <li><a href="#PropTypes">Les PropTypes</a></li>
                        <li><a href="#styled_components">Styled components</a></li>
                        <li><a href="#useState_useEffect_calls_API">useState et useEffect pour effectuer des calls API</a></li>
                        <li><a href="#useContext">useContext</a></li>
                        <li><a href="#hooks">Hooks</a></li>
                        <li><a href="#tests_React_Jest">Tests dans React avec Jest</a></li>
                        <li><a href="#React_Testing_Library">React Testing Library</a></li>
                        <li><a href="#anciennes_syntaxes_React">Anciennes syntaxes de React</a></li>
                        <li><a href="#API_composant_classe">Affichage de données d'API dans un composant classe</a></li>
                        <li><a href="#state_management">State management</a></li>
                        <li><a href="changements_state_Flux">Changements de state via Flux</a></li>
                        <li><a href="#modification_valeurs_state_Reducers">Modification des valeurs du state avec les Reducers</a></li>
                        <li><a href="#Redux">Redux</a></li>
                        <li><a href="#Redux_React">Redux dans React</a></li>
                        <li><a href="#partage_state_composants">Partage du state entre composants</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>React :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Vous avez sûrement déjà entendu parler de React.</p>
                    <p>Utilisée par les entreprises géantes de la Tech comme Facebook, X ou Netflix, il s'agit de l'une des bibliothèques JavaScript les plus populaires pour construire des interfaces web. Son approche par composants réutilisables en fait un outil particulièrement modulaire pour développer vos applications.</p>
                    <p>Lorsqu'on parle de frameworks JavaScript, les noms de React, Vue.js et Angular ne sont jamais bien loin. Et il en existe d'autres (Ember, Meteor, Backbone...). Chacun a ses spécificités, ses avantages et ses inconvénients.</p>
                    <p>React est un projet open-source, distribué sous la licence MIT et piloté par Facebook. Leurs produits web et mobile tels que Facebook, Messenger, Instagram, reposent en grande partie sur cette technologie. Comme React est open-source, vous pouvez accéder au code source <a href="https://github.com/facebook/react" target="_blank">directement sur GitHub</a>, proposer une feature, ou même notifier d'un problème (issue).</p>
                    <p>L'ambition de React est de <span class="em">créer des interfaces utilisateurs</span>, avec un outil <span class="em">rapide</span> et <span class="em">modulaire</span>. L'idée principale derrière React est que vous vous construisez votre application à partir de composants. <span class="em">Un composant regroupe à la fois le HTML, le JS et le CSS</span>, créés sur mesure pour vos besoins, et que vous poubez <span class="em">réutiliser</span> pour construire des interfaces utilisateurs.</p>
                    <p><a href="https://fr.reactjs.org/docs/getting-started.html" target="_blank">Sur sa documentation</a>, React se présente comme "une bibliothèque JavaScript pour créer des interfaces utilisateurs." Pourtant, depuis tout à l'heure je vous parle de framework. En fait, <span class="em">la frontière entre framework et bibliothèque reste assez fine</span>, surtout dans le cas de React; et il n'est pas simple de séparer parfaitement l'un de l'autre.</p>
                    <p>Pour faire simple, vous pouvez vous dire qu'un <span class="em">framework</span> est un ensemble d'outils ultra complets permettant de <span class="em">créer une application de A à Z</span> et fournissant les outils nécessaires au développement d'une application. Alors qu'une <span class="em">bibliothèque s'ajoute à une partie</span> de votre application.</p>
                    <figure>
                        <img src="../images/framework_bibliotheque_React.png" alt="">
                        <figcaption>Les bibliothèques et les frameworks interagissent différemment avec le code.</figcaption>
                    </figure>
                    <p>Angular, par exemple, qui permet de créer une solution complète où tous les outils sont déjà fournis, comme une solution dédiée au routing ou bien aux appels API, est un framework, pour lequel on attend de vous de respecter une certaine architure.</p>
                    <p>En revanche, avec une bibliothèque, tout est beaucoup plus flexible. La bibliothèqyes vous fournit un ensemble de ressources que vous poubez combiner avec d'autres bibliothèques pour construire votre application.</p>
                    <p>À proprement parler, React... est une bibliothèqye. Mais son écosystème est tellement développé maintenant qu'on peut aussi bien le considérer comme un framexork à part entière.</p>
                    <p>Je vous parlais plus tôt des avanatages/inconvénients de chaque framework. Sans même rentrer dans l'aspect technique, voici quelques-uns des atouts de React :</p>
                    <dl>
                        <dt>Sa communauté :</dt>
                        <dd>Particulièrement active, elle vous facilite la vie. Lorsque vous cherchez votre problème sur Internet, il est quasiment impossible que personne n'ait déjà rencontré le même problème que vous. D'autant plus que React compte de très grosses entreprises parmi ses utilisateurs (Netflix, Twitter, Paypal, Airbnb pour n'en citer que quelques-unes). Vous pouvez être sûr qu'un autre ingéneirur s'est déjà trouvé confronté à votre problème. Par exemple, lorsque vous trouvez une question posée sur <a href="https://stackoverflow.com/" target="_blank">Stack Overflow</a> (en anglais). L'équipe de React répond également aux issues (problèmes) <a href="https://github.com/facebook/react/issues" target="_blank">sur le repository GitHub de React</a> (en anglais). Mais il existe un nombre de newsletters, blogs, chaînes YouTube, créées par des utilisateurs - leur dynamique vous donne toujours envie de tester de nouveaux outils.</dd>
                        <dt>Sa documentation :</dt>
                        <dd>La <a href="https://fr.reactjs.org/" target="_blank">documentation de React</a> est riche, régulièrement mise à jour et intégralement traduite en français.</dd>
                        <dt>Ses opportunités professionnelles :</dt>
                        <dd>Comme il s'agit d'un des frameworks les plus populaires, les opportunités professionnelles sont particulièrement nombreuses. Dans <a href="https://2022.stateofjs.com/fr-FR/libraries/front-end-frameworks/" target="_blank">l'enquête annuelle State of JS de 2022</a>, 100% des personnes déclaraient connaître React, et sur 33338 sondés, 27289 déclaraient utiliser React (qui a d'ailleurs <a href="https://2019.stateofjs.com/awards/" target="_blank">gagné l"Award 2019</a> de la technologie la plus utilisée).</dd>
                    </dl>
                </article>
                <article>
                    <h2 id="transformation_HTML_React">Transformez un simple fichier HTML en app React :</h2>
                    <p>Nous allons maintenant <span class="em">transformer un fichier HTML en app React</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode que je vous montre ici n'est pas une méthode utilisée dans le monde du travail. Il s'agit d'un moyen de vous montrer les bases sans aoir à faire trop de paramétrage, et sans avoir à utiliser trop d'outils tels que Webpack. Ici, nous pouvons nous concentrer sur l'essentiel.</p>
                    </div>
                    <p>Nous allons utiliser des liens CDN (Content Deklivery Network) pour ajouter React à un fichier HTML.</p>
                    <p>On oublie pas d'aller chercher le lien CDN de Babel et on rajoute une autre balise &lt;script&gt; :</p>
<pre><code>&lt;div id="root"&gt;Bonjour&lt;/div&gt;
&lt;script type="text/babel"&gt;
    ReactDom.render(&lt;div&gt;Mon élément remplace le contenu précédent&lt;/div&gt;,
                    document.getElementById('root')
                   )
&lt;/script&gt;</code></pre>
                </article>
                <article>
                    <h2 id="premier_composant">Créez votre premier composant :</h2>
                    <p>Écrivons maintenant <span class="em">notre premier composant</span>.</p>
                    <p>Ici, je vais utiliser des composants qu'on appelle <span class="em">functional components</span> (composants fonction), c'est-à-dire une fonction qui retourne un élément React. Commençons avec cette <span class="em">prem!re fonction</span>, MyComponent :</p>
<pre><code>function MyComponent() {
    return (&lt;div&gt;Hello World !&lt;/div&gt;)
}</code></pre>
                    <p>En copiant ce code dans la partie JS, rien ne se passe. Pas de panique ! C'est normal : il vous reste encore à attacher votre composant React à votre HTML.</p>
                    <p>On va dès maintenant <span class="em">utiliser ReactDOM pour s'atatcher à notre HTML</span>.</p>
                    <p>Dans le code ci-dessous, l'id <span class="em">root</span> permet de préciser où notre app React va vivre dans notre HTML. Ensuite, on va ordonner à ReactDOM de générer (<span class="em">render</span>) notre composant React qui s'appelle MyComponent.</p>
<pre><code>ReactDOM.render(&lt;,MyComponent /&gt;, document.getElementById('root'))</code></pre>
                    <p>Et tadaaa ! Notre composant s'affiche !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe différentes manières de créer des composants en React. Il y a peu de temps encore, la manière la plus utilisée était d'utiliser des composants classes, avec la syntaxe :</p>
<pre><code>class MyComponent extends React.Component</code></pre>
                        <p>Cette manière était la seule pour utiliser des fonctionnalités qui sont au coeur de React. Mais depuis la mise à jour de React 16.8 en 2019, les composants fonctions permettent aussi de gérer tout ça.</p>
                    </div>
                    <p class="em">Les composants sont essentiels dans React.</p>
                    <p>Une interface est toujours constituée de différents éléments : des boutons, des listes, des titres, des sous-tritres. Une fois rassemblés, ces éléments constituent une <span class="em">interface utilisateur ou UI</span>. Si je prends l'exemple de la maquette du site de plantes ci-dessous, vous voyez la barre de menu, le panier, et que pour chaque article, il y a un nom, une photo, une description.</p>
                    <img src="../images/maquette_React.png" alt="">
                    <p>Avec React, chacune de ces parties qu'on va pouvoir réutiliser correspond à un composant. Ils contiennent tout ce qui est nécessaire à leur bon fonctionnement : <span class="em">la structure, les styles et le comportement</span> (par exemple, les actions qui sont déclenchées quand on clique dessus).</p>
                    <p>Les composants nous permettent d'utiliser la même structure de données, et de remplir ces structures avec différents jeux de données. Peu importe le nombre de plantes que vous aurez à mettre dans La maison jungle, vous pourrez les exploiter pour afficher vos données sans aucun effort. Et si dans le futur, vous avez besoin de créer une nouvelle page avec la même présentation, vous pourrez réutiliser le même composant: vous vous rendez compte de la puissance des composants ?</p>
                    <p>C'est donc la mission des développeurs et développeurses React de découper toute interface utilisateur en éléments réutilisables, imbriqués les uns dans les autres. La majorité de nos composants sont eux-mêmes créés en <span class="em">combinant d'autres composants</span> plus simples.</p>
                    <p>Derrière chaque technologie, il y a une logique.</p>
                    <p>Vous savez que le HTML est une suite d'instructions que le navigateur doit suivre pour construire le DOM. Eh bien, <span class="em">react vient directement modifier le DOM pour vous</span> ; il suffit juste de lui donner les instructions de ce que vous souhaitez faire.</p>
                    <p>Pour faire simple : en utilisant <span class="html">React.createElement</span>, React crée d'abord ses éléments dans le DOM virtuel, puis il vient prévenir le DOM au moment de sa créatuibn "Hé, rajoute-moi une balise h1 avec le texte <span class="em">La maison jungle</span> dedans".</p>
<pre><code>&lt;div id="root"&gt;&lt;/div&gt;

const Header = React.createElement('h1', {}, 'La maison jungle')

console.log(Header)

ReactDOM.render(Header, document.getElementById("root"))</code></pre>
                    <p>En faisant un <span class="html">console.log</span> de votre composant, voilà ce que vous obtenez :</p>
                    <figure>
                        <img src="../images/console_log_React.png" alt="">
                        <figcaption>Un console.log de notre premier composant</figcaption>
                    </figure>
                    <p><span class="em">Header</span> est ici un élément React, créé par React. Concrètement, il s'agit d'un gros objet. Chaque composant génère des arborescences d'éléments React et d'autres composants, qui seront ensuite traduits en éléments dans le DOM.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>C'est un peu comme lorsque vous créez en JavaScript un nouvel élément avec <span class="html">document.createElement</span> et que vous l'ajoutez au DOM avec la méthode <span class="html">.appendChild()</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="initialisation_JSX">Initiez-vous au JSX :</h2>
                    <p>Vous avez découvert que les éléments renvoient des objets avec tout un ensemble de propriétés spécifiques, et que React vient les créer avec <span class="em">createElement</span>. Mais vous vous doutez que les développeurs React ne manipulent pas ces objets directement. Non, à la place, ils utilisent le <span class="em">JSX</span>.</p>
                    <p>Il s'agit de l'extension JavaScript créée par React, qui permet d'<span class="em">utiliser notre syntaxe sous forme de tages directement dans le code JavaScript</span>.</p>
                    <p>Lorsqu'on a ça :</p>
<pre><code>function Header() {
    return (&lt;div&gt;
        &lt;h1&gt;La maison jungle&lt;/h1&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>... et qu'on le réutilise avec <span class="em">&lt;Header /&gt;</span>, on pourrait croire qu'il s'agit de HTML. Ça a un peu la même tête, mais il s'agit de JSX ! Eh oui, JSX est la manière la plus compréhensible d'écrire dfes composants React dans une application, et donc la manière qui est quasiment toujours utilisée. Il s'agit d'ailleurs de <span class="em">la sépcificité de React</span> : contrairement aux autres frameworks où on écrit du HTML enrichi, les équipes de React ont créé le JSX, leur propre syntaxe basée sur JavaScript, qui permet de <span class="em">mêler HTML et JS</span>.</p>
                    <p>Comme le HTML, le JSX est un <span class="em">langage à balises</span>. Les touches <span class="html">&lt;</span>, <span class="html">&gt;</span> et <span class="html">/</span> de vos claviers vont donc être souvent utilisées.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>On a bien créé un composant <span class="em">Header</span> et pas <span class="em">header</span>. Il est essentiel de <span class="em">mettre une majuscule à nos composants JSX</span>, sinon React ne saura pas qu'il s'agit d'un composant, et pensera qu'il s'agit juste d'une balise HTML.</p>
                    </div>
                    <h3>Composez vos composants :</h3>
                    <p>Reprenons notre composant <span class="em">&lt;Header /&gt;</span>. Il est un peu tout seul, vous ne trouvez pas ?</p>
                    <p>On va lui ajouter un composant <span class="em">&lt;Description /&gt;</span> :</p>
<pre><code>function Description() {
    return (&lt;p&gt;Ici achetez toutes les plantes dont vous avez toujours rêvé&lt;/p&gt;)
}</code></pre>
                    <p>Et on le rajoute dans le render :</p>
<pre><code>ReactDOM.render(&lt;Header /&gt;&lt;Description /&gt;, document.getElementById("root"))</code></pre>
                    <p>Quoi ?! Rien ne s'affiche sauf un point d'exclamation entouré de rouge : il y a une erreur !</p>
                    <p>Pas de panique, c'est normal : deux composants doivent toujours être <span class="em">wrappés dans un seul composant parent</span>.</p>
                    <p>On peut donc faire :</p>
<pre><code>ReactDOM.render(&lt;div&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/div&gt;, document.getElementById("root"))</code></pre>
                    <p>et le problème est résolu.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>React met également à notre disposition un outil, les Fragments, si on veut wrapper deux composants dans un seul parent sans que le parent apparaisse dans le DOM. Pour ça, vous pouvez faire :</p>
<pre><code>ReactDOM.render(&lt;React.Fragment&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/React.Fragment&gt;, document.getElementById("root"))</code></pre>
                        <p>Nos éléments sont bien wrappés, et si vous inspectez votre page, ce parent n'apparaît pas dans le DOM.</p>
                    </div>
                    <p>Comme je vous l'ai expliqué, le propre de react est de nous encourager à <span class="em">réutiliser nos composants</span>. On va donc structurer notre interface en arborescences de composants.</p>
                    <p>Regroupons notre Titre et notre Description dans une bannière :</p>
<pre><code>function Banner() {
    return (&lt;div&gt;
        &lt;Header /&gt;
        &lt;Description /&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>Vous voyez ? Tout se passe bien comme prévu.</p>
                    <p>Et nous pourrions également les encapsuler, et les utiliser autant de fois que nous le souhaitons comme ci-dessous :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
&lt;/Parent&gt;</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Vous remarquez d'aillez que tous nos composants sont bien fermés. En JSX, <span class="em">toutes les balises doivent être fermées</span>, y compris les éléments HTML autofermants tels que input. On l'écrira de cette manière (en lui ajoutant les attributs souhaités) :</p>
<pre><code>&lt;input /&gt;</code></pre>
                    </div>
                    <h3>Manipulez des données dans vos composants JSX :</h3>
                    <p>En React, les accolades <span class="html">{</span> et <span class="html">}</span> sont également particulièrement utiles. Dès qu'il s'agit d'expressions JavaScript, elles sont écrites entre accolades.</p>
                    <p>Ça nous permet d'<span class="em">appliquer des expressions JavaScript</span> directement dans notre JSX pour :</p>
                    <ul>
                        <li>
                            <p>faire des maths :</p>
<pre><code>&lt;div&gt;La grande réponse sur la vie, l'univers et le reste est { 6 * 7 } &lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>modifier des chaînes de caractères :</p>
<pre><code>&lt;div&gt;{ alexia.toUpperCase() }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>utiliser des <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaires</a> :</p>
<pre><code>&lt;div&gt;{ 2 &gt; 0 ? 'Deux est plus grand que zéro' : 'Ceci n\'apparaîtra jamais' }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Ou même tout simplement pour afficher une variable JS :</p>
                    <ul>
                        <li>
                            <p>pour une string :</p>
<pre><code>&lt;div&gt;{ myTitle }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>pour un nombre :</p>
<pre><code>div&gt;{ 42 }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Par exemple, si on décide de mettre notre texte ou description dans une variable :</p>
<pre><code>function Description() {
    const text = "Ici achetez toutes les plantes dont vous avez toujours rêvées"
    return (&lt;p&gt;{ text }&lt;/p&gt;)
}</code></pre>
                    <p>ça s'affiche bien comme prévu.</p>
                </article>
                <article>
                    <h2 id="Create_React_App">Prenez en main Create React App :</h2>
                    <p>Nous avons appris à utiliser les liens CDN de React, ReactDOM et Babel pour rapidement créer une app React. Mais cette technique n'est quasiment pas utilisée dans la vie de tous les jours d'un développeur.</p>
                    <p>À la place, les développeuses et développeurs utilisent des outils automatisés pour créer une base de code, qui dispose des outils essentiels déjà préconfigurés. Pour vous citer quelques-unes des fonctionnalités de ces outils, ils permettent de :</p>
                    <ul>
                        <li>
                            <p>gérer les différentes dépendances (bibliothèques) utilisées par notre app;</p>
                        </li>
                        <li>
                            <p>optimiser le chargement de notre code dans les navigateurs;</p>
                        </li>
                        <li>
                            <p>importer du CSS et des images;</p>
                        </li>
                        <li>
                            <p>gérer les différentes versions de JavaScript;</p>
                        </li>
                        <li>
                            <p>faciliter l'expérience de développement, en rechargeant la page lorsque le code est modifié.</p>
                        </li>
                    </ul>
                    <h3>Découvrez CRA :</h3>
                    <p>Également créé par les équipes de Facebook, <a href="https://github.com/facebook/create-react-app" target="_blank">Create React App</a> est un outil qui vous aidera à faire tout ce que je viens de citer. S'il existe d'autres outils (<a href="https://nextjs.org/" target="_blank">Next</a>, <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a>, <a href="https://parceljs.org/" target="_blank">Parcel</a>, etc.), Create React App reste la référence, notamment pour les nouveaux utilisateurs de React.</p>
                    <p>Create React App va permettre de <span class="em">générer un squelette de code</span> pour votre application. Il embarque un certain nombre d'<span class="em">outils préconfigurés</span>, tels que Webpack, Babel et ESLint, afin de vous garantie la meilleure expérience de développement possible.</p>
                    <h3>Installez et lancez CRA :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour manipuler Create React App ici, nous allons avoir besoin d'un gestionnaire de paquet (<span class="em">package manager</span>) directement dans le terminal. Ici, je vais utiliser <span class="html">yarn</span>. Si vous utilisez une autre version, telle que npm, je vous conseille de vous référer au <a href="https://github.com/facebook/create-react-app#user-guide" target="_blank">guide d'utilisation de Create React App par Facebook, sur GitHub</a> (en anglais).</p>
                        <p>D'ailleurs, si vous voulez en apprendre davantage sur pourquoi choisir npm ou Yarn, <a href="https://blog.zenika.com/2017/03/13/npm-vs-yarn/" target="_blank">je vous conseille cet excellent article de blog qui compare les deux.</a></p>
                    </div>
                    <p>Pour commencer, placez-vous dans le dossier où vous voulez créer votre projet.</p>
                    <p>Pour initialiser votre projet, nous allons faire :</p>
<pre><code>yarn create react-app la-maison-jungle</code></pre>
                    <p>Grâce à cette commande, vous avez votre premier projet créé avec Create React App !</p>
                    <h3>Découvrez les fichiers :</h3>
                    <p>Maintenant que votre projet est initialisé, il est temps de vous plonger dedans et de partir à l'exploration des fcihiers créés. On rentre dans le projet avec <span class="html">cd la-maison-jungle</span> dans votre terminal.</p>
                    <p>À partir de là, vous pouvez ouvrir votre éditeur de texte préféré pour jeter un oeil.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Votre environnement de travail est particulièrement important. Vous devez vous sentir à l'aise avec les outils que vous utilisez. VS Code vous permet d'installer des extensions qui vous offrent des fonctionnalités supplémentaires. Typiquement, pour un projet React, les extensions Prettier et ESLint sont très utiles !</p>
                    </div>
                    <p>Vous trouverez trois dossiers :</p>
                    <ul>
                        <li>
                            <p><span class="html">node_modules</span> : c'est là que sont installées toutes les <span class="em">dépendances</span> de notre code. Ce dossier peut vite devenir très volumineux.</p>
                        </li>
                        <li>
                            <p><span class="html">public</span> : dans ce dossier, vous trouverez votre <span class="em">fichier</span> <span class="html">index.html</span> et d'autres fichiers relatifs au référencement web de votre page.</p>
                        </li>
                        <li>
                            <p><span class="html">src</span> : vous venez de renrer dans le coeur de l'action. <span class="em">L'essentiel des fichiers que vous créerez et modifierez seront là.</span></p>
                        </li>
                    </ul>
                    <p>Et faisons maintenant un petit tour des fichiers importants :</p>
                    <ul>
                        <li>
                            <p><span class="html">package.json</span> situé à la racine de votre projet, il vous permet de <span class="em">gérer vos dépendances</span> (tous les outils permettant de construire votre projet), vos scripts qui peuvent être exécutés avec <span class="html">yarn</span>, etc. Si vous examinez son contenu, vous pouvez voir des dépendances que vous connaissez : React et ReactDOM :</p>
                            <ul>
                                <li>
                                    <p>vous y trouverez <span class="html">react-scripts</span>, créé par Facebook, qui permet d'installer Webpack, Babel, ESLint et d'autres pour vous faciliter la vie</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>dans <span class="html">/public</span>, vous trouvez <span class="html">index.html</span>. Il s'agit du <span class="em">template de votre application</span>. Il y a plein de lignes de code, mais vous remarquez <span class="html">&lt;div id="root"&gt;&lt;/div&gt;</span> ? Comme précédemment, nous allons y ancrer notre app React</p>
                        </li>
                        <li>
                            <p>dans <span class="html">/src</span>, il y a <span class="html">index.js</span> qui permet d'<span class="em">initialiser notre app React</span>;</p>
                        </li>
                        <li>
                            <p>et enfin, dans <span class="html">/src</span>, vous trouvez <span class="html">App.js</span> qui est <span class="em">notre premier composant React</span>.</p>
                        </li>
                    </ul>
                    <p>Deux fichiers que nous n'utiliserons pas directement mais qui ne font pas de mal à garder :</p>
                    <ul>
                        <li>
                            <p>le <span class="html">README.md</span> qui permet d'afficher une page d'explication si vous mettez votre code sur GitHub, par exemple</p>
                        </li>
                        <li>
                            <p>et le fichier <span class="html">.gitignore</span> qui précise ce qui ne doit pas être mis sur GitHub, typiquement le volumineux dossier des <span class="html">node_modules</span>.</p>
                        </li>
                    </ul>
                    <h3>Choisir une version spécifique de React :</h3>
                    <p>Pour mettre à jour les dépendances, nous allons suivre différentes étapes :</p>
                    <ol>
                        <li>
                            <p>Rendez-vous au fichier <span class="html">package.json</span> dans la section <span class="html">depencies</span>. Modifiez cette section avec le code suivant, correspondant aux dépendances nécessaires à React 17 :</p>
<pre><code>"dependencies": {
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "react-scripts": "4.0.1",
    "web-vitals": "^0.2.4"
},</code></pre>
                        </li>
                        <li>
                            <p>Supprimez le fichier <span class="html">yarn.lock</span> (ou <span class="html">package.lock</span> si vous avez utilisé npm) ainsi que le dossier de nos dépendances <span class="html">node_modules</span>.</p>
                        </li>
                        <li>
                            <p>Dans le dossier <span class="html">src</span>, modifiez le fichier <span class="html">index.js</span> qui a été généré pour la dernière version de React avec le code correspondant à la version de React 17, comme ceci :</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;App /&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
);</code></pre>
                        </li>
                        <li>
                            <p>Lancer la commande <span class="html">yarn</span> pour installer les dépendaces.</p>
                        </li>
                    </ol>
                    <p>Vous pouvez procéder de la même manière pour installer n'importe quelle version spécifique de React dans votre application. En suivant le cheminement ci-dessus vous serez à même de suivre la suite de ce cours sans difficulté.</p>
                    <h3>Prenez en main votre app avec les commandes :</h3>
                    <p>Lorsque vous vous trouvez à la racine de votre projet, vous pouvez exécuter <span class="html">yarn start</span> qui va <span class="em">démarrer votre application en mode développement</span>.</p>
                    <p>Cela vous donne quelque chose comme ça (même si votre adresse IP sera très probablement différente) :</p>
                    <img src="../images/yarn_start_React.png" alt="">
                    <p>Un onglet a dû s'ouvrir dans votre navigateur à l'URL <span class="em">http://localhost:3000/</span>. Si ce n'est pas le cas, ouvrez-le vous-même.</p>
                    <p>Vous avez le magnifique logo de React qui tourne dans votre navigateur.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe d'autres commandes :</p>
                        <ul>
                            <li>
                                <p><span class="html">yarn run build</span> vous permettra de créer un <span class="html">build</span> avec votre code transformé et minifié, si vous devez déployer votre application en production (la mettre en ligne, par exemple);</p>
                            </li>
                            <li>
                                <p><span class="html">yarn test</span> pour exécuter les tests.</p>
                            </li>
                        </ul>
                        <p>Vous pouvez d'ailleurs créer vos propres commandes si vous les ajoutez dans la partie <span class="html">scripts</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="organisation_code">Organisez votre code :</h2>
                    <p>Nous allons maintenant <span class="em">modifier notre base de code</span> pour qu'elle soit plus à l'image de notre projet. Il existe plusieurs manières d'organiser son code, et il est important de réfléchir à comment l'organiser. Ici, nous allons séparer les fichiers selon leur type : composants/style/images, etc.</p>
                    <p>On va commencer par créer un dossier <span class="html">/components</span> dans <span class="html">/src</span>, où nous mettrons tous nos composants. On y glisse <span class="html">App.js</span> et on en profite pour changer le chemin d'import dans <span class="html">index.js</span>. Pour ce qui est des autres fichiers, le plus important est <span class="html">index.js</span> que vous devez garder. Vous pouvez également garder <span class="html">index.css</span>, mais vous pouvez supprimer les autres fichiers.</p>
                    <p>Maintenant, <span class="em">créons notre</span> <span class="html">Banner</span> dans un fichier JavaScript à part dans <span class="html">/components</span> que nous pouvons appeler <span class="html">Banner.js</span>.</p>
<pre><code>function Banner() {
    return &lt;h1&gt;La maison jungle&lt;/h1&gt;
}

export default Banner</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous remarquez la notation <span class="html">export default</span> ? Il s'agit d'une syntaxe prévue dans l'ES6, qui vous épargnera d'utiliser les accolades au moment de l'import.</p>
                    </div>
                    <p>On peut maintenant adapter le code de <span class="html">App.js</span> en supprimant le code de base, et <span class="em">y importer notre</span> <span class="html">Banner</span>.</p>
<pre><code>import Banner from './Banner'

function App() {
    return &lt;Banner /&gt;
}

export default App</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/banner_React.png" alt="">
                        <figcaption>Notre Banner s'affiche dans le navigateur.</figcaption>
                    </figure>
                    <p>Félicitations ! Comme je l'ai déjà mentionné, mais ici, c'est <a href="https://webpack.js.org/" target="_blank">Webpack</a> qui nous permet d'importer notre composant aussi facilement, avec <span class="html">import</span>. Cet outil particulièrement utile est essentiel pour lier les fichiers entre eux, afin qu'ils soient interprétés par le navigateur. Et dire que Create React App nous a permis de l'installer sans faire aucune configuration. Si ça c'est pas de la chance !</p>
                    <figure>
                        <img src="../images/webpack_React.png" alt="">
                        <figcaption>Import vos composants grâce à Webpack</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="stylisation_app">Stylisez votre app :</h2>
                    <p>C'est maintenant le moment d'ajouter un peu de style à nos composants.</p>
                    <h3>Exploitez les classNames :</h3>
                    <p>Comme en HTML, nous pouvons <span class="em">associer des attributs à nos éléments</span>. Les attributs HTML tels que <span class="html">id</span>, <span class="html">href</span> pour un lien &lt;a /&gt;, <span class="html">src</span> pour une balise &lt;img /&gt;, fonctionnent normalement en JSX.</p>
                    <p>En revanche, il existe des mots réservés en JavaScript, tels que <span class="html">class</span>. Pour attribuer du style avec une classe CSS, il suffit pour cela d'utiliser l'attribut <span class="html">className</span>, et de lui préciser une string. D'ailleurs, vous pouvez utiliser plusieurs classes sur un élément en les mettant à la suite, séparées par un espace.</p>
                    <p>Créons dans <span class="html">/src</span> un dossier <span class="html">/styles</span> qui va regrouper nos fichiers CSS. On peut y glisser <span class="html">index.css</span> en n'oubliant pas de modifier le path relatif pour importer <span class="html">index.css</span> dans <span class="html">index.js</span>.</p>
                    <p>Je crée donc mon fichier <span class="html">Banner.css</span> qui va me permettre de <span class="em">styliser mon composant</span>. Ce qui nous donne une organisation comme dans la capture ci-dessous :</p>
                    <figure>
                        <img src="../images/banner_CSS_React.png" alt="">
                        <figcaption>L'arborescence de notre app</figcaption>
                    </figure>
                    <p>Dans <span class="html">Banner.js</span>, je wrappe mon <span class="em">h1</span> dans une div à laquelle je <span class="em">précise la className lmj-banner</span> ("lmj" pour la maison jungle, bien sûr !) :</p>
<pre><code>&lt;div className='lmj-banner'&gt;
    &lt;h1&gt;La maison jungle&lt;/h1&gt;
&lt;/div&gt;</code></pre>
                    <p>Et retour dans notre fichier <span class="html">Banner.css</span>, où on <span class="em">crée la classe correspondante</span> :</p>
<pre><code>.lmj-banner {
    color: black;
    text-align: right;
    padding: 32px;
    border-bottom: solid 3px black;
}</code></pre>
                    <p>Jetons un oeil à notre page dans le navigateur.</p>
                    <p>Rien ne se passe car nous n'avons tout simplement pas <span class="em">importé le fichier</span>. Il suffit de rajouter dans notre fichier <span class="html">Banner.js</span> :</p>
<pre><code>import '../styles/Banner.css'</code></pre>
                    <p>Et ça y est ! Notre style est appliqué !</p>
                    <p>En React comme dans toutes les librairies et tous les frameworks front, <span class="em">l'accessibilité du web est essentielle</span>. Elle est nécessaire pour permettre aux technologies d'assistance et aux personnes en situation de handicap, notamment, d'interpréter les pages web. Pour en savoir plus, je vous conseille "<a href="https://openclassrooms.com/fr/courses/6691346-concevez-un-contenu-web-accessible" target="_blank">Concevez un contenu web accessible</a>", un excellent cours sur ce sujet.</p>
                </article>
                <article>
                    <h2 id="decouverte_attribut_style">Découvrez l'attribut style :</h2>
                    <p>Bonne nouvelle : les éléments React acceptent également l'attribut <span class="html">style</span> pour styliser un composant. À la différence des éléments HTML, pour lesquels cet attribut est également accepté, il faut lui passer un objet en paramètre. On appelle cette méthode du <span class="em">inline style</span> :</p>
<pre><code>import '../styles/Banner.css'

function Banner() {
    return (
        &lt;div
                style={{
                    color: 'black',
                    textAlign: 'right',
                    padding: 32,
                    borderBottom: 'solid 3px solid'
                }}
        &gt;
            &lt;h1&gt;La maison jungle&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>Cet attribut peut être pratique pour tester rapidement quelque chose, mais il n'est pas recommandé d'en faire une utilisation plus poussée. Donc, pour styliser votre application, privilégiez davantage la méthode des classNames, ou d'autres méthodes avec des librairies tierces, par exemple.</p>
                </article>
                <article>
                    <h2 id="utilisation_images">Utilisez des images :</h2>
                    <p>Vous avez peut-être vu le <span class="em">logo.svg</span> de React situé dans <span class="html">/src</span> ?</p>
                    <p>Ici, nous allons faire un peu la même chose. Mais commençons par organiser tout ça.</p>
                    <p>Toujours dans <span class="html">/src</span> , on crée un dossier <span class="html">/assets</span> dans lequel on vient mettre notre fichier <span class="em">logo.png</span> qui voici :</p>
                    <img src="../images/logo.png" alt="">
                    <p>Pour <span class="em">l'importer dans votre code</span>, vous pouvez maintenant faire de la manière suivante . Dans <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'</code></pre>
                    <p>Vous voyez ici, on déclare en fait une variable logo à laquelle on assigne le contenu de notre image.</p>
                    <p>Puis vous pouvez <span class="em">l'utiliser dans un élément img</span>, ce qui nous donne pour notre <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'
import '../styles/Banner.css'

function Banner() {
    const title = 'La maison jungle'
    return (
        &lt;div className='lmj-banner'&gt;
            &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
            &lt;h1 className='lmj-title'&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>En ajoutant un peu de CSS, me voilà avec la bannière telle que je la voulais.</p>
                    <p>Vous avez maintenant une très bonne base de code pour créer votre application, en utilisant du style et des assets directement dans vos composants React.</p>
                </article>
                <article>
                    <h2 id="iteration_contenu">Itérez sur votre contenu :</h2>
                    <p>En code, vous serez très souvent confronté à des listes de données qui présentent la même struture. Bonne nouvelle ! Pas besoin de vous faire des crampes à force de copier-coller : vous pouvez <span class="em">directement itérer sur votre contenu et générer des composants react dessus</span>.</p>
                    <h3>Découvrez votre allié : map() :</h3>
                    <p>La <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/map" target="_blank">méthode JavaScript <span class="html">map()</span></a> passe sur chaque élément d'un tableau. Elle lui applique une fonction, et renvoie un nouveau tableau contenant les résultats de cette fonction appliquée sur chaque élément.</p>
                    <p>Par exemple, pour une fonction qui doublerait la valeur d'un élément, cela donne :</p>
<pre><code>const numbers = [1, 2, 3, 4]
const doubles = numbers.map(x =&gt; x * 2) // [ 2, 4, 6, 8]</code></pre>
                    <p>Dans notre cas, ekke ca biys oerlerrre de <span class="em">prendre une liste de données</span>, et de la <span class="em">transformer en liste de composants</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode <span class="html">map()</span> permet facilement d'itérer sur des données et de retourner un tableau d'éléments. Comme elle, les méthodes <span class="html">forEach()</span>, <span class="html">filter()</span>, <span class="html">reduce()</span>, etc., qui permettent de manipuler des tableaux, seront également vos alliés en React.</p>
                    </div>
                    <p>On va donc créer un composant <span class="html">ShoppingList.js</span> pour notre magain de plantes.</p>
                    <p>Dans ce fichier, on déclare une variable plantList qui <span class="em">contient notre liste de plantes</span> :</p>
<pre><code>const plantList = [
    'monstera',
    'ficus lyrata',
    'pothos argenté',
    'yucca',
    'palmier'
]</code></pre>
                    <p>Et <span class="em">on ajoute en dessous le composant</span> lui-même :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant) => (
                &lt;li&gt;{plant}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Vous voyez : pour chaque entrée du tableau, on retourne un élément <span class="html">&lt;li&gt;</span>.</p>
                    <p>On <span class="em">importe ShoppingList.js dans</span> <span class="html">&lt;App /&gt;</span>. On a notre liste de composants !</p>
                    <p>Mais qu'est-ce que c'est que cette erreur rouge dans ma console ?</p>
                    <p>Oh oh ! Il semblerait que j'aie oublié la prop <span class="html">key</span>.</p>
                    <p>La <a href="https://fr.reactjs.org/docs/lists-and-keys.html" target="_blank">documentation de React</a> est claire sur ce sujet : les <span class="html">key</span> (clés) aident React à <span class="em">identifier quels éléments d'une liste ont changé, ont été ajoutés ou spprimés</span>. Vous devez donner une clé à chaque élément dans un tableau, afin d'apporter aux éléménts une identité stable.</p>
                    <p>Si vous voulez éviter kes bugs, une <span class="html">key</span> doit impérativement respecter deux principes :</p>
                    <ul>
                        <li>
                            <p>Elle doit être <span class="em">unique</span> au sein du tableau.</p>
                        </li>
                        <li>
                            <p>Et <span class="em">stable dans le temps</span> (pour la même donnée source, on aura toujours la même valeur de <span class="html">key=</span>).</p>
                        </li>
                    </ul>
                    <p>Nous avons plusieurs méthodes pour générer une <span class="em">key</span> unique :</p>
                    <ul>
                        <li>
                            <p>La méthode la plus simple et la plus fiable consiste à <span class="em">utiliser l'id associée à votre donnée</span> dans votre base de données.</p>
                        </li>
                        <li>
                            <p>Vous pouvez également trouver un moyen d'<span class="Em">exploiter la valeur de la donnée</span>, si vous avez la certitude qu'elle sera toujours unique, et stable dans le temps.</p>
                        </li>
                        <li>
                            <p>En dernier recours, vous pouvez <span class="em">définir une string et la combiner avec l'index</span> de la data dans votre tableau.</p>
                        </li>
                    </ul>
                    <p>Dans notre cas, puisqu'il n'y a pas d'id associée, on peut faire une combinaison entre l'index et le nom de la plante qui est une string :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant, index) =&gt; (
                &lt;li key={`${plant}-${index}`}&gt;{ plant }&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Cette fois-ci, pas d'erreur dans la console !</p>
                </article>
                <article>
                    <h2 id="contextualisation_contenu_composants">Contextualisez le contenu de vos composants :</h2>
                    <p>React nous permet de faire des listes de composants : un gain de temps énorme dans votre vie de développeur. Mais ce n'est pas tout ! Le JSX nous permet également d'<span class="em">afficher des éléments de manière conditionnelle dans nos composants</span>.</p>
                    <h3>Créez des conditions dans le JSX :</h3>
                    <p>Donc... Nous avons déjà vu <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaire</a>. maintenant qu'on a une app complète pour nous faire la main, moi, ça me donne envie de le mettre en applicationdans notre site de plantes.</p>
                    <p>Dans notre liste de plantes <span class="html">plantList.js</span>, je vais <span class="em">rajouter une catégorie <span class="html">isBestSale</span> correspondant à un <span class="html">booléen</span></span> qui nous indique si notre plante fait partie des meilleures ventes. Ce qui nous donne pour le premier élément :</p>
<pre><code>{
    name: 'monstera',
    category: 'classique',
    id: '1ed',
    isBestSale: true
},</code></pre>
                    <p>Maintenant que nous avons notre booléen, nous allons <span class="em">utiliser un ternaire pour afficher un emoji en fonction</span>. Dans <span class="html">ShoppingList.js</span>, au niveau de l'affichage du nom, je rajoute :</p>
<pre><code>{plantList.map((plant) =&gt; (
    &lt;li key={ plant.id }&gt;
        {plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : &lt;span&gt;👎&lt;/span&gt;}
    &lt;/li&gt;
))}</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/condition_React.png" alt="">
                        <figcaption>Notre condition différencie les meilleures ventes des autres.</figcaption>
                    </figure>
                    <p>Génial ! Ça marche bien !</p>
                    <p>Mais en y repensant, je ne suis pas sûre que ce soit top comme argulent de vente... À la place, n'affichons que le 🔥 pour les meilleures ventes, et rien pour les autres.</p>
                    <p>Pour ça, on peut <span class="em">retourner <span class="html">null</span> dans la condition où on ne veut rien afficher</span> :</p>
<pre><code>{plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : null}</code></pre>
                    <p>Et voilà ! On a ce que l'on voulait !</p>
                    <p>Mais vous savez quoi ? Il existe une manière encore plus simple d'écrirer ça : vous pouvez utiliser <span class="html">&amp;&amp;</span>.</p>
                    <p>Indiquée entre accolades, <span class="html">&amp;&amp;</span> précède un élément JSX et <span class="em">précise que l'élément ne sera généré que si la condition est respectée</span>. On peut donc écrire :</p>
<pre><code>{plant.isBestSale && &lt;span&gt;🔥&lt;/span&gt;}</code></pre>
                    <p>Yes ! Ça fonctionne comme prévu !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous pouvez d'ailleurs chaîner les conditions.</p>
                    </div>
                    <h3>Ouvrez-vous à d'autres méthodes :</h3>
                    <p>React est particulièrement flexible : il existe d'autres méthodes permettant de contextualiser votre contenu.</p>
                </article>
                <article>
                    <h2 id="familisarisation_props">Familiarisez-vous avec les props :</h2>
                    <p>Vous l'avez compris : la réutilisation des composants est au coeur de la logique de react. Mais, pour être réutilisés, les composants requièrent souvent une conviguration. Bonne nouvelle : pour ça, vous allez pouvoir utiliser les props.</p>
                    <h3>Familiarisez-vous avec la syntaxe :</h3>
                    <p>Et si je vous disais que vous avez déjà utilisé une prop ? Eh oui, la prop <span class="html">key</span> sur les listes ! Vous avez donc déjà vu la syntaxe.</p>
                    <p>Revenons à notre site de plantes. Nous allons maintenant créer un nouveau composant qui va être réutilisé. L'idée est de créer une échelle d'arrosage et une échelle de luminosité pour chaque plante.</p>
                    <p>Rouvrons <span class="html">ShoppingList.js</span>, où nous <span class="em">ajoutons les données correspondantes dans <span class="html">plantList</span></span> :</p>
                    <ul>
                        <li>
                            <p>une donnée <span class="em">water</span> qui correspond à l'arrosage conseillé pour chaque plante;</p>
                        </li>
                        <li>
                            <p>et une donnée <span class="em">light</span> qui correspond à l'ensoleillement nécessaire.</p>
                        </li>
                    </ul>
                    <p>Commençons par la lumière : dans chaque item plante, on vient <span class="em">ajouter un composant <span class="html">CareScale</span> et on lui passe la prop value</span> :</p>
<pre><code>&lt;CareScale scalueValue={plant.light} /&gt;</code></pre>
                    <p>Les props sont récupérées dans les <span class="em">paramètres de la fonction qui définit notre composant</span>.</p>
                    <p>Pour <span class="html">CareScale</span>, on aura donc :</p>
<pre><code>function CareScale(props) {µ
    const scaleValue = props.scaleValue
    return &lt;div&gt;{scaleValue}☀️&lt;/div&gt;
}

export default CareScale</code></pre>
                    <p>Mais on avait dit qu'on voulait une échelle de 1 à 3, non ?</p>
                    <p>On va donc <span class="em">partir sur une liste</span>, qu'on peut manuellement.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>function CareScale(props) {
    const scaleValue = props.scaleValue

    const range = [1, 2, 3]

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt;
                scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;☀️&lt;/span&gt; : null
            )}
        </div>
    )
}</code></pre>
                    <p>Félicitations ! Vous venez d'utiliser les <span class="em">props</span> !</p>
                    <p>Les props sont donc des <span class="em">objets que l'on peut récupérer dans les paramètres de notre composant fonction</span>.</p>
                    <p>On va pousser la logique un peu plus loin afin de véritablement paramétrer notre composant.</p>
                    <h3>Créez des paramètres :</h3>
                    <p>Je vais commencer par <span class="em">préciser une <span class="html">prop</span> pour le type que j'appellerai <span class="html">careType</span> pour mon composant <span class="html">CareScale</span> et réutiliser ce composant</span> entre l'ensoleillement et l'arrosage :</p>
<pre><code>&lt;CareScale careType='water' scaleValue={plant.water} /&gt;
&lt;CareScale careType='light' scaleValue={plant.light} /&gt;</code></pre>
                    <p>Il faut maintenant que j'adapte <span class="html">CareScale</span> pour récupérer le <span class="html">careType</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>À partir de maintenant, je vais utiliser une syntaxe qui nous est permise depuis l'ES6 : la <span class="em">déstructuration</span>. Elle permet directement de déclarer une variable et de lui assigner la valeur d'une propriété d'un objet.</p>
                        <p>Ici on peut donc faire :</p>
<pre><code>const {scaleValue, careType} = props
// On évite de multiplier les déclarations qui sans cette syntaxe auraient été :
// const scaleValue = props.scaleValue et
// const careType = props.careType</code></pre>
                        <p>Cela nous permet de <span class="em">déclarer directement nos deux variables</span> <span class="html">scaleValue</span> et <span class="html">careType</span>, et de <span class="em">les assigner aux valeurs</span> passées en propos. On peut même directement l'écrire dans les paramètres :</p>
<pre><code>function CareScale({scaleValue, careType}) {</code></pre>
                    </div>
                    <p>On peut donc maintenant <span class="em">paramétrer notre composant <span class="html">CareScale</span> pour qu'il puisse gérer les données</span> d'arrosage et les données d'ensoleillement :</p>
<pre><code>function CareScale({ scaleValue, careType }) {
    const range = [1, 2, 3]
    
    const scaleType = careType === 'light' ? '☀️' : '💧'

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt; scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;{scaleType}&lt;/span&gt; : null
            )}
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Comme vous l'avez vu ici, nous avons utilisé <span class="em">deux syntaxes différentes pour nos props</span>. Pour <span class="html">scaleType</span>, nous lui avons assigné une <span class="html">string</span>, entre guillemets. En revanche, pour <span class="em">scaleValue</span>, nous lui avons attribué la valeur d'un objet, que nous avons passée entre accolades.</p>
                    <p>En pratique, une prop peut avoir n'importe quelle valeur possible en JavaScript, mais syntaxiquement, en JSX, on n'a en gros que deux possibilités :</p>
                    <ul>
                        <li>
                            <p>un littéral <span class="html">String</span>, matérialisé par des guillemets;</p>
                        </li>
                        <li>
                            <p>ou, pour toute le reste (booléen, number, expression JavaScript, etc.), des accolades <span class="html">{}</span>.</p>
                        </li>
                    </ul>
                    <h3>Faites descendre les données, des parents vers les enfants :</h3>
                    <p>Les props nous permettent de configurer nos composants. Elles répondent à la logique même de React selon laquelle les données descendent à travers notre arborescence de composants : il s'agit d'<span class="em">un flux de données unidirectionnel</span>.</p>
                    <figure>
                        <img src="../images/composants_parents_enfants_React.png" alt="">
                        <figcaption>Les composants parents partagent leurs données avec leurs enfants.</figcaption>
                    </figure>
                    <p>Comme vous pouvez vous en douter, un composant est le parent du composant défini dans le <span class="html">return()</span>.</p>
                    <p>Dans notre exemple, <span class="html">CareScale</span> est l'enfant, et <span class="html">ShoppingList</span> est le parent.</p>
                    <p>Pour les props, vous devez garder deux règles à l'esprit :</p>
                    <ul>
                        <li>
                            <p>Une prop est toujours <span class="em">passée par un composant parent à son enfant</span> : c'est le seul moyen normal de transmission.</p>
                        </li>
                        <li>
                            <p>Une prop est considérée <span class="em">en lecture seule</span> dans le composant qui la reçoit.</p>
                        </li>
                    </ul>
                    <h3>Découvrez la prop technique children :</h3>
                    <p>Il existe des props qui ont un comportement un peu particulier : nous les appelons les <span class="em">props techniques</span>.</p>
                    <p>La syntaxe de cette prop est particulière, puisqu'elle n'est pas fournie à l'aide d'un attribut, mais en <span class="em">imbriquant des composants</span> à l'intérieur du composant concerné.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant1 /&gt;
    &lt;Enfant2 /&gt;
&lt;/Parent&gt;</code></pre>
                    <p>Par exemple, si on <span class="em">utilise <span class="html">children</span> pour réécrire la Banner</span>, cela nous donnerait dans <span class="html">App.js</span> :</p>
<pre><code>&lt;Banner&gt;
    &lt;img src={logo} alt='La maison jungle' /&gt;
    &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
&lt;/Banner&gt;</code></pre>
                    <p>Ici, <span class="em">img</span> et <span class="em">h1</span> sont les noeuds enfants dans le DOM de <span class="html">Banner</span>.</p>
                    <p>Et on peut <span class="em">accéder à ces noeuds enfants de Banner dans ses paramètres</span>, un peu de la même manière qu'on récupérerait des props :</p>
<pre><code>function Banner({ children }) {
    return &lt;div className='lmj-banner'&gt;{children}&lt;/div&gt;
}</code></pre>
                    <p>Cette manière d'utiliser <span class="html">children</span> et particulièrement <span class="em">utile lorsqu'un composant ne connaît pas ses enfants à l'avance</span>, par exemple pour une barre de navigation (Sidebar) ou bien pour une modale.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les <span class="html">props</span> constituent un aspect clé de React. Mais, en les manipulant, vous verrez qu'il peut être très facile de faire des erreurs. Cela vient notamment de la flexibilité de JavaScript, qui fait du <a href="https://developer.mozilla.org/fr/docs/Glossaire/typage_dynamique" target="_blank">typage dynamique</a> (les types <span class="html">string</span>, <span class="html">int</span>, etc.). Pour vous donner un exemple d'erreur classique :</p>
                        <ul>
                            <li>
                                <p>Vous pouvez passer une prop value à un composant.</p>
                            </li>
                            <li>
                                <p>Vous utilisez une liste de valeurs, certaines valeurs sont des strings, d'autres des nombres.</p>
                            </li>
                            <li>
                                <p>Vous appliquez la méthode <span class="html">.toUpperCase()</span> à votre <span class="html">value</span> : <span class="em">boum</span> !</p>
                            </li>
                        </ul>
                        <p>Une erreur ! <span class="html">.toUpperCase()</span> n'existe pas sur un nombre.</p>
                        <p>Pour éviter ce genre d'erreur, je vous conseille d'être extrêmement rigoureux sur le type de props que vous passez à vos composants.</p>
                    </div>
                    <p>Pour cela, React a créé les <span class="em">PropTypes</span>, qui nous permettent de préciser dès le début le type d'une prop, si elle est requise, et de lui attribuer une valeur par défaut.</p>
                </article>
                <article>
                    <h2 id="maitrise_evenements_React">Maîtrisez les évenements en React :</h2>
                    <p>Si vous avez déjà manipulé du JavaScript, vous êtes sûrement déjà familier avec les événements. Bon, vous avez quand même droit à un petit rappel : un événement est une <span class="em">réaction</span> à une <span class="em">action</span> émise par l'utilisateur, comme le clic sur un bouton ou la saisie d'un texte dans un formulaire.</p>
                    <p>Bonne nouvelle pour vous : avec sa syntaxe pratique et concise, React facilite énormément la gestion des événements du DOM.</p>
                    <h3>Familiarisez-vous avec ka syntaxe :</h3>
                    <p>Quelques caractéristiques de la déclaration d'un événement en React :</p>
                    <ul>
                        <li>
                            <p>l'événement s'écrit dans une balise en <span class="em">camelCase</span>;</p>
                        </li>
                        <li>
                            <p>vous <span class="em">déclarez l'événement</span> à capter, et <span class="em">lui passez entre accolades la fonction</span> à appeler;</p>
                        </li>
                        <li>
                            <p>contrairement au JS, dans la quasi totalité des cas, <span class="em">vous n'avez pas besoin d'utiliser <span class="html">addEventListener</span></span>.</p>
                        </li>
                    </ul>
                    <p>Testons ça dès maintenant dans notre code. Dans <span class="html">components/PlantItem.js</span>, je vais <span class="em">déclarer une finction <span class="html">handleClick</span> qui vient faire un log</span> dans notre console :</p>
<pre><code>function handleClick() {
    console.log('Ceci est un clic')
}</code></pre>
                    <p>On <span class="em">ajoute maintenant <span class="html">onClick={handleClick}</span></span> dans la balise <span class="html">li</span> du composant <span class="html">PlantItem</span>. On a donc :</p>
<pre><code>&lt;li className='lmj-plant-item' onClick={handleClick}&gt;
    &lt;img className='img-plant-item-cover' src={cover} alt={`${name} cover`} /&gt;
    {name}
    &lt;div&gt;
        &lt;CareScale careType='water' scaleValue={water} /&gt;
        &lt;CareScale careType='light' scaleValue={light} /&gt;
    &lt;/div&gt;
&lt;/li&gt;</code></pre>
                    <p>J'ouvre la console et ça fonctionne comme prévu !</p>
                    <p>Je vais pousser cet exercice un peu plus loin : on va déclencher une alerte qui affiche le nom de la plante sur laquelle on a cliqué.</p>
                    <p>On <span class="em">passe donc <span class="html">plantName</span> en paramètre</span> de handleClick comme ici :</p>
<pre><code>function handleClick(plantName) {
    alert(`Vous voulez acheter 1 ${plantName} ? Très bon choix 🌱✨`)
}</code></pre>
                    <p>Mais si je clique, ça ne marche pas :</p>
                    <figure>
                        <img src="../images/plantName_React_1.png" alt="">
                        <figcaption>Aucune de nos plantes ne s'appelle 1 [object Object].</figcaption>
                    </figure>
                    <p>En effet, React passe par défaut un objet (que nous aborderons dans quelques minutes), mais ici, nous voulons lui spécifier notre propre argument.</p>
                    <p>Pour cela, c'est très simple : on <span class="em">déclare une fonction directement dans <span class="html">onClick</span></span> (les fonctions fléchées sont très pratiques pour ça). Cette fonction appellera handleClick en lui passant <span class="html">name</span> en paramètre. Donc on a :</p>
<pre><code>onClick={() =&gt; handleClick(name)}</code></pre>
                    <h3>Découvrez les événements synthétiques :</h3>
                    <p>Donc, je vous parlais de l'objet que React passe par défaut en paramètre aux fonctions indiquées en callback des événements. Voyons voir à quoi ça ressemble.</p>
                    <p>Si je <span class="em">récupère le paramètre dans handleClick</span> :</p>
<pre><code>function handleClick(e) {
    console.log('Cecu est mon event :', e)
}</code></pre>
                    <p>j'obtiens ça :</p>
                    <img src="../images/console_log_React_1.png" alt="">
                    <p>Il s'agit en fait d'un <span class="em">événement synthétique</span>. Pour faire bref, il s'agit de la même interface que pour les événements natifs du DOM, sauf qu'ils sont compatibles avec toues les navigateurs.</p>
                    <p>Pratique, n'est-ce pas ?</p>
                    <p>Vous pouvez utiliser les méthodes <span class="html">preventDefault</span> et <span class="html">stopPropagation</span> avec le paramètre dans la fonction passée à l'événement. Dans notre cas, vous auriez pu faire <span class="html">e.preventDefault()</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous voulez en savoir plus sur les événements synthétiques, vous trouverez <a href="https://fr.reactjs.org/docs/events.html" target="_blank">une liste de tous les événements orus eb charge ici</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="creation_formulaires_React">Simplifiez votre création de formulaires avec React :</h2>
                    <p>En React, la gestion des formulaires est simplifiée : on a accès à la valeur très facilement, qu'il s'agisse d'un input checkbox, d'un textarea, ou encore d'un select avec <span class="html">onChange</span>.</p>
                    <p>Il existe deux grandes manières de gérer les formulaires : <span class="em">la manière contrôlée et la manière non contrôlée</span>. J'aborderai assez rapidement la manière non contrôlée, parce qu'elle nécessite moins d'implication de react, et que React encourage l'utilisation des formulaires contrôlés.</p>
                    <h3>Déléguez le contrôle : les formulaires non contrôlés :</h3>
                    <p>Je vous fais une petite démo d'un formulaire non contrôlé. Sur notre app; directement dans <span class="html">App.js</span>, je mets un composant <span class="html">QuestionForm</span> que je vais déclarer dans un fichier à part. Nous allons ajouter un champ pour une question.</p>
                    <p>Donc pour ça, je <span class="em">crée un form</span>, qui englobe mon input :</p>
<pre><code>&lt;form onSubmit={handleSubmit}&gt;
    &lt;input type='text' name='my_input' defaultValue='Tapez votre texte' /&gt;
    &lt;button type='submit'&gt;Entrer&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    <p>Et <span class="em">pour <span class="html">handleSubmit</span></span>, cela donne :</p>
<pre><code>function handleSubmit(e) {
    e.preventDefault()
    alert(e.target['my_input'].value)
}</code></pre>
                    <p>Vous voyez que React me permet de préciser une <span class="html">defaultValue</span> à mon champ input. Ici, j'appelle <span class="html">preventDefault</span>, sinon le <span class="html">submit</span> rafraîchirait la page.</p>
                    <p>Et j'ai bien mon alerte qui se déclenche.</p>
                    <p>Plutôt simple, n'est-ce pas ? Vous déléguez le travail à votre DOM. Effectivement, les formulaires non contrôlés nous permettent de <span class="em">ne pas avoir à gérer trop d'informations</span>. Mais cette approche est un peu moins "React", parce qu'elle ne permet pas de tout faire.</p>
                    <p>À la place, vous pouvez utiliser les composants contrôlés.</p>
                    <h3>Contrôlez vos formulaires :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, pour vous montrer l'utilisation des formulaires contrôlés, je vais avoir besoin d'une notions que nous aborderons prochainement : le state (état). Donc je vais essayer de vous faire un petit brief sans rentrer dans le détail.</p>
                    </div>
                    <p>Le <span class="em">state local</span> nous permet de <span class="html">garder des informations. Ces informations sont spécifiques à un composant et elles proviennent d'une iteraction</span> que l'utilisateur a eue avec le composant.</p>
                    <p>Donc je vais <span class="em">créer ma variable <span class="html">inputValue</span> et la fonction</span> qui va permettre de changer sa valeur dans le state local avec <span class="html">useState</span>.</p>
                    <p>Sachez juste que la ligne de code ci-dessous me permet de déclarer l'état initial pour <span class="html">inputValue</span> et la fonction correspondante pour la modifier, et de lui préciser la valeur par défaut "Posez votre question ici" :</p>
<pre><code>const [inputValue, setInputValue] = useState("Posez votre question ici")</code></pre>
                    <p>J'ai donc mon <span class="html">QuestionForm</span> comme ci-dessous :</p>
<pre><code>import { useState } from 'react'

function QuestionForm() {
    const [inputValue, setInputValue] = useState('Posez votre question ici')
    return (
        &lt;div&gt;
            &lt;textarea
                value={inputValue}
                onChange={(e) =&gt; setInputValue(e.target.value)}
            /&gt;
        &lt;/div&gt;
    )
}

export default QuestionForm</code></pre>
                    <p>Ici, je passe une fonction en callback à <span class="html">onChange</span> pour qu'elle sauvegarde dans mon state local la valeur de mon input. J'accède à la valeur tapée dans l'input avec <span class="html">e.targer.value</span>.</p>
                    <p><span class="html">inputValue</span> a maintenant accès au contenu de mon input à tout moment. Je peux donc <span class="em">créer un bouton qui déclenche une alerte</span> qui affiche le contenu de mon input, comme ici :</p>
<pre><code>&lt;div&gt;
    &lt;textarea
        value={inputValue}
        onChange={(e) =&gt; setInputValue(e.target.value)}
    /&gt;
    &lt;button onClick={() =&gt; alert(inputValue)}&gt;Alertez moi 🚨&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>Et ça marche bien !</p>
                    <h3>Comprenez les avantages des formulaires contrôlés :</h3>
                    <p>Eh bien, cela permet d'<span class="em">interagir directement avec la donnée renseignée par l'utilisateur</span>. Vous pouvez donc afficher un message d'erreur si la donnée n'est pas valide, ou bien la filtrer en interceptant une mauvaise valeur.</p>
                    <p>Si nous décidons qu'il n'est pas autorisé d'utiliser la lettre "f" (bon oui, c'est un peu bizarre), eh bien nous pouvons déclarer une variable :</p>
<pre><code>const isInputError = inputValue.includes('f')</code></pre>
                    <p>et afficher ou non un message d'erreur en fonction de ce booléen :</p>
<pre><code>{isInputError && (
    &lt;div&gt;🔥 Vous n'avez pas le droit d'utiliser la lettre "f" ici.&lt;/div&gt;
)}</code></pre>
                    <p>De la même manière, nous pouvons intercepter une mauvaise valeur entrée par l'utilisateur. Pour cela, il faut déclarer une fonction intermédiaire :</p>
<pre><code>function checkValue(value) {
    if (!value.includes('f')) {
        setInputValue(value)
    }
}</code></pre>
                    <p>et on aplique la modification dans notre fonction callback :</p>
<pre><code>onChange={(e) =&gt; checkValue(e.target.value)}</code></pre>
                    <p>Ici, vous aure be.au marteler votre touche 'f' autant de fois que vous voudrez, la valeur ne s'inscrira pas dans votre input.</p>
                    <p>Vous ne vous en rendez peut-être pas compte pour l'instant, mais ça vous laisse une très grande liberté quant aux validations que vous voulez créer; et en tant que développeur, c'est vraiment très puissant.</p>
                    <p>Quand utiliser le composant contrôlé et quand utiliser sa version non contrôlée ? Eh bien cela dépen des cas. À vous de voir selon vos contraintes. Quand vous avez un composant rapide à faire, qui n'intègre aucuene complexité, un input non contrôlé peut faire l'affaire. À l'inverse, si vous avez des vérifications à faire, il vaudra sûrement mieux passer par un composant contrôlé. Pour ma part, j'ai vu beaucoup plus de composants contrôlés dans les codebases que j'ai pu voir.</p>
                    <p>Sachez qu'il existe également des bibliothèqyes qui vous permettent de gérer les formulaires et leur validation aussi proprement que possible, par exemple <a href="https://react-hook-form.com/" target="_blank">le très bon outil <span class="html">react-hook-form</span></a>.</p>
                    <p>Et voilà, vous êtes maintenant équipé pour interagir avec vos utilisateurs grâce aux événements et aux formulaires.</p>
                </article>
                <article>
                    <h2 id="stateful_components">Découvrez les stateful components :</h2>
                    <p>Le state local est présent à l'intérieur d'un composant et <span class="em">garde sa valeur, même si l'application le re-render</span>. On peut alors dire qu'il <span class="em">stateful</span>.</p>
                    <p>Dans <span class="html">Cart.js</span>, nous allons uniquement <span class="em">permettre aux utilisateurs d'ajouter des monsteras dans leur panier</span>, supprimons donc tout le reste.</p>
                    <p>Commençons par <span class="em">importer <span class="html">useState</span></span> avec :</p>
<pre><code>import { useState } from 'react'</code></pre>
                    <p>Puis, on peut <span class="em">créer un state <span class="html">cart</span></span>. Avec <span class="html">useState</span>, nous devons déclarer en même temps une fonction pour mettre à jour ce state (<span class="html">updateCart</span>), et lui attribuer une valeur initiale, qui sera ici de 0 :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Je vais maintenant pouvoir <span class="em">ajouter un bouton dans mon panier qui permet d'ajouter un monstera</span> avec la fonction que nous venons de déclarer. Ce qui me donne dans <span class="html">Cart.js</span> :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)

    return (
        &lt;div className='lmj-cart'&gt;
            &lt;h2&gt;Panier&lt;/h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Maintenant, si on clique sur "Ajouter", le montant total est modifié en fonction du nombre d'éléments sauvegardés dans le state du panier. Lorsqu'un state est modifié, alors l'affichage du composant est rafraichit et la valeur affichée est actualisée, on dit que le composant est re-render.</p>
                    <p>Bienvenue dans la magie du state ! Notre composant Cart est maintenant devenu un <span class="em">stateful component</span>, grâce à <span class="html">useState</span>.</p>
                    <p>Concrètement, cela veut dire que le composant Cart peut être re-render autant de fois que nécessaire, mais la valeur du panier sera préservée.</p>
                </article>
                <article>
                    <h2 id="useState">Familiarisez-vous avec useState :</h2>
                    <p><span class="html">useState</span> est un hook qui permet d'ajouter le state local React à des composants fonctions.</p>
                    <p>Un hook est <span class="em">une fonction qui permet de "se brancher" (to hook up) sur des fonctionnalités React</span>. On peut d'ailleurs les importer directement depuis React. Après useState, nous verrons un autre hook : <span class="html">useEffect</span>. Il existe d'autres hooks.</p>
                    <p>Nous l'avons déjà utilisé, mais je vous le remets ici :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Investiguons comment est construit notre state cart.</p>
                    <h3>Comprenez les crochets :</h3>
                    <p>Tout d'abord, les crochets <span class="html">[]</span>. Si cette syntaxe peut vous paraître un peu particulière, il s'agit en fait de la même pratique que nous avions vue précédemment : la déstructuration. Sauf qu'ici, ça s'appelle la <span class="em">décomposition</span> parce qu'il s'agit d'un <span class="em">tableau</span> et non d'un objet.</p>
                    <p><span class="html">useState</span> nous <span class="em">renvoie une paire de valeurs dans un tableau de 2 éléments</span>, que nous récupérons dans les variables <span class="em">cart</span> et <span class="em">updateCart</span> dans notre exemple. Le premier élément est la valeur actuelle, et le deuxième est une fonction qui permet de la modifier.</p>
                    <p>Sans la décomposition, nous aurions aussi pu faire :</p>
<pre><code>const cartState = useState(0)
const cart = cartState[0]
const updateCart = cartState[1]</code></pre>
                    <p>Dans un tableau qu'on décompose, nous pouvons librement nommer nos variables. J'aurais tout aussi bien pu faire :</p>
<pre><code>const [coucou, cavabien] = useState(0)</code></pre>
                    <h3>Initialisez votre state :</h3>
                    <p>Intéressons-nous maintenant au paramètre passé entre parenthèses à <span class="em">useState</span> : <span class="html">useState(0)</span>.</p>
                    <p>Comme je vous l'ai dit, il correspond à l'<span class="em">état initial de notre state</span>. Cet état initial peut être un nombre comme ici, une string, un booléen, un tableau ou encore un objet avec plusieurs propriétés.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Il est important de préciser une valeur initiale dans votre state. Sinon, elle sera <span class="em">undefined</span> par défaut, et ce n'est pas un comportement souhaitable : plus vous serez explicite, mieux votre application s'en portera !</p>
                    </div>
                    <h3>Créez plusieurs variables d'état :</h3>
                    <p>Nous allons encore améliorer notre panier. Cette fois-ci, je veux pouvoir <span class="em">choisir de l'afficher ou de le cacher</span>. Pour ça, nous allons utiliser une variable d'état dans notre composant Cart.</p>
                    <p>S'il y en a déjà une, comment en créer une autre ? Pas de panique. Il y a plusieurs moyens de faire. Mais le plus simple est d'utiliser plusieurs variables d'état.</p>
                    <p>Dans notre cas, il suffit de <span class="em">créer une variable <span class="html">isOpen</span> associée avec la fonction <span class="html">setIsOpen</span></span>, et de l'initialiser à false :</p>
<pre><code>const [isOpen, setIsOpen] = useState(false)</code></pre>
                    <p>Pour pouvoir interagir, on crée ensuite :</p>
                    <ul>
                        <li>
                            <p><span class="em">un bouton pour ouvrir</span> le panier qui sera le seul composant retourné par Cart si le panier est fermé;</p>
                        </li>
                        <li>
                            <p>et <span class="em">un bouton pour fermer</span> le panier.</p>
                        </li>
                    </ul>
                    <p>Cela nous donne le code suivant :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)
    const [isOpen, setIsOpen] = useState(false)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button onClick={() =&gt; setIsOpen(false)}&gt;Fermer&lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() => updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    ) : (
        &lt;button onClick={() =&gt; setIsOpen(true)}&gt;Ouvrir le Panier&lt;/button&gt;
    )
}

export default Cart</code></pre>
                    <p>En ajoutant un peu de style, j'ai donc :</p>
                    <figure>
                        <img src="../images/panier_lmj_React.jpg" alt="">
                        <figcaption>Le panier du site de la maison jungle</figcaption>
                    </figure>
                    <p>Vous voyez ? Pas de soucis à créer plusieurs variables d'état dans un même composant !</p>
                    <p>C'est bien beau, nous avons nos composants avec leur state local. Notre panier permet d'ajouter des monsteras, et le total du panier se calcule en fonction.</p>
                    <p>Mais comment faire pour <span class="em">changer le comportement d'un composant en fonction du state d'un autre composant</span> ? Par exemple, si je veux enfin ajouter un lien entre mon <span class="em">Cart</span> et mon composant <span class="em">ShoppingList</span>. Je peux créer un bouton "Ajouter au panier" dans chaque <span class="em">PlantItem</span>... Mais comment faire pour venir compléter mon panier en fonction ?</p>
                </article>
                <article>
                    <h2 id="remonter_etat_maj_composants_enfants">Faites remonter l'état et mettez-le à jour depuis vos composants enfants :</h2>
                    <p>Comme son nom l'indique, un state local... est local. Ni les parents, ni les enfants ne peuvent manipuler le state local d'un composant (ils n'en ont pas la possibilité technique).</p>
                    <p>Pour partager un élément d'état entre plusieurs composants, il faudra <span class="em">faire remonter ces données</span> vers le state local du <span class="em">plus proche composant qui est un parent commun</span>, et y garder le state. À partir de là, il sera possible de :</p>
                    <ul>
                        <li>
                            <p>Faire <span class="em">redescendre</span> ces infos avec des props jusqu'aux composants qui en ont besoin.</p>
                        </li>
                        <li>
                            <p>Faire <span class="em">"remonter" les demandes d'update</span> toujours dans les props. Pour cela, on peut utiliser la fonction de mise à jour du state récupérée dans useState, en la passant en props aux composants qui en ont besoin.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/remonter_maj_parents_props_React.png" alt="">
                        <figcaption>Remonter les mises à jour aux parents dans les props</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous vous demandez peut-être quelles sont les bonnes pratiques : où mettre le state ? Dans le composant parent, ou le composant enfant ? Eh bien, dans la pratique... ça dépend totalement. Il est considéré comme plus propre de garder la logique au maximum dans les composants parents, et que les enfants ne servent qu'à afficher les éléments en props. Mais dans de nombreux cas, il est bien mieux de garder le state dans le composant enfant. Vous apprendrez à le voir avec le temps et l'expérience.</p>
                    </div>
                    <p>Attaquons-nous donc à notre exemple.</p>
                    <p>Je commence à <span class="em">faire remonter <span class="html">cart</span> dans <span class="html">App.js</span></span> :</p>
<pre><code>function App() {
    const [cart, updateCart]  useState(0)

    return (
        &lt;div&gt;
            &lt;Banner&gt;
                &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
                &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
            &lt;/Banner&gt;
            &lt;div className='lmj-layout-inner'&gt;
                &lt;Cart cart={cart} updateCart={updateCart} /&gt;
                &lt;ShoppingList cart={cart} updateCart={updateCart} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}

export default App</code></pre>
                    <p>Et toujours dans <span class="html">App.js</span> dans le JSX, je <span class="em">passe <span class="html">cart</span> ainsi que <span class="html">updateCart</span> en props</span> :</p>
<pre><code>&lt;Cart cart={cart} updateCart={updateCart} /&gt;</code></pre>
                    <p>... <span class="em">que je récupère dans <span class="html">Cart.js</span></span>. Vous vous souvenez de la déstructuration ? Ça nous permet de récupérer notre prop en une ligne.</p>
                    <p>J'en profite pour supprimer mon bouton "Ajouter" dans <span class="html">Cart.js</span>.</p>
                    <p>On a donc un panier un peu vide :</p>
<pre><code>function Cart({ cart, updateCart }) {
    const monsteraPrice = 8
    const [isOpen, setIsOpen] = useState(true)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(false)}
            &gt;
                Fermer
            &lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
            &lt;button onClick={() =&gt;updateCart(0)}&gt;Vider le panier&lt;/button&gt;
        &lt;/div&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Du côté de <span class="html">ShoppingList</span>, je <span class="em">lui passe <span class="html">updateCart</span></span>. Je <span class="em">le récupère ensuite dans <span class="html">ShoppingList.js</span></span>.</p>
                    <p>Je <span class="em">change ensuite ma liste de plantes</span> pour avoir (toujours dans <span class="html">ShoppingList.js</span>) :</p>
<pre><code>function ShoppingList({ cart, updateCart }) {
    // Petite précision : categories permet de récupérer toutes les catégories uniques de plantes.

    const categories = plantList.renduce(
        (acc, elem) =&gt;
            acc.includes(elem.category) ? acc : acc.concat(elem.category),
            []
    )

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Et voilà ! Maintenant, vous pouvez updater votre panier directement en cliquant sur un bouton lié à chaque plante.</p>
                    <p>Vous voyez, ce n'est pas si compliqué, il a suffit de :</p>
                    <ul>
                        <li>
                            <p>faire remonter notre state;</p>
                        </li>
                        <li>
                            <p>faire descendre le contenu de notre state et la fonction pour l'updater;</p>
                        </li>
                        <li>
                            <p>déclencher la mise à jour de notre state avec une interaction utilisateur (ici le clic sur le bouton).</p>
                        </li>
                    </ul>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous sommes sur une petite application : il n'y a qu'une seule page et nous partageons le state directement entre parents et enfants. Mais ça peut vite devenir le bazar pour une plus grosse application. C'est pourquoi la notion de state management va beaucoup plus loin. Il existe des outils dédiés au State Management tels que Flux, Redux ou des solutions natives comme React Context.</p>
                    </div>
                    <p>Nous avons vu comment partager des éléments du state entre plusieurs composants. Nous allons maintenant adapter notre application pour que le panier se comporte de manière un peu plus réaliste.</p>
                    <p>L'idée ici est que <span class="em">notre state stocke quels types</span> de plantes ont été ajoutés, <span class="em">en quelle quantité</span>, et <span class="em">de mettre à jour le montnat total</span> en fonction du prix.</p>
                    <p>Première étape : ajouter le prix à chaque plante dans le fichier <span class="em">plantList.js</span>.</p>
                    <p>Dans le fichier <span class="em">App.js</span>, on modifie le state <span class="em">cart</span> pour que ce soit un tableau comme ceci :</p>
<pre><code>const [cart, updateCart] = useState([])</code></pre>
                    <p>Troisième étape : on modifie le fichier <span class="em">Cart.js</span> pour itérer sur les <span class="em">cart</span> comme ceci :</p>
<pre><code>import { useState } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )
    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        &lt;h2&gt;Panier&lt;/h2&gt;
        {cart.map(({ name, price, amount}, index) =&gt; (
            &lt;div key={`${name}-${index}`}&gt;
                {name} {price}€ x {amount}
            &lt;/div&gt;
        ))}

        &lt;h3&gt;Total : {total}€&lt;/h3&gt;
        &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Enfin, dernière étape : on fait une modification dans le fichier <span class="em">ShoppingList.js</span> pour ajouter la fonction <span class="html">addToCart(...)</span> comme ci-dessous :</p>
<pre><code>import '../styles/ShoppingList.css'

function ShoppingList({ cart, updateCart }) {
    
    const categories = plantList.renduce(
        (acc, plant) =&gt;
            acc.includes(plant.category) ? acc : acc.concat(plant.category),
            []
    )

    function addToCart(name, price) {
        const currentPlantAdded = cart.find((plant) =&gt; plant.name === name)
        if (currentPlantAdded) {
            const cartFilteredCurrentPlant = cart.filter(
                (plant) =&gt; plant.name !== name
            )
            updateCart([
                ...cartFilteredCurrentPlant = cart.filter(
                    (plant) =&gt; plant.name !== name
                )
                updateCart([
                    ...cartFilteredCurrentPlant,
                    { name, price, amount: currentPlantAdded.amount + 1 }
                ])
            ])
        } else {
            updateCart([...cart, { name, price, amount: 1 }])
        }
    }

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; addToCart(name, price)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Notre panier fait maintenant une liste des articles sélectionnés, et met à jour le total en fonction des plantes sélectionnées et de leur prix.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Est-ce que vous avez remarqué que lorsqu'on change le state, on crée un nouvel objet avec le spread operator ? C'est normal : le state est immutable, c'est-à-dire qu'il ne faut pas le modifier directement.</p>
                    </div>
                </article>
                <article>
                    <h2 id="useEffect">Déclenchez des effets avec useEffect :</h2>
                    <p>Est-ce que je vous ai déjà parlé du render (rendu) d'une application React ?</p>
                    <p>Dès qu'une modification intervient dans une prop ou le state, le composant concerné et ses enfants sont re-render.</p>
                    <p>Mais comment faire si on on veut effectuer une action qui ne fait pas partie du return ? Qui intervient après que React a mis à jour le DOM ? Par exemple, si vous voulez déclencher une alerte à chaque fois que votre panier est mis à jour ? Ou bien même pour sauvegarder ce panier à chaque mise à jour ?</p>
                    <p>Eh bien, ces types d'actions s'appellent des effets de bord, et pour cela, nous avons <span class="html">useEffect</span>. Ils nous permettent d'effectuer une action à un moment donné du cycle de vie de nos composants.</p>
                    <p>Disons que je veux <span class="em">créer une alert lorsque j'ajoute une plante à mon panier</span>, et que cette alerte <span class="em">affiche le montant total du panier</span>.</p>
                    <p>Pour ça, une petite ligne de code suffit dans <span class="em">Cart.js</span> :</p>
<pre><code>alert(`J'aurai ${total}€ à payer`)</code></pre>
                    <p>On la met donc directement dans notre composant, avant le <span class="em">return</span>. Mais, quand je clique, ça bloque mon code et ma valeur ne s'affiche qu'une fois que j'ai cliqué sur "OK" !</p>
                    <p>À la place, on va utiliser <span class="html">useEffect</span>.</p>
                    <p><span class="em">Importez-le</span> comme nous l'avons fait avec <span class="html">useState</span> dans <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'</code></pre>
                    <p>et <span class="em">utilisez ce snippet à la place</span> (toujours dans <span class="em">Cart.js</span>) :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
})</code></pre>
                    <p>Ce qui nous donne pour <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )

    useEffect(() =&gt; {
        alert(`J'aurai ${total}€ à payer`)
    })

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        {cart.length &gt; 0 ? (
            &lt;h2&gt;Panier&lt;/h2&gt;
            {cart.map(({ name, price, amount}, index) =&gt; (
                &lt;div key={`${name}-${index}`}&gt;
                    {name} {price}€ x {amount}
                &lt;/div&gt;
            ))}

            &lt;h3&gt;Total : {total}€&lt;/h3&gt;
            &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;            
        ) : (
            &lt;div&gt;Votre panier est vide&lt;/div&gt;
        )}
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Et voilà ! Tout se passe comme espéré, pour la simple et bonne raison que <span class="html">useEffect</span> nous permet d'<span class="em">effectuer notre effet une fois le rendu du composant terminé</span>. Et comme <span class="html">useEffect</span> est directement dans notre composant, nous avons directement accès à notre state, à nos variables, nos props, magique n'est-ce pas ?</p>
                    <p>Quand je ferme mon, mon alerte se déclenche aussi ! Eh bien c'est normal : je vous ai dit que <span class="html">useEffect</span> se déclenche après le rendu. Eh bien il se déclenche après <span class="em">CHAQUE</span> rendu du composant. Sauf si vous...</p>
                    <h3>Précisez quand déclencher une effect avec le tableau de dépendances :</h3>
                    <p>Pour décider précisément quand on veut déclencher un effet, on peut utoliser le tableau de dépendances. Il correspond au deuxième paramètre passé à <span class="html">useEffect</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Petit rappel : le premier paramètre passé à useEffect est une fonction.</p>
                    </div>
                    <p>Cette fonction correspond à l'<span class="em">effet à exécuter</span>. Ici, il s'agit de :</p>
<pre><code>() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}</code></pre>
                    <p>Le deuxième paramètre de <span class="html">useEffect</span> accepte <span class="em">un tableau noté entre crochets</span> : il s'agit du tableau de dépendances.</p>
                    <p>Dans notrre cas, si je veux que l'<span class="em">alerte ne s'affiche que lorsque le total de mon panier change</span>, il me suffit de faire :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}, [total])</code></pre>
                    <p>Vous pouvez mettre n'imprte quelle variable ici. Si vous voulez afficher l'alerte quand le total change OU quand une nouvelle catégorie est sélectionnée, vous pourriez tout à fait :</p>
                    <ul>
                        <li>
                            <p>récupérer la catégorie sélectionnée (en faisant remonter <span class="html">activeCategory</span> et <span class="html">setActiveCategory</span> et en les passant en props);</p>
                        </li>
                        <li>
                            <p>puis mettre <span class="html">[total, activeCategory]</span> dans votre tableau de dépendances.</p>
                        </li>
                    </ul>
                    <p>L'alerte s'affiche bien quand la catégorie change ou bien quand le total change.</p>
                    <p>Est-ce que l'effet est lancé au tout premier render de mon composant ? Oui, l'alerte s'affiche.</p>
                    <p>Comment faire pour exécuter un effet uniquement après le premier render de mon composant ? Par exemple, si je veux récupérer des données sur une API ? Eh bien, dans ce cas, il faut <span class="em">renseigner un tableau de dépendances vide</span> :</p>
<pre><code>useEffect(() =&gt; {
    alert('Bienvenue dans La maison jungle')
}, [])</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>À partir du moment où vous utilisez le tableau de dépendances, faites attention à ne pas ouvlier des dépendances, ou bien à ne pas en laisser qui n'ont plus rien à y faire, pour éviter d'exécuter à des moments inopportuns.</p>
                    </div>
                    <h3>Modifiez le titre de votre onglet :</h3>
                    <p>Bon, moi je commence à en avoir un peu marre de toutes ces alertes. J'ai plutôt envie d'utiliser <span class="html">useEffect</span> pour <span class="em">mettre à jour le titre de l'onglet de mon navigateur</span>.</p>
                    <img src="../images/titre_onglet_React_1.png" alt="">
                    <p>Vous voyez de quoi je parle ?</p>
                    <p>On va donc <span class="em">utiliser <span class="html">document.title</span></span> toujours dans <span class="em">Cart.js</span>, comme ici :</p>
<pre><code>useEffect(() =&gt; {
    document.title = `LMJ : ${total}€ d'achats`
}, [total])</code></pre>
                    <p>Et voilà ! Le litre de notre onglet change en fonction du total de notre panier !</p>
                    <figure>
                        <img src="../images/titre_onglet_React_2.png" alt="">
                        <figcaption>useEffect modifie le titre de notre onglet pour la maison jungle.</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="regles_useEffect">Maîtrisez les règles de useEffect :</h2>
                    <h3>Intégrez les différentes étapes de useEffect :</h3>
                    <p>Repassons sur ce qu'on vient de voir de useEffect :</p>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche à chaque rendu`)
})</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche au premier rendu`)
}, [])</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche la première fois et quand mon panier est mis à jour`)
}, [cart])</code></pre>
                    <p>Il est pssoble d'effectier une action quand React démonte le composant en le retirant du DOM. Dans notre <span class="em">App.js</span>, on rajoute le state :</p>
<pre><code>const [isFooterShown, updateIsFooterShown] = useState(true)

{isFooterShown && &lt;Footer cart={cart} /&gt;}</code></pre>
                    <p>Ensuite, dans notre <span class="em">Footer.js</span>, on utilise le <span class="html">useEffect</span> suivant :</p>
<pre><code>useEffect(() =&gt; {
    return () =&gt;
        console.log(`Cette alerte s'affiche quand Footer est retiré du DOM`)
})</code></pre>
                    <p>Cela nous permet d'effectuer un "nettoyage" de notre effet. En effet, il est indispensable de nettoyer certains effets au <span class="em">unmount</span> (démontage) d'un composant pour éviter les fuites de mémoire, typiquement si on utilise <span class="html">setInterval</span>. Nous n'aurons pas besoin de tels effets pour le moment.</p>
                    <h3>Intégrez quelques règles :</h3>
                    <p>Comme je vous l'ai expliqué précédemment, <span class="html">useEffect</span> est un <span class="em">hook</span>, une fonction qui permet de "se brancher" sur la fonctionnalité des effets de React. Mais quelques règles s'appliquent au hook <span class="html">useEffect</span> :</p>
                    <ul>
                        <li>
                            <p>Appelez toujours <span class="html">useEffect</span> à la <span class="em">racine de votre composant</span>. Vous ne pouvez pas l'appeler à l'intérieur de boucles, de code conditionnel ou de fonctions imbriquées. Ainsi, vous vous assurez d'éviter des erreurs involontaires.</p>
                        </li>
                        <li>
                            <p>Comme pour <span class="html">useState</span>, <span class="html">useEffect</span> est uniquement accessible dans un <span class="em">composant fonction React</span>. Donc ce n'est pas possible de l'utiliser dans un composant classe, ou dans une simple fonction JavaScript.</p>
                        </li>
                    </ul>
                    <p>Par ailleurs, je vous conseille de séparer les différentes actions effectuées dans différents useEffect. Cela est plutôt une bonne pratique qu'une règle.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les hooks sont assez récents. Les développeurs React y ont accès depuis début 2019. Avant, il n'était pas possible d'accéder au state ni aux effets depuis des composants fonctions. Si on voulait utiliser un effet de bord ou l'état local; il fallait forcément passer par un <span class="em">class component</span>. Vous pouvez vous estimer heureux d'avoir accès aux hooks dès le début de votre apprentissage de React, car ils représentent plusieurs avanatages pour les développeurs et développeuses :</p>
                        <ul>
                            <li>
                                <p>ils nécessitent d'écire moins de code;</p>
                            </li>
                            <li>
                                <p>ils sont donc plus faciles à tester;</p>
                            </li>
                            <li>
                                <p>mais également plus lisibles.</p>
                            </li>
                        </ul>
                    </div>
                </article>
                <article>
                    <h2 id="creation_application_React_complete">Créez une application React complète :</h2>
                    <h3>Installez votre app avec Create React App :</h3>
                    <p>Pour initialiser notre application, nous allons utiliser Create React App (CRA).</p>
                    <p>Dans votre terminal, placez-vous dans le dossier où vous souhaitez créer votre projet et faites la commande suivante :</p>
<pre><code>npx create-react-app shiny-agency</code></pre>
                    <h3>Architecturez votre projet par modules :</h3>
                    <p>Maintenant que nous avons la base de notre projet, nous allons pouvoir nous décider sur son architure.</p>
                    <p>Pas de panique ! Ici, je ne vais pas vous parler de patterns complexes. L'idée est juste de suivre des règles logiques et suffisamment claires pour que vous sachiez où placer les fichiers que vous créez, et où retrouver ceux dont vous avez besoin dans votre codebase. D'ailleurs, dans la documentation React <a href="https://fr.reactjs.org/docs/faq-structure.html" target="_blank">sur la structure de fichiers</a>, React laisse la liberté aux développeurs quant à la structure de leur projet.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Lorsque vous utilisez des frameworks tels que <a href="https://nextjs.org/" target="_blank">Next</a> ou <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a> une structure de fichiers toute faite vous sera déjà proposée. je vous conseille d'y jeter un oeil si vous avez l'occassion !</p>
                    </div>
                    <p>Précédemment, nous avions organisé le code de sorte à regrouper les fichiers par type : chaque fiche correspondait à un composant situé dans le dossier <span class="html">/components</span>. Les fichiers CSS, quant à eux, se trouvaient dans le dossier <span class="html">/style</span>, etc.</p>
                    <p>Ici, nous allons organiser nos fichiers en suivant la même logique, sauf qu'il faudra ajouter un dossier pour les "pages", qui regroupera les composants vers lesquels chacune de nos routes renverra (pas de panique si vous ne savez pas ce qu'est une route).</p>
                    <p><span class="em">Commençons</span> donc par créer un dossier <span class="html">/components</span> et un dossier <span class="html">pages</span> dans <span class="html">src</span>. Dans <span class="html">/pages</span>, on créé un dossier <span class="html">Home</span> et l'on y insère <span class="html">App.js</span>, qu'on renomme en <span class="html">index.jsx</span>. On peut ensuite supprimer tous les fichiers que nous n'utiliserons pas.</p>
                    <p>Ce qui nous donne...</p>
<pre><code>├── README.md
├── node_modules
...
├── package.json
├── public
...
├── src
│   ├── index.js
│   ├── components
│   └── pages
│       └── Home
│            └── index.jsx 
└── yarn.lock</code></pre>
                    <p>Ici, pas d'obligation d'utiliser l'extension <span class="html">.jsx</span>. Votre fichier React fonctionnera très bien aussi avec une extension <span class="html">.js</span>, mais puisqu'on peut l'utiliser, autant être explicite, n'est-ce pas ? Ainsi, vous voyez en un coup d'oeil quand votre fichier du React, et quand il n'en contient pas.</p>
                    <p>Ce qui est important pour nous est de pouvoir retrouver rapidement nos fichiers. Pour les architectures, il n'existe pas de solution parfaite à utiliser dans tous les cas. Nous devons donc essayer de trouver une organisation qui convienne. Ici, nous aurons relativement peu de fichiers, donc une structure par type devrait bien fonctionner.</p>
                    <p>On n'oublie pas de <span class="em">mettre à jour les paths des imports</span>, par exemple dans <span class="html">index.js</span> à la racine de src :</p>
<pre><code>import Home from './pages/Home/';</code></pre>
                    <p>Les approches sont multiples. Lorsque vous travaillez sur une application complexe, avec plusieurs grosses fonctionnalités, vous pouvez envisager un découpage selon les <span class="em">fonctionnalités</span>, par exemple. Vous trouverez un petit exemple de ce type d'organisation dans <a href="https://fr.reactjs.org/docs/faq-structure.html#grouping-by-features-or-routes" target="_blank">la documentation React</a>.</p>
                    <p>Un autre type d'organisation qui fonctionne bien ces dernières années est la création et l'organisation des composants selon les principes de l'<span class="em">atom design</span>, qui facilite la collaboration avec les designers. mais dans notre cas, l'application n'a pas vocation à être très grande, et l'utilisation d'une telle structure pourrait paraître superflue. C'est pourquoi nous avons choisi d'organiser le projet de ce cours par type de fichier, afin de s'approcher au maximum de ce qui aurait été fait en entreprise.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Dans notre codebase, nous allons organiser nos fichiers de sorte à avoir <span class="html">/NomDuComposant/index.jsx</span>. Cette pproche présente des avantages (notamment de ne pas avoir à nous répéter lorsqu'on importe nos fichiers), mais peut aussi paraître un peu désorganisée dans tous vos onglets d'IDE. Comme pour tout en code, il existe plusieurs manières de faire; à vous de voir ce qui vous convient, et de vous adapter lorsque vous travaillez sur une codebase qui est un peu différente. Si ce sujet vous intéresse, vous pourrez en apprendre davantage sur l'organisation et le nommage des fichiers <a href="https://bradfrost.com/blog/post/this-or-that-component-names-index-js-or-component-js/" target="_blank">dans cet article (en anglais)</a>.</p>
                    </div>
                    <p>Et voilà pour notre architecture ! Penchons-nous maintenant sur quelques outils qui nous permettent d'écrire du code plus proprement et d'éviter des erreurs communes.</p>
                    <h3>Exploitez les outils ESLint et Prettier :</h3>
                    <p>Pour ce qui est des erreurs de code, ou tout simpelment de la mise en forme, vous le savez sûremnt déjà, JavaScript est très <span class="em">souple</span> : pas de compilation stricte qui vous signale vos erreurs. Heureusement, il existe des outils qui permettent d"crire du code plus propre !</p>
                    <p>Vous vous posez la question suivante : <q>Écrire du code plus proprement ? Pourquoi prendre du temps à configurer des outils, alors que je m'en sors très bien comme ça ?</q> Eh bien, vous vous en sortez bien actuellement, sur une codebase plutôt petite et en travaillant seul. Mais imaginez que vous travaillez dans une équipe, dans laquelle chacun a son <span class="em">propre style de code</span> (mettre des points-virgules ou non, les règles d'indentation, etc.). Croyez-moi, ce n'est vraiment pas efficace.</p>
                    <p>Dans notre cas, nous allons nous intéresser à <span class="html">ESLint</span>, qui va vous signaler des erreurs dans le code (aussi bien des erreurs de style que des erreurs basiques de code qui peuvent conduire à des bugs), et <span class="html">Prettier</span>, qui va le formater.</p>
                    <h4>Sécurisez votre code avec ESLint et son extension :</h4>
                    <p>Commençons donc par ESLint.</p>
                    <p>Si vous regardez votre <span class="html">package.json</span>, vous verrez qu'ESLint fait déjà partie des outils préconfigurés par Create React App. Cet outil permet de vous signaler des erreurs de code - si vous utilisez une variable qui n'a jamais été déclarée, par exemple.</p>
                    <p>Testons dès maintenant. Dans <span class="html">Home/index.jsx</span>, je rajoute une ligne de code en faisant un console.log d'une variable non déclarée avant le <span class="html">return</span> :</p>
<pre><code>console.log(ceciEstUneErreur)</code></pre>
                    <p>Rien de spécial ne s'affiche. Pourtant, la variable n'est pas déclarée, donc c'est bien une erreur.</p>
                    <p>... Mais si vous n'avez pas encore installé l'extension ESLint dans votre éditeur de code (IDE), rien ne se passe.</p>
                    <p>Installons donc l'extension. Pour ma part, j'utilise VS Code qui me permet d'installer une extension directement dans l'onglet "Extensions" (cela dépend de l'IDE que vous utilisez). Une fois l'extension installée, votre éditeur de code devrait souligne votre erreur, comme ici.</p>
                    <figure>
                        <img src="../images/ESLint_React.png" alt="">
                        <figcaption>La voilà notre erreur !</figcaption>
                    </figure>
                    <p>Et voilà, la configuration est prête. On peut configurer manuellement ESLint en créant le fichier <span class="html">.eslintrc</span> avec le contenu suivant :</p>
<pre><code>{
    "extends": ["react-app"],
    "rules": {
        "no-console": "error"
    }
}</code></pre>
                    <p>On peut également utiliser la configuration ESLint de Airbnb qui peut être installé via <span class="html">npx</span>.</p>
                    <h4>Formatez votre code avec Prettier :</h4>
                    <p>Alors qu'ESLint vous permet de relever des erreurs de syntaxe, Prettier est la référence pour formater votre code. Contrairement à ESLint, Prettier n'est pas installé de base avec Create-React-App.</p>
                    <p>Pour vous donner une idée de la puissance de cet outil, regardez un peu ce GIF :</p>
                    <figure>
                        <img src="../images/Prettier_React.gif" alt="">
                        <figcaption>Bien pratique de tout formater en un clic, n'est-ce pas ?</figcaption>
                    </figure>
                    <p>Pas mal, n'est-ce pas ? Alors, lançons-nous dans la config ! Pour commencer, vous pouvez installer la library (bibliothèque) dans votre terminal avec <span class="html">yarn add -D prettier</span>.</p>
                    <p>À partir de là, l'outil est installé, mais nous devons le lancer manuellement - alors que nous voulons que Prettier fasse tout à notre place sans même avoir à y penser ! La manière la plus simple est d'installer l'extension de Prettier directement dans les extensions de votre IDE.</p>
                    <p>Pour ma part, dans VSCode, j'installe l'extension.</p>
                    <figure>
                        <img src="../images/extension_Prettier_VSCode.png" alt="">
                        <figcaption>L'extension Prettier dans VSCode</figcaption>
                    </figure>
                    <p>Il vous suffit d'aller dans les paramètres de votre IDE (<span class="html">Code</span> &gt; <span class="html">Preferences</span> &gt; <span class="html">Settings</span> dans VSCode pour Windows) pour activer la commande <span class="html">formatOnSave</span>. Elle permettra de formater le fichier à chaque fois que vous sauvegardez.</p>
                    <p>Vous pouvez également aller dans la barre de recherche de votre IDE, taper "format" et activer <spab class="html">formatOnSave</spab> :</p>
                    <figure>
                        <img src="../images/formatOnSave.png" alt="">
                        <figcaption>Le parametrage à activer dans VSCode pour formater en sauvegardant</figcaption>
                    </figure>
                    <p>Mais attendez, on n'a pas encore fini ! Nous allons aussi activer l'option qui permet d'éviter de modifier tous les fichiers à tort et à travers.</p>
                    <p>Tapez <span class="html">require config</span> ey descendez sur le paramètre correspondant à Prettier. Activez le paramètre comme ci-dessous :</p>
                    <figure>
                        <img src="../images/require_config.png" alt="">
                        <figcaption>Activez cette option dans vos paramètres pour formater uniquement les fichiers qui ont une config Prettier.</figcaption>
                    </figure>
                    <p>Cela permet de préciser à VSCode de formater le fichier uniquement quand une configuration est présente dans le projet pour Prettier.</p>
                    <p>Donc à nous d'en créer une !</p>
                    <p>À la racine de votre projet, créez un fichier <span class="html">.prettierrc</span> dans lequel vous allez pouvoir préciser quelques règles. Vous trouverez l'ensemble de ces règles dans <a href="https://prettier.io/docs/en/options.html" target="_blank">la documentation de Prettier</a>. typiquement, si vous voulez supprimer tous les points-virgules, vous faites :</p>
<pre><code>{
    "semi": false
}</code></pre>
                    <p>Et voilà, si vous retournez dans votre fichier <span class="html">Home/index.jsx</span>, vous aurez bien du code sans les points-virgules !</p>
                    <p>Félicitations ! Vous venez de configurer avec succès ESLint et Prettier avec leurs extensions, vous n'aurez plus à vous soucier du formatage de votre code ou bien de faire des erreurs d'inattention !</p>
                </article>
                <article>
                    <h2 id="SPA">Transformez votre application en Single Page Application avec React Router :</h2>
                    <h3>Comprenez le principe de SPA :</h3>
                    <p>Prenons notre machine à voyager dans le temps et retournons aux débuts du Web.</p>
                    <p>À cette époque, l'immense majorité des sites consistaient en un groupe de pages, envoyées par le serveur, qui s'affichaient en fonction de la navigation. Pour chaque interaction, telle que l'envoi d'un formulaire, la page entière devait être rechargée.</p>
                    <p>Mais au début des abbées 2000, le concept de Single Page Application (SPA) commence à émerger. Les idées principales derrière ce concept sont les suivantes :</p>
                    <ul>
                        <li>
                            <p>les utilisateurs ne chargent une page Web qu'une seule fois (le fameux <span class="html">index.html</span>).</p>
                        </li>
                        <li>
                            <p>Au lieu de récupérer toute la page avec une page avec une requête HTTP, on les récupère de manière distincte, petite partie par petite partie, ce qui permet à l'utilusateur d'interagir de manière beaucoup plus dynamique.</p>
                        </li>
                        <li>
                            <p>L'utilisateur peut naviguer entre plusieurs pages et JavaScript (et dans notre cas, React) gère l'affichage de nouvelles pages au sein du même domaine, sans qu'un rafraîchissement complet de la page soit nécessaire.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/site_Web_classique_SPA.png" alt="">
                        <figcaption>L'affichage du site Web classique en haut est moins dynamique que celui de la SPA en bas.</figcaption>
                    </figure>
                    <p>Toutes les applications ne sont pas nécessairement des SPA. Lorsque vous codez votre site en Single Page Application, il faut être conscient de certains inconvénients : vos utilisateurs doivent notamment impérativement avoir JavaScript pour que votre site fonctionne, ou encore le Search Engine Optimisation (SEO, l'optimisation de l'indexation de votre site par les moteurs de recherche) est plus laborieux pour les Single Page Applications.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Je vous ai déjà parlé de Gatsby ou bien Next.js. Il s'agit de frameworks basés sur React qui permettent de générer notre application côté serveuur et donc de faire du <span class="em">Server Side Rendering</span> (SSR). C'est-à-dire qu'ils génèrent le HTML depuis React côté serveur et puis l'envoient avec chaque page déjà générée au client. Pour ce qui est de leur <span class="em">routing</span>, ils mettent leur propre solution à disposition. Elle se comporte comme du routing de SPA au niveau de l'expérience utilisateur, mais qui est un peu plus complexe qu'il n'y paraît.</p>
                    </div>
                    <p>Les projets que nous créons avec Create React App ne peuvent pas encore être considérés comme des Single Page Applications : il leur manque une solution de <span class="em">routing</span>.</p>
                </article>
                <article>
                    <h2 id="react_router">Découvrez React Router :</h2>
                    <p>Contrairement aux frameworks comme Angular, React ne nous fournit pas directement une solution pour gérer les routes de notre application. Pas de panique, comme pour quasiment tout en React, l'écosystème a vite comblé ce besoin. Il existe donc plusieurs solutions de routing. Cela à laquelle nous allons nous intéresser dans la suite est <a href="https://reactrouter.com/" target="_blank">React Router</a> (le nom est plutôt bien trouvé, n'est-ce pas ?).</p>
                    <p>Comme nous pouvons le voir dans <a href="https://reactrouter.com/en/6.8.1/start/concepts#defining-routes" target="_blank">la documentation React Router</a>, une route permet d'afficher des composants de manière conditionnelle si le path (chemin) de l'URL correspond au path de la route.</p>
                    <p>On lui passe en prop le path auquel la route correspond et elle se charge d'afficher les children qui lui sont passés.</p>
                    <p>Cette bibliothèqye, créée par <a href="https://remix.run/" target="_blank">Remix</a>, met à votre disposition tous les outils nécessaires pour gérer la navigation dans votre appliction côté client.</p>
                    <p>Alors, partons à la découverte de React Router.</p>
                    <h3>Créez votre prmeier fichier de routing :</h3>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>React Router est très régulièrement mis à jour. La version utilisée pour faire ce cours est la <span class="em">V6</span>. Pour suivre ce cours, vous pourrez préciser la version que vous souhaitez installer directement dans la ligne de commande pour installer le package. Ici nous installerons la version 6.10.0.</p>
                        <p>N'hésitez pas à <a href="https://reacttraining.com/blog/" target="_blank">consulter le blog de React Router</a> pour en apprendre davantage sur les différentes versions et leurs actualités.</p>
                    </div>
                    <p>Nous allons commencer par installer la bibliothèque avec <span class="html">yarn add react-router-dom@6.10.0</span>. Si vous voulez en apprendre davantage sur la configuration, n'hésitez pas à jeter un oeil à <a href="https://reactrouter.com/en/6.10.0/start/tutorial" target="_blank">la documentation de React Router</a>.</p>
                    <p>React Router est maintenant prêt à être utilisé !</p>
                    <p>Actuellement, nous n'avons qu'une seule fonctionnalité avec <span class="html">Home</span>. Créons dès maintenant un nouveau composant pour le questionnaire.</p>
                    <p>Pour cela, on crée un dossier, on crée un dossier <span class="html">SUrvey.jsx</span> dans <span class="html">pages</span>. Pour le moment, gardons un composant très simple :</p>
<pre><code>function Survey() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Survey</code></pre>
                    <p>Votre mission, si vous l'acceptez, est de pouvoir <span class="em">naviguer entre la page d'accueil - Home - et le questionnaire - Survey</span>.</p>
                    <p>Vous vous en doutez sûrement : nous allons utiliser React Router et ses composants BrowserRouter, Routes et Route !</p>
                    <p>Dans l'exemple ci-dessous, on renomme <span class="html">BrowserRouter</span> en <span class="html">Router</span> pour une lecture plus simple. Il servira à stocker et à s'abandonner au changement de l'URL de la page courante (celle qu'on retrouve dans la barre d'URL).</p>
                    <p>Ensuite, nous ajoutons le composant <span class="em">Routes</span> qui va servir à sélectionnner le composant enfant correspondant à la location.</p>
                    <p>Finalement, le composant le plus complexe, le composant <span class="em">Route</span>. Ce composant prend de base plusieurs paramètres dont à minima :</p>
                    <ul>
                        <li>
                            <p><span class="html">path</span> qui contient l'URL dans notre navigateur qui dirigera vers le composant;</p>
                        </li>
                        <li>
                            <p><span class="html">element</span> qui va permettre de sélectionner le composant à afficher.</p>
                        </li>
                    </ul>
                    <p>Le fichier <span class="html">index.jsx</span> à la racine de votre projet se transforme donc de cette manière :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>L'idée est maintenant de mettre dans notre router toutes les routes qui seront accessibles.</p>
                    <figure>
                        <img src="../images/survey_URL_React.png" alt="">
                        <figcaption>Il faudra afficher le bon composant pour cette URL.</figcaption>
                    </figure>
                    <p>Créons donc une route pour la page d'accueil et pour notre questionnaire.</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Si vous allez sur l'URL <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a>, on a bien la page d'accueil qui s'affiche. C'est la mêem chose si vous vous mettez <a href="http://localhost:3000/survey" target="_blank">http://localhost:3000/survey</a> dans la barre d'URL.</p>
                    <p>Félicitations ! Tout fonctionne bien comme prévu !</p>
                    <p>Mais bon... Ce n'est pas vraiment pratique de devoir taper toutes nos URL à la main dans la barre du navigateur pour changer de page.</p>
                </article>
                <article>
                    <h2 id="navigation_Link">Naviguez avec les Link :</h2>
                    <p>Profitons-en pour créer notre header, avec les liens vers les différentes pages de notre application.</p>
                    <p>Dans notre dossier <span class="html">/components</span>, on crée donc un nouveau dossier <span class="html">/Header</span> avec un fichier <span class="html">index.jsx</span> à l'intérieur, ce qui nous donne <span class="html">/components/Header/index.jsx</span> :</p>
<pre><code>import { Link } from 'react-router-dom'

function Header() {
    return (
        &lt;nav&gt;
            &lt;Link to="/"&gt;Accueil&lt;/Link&gt;
            &lt;Link to="/survey"&gt;Questionnaire&lt;/Link&gt;
        &lt;/nav&gt;
    )
}

export default Header</code></pre>
                    <p>Ici, j'utilise <span class="html">Link</span>, qui nous vient de React Router et se comporte comme une balise <span class="html">anchor</span>. Il est donc très important de l'utiliser lorsque vous souhaitez naviguer pour l'accessibilité de votre application (et non utoliser des redirections déclenchées par des <span class="html">onClick</span>).</p>
                    <p>Utilisons maintenant <span class="html">Header</span> dans <span class="html">index.jsx</span> à la racine de notre projet :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, j'aurais pu utiliser <span class="html">Header</span> dans <span class="html">Home</span> et dans <span class="html">Survey</span>. Mais, encore mieux, je le place à la base du router. On considère ici que notre <span class="html">Header</span> fait partie du <span class="html">Layout</span> (agencement) de notre application.</p>
                    </div>
                    <figure>
                        <img src="../images/routes_React.png" alt="">
                        <figcaption>Nos routes renvoient bien les bons composants.</figcaption>
                    </figure>
                    <p>Vous avez maintenant la base de votre application avec navigation : félicitations à vous, vous avez fait du bon boulot.</p>
                    <p>Maintenant que nous avons vu comment mettre en place le routing, j'en profite pour vous montrer comment découper notre router quand nous avons beaucoup de routes à gérer - dans un projet de code plus important, par exemple.</p>
                </article>
                <article>
                    <h2 id="Outlets_page">Utilisez les Outlets pour afficher certaines parties de la page :</h2>
                    <p>Dans une application complexe, on peut décider d'afficher certaines parties de la page en fonction de la route que nous avons prise. Imaginons que pour notre questionnaire nous souhaitons afficher des questions différentes si la personne est porteuse de projet ou prestataire freelance.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Nous ne le ferons pas dans notre application, nous faisons juste cet exemple afin que vous avez connaissance de cette possibilité.</p>
                    </div>
                    <p>Nous commençons donc par modifier notre composant Survey comme ceci :</p>
<pre><code>import { Outlet, Link } from 'react-router'

function Survey() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
            &lt;Link to="client"&gt;Questionnaire Client&lt;/Link&gt;
            &lt;Link to="freelance"&gt;Questionnaire Freelance&lt;/Link&gt;
            &lt;Outlet /&gt;
        &lt;/div&gt;
    )
}

export default Survey</code></pre>
                    <p>Ensuite, il nous faut créer nos composants pour les formulaires client et prestataires. Je vais donc créer un dossier <span class="html">ClientForm</span> dans <span class="html">/components</span>. Dans ce dossier, je crée mon fichier <span class="html">index.js</span> avec le code suivant :</p>
<pre><code>function ClientForm() {
    return (
        &lt;div&gt;
            &lt;h2&gt;Questionnaire Client&lt;/h2&gt;
        &lt;/div&gt;
    )
}

export default ClientForm</code></pre>
                    <p>Je peux faire la même chose ensuite avec le composant FreelanceForm, puis finalement he viens de modifier mon Router afin d'inclure les composants de ma page Questionnaire de cette manière :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'
// On ajoute nos composants
import ClientForm from './components/ClientForm'
import FreelanceForm from './coimponents/FreelanceForm'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;}&gt;
                    { /* Nous imbriquons nos composants dans survey */ }
                    &lt;Route path="client" element={&lt;ClientForm /&gt;} /&gt;
                    &lt;Route path="freelance" element={&lt;FreelanceForm /&gt;} /&gt;
                &lt;/Route&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Et voilà, notre affichage de survey dépendra maintenant de notre route :</p>
                    <ul>
                        <li>
                            <p><span class="html">/survey</span> : n'affichera que l'en-tête et les deux liens;</p>
                        </li>
                        <li>
                            <p><span class="html">/survey/client</span> : ajoutera le composant ClientForm;</p>
                        </li>
                        <li>
                            <p><span class="html">/survey/freelance</span> : ajoutera le composant ClientForm.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/Outlets_React.png" alt="">
                        <figcaption>Nos Outlets fonctionnent !</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous avez réalisé le code en même temps que moi, je vous conseille de le commit dans une nouvelle branche, car comme énoncé plus haut, nous ne servirons pas des Outlets dans notre projet.</p>
                    </div>
                </article>
                <article>
                    <h2 id="recuperation_parametres_URL">récupérez des paramètres dans vos URL :</h2>
                    <p>La navigation de notre application fonctionne bien, mais comment faire si vous voulez passer des paramètres ? Par exemple, lorsqu'on va faire le questionnaire et que le numéro de chaque question sera récupéré depuis l'URL ? Eh bien, bonne question ! Le router vous permet de récupérer des paramètres; pour cela, il suffit d'écrire votre route comme ici dans le fichier <span class="html">index.jsx</span> à la racine de <span class="html">/src</span> :</p>
<pre><code>&lt;Route path="/survey/:questionNumber element={&lt;Survey /&gt;} /&gt;</code></pre>
                    <p>Dans <span class="html">components/Header/index.jsx</span>, mettons donc un numéro de question à la suite :</p>
<pre><code>function Header() {
    return (
        &lt;nav&gt;
            &lt;Link to="/"&gt;Accueil&lt;/Link&gt;
            &lt;Link to="/survey/42"&gt;Questionnaire&lt;/Link&gt;
        &lt;/nav&gt;
    )
}</code></pre>
                    <p>Allons maintenant récupérer ce paramètre dans <span class="html">Survey/index.jsx</span> à l'aide du hook <span class="html">useParams</span>, mis à disposition par React Router :</p>
<pre><code>import { useParams } from 'react-router-dom'

function Survey() {
    const { questionNumber } = useParams()

    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
            &lt;h2&gt;Question {questionNumber}&lt;/h2&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Félicitations à vous ! Vous avez récupéré le numéro de votre question en paramètre.</p>
                </article>
                <article>
                    <h2 id="route_404">Créez une route pour les attraper toutes : 404 :</h2>
                    <p>Quelle chance, tout fonctionne comme on le souhaite ! Mais qu'est-ce qui se passe si je commence à taper n'importe quoi dans mon URL ? par exemple, si j'essaie d'accéder au contenu de <a href="http://localhost:3000/coucouCommentCaVa" target="_blank">http://localhost:3000/coucouCommentCaVa</a> ?</p>
                    <p>Notre header s'affiche, mais rien d'autre... Moi, j'aimerais signaler à l'utilisateur que rien n'existe à cette adresse. Eh bien, ça vous dit quelque chose, les pages d'erreur ? C'est ce que nous allons faire ici : afficher une page 404.</p>
                    <p>On commence par créer un simple composant <span class="em">Error</span> dans <span class="html">components/Error/index.jsx</span> :</p>
<pre><code>function Error() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Oups ! Cette page n'existe pas&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Error</code></pre>
                    <p>On retourne maintenant dans notre Router. Afin de gérer les erreurs qui n'existent pas nous ajouterons une route avec un <span class="html">path</span> particulier, le <span class="html">path=*</span> ainsi que toutes les routes qui ne sont pas mentionnées plus haut conduiront à ma page d'erreur.</p>
                    <p>Dans notre router, on a donc :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'
import Error from './components/Error/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey/:questionNumber" element={&lt;Survey /&gt;} /&gt;
                &lt;Route path="*" element={&lt;Error /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Testons dans notre navigateur :</p>
                    <figure>
                        <img src="../images/erreur_404_React.png" alt="">
                        <figcaption>Notre Route permet d'afficher une erreur lorsque l'URL saisie n'existe pas dans le router.</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nos besoins en routing restent limités. Mais comment auriez-vous fait si vous aviez dû créer un système d'authentification ? Eh bien, le router aurait été au coeur de votre login. Vous auriez séparé votre application entre les routes non authentifiées, telles qu'une page d'inscription, de connexion, etc., et les routes authentifiées. À chaque requête sur une page authentifiée, vous auriez dû passer un token secret permettant de vous authentifier à l'API :</p>
                        <ul>
                            <li>
                                <p>Si le token est correct, pas de souci, vous récupérez vos données.</p>
                            </li>
                            <li>
                                <p>En cas d'erreur de token, vous recevez une erreur qui a pour conséquence de vous rediriger auutomatiquement côté router de React sur la partie non authentifiée avec Redirect.</p>
                            </li>
                        </ul>
                        <p>Vous pouvez en apprendre plus sur <a href="https://ui.dev/react-router-v5-protected-routes-authentication/" target="_blank">l'authentification avec React React Router dans cet article (en anglais)</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="PropTypes">Indiquez les types de vos props avec les PropTypes :</h2>
                    <h3>Découvrez le typage :</h3>
                    <p>Les PropTypes sont une des méthodes les plus répandues pour sécuriser le type des props que reçoivent vos composants.</p>
                    <p>En termes de typage, le typage de JavaScript est considéré comme "faible" : JS fonctionne sur du <a href="https://developer.mozilla.org/fr/docs/Glossary/Dynamic_typing" target="_blank">typage dynamique</a> et n'assure pas de type safety. Cela veut dire que lorsqu'on déclare une nouvelle variable, le développeur ou la développeuse <span class="em">ne précise pas de quel type</span> sera la nouvelle variable, le code s'adapte à la volée, et on peut tout à fait changer le type d'une variable.</p>
                    <p>En JS, je peux totalement faire :</p>
<pre><code>let maVariable = 42
maVariable = "quarante trois"</code></pre>
                    <p>Alors que dans un certain nombre d'autres langages, ce n'est pas du tout possible.</p>
                    <p>Typiquement, en C, je dois préciser le type <span class="em">dès la déclaration</span> et il <span class="em">ne change pas</span>. Le typage est alors qualifié de "statique". Ici, <span class="html">maVariable</span> est un <span class="html">integer</span> :</p>
<pre><code>int maVariable;
maVariable = 42; // Pas de souci ici
maVariable = "Quarante trois"; // ce code ne compilera pas !</code></pre>
                    <p>Les choses sont donc bien plus flexibles en JavaScript.</p>
                    <p>Mais ne vous réjouissez pas trop vite, cette flexibilité peut aussi causer votre perte. En effet, des bugs sont vite arrivés en JavaScript, surtout lorsque vous collaborez en équipe !</p>
                    <p>C'est pourquoi il existe des outils pour assurer ses arrières, tels que les <span class="html">PropTypes</span>.</p>
                    <h3>Installez PropTypes :</h3>
                    <p>La bibliothèque PropTypes vous permey de déclarer le type des props qui est attendu lorsque vous les récupérez dans vos composants, et de déclencher un warning si ça ne correspond pas. Bien pratique !</p>
                    <p>Comme d'habitude, pour installer la bibliothèque PropTypes, il vous suffit de lancer la commande <span class="html">yarn add prop-types</span>.</p>
                    <p>Profitons-en pour mettre les <span class="html">propTypes</span> en pratique dans notre application Shiny Agency !</p>
                    <p>Nous allons dès maintenant coder la base des <span class="html">Card</span> dans la page <span class="html">/freelances</span>.</p>
                    <p>Dans le dossier <span class="html">/components</span>, on vient créer un nouveau dossier <span class="html">/Card</span> dans lequel vous pouvez créer un fichier <span class="html">index.jsx</span>. Vous pouvez y coller le code suivant :</p>
<pre><code>function Card({ label, title, picture }) {
    return (
        &lt;div style={{ display: 'flex', flexDirection: 'column', padding: 15 }}&gt;
            &lt;span&gt;{label}&lt;/span&gt;
            &lt;img src={picture} alt="freelance" height={80} width={80} /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/div&gt;
    )
}

export default Card</code></pre>
                    <p>Ce composant récupère 3 props : <span class="html">label</span>, <span class="html">title</span> et <span class="html">picture</span>. J'ai également ajouté quelques propriétés de style pour que le tout soit plus visible.</p>
                    <p>Nous allons utiliser les <span class="html">Card</span> dans notre fichier <span class="html">Freelances/index.js</span>. Comme nous n'avons pas encore récupéré les datas que nous afficherons, nous allons créer un tableau d'objets nous-mêmes, qu'on déclare dans <span class="html">/pages/Freelances/index.jsx</span> :</p>
<pre><code>import DefaultPicture from '../../assets/profile.png'

const freelanceProfiles = [
    {
        name: 'Jane Doe',
        jobTitle: 'Devops',
        picture: DefaultPicture,
    },
    {
        name: 'John Doe',
        jobTitle: 'Développeur frontend',
        picture; DefaultPicture,
    },
    {
        name: 'Jeanne Biche',
        jobTitle: 'Développeuse Fullstack',
        picture: DefaultPicture,
    },
]</code></pre>
                    <p>Ici, on utilise une photo de profil vide standard qu'on a mise dans un dossier <span class="html">/assets</span>. Nous pouvons mapper ce tableau pour afficher le composant <span class="html">Card</span> :</p>
<pre><code>function Freelances() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Freelances&lt;/h1&gt;
            {freelanceProfiles.map((profile, index) =&gt; (
                &lt;Card
                    key={`${profile.name}-${index}`}
                    label={profile.jobTitle}
                    picture={profile.picture}
                    title={profile.name}
                /&gt;
            ))}
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Nous avons tout ce qu'il nous faut ! Sécurisons donc les props de <span class="html">Card</span> avec les propTypes !</p>
                    <p><span class="html">Card</span> récupère 3 props, <span class="html">label</span>, <span class="html">title</span> et <span class="html">picture</span>. On va donc importer <span class="html">PropTypes</span> depuis la bibliothèque et utiliser <span class="html">Card.propTypes</span> pour préciser les types de chacune des propriétés.</p>
<pre><code>import PropTupes from 'prop-types'

function Card({ label, title, picture }) {
    return (
        &lt;div style={{ display: 'flex', flexDirection: 'column', padding: 15 }}&gt;
            &lt;span&gt;{label}&lt;/span&gt;
            &lt;img src={picture} alt="freelance" height={80} width={80} /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/div&gt;
    )
}

Card.propTypes = {
    label: PropTypes.string,
    title: PropTypes.string,
    picture: PropTypes.string,
}

export default Card</code></pre>
                    <p>Vous pouvez essayer dès maintenant de passer une prop dont le type n'est pas <span class="html">string</span>, pour voir. Dans <span class="html">freelances/index.jsx</span> :</p>
<pre><code>{freelanceProfiles.map((profile, index) =&gt; (
    &lt;Card
        key={`${profile.name}-${index}`}
        label={profile.jobTitle}
        picture={profile.picture}
        title={42}
    /&gt;
))}</code></pre>
                    <figure>
                        <img src="../images/propTypes_React.jpg" alt="">
                        <figcaption>Ça me renvoie directement une erreur dans la console !</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous n'avons que des <span class="html">strings</span>, mais il existe bien plus de types supportés par <span class="html">propTypes</span>. <a href="https://fr.reactjs.org/docs/typechecking-with-proptypes.html#proptypes" target="_blank">Vous pourrez les trouver dans la doc de React.</a></p>
                    </div>
                    <p>Bravo à vous, vous venez de sécuriser votre composant <span class="html">Card</span> à l'aide des propTypes.</p>
                    <p>Mais je ne vous ai pas tout montré : vous pouvez même préciser si une prop est requise ou non !</p>
                    <h3>Exigez une prop :</h3>
                    <p>Il est très simple de préciser qu'une prop est requise pour le bon fonctionnement de l'application. Pour cela, il suffit d'ajouter <span class="html">isRequired</span> à la suite du type déclaré.</p>
                    <p>Par exemple, toujours pour <span class="html">Card</span>, si on fait :</p>
<pre><code>Card.propTypes = {
    label: PropTypes.string,
    title: PropTypes.string.isRequired,
    picture: PropTypes.string
}</code></pre>
                    <p>... et qu'on omet de déclarer la prop <span class="html">title</span>, ça nous donne :</p>
                    <figure>
                        <img src="../images/propTypes_React_1.jpg" alt="">
                        <figcaption>Une erreur apparaît dans la console lorsque vous oubliez de préciser une prop qui est requise.</figcaption>
                    </figure>
                    <p>Et voilà, vous avez réussi à "exiger une prop avec <span class="html">.isRequired</span> !</p>
                    <p>Je voulais vous montrer une dernière chose en lien avec les propTypes : comment définir une prop par défaut.</p>µ
                    <h3>Définissez des props par défaut :</h3>
                    <p>Bon, précédemment, vous avez déjà vu comment définir par défaut avec la déstructuration. Mais nous allons voir comment le faire de manière plus formelle : nous allons utiliser <span class="html">defaultProps</span>. Dans l'exemple précédent, au lieu de déclencher une erreur pour notre propriété manquante (alors qu'on avait précisé <span class="html">isRequired</span>), nous aurions pu aussi déclarer une propriété par défaut.</p>
                    <p>Il est possible d'assigner une valerur à <span class="html">title</span> directement dans la déstructuration, comme ici :</p>
<pre><code>function Card({ label, title = 'Mon titre par défaut', picture })</code></pre>
                    <p>Mais cette syntaxe déclenche malgré tout une erreur de <span class="html">PropType</span>. Dans ce cas, la meilleure manière est d'avoir recours à <span class="html">defaultProps</span>. Juste en dessous de <span class="html">Card.propTypes</span>, nous déclarons un objet <span class="html">Card.defaultProps</span> :</p>
<pre><code>Card.defaultProps = {
    title: 'Mon titre par défaut',
}</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Jusqu'à il y a quelques années, <span class="html">prop-types</span> était la solution recommandée pour typer ses props. Mais aujourd'hui, il existe d'autres solutions, telles que <span class="html">TypeScript</span> ou <span class="html">Flow</span>. Si vous voulez voir à quoi ressemble la base d'une application codée avec TypeScript, <a href="https://github.com/OpenClassrooms-Student-Center/7150606-React-intermediaire/tree/typescript" target="_blank">vous trouverez la branche "typescript" dans le projet "shiny-agency" où l'application est entièrement codée en TS</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="styled_components">Scopez votre CSS avec styled components :</h2>
                    <p>Pour ajouter du style à votre application React, vous avez certainement jusqu'ici utilisé du CSS. Pour gagner du temps de développement sur le CSS nous pouvons même utiliser des bibliothèqyes comme <a href="https://getbootstrap.com/" target="_blank">Bootstrap</a> ou encore <a href="https://tailwindcss.com/" target="_blank">Tailwind</a>. Cependant, vous est-il déjà arrivé de réutiliser le nom d'une classe CSS dans un autre composant sans faire exprès ? Ou bien encore de trouver du style appliqué à un élément sans comprendre d'où il venait ? Si ça vous est déjà arrivé, vous devez savoir à quel point c'est frustrant !</p>
                    <p>L'enjeu de <span class="em">scoper</span> notre style aux composants concernés est réel.</p>
                    <p>Le scope correspond aux parties de notre code qui ont accès à un élément, comme une variable, ou une classe CSS. Il peut être global (comme c'est le cas pour les classes CSS dont je vous parlais il y a quelques instants), ou bien converner une partie spécifique du code.</p>
                    <p>Pour scoper le style, il existe des solutions, telles que des méthodologies d'architecture de CSS ou bien des outils spécifiques comme Sass (qui requiert un préprocesseur). Mais depuis quelques années, le <span class="em">CSS in JS</span> émerge comme l'une des solutions à notre problème.</p>
                    <h3>Découvrez le CSS in JS :</h3>
                    <p>Comme son nom l'indique, le CSS in JS est généré... avec du JavaScript. Il sera inséré dans le DOM dans un élément <span class="html">&lt;style&gt;</span>.</p>
                    <p>L'inline style est inséré dans le DOM sur l'attribut <span class="html">style</span> d'un élément spécifique (souvenez-vous, on fait <span class="html">&lt;div style={{ color: 'red' }} /&gt;</span>). Par ailleurs, l'inline style ne permetpas d'utiliser les pseudo-selectors. Ce n'est pas pareil pour le CSS in JS, avec lequel on peut utiliser autant de pseudo-selectors que nécessaire.</p>
                    <p>Mais avec le CSS in JS, on garde l'idée que <span class="em">le style est attaché à un compposant spécifique</span>, directement dans le même fichier. Beaucoup plus simple lorsqu'il faut supprimer ou modifier du style déjà existant, n'est-ce pas ?</p>
                    <p>Il existe plusieurs solutions de CSS in JS, avec leurs syntaxes propres. Ici nous allons nous intéresser à la bibliothèque <span class="em">styled components</span>.</p>
                    <p>Commençons dès maintenant par installer la bibliothèque avec <span class="html">yarn add styled-components</span> :</p>
                    <figure>
                        <img src="../images/CSS_in_JS.jpg" alt="">
                        <figcaption>Styled-components s'installe.</figcaption>
                    </figure>
                    <p>Penchons-nous dès maintenant sur le style que nous allons pouvoir créer !</p>
                    <h3>Appliquez la logique styled components :</h3>
                    <p>Dans styled components, la principale chose à comprendre est que tout est composant. Pour voir cela, créons dès maintenant notre premier styled component (styled composant).</p>
                    <p>Dans <span class="html">Card/index.jsx</span>, créons donc le style pour le <span class="html">label</span>.</p>
                    <p>On commence par ajouter l'import de styled-components puis nous créons notre composant <span class="html">CardLabel</span> de la manière suivante :</p>
<pre><code>import styled from 'styled-components'

const CardLabel = styled.span``</code></pre>
                    <p>Et on a réutilisé <span class="html">CardLabel</span> directement dans le JSX :</p>
<pre><code>&lt;CardLabel&gt;{label}&lt;/CardLabel&gt;</code></pre>
                    <p>Pas de panique ! Ici, <span class="html">styled-components</span> utilise des templates literals que vous pouvez voir <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates" target="_blank">dans la documentation Mozilla</a>. Vous pouvez écrire votre CSS directement à l'intérieur. Ce qui nous donne :</p>
<pre><code>const CardLabel = styled.span`
    color: #5843e4;
    font-size: 22px;
    font-weight: bold;
`</code></pre>
                    <p>Profitons-en pour ajouter du style à notre image. Cette fois-ci, toujours dans le même fichier <span class="html">Card/index.jsw</span>, on a :</p>
<pre><code>const CardImage = styled.img`
    height: 80px;
    width: 80px;
    border-radius: 50%;
`</code></pre>
                    <p>... qu'on utilise dans le code :</p>
<pre><code>&lt;CardImage src={picture} alt="freelance" /&gt;</code></pre>
                    <p>Bravo à vous ! Vous avez généré des éléments <span class="html">span</span> et <span class="html">img</span> auxquels vous avez appliqué du style avec <span class="html">styled-components</span> ! Vous vous en doutez, ça ne s'arrête pas à <span class="html">span</span> et <span class="html">img</span> : vous pouvez ainsi générer tous les éléments du DOM... mais pas que.</p>
                    <p>Style components prévoit ce cas ! Prenons l'exemple de <span class="html">Header/index.jsx</span>. Pour cela, il nous suffit de faire :</p>
<pre><code>import { Link } from 'react-router-dom'
import styled from 'styled-components'

const StyledLink = styled(Link)`
`

function Header() {
    return (
        &lt;nav&gt;
            &lt;StyledLink to="/"&gt;Accueil&lt;/StyledLink&gt;
            &lt;StyledLink to="/survey/1"&gt;Questionnaire&lt;/StyledLink&gt;
            &lt;StyledLink to="/freelances"&gt;Profils&lt;/StyledLink&gt;
        &lt;/nav&gt;
    )
}

export default Header</code></pre>
                    <p>Essayez ce code pour voir le rendu vous-même - pas mal, n'est-ce pas ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>D'ailleurs, vous pouvez styliser un composant que vous avez vous-même créé de la même manière. Cette technique permet d'étendre votre style.</p>
                    </div>
                    <h3>Passez des props dans votre CSS :</h3>
                    <p>C'est bien beau, nous avons créé nos styled components et nous les avons utilisés, mais quels autres avantages tire-t-on du fait d'écrire notre style avec du JS ? ...Eh bien justement, on utilise du JS. On va pouvoir passer des props à nos composants directement depuis notre composant React.</p>
                    <p>Voyons voir concrètement ce que cela donne dans notre <span class="html">Header</span>.</p>
<pre><code>&lt;styledLink to="/survey/1" $isFullLink&gt;
    Faire le test
&lt;/StyledLink&gt;</code></pre>
                    <p>Ici on passe la prop <span class="html">1isFullLink</span>. Ce qui nous permet d'utiliser la prop directement dans le style :</p>
<pre><code>const StyledLink = styled(Link)`
    padding: 15px;
    color: #8186a0;
    text-decoration: none;
    font-size: 18px;
    ${(props) =&gt;
        props.$isFullLink &&
        `color; wite; border-radius: 300px; background-color; #5843E4;`}
`</code></pre>
                    <p>C'est quoi ce <span class="html">$</span> ? Eh bien, cela permet de signaler à <span class="html">styled-components</span> que notre prop nous sert pour le style, et qu'elle ne doit pas être passée dans le DOM.</p>
                    <p>Ce <span class="html">$</span> est uniquement nécessaire pour passer une prop si le composant en question est un composant React, comme ici pour <span class="html">Link</span> (et non un élément HTML). Si mon styled component était basé sur une simple balise <span class="html">a</span>, je pourrais totalement utiliser la prop <span class="html">isFullLink</span> sans le <span class="html">$</span>.</p>
                    <p>Voyons l'utilisation du state en prop de plus près ci-dessous :</p>
<pre><code>// Dans /pages/Home/index.jsx
import { useState } from 'react'
import styled from 'styled-components'

const HomeContainer = styled.div`
    height: 100px;
    width: 100px;
    border-radius: 50px;
    background-color: #e20202;
    transform: scale(${({ size }) =&gt; size});
`

function Home() {
    const [size, setSize] = useState(1)
    return (
        &lt;HomeContainer&gt;
            &lt;h1 onClick={() =&gt; setSize(size + 0.1)}&gt;Page d'accueil&lt;/h1&gt;
            &lt;Ballon size={size} /&gt;
        &lt;/HomeContainer&gt;
    )
}

export default Home</code></pre>
                    <p>Pas mal, non ?</p>
                    <h3>Utilisez des variables :</h3>
                    <p>Vous voyez, dans notre avant-dernier snippet de code, on a encore utilisé la couleur violette <span class="html">#5843E4</span>. Qui dit JS dit aussi qu'on peut utiliser des variables, et c'est ce que nous allons faire : nous allons utiliser des variables pour <span class="em">stocker nos couleurs</span> !</p>
                    <p>Vous pourriez tout simplement déclarer un objet <span class="html">colors</span> qui reprend toutes les couleurs de notre application, mais il est considéré comme une bonne pratique de créer un thème géré par <span class="html">styled-components</span>.</p>
                    <p>On crée donc un dossier <span class="html">/utils</span> directement dans <span class="html">src/</span>, dans lequel on met un dossier <span class="html">/style</span>. On y crée notre fichier <span class="html">color.js</span>, ce qui nous donne :</p>
<pre><code>├── assets
│   └── profile.png
├── components
│   ├── Card
│   │   └── index.jsx
│   ├── Error
│   │   └── index.jsx
│   └── Header
│       └── index.jsx
├── index.jsx
├── pages
│   ├── Freelances
│   │   └── index.jsx
│   ├── Home
│   │   └── index.jsx
│   ├── Results
│   │   └── index.jsx
│   └── Survey
│       └── index.jsx
└── utils
└── style
└── colors.js</code></pre>
                    <p>Dans <span class="html">color.js</span>, on définit nos couleurs :</p>
<pre><code>const colors = {
    primary '#5843E4',
    secondary: '8186A0',
    backgroundLight: '#F9F9FC',
}

export default colors</code></pre>
                    <p>Pour l'utiliser, il nous suffit de l'importer directement dans notre template string :</p>
<pre><code>const StyledLink = styled(Link)`
    padding: 15px;
    color: #8186a0;
    text-decoration: none;
    font-size: 18px;
    ${(props) =&gt;
        props.$isFullLink && 
        `color: white; border-radius: 30px; background-color: ${colors.primary};`}
`</code></pre>
                    <p>Et on a bien ce qu'on voulait.</p>
                    <p>Par contre, comment faire si je veux styliser mon composant au survol de la souris ? Eh bien, c'est très simple ici puisque les pseudosélecteurs fonctionnent dans nos styled components.</p>
                    <p>Pour mettre tout ça en pratique, on va retourner sur nos <span class="html">Cards</span>. On y ajoutera un peu de style pour que l'effet de <span class="em">hover</span> soit plus visible. Dans <span class="html">pages/freelances.jsx</span>, on met :</p>
<pre><code>const CardContainer = styled.div`
    display: grid;
    gap: 24px;
    grid-template-rows: 350px 350px;
    grid-template-columns: repeat(2, 1fr);
`</code></pre>
                    <p>... qu'on utilise tout de suite dans le même fichier :</p>
<pre><code>function Freekabces() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Freelances&lt;/h1&gt;
            &lt;CardsContainer&gt;
                {freelanceProfiles.map((profile, index) =&gt; (
                    &lt;Card
                        key={`${profile.name}-${index}`}
                        label={profile.jobTitle}
                        title={profile.name}
                    /&gt;
                ))}
            &lt;/CardContainer&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Puis dans <span class="html">Card/index.jsx</span>, on peut créer un effet d'ombre au survol de la souris. Pour ça, on crée un <span class="html">CardWrapper</span> qui vient remplacer notre précédente <span class="html">div</span> :</p>
<pre><code>function Card({ label, title, picture }) {
    return (
        &lt;CardWrapper&gt;
            &lt;CardLabel&gt;{label}&lt;/CardLabel&gt;
            &lt;CardImage src={picture} alt="freelance" /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/CardWrapper&gt;
    )
}</code></pre>
                    <p>Et on définit CardWrapper comme suit :</p>
<pre><code>const CardWrapper = styled.div`
    display: flex;
    flex-direction: column;
    padding: 15px;
    background-color: ${colors.backgroundLight};
    border-radius: 30px;
    width: 350px;
    transition: 200ms;
    &:hover {
        cursor: pointer;
        box-shadow: 2px 2px 10px #e2e3e9;
    }
`</code></pre>
                    <p>La syntaxe <span class="html">&:hover</span> nous permet d'accéder au pseudosélecteur du survol de la souris, et on a bien l'effet souhaité !</p>
                    <figure>
                        <img src="../images/hover_React.png" alt="">
                        <figcaption>On a bien l'effet d'ombre au survol de la souris.</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous avons utilisé le pseudosélecteur <span class="html">:hover</span> avec <span class="html">&</span>. <span class="html">&</span> est très utile dans nos styled components, notamment pour utiliser des pseudosélecteurs, mais aussi pour accéder à d'autres éléments. Notamment si un de nos compoisants a <span class="html">className</span> et qu'on ne peut pas accéder directement à son style. Je ne vous le montrerai pas ici, mais <a href="https://styled-components.com/docs/basics#pseudoelements-pseudoselectors-and-nesting" target="_blank">vous trouverez des exemples dans la documentation de Styled Components</a>.</p>
                    </div>
                    <h3>Créez un style global :</h3>
                    <p>Nous avons déjà vu beaucoup de choses avec styled components. Encore une fois, nous ne pouvons pas tout couvrir dans ce cours, mais avant de conclure j'aimerais que nous créions un style global. Cela nous permettra de créer un style de base, notamment pour la police ou pour d'autres propriétés CSS.</p>
                    <p>Pour cela, dans <span class="html">index.jsx</span> à la racine de notre projet, vous pouvez créer un composant GlobalStyle :</p>
<pre><code>const GlobalStyle = createGlobalStyle`
    div {
        font-family: 'Trebuchet MS', Helvetica, sans-serif;
    }
`</code></pre>
                    <p>Et vous l'importez tout simplement dans vos composants :</p>
<pre><code>&lt;Router&gt;
    &lt;GlobalStyle /&gt;
    &lt;Header /&gt;
    ...
&lt;/Router&gt;</code></pre>
                    <p>Et voilà ! Ensemble, nous avons utilisé <span class="html">styled-components</span> pour styliser notre application !</p>
                </article>
                <article>
                    <h2 id="useState_useEffect_calls_API">Exploitez vos connaissances de useState et useEffect pour effectuer des calls API :</h2>
                    <h3>Rafraîchissez vos connaissances de useState et useEffect :</h3>
                    <p>Souvenez-vous...</p>
                    <p>Le <span class="em">state local</span> esy présent à l'intérieur d'un composant : ce composant peut être re-render autant de fois que l'on veut, mais les données seront <span class="em">préservées</span>. Pour cela on utilise <span class="html">useState</span>, un hook qui permet d'ajouter un state local dans un composant fonction.</p>
                    <p><span class="html">useEffect</span> est également un hook, qui permet d'exécuter des actions après le render de nos composants, en choisissant à quel moment et à quelle fréquence cette action doit être exécutée, avec le tableau de dépendances.</p>
                    <p>Vous vous en doutez sûrement, nous allons les utiliser pour faire des calls API :</p>
                    <ul>
                        <li>
                            <p><span class="html">useEffect</span> nous permettra de déclencher le <span class="html">fetch</span>;</p>
                        </li>
                        <li>
                            <p><span class="html">useState</span> permettra de stocker le retour de l'API dans le <span class="em">state</span>.</p>
                        </li>
                    </ul>
                    <h3>Récupérez les données d'une API :</h3>
                    <h4>Reprenez les bases des calls API :</h4>
                    <p>Les données sont au coeur d'une application. Qu'il s'agisse de données locales ou bien qu'elles soient récupérées depuis une API, elles viennent <span class="em">alimenter nos composants</span> et <span class="em">nourrir les interactions</span> avec les utilisateurs.</p>
                    <p>Une <span class="em">API</span> (Application Programming Interface) est littéralement une interface de programmation d'application : c'est un moyen de communication entre deux logiciels. Concrètement, pour nous, c'est ce qui nous permet de <span class="em">récupérer des données</span>.</p>
                    <p>Mais pourquoi on n'a pas mis les données directement dans le front ? Eh bien... oui, on aurait pu. Ici, on dispose de toutes les données. Mais dans les faits, ce ne sera pas toujours le cas, loin de là. Vous pouvez par exemple avoir besoin que votre contenu soit administré par une personne qui ne sait pas coder. Dans ce cas, vous pourriez <a href="https://openclassrooms.com/fr/courses/5922626-optimisez-le-referencement-de-votre-site-seo-en-ameliorant-ses-performances-techniques/6055246-accelerez-un-site-cree-avec-un-cms" target="_blank">utiliser un CMS</a> (comme <a href="https://wordpress.com/fr/" target="_blank">WordPress</a>, <a href="https://ghost.org/" target="_blank">Ghost</a>, etc.), et récupérer le contenu.</p>
                    <p>Ou bien tout silmplement, vous pouvez créer une application complexe qui requiert un système d'authentification, qui sauvegarde des données utilisateurs, etc. Dans ce cas, une application frontend ne suffit pas et doit être complémentaire avec l'application backend.</p>
                    <p>Mettons tout ça en application dès maintenant !</p>
                    <p>Pour notre projet pour l'agence Shiny, nous allons utiliser l'API <a href="https://github.com/OpenClassrooms-Student-Center/7150606-API-React-intermediaire" target="_blank">que vous trouverez ici</a>. Vous trouverez toutes les instructions nécessaires pour la faire tourner dans le <span class="html">README.md</span>. Je vous laisse un petit moment pour cloner le repo et lancer l'API en local.</p>
                    <p>... C'est bon, vous avez bien l'API qui tourne en local ? On va aller récupérer le contenu de nos questions sur l'API sur la route <a href="http://localhost:8000/" target="_blank">http://localhost:8000/</a> avec <a href="https://developer.mozilla.org/fr/docs/Web/API/Fetch_API/Using_Fetch" target="_blank">la méthode <span class="html">fetch()</span></a>.</p>
                    <p><span class="html">fetch()</span> est la méthode native pour faire des calls API. Nous aurions très bien pu utiliser des outils tels que <a href="https://github.com/axios/axios" target="_blank">axios</a>, mais ici la méthode native a été privilégiée, pour vous éviter une nouvelle installation d'outil externe.</p>
                    <h4>Développez le questionnaire avec les données :</h4>
                    <p>Pour nous atteler à l'utilisation de l'API, nous allons développer la page <span class="html">/survey</span>. Souvenez-vous, précédemment, nous avions créé des liens pour naviguer entre les questions, et rediriger l'utilisateur sur <span class="html">/results</span> quand il atteignait la dixième question. Eh bien, ici, nous allons continuer à développer cette page afo, de récupérer les données depuis l'API.</p>
                    <p>L'API nous renvoie l'ensemble de questions sur l'endpoint <a href="http://localhost:8000/survey" target="_blank">http://localhost:8000/survey</a>.</p>
                    <p>Hé, mais comment on sait ça ? Bon, c'est facile pour moi parce que j'ai aussi écrit l'API que nous utilisons. Mais vous pouvez tout simplement utiliser la documentation de l'API accessible dans le fichier <span class="html">README.md</span>.</p>
                    <p>On peut donc l'appeler, comme nous l'avons dit, dans notre <span class="html">useEffect</span> pour récupérer les questions. Si vous regardez la documentation, vous verrez que la route correspondant aux questions (<a href="http://localhost:8000/survey" target="_blank">http://localhost:8000/survey</a>) est une route <span class="html">GET</span>, et qu'elle ne requiert pas de paramètre : on pourra récupérer les données en faisant <span class="html">fetch('http://localhost:8000/survey')</span>.</p>
                    <p>Ici, on a donc uniquement besoin d'appeler l'API à la première initialisation de notre composant, et on <span class="em">précise un tableau de dépendances vide</span> dans notre fichier :</p>
<pre><code>useEffect(() =&gt; {
    fetch('http://localhost:8000/survey')
        .then((response) =&gt; response.json())
        .then(({ surveyData }) =&gt; console.log(surveyData))
        .catch((error) =&gt; console.log(error))
}, [])</code></pre>
                    <p>Et voilà : on a bien ce qu'on voulait  !</p>
                    <figure>
                        <img src="../images/donnees_questionnaire_React.png" alt="">
                        <figcaption>Les données de notre questionnaire arrivent dans la console.</figcaption>
                    </figure>
                    <p>Ici, nous avons utilisé des <span class="html">Promises</span>. Une autre syntaxe aurait été possible avec des <span class="html">async</span> / <span class="html">await</span>. Mais attention, il y a une petite subtilité avec <span class="html">useEffect</span>.</p>
                    <p>Bon, ce n'est pas tout d'afficher le retour de notre API dans la console : on veut que ce soit visible dans notre application !</p>
                    <p>Pour cela, nous allons <span class="em">utiliser le state</span>. À l'aide de <span class="html">useState</span>, on crée donc :</p>
<pre><code>const [questions, setQuestions] = useState({})</code></pre>
                    <p><span class="html">questions</span> va nous permettre de <span class="em">stocker l'objet qui a été retourné par l'API</span>. À partir de là, on peut exploiter <span class="html">questions</span> assez simplement en appelant : <span class="html">setQuestions(surveyData)</span>.</p>
                    <p>Ici, vous avez pu voir dans votre console que <span class="html">surveyData</span> est un objet ayant pour clé des nombres. C'est très pratique pour s'assurer que les questions sont toujours ordonnées, et on peut tout simplement <span class="em">accéder à une question</span> avec :</p>
<pre><code>surveyData[questionNumber]</code></pre>
                    <p>De la même manière, pour savoir s'il faut mettre un lien vers le numéro de question suivant, ou bien un lien vers les résultats, vous pouvez tout simplement <span class="em">vérifier ce que donne l'affirmation</span> :</p>
<pre><code>surveyData[questionNumberInt + 1] ?</code></pre>
                    <p>Ce qui nous donne le code suivant :</p>
<pre><code>function Survey() {
    const { questionNumber } = useParams()
    const questionNumberInt = parseInt(questionNumber)
    const prevQuestionNumber = questionNumberInt === 1 ? 1 : questionNumberInt - 1
    const nextQuestionNumber = questionNumberInt + 1
    const [surveyData, setSurveyData] = useState({})

    useEffect(() =&gt; {
        setDataLoading(true)
        fetch('http://localhost:8000/survey')
            .then((response) =&gt; response.json())
            .then(({ surveyData }) =&gt; console.log(surveyData))
            .catch((error) =&gt; console.log(error))
    }, [])

    return (
        &lt;SurveyContainer&gt;
            &lt;QuestionTitke&gt;Question {questionNumber}&lt;/questionNumber&gt;
            &lt;QuestionContent&gt;{surveyData[questionNumber]}&lt;/QuestionContent&gt;
            &lt;LinkWrapper&gt;
                &lt;Link to={`/survey/${prevQuestionNumber}`}&gt;Précédent&lt;/Précédent&lt;/Link&gt;
                {surveyData[questionNumberInt + 1] ? (
                    &lt;Link to={`/survey/${nextQuestionNumber}`}&gt;Suivant&lt;/Link&gt;
                ) : (
                    &lt;Link to="/results"&gt;Résultats&lt;/Link&gt;
                )}
            &lt;/LinkWrapper&gt;
        &lt;SurveyContainer&gt;
    )
}

export default Survey</code></pre>
                    <h3>Créez un state loading :</h3>
                    <p>C'est pas mal tout ça, n'est-ce pas ? Notre question s'affiche bien :</p>
                    <figure>
                        <img src="../images/state_loading_React.png" alt="">
                        <figcaption>Votre application affiche bien la question souhaitée.</figcaption>
                    </figure>
                    <p>Mais ça vient d'où ce petit moment de "blanc" ? Comment fait-on pour que ça ressemble plus aux sites professionnels ? Eh bien, ça correspond tout simple au temps entre lequel lequel le composant est <span class="em">render</span> (généré) et celui où leuel les données sont chargées. Effectivement, d'un point de vue UI (interface utilisateur), ce n'est pas idéal : l'utilisateur ne comprend pas que les données sont en train d'être chargées, et peut alors penser qu'uk y a un problème sur l'application.</p>
                    <p>Une pratique très répandue consiste à mettre un petit <span class="em">loader</span> pour <span class="em">signifier que les données vont bientôt s'afficher</span>. On pourrait mettre un simple texte "Chargement...", mais bon, on sait manier le CSS : autant s'amuser avec, non ?</p>
                    <p>Je vous propose de <span class="em">créer un simple <span class="html">Loader</span> en CSS</span>, directement dans le fichier <span class="html">utils.Atoms.jsx</span>. Pour cela, on a également besoin d'importer <span class="html">keyframes</span> depuis la bibliothèque <span class="html">styled-components</span>. Ce qui nous donne :</p>
<pre><code>import colors from './colors'
import styled, { keyframes } from 'styled-components'

const rotate = keyframes`
    from {
        transform: rotate(0deg);
    }

    to {
        transform: rotate(360deg);
    }
`

export const Loader = styled.div`
    padding: 10px;
    border: 6px solid ${colors.primary};
    border-bottom-color: transparent;
    border-radius: 22px;
    animation: ${rotate} 1s infinite linear;
    height: 0;
    width: 0;
`</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, ce CSS n'est pas l'objet de ce cours, donc pas de panique si vous ne comprenez pas tout : sachez juste qu'il s'agit d'une utilisation un peu détournée pour avoir un <span class="html">Loader</span> en CSS pur.</p>
                    </div>
                    <p>On va maintenant <span class="Em">utiliser le state pour afficher notre <span class="html">Loader</span></span>. Pour cela, on crée une variable <span class="html">isDataLoading</span> avec <span class="html">useState</span> :</p>
<pre><code>const [isDataLoading, setDataLoading] = useState(false)</code></pre>
                    <p>Dans le <span class="html">useEffect</span>, on vient <span class="em">modifier notre booléen</span> :</p>
<pre><code>useEffect(() =&gt; {
    setDataLoading(true)
    fetch(`http://localhost:8000/survey`)
        .then((response) =&gt; response.json())
        .then(({ surveyData }) =&gt; {
            setSurveyData(surveyData)
            setDataLoading(false)
        })
}, [])</code></pre>
                    <p>... ce ui nous permet ainsi de <span class="em">condititionner le rendu de notre composant</span> : le <span class="html">Loader</span> s'affiche tant que les données chargent, et une fois qu'on les a bien, le contenu de la question s'affiche à la place du <span class="html">Loader</span>.</p>
<pre><code>&lt;SurveyContainer&gt;
    &lt;QuestionTitle&gt;Question {questionNumber}&lt;/QuestionTitle&gt;
    {isDataLoading ? (
        &lt;Loader /&gt;
    ) : (
        &lt;QuestionContent&gt;{surveyData[questionNumber]}&lt;/QuestionContent&gt;
    )}
    ...
&lt;/SurveyContainer&gt;</code></pre>
                    <p>On a bien notre contenu qui s'affiche comme on le souhaitait !</p>
                    <figure>
                        <img src="../images/state_loading_React_1.png" alt="">
                        <figcaption>Pas mal, ce petit loader ?</figcaption>
                    </figure>
                    <p>Maintenant que nous avons le comportement que nous souhaitons, profitons-en pour implémenter une syntaxe un peu plus moderne, et pour gérer les erreurs :</p>
<pre><code>useEffect(() =&gt; {
    async function fetchSurvey() {
        try {
            const response = await fetch(`http://localhost:8000/survey`)
            const { surveyData } = await response.json()
            setSurveyData(surveyData)
        } catch(err) {
            console.log(err)
            setError(true)
        } finally {
            setDataLoading(false)
        }
    }
    fetchSurvey()
}, [])</code></pre>
                </article>
                <article>
                    <h2 id="useContext">Partagez vos données avec le Contexte et useContext :</h2>
                    <h3>Découvrez le Contexte dans React :</h3>
                    <p>Dans la famille des hooks, je veudx maintenant celui qui nous permet d'utiliser simplement le Contexte de React !</p>
                    <p>Contexte est un moyen de partage simplement les props entre les composants. Contexte est natif à React et ne nécessite pas d'installer quoi que ce soit de plus.</p>
                    <p>Précédemment, vous avez vu comment passer de simples props entre les composants parents et enfants, et comment utiliser les props pour faire remonter le state. Mais est-ce que vous imaginez ce que ça pourrait donner dans une application complexe, où pour passer une prop à un composant enfant, vous devez <span class="em">le faire par des dizaines de composants</span> parents qui n'ont eux-mêmes pas beosin de cette prop ?</p>
                    <figure>
                        <img src="../images/useContext_React_1.png" alt="">
                        <figcaption>Ça n'a pas l'air très efficace, n'est-ce pas ?</figcaption>
                    </figure>
                    <p>À l'inverse, Contexte nous permet de <span class="em">récupérer simplement nos datas sans avoir à tout passer manuellement</span>. Pour cela, on englobe le composant le plus haut dans l'arborescence de composants avec ce qu'on appelle un <span class="html">Provider</span>. Tous les composants enfants pourront alors se connecter au <span class="html">Provider</span> (littéralement en anglais, le "fournisseur") et aisi accéder aux props, sans avoir à passer par tous les composants intermédiaires. On dit que les composants enfants sont les <span class="html">Consumers</span> (consommateurs).</p>
                    <figure>
                        <img src="../images/useContext_React_2.png" alt="">
                        <figcaption>Cette fois-ci, le composant se branche tout simplement au Provider pour accéder au Contexte !</figcaption>
                    </figure>
                    <p>L'idée de passer simplement nos datas entre les composants est au coeur de nombreuses questions, afin que le code soit le plus performant et lisible possible. Vous verre plus particulièrement des interrogations sur la manière de gérer le state de manière compréhensible et performante. On parle de <span class="em">State Management</span>. Vous en avez déjà entendu parler ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Comme son nom l'indique, le State Management cherche à <span class="em">optimiser la gestion du State</span>. Il existe des solutions dédiées telles que Redux (Redux nécessite d'installer une bibliothèque externe). Le Contexte permet de manipuler des variables liées au state. Mais il ne s'agit pas vraiment à proprement parler d'une solution de State Management. Contexte ne vient donc pas remplacer Redux, mais cohabite avec Redux dans la plupart des codebases. Comprendre le State Management est essentiem si vous souhaitez travailler sur une base de code en entreprise.</p>
                    </div>
                    <p>Avant les hooks, l'utilisation du Contexte était plus laborieuse, mais réjouissez-vous : vous avez maintenant le hook <span class="html">useContext</span>.</p>
                    <h3>Tirez profit du COntexte et de useContext :</h3>
                    <p>Maintenant que nous avons vu ce qu'était un OCntexte, utilisons-le dès maintenant dans notre application Shiny !</p>
                    <h4>Mettez en place un Contexte :</h4>
                    <p>Quelles données mettre dans le Contexte ? La documentation de React dit que "le Contexte est conçu pour partager des données qui peuvent être considérées comme <span class="em">globales</span>", et cite en exemple des données sur l'utilisateur actuellement authentifié, le thème, la langue utilisée, etc.</p>
                    <p>Nous allons commencer en douceur avec le contexte pour <span class="em">créer un Dark Mode (mode nuit) pour notre application</span>. Vous savez, ce thème de couleurs plutôt sombres qui permet de reposer devant l'écran.</p>
                    <p>Pour cela, nous allons <span class="em">créer un Footer dans lequel on ajoute un bouton</span>. Dans <span class="html">/components</span>, on crée donc un fichier <span class="html">Footer/index.jsx</span> au fonctionnement assez basique :</p>
<pre><code>import styled from 'styled-components'
import colors from '../../utils/style/colors'

function FooterContainer = styled.footer`
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    padding-top: 60px;
`

const NightModeButton = styled.button`
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: ${colors.secondary};
`

function Footer() {
    return (
        &lt;FooterContainer&gt;
            &lt;NightModeButton&gt;Changer de mode&lt;/NightModeButton&gt;
        &lt;/FooterContainer&gt;
    )
}

export default Footer</code></pre>
                    <p>Ce bouton dans notre Footer permettra de déclencher le dark mode de l'application. C'est maintenant le moment de <span class="em">créer notre Provider de Contexte pour le thème</span>. Pour cela, on va créer un dossier dédié au Contexte dans <span class="html">utils/context</span>. On crée un fichier <span class="html">index.jsx</span>.</p>
                    <p>On commence par importer <span class="html">{ createContext }</span> depuis <span class="html">react</span>, et initialiser notre Contexte pour le thème avec :</p>
<pre><code>export const ThemeContexte = createContext()</code></pre>
                    <p>Et on utilise ensuite <span class="html">ThemeContext</span> :</p>
<pre><code>export const ThemeProvider = ({ children }) =&gt; {
    const [theme, setTheme] = useState('light')
    const toggleTheme = () =&gt; {
        setTheme(theme === 'light' ? 'dark' : 'light')
    }

    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    )
}</code></pre>
                    <p>On a bien créé un composant qui nous permet de wrapper notre composant parent avec <span class="html">Provider</span> de thème. Le state de <span class="html">theme</span> et sa fonction pour le modifier, <span class="html">setTheme</span>, sont passés dans les <span class="html">values</span>. Ainsi, tous les composants enfants qui se retrouvent englobés par le <span class="html">Provvider</span> vont pouvoir accéder à <span class="html">theme</span> et <span class="html">setTheme</span>.</p>
                    <p>C'est le moment d'<span class="em">utiliser notre <span class="html">Provider</span> au plus haut niveau</span> où les composants devront pouvoir accéder au Contexte. On va donc le mettre dans <span class="html">index.jsx</span> à la racine de <span class="html">/src</span>. On a donc maintenant :</p>
<pre><code>ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;ThemeProvider&gt;
                &lt;GlobalStyle /&gt;
                &lt;Header /&gt;
                &lt;Routes&gt;
                    &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                    &lt;Route path="/survey+:questionNumber" element={&lt;Survey /&gt;} /&gt;
                    &lt;Route path="/results" element={&lt;Results /&gt;} /&gt;
                    &lt;Route path="/freelances" element={&lt;Freelances /&gt;} /&gt;
                    &lt;Route path="*" element={&lt;Error /&gt;} /&gt;
                &lt;/Routes&gt;
            &lt;/ThemeProvider&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
);</code></pre>
                    <p>Ça veut dire qu'on doit forcément mettre notre <span class="html">Provider</span> au niveau de notre <span class="html">router</span> ? Eh bien... Pas nécessairement ! Comme son nom l'indique, le Contexte nous sert à "contextualiser" nos datas. Cetaines parties de l'application ont besoin d'être au courant d'une partie du state, alors qu'il n'y en a pas du tout besoin ailleurs. <span class="em">À vous de voir quelle utilisation est la plus adaptée.</span></p>
                    <h4>Accédez à vos données avec useContext :</h4>
                    <p><span class="html">useContext</span> est un hook qui permet de se "brancher" depuis un composant enfant qui a été wrappé par un <span class="html">Provider</span>, et donc d'<span class="em">accéder simplement au state partagé</span>.</p>
                    <p>Mettons-le en pratique dès maintenant.</p>
                    <p>On va d'abord utiliser le <span class="html">theme</span> pour effectuer une modification très visible : <span class="em">modifier le <span class="html">background-color</span>  de toute notre application</span>.</p>
                    <p>Auparavant, on avait notre <span class="html">GlobalStyle</span> dans notre fichier <span class="html">index.jsx</span> à la racine de <span class="html">/src</span>, mais on va le déplacer dans un fichier à part dans <span class="html">/utils/style/GlobalStyle.jsx</span>. On va également modier GlobalStyle en composant fonction qui va nous permettre d'y utiliser des hooks (alors qu'avant c'était un simple style component). On a donc :</p>
<pre><code>function GlobalStyle() {
    return &lt;StyledGlobalStyle /&gt;
}</code></pre>
                    <p>Puis on importe <span class="html">ThemeContext</span> et <span class="html">useContext</span> avec :</p>
<pre><code>import { useContext } from 'react'
import { ThemeContext } from '../context/ThemeProvider'</code></pre>
                    <p>Ce qui nous permet de <span class="em">récupérer le thème</span> :</p>
<pre><code>function GlobalStyle() {
    const { theme } = useContext(ThemeContext)

    return &lt;StyledGlobalStyle isDarkMode={theme === 'dark'} /&gt;
}</code></pre>
                    <p>... et donc de <span class="em">passer une prop <span class="html">isDarkMode</span></span> en fonction du thème activé.</p>
                    <p>Dans notre <span class="html">Style</span>, on l'utilise ainsi :</p>
<pre><code>const StyledGlobalStyle = createGlobalStyle`
    * {
        font-family: 'Trebuchet MS', Helvetica, sans-serif;
    }

    body {
        /* Ici cette syntaxe revient au même que
        background-color: ${({ props}) =&gt;
        props.isDarkMode ? '#2F241' : 'white'};
        */
        background-color: ${({ isDarkMode }) =&gt; (isDarkMode ? 'black' : 'white')};
        margin: 0;
    }
`</code></pre>
                    <p>Et c'est parti pour la dernière pièce de notre puzzle : <span class="em">l'implémentation du bouton permettant de changer de mode</span>.</p>
                    <p>On retourne donc dans notre <span class="html">Footer/index.jsx</span>. De la même manière que ce qu'on a fait juste avant, on importe <span class="html">ThemeContext</span> et <span class="html">useContext</span>.</p>
                    <p>Et on récupère notre action <span class="html">toggleTheme</span> et <span class="html">theme</span> avec :</p>
<pre><code>const { toggleTheme, theme } = useContext(ThemeContext)</code></pre>
                    <p>... qu'on peut utiliser juste en dessous :</p>
<pre><code>function Footer() {
    const { toggleTheme, theme } = useContext(ThemeContext)
    return (
        &lt;FooterContainer&gt;
            &lt;NightModeButton onClick={() =&gt; toggleTheme()}&gt;
                Changer de mode : {theme === 'light' ? '☀️' : '🌙'}
            &lt;/NightModeButton&gt;
        &lt;/FooterContainer&gt;
    )
}</code></pre>
                    <p>Et si on teste...</p>
                    <figure>
                        <img src="../images/useContext_React_3.png" alt="">
                        <figcaption>La couleur du backgrouynd change bien au clic sur le bouton.</figcaption>
                    </figure>
                    <p>Bravo à vous : vous venez de créer un Contexte et vous l'avez utilisé avec <span class="html">useContext</span> pour créer un dark mode dans votre application.</p>
                    <p>Comme je vous le disais, vous êtes un chanceux : avant les hooks, le Contexte était plus compliqué à mettre en oeuvre. Je vous fais une démonstration juste en dessous de comment ça se passait.</p>
<pre><code>// import { useContext } from 'react'
import { ThemeContext } from '../../utils/context'
import styled from 'styled-components'
import colors from '../../utils/style/colors'

const FooterContainer = styled.footer`
    display: flex;
    flex-direction: row;
    align-item: center;
    justify-content: center;
    padding-top: 60px;
`

const NightModeButton = styled.button`
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: ${colors.secondary};
`

function Footer() {
    // const { toggleTheme, theme } = useContext(ThemeContext)

    return (
        &lt;ThemeContext.Consumer&gt;
            {({toggleTheme, theme}) =&gt; (
                &lt;FooterContainer&gt;
                    &lt;NightModeButton onClick={() =&gt; toggleTheme()}&gt;
                        Changer de mode : {theme === 'light' ? '☀️' : '🌙'}
                    &lt;/NightModeButton&gt;
                &lt;/FooterContainer&gt;
            )}
        &lt;/ThemeContext.Consumer&gt;
    )
}

export defaut Footer</code></pre>
                </article>
                <article>
                    <h2 id="hooks">Allez plus loin avec les hooks :</h2>
                    <p>Précédemment, vous avez découvert les hooks avec <span class="html">useState</span> et <span class="html">useEffect</span> et, ensemble, nous avons appris à les utiliser pour faire des calls API. Vous avez également découvert le Contexte et comment y accéder simplement avec <span class="html">useContext</span> : vous commencez à avoir quelques cartes en main pour utiliser les hooks dans vos applications React.</p>
                    <p>Et si je vous disais que vous pouvez créer vos propres hooks ?</p>
                    <h3>Créez vos propres hooks pour simplifier votre code :</h3>
                    <p>Je ne sais pas ce que ça évoque pour vous, mais moi la prmeière fois qu'on m'a dit que je pouvais créer mes propres hooks, ça m'a un peu fait paniquer. Je m'imaginais devoir travailler sur la codebase de React, et devoir créer un de ces fichiers immenses pour pouvoir faire tourner un hook "custom".</p>
                    <p>Détrompez-vous, la création d'un hook "custom" est <span class="em">toute simple</span> : il s'agit juste d'une fonction qui commence par "use", qui extrait de la logique réutilisable et qui peut utiliser d'autres hooks.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Comme pour tout le reste, créer des hooks n'est pas obligatoire, mais cela peut vous simplifier la vie ! Cette approche vous aidera à mettre en application le principe "DRY" ("don't reapeat yourself" ou "ne vous répétez pas"), avec des bouts de logique qui deviennent réutilisables à travers votre application.</p>
                    </div>
                    <p>Mettons en application ce que nous avons vu dès maintenant.</p>
                    <h4>Créez un hook pour vos calls API :</h4>
                    <p>Précédemment, vous avez appelé l'API du projet Shiny pour récupérer les profils des freelances, ainsi que les questions de notre questionnaire.</p>
                    <p>Si vous regardez votre code d'un peu plus près, vous aussi vous voyez <span class="em">une certaine répétition</span> ? C'est normal. On va donc essayer de mutualiser tout ça avec un hook "personnalisé" !</p>
                    <p>Pour cela, on crée dans <span class="html">/utils</span> un nouveau dossier qu'on appelle <span class="html">/hooks</span> et dans lequel on crée un fichier <span class="html">index.jsx</span>.</p>
                    <p>On va <span class="em">créer notre hook</span> qu'on base cette fois-ci sur la syntaxe <span class="html">async</span> / <span class="html">await</span> :</p>
<pre><code>import { useState, useEffect } from 'react'

export function useFetch(url) {
    const [data, setData] = useState({})
    const [isLoading, setLoading] = useState(true)

    useEffect(() =&gt; {
        if (!url) return

        async function fetchData() {
            const response = await fetch(url)
            const data = await response.json()
            setData(data)
            setLoading(false)
        }
        
        setLoading(true)
        fetchData()
    }, [url])

    return { isLoading, data }
}</code></pre>
                    <p>Le code est plutôt explicite, n'est-ce pas ? Pour notre nouveau hook, <span class="html">useFetch</span>, on lui passe en paramlètre l'URL de l'API qu'on veut appeler. Il possède un state interne qui lui permet de stocker la data, et de savoir si la data est en train de charger avec <span class="html">isLoading</span>.</p>
                    <p>Dans <span class="html">useEffect</span>, le hook fait un <span class="html">return</span> vide si le paramètre de l'URL est vide, et commence par mettre <span class="html">isLoading</span> à <span class="html">true</span>. Il déclare la fonction asynchrone <span class="html">fetchData</span> qui permet de :</p>
                    <ul>
                        <li>
                            <p>appeler <span class="html">fetch</span>;</p>
                        </li>
                        <li>
                            <p>parcer ce qui est retourné avec <span class="html">data.json()</span>;</p>
                        </li>
                        <li>
                            <p>et changer l'état de <span class="html">isLoading</span>.</p>
                        </li>
                    </ul>
                    <p><span class="html">url</span> fait partie du tableau de dépendances du <span class="html">useEffect</span>, ce qui permettra de redéclencher le call en cas de changement d'URL passée en paramètre. Puis on appelle notre fonction <span class="html">fetchData</span>.</p>
                    <p>Pour <span class="em">utiliser notre nouveau hook</span>, modifions <span class="html">/Survey/index.jsx</span>. On commence par importer notre hook avec :</p>
<pre><code>import { useFetch } from '../utils/hooks'</code></pre>
                    <p>Puis on <span class="em">récupère notre <span class="html">data</span></span> avec :</p>
<pre><code>const { data, isLoading } = useFetch(`http://localhost:8000/survey`)

const { surveyData } = data</code></pre>
                    <p>Je vous invite aussi à <span class="em">supprimer tout le contenu</span> du <span class="html">useEffect</span> qui permettait d'effectuer le <span class="html">fetch</span>. J'adore supprimer du code inutile : c'est super satisfaisant, non ?</p>
                    <p>On n'oublie pas de remplacer <span class="html">isDataLoading</span> par <span class="html">isLoading</span> qui sera plus générique ici, et de remplacer <span class="html">surveyData</span> par <span class="html">data</span>.</p>
                    <p>Est-ce que ça marche toujours ? ... Oh, on a une erreur qui empêche le code de tourner !</p>
                    <p>Pas de panique, c'est normal ! Pour faire la navigation, on a accédé au contenu de notre objet de questions en faisant <span class="html">data[questionNumber]</span>. Sauf qu'à l'initialisation, <span class="html">data</span> est un objet vide... Ce qui veut dire qu'avec :</p>
<pre><code>const { surveyData } = data</code></pre>
                    <p><span class="html">surveyData</span> est undefined. JavaScript provoque donc une erreur pour <span class="html">data[questionNumber]</span>. Une des manières déviter l'erreur est donc de vérifier que <span class="html">surveyData</span> est défini avant de l'utiliser dans le composant :</p>
<pre><code>&lt;QuestionContent&gt;

    {surveyData && surveyData[questionNumber]}

&lt;/QuestionContent&gt;</code></pre>
                    <p>Et voilà, notre page fonctionne à nouveau comme avant, en utilisant notre hook <span class="html">useFetch</span>, ce qui a permis de supprimer pas mal de code répétitif !</p>
                    <h4>Ajoutez une grestion d'erreur :</h4>
                    <p>Mais que se passe-t-il quand l'API nous renvoie une erreur ? Notre application ne se comportera pas comme prévu, et l'utilisateur n'en sera même pas informé. Je vous propose d'intégrer une gestion d'erreur dans notre hook <span class="html">useFetch</span> afin d'afficher à l'écran qu'il y a eu un problème.</p>
                    <p>Pour cela, dans <span class="html">utils/hooks/index.jsx</span>, on peut <span class="em">créer un state pour <span class="html">error</span></span> avec :</p>
<pre><code>const [error, setError] = useState(false)</code></pre>
                    <p>Puis, on <span class="em">ajoute un <span class="html">try</span> et un <span class="html">catch</span></span> à notre cher hook <span class="html">useFetch</span> :</p>
<pre><code>const function useFetch(url) {
    const [data, setData] = useState({})
    const [isLoading, setLoading] = useState(true)
    const [error, setError] = useState(false)

    useEffect(() =&gt; {
        if (!url) return
        setLoading(true)

        async function fetchData() {
            try {
                const response = await fetch(url)
                const data = await response.json()
                setData(data)
            } catch (err) {
                console.log(err)
                setError(true)
            } finally {
                setLoading(false)
            }
        }

        fetchData()
    }, [url])

    return { isLoading, data, error }
}</code></pre>
                    <p>Ce qui nous permet de passer <span class="html">error</span> à <span class="html">true</span> lorsqu'un problème est rencontré.</p>
                    <p>De la même manière, dans <span class="html">Survey.jsx</span>, on <span class="em">récupère maintenant <span class="html">error</span></span> :</p>
<pre><code>const { data, isLoading, error } = useFetch(`http://localhost:8000/survey`)</code></pre>
                    <p>Et on peut tout simplement <span class="em">ajouter au-dessous du <span class="html">return</span></span> :</p>
<pre><code>if (error) {
    return &lt;span&gt;Il y a un problème&lt;/span&gt;
}</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous voulez tester votre nouvelle gestion d'erreur, vous pouvez tout simplement stopper l'API et voir ce qui se passe... !</p>
                    </div>
                    <p>Et voilà, vous avez même géré les erreurs d'appel API !</p>
                    <p>Nous allons en profiter pour utiliser <span class="html">useFetch</span> pour envoyer les réponses de l'utilisateur, et donc récupérer les résultats de notre API depuis la page <span class="html">/results</span>.</p>
<pre><code>function formatQueryParams(answers) {
    const answersNumbers = Object.keys(answers)

    return answersNumbers.reduce((previousParams, answerNumber, index) =&gt; {
        const isFirstAnswer = index === 0
        const separator = isFirstAnswer ? '' : '&'
        return `${previousParams}${separator}a${answerNumber}=${answers[answerNumber]}`
    }, '')
}

function Results() {
    const { theme } = useContext(ThemeContext)
    const { answers } = useContext(SurveyContext)
    const queryParams = formatQueryParams(answers)

    const { data, isLoading, error } = useFetch(`http://localhost:8000/results?${queryParams}`)

    console.log('===== data =====', data)

    if (error) {
        return &lt;span&gt;Il y a un problème&lt;/span&gt;
    }

    const resultData = data?.resultsData

    return isLoading ? (
        &lt;LoaderWrapper&gt;
            &lt;Loader /&gt;
        &lt;/LoaderWrapper&gt;
    ) : (
        &lt;ResultsContainer theme={theme}&gt;
            &lt;ResultTitle thme={theme}&gt;
            ...
        &lt;/ResultsContainer&gt;
    )
}</code></pre>
                    <p>C'est pas mal ce <span class="html">useFetch</span>, je vais pouvoir l'implémenter dans toutes les bases de code en production ? Le hook <span class="html">useFetch</span> que nous avons codé ici est très pratique pour éviter de nous répéter... et pour pratiquer la création de hooks personnalisés. Mais dans les faits, ce code est un peu trop basique pour être utilisé en production. À la place, vous pouvez utiliser <a href="https://tanstack.com/query/latest/docs/react/overview" target="_blank">un outil bien plus robuste tel que <span class="html">TanStack Query</span> pour React</a>, qui vous permet d'utiliser des hooks pour faire vos requêtes et les mettre en cache dans vos applications.</p>
                    <h4>Maîtrisez les hooks :</h4>
                    <h5>Intégrez les règles des hooks :</h5>
                    <p>Je le rappelle ici : les hooks ont leurs propres règles d'utilisation.</p>
                    <ul>
                        <li>
                            <p>Les hooks sont uniquement accessibles dans un <span class="em">composant fonction React</span>. Donc ce n'est pas possible d'en utiliser dans un composant classe ou bien dans une simple fonction JavaScript.</p>
                        </li>
                        <li>
                            <p>Appelez les hooks au niveau racine de vos composants.</p>
                        </li>
                        <li>
                            <p>Attention au nommage de vos hooks personnalisés : même s'il ne s'agit pas vraiment d'une règle obligatoire, mais d'une convention, vos hooks personnalisés doivent commencer par <span class="html">use</span> pour que l'on sache en un coup d'oeil qu'il s'agit d'un hook.</p>
                        </li>
                    </ul>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Effectivement, il existe d'autres hooks mis à disposition par React, dont vous pouvez <a href="https://fr.reactjs.org/docs/hooks-reference.html" target="_blank">trouver la liste sur la documentation</a>.</p>
                    </div>
                    <p>Pour l'instant, voici quelques hooks que vous pourriez être susceptible de croiser dans différentes codebases :</p>
                    <dl>
                        <dt>useRef</dt>
                        <dd>je vous laisse regarder par vous-même la documentation si ça vous intéresse, mais même s'il existe plusieurs utilisations de <span class="html">useRef</span>, ce hook est avant tout utilisé pour interagir avec des éléments du DOM.</dd>
                        <dt>useReducer</dt>
                        <dd><span class="html">useReducer</span> permet de mieux gérer votre state lorsqu'il comporte de nombreuses propriétés qui doivent être modifiées régulièrement.</dd>
                        <dt>useMemo et useCallback</dt>
                        <dd>Ces deux hooks nous permettent d'éviter de refaire des calculs coûteux pour nos performances. Vous pouvez préciser des valeurs pour lesquelles il faudra refaire les calculs uniquement si l'un des paramètres change, grâce à <span class="html">useMemo</span> et <span class="html">useCallback</span>.</dd>
                    </dl>
                    <p>Et il en existe encore d'autres... À l'heure où ce cours a été écrit, nous en sommes à la version 17 de React. Mais nous ne sommes pas à l'abri que d'autres hooks soient créés entretemps.</p>
                </article>
                <article>
                    <h2 id="tests_React_Jest">Découvrez la base des tests dans React avec Jest :</h2>
                    <h3>Utilisez les tests automatisés dans React :</h3>
                    <p>Peu importe le langage dans lequel vous développez, les tests font partie intégrante du métier de développeur, même en frontend. Ils permettent de s'assurer de la <span class="em">fiabilité</span> de votre code.</p>
                    <h4>Comprenez l'utilité des tests :</h4>
                    <p>Rédiger des temps prend du <span class="em">temps</span> et de la <span class="em">réflexion</span>. Et pourtant, vous pouvez vous considérer comme chanceux : depuis quelques années apparaissent des outils de plus en plus simples à utiliser pour tester le JS. Encore une fois, quand vous codez seul sur une petite application, ça peut vite vous sembler pénible pour pas grand-chose. Mais essayez de vous projeter.</p>
                    <p>Lorsque vous travaillez sur une base de code qui comporte de <span class="em">nombreuses fonctionnalités</span>, et que vous <span class="em">codez à plusieurs</span>, il est si simple de faire une modification qui amène une <span class="em">régression</span> (introduction d'un bug en production). Surtout lorsque vous touchez à du code que vous n'avez pas écrit vous-même... et donc pour lequel vous ne saisissez pas toujours toutes les subtilités. Dans ces cas-là, c'est un vrai atout de savoir que vous pouvez <span class="em">compter sur les tests</span> pour vous signaler une erreur ! Vous <span class="em">évitez les régressions</span>, et vous <span class="em">gagnez en confiance sur vos modifications</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Un des meilleurs moyens pour s'obliger à recouvrir aux tests en équipe est d'intégrer une étape "test" directement lorsque vous pushez votre travail sur la plateforme où vous hévergez votre code versionné, typiquement sur <a href="https://github.com/" target="_blank">GitHub</a>. On appelle ça <span class="em">l'intégration continue</span>. Chaque commit sur une branche déclenche votre série de tests automatisés, et l'équipe ne merge pas le code si les tests ne fonctionnnent pas, ou bien si le code coverage n'est pas suffisant (nous verrons ce que c'est dans un très court instant).</p>
                    </div>
                    <p>Mais "test" est un tout petit mot qui recouvre une réalité bien plus grande : il existe de <span class="em">nombreux types de tests</span>.</p>
                    <h4>Faites la différence entre les types de tests :</h4>
                    <p>Il existe différents types de tests, les principaux sont <span class="em">les tests unitaires, d'intégration et end-to-end</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Une petite explication s'impose :</p>
                        <ul>
                            <li>
                                <p>Les tests <span class="em">unitaires</span> vont venir tester une petite partie de votre code de manière totalement indépendante : une fonction, un bout de script... Ils sont les plus rapides à écrire, mais n'assurent pas forcément vos arrières.</p>
                            </li>
                            <li>
                                <p>Les tests <span class="em">end-to-end</span>, quant à eux, permettent de tester l'intégralité d'une fonctionnalité de bout en bout. Ils sont beaucoup plus sécurisants, mais prennent donc beaucoup de temps à écrire.</p>
                            </li>
                            <li>
                                <p>Viennent enfin les tests <span class="em">d'intégration</span> qui sont souvent considérés comme le juste milieu entre sécurité fournie et temps requis pour les rédiger. Ils permettent de tester une fonctionnalité, en simulant des interactions utilisateur pour s'assurer que tout fonctionne bien comme prévu.</p>
                            </li>
                        </ul>
                    </div>
                    <p>Cela ne veut pas dire que vous devez totalement abandonner les tests unitaires et les tests end-to-end, mais qu'il est important de <span class="em">trouver un juste milieu</span> entre les trois types. Par exemple, vous pouvez totalement choisir d'implémenter des tests end-to-end spécifiquement pour une fonctionnalité "critique" de votre application.</p>
                    <h3>Créez votre premier test avec Jest :</h3>
                    <p>Comme tout ce qui a trait à JavaScript, l'écosystème des tests évolue très vite. Dans cette partie, nous allons utiliser <span class="em">Jest</span> et <span class="em">React Testing Library</span>.</p>
                    <p>Pour sa part, Jest fait partie des outils acclamés depuis plusieurs années, et il se trouve également que Jest est déjà installé Create-React-App. Pas mal pour se lancer dans les tests.</p>
                    <p>Quant à React Testing Library, il s'agit d'une bibliothèque qui donne accès à davantage d'outils permettant de tester des composants. Nous la découvrirons un peu plus tard.</p>
                    <p>Si vous vous demandez comment les deux s'articulent, vous pouvez vous dire que Jest est l'outil de base pour vos tests, et que React Testing Library est l'outil qui vous facilite les tests de composants.</p>
                    <p>Plongeons ensemble dans le monde des tests avec un premier exemple de Jest :</p>
                    <p>Par exemple, dans <span class="em">Home/index.jsx</span>, on a une fonction <span class="em">sum</span> qui additionne deux nombres :</p>
<pre><code>export function sum(a, b) {
    return a + b
}</code></pre>
                    <p>On va créer le fichier de tests <span class="em">Home/index.test.js</span> :</p>
<pre><code>import {sum} from './'

test('Ma fonction sum', () =&gt; {
    const result = sum(3, 7)
    expect(result).toBe(10)
})</code></pre>
                    <p>Et on lance la commande suivante :</p>
<pre><code>yarn run test</code></pre>
                    <p>Maintenant, <span class="em">écrivons un test unitaire</span>.</p>
                    <h4>Préparez votre code :</h4>
                    <p>Pour tester notre code de manière indépendante, nous allons <span class="em">sortir une partie de notre logique</span> sur la page <span class="html">/Results/index.jsx</span>. On peut faire la fonction :</p>
<pre><code>export function formatJobList(title, listLength, index) {
    if (index === listLength - 1) {
        return title
    }
    return `${title},`
}</code></pre>
                    <p>Et dans notre JSX, on met :</p>
<pre><code>&lt;ResultsTitle theme={theme}&gt;
    Les compétences dont vous avez besoin :
    {resultsData &&
        resultsData.amp((result, index) =&gt; (
            &lt;JobTitle
                key={`result-title-${index}-${result.title}`}
                theme={theme}
            &gt;
                {formatJobList(result.title, resultsData.length, index)}
            &lt;/JobTitle&gt;
        ))}
&lt;/ResultsTitle&gt;</code></pre>
                    <p>Nous voilà dond fin prêts pour notre test.</p>
                    <h4>Créez votre fichier de test :</h4>
                    <p>Depuis quelques temps, tous nos fichiers sont répartis dans des dossiers ayant un nom spécifique et un fichier <span class="html">index.jsx</span>. Eh bien, cette répartition va nous être bien utile car elle va nous permettre de <span class="em">mettre nos tests directement à la racine de chaque dossier</span>.</p>
                    <p>On va donc commencer par <span class="html">/Results</span> et y créer un fichier <span class="html">index.test.js</span>, et voilà !</p>
                    <p>Mais comment Jest va retrouver notre fichier de test ? Eh bien, pas de panique. Jest est ici configuré pour chercher dans tous les sous-dossiers (à part <span class="html">node_modules</span> et <span class="html">.git</span>, notamment) à la recherche de fichiers se terminant par <span class="html">spec.js</span> ou <span class="html">test.js</span>, précédé d'un trait d'union (-) ou d'un point (.). C'est également possible de mettre vos tests dans un dossier <span class="html">__tests__</span>.</p>
                    <h4>Comprenez la rédaction du test :</h4>
                    <p>Attelons-nous maintenant à la <span class="em">rédaction du test</span>.</p>
                    <p>Il nous faut dans un premier temps <span class="em">importer l'élément</span> à tester, puis <span class="em">utiliser <span class="html">test</span></span>.</p>
                    <p>On utilise <span class="html">test</span>, mais on ne l'a importé nulle part ? Pourquoi on n'a pas une erreur ici ? Eh bien, test un outil auquel on peut accéder globalement dans un fichier de test grâce à Jest. Il existe d'autres outils globaux, <a href="https://jestjs.io/docs/api" target="_blank">vous pourrez en apprendre davantage sur la documentation (en anglais)</a>.</p>
                    <p>Vérifions dès maintenant que notre test fonctionne. Dans <span class="html">Results/results.test.js</span>, on importe notre fonction, et on prépare le test :</p>
<pre><code>import { formatJobList } from './'

test('Ceci est mon premier test', () =&gt; {})</code></pre>
                    <p>Notez bien que <span class="html">test()</span> prend une <span class="html">string</span> en premier <span class="html">argument</span>, puis une fonction en deuxième argument.</p>
                    <p>J'essaie dès maintenant de <span class="em">lancer la commande <span class="html">yarn run test</span></span> dans mon terminal.</p>
                    <figure>
                        <img src="../images/test_React.png" alt="">
                        <figcaption>Aucun fichier de test n'est trouvé</figcaption>
                    </figure>
                    <p>... C'est complètement normal. Ici, nous n'avons pas écrit le coeur de notre test : <span class="em">exécuter notre fonction</span>, et <span class="em">comparer avec une référence</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Notez ici que Jest ne rend pas la main : il est en mode "watch", c'est-à-dire qu'il <span class="em">surveille</span> vos fichiers et relance les tests appropriés si besoin. Ce mode a été exécuté automatiquement par <span class="html">"react-scripts test"</span>. Pour arrêter Jest dans ce cas, il vous suffit d'appuyer sur <span class="html">q</span> (quitter) ou de taper <span class="html">Ctrl+C</span>.</p>
                    </div>
                    <p>Pour cela, on va utiliser <span class="html">expect</span> et <span class="html">toEqual</span>. Ici, <span class="html">toEqual</span> est ce qui s'appelle <span class="em">un matcher</span>, mis à disposition par Jest. On utilise la fonction <span class="html">expect()</span>, qui va comparer un élément avec notre <span class="em">matcher</span>. Cela nous oblige à nous interroger sur ce qu'on veut obtenir de <span class="html">formatJobList</span>.</p>
                    <p>On prend par exemple un élément <span class="html">item2</span> qui sera en deuxième position dans notre liste (son index est donc de 1), mais qui ne sera pas le dernier élément : on veut donc que <span class="em">le titre ajoute une virgule</span>.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>import { formatJobList } frrom './'

test('Ceci est mon premier test', () =&gt; {
    const expectedState = 'item2,'
    expect(formatJobList('item2', 3, 1)).toEqual(expectedState)
})</code></pre>
                    <p>On sauvegarde, et nos tests se lancent automatiquement (sauf si on a quitté le mode <span class="html">watch</span>). On a bien du vert !</p>
                    <figure>
                        <img src="../images/test_React_1.png" alt="">
                        <figcaption>Notre premier test est tout bon !</figcaption>
                    </figure>
                    <p>Vous avez vu : ce n'était pas si dur, n'est-ce pas ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous aurez besoin de nombreux autres <span class="em">matchers</span> pour comparer ce que votre code retourne avec les outils de Jest, par exemple <span class="html">toBe</span>, <span class="html">toContains</span>, etc.</p>
                        <p>Pour en savoir plus, je vous conseille <a href="https://jestjs.io/docs/getting-started" target="_blank">de lire la documentation Jest (en anglais)</a>.</p>
                    </div>
                    <p>Il existe aussi d'autres fonctions, telles que <span class="html">describe()</span>.</p>
                    <p><span class="html">describe</span> vous permet d'<span class="em">englober plusieurs tests</span> qui ont un lien entre eux (vous êtes libre de choisir quel est ce lien), et que cela s'affiche de manière plus lisible lorsque vous lancez vos tests. Dans notre exemple, on peut maintenant ajouter un test pour vérifier que notre fonction ne met pas de virgule sur le dernier élément :</p>
<pre><code>import { formatJobList } from './'

describe('La fonction formatJobList', () =&gt; {
    test('ajoute une virgule à un item', () =&gt; {
        const expectedState = 'item2,'
        expect(formatJobList('item2', 3, 1)).toEqual(epectedState)
    })
    test('ne met pas de virgule pour le dernier élément', () =&gt; {
        const expectedState = 'item3'
        expect(formatJobList('item3', 3, 2)).toEqual(expectedState)
    })
})</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/test_React_2.png" alt="">
                        <figcaption>Nos deux tests marchent !</figcaption>
                    </figure>
                    <p>C'est beaucoup plus lisible, n'est-ce pas ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Jusqu'à maintenant, vous utilisé "test" pour écrire vos tests. Mais il existe un alias pour cette fonction : <span class="html">it()</span>.</p>
                    </div>
                    <p>Comme pour tout, il existe des <span class="em">conventions de rédaction de tests</span> pour que les appellations soient <span class="em">les plus explicites possibles</span>. Une des conventions possibles consiste à commencer tous les tests par "should". Dans ce cas, c'est encore plus explicite d'utiliser l'alias <span class="html">it</span> dont je viens de vous parler. Ce qui aurait donné dans notre cas :</p>
<pre><code>import { formatJobList } from './'

describe('La fonction formatJobList', () =&gt; {
    it('ajoute une virgule à un item', () =&gt; {
        const expectedState = 'item2,'
        expect(formatJobList('item2', 3, 1)).toEqual(epectedState)
    })
    it('ne met pas de virgule pour le dernier élément', () =&gt; {
        const expectedState = 'item3'
        expect(formatJobList('item3', 3, 2)).toEqual(expectedState)
    })
})</code></pre>
                    <h3>Assurez-vous d'avoir le test coverage idéal :</h3>
                    <p>Lorsqu'on commence à avoir des tests, il devient possible de mesurer la <span class="em">couverture de tests (code coverage)</span>, c'est-à-dire le pourcentage de notre code - à l'expression près ! - qui est couvert par les tests. On peut alors repérer les parties non testées, ou insuffisamment testées, et savoir ainsi où concentrer nos prochains efforts d'écriture de test.</p>
                    <p>Lançons dès maintenant la commande nous permettant de vérifier notre code coverage.</p>
                    <p>Pour cela, je fais <span class="html">yarn test -- --coverage</span>.</p>
                    <figure>
                        <img src="../images/test_React_3.png" alt="">
                        <figcaption>Le test coverage s'affiche sous la forme d'un tableau dans le terminal.</figcaption>
                    </figure>
                    <p>On a donc le détail de la couverture de nos tests, y compris des lignes qui ne sont pas couvertes par les tests.</p>
                    <p>Il existe des services qui permettent d'utiliser la couverture de tests comme critère de blocage pour l'intégration de nouveau code à nos projets, en définissant des exigences de taux absolu plancher, ou l'interdiction de faire baisser le taux existant, pour autoriser une <span class="em">pull request</span> à être fusionnée dans sa branche destinataire.</p>
                    <p>Il peut être très satisfaisant d'augmenter son code coverage au maximum. Mais attention, le code coverage peut être traître : non seulement, vous pouvez perdre trop de temps afin d'essayer d'obtenir 100% de couverture, ce qui, la plupart du temps, n'est pas nécessaire. D'autant plus quand on sait que les tests doivent être maintenus dans le temps, en gardant la même logique à l'esprit. Et un autre point de vigilance : le coverage ne prend pas du tout compte la pertinence de vos tests. Alors, ne vous laissez pas aveuglément séduire !</p>
                </article>
                <article>
                    <h2 id="React_Testing_Library">Testez vos composants avec React Testing Library :</h2>
                    <p>Pour l'instant, nous avons appris à faire de simples tests unitaires pour tester des fonctions simples. Mais qu'en est-il du comportement de nos composants . Comment vérifier que ce qui est affiché pour l'utilisateur fonctionne bien comme on le souhaite, et qu'il n'y a pas de régession ?</p>
                    <p>En d'autres mots, comment faire pour <span class="em">tester nos composants</span> ?</p>
                    <p>Vous avez pu voir précédemment que pour tester, on exécute, et on compare avec ce qui était attendu. Or, nos composants React fournissent des instructions permettant de mettre à jour le DOM. Pour tester nos composants, il faudra donc <span class="em">faire un render, vérifier le DOM généré, et le comparer avec ce qui était attendu</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous pouvez en apprendre davantage sur la logique des tests directement sur <a href="https://reactjs.org/docs/testing-recipes.html" target="_blank">la documentation de React</a>.</p>
                    </div>
                    <p>Pour faire ça, nous allons pouvoir utiliser React Testing Library, la bibliothèque dont je vous ai déjà parlé.</p>
                    <h3>Découvrez React Testing Library :</h3>
                    <p>React Testing Library nous donne accès à des outils basés sur <span class="html">react-dom</span> et <span class="html">react-fom/test-utils</span> qui nous permettent de <span class="em">respecter les bonnes pratiques</span> des tests et de profiter de <span class="em">messages d'erreur lisibles</span>.</p>
                    <p>Cette solution ne remplace pas Jest, au contraire, elle est <span class="em">complémentaire</span> à Jest. React Testing Library nous permet de vraiment nous concentrer sur le DOM, en le recréant, en permettant de simuler des interactions et de vérifier ce qui est rendu? Cela nous aide à <span class="em">nous mettre dans la peau de nos utilisateurs</span>, et à anticiper ce qu'ils verront.</p>
                    <p>Par exemple, lorsqu'on veut tester un composant qui fait un call API, on n'a pas forcément besoin de vérifier le <span class="html">useEffect</span> et le <span class="html">state</span> qui nous permettent de faire tout ça. La logique de React Testing Library est de vérifier qu'on a bien notre composant, qu'il est remplacé par un loader le temps que les datas chargent, puis qu'il est complété avec les datas qu'on a récupérées.</p>
                    <p>Mais ici... On a affaire à des tests d'intégration ou des tests unitaires ? Eh bien, React Testing Library nous permet de faire <span class="em">les deux</span>. On va pouvoir tester nos hooks en isolation pour faire des tests unitaires dessus, et tester les interactions entre nos différents composants, faisant ainsi des tests d'intégration.</p>
                    <p>Lançons-nous dès maintenant dans le test de nos composants avec React Testing Library... !</p>
                    <h3>Créez un test simple d'un composant :</h3>
                    <p>Mais... on n'a même pas installé la bibliothèque ? C'est normal, pas besoin d'installation ici puisque React Testing Library fait maintenant partie des outils istallés de base par Create React App. Il nous suffit juste d'importer ce dont on a besoin dans notre fichier de test.</p>
                    <p>Nous allons commencer par <span class="em">tester notre composant <span class="html">Footer</span></span> qui permet de changer de thème. Dans <span class="html">/components/Footer</span>, on crée donc un fichier <span class="html">index.test.js</span>.</p>
                    <p>Nous allons commencer tout d'abord nous <span class="em">assurer que <span class="html">Footer</span> render bien</span>, sans crasher. Pour cela, on importe <span class="html">Footer</span>, le <span class="html">render</span> de React Testing Library, et on utilise <span class="html">render</span> :</p>
<pre><code>import Footer from './'
import { render } from '@testing-library/react'

describe('Footer', () =&gt; {
    test('Should render without crash', async () =&gt; {
        render(&lt;Footer /&gt;;)
    })
})</code></pre>
                    <p>Si vous n'avez pas quitté le mode watch, vos tests se lancent automatiquement... Ou sinon, vous pouvez refaire <span class="html">yarn run test</span>. Et on a <span class="em">une erreur</span>...</p>
<pre><code>TypeError: Cannot destructure property toggleTheme of '(0 , _react.useContext)(...)' as it is undefined.</code></pre>
                    <p>Évidemment ! Notre composant fait partie d'un ensemble qui utilise le Contexte... Or, ici, notre composant n'est pas englobé par notre Provider de thème <span class="html">light</span> / <span class="html">dark</span>.</p>
                    <p>Pas de panique, vous vous en doutez : React Testing Library nous permet de gérer ça. Il y a un moyen plus propre que nous verrons un peu plus tard, mais pour l'instant, contentons-nous de <span class="em">wrapper le composant <span class="html">Footer</span> avec <span class="html">ThemeProvider</span> directement dans notre test</span> :</p>
<pre><code>import Footer from './'
import { render } from '@testing-library/react'
import { ThemeProvider } from '../../utils/context'

describe('Footer', () =&gt; {
    test('Should render without crashing', async () =&gt; {
        render(
            &lt;ThemeProvider&gt;
                &lt;Footer /&gt;
            &lt;/ThemeProvider&gt;
        )
    })
})</code></pre>
                    <p>Et bravo ! Ainsi le retour de notre test est <span class="em">tout vert</span>.</p>
                    <p>Profitons-en pour aller un peu plus loin dans ce que l'on teste dans notre composant.</p>
                    <h3>Testez les événements de vos composants :</h3>
                    <p>Je vous ai déjà parlé du fait que la philosophie React Testing Library est de se mettre dans la peau de votre utilisateur.</p>
                    <p>Alors comment faire pour tester que notre <span class="html">NightModeButton</span> fonctionne bien ? Ici, il n'est pas question de vérifier le state interne de notre Contexte. Au lieu de ça, <span class="em">regardons ce que l'utilisateur voit</span>.</p>
                    <p>Le bouton affiche "☀️" lorsque nous sommes en mode jour et "🌙" pour le mode nuit. Il faut donc que l'on vérifie ce qui est affiché.</p>
                    <p>On va donc récupérer le contenu de notre bouton, et comparer le texte affiché - allons-y !</p>
                    <h4>Interagissez avec un élément :</h4>
                    <p>La bibliothèque met à jour toute une série de <span class="em">sélecteurs</span> permettant d'<span class="em">accéder à un élément spécifique</span> (comme en JavaScript). N'hésitez pas à jeter un oeil à <a href="https://testing-library.com/docs/react-testing-library/cheatsheet" target="_blank">la documentation de React Testing Library (en anglais)</a> pour découvrir tous les sélecteurs auxquels vous avez accès.</p>
                    <p>Vous pouvez sélectionner un élément <span class="em">selon son rôle, son label, son placeholder</span>, etc. Dans notre cas, notre <span class="html">Footer</span> ne contient qu'un seul bouton. On peut donc très simplement utiliser <span class="html">getByRole</span>.</p>
                    <p>On va également avoir besoin de <span class="html">screen</span> qu'on importe avec <span class="html">render</span> :</p>
<pre><code>import { render, screen } from '@testing-library/react'</code></pre>
                    <p>C'est quoi encore ça, <span class="html">screen</span> ? Eh bien, <span class="html">screen</span> est en quelque sorte le <span class="html">body</span> qui contient notre composant, à partir duquel on va pouvoir utiliser nos sélecteurs.</p>
                    <p>Pour <span class="em">accéder à notre bouton</span>, on a donc :</p>
<pre><code>test('Change theme', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Footer /&gt;
        &lt;/ThemeProvider&gt;
    )
    const nightModeButton = screen.getByRole('button')
})</code></pre>
                    <p>Et à partir de là, les choses sérieuses commencent !</p>
                    <p>Comme précédemment, on va <span class="em">comparer ce qui est attendu avec ce qui se passe vraiment</span>. Alors réfléchissons.</p>
                    <p>Au départ, notre thème est récupéré. Sa valeur initiale est <span class="html">light</span> : le "☀️" est affiché. Lorsqu'on clique sur le bouton, la valeur du thème change (avec <span class="html">toggleTheme</span>), et le thème devient <span class="html">dark</span>. Le bouton affiche alors "🌙". Un bon test est de :</p>
                    <ol>
                        <li>
                            <p>Vérifier la présence de "☀️".</p>
                        </li>
                        <li>
                            <p>Cliquer sur le bouton.</p>
                        </li>
                        <li>
                            <p>Vérifier s'il y a bien "🌙".</p>
                        </li>
                    </ol>
                    <p>Commençons donc par la première étape, <span class="em">la présence de "☀️"</span>.</p>
<pre><code>test('Change theme', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Footer /&gt;
        &lt;/ThemeProvider&gt;
    )
    const nightModeButton = screen.getByRole('button')
    expect(nightModeButton.textContent).toBe('Changer de mode : ☀️')
})</code></pre>
                    <p>En vérifiant notre terminal, ce test fonctionne bien.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>D'ailleurs, n'hésitez pas <span class="html">textContent</span> pour casser votre test et voir ce qui se passe.</p>
                    </div>
                    <p>On passe donc à l'étape 2, et on peut enchaîner directement avec l'étape 3 puisqu'elle ressemble fortement à l'étape 1.</p>
                    <p>Pour <span class="em">interagir avec notre composant</span>, on a besoin de <span class="html">fireEvent</span> qui va nous permettre de <span class="em">déclencher des événements du DOM</span>, ici <span class="html">click</span>. On fait donc :</p>
<pre><code>import { render, screen, fireEvent } from '@testing-library/react'
import { ThemeProvider } from '../../utils/context'
import Footer from './'

test('Change theme', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Footer /&gt;
        &lt;/ThemeProvider&gt;
    )
    const nightModeButton = screen.getByRole('button')
    expect(nightModeButton.textContent).toBe('Changer de mode : ☀️')
    fireEvent.click(nightModeButton)
    expect(nightModeButton.textContent).toBe('Changer de mode : 🌙')
})</code></pre>
                    <p>Bravo à vous ! Vous venez de tester avec succès votre composant <span class="html">Footer</span> !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous avons utilisé le sélecteur <span class="html">getByRole</span>. Ce sélecteur peut dans beaucoup de cas vous permettre d'accéder à votre élément, d'autant que vous pouvez lui passer un paramètre pour cibler encore plus précisément un élément. Mais dans le cas où vous ne pouvez pas l'utiliser, et où aucun autre sélecteur ne vous permet de cibler votre élément, vous pouvez tout à fait passer <span class="html">data-testid</span> à votre composant et ensuite y accéder avec le sélecteur <span class="html">getByTestId</span>. Je vous laisse regarder <a href="https://testing-library.com/docs/queries/bytestid" target="_blank">la documentation de React Testing Library par vous-même (en anglais)</a>.</p>
                    </div>
                    <p>Voyons maintenant quelques méthodes supplémentaires pour faire des tests :</p>
                    <p>On va vérifier dans <span class="html">Home/index.test.js</span> que le titre de la page s'affiche bien :</p>
<pre><code>import { MemoryRouter } from 'react-router-dom'
import { render, screen } from '@testing-library/react'
import Home from './'
import { ThemeProvider } from '../../utils/context'

describe('The home component', () =&gt; {
    it('should render title'; () =&gt; {
        render(
            &lt;MemoryRouter&gt;
                &lt;ThemeProvider&gt;
                    &lt;Home /&gt;
                &lt;/ThemeProvider&gt;
            &lt;/MemoryRouter&gt;
        )
        expect(
            screen.getByRole('heading', {level: 2, 'text: Récupérez vos besoins, on s'occupe du reste, avec les meilleurs talents' })
        ).toBeTruthy()
    })
})</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Le composant &lt;MemoryRouter&gt; utilisé précédemment, importé de React Router, nous permet d'inclure le router dans les tests. Vous pourrez trouver plus d'information dans <a href="https://reactrouter.com/en/main/router-components/memory-router" target="_blank">la documentation</a>.</p>
                    </div>
                    <h4>Testez vos hooks :</h4>
                    <p>Précédemment, vous avez appris à créer vos propres hooks personnalisés. Mais <span class="em">comment tester ses hooks</span> ?</p>
                    <p>Il pourrait être tentant de les tester indépendamment, mais la plupart du temps, ça ne correspond pas à la philosophie de React Testing Library. En effet, ces tests peuvent être considérés comme des "tests de détails d'implémentation", qui prennent du temps, pour ne pas être forcément très pertinents, précisément ce qu'on cherche à éviter.</p>
                    <p>De toute manière, ici, vous avez <span class="em">déjà testé un de vos hooks</span> sans vous en rendre compte. Allez-y, lancez la commande <span class="html">yarn test -- --coverage</span> pour voir.</p>
                    <figure>
                        <img src="../images/React_Testing_Library_1.png" alt="">
                        <figcaption>Voilà un screenshot du coverage.</figcaption>
                    </figure>
                    <p>Vous voyez que votre fichier <span class="html">utils/hooks/index.jsx</span> est effectivement testé (le pourcentage est bas, car le hook qui est dans le même fichier <span class="html">useFetch</span> n'a pas été testé). En effet, <span class="em">votre composant <span class="html">Footer</span> utilise le hook <span class="html">useTheme</span></span> pour accéder à <span class="html">theme</span> et <span class="html">toggleTheme</span>. Et la plupart du temps, c'est la méthode à privilégier.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous souhaitez en savoir plus sur ce sujet, ou tout de même savoir comment tester des hooks, je vous conseille de lire <a href="https://kentcdodds.com/blog/how-to-test-custom-react-hooks" target="_blank">cet article (en anglais) du créateur de React Testing Library</a>.</p>
                    </div>
                    <p>La leçon à retenir est donc que pour tester un hook, le meilleur moyen est de <span class="em">tester un composant qui utilise ce hook</span>.</p>
                    <h3>Allez plus loin dans vos tests :</h3>
                    <p>Qu'il s'agisse de Jest ou de React Testing Library, ces outils sont très puissants : ils permettent de simuler à peu près ce que l'on veut.</p>
                    <p>Dans notre application Shiny, la majeure partie de notre contenu vient des données que l'on récupère depuis une API (comme on aurait récupéré notre contenu depuis un CMS). Les calls API ne dérogent pas à la règle : les datas peuvent <span class="em">être simulées dans nos tests</span> et on appelle ça des <span class="em">mocks</span> (des simulations) ! Nous allons donc pouvoir tester nos autres composants.</p>
                    <h4>Testez des composants qui font des calls API :</h4>
                    <h5>Installez msw pour faire vos simulations de calls API :</h5>
                    <p>Pour pouvoir simuler nos calls API, un peu de configuration s'impose à nous. Si, comme moi, vous n'aimez pas la config, ne vous inquiétez pas : je vous promets que ça ne durera pas trop longtemps !</p>
                    <p>Pour faire nos mocks, React Testing Library recommande d'utiliser une bibliothèqye externe : <a href="https://github.com/mswjs/msw" target="_blank">MSW (pour Mock Service Worker), hébergée sur GitHub</a>. On commence donc par <span class="em">installer la bibliothèque</span> :</p>
<pre><code>yarn add msw --dev</code></pre>
                    <p>Pour faire simple, la biliothèque <span class="html">msw</span> va permettre d'<span class="em">intercepter les calls API que font vos composants lors des tests</span>. Et fonc, elle permet de <span class="em">simuler ce qui aurait été retourné</span>, sans même que votre application ait conscience de quoi que ce soit.</p>
                    <h5>Créez vos mocks :</h5>
                    <p>Pour cela, dans chacun de nos fichiers de test, on va devoir configurer un "server", qui va s'occuper de l'interception des calls API. Lançonnous dès maintenant dans le <span class="em">test du composant de la page</span> <span class="html">Freelances/index.jsx</span>. On crée donc un fichier dans <span class="html">/pages/Freelances</span>, qu'on appelle <span class="html">index.test.js</span>.</p>
                    <p>On va avoir besoin de <span class="html">rest</span> depuis <span class="html">msw</span>. On fait donc :</p>
<pre><code>import { rest } from 'msw'
import { setupServer } from 'msw/node'
import { render, waitFor, screen } from '@testing-library/react'

import Freelances from './'

const server = setupServer(
    // On précidr ivi l'url qu'il faudra "intercepter"
    rest.get('http://localhost:8000/freelances', (req, res, ctx) =&gt; {
        // Là on va pouvoir passer les datas mockées dans ce qui est retourné en json
        return res(ctx.json({}))
    })
)

// Active la simulation d'API avant les tests depuis server
beforeAll(() =&gt;server.listen())
// Réinitialise tout ce qu'on aurait pu ajouter en termes de durée pour nos tests avant chaque test
afterEach(() =&gt; server.resetHandlers())
// Ferme la simulation d'API une fois que les tests sont finis
afterAll(() =&gt; server.close())</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, <span class="html">beforeAll()</span>, <span class="html">beforeEach()</span> et <span class="html">afterEach</span> n'ont pas besoin d'être importés au même titre que test et describe : ils font partie de l'environnement global de Jest. Vous ne trouverez égalemnt dans <a href="https://jestjs.io/docs/api" target="_blank">la documentation des <span class="html">Globals</span> de Jest</a>. Comme leur nom l'indique :</p>
                        <ul>
                            <li>
                                <p><span class="html">beforeAll</span> est exécuté avant les tests;</p>
                            </li>
                            <li>
                                <p><span class="html">beforeEach</span> est exécuté avant chaque test;</p>
                            </li>
                            <li>
                                <p>et <span class="html">afterEach</span> est exécuté après chacun des tests.</p>
                            </li>
                        </ul>
                    </div>
                    <p>Et voilà, c'est tout pour la configuration !</p>
                    <p>Mais... elle est où la data qu'on renvoie ?! Très bien vu. Je ne l'avais pas encore mise. Il nous faut un <span class="em">format qui corresponde à ce que l'API nous renvoie</span>. So vpis faites un <span class="html">console.log</span> de ce que <a href="http://localhost:8000/freelances" target="_blank">http://localhost:8000/freelances</a> vous retourne, vous verre que c'est une liste d'objets. On crée donc une liste d'objets pour notre mock :</p>
<pre><code>const freelancersMockedData = [
    {
        name: 'Harry Potter',
        job: 'Magicien fontend',
        picture: '',
    },
    {
        name: 'Hermione Granger',
        job: 'Magicienne fullstack',
        picture: '',
    },
]</code></pre>
                    <p>... qu'on <span class="em">retourne dans notre mock</span> :</p>
<pre><code>const server = setupServer(
    // On précidr ivi l'url qu'il faudra "intercepter"
    rest.get('http://localhost:8000/freelances', (req, res, ctx) =&gt; {
        // Là on va pouvoir passer les datas mockées dans ce qui est retourné en json
        return res(ctx.json({ freelancersList: freelancersMockedData }))
    })
)</code></pre>
                    <p>Tout est prêt ! C'est le moment d'utiliser tout ça.</p>
                    <h5>Exploitez vos mocks :</h5>
                    <p>Notre configuration est prête. On va pouvoir l'utiliser pour tester <span class="html">pages/Freelances/index.jsx</span>.</p>
                    <p>Mais avant de la tester, arrêtons-nous quelques instants sur <span class="em">notre stratégie de tests</span>. Notre composant affiche un loader pendant qu'il fait la requête à l'API, puis affiche les données dans des composants <span class="html">Cards</span>. Dans un premier temps, on peut donc vérifier que :</p>
                    <ol>
                        <li>
                            <p><span class="em">Le loader s'affiche bien</span> pendant le call.</p>
                        </li>
                        <li>
                            <p>Notre première <span class="html">Card</span> <span class="em">affiche bien les éléments récupérées</span> dans le call avec le premier élément.</p>
                        </li>
                    </ol>
                    <p>Commençons par nous occuper de la première étape. On sait que <span class="html">isLoading</span> est initialisé à <span class="html">true</span>, donc on peut tout simplement vérifier que notre <span class="html">Loader</span> apparaît bien.</p>
                    <p>Mais d'ailleurs, on fait comment ? Notre <span class="html">Loader</span> est une simple <span class="html">div</span> stylisée, il ne contient pas de texte ? Je vous l'avais mentionné précédemment, c'est maintenant le moment d'<span class="em">utiliser <span class="html">data-testid</span></span>. On va tout simplement le préciser dans <span class="html">Freelances/index.jsx</span> :</p>
<pre><code>&lt;Loader theme={theme} data-testid="loader" /&gt;
```
Et dans notre test, on le récupère avec :
```
test('Should render without crash', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Freelances /&gt;
        &lt;/ThemeProvider&gt;
    )
    expect(screen.getByTestId('loader')).toBeTruthy()
})</code></pre>
                    <p>Votre test se lance. Ça <span class="em">fonctionne</span>.</p>
                    <p>C'est bien beau, "ça fonctionne", mais qu'est-ce qui me dit que mon test n'est pas toujours bon ? Que ça fonctionne quoi qu'il arrive ? Essayez de changer l'<span class="html">id</span> pour vous assurer que ça casse bien :</p>
<pre><code>expect(screen.getByTestId('cetIdCorrespondÀRien')).toBeTruthy()</code></pre>
                    <p>Notre test <span class="em">échoue</span> bien.</p>
                    <p>On va maintenant tester avec nos datas. Pour cela, on va avoir besoin de <span class="html">waitFor</span> que je vous ai déjà importer juste avant depuis <span class="html">'@testing-library/react'</span>. Cette méthode permet de <span class="em">gérer du code asynchrone</span>, comme pour un call API, par exemple. On n'oublie d'ailleurs pas d'<span class="em">ajouter un <span class="html">async</span></span> devant le callback de notre test.</p>
                    <p>On va vérifier ici que <span class="em">notre code affiche bien les noms</span> "Harry Potter" et "Hermione Granger". Pour cela, on a :</p>
<pre><code>it('Should display freelancers names', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Freelances /&gt;
        &lt;/ThemeProvider&gt;
    )
    expect(screen.getByTestId('loader')).toBeTruthy()
    await waitFor(() =&gt; {
        expect(screen.getByText('Harry Potter')).toBeTruthy()
        expect(screen.getByText('Hermione Granger')).toBeTruthy()
    })
})</code></pre>
                    <p>Encore une fois, vous pouvez <span class="em">modifier le texte</span>, avec par exemple :</p>
<pre><code>expect(screen.getByText('Harry PotDeBeurre')).toBeTruthy()</code></pre>
                    <p>Et le test <span class="em">échoue</span> !</p>
                    <p>Maintenant que nous avons vu les mocks et une stratégie pour les tests, on se retrouve juste en dessous pour un autre exemple :</p>
                    <p>Grâce à la méthode <span class="html">waitForElementToBeRemoved</span>, qui est une fonction asynchrone qui attend que notre élément soit retiré du DOM avant d'exécuter la suite, on va remplacer le code précédent par ceci :</p>
<pre><code>it('Should display freelancers names', async () =&gt; {
    render(
        &lt;ThemeProvider&gt;
            &lt;Freelances /&gt;
        &lt;/ThemeProvider&gt;
    )
    await waitForElementToBeRemoved(() =&gt; screen.getByTestId('loader'))
    await waitFor(() =&gt; {
        expect(screen.getByText('Harry Potter')).toBeTruthy()
        expect(screen.getByText('Hermione Granger')).toBeTruthy()
    })
})</code></pre>
                    <h3>Personnalisez votre render :</h3>
                    <p>Bon, depuis tout à l'heure je vous fais utiliser votre <span class="html">Theme</span> directemnt dans vos tests. Ce n'est pas très propre. Surtout que si vous testez d'autres composants tels que <span class="html">Home</span>, vous aurez aussi à le wrapper dans le router.</p>
                    <p>Mais ça tombe bien, puisque la fonction <span class="em">render</span> de React Testing Library peut <span class="em">prendre en paramètre un wrapper</span>.</p>
                    <p>Dans le test qu'on a fait juste au-dessus, on va donc <span class="em">déclarer un nouveau composant React <span class="html">Wrapper</span></span> :</p>
<pre><code>function Wrapper({ children }) {
    return &lt;ThemeProvider&gt;{children}&lt;/ThemeProvider&gt;
}</code></pre>
                    <p>Et on le réutilise en le <span class="em">passant en paramètre de notre <span class="html">render</span></span> :</p>
<pre><code>render(&lt;Freelances /&gt;, { wrapper: Wrapper })</code></pre>
                    <p>Et voilà !</p>
                    <p>On peut même en <span class="em">faire un outil qu'on pourra réutiliser dans tous nos tests</span>.</p>
                    <p>Pour cela, on crée un dossier <span class="html">/test</span> dans <span class="html">/utils</span> et on y met un fichier <span class="html">index.js</span> afin d'y mettre notre outil qui servira pour tous nos tests.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>import { render as rtlRender } from '@testing-library/react'
import { ThemeProvider } from '../../utils/context'

function Wrapper({ children }) {
    return &lt;ThemeProvider&gt;{children}&lt;/ThemeProvider&gt;
}

export function render(ui) {
    rtlRender(ui, { wrapper: Wrapper })
}</code></pre>
                    <p>Il ne nous reste qu'à <span class="em">importer notre nouveau <span class="html">render</span></span> dans notre <span class="html">/pages/Freelances/index.test.js</span>, et à supprimer <span class="html">rendre</span> des imports depuis <span class="html">'@testing-library/react'</span>.</p>
                    <p>... Et ça fonctionne comme on le souhaite !</p>
                    <p>Puisqu'on en est là, autant en profiter pour gérer notre <span class="html">Router</span> et notre <span class="html">SurveyProvider</span> aussi. Si vous voulez explorer différentes options (et si vous avez besoin besoin de faire des tests en ayant accès à notre <span class="html">history</span>), vous pouvez regarder <a href="https://testing-library.com/docs/example-react-router/" target="_blank">la documentation de React Testing Library (en anglais)</a>.</p>
                    <p>Mais dans notre cas, on veut juste que nos tests fonctionnent, même lorsqu'il y a des <span class="html">Link</span> dans nos composants. On transforme donc notre fichier pour ajouter notre <span class="html">Router</span> et <span class="html">SurveyProvider</span> :</p>
<pre><code>import { render as rtlRender } from '@testing-library/react'
import { ThemeProvider } from '../../utils/context'

function Wrapper({ children }) {
    return (
        &lt;MemoryRouter&gt;
            &lt;ThemeProvider&gt;
                &lt;SurveyProvider&gt;{children}&lt;/SurveyProvider&gt;
            &lt;/ThemeProvider&gt;
        &lt;/MemoryRouter&gt;
    )
}

export function render(ui) {
    rtlRender(ui, { wrapper: Wrapper })
}</code></pre>
                    <p>En lançant le test, tout fonctionne comme prévu !</p>
                    <h3>Découvrez d'autres types de tests :</h3>
                    <p>Vous avez appris à créer des tests unitaires avec Jest et à teser vos composants avec React Testing Library. Vous avez testé vos interactions et pu simuler des appels API. Mais vous vous en doutez peut-être : <span class="em">le sujet des tests est très vaste</span>. Il existe de nombreux outils et de nombreuses approches.</p>
                    <p>Ci-dessous, je vous fais la démo d'une approche que nous n'avons pas vue ensemble.</p>
                    <p>L'idée des snapshots est plutôt simple : le test vient faire une capture de ce qui est rendu par notre composant et, quand on fait une modification de code, le test compare le snapshot qui a été pris avec la nouvelle version obtenue. Cela permet de nous signaler ce qui change quand on fait une modification de code et donc de vérifier que rien de critique n'est caché sans que l'on s'en rende compte. On va le faire le test sur la page "Freelances" pour les messages d'erreur venant de l'API</p>
                    <p>Dans le <span class="httml">useEffect</span> du hook personnalisé <span class="html">useFetch</span> dans le fichier <span class="html">/hooks/index.jsx</span>, on a le code suivant :</p>
<pre><code>useEffect(() =&gt; {
    if (!url) return
    setLoading(true)
    async function fetchData() {
        try {
            const response = await fetch(url)
            if (!response.ok) {
                const { errorMessage } = await response.json()
                throw new Error(errorMessage)
            } else {
                const data = await response.json()
                setData(data)
            }
        } catch (err) {
            setError(err.message)
        } finally {
            setLoading(false)
        }
    }
    fetchData()
}, [url])</code></pre>
                    <p>Donc, dans notre fichier <span class="html">/pages/Freelances/index.jsx</span>, on a le code ci-dessous :</p>
<pre><code>const { data, isLoading, error } = useFetch(`http://localhost:8000/freelances`)

if (error) {
    return &lt;span data-testid="error"&gt;{error}&lt;/span&gt;
}</code></pre>
                    <p>Enfin, dans le fichier <span class="html">/pages/Freelances/index.test.js</span>, on a ceci :</p>
<pre><code>it('Should display error content', async () =&gt; {
    server.use(
        rest.get('http://localhost:8000/freelances', (req, res, ctx) =&gt; {
            return res.once(
                ctx.status(500,
                ctx.json({
                    errorMessage: `Oups il y a eu une erreur dans l'API`,
                }))
            )
        })
    )
    render(&lt;Freelances /&gt;)
    await waitForElementToBeRemoved(() =&gt; screen.getByTestId('loader'))
    expect(screen.getTestId('error')).toMatchInlineSnapshot()
})</code></pre>
                    <p>On lance le test avec <span class="html">yarn run test</span> et, une fois le test totalement exécuté, on peut voir dans <span class="html">/pages/Freelances/index.test.js</span> le contenu de notre élément s'est rajouté dedans.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Juste au-dessus, nous avons appris à manier des snapshots. Si vous voulez en apprendre davantage, n'hésitez pas à jeter un oeil à <a href="https://jestjs.io/fr/docs/snapshot-testing" target="_blank">la documentation officielle de Jest sur les snapshots</a>, et à <a href="https://kentcdodds.com/blog/effective-snapshot-testing" target="_blank">cet article de blog (en anglais)</a>.</p>
                    </div>
                    <p>Je vous ai également mentionné les tests end-to-end. Nous ne les avons pas vus ensemble, mais ils constituent un outil très puissant. À l'heure actuelle, j'aurais tendance à vous conseiller d'utiliser <a href="https://www.cypress.io/" target="_blank">la bibliothèque <span class="html">Cypress</span></a>.</p>
                    <p>Comme pour tout le reste en JavaScript, les outils de tests <span class="em">évoluent rapidement</span>. Pour rester à la page, je vous conseille de faire une veille, puis la documentation des nouveaux outils.</p>
                </article>
                <article>
                    <h2 id="anciennes_syntaxes_React">Apprivoisez les anciennes syntaxes de React :</h2>
                    <p>À l'heure où ce cours a été écrit, nous en sommes à la version 17.0.2 de React. React a effectivement connu de nombreuses évolutions. Cela veut aussi dire que la manière dont on écrit un composant aujourd'hui ne ressemble pas du tout à la manière dont on le faisait au début. On pourrait considérer que ce qui appartient au passé reste dans le passé. Mais ce serait sans compter les codebases qui contiennent des composants écrits dans d'autres syntaxes. Remontons dans notre machine à remonter dans le temps pour voir les grandes étapes de React.</p>
                    <h3>Découvrez les évolutions principales de React :</h3>
                    <h4>Au tout début : createClass :</h4>
                    <p>Lorsque React a été rendu open source en 2013, les composants étaient créés avec <span class="html">React.createClass</span>. Pour vous donner un exemple, un composant <span class="html">MyComponent</span> reçoit une prop <span class="html">title</span> se serait écrit de la manière suivante :</p>
<pre><code>React.createClass({
    displayName: "MyComponent",
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;{this.props.title}&lt;/h1&gt;
            &lt;/div&gt;
        )
    }
})</code></pre>
                    <p>Mais aujourd'hui, cette syntaxe est officiellement considérée comme dépréciée, et vous ne la trouvez nulle part dans la documentation de React.</p>
                    <p>... En revanche, vous risquez clairement de tomber sur des composants classe.</p>
                    <h3>Le temps des composants classe :</h3>
                    <p>Avec l'ajout des classes dans ES 2015 (voici <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank">la documentation de Mozilla sur les classes, en anglais</a>), React a voulu s'aligner en créant les composants classe. Il s'agissait à l'époque d'un changement majeur. Dans la suite de ce cours, nous allons prendre le temps de revenir sur leur syntaxe, la manière de faire des appels API et de gérer le state et les props dans les composants classe.</p>
                    <p>Découvrons ci-dessous la syntaxe des composants classe. On va transformer notre composant fonction <span class="html">Card</span> en composant classe comme ceci :</p>
<pre><code><span class="html">import { Component } from 'react'</span>
import PropTypes from 'prop-types'
import DefaultPicture from '../../assets/profile.png'
import { CradWrapper, CardLabel, CardImage, CardTitle } from './style'

/* function Card({ label, title, picture, theme }) {
    return (
        &lt;CardWrapper theme={theme}&gt;
            &lt;CardLabel theme={theme}&gt;{label}&lt;/CardLabel&gt;
            &lt;CardImage src={picture} alt="freelance" /&gt;
            &lt;CardTitle theme={theme}&gt;{title}&lt;/CardTitle&gt;
        &lt;/CardWrapper&gt;
    )
} */

<span class="html">class Card extends Component {
    constructor(props) {
        super(props)
        this.state = {}
    }

    render() {
        const { theme, label, picture, title } = this.props
        return (
            &lt;CardWrapper theme={theme}&gt;
                &lt;CardLabel theme={theme}&gt;{label}&lt;/CardLabel&gt;
                &lt;CardImage src={picture} alt="freelance" /&gt;
                &lt;CardTitle theme={theme}&gt;{title}&lt;/CardTitle&gt;
            &lt;/CardWrapper&gt;
        )
    }
}</span>

Card.propTypes = {
    label: PropTypes.string.isRequired,
    title: PropTypes.string.isRequired,
    picture: PropTypes.string.isRequired,
}

Card/defaultProps = {
    label: '',
    title: '',
    picture: '',
}

export default Card</code></pre>
                    <h3>Découvrez la syntaxe :</h3>
                    <p>Comme vous avez pu le voir juste au-dessus, la syntaxe des composants classe est différente. Nous allons ici créer un nouveau composant <span class="html">EmailInput</span> que nous mettrons dans le footer.</p>
                    <p>On commence d'abord par déclarer le composant :</p>
<pre><code>import { Component } from 'react'

class EmailInput extends Component {
    constructor() {
    }

    render() {
        return (
            &lt;div&gt;
                &lt;input /&gt;
            &lt;/div&gt;
        )
    }

}

export default EmailInput</code></pre>
                    <p><span class="html">class</span> et <span class="html">extends Component</span> sont ici la manière de déclarer cotre composant. Si vous avez déjà manipulé des classes, vous devriez déjà avoir vu <span class="html">extends</span> et <span class="html">constructor</span>. Mais sachez que le <span class="html">constructor</span>, <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank">dont vous trouverez la documentation ici</a>, est une méthode qui est utilisée pour créer et initialiser un objet lorsqu'on utilise le mot clé <span class="html">class</span>.</p>
                    <p>Mais au fait, c'est quoi ce <span class="html">render</span> ?! Eh bien, il s'agit d'une méthode de votre composant. C'est d'ailleurs la seule méthode qui est obligatoirement appelée dans votre composant (et donc qui doit impérativement y figurer). Pour un certain nombre d'événements, votre composant devra être "re-render". À chaque fois, cette méthode va recalculer ce qui y est déclaré, et afficher ce qui est retourné.</p>
                    <p>Il y aura un nouveau render à chaque fois qu'une mise à jour aura lieu :</p>
                    <ul>
                        <li>
                            <p>à l'initialisation du <span class="html">constructor</span>;</p>
                        </li>
                        <li>
                            <p>à chaque mise à jour d'une props;</p>
                        </li>
                        <li>
                            <p>à chaque changement du state (mais nous y reviendrons plus tard).</p>
                        </li>
                    </ul>
                    <p>Effectivement, vous n'avez pas de <span class="html">render</span> dans le composants fonction.</p>
                    <p>Notez que <span class="html">render</span> doit forcément retourner du JSX (ce qui sera dans le <span class="html">return</span>). Mais si vous n'avez rien à retourner dans votre <span class="html">render</span>, vous pouvez également retourner <span class="html">null</span>.</p>
                    <h3>Accédez aux props :</h3>
                    <p>Nous allons ajouter un peu de style au composant que vous venons de créer, en faisant une version pour le <span class="html">darkMode</span> et une version pour le <span class="html">lightMode</span>. Sauf que, comme je vous l'ai dit précédemment, utiliser le Contexte est beaucoup plus simple avec les hooks... Or, on ne peut pas utiliser les hooks depuis les composants classe. On va donc se contenter le <span class="html">theme</span> en props.</p>
                    <p>Mais d'ailleurs, ici, on n'a pas de paramètres dans lesquels récupérer les props ? On fait comment pour les récupérer ? Vous vous en doutez sûrement, il existe également un moyen de les récupérer dans les composants classe. Pour cela, vous pouvez utiliser <span class="html">this.props</span> partout dans votre composant - que ce soit dans le <span class="html">return</span>, le <span class="html">render</span>, ou dans une méthode. On va d'abord les initialiser dans le <span class="html">constructor</span>, on en profite pour lui passer le <span class="html">state</span> initial, même si nous n'en avons pas besoin pour le moment (sinon, notre linter va râler).</p>
                    <p>On déclare donc dans notre composant :</p>
<pre><code>import { Component } from 'react'

class EmailInput extends Component {
    constructor(props) {
        super(props)
        this.state = {
            inputValue: '',
        }
    }

    render() {
        // Ici on récupère theme en destructurant this.props
        const { theme } = this.props
        return (
            &lt;div&gt;
                &lt;input /&gt;
            &lt;/div&gt;
        )
    }

}

export default EmailInput</code></pre>
                    <p>Ce qui va nous permettre de faire un style différent en fonction de notre <span class="html">theme</span>.</p>
                    <p>Mais au fait, c'est quoi ce <span class="html">this</span>, là ? Si vous êtes familier de JavaScript, vous connaissez sûrement déjà <span class="html">this</span>. <span class="html">this</span> fait référence à l'objet auquel il appartient.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous essayez de faire un <span class="html">console.log</span> de <span class="htmm">this</span> dans un composant fonction, vous verrez qu'il est <span class="html">undefined</span>. Pour en apprendre davantage sur le this, vous pouvez jeter un oeil <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/this" target="_blank">à la documentation</a>.</p>
                    </div>
                    <p>Donc, ici, le <span class="html">this</span> fait référence à notre composant : il s'agit des <span class="html">props</span> et du <span class="html">state</span> de <span class="html">EmailInput</span>.</p>
                    <p>Mais attention, lorsque vous déclarez des méthodes (qui sont en quelque sorte des fonctions) dans vos composants, il vous faudra faire attention au <span class="html">bind</span>.</p>
                    <p>C'est quoi encore ça, le "bind" ? Déjà, commençons simple : "bind" en traduction littérale veut dire "lier". Cela veut dire qu'on va <span class="em">lier</span> nos méthodes à notre composant classe : il faut qu'elles soient correctement bindées au <span class="html">this</span>. C'est ce que nous verrons dans quelques instants, une fois que nous aurons utilisé le <span class="html">state</span>.</p>
                    <h3>Gérez le state avec setState :</h3>
                    <p>Nous allons maintenant gérer la valeur qui est saisie dans notre <span class="html">EmailInput</span> avec <span class="html">setState</span>.</p>
                    <p><span class="html">setState</span>... C'est un peu la même chose que <span class="html">useState</span>, non ? Eh bien... non. Tout d'abord, <span class="html">useState</span> est un hook : il s'agit donc de la manière de gérer le state pour les composants fonction. <span class="html">setState</span> concerne les composants classe. Par ailleurs, si ces deux fonctions concernent toutes les deux le state, elles ne fonctionnent pas de la même manière :</p>
                    <ul>
                        <li>
                            <p><span class="html">useState</span> vous permet de déclarer votre variable de state, d'initialiser sa valeur et de récupérer une fonction pour la mettre à jour;</p>
                        </li>
                        <li>
                            <p>mais <span class="html">setState</span> permet uniquement de mettre à jour tout le state de notre composant. Souvenez-vous : le state initial est déclaré dans le <span class="html">constructor</span>.</p>
                        </li>
                    </ul>
                    <p>Pour gérer le state de la valeur saisie dans notre <span class="html">EmailInput</span>, nous allons devoir procédér par étapes.</p>
                    <p>Juste au-dessus, vous aviez initialisé votre state dans le <span class="html">constructor</span> avec :</p>
<pre><code>this.state = {
    inputValue: '',
}</code></pre>
                    <p>On va maintenant pouvoir déclarer une fonction pour mettre à jour la valeur de notre state :</p>
<pre><code>updateInputValue = (value) =&gt; {
    this.setState({ inputValue: value })
}</code></pre>
                    <p>Pas besoin de <span class="html">const =</span> devant notre fonction. D'habitude, il aurait fallu l'initialiser, mais ici, étant donné que vous êtes dans une <span class="html">classe</span>, <span class="html">updateInputValue</span> est une méthode de votre classe <span class="html">EmailInput</span>.</p>
                    <p>On aurait pu mettre <span class="html">updateInputValue</span> dans le <span class="html">render</span>, non ? Eh bien, oui. On aurait pu. Mais comme je vous disais, tout ce qui est dans le <span class="html">render</span> est exécuté à chaque fois qu'une prop, ou que le state, est mis à jour. Ce qui veut dire que notre fonction serait à nouveau déclarée : pas très performant, n'est-ce pas ?</p>
                    <p>Et cette méthode est appelée dans <span class="html">onChange</span> de <span class="html">input</span> :</p>
<pre><code>&lt;input
    onChange={(e) =&gt; this.updateInputValue(e.target.value)}
/&gt;</code></pre>
                    <p>Ici, chaque fois qu'un <span class="html">setState</span> est effectué, cela va déclencher un nouveau <span class="html">render</span> de notre composant.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Puisque <span class="html">setState</span> déclenche un <span class="html">rerender</span> de votre composant, vous ne pouvez jamais appeler <span class="html">setState</span> depuis <span class="html">render</span>, sinon, cela provoquera une boucle infinie dans votre composant.</p>
                    </div>
                    <p>Il existe un certain nombre de règles à respecter pour <span class="html">setState</span> (le fait que <span class="html">setState</span> soit asynchrone, que les mises à jour du state soient fusionnées, etc.). Je vous conseille donc de vous renseigner sur ces règles directement dans <a href="https://fr.reactjs.org/docs/state-and-lifecycle.html#using-state-correctly" target="_blank">la documentation de React</a>.</p>
                    <p>Et de la même manière qu'on a accédé aux <span class="html">props</span> avec <span class="html">this.props</span>, c'est <span class="html">this.state</span> qui nous permet d'accéder au state courant.</p>
                    <p>Pour afficher le contenu de notre input, on peut donc faire :</p>
<pre><code>render() {
    return (
        &lt;div&gt;
            {this.state.inputValue}
            &lt;input
                onChange={(e) =&gt; this.updateInputValue(e.target.value)}
            /&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <h3>Revenez au this :</h3>
                    <p>D'habitude, lorsque nous déclarons une nouvelle fonction, on utilise la syntaxe <span class="html">function myFunction()</span>. Alors pourquoi ici on a utilisé une fonction fléchée ? Eh bien, pour pouvoir accéder à votre méthode dans votre classe, vous avez besoin de "binder" votre fonction à votre classe, relier les deux, en quelque sorte. Les fonctions fléchées permettent de le faire de manière implicite. Donc pas d'embêteemnt ici.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ça ne vous provoquera pas systématiquement une erreur si vous ne bindez pas votre fonction au <span class="html">this</span> systématiquement, mais il faut clairement éviter de le faire car cela PEUT provoquer une erreur très facilement.</p>
                    </div>
                    <p>Sans fonction fléchée, autrement, vous auriez dû le faire de manière explicite comme ci-dessous :</p>
<pre><code>constructor(props) {
    super(props)
    this.updateInputValue = this.updateInputValue.bind(this)
    this.state = {
        inputValue: '',
    }
}

updateInputValue (value) {
    this.setState({ inputValue: value })
}</code></pre>
                    <p>Je sais que le <span class="html">this</span> peut être un peu complexe à saisir. C'est d'ailleurs une des raisons pour lesquelles React a choisi de favoriser les composants fonction, pour éviter cette complexité au moment de l'apprentissage. Mais n'hésitez pas à creuser un peu le sujet si cela reste trop flou pour vous. Par exemple, <a href="https://medium.com/byte-sized-react/what-is-this-in-react-25c62c31480" target="_blank">cet article de blog (en anglais)</a> revient sur quelques notions fondamentales.</p>
                </article>
                <article>
                    <h2 id="API_composant_classe">Affichez les données d'une API dans un composant classe :</h2>
                    <p>Entre le moment où ils sont générés dans le DOM, et le moment où ils en sont retirés, les composants passent par différentes étapes. Dans les composants classe, vous avez une liste d'étapes qui correspondent à un moment précis du cycle de vie, dans lesquelles vous pouvez effectuer des actions.</p>
                    <p>On parle de <span class="em">méthodes de cycle de vie</span>.</p>
                    <h3>Découvrez les méthodes de cycle de vie :</h3>
                    <p>Juste en dessous, vous aurez une petite démonstration des différentes étapes que connaît un composant, et auxquelles vous pouvez accéder.</p>
                    <p>Pour la démonstration, j'ai créé un nouveau composant <span class="html">MyComponent</span> qui va être affiché dans <span class="html">Home</span> selon le state <span class="html">display</span>. Notre nouveau composant possède le contenu suivant :</p>
<pre><code>import { Component } from 'react'

export default class MyComponent extends Component {

    render() {
        console.log('===== render =====')
        return (
            &lt;div
                style={{
                    backgroundColor: 'red',
                    height: 30,
                    marginBottom: 20,
                    textAlign: 'center',
                }}
            &gt;
                Mon composant
            &lt;/div&gt;
        )
    }
}</code></pre>
                    <p>La méthode du cycle la plus évidente et qui est obligatoire est le <span class="html">render</span>.</p>
                    <p>La méthode <span class="html">componentDidMount()</span> est appelé juste après que le composant a été monté dans le DOM, donc juste après le premier <span class="html">render</span> :</p>
<pre><code>componentDidMount() {
    console.log('===== componentDidMount =====')
}</code></pre>
                    <p>La méthode <span class="html">componentDidUpdate()</span> intervient, comme son nom l'indique, juste après une mise à jour du state ou des props :</p>
<pre><code>componentDidUpdate(prevProps, prevState) {
    console.log('===== componentDidUpdate =====')
}</code></pre>
                    <p>La méthode explicite <span class="html">componentWillUnmont()</span> intervient juste avant la mort en quelque sorte du composant, lorsqu'il va être retiré du DOM :</p>
<pre><code>componentWillUnmont() {
    console.log('===== componentWillUnmont =====')
}</code></pre>
                    <p>Alors est-ce que ça vous paraît plus clair ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Dans les composants fonction que vous connaissez davantage, vous avez appris à déclencher une action juste après que le composant a été généré dans le DOM avec <span class="html">useEffect</span> et en passant un tableau de dépendances vide.</p>
                    </div>
                    <p>Pour vous faire un petit résumé des différentes étapes auxquelles vous avez accès dans les composants classe :</p>
                    <figure>
                        <img src="../images/methodes_cycle_vie_React.png" alt="">
                        <figcaption>Voilà un diagramme des méthodes de cycle de vie.</figcaption>
                    </figure>
                    <p>Comme vous l'avez vu juste en haut :</p>
                    <ul>
                        <li>
                            <p>Le <span class="html">constructeur</span> est invoqué, comme pour n'importe quel objet, lorsque le composant apparaît pour la première fois dans un DOM virtuel... Il reçoit les props initiales en argument.</p>
                        </li>
                        <li>
                            <p>Puis vient le <span class="html">render</span>. C'est ensuite le moment où est appelé <span class="html">componentDidMount</span> (une fois que le composant est monté sur le DOM).</p>
                        </li>
                        <li>
                            <p>Après, s'il y a une mise à jour et que le composant est re-render, <span class="html">componentDidUpdate</span> est appelé.</p>
                        </li>
                        <li>
                            <p>Et juste avant que le composant soit retiré du DOM, c'est au tour de <span class="html">componentWillUnmount</span> d'être appelé.</p>
                        </li>
                    </ul>
                    <p>Il existe d'autres méthodes de cycle de vie, mais vous aurez moins souvent besoin de celles-ci. Vous pourrez en apprendre davantage dans <a href="https://fr.reactjs.org/docs/react-component.html#rarely-used-lifecycle-methods" target="_blank">la documentation de React</a>.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>En ce qui concerne les méthodes de cyclique de vie, il existe un certain nombre de méthodes qui ont été dépréciées au fil du temps, telles que "componentWillMount". Vous verrez que depuis quelques années, ces méthodes dépréciées ont été renommées pour éviter qu'on les utilise. Ainsi, <span class="html">componentWillMount</span> s'appelle désormais <span class="html">UNSAFE_componentWillMount()</span>. Ça ne donne pas vraiment envie de l'utiliser, non ? Dans les dernières versions, elles ne fonct même plus partie de React.</p>    
                    </div>
                    <h3>Appelez une API dans un composant classe avec componentDidMount :</h3>
                    <p>C'est le moment de mettre tout ça en application en appelant notre API Shiny dans un nouveau composant classe. Pour l'occassion, nous allons créer un nouveau composant qui permet d'afficher plus d'informations sur un freelance lorsqu'on clique sur la <span class="html">Card</span>.</p>
                    <p>Nous allons commencer par permettre de naviguer sur <a href="http://localhost/profile/:id" target="_blank">http://localhost/profile/:id</a>. Dans le fichier <span class="html">index.jsx</span> à la racine de <span class="html">/src</span>, nous avons ajouté une route pour bien rediriger l'utilisateur vers le profil du freelance :</p>
<pre><code>...
&lt;Route path="/freelances" element={&lt;Freelances /&gt;} /&gt;
&lt;Route path="/profile/:id" element={&lt;Profile /&gt;} /&gt;
&lt;Route path="*" element={&lt;Error /&gt;} /&gt;
...</code></pre>
                    <p>On enchraîne ensuite en permettant de naviguer sur la page <span class="html">profile</span> en ajoutant un lien autour de la <span class="html">Card</span> dans <span class="html">/pages/Freelances/index.jsx</span>. Pour cela, on fait donc :</p>
<pre><code>&lt;CardsContainer&gt;
    {freelancersList?.map((profile) =&gt; (
        &lt;Link key={`free-lance-${profile.id}`} to={`/profile/${profile.id}`}&gt;
            &lt;Card
                label={profile.job}
                title={profile.name}
                picture={profile.picture}
                theme={theme}
            /&gt;
        &lt;/Link&gt;
    ))}
&lt;/CardsContainer&gt;</code></pre>
                    <p>Et on oublie pas de supprimer la fonctionnalité de favoris dans le composant classe (pour ne pas avoir des étoiles ajoutées inutilement). Il ne nous reste plus qu'à développer <span class="html">pages/Profile/index.jsx</span> elle-même !</p>
                    <p>On va commencer par récupérer l'<span class="html">id</span> du freelance dont on veut afficher le profil dans les paramètres. Mais oh oh... Comment on va faire ?</p>
                    <p>Comme on l'avait fait pour la page <span class="html">Survey</span> : il nous suffit d'utiliser <span class="html">useParams</span>, non ?! Eh bien non ! Souvenez-vous : les hooks sont uniquement accessibles depuis les composants fonction. D'ailleurs, la version 6 de React Router, sortie en 2021, soit 2 ans après la mise en place des hooks, est pensée pour être utilisée dans des composants fonctions. Nous avons donc ici 2 options :</p>
                    <ol>
                        <li>
                            <p>Transformer le composant Profile en composant de type fonction.</p>
                        </li>
                        <li>
                            <p>Créer un composant qui sera parent de Profile et qui pourra récupérer les paramètres.</p>
                        </li>
                    </ol>
                    <p>Comme nous souhaitons pour l'exemple créer notre composant Profile en Classe nous allons donc opter pour la deuxième option.</p>
                    <p>On va donc devoir changer la déclaration de notre route. Dans <span class="html">/src/index.jsx</span>, on fait donc :</p>
<pre><code>&lt;Route
    path="/profile/:id"
    element={&lt;ProfileContainer /&gt;}
/&gt;</code></pre>
                    <p>Nous créons donc notre composant ProfileContainer que nous ajouterons à notre dossier components. Nous aurons donc un nouveau fichier <span class="html">index.jsx</span> dans le dossier <span class="html">src/components/ProfileContainer</span> avec ce code :</p>
<pre><code>import { useParams } from 'react-router-dom'
import Profile from '../../pages/Profile'

function ProfileContainer() {
    const { id } = useParams()
    return &lt;Profile id={id} /&gt;
}

export default ProfileContainer</code></pre>
                    <p>Ensuite nous pourrons récupérer l'id dans notre classe <span class="html">Profile</span> comme n'importe quelle autre props :</p>
<pre><code>import { Component } from 'react'

class Profile extends Component {
    render() {
        const { id } = this.props
        return &lt;div&gt;&lt;h1&gt;Freelance : {id}&lt;/h1&gt;&lt;/div&gt;
    }
}

export default Profile</code></pre>
                    <p>Notre paramètre s'affiche bien.</p>
                    <p>Passons maintenant aux choses sérieuses en lançant notre appel API dans la méthode de cycle de vie <span class="html">componentDidMount()</span>. Encore une fois, nous allons devoir nous passer de notre hook <span class="html">useFetch</span> puisque nous sommes dans un composant classe.</p>
                    <p>On commence donc par notre <span class="html">constructor</span>. Ici, si vous regardez l'API, vous verrez que nous allons récupérer un objet <span class="html">profileData</span>; il nous faudra donc <span class="html">profileData</span> dans notre state.</p>
<pre><code>constructor(props) {
    super(props)
    this.state = {
        profileData: {},
    }
}</code></pre>
                    <p>Pour le fetch, vous pouvez réutiliser le code que vous aviez dans <span class="html">useFetch</span>, version Promise. On le met tout simplement dans <span class="html">componentDidMount()</span>, ce qui nous donne :</p>
<pre><code>componentDidMount() {
    const { id } = this.props

    fetch(`http://localhost:8000/freelance?id=${id}`)
    .then((response) =&gt; response.json())
    .then((jsonResponse) =&gt: {
        this.setState({ profileData: jsonResponse?.freelanceData })
    })
}</code></pre>
                    <p>Et... Ça fonctionne bien !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous aviez voulu utiliser la syntaxe <span class="html">async</span> / <span class="html">await</span>, ça aurait donné ça :</p>
<pre><code>componentDidMount() {
    const { id } = this.props
    const fetchData = async () =&gt; {
        const response = await fetch(`http://localhost:8000/freelance?id=${id}`)
        const jsonResponse = await response.json()
        if (jsonResponse && jsonResponse.freelanceData) {
            this.setState({ profileData: jsonResponse?.freelanceData })
        }
    }
    fetchData()
}</code></pre>
                    </div>
                    <p>Il ne reste plus qu'à afficher ce qui nous est retourné par l'API. Et voilà notre composant :</p>
<pre><code>import { Component } from 'react'

class Profile extends Component {
    constructor(props) {
        super(props)
        this.state = {
            profileData: {},
        }
    }

    componentDidMount() {
        const { id }  this.props

        fetch(`http://localhost:8000/freelance?id=${id}`)
        .then((response) =&gt; response.json())
        .then((jsonResponse) &gt; {
            this.setState({ profileData: jsonResponse?.freelanceData })
        })
    }

    render() {
        const { profileData } = this.state
        const {
            picture,
            name,
            location,
            tjm,
            job,
            skills,
            available,
            id,
        } = profileData

        return (
            &lt;div&gt;
                &lt;img src={picture} alt={name} height={150} width={150} /&gt;
                &lt;h1&gt;{name}&lt;/h1&gt;
                &lt;span&gt;{location}&lt;/span&gt;
                &lt;h2&gt;{job}&lt;/h2&gt;
                &lt;div&gt;
                    {skills &&
                        skills.map((skill) =&gt; (
                            &lt;div key={`skill-${skill}-${id}`}&gt;{skill}&lt;/div&gt;
                        ))}
                &lt;/div&gt;
                &lt;div&gt;{available ? 'Disponible maintenant' : 'Indisponible'}&lt;/div&gt;
                &lt;span&gt;{tjm} € / jour&lt;/span&gt;
            &lt;/div&gt;
        )
    }
}

export default Profile</code></pre>
                    <p>Et voilà ! Vous avez un tout nouveau composant <span class="html">Profile</span> qui permet d'afficher le profil de vos freelances, et le tout écrit avec un composant classe.</p>
                </article>
                <article>
                    <h2 id="state_management">Découvrez le state management :</h2>
                    <h3>Revenez sur les notions dde state et de props :</h3>
                    <p>Vous rappelez-vous comment créer un composant réutilisable et configurable ?</p>
                    <p>Revoyons brièvement la différence entre les <span class="em">props</span> et le <span class="em">state</span>, ce qu'ils nous permettent de faire et leurs limites.</p>
                    <p>En réutilisant nos composants, nous souhaitons la plupart du temps <span class="em">adapter leur comportement selon leur emplacement</span> dans l'application ou <span class="em">selon certaines données</span> provenant du composant parent. Nous utilisons donc à cet effet <span class="em">les props</span>, qui seront appliqués à nos composants.</p>
<pre><code>const IMAGES = [
    {
        url: "https://unsplash.com/fr/photos/cjSUZMA2iW8",
        title: "Un cheval"
    },
    {
        url: "https://unsplash.com/fr/photos/1ZjI3KgB9Co",
        title: "Un chien"
    }
]

const Container = () =&gt; {
    return IMAGES.map((image, index) =&gt; &lt;Picture url={image.url} title={image.title} key={index} /&gt;)
}</code></pre>
                    <p>Ci-dessus, nous utilisons le composant <span class="html">Picture</span> pour afficher autant d'images différentes provenant d'un tableau <span class="html">IMAGES</span> en passant en props des valeurs <span class="html">url</span> et <span class="html">title</span> distinctes.</p>
                    <p>Certains composants <span class="em">évoluent au fil du temps</span>. Ils <span class="em">réagissent aux évènements utilisateurs</span> : des actions sur un bouton ou la saisie d'un nombre dans un champ, par exemple.</p>
                    <p>Le <span class="em">state</span>n, ou état local du composant, nous permet de <span class="em">stocker à l'échelle de notre composant des valeurs qui changent</span> et <span class="em">dont les changements ont une incidence sur le comportement de notre composant</span> :</p>
<pre><code>const Counter = () =&gt; {
    const [count, setCount] = useState(0)

    return &lt;div&gt;
        &lt;span&gt;Valeur du compteur: {count}&lt;/span&gt;
        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;ajouter&lt;/button&gt;
    &lt;/div&gt;
}</code></pre>
                    <p>Ci-dessus, nous modifions la valeur d'un compteur qui change à chaque clic sur le bouton "Ajouter".</p>
                    <p>En combinant props et state, il nous est donc possible de <span class="em">partager des valeurs de states</span> entre des composants faisant partie de la même branche, c'est-à-dire ayant un <span class="em">parent commun</span>.</p>
                    <p>Pour accéder au state d'un parent, un composant doit recevoir en props les valeurs du state du parent. Un composant peut modifier le state de son parent si celui-ci obtient la méthode <span class="html">setState</span>, qui permet de modifier le state en props. On dit que les <span class="em">props descendent et que l'état remonte</span> :</p>
                    <figure>
                        <img src="../images/state_management_1.png" alt="">
                        <figcaption>Les props descendent et l'état remonte.</figcaption>
                    </figure>
                    <p>Ci-dessus, nous partageons la valeur du state du composant parent vers les composants A et B en passant celle-ci en props. Grâce au <span class="html">setState</span> passé en props, le composant B peut modifier la valeur du state A.</p>
                    <p>Notez aussi qu'un composant A qui partage le même parent que le composant B ne peut pas accéder au state de celle-ci. C'est une contrainte, puisque faire remonter le state dans le composant parent devient ici l'unique moyen de partager le state entre A et B.</p>
                    <h3>Comprenez le principe de props drilling :</h3>
                    <p>Nous venons de voir que l'état peut se districbuer dans les composants par le biais des props. Du fait que deux composants ayant le même parent ne peuvent pas accéder directement à leur state respectif, nous sommes contraints de passer par le state du parent pour le distribuer dans chacun d'eux.</p>
                    <p>Ce qui suit décrit une seconde contrainte.</p>
                    <p>Comment faire pour transmettre des données à un composant qui n'est pas enfant direct d'un autre composant ? On respecte dans ce cas le sens de distribution pazrent vers enfant et on s'assure de passer les props jusqu'au composant ciblé.</p>
                    <figure>
                        <img src="../images/state_management_2.png" alt="">
                        <figcaption>Le props drilling</figcaption>
                    </figure>
                    <p>Ci-dessus, nous voyons un exemple de transmission à travers les composants. Notre Props A, appliqué à notre Composant A, traverse ainsi le Composant B pour être appliqué au Composant C.</p>
                    <p>Nous faisons ici ce qu'on appelle du <span class="em">props drilling</span>, nous avons "percé" un passage dans le composant B pour transmettre la valeur de notre <span class="em">props A</span> au <span class="em">composant C</span>.</p>
                    <h3>Découvrez les limites du props drilling :</h3>
                    <p>Nous avons donc un moyen de partager des states dans ce cas dans notre application, pourquoi ne pas utiliser cette méthode partout ? La raison est à la fois conceptuelle et pratique.</p>
                    <p>Lorsque nous créons des composants afin de les réutiliser, nous cherchons à les rendre le plus <span class="em">génériques</span> possible. C'est-à-dire suffisammebr simples et conçus de manière à être adaptés à beaucoup de situations. Nous essayons alors de <span class="em">limiter la responsabilité de chaque composant à ses fonctionnalités propres</span>.</p>
                    <p>Lorsque nous utilisons le props drilling, nos composants intermédiaires (ici Composant B) <span class="em">doivent recevoir des props et les transmettre même si ces données ne sont pas rattachées à leur logique propre</span>. Nous donnons ainsi à ces composants trop de responsabilités.</p>
                    <p>De plus, si nous multiplions la réutilisation de nos composants intermédiaires avec des composants enfants qui attendent des props différents à chaque fois, nous <span class="em">augmentons le nombre de props à faire traverser</span>.</p>
                    <figure>
                        <img src="../images/state_management_3.png" alt="">
                        <figcaption>Le props drilling devient plus compliqué.</figcaption>
                    </figure>
                    <p>Ci-dessus, nous représentons la réutilisation du composant B dans 2 situations. Le composant B doit faire redescendre Props A, Props B et Props C, et ce, même s'ils ne sont pas utilisés dans tous les cas.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Bien évidemment, sur un arbre qui ne contient que quelques composants, il est assez simple de distribuer ces props. Mais on imagine très vite que certaines applications demanderaient une difficile organisation de cette distribution.</p>
                    </div>
                    <p>On comprend très vite que mis à l'échelle dans une application qui contient des <span class="em">dizaines composants à faire communiquer</span>, avec <span class="em">plusieurs composants intermédiaires</span>, l'exercice peut s'avérer <span class="em">difficile</span>.</p>
                    <h3>Gérez le state depuis un store centralisé :</h3>
                    <p>Eh oui, distribuer les valeurs via les props peut devenir un vrai casse-tête. Alors, comment gérer le state ?</p>
                    <p>À l'image d'une étagère remplie de livres dans lesquels des élèves se servent au moment voulu, peut-on imaginer stocker les données à un seul endroit et connecter chaque composant qui aurait besoin de ceux-ci ? C'est ce que propose Dan Abramow via la librairie <span class="em">Redux</span> qui s'inspire de l'architecture Flux. D'autres librairies s'inspirent ou sont des alternatives de cette architecture, comme MobX ou Recoil. Vous pouvez retrouver <a href="https://github.com/facebookarchive/flux" target="_blank">le projet archivé de Flux sur GitHub</a>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Dan Abramov est un développeur de la communauté open source qui a contribué fortement à la création de Redix et qui, à l'heure où ce cours s'écrit, travaille auprès de Facebook, au coeur même des contributeurs principaux de ReactJS.</p>
                    </div>
                    <p>Le principe de l'architecture flux est le suivant :</p>
                    <ul>
                        <li>
                            <p>nous stockons un <span class="em">état général</span> dans ce qu'on appelle des <span class="em">stores</span>;</p>
                        </li>
                        <li>
                            <p>les composants qui ont <span class="em">besoin d'une valeur</span> de ce state viennent <span class="em">consulter le store</span> et <span class="em">s'abonner aux changements</span> de ce state</p>
                        </li>
                        <li>
                            <p>le store possède un mécanisme qui à chaque changement du state, va <span class="em">informer chaque composant abonné qu'un changement a eu lieu</span>;</p>
                        </li>
                        <li>
                            <p>chaque composant peut alors <span class="em">relire le contenu du state et mettre à jour son état local</span>.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/state_management_4.png" alt="">
                        <figcaption>L'état centralisé simplifie la distribution d'état dans l'application React.</figcaption>
                    </figure>
                    <p>Ainsi nous <span class="em">stockons l'état à l'extérieur</span> de notre application qui <span class="em">vient s'alimenter le moment voulu</span>.</p>
                    <p>Nous reviendrons plus en détail sur cette architecture prochainement, lorsque nous mettrons en place notre propre implémentation.</p>
                </article>
                <article>
                    <h2 id="changements_state_Flux">Communiquez les changements de state à travers un architecture Flux :</h2>
                    <h3>Décortiquez l'architecture Flux :</h3>
                    <p>Nous avons vu précédemment le fonctionnement général de cette architecture. Quels sont les éléments qui aident à mettre celle-ci en place et comment ils interagissent ?</p>
                    <figure>
                        <img src="../images/changements_state_Flux_1.png" alt="">
                        <figcaption>On identifie ici le sens de modification du state à partir du composant.</figcaption>
                    </figure>
                    <p>Ci-dessus, le <span class="em">dispatcher</span> centralise les changements du state.</p>
                    <p>Il reçoit ainsi des <span class="em">actions</span>, ou messages, qui comportent :</p>
                    <ul>
                        <li>
                            <p>le <span class="em">type de traitement à appliquer au state</span>, l'ajout d'un produit à la liste, par exemple;</p>
                        </li>
                        <li>
                            <p>un <span class="em">payload</span>, ou un <span class="em">ensemble de données</span> servant à mettre à jour le state, admettons le nom et le prix du produit à ajouter.</p>
                        </li>
                    </ul>
                    <p>Ensuite, il <span class="em">transmet cette action à tous les stores</span> qui, selon leur responsabilité, vont <span class="em">exécuter l'action</span>, puis <span class="em">notifier aux composants abonnés</span> que leur state a été modifié.</p>
                    <p>Les composants peuvent ensuite venir <span class="em">récupérer les nouvelles valeurs</span> du state et <span class="em">mettre à jour leur rendu</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Nous verrons plus tard comment s'articule Redux, mais nous remarquerons dès ici que Flux autorise le multi-store. A contrario, <span class="em">Redux</span> est <span class="em">mono-store</span>.</p>
                    </div>
                    <h3>Créez votre propre système simplifié d'architecture Flux :</h3>
                    <p>Nous allons tenter d'appliquer cette architecure en nous concentrant uniquement sur le state et les actions d'abonnement (<span class="html">subscribe</span>) et de répartition (<span class="html">dispatch</span>).</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Nous allons ainsi nous permettre, en introduisant petit à petit d'autres outils que nous verrons dans les prochains chapitres et parties, de faire évoluer notre architecture vers un modèle se rapprochant de Redux.</p>
                    </div>
                    <p>Pour cela, je vous propose ci-dessous de comprendre comment implémenter simplement le mécanisme lié à cette architecture :</p>
                    <p>On va créer les fichiers <span class="html">index.html</span> et <span class="html">flux.js</span> avec le contenu suivant pour <span class="html">index.html</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="flux.js" defer&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header"&gt;
            Aucun propriétaire configuré
        &lt;/div&gt;
        &lt;form id="addForm" action="#"&gt;
            &lt;input name="firstName" /&gt;
            &lt;button&gt;Enregistrer&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>Et le contenu suivant pour <span class="html">flux.js</span> :</p>
<pre><code>let state = {};

const subscribers = [];

const subscribe = (fct) =&gt; {
    return subscribers.push(fct);
};

const dispatch = (newStateValue) =&gt; {
    state = newStateValue;
    for (const fct of subscribers) {
        fct(state);
    }
};

document.getElementById("addForm").addEventListener("submit", (evt) =&gt; {
    evt.preventDefault();
    const firstNameInput = evt.currentTarget.firstName;
    dispatch({
        owner: {
            firstName: firstNameInput.value,
        }
    })
})

subscribe((state) =&gt; {
    if (state) {
        document.getElementById("header").textContent = `Le propriétaire du restaurant est ${state.owner.firstName}`;
    }
})</code></pre>
                    <p>Revenons ici sur l'implémentation. Nous avons créé :</p>
                    <ul>
                        <li>
                            <p>une variable de type objet pour stocker le state;</p>
                        </li>
                        <li>
                            <p>une fonction d'abonnement, <span class="html">subscribe</span>, qui permet d'empiler des fonctions qui seront exécutées à chaque appel à la fonction <span class="html">dispatch</span>.</p>
                        </li>
                    </ul>
                    <p>Ce qui nous donne dans notre fichier <span class="html">flux_s1.html</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="flux.js" defer&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header"&gt;
            Aucun propriétaire configuré
        &lt;/div&gt;
        &lt;form id="addForm" action="#"&gt;
            &lt;input name="firstName" /&gt;
            &lt;button&gt;Enregistrer&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>Et dans notre fichier <span class="html">flux_s1.js</span> :</p>
<pre><code>let state = {
};

const subscribers = [];

const dispatch = (newStateValue) =&gt; {
    state = newStateValue;
    for (const fct of subscribers) {
        fct(state)
    }
}

const subscribe = (subscriberFct) =&gt; {
    subscribers.push(subscriberFct);
}

subscribe((state) =&gt; {
    if (state.owner) {
        console.log('Le propriétaire est ajouté', state.owner)
        document.getElementById('header').textContent = `Le propriétaire du restaurant est ${state.owner.firstName}`
    }
})

dispatch({
    company: {
        name: 'Burger du Pré'
    }
})

document.getElementById('addForm').addEventListener("submit", (evt) =&gt; {
    evt.preventDefault()
    const firstNameInput = evt.currentTarget.firstName
    dispatch({
        company: {
            name: 'Burger du Pré'
        },
        owner: {
            firstName: firstNameInput.value,
        }
    })
})</code></pre>
                    <h3>À vous de jouer !</h3>
                    <p>Et si on mettait tout de suite en place cette architecture dans le cadre de notre projet de borne de commande ?</p>
                    <p>Pour rappeler le contexte de notre projet fil rouge, nous souhaitons créer une application pour une borne de commande de burger. On devrait donc pouvoir ajouter une liste de produits à une commande, et c'est ce que nous allons réaliser dans cette première étape.</p>
                    <p>Dans cette partie du cours, je vous laisse travailler sur une architecture qui nous permettra de stocker un panier de burgers sélectionnés pour la commande.</p>
                    <p>L'objectif est d'<span class="em">afficher en console, de votre navigateur, une liste actualisée de burgers sélectionnés à chaque nouvelle sélection</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ci-dessous, vous trouverez des éléments qui vous aideront à concrétiser cet exercice. Les modèles sont les objets à utiliser et à insérer dans notre liste.</p>
                    </div>
                    <p>D'abord, un fichier <span class="html">flux_s2.js</span> :</p>
<pre><code>const DoubleCantal = {
    title: 'Double Cantal',
    price: 15.99,
}

const SuperCremeux = {
    title: 'Super Crémeux',
    price: 14.99,
}

const PouletCroquant = {
    title: 'Poulet Croquant',
    price: 17.99,
}</code></pre>
                    <p>Et un fichier <span class="html">flux_s2.html</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header"&gt;
            Aucun propriétaire configuré
        &lt;/div&gt;
        &lt;form id="addForm" action="#"&gt;
            &lt;input name="firstName" /&gt;
            &lt;button&gt;Enregistrer&lt;/button&gt;
        &lt;/form&gt;
        &lt;div&gt;
            &lt;button class="orderButton" data-id="PouletCroquant"&gt;Poulet Croquant&lt;/button&gt;
            &lt;button class="orderButton" data-id="DoubleCantal"&gt;Double Cantal&lt;/button&gt;
            &lt;button class="orderButton" data-id="SuperCremeux"&gt;Super Crémeux&lt;/button&gt;
        &lt;/div&gt;
        &lt;div id="command"&gt;&lt;/div&gt;
        &lt;script src="flux_s2.js" defer&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour vous aiguiller, vous devez adapter le <span class="html">dispatch</span> pour gérer un tableau comme valeur de <span class="html">value</span> dans le state, qui sera augmenté d'un nouveau burger à chaque utilisation du <span class="html">dispatch</span>.</p>
                    </div>
                    <p>Vous avez tout implémenté ? Voici la correction :</p>
                    <p>Donc, premièrement, voici le contenu du fichier <span class="html">flux_s2.html</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header"&gt;
            Aucun propriétaire configuré
        &lt;/div&gt;
        &lt;form id="addForm" action="#"&gt;
            &lt;input name="firstName" /&gt;
            &lt;button&gt;Enregistrer&lt;/button&gt;
        &lt;/form&gt;
        &lt;div&gt;
            &lt;button class="orderButton" data-id="PouletCroquant"&gt;Poulet Croquant&lt;/button&gt;
            &lt;button class="orderButton" data-id="DoubleCantal"&gt;Double Cantal&lt;/button&gt;
            &lt;button class="orderButton" data-id="SuperCremeux"&gt;Super Crémeux&lt;/button&gt;
        &lt;/div&gt;
        &lt;div id="command"&gt;&lt;/div&gt;
        &lt;script src="flux_s2.js" defer&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>Et dans <span class="html">flux_s2.js</span> :</p>
<pre><code>let state = {
    list: [],
};

const subscribers = [];

const subscribe = (fct) =&gt; {
    return subscribers.push(fct);
};

const dispatch = (newStateValue) =&gt; {
    state = newStateValue;
    for (const fct of subscribers) {
        fct(state);
    }
};

document.getElementById("addForm").addEventListener("submit", (evt) =&gt; {
    evt.preventDefault();
    const firstNameInput = evt.currentTarget.firstName;
    dispatch({
        owner: {
            firstName: firstNameInput.value,
        }
    })
});

subscribe((state) =&gt; {
    if (state.owner) {
        document.getElementById("header").textContent = `Le propriétaire du restaurant est ${state.owner.firstName}`;
    }
    if (state.list) {
        document.getElementById("command").innerHTML = `&lt;h2&gt;Vous avez sélectionné les produits suivants :&lt;/h2&gt;;

        for (let item of state.list) {
            const itemElement = document.createElement("div");
            itemElement.innerHTML = `
                &lt;div&gt;
                    ${item.title} &lt;span&gt;${item.price}&lt;/span&gt;
                &lt;/div&gt;
            `;
            document.getElementById("command").appendChild(itemElement);
        }
    }
});

const DoubleCantal = {
    title: 'Double Cantal',
    price: 15.99,
};

const SuperCremeux = {
    title: 'Super Crémeux',
    price: 14.99,
};

const PouletCroquant = {
    title: 'Poulet Croquant',
    price: 17.99,
};

const PRODUCT_LIST = {
    PouletCroquant,
    SuperCremeux,
    DoubleCantal,
};

document.querySelectorAll('.orderButton').forEach((element) =&gt; {
    element.addEventListener('click', event =&gt; {
        const productId = event.target.dataset['id'];
        const productList = state.list;
        productList.push(PRODUCT_LIST[productId]);
        dispatch({
            list: productList,
        });
    });
});</code></pre>
                </article>
                <article>
                    <h2 id="modification_valeurs_state_Reducers">Modifiez les valeurs du state de la bonne manière avec les Reducers :</h2>
                    <h3>Rappelez-vous l'immutabilité :</h3>
                    <p>Maintenant que nous avons mis en place une méthode qui permet à la fois de centraliser un state et de communiquer les chanegements de celui-ci, nous allons nous concentrer sur la manière dont nous modifions sa valeur.</p>
                    <p>Si nous nous souvenons du fonctionnement de JavaScript au niveau de l'assignation, c'est-à-dire l'association entre les variables et les valeurs, hormis les cas des primitives ("string", "number", "boolean"...), toutes les autres valeurs sont assignées par <span class="em">référence</span> : c'est l'adresse mémoire où se trouve la valeur qui est stockée. La variable ne stocke pas directement la valeur !</p>
<pre><code>const A = {name: 'joe'}
const B = {name: 'joe'}

A === B
// false</code></pre>
                    <p>Et ceci parce que les valeurs de A et B n'ont pas la même référence. C'est-à-dire, elles <span class="em">ne sont pas placées au même endroit de la mémoire</span> de votre ordinateur.</p>
                    <p>Comme nous l'avons vu précédemment, nous pouvons faire des copies par valeur pour nous assurer de l'immutabilité. C'est-à-dire que nous copions tout le contenu d'une variable et nous créons une nouvelle référence.</p>
                    <p>Par contre, si nous faisons :</p>
<pre><code>const C = A
C.name = "claude"

A.name
// claude</code></pre>
                    <p>A et C partagent la même référence.</p>
                    <p>D'accord, il y a les valeurs et les références, mais pourquoi s'arrêter là-dessus ici ? Eh bien, si nous revenons sur notre implémentation précédente, nous mettons à jour la valeur de notre variable state <span class="em">à chaque <span class="html">dispatch</span></span>. Ceci peut présenter des effets non désirés et des incohérences dans les données. Selon le contexte dans lequel nous faisons appel à une variable, celle-ci ne retourne pas exactement le résultat attendu.</p>
                    <p>Voici comment ces effets peuvent avoir lieu :</p>
<pre><code>// flux_s3.js

function autoAddPromo() {
    setTimeout(function() {
        const newState = {...state};
        newState.list = state.list.map(item =&gt; ({...item}));
        newState.list.find((product) =&gt; product.title === "Super Crémeux").price = 2;
        dispatch(newState);
    }, 9000)
}

autoAddPromo();</code></pre>
                    <p>Pour revenir à ce que nous venons de voir, copier une référence de state peut s'avérer contre-intuitif.</p>
                    <p>Dans notre exemple, nous avons appliqué une promotion aux produits du panier du type Super Crémeux, sauf que nous avons modifié la valeur <span class="html">price</span> de l'objet en référence <span class="html">SuperCremeux</span>. Donc à chaque nouvel ajout du produit <span class="html">SuperCremeux</span>, celui-ci n'est plus au prix de base mais au prix promotionnel.</p>
                    <p>Pour éviter cette situation, nous allons <span class="em">créer une copie complète de notre state</span>, et nous assurer qu'à chaque changement, ce soit la nouvelle copie modifiée qui soit transmise dans le dispatch.</p>
                    <h3>Maîtrisez les changements avec les Reducers :</h3>
                    <p>Il faudra donc à chaque fois reconstruire un nouveau state ? Oui, mais nous allons le faire de la bonne façon. Pour nous rapprocher de Redux nous allons simplifier notre méthode en introduisant un nouvel outil : le reducer.</p>
                    <p>Un <span class="em">reducer</span> est une <span class="em">fonction qui prend le state qui prend le state courant et les données que nous souhaitons modifier et retourne le nouveau state</span>.</p>
<pre><code>const reducer = (currentState, dataToUpdate) =&gt; {
    const newState = {...currentState, ...dataToUpdate}
    return newState
}</code></pre>
                    <p>Plutôt simple comme implémentation ! Mais pas vraiment.</p>
                    <p>Si maintenant nos fonctionnalités se complètent avec la possibilité d'appliquer une promotion sur chaque produit <span class="html">SuperCremeux</span> et que l'on souhaite retirer un produit déjà sélectionné de la commande... On comprend vite que notre reducer risque de devenir compliqué !</p>
                    <p>C'est pourquoi les reducers avec Redux ont une impélmentation un peu différente. Au lieu de passer uniquement des données à mettre à jour en paramètre, nous allons passer un <span class="em">objet</span> contenat :</p>
                    <ul>
                        <li>
                            <p>une <span class="em">instruction</span> de ce que nous voulons effectuer;</p>
                        </li>
                        <li>
                            <p>les <span class="em">données à modifier</span>.</p>
                        </li>
                    </ul>
                    <p>Cet objet, c'est ce qu'on appelle une <span class="em">action</span> :</p>
<pre><code>{
    type: 'APPLY_VOUCHER',
    payload: {
        price: 2,
    }
}</code></pre>
                    <p>Maintenant, je vais vous montrer comment l'utiliser.</p>
                    <p>On va ajouter le bouton dans notre fichier HTML comme ceci :</p>
<pre><code>&lt;div&gt;
    &lt;button id="voucher"&gt;Super Crémeux à 2 euros&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>Et dans le fichier JS, on rajoute notre reducer comme cela :</p>
<pre><code>const reducter = (currentState, action) =&gt; {
    switch(action.type) {
        case 'ADD_PRODUCT':
            const listWithNewProduct = [...currentState.list, action.payload]
            return {...currentState, list: listWithNewProduct}
        case 'APPLY_VOUCHER':
            const withVoucherList = currentState.list.map(
                item =&gt; item.title === 'Super Crémeux' ? ({...item, price: action.payload.price}) : ({...item})
            )
            return {...currentState, list: withVoucherList}
        default:
            return currentState
    }
}</code></pre>
                    <p>Et dans ce fichier, on va également modifier le code des boutons "order" :</p>
<pre><code>document.querySelectorAll(".orderButton").forEach((element) =&gt; {
    element.addEventListener("click", (event) =&gt; {
        const productId = event.target.dataset["id"];
        const newState = reducer(state, {
            type: "ADD_PRODUCT",
            payload: PRODUCT_LIST[productId],
        });
        dispatch(newState);
    });
});

document.getElementById("voucher").addEventListener("click", () =&gt; {
    const newState = reducer(state, {
        type: "APPLY_VOUCHER",
        payload: { price: 2.0 },
    });
    dispatch(newState);
});</code></pre>
                    <p>Pour résumer le code ci-dessus, ça présente comment appliquer une action dans notre reducer en veillant à bien recréer un nouveau state à chaque changement :</p>
<pre><code>// Nous créons le reducer
const reducer = (currentState, action ) =&gt; {
    switch (action.type) {
        case 'ADD_PRODUCT':
            const listWithNewProduct = [...currentState.list, action.payload]
            return {...currentState, list: listWithNewProduct}
        case 'REMOVE_PRODUCT':
            const list = currentState.list.filter(
                (item, index) =&gt; index !== action.payload
            )
            return {...currentState, list: list}
        case 'APPLY_VOUCHER':
            const withVoucherList = currentState.list.map(
                        item =&gt; item.title === 'Super Crémeux' ? ({...item, price: action.payload.price}) : item
            )
            return {...currentState, list: withVoucherList}
        case 'UPDATE_FIRSTNAME':
            const owner = {...currentState.owner, firstName: action.payload}
            return {...currentState, owner}
        default:
            return currentState
    }
}

// Et nous modifions en conséquence...
dispatch({...state, company: {name: 'Burger du Pré'}})
document.getElementById('addForm').addEventListener("submit", (evt) =&gt; {
    evt.preventDefault()
    const firstNameInput = evt.currentTarget.firstName
    const newState = reducer(state, {type: 'UPDATE_FIRSTNAME', payload: firstNameInput.value })
    dispatch(newState)
})

document.querySelectorAll('.orderButton').forEach((element) =&gt; {
    element.addEventListener('click', (event) =&gt; {
        const productId = event.target.dataset['id']
        const newState = reducer(state, {type: 'ADD_PRODUCT', payload: PRODUCT_LIST[productId] })
        dispatch(newState)
    })
})

document.getElementById('voucher').addEventListener("click", (evt) =&gt; {
    const newState = reducer(state, {type: 'APPLY_VOUCHER', payload: {price: 2.00} })
    dispatch(newState)
})</code></pre>
                </article>
                <article>
                    <h2 id="Redux">Simplifiez votre architecture avec Redux :</h2>
                    <h3>Intallez Redux :</h3>
                    <p>En tant que développeurs, nous devons nous efforcer à ne pas réinventer la roue à chaque nouveau projet.</p>
                    <p>De ce fait, il existe des outils de la communauté qui nous permettent dans la plupart des cas de répondre à nos problématiques. Et c'est ici qu'entre en jeu <span class="em">Redux</span>, notre gestionnaire de state centralisé.</p>
                    <p>Tout d'abord, je vous propose d'installer Redux. Et pour ce faire, je vais vous demander d'installer Redux Toolkit.</p>
                    <p>Mais pourquoi installer Redux Toolkit alors que l'on travaille sur Redux ? Eh bien la raison est la suivante : Redux est un outil <span class="em">open source</span>, propulsé par une <span class="em">communauté</span>. De ce fait, les développeurs qui la composent ont dicté des "<span class="em">best pratices</span>" qui font office de normes. Les pratiques actuelles préconisent d'utiliser Redux avec Redux Toolkit (RTK). C'est donc pourquoi nous apprenons à utiliser Redux avec RTK.</p>
                    <p>Installons maintenant Redux et RTK :</p>
                    <p>Ajoutez la ressource suivante dans votre fichier HTML :</p>
<pre><code>&lt;script src="https://unpkg.com/@reduxjs/toolkit@1.9.7/dist/redux-toolkit.umd.js"&gt;&lt;/script&gt;</code></pre>
                    <p>Dans votre navigateur, dans la console, tapez <span class="html">window.RTK</span> puis <span class="html">Entrée</span>. Vous devriez retrouver ce qui suit :</p>
                    <figure>
                        <img src="../images/Redux_RTK.png" alt="">
                        <figcaption>Redux et RTK sont installés.</figcaption>
                    </figure>
                    <p>Voilà Redux et RTK bien installés !</p>
                    <h3>Créez un store avec Redux :</h3>
                    <p>Allons-nous remplacer notre implémentation par Redux ? Oui, mais vous verrez, son utilisation ne diffère pas beaucoup de ce que nous avons réalisé.</p>
                    <p>Remplaçons notre architecture Flux par Redux dans le fichier JS :</p>
<pre><code>let state = {
    list: [],
};

// Nous créons le reducer
const reducer = (currentState, action ) =&gt; {
    switch (action.type) {
        case 'ADD_PRODUCT':
            const listWithNewProduct = [...currentState.list, action.payload]
            return {...currentState, list: listWithNewProduct}
        case 'REMOVE_PRODUCT':
            const list = currentState.list.filter(
                (item, index) =&gt; index !== action.payload
            )
            return {...currentState, list: list}
        case 'APPLY_VOUCHER':
            const withVoucherList = currentState.list.map(
                        item =&gt; item.title === 'Super Crémeux' ? ({...item, price: action.payload.price}) : item
            )
            return {...currentState, list: withVoucherList}
        case 'UPDATE_FIRSTNAME':
            const owner = {...currentState.owner, firstName: action.payload}
            return {...currentState, owner}
        default:
            return currentState
    }
}

const store = window.RTK.configureStore({
    preloadedState: state,
    reducer: reducer,
});

store.subscribe(() =&gt; {
    const state = store.getState();
    if (state.owner) {
        document.getElementById("header").textContent = `Le propriétaire du restaurant est ${state.owner.firstName}`;
    }
    if (state.list) {
        document.getElementById("command").innerHTML = `&lt;h2&gt;Vous avez sélectionné les produits suivants :&lt;/h2&gt;`;

        for (let i in state.list) {
            const itemElement = document.createElement("div");
            itemElement.innerHTML = `
                &lt;div&gt;
                    ${item.title} &lt;span&gt;{item.price}&lt;/span&gt;
                    &lt;button id="removeButton_${i}"&gt;remove&lt;/button&gt;
                &lt;/div&gt;
            `;
            document.getElementById("removeButton_${i}").addEventListener("click", () =&gt; {});
        }
    }
});

const DoubleCantal = {
    title: 'Double Cantal',
    price: 15.99,
};

const SuperCremeux = {
    title: 'Super Crémeux',
    price: 14.99,
};

const PouletCroquant = {
    title: 'Poulet Croquant',
    price: 17.99,
};

const PRODUCT_LIST = {
    PouletCroquant,
    SuperCremeux,
    DoubleCantal,
};

document.querySelectorAll('.orderButton').forEach((element) =&gt; {
    element.addEventListener('click', event =&gt; {
        const productId = event.target.dataset['id'];
        store.dispatch({
            type: 'ADD_PRODUCT',
            payload: PRODUCT_LIST[productId],
        });
    });
});

document.getElementById('voucher').addEventListener("click", () =&gt; {
    store.dispatch({
        type: 'APPLY_VOUCHER',
        payload: {price: 2.00},
    });
});</code></pre>          
                    <p>Pour résumer, nous avons donc créer un store avec la focntion <span class="html">configureStore</span> de RTK. Ce store nous expose deux fonctions, <span class="html">subscribe</span> et <span class="html">dispatch</span>, ce qui nous permet de remplacer les deux fonctions implémenées précédemment. C'est tout ce qu'il y avait à faire le fonctionnement reste le même.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Notez que nous avons initialisé un state via la propriété <span class="html">preloadedState</span>. Cette propriété nous permet de configurer un state par défaut dans notre store.</p>
                    </div>
                    <p>Ce qui nous donne dans un fichier <span class="html">flux_s6.html</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header"&gt;
            Aucun propriétaire configuré
        &lt;/div&gt;
        &lt;form id="addForm" action="#"&gt;
            &lt;input name="firstName" /&gt;
            &lt;button&gt;Enregistrer&lt;/button&gt;
        &lt;/form&gt;
        &lt;div&gt;
            &lt;button class="orderButton" data-id="PouletCroquant"&gt;Poulet Croquant&lt;/button&gt;
            &lt;button class="orderButton" data-id="DoubleCantal"&gt;Double Cantal&lt;/button&gt;
            &lt;button class="orderButton" data-id="SuperCremeux"&gt;Super Cremeux&lt;/button&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;button id="voucher"&gt;Super Crémeux à 2 euros&lt;/button&gt;
        &lt;/div&gt;
        &lt;div id="command"&gt;&lt;/div&gt;
        &lt;script src="https://unpkg.com/@reduxjs/toolkit/dist/redux-toolkit.umd.min.js"&gt;&lt;/script&gt;
        &lt;script src="flux_s6.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>Et dans un fichier <span class="html">flux6.js</span> :</p>
<pre><code>const DoubleCantal = {
    title: 'Double Cantal',
    price: 15.99,
}


const SuperCremeux = {
    title: 'Super Crémeux',
    price: 14.99,
}

const PouletCroquant = {
    title: 'Poulet Croquant',
    price: 17.99,
}

const PRODUCT_LIST = {
    PouletCroquant,
    SuperCremeux,
    DoubleCantal,
}

let state = {
    value: null,
    list: []
};
const subscribers = [];

const reducer = (currentState, action ) =&gt; {
    switch (action.type) {
        case 'ADD_PRODUCT':
            const listWithNewProduct = [...currentState.list, action.payload]
            return {...currentState, list: listWithNewProduct}
        case 'REMOVE_PRODUCT':
            const list = currentState.list.filter(
                (item, index) =&gt; index !== action.payload
            )
            return {...currentState, list: list}
        case 'APPLY_VOUCHER':
            const withVoucherList = currentState.list.map(
                item =&gt; item.title === 'Super Crémeux' ? ({...item, price: action.payload.price}) : item
            )
            return {...currentState, list: withVoucherList}

        case 'UPDATE_FIRSTNAME':
            const owner = {...currentState.owner, firstName: action.payload}
            return {...currentState, owner}
        default:
            return currentState
    }
}

const store = window.RTK.configureStore(
    {
        preloadedState: state,
        reducer
    }
)

store.subscribe(() =&gt; {
    const state = store.getState()
    if (state.owner) {
        console.log('Le propriétaire est ajouté', state.owner)
         document.getElementById('header').textContent = `Le propriétaire du restaurant est ${state.owner.firstName}`
    }
    if (state.list) {
        document.getElementById('command').innerHTML = ``;
        for (let item of state.list) {
            const itemElement = document.createElement('div')
            itemElement.innerHTML = `
                &lt;div&gt;
                    ${item.title} &lt;span&gt;${item.price}&lt;/span&gt;
                &lt;/div&gt;
            `
            document.getElementById('command').appendChild(itemElement)
        }
    }
})

document.getElementById('addForm').addEventListener("submit", (evt) =&gt; {
    evt.preventDefault()
    const firstNameInput = evt.currentTarget.firstName
    store.dispatch({type: 'UPDATE_FIRSTNAME', payload: firstNameInput.value })
})

document.querySelectorAll('.orderButton').forEach((element) =&gt; {
    element.addEventListener('click', (event) =&gt; {
        const productId = event.target.dataset['id']
        store.dispatch({type: 'ADD_PRODUCT', payload: PRODUCT_LIST[productId] })
    })
})

document.getElementById('voucher').addEventListener("click", (evt) =&gt; {
    store.dispatch({type: 'APPLY_VOUCHER', payload: {price: 2.00} })
})</code></pre>
                </article>
                <article>
                    <h2 id="Redux_React">Ajoutez Redux à une application React :</h2>
                    <h3>Créez une application React :</h3>
                    <p>Redux fonctionne <span class="em">indépendamment</span> de React. Nous avons découvert précédemment les concepts qui fondent son fonctionnement. Nous savons ainsi que nous pouvons :</p>
                    <ul>
                        <li>
                            <p>stocker dans un store centralisé des états;</p>
                        </li>
                        <li>
                            <p>exécuter des parties de notre code en fonction des chanegements intervenant dans le store;</p>
                        </li>
                        <li>
                            <p>modifier les valeurs du store en appliquant des actions.</p>
                        </li>
                    </ul>
                    <p>Créons alors notre application React en suivant les commandes ci-dessous :</p>
<pre><code>## create react project
npm init react-app resto-cmd
# ou
yarn react-app resto-cmd
# ou encore
yarn create-react-app resto-cmd</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous pouvez retrouver d'autres outils qui permettent de configurer un projet React, d'ailleurs la nouvelle documentation ne mentionne plus <span class="html">create-react-app</span>. L'outil reste utilisable pour configurer rapidement un projet. Vous pouvez ainsi utiliser <a href="https://vitejs.dev/" target="_blank">Vite</a> comme suit :</p>
<pre><code>npm create vite@latest resto-cmd -- --template react
cd resto-cmd
npm install
npm run dev</code></pre>
                    </div>
                    <p>Nous allons ajouter notre package Redux Toolkit pour bénéficier de Redux dans notre application React et du package <span class="html">react-redux</span>, qui va nous permettre de manipuler le store dans nos composants :</p>
                    <p>Pour ce faire, utilisez ma commande suivante :</p>
<pre><code>## add rtk as package
npm install @reduxjs/tookit react-redux
# ou
yarn add @reduxjs/tookit react-redux</code></pre>
                    <p>À ce stade, vous devriez obtenir une application React prête à être développée avec notre state manager Redux.</p>
                    <p>Afin de préparer la suite de nos avancées, nous allons utiliser une partie du code que nous avons déjà implémenté !</p>
                    <p>Afin de suivre les bonnes pratiques, nous allons respecter certaines règles proposées dans le guide de styles que vous retrouvez dans <a href="https://redux.js.org/style-guide/#structure-files-as-feature-folders-with-single-file-logic" target="_blank">la documentation de Redux (en anglais)</a>.</p>
                    <ol>
                        <li>
                            <p>D'abord, créons un dossier <span class="html">app/</span>.</p>
                        </li>
                        <li>
                            <p>Nous y dépaçons nos fichiers <span class="html">App.js</span> et <span class="html">App.css</span> en modifiant leurs imports.</p>
                        </li>
                        <li>
                            <p>Ensuite, nous créons notre fichier <span class="html">app/store.js</span>.</p>
                        </li>
                        <li>
                            <p>Créons un dossier <span class="html">common</span> pour y placer notre fichier <span class="html">models.js</span>, car il sera utile à plusieurs parties de notre application et tous les composants réutilisables. Nous ajoutons nos produits dans ce fichier.</p>
                        </li>
                        <li>
                            <p>Puis, en copiant l'intégralité de notre fichier <span class="html">flux_s6.js</span>, nous ajoutons ce code dans le fichier <span class="html">store.js</span>. J'en profite pour rajouter deux produits par défaut dans mon store. Vous pouvez voir dans le code qui suit comment je m'y prends.</p>
                        </li>
                        <li>
                            <p>Nous modifions, notre import du composant App dans <span class="html">index.js</span> qui devient <span class="html">./app/App.js</span>.</p>
                        </li>
                        <li>
                            <p>Nous ajoutons le provider dans notre fichier <span class="html">app/App.js</span> comme suit, et nettoyons un peu son implémentation :</p>
<pre><code>import { Provider } from 'react-redux';
import { store } from './store';
import './App.css';

function App() {
    return (
        &lt;Provider store={store}&gt;
            &lt;div className="App"&gt;
            &lt;/div&gt;
        &lt;/Provider&gt;
    );
}

export default App;</code></pre>
                        </li>
                    </ol>
                    <p>Vous devriez à ce stade avoir :</p>
                    <ol>
                        <li>
                            <p>Un fichier <span class="html">app/store.js</span> comme suit :</p>
<pre><code>import { configureStore } from "@reduxjs/toolkit";
import { PouletCroquant, SuperCremeux } from '../common/models";

let state = {
    value: null,
    list: [
        SuperCremeux,
        PouletCroquant,
    ],
};

const reducer = (currentState, action) =&gt; {
    switch (action.type) {
        case 'ADD_PRODUCT':
            const listWithNewProduct = [...currentState.list, action.payload];
            return {...currentState, list; listWithNewProduct};
        case 'REMOVE_PRODUCT':
            const list = currentState.list.filter(
                (item, index) =&gt; index !== action.payload
            );
            return {...currentState, list: list};
        case 'APPLY_VOUCHER':
            const withVoucherList = currentState.list.map(
                item =&gt; item.title === 'Super Crémeux' ? ({...item, price: action.payload.price}) : item
            );
            return {...currentState, list: withVoucherList};
        case 'UPDATE_FIRSTNAME':
            const owner = {...currentState.owner, firstName: action.payload};
            return {...currentState, owner};
        default:
            return currentState;
    }
};

export const store = configureStore({
    preloadedState: state,
    reducer,
});</code></pre>
                        </li>
                        <li>
                            <p>Un fichier <span class="html">common/models.js</span> :</p>
<pre><code>export const DoubleCantal = {
    title: 'Double Cantal',
    price: 15.99,
};

export const SuperCremeux = {
    title: 'Super Crémeux',
    price: 14.99,
};

export const PouletCroquant {
    title: 'Poulet Croquant',
    price: 17.99,
};</code></pre>
                        </li>
                        <li>
                            <p>Un fichier <span class="html">app/App.js</span> :</p>
<pre><code>import { Provider } from 'react-redux';
import { store } from './store';
import './App.css';

function App() {
    return (
        &lt;Provider store={store}&gt;
            &lt;div className="App"&gt;
            &lt;/div&gt;
        &lt;/Provider&gt;
    );
}

export default App;</code></pre>
                        </li>
                    </ol>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Enfin, pour avoir le même rendu que moi, vous pouvez ajouter un fichier <span class="html">index.css</span>.</p>
                    </div>
                    <p>Nous venons d'intégrer nos sources à notre projet React. Ainsi, nous avons :</p>
                    <ul>
                        <li>
                            <p>construit un fichier <span class="html">store.js</span> pour y placer notre reducer et notre configurtion du store;</p>
                        </li>
                        <li>
                            <p>appliqué à notre <span class="em">provider</span> à la racine de notre application (<span class="html">App.js</span>) afin de pouvoir accéder à notre store au sein de chacun de nos composants</p>
                        </li>
                        <li>
                            <p>placé nos <span class="em">modèles</span> dans un fichier dédié pour mieux structurer notre code;</p>
                        </li>
                        <li>
                            <p>ajouté le <span class="em">style</span> de l'application pour utiliser les classes toutes prêtes.</p>
                        </li>
                    </ul>
                    <p>Et voilà, nous sommes enfin prêts à manipuler notre state dans React avec Redux et Redux Toolkit !</p>
                    <h3>Associez le store à un premier composant :</h3>
                    <p>Maintenant que notre store est configuré, notre prochain défi sera de...</p>
                    <p>... l'associer à lun de nos composants ? Exact !</p>
                    <p>Pour accéder au store de Redux dans nos composants, nous pouvons utiliser le hook <span class="html">useStore</span> de react-redux que nous avons précédemment installé.</p>
                    <p>Ci-dessous, un exemple d'implémentation permettant d'accéder au store.</p>
<pre><code>import { useStore } from "react-redux";

const Component = () =&gt; {
    const store = useStore();
    return &lt;i&gt;&lt;/i&gt;
};</code></pre>
                    <p><span class="html">useStore</span> nous permet donc d'<span class="em">accéder à l'instance du store qui est diffusée dans notre application</span> via le Provider préalablement inséré.</p>
                    <p>Maintenant que nous savons comment accéder au store, nous allons commencer à l'utiliser dans notre application.</p>
                    <p>Pour cela, nous allons créer notre composant affichant la liste des produits sélectionnés, que nous appellerons <span class="html">Cart</span>, dans le fichier <span class="html">features/cart/Cart.js</span>.</p>
                    <p>L'instance <span class="html">store</span> fournit une méthode <span class="html">getState()</span> qui nous permet d'obtenir à chaque instance les valeurs stockées dans le store. Si nous faisons donc appel à <span class="html">store.getState()</span>, nous aurons accès à <span class="html">list</span> qui contient notre liste de produits sélectionnés.</p>
                    <p>Il ne nous reste donc plus qu'à "mapper" sur <span class="em">store.getState().list</span> en faisant :</p>
<pre><code>store.getState().list.map((item, index) =&gt; &lt;JSXElement /&gt;)</code></pre>
                    <p>Je vous propose maintenant de comprendre comment le créer ci-dessous.</p>
                    <p>On va créer le fichier <span class="html">src/app/features/cart/Cart.js</span> avec le contenu suivant :</p>
<pre><code>import { useStore } from "react-redux";
    
export const Cart = () =&gt; {
    const store = useStore();

    return (
        &lt;div className="Selection"&gt;
            &lt;h1&gt;Vos produits sélectionnés&lt;/h1&gt;
            {
                store.getState().list.map(
                    (item, index) =&gt; &lt;span key={index} className="SelectedProduct"&gt;{item.title} {item.price}&lt;/span&gt;
                );
            }
        &lt;/div&gt;
    );
}</code></pre>
                    <p>N'oublions pas de rajouter ce composant dans notre application, <span class="html">App</span> :</p>
<pre><code>import { Provider } from 'react-redux';
import { store } from './store';
import './App.css';
import { Cart } from '../features/cart/Cart';

function App() {
    return (
        &lt;Provider store={store}&gt;
            &lt;div className="App"&gt;
                &lt;Cart /&gt;
            &lt;/div&gt;
        &lt;/Provider&gt;
    );
}

export default App;</code></pre>
                    <p>Nous venons donc d'ajouter l'affichage du listing de nos produits sélectionnés dans notre panier.</p>
                    <p>Faisons le point sur cette phase d'implémentation, au cours de laquelle nous avons :</p>
                    <ol>
                        <li>
                            <p>Déclaré et inséré notre composant Cart dans <span class="html">App.js</span>.</p>
                        </li>
                        <li>
                            <p>Créé notre composant Cart dans <span class="html">Cart.js</span>.</p>
                        </li>
                        <li>
                            <p>Importé <span class="html">useStore</span> de react-redux.</p>
                        </li>
                        <li>
                            <p>Utilisé <span class="html">useStore</span> pour l'assigner à notre variable locale store.</p>
                        </li>
                        <li>
                            <p>Utilisé la méthode <span class="html">getState</span> pour récupérer l'état (le state) courant.</p>
                        </li>
                        <li>
                            <p>Mappé sur list du store qui contient la liste des produits sélectionnés.</p>
                        </li>
                    </ol>
                    <h3>Faites des modifications du store à partir de votre composant :</h3>
                    <p>Nous voilà capables d'afficher la liste de produits sélectionnés... enfin, presque ! La liste contient des produits insérés manuellement avec le code.</p>
                    <p>Mais nous souhaitons rendre cette liste <span class="em">dynamique</span>, c'est-à-dire être capables d'ajouter d'autres produits sans pour cela réécrire de code pour en ajouter.</p>
                    <p>Pour ajouter cette fonctionnalité, nous allons créer un bouton pour chaque produit et utiliser le store pour stocker le produit correspondant à chaque bouton lors du clic sur le bouton.</p>
                    <p>À l'instar de la méthode <span class="html">getState</span>, l'instance <span class="html">store</span> fournit une méthode dispatch qui va nous permettre d'appliquer des actions, <span class="html">dispatch()</span>.</p>
                    <p>Bien évidemment, la méthode dispatch fonctionne de pair avec la méthode subscribe. On va donc modifier notre accès à <span class="html">list</span> et ajouter un état local qui sera modifié à chaque <span class="html">dispatch</span>.</p>
                    <p>On ajoute donc :</p>
<pre><code>const [list, setList] = useState(store.getState().list);</code></pre>
                    <p>Et afin de venir modifier notre state à chaque changement du store, on ajoute à notre composant :</p>
<pre><code>useEffect(() =&gt; {
    store.subscribe(() =&gt; { setList(store.getState().list) });
}, [store]);</code></pre>
                    <p>Pour ajouter un produit, nous allons créer un bouton et ajouter un <span class="html">dispatch</span> de type <span class="html">ADD_PRODUCT</span> avec comme payload le modèle 'SuperCremeux' au clic sur celui-ci :</p>
<pre><code>&lt;div className="cartNavBar"&gt;
    &lt;button onClick={() =&gt; store.dispatch({type: 'ADD_PRODUCT', payload: SuperCremeux})}&gt;Ajouter un super crémeux&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>On va modifier le fichier <span class="html">features/cart/Cart.js</span> pour rajouter le code ci-dessus comme ceci :</p>
<pre><code>import { useStore } from "react-redux";
import { SuperCremeux } from "./models";
import { useEffect, useState } from "react";

export const Cart = () =&gt; {
    const store = useStore();
    const [list, setList] = useState(store.getState().list);

    useEffect(() =&gt; {
        store.subscribe(() =&gt; setList(store.getState().list));
    }, [store]);

    return (
        &lt;div className="Selection"&gt;
            &lt;h1&gt;Choisir son menu&lt;/h1&gt;
            &lt;div className="CartNavBar"&gt;
                &lt;button onClick={() =&gt; store.dispatch({type: 'ADD_PRODUCT', payload: SuperCremeux})}&gt;Ajouter un super crémeux&lt;/button&gt;
            &lt;/div&gt;
            {
                list.map((item, index) =&gt, &lt;span key={index} className="SelectedProduct"&gt;{item.title} {item.price}€&lt;/span&gt;)
            }
        &lt;/div&gt;
    );
};</code></pre>
                    <p>Revoyons ensemble ce que nous venons de réaliser :</p>
                    <ol>
                        <li>
                            <p>Nous avons connecté notre composant au store pour écouter chaque changement de valeur de celui-ci.</p>
                        </li>
                        <li>
                            <p>Nous avons exécuté une action d'ajout de produit pour modifier la valeur du store.</p>
                        </li>
                    </ol>
                    <h3>Débuggez votre configuration Redux :</h3>
                    <p>Avant d'aller plus loin, je vous propose de vous mettre dans les meilleures conditions pour travailler avec Redux et Redux Toolkit.</p>
                    <p>En tant qu'utilisateur régulier de React, vous avez sans doute eu l'opportunité d'installer les <span class="em">DevTools</span>, ces outils qui permettent de visualiser et de débugger votre application React dans la barre du navigateur.</p>
                    <p>Eh bien Redux fournit ce même genre d'outil, <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" target="_blank">Redux DevTools</a> !</p>
                    <figure>
                        <img src="../images/Redux_DevTools_1.png" alt="">
                        <figcaption>Redux DevTools</figcaption>
                    </figure>
                    <p>Découvrons l'outil Redux DevTools :</p>
                    <p>Dans l'inspecteur du navigateur, dans l'onglet "Redux", on peut contrôler les actions qui ont eu lieu, ainsi que de les rejouter, consulter la valeur du state à un instant "T" et exécuter manuellement des actions.</p>
                    <p>Nous avons vu que cet outil nous sera utile pour débugegr notre application Redux, notamment grâce à la possibilité de suivre les changements du state, de visualiser les actions et leur contenu, la possibilité de rejouer, d'éditer des actions et encore plein d'autres fonctionnalités.</p>
                    <p>Vous savez à présent comment l'installer et l'utiliser. Il vous sera très utile pour déboguer votre application.</p>
                </article>
                <article>
                    <h2 id="partage_state_composants">Partagez un state entre plusieurs composants :</h2>
                    <h3>Créez un second composant :</h3>
                    <p>Maintenant que nous pouvons modifier notre store et consulter son état à chaque fois que c'est nécessaire, allons apprendre à le gérer à travers plusieurs composants. Ça tombe bien, c'est notre objectif principal !</p>
                    <p>Pour cela, rien de plus simple. Chaque composant de notre application peut avoir accès au store. Nous allons créer un composant dédié au motant total de la commande.</p>
                    <p>Ainsi, dans notre composant <span class="html">Cart.js</span>, on utilise <span class="html">useStore</span> pour accéder au store.</p>
                    <p>Nous rajoutons un abonnement au chanegement de valeur du store pour nous assurer que notre composant sera bien à jour à l'ajout ou à la suppression de produit dans la liste des produits sélectionnés.</p>
                    
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>