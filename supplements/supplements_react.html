<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>React - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#transmation_HTML_React">Transformation d'un simple fichier HTML en app React</a></li>
                        <li><a href="#premier_composant">Création du premier composant</a></li>
                        <li><a href="#initialisation_JSX">Initialisation au JSX</a></li>
                        <li><a href="#Create_React_App">Create React App</a></li>
                        <li><a href="#organisation_code">Organisation du code</a></li>
                        <li><a href="#stylisation_app">Stylisation de l'application</a></li>
                        <li><a href="#decouverte_attribut_style">Découverte de l'attribut style</a></li>
                        <li><a href="#utilisation_images">Utilisation des images</a></li>
                        <li><a href="#iteration_contenu">Itération sur le contenu</a></li>
                        <li><a href="#contextualisation_contenu_composants">Contextualisation du contenu des composants</a></li>
                        <li><a href="#familiarisation_props">Familirisation avec les props</a></li>
                        <li><a href="#maitrise_evenements_React">Maîtrise des événements en React</a></li>
                        <li><a href="#creation_formulaires_React">Création de formulaires avec React</a></li>
                        <li><a href="#stateful_components">Les stateful components</a></li>
                        <li><a href="#useState">useState</a></li>
                        <li><a href="#remonter_etat_maj_composants_enfants">Remonter l'état et le mettre à jour depuis les composants enfants</a></li>
                        <li><a href="#useEffect">useEffect</a></li>
                        <li><a href="#regles_useEffect">Les règles de useEffect</a></li>
                        <li><a href="#creation_application_React_complete">Création d'une application React complète</a></li>
                        <li><a href="#SPA">Single Page Application</a></li>
                        <li><a href="#react_router">React Router</a></li>
                        <li><a href="#navigation_Link">Navigation avec les Link</a></li>
                        <li><a href="#Outlets_pages">Utilisation des Outlets pour afficher certaines parties de la page</a></li>
                        <li><a href="#recuperation_parametres_URL">Récupération des paramètres dans l'URL</a></li>
                        <li><a href="#route_404">Route 404</a></li>
                        <li><a href="#PropTypes">Les PropTypes</a></li>
                        <li><a href="#styled_components">Styled components</a></li>
                        <li><a href="#useState_useEffect_calls_API">useState et useEffect pour effectuer des calls API</a></li>
                        <li><a href="#useContext">useContext</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>React :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Vous avez sûrement déjà entendu parler de React.</p>
                    <p>Utilisée par les entreprises géantes de la Tech comme Facebook, X ou Netflix, il s'agit de l'une des bibliothèques JavaScript les plus populaires pour construire des interfaces web. Son approche par composants réutilisables en fait un outil particulièrement modulaire pour développer vos applications.</p>
                    <p>Lorsqu'on parle de frameworks JavaScript, les noms de React, Vue.js et Angular ne sont jamais bien loin. Et il en existe d'autres (Ember, Meteor, Backbone...). Chacun a ses spécificités, ses avantages et ses inconvénients.</p>
                    <p>React est un projet open-source, distribué sous la licence MIT et piloté par Facebook. Leurs produits web et mobile tels que Facebook, Messenger, Instagram, reposent en grande partie sur cette technologie. Comme React est open-source, vous pouvez accéder au code source <a href="https://github.com/facebook/react" target="_blank">directement sur GitHub</a>, proposer une feature, ou même notifier d'un problème (issue).</p>
                    <p>L'ambition de React est de <span class="em">créer des interfaces utilisateurs</span>, avec un outil <span class="em">rapide</span> et <span class="em">modulaire</span>. L'idée principale derrière React est que vous vous construisez votre application à partir de composants. <span class="em">Un composant regroupe à la fois le HTML, le JS et le CSS</span>, créés sur mesure pour vos besoins, et que vous poubez <span class="em">réutiliser</span> pour construire des interfaces utilisateurs.</p>
                    <p><a href="https://fr.reactjs.org/docs/getting-started.html" target="_blank">Sur sa documentation</a>, React se présente comme "une bibliothèque JavaScript pour créer des interfaces utilisateurs." Pourtant, depuis tout à l'heure je vous parle de framework. En fait, <span class="em">la frontière entre framework et bibliothèque reste assez fine</span>, surtout dans le cas de React; et il n'est pas simple de séparer parfaitement l'un de l'autre.</p>
                    <p>Pour faire simple, vous pouvez vous dire qu'un <span class="em">framework</span> est un ensemble d'outils ultra complets permettant de <span class="em">créer une application de A à Z</span> et fournissant les outils nécessaires au développement d'une application. Alors qu'une <span class="em">bibliothèque s'ajoute à une partie</span> de votre application.</p>
                    <figure>
                        <img src="../images/framework_bibliotheque_React.png" alt="">
                        <figcaption>Les bibliothèques et les frameworks interagissent différemment avec le code.</figcaption>
                    </figure>
                    <p>Angular, par exemple, qui permet de créer une solution complète où tous les outils sont déjà fournis, comme une solution dédiée au routing ou bien aux appels API, est un framework, pour lequel on attend de vous de respecter une certaine architure.</p>
                    <p>En revanche, avec une bibliothèque, tout est beaucoup plus flexible. La bibliothèqyes vous fournit un ensemble de ressources que vous poubez combiner avec d'autres bibliothèques pour construire votre application.</p>
                    <p>À proprement parler, React... est une bibliothèqye. Mais son écosystème est tellement développé maintenant qu'on peut aussi bien le considérer comme un framexork à part entière.</p>
                    <p>Je vous parlais plus tôt des avanatages/inconvénients de chaque framework. Sans même rentrer dans l'aspect technique, voici quelques-uns des atouts de React :</p>
                    <dl>
                        <dt>Sa communauté :</dt>
                        <dd>Particulièrement active, elle vous facilite la vie. Lorsque vous cherchez votre problème sur Internet, il est quasiment impossible que personne n'ait déjà rencontré le même problème que vous. D'autant plus que React compte de très grosses entreprises parmi ses utilisateurs (Netflix, Twitter, Paypal, Airbnb pour n'en citer que quelques-unes). Vous pouvez être sûr qu'un autre ingéneirur s'est déjà trouvé confronté à votre problème. Par exemple, lorsque vous trouvez une question posée sur <a href="https://stackoverflow.com/" target="_blank">Stack Overflow</a> (en anglais). L'équipe de React répond également aux issues (problèmes) <a href="https://github.com/facebook/react/issues" target="_blank">sur le repository GitHub de React</a> (en anglais). Mais il existe un nombre de newsletters, blogs, chaînes YouTube, créées par des utilisateurs - leur dynamique vous donne toujours envie de tester de nouveaux outils.</dd>
                        <dt>Sa documentation :</dt>
                        <dd>La <a href="https://fr.reactjs.org/" target="_blank">documentation de React</a> est riche, régulièrement mise à jour et intégralement traduite en français.</dd>
                        <dt>Ses opportunités professionnelles :</dt>
                        <dd>Comme il s'agit d'un des frameworks les plus populaires, les opportunités professionnelles sont particulièrement nombreuses. Dans <a href="https://2022.stateofjs.com/fr-FR/libraries/front-end-frameworks/" target="_blank">l'enquête annuelle State of JS de 2022</a>, 100% des personnes déclaraient connaître React, et sur 33338 sondés, 27289 déclaraient utiliser React (qui a d'ailleurs <a href="https://2019.stateofjs.com/awards/" target="_blank">gagné l"Award 2019</a> de la technologie la plus utilisée).</dd>
                    </dl>
                </article>
                <article>
                    <h2 id="transformation_HTML_React">Transformez un simple fichier HTML en app React :</h2>
                    <p>Nous allons maintenant <span class="em">transformer un fichier HTML en app React</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode que je vous montre ici n'est pas une méthode utilisée dans le monde du travail. Il s'agit d'un moyen de vous montrer les bases sans aoir à faire trop de paramétrage, et sans avoir à utiliser trop d'outils tels que Webpack. Ici, nous pouvons nous concentrer sur l'essentiel.</p>
                    </div>
                    <p>Nous allons utiliser des liens CDN (Content Deklivery Network) pour ajouter React à un fichier HTML.</p>
                    <p>On oublie pas d'aller chercher le lien CDN de Babel et on rajoute une autre balise &lt;script&gt; :</p>
<pre><code>&lt;div id="root"&gt;Bonjour&lt;/div&gt;
&lt;script type="text/babel"&gt;
    ReactDom.render(&lt;div&gt;Mon élément remplace le contenu précédent&lt;/div&gt;,
                    document.getElementById('root')
                   )
&lt;/script&gt;</code></pre>
                </article>
                <article>
                    <h2 id="premier_composant">Créez votre premier composant :</h2>
                    <p>Écrivons maintenant <span class="em">notre premier composant</span>.</p>
                    <p>Ici, je vais utiliser des composants qu'on appelle <span class="em">functional components</span> (composants fonction), c'est-à-dire une fonction qui retourne un élément React. Commençons avec cette <span class="em">prem!re fonction</span>, MyComponent :</p>
<pre><code>function MyComponent() {
    return (&lt;div&gt;Hello World !&lt;/div&gt;)
}</code></pre>
                    <p>En copiant ce code dans la partie JS, rien ne se passe. Pas de panique ! C'est normal : il vous reste encore à attacher votre composant React à votre HTML.</p>
                    <p>On va dès maintenant <span class="em">utiliser ReactDOM pour s'atatcher à notre HTML</span>.</p>
                    <p>Dans le code ci-dessous, l'id <span class="em">root</span> permet de préciser où notre app React va vivre dans notre HTML. Ensuite, on va ordonner à ReactDOM de générer (<span class="em">render</span>) notre composant React qui s'appelle MyComponent.</p>
<pre><code>ReactDOM.render(&lt;,MyComponent /&gt;, document.getElementById('root'))</code></pre>
                    <p>Et tadaaa ! Notre composant s'affiche !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe différentes manières de créer des composants en React. Il y a peu de temps encore, la manière la plus utilisée était d'utiliser des composants classes, avec la syntaxe :</p>
<pre><code>class MyComponent extends React.Component</code></pre>
                        <p>Cette manière était la seule pour utiliser des fonctionnalités qui sont au coeur de React. Mais depuis la mise à jour de React 16.8 en 2019, les composants fonctions permettent aussi de gérer tout ça.</p>
                    </div>
                    <p class="em">Les composants sont essentiels dans React.</p>
                    <p>Une interface est toujours constituée de différents éléments : des boutons, des listes, des titres, des sous-tritres. Une fois rassemblés, ces éléments constituent une <span class="em">interface utilisateur ou UI</span>. Si je prends l'exemple de la maquette du site de plantes ci-dessous, vous voyez la barre de menu, le panier, et que pour chaque article, il y a un nom, une photo, une description.</p>
                    <img src="../images/maquette_React.png" alt="">
                    <p>Avec React, chacune de ces parties qu'on va pouvoir réutiliser correspond à un composant. Ils contiennent tout ce qui est nécessaire à leur bon fonctionnement : <span class="em">la structure, les styles et le comportement</span> (par exemple, les actions qui sont déclenchées quand on clique dessus).</p>
                    <p>Les composants nous permettent d'utiliser la même structure de données, et de remplir ces structures avec différents jeux de données. Peu importe le nombre de plantes que vous aurez à mettre dans La maison jungle, vous pourrez les exploiter pour afficher vos données sans aucun effort. Et si dans le futur, vous avez besoin de créer une nouvelle page avec la même présentation, vous pourrez réutiliser le même composant: vous vous rendez compte de la puissance des composants ?</p>
                    <p>C'est donc la mission des développeurs et développeurses React de découper toute interface utilisateur en éléments réutilisables, imbriqués les uns dans les autres. La majorité de nos composants sont eux-mêmes créés en <span class="em">combinant d'autres composants</span> plus simples.</p>
                    <p>Derrière chaque technologie, il y a une logique.</p>
                    <p>Vous savez que le HTML est une suite d'instructions que le navigateur doit suivre pour construire le DOM. Eh bien, <span class="em">react vient directement modifier le DOM pour vous</span> ; il suffit juste de lui donner les instructions de ce que vous souhaitez faire.</p>
                    <p>Pour faire simple : en utilisant <span class="html">React.createElement</span>, React crée d'abord ses éléments dans le DOM virtuel, puis il vient prévenir le DOM au moment de sa créatuibn "Hé, rajoute-moi une balise h1 avec le texte <span class="em">La maison jungle</span> dedans".</p>
<pre><code>&lt;div id="root"&gt;&lt;/div&gt;

const Header = React.createElement('h1', {}, 'La maison jungle')

console.log(Header)

ReactDOM.render(Header, document.getElementById("root"))</code></pre>
                    <p>En faisant un <span class="html">console.log</span> de votre composant, voilà ce que vous obtenez :</p>
                    <figure>
                        <img src="../images/console_log_React.png" alt="">
                        <figcaption>Un console.log de notre premier composant</figcaption>
                    </figure>
                    <p><span class="em">Header</span> est ici un élément React, créé par React. Concrètement, il s'agit d'un gros objet. Chaque composant génère des arborescences d'éléments React et d'autres composants, qui seront ensuite traduits en éléments dans le DOM.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>C'est un peu comme lorsque vous créez en JavaScript un nouvel élément avec <span class="html">document.createElement</span> et que vous l'ajoutez au DOM avec la méthode <span class="html">.appendChild()</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="initialisation_JSX">Initiez-vous au JSX :</h2>
                    <p>Vous avez découvert que les éléments renvoient des objets avec tout un ensemble de propriétés spécifiques, et que React vient les créer avec <span class="em">createElement</span>. Mais vous vous doutez que les développeurs React ne manipulent pas ces objets directement. Non, à la place, ils utilisent le <span class="em">JSX</span>.</p>
                    <p>Il s'agit de l'extension JavaScript créée par React, qui permet d'<span class="em">utiliser notre syntaxe sous forme de tages directement dans le code JavaScript</span>.</p>
                    <p>Lorsqu'on a ça :</p>
<pre><code>function Header() {
    return (&lt;div&gt;
        &lt;h1&gt;La maison jungle&lt;/h1&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>... et qu'on le réutilise avec <span class="em">&lt;Header /&gt;</span>, on pourrait croire qu'il s'agit de HTML. Ça a un peu la même tête, mais il s'agit de JSX ! Eh oui, JSX est la manière la plus compréhensible d'écrire dfes composants React dans une application, et donc la manière qui est quasiment toujours utilisée. Il s'agit d'ailleurs de <span class="em">la sépcificité de React</span> : contrairement aux autres frameworks où on écrit du HTML enrichi, les équipes de React ont créé le JSX, leur propre syntaxe basée sur JavaScript, qui permet de <span class="em">mêler HTML et JS</span>.</p>
                    <p>Comme le HTML, le JSX est un <span class="em">langage à balises</span>. Les touches <span class="html">&lt;</span>, <span class="html">&gt;</span> et <span class="html">/</span> de vos claviers vont donc être souvent utilisées.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>On a bien créé un composant <span class="em">Header</span> et pas <span class="em">header</span>. Il est essentiel de <span class="em">mettre une majuscule à nos composants JSX</span>, sinon React ne saura pas qu'il s'agit d'un composant, et pensera qu'il s'agit juste d'une balise HTML.</p>
                    </div>
                    <h3>Composez vos composants :</h3>
                    <p>Reprenons notre composant <span class="em">&lt;Header /&gt;</span>. Il est un peu tout seul, vous ne trouvez pas ?</p>
                    <p>On va lui ajouter un composant <span class="em">&lt;Description /&gt;</span> :</p>
<pre><code>function Description() {
    return (&lt;p&gt;Ici achetez toutes les plantes dont vous avez toujours rêvé&lt;/p&gt;)
}</code></pre>
                    <p>Et on le rajoute dans le render :</p>
<pre><code>ReactDOM.render(&lt;Header /&gt;&lt;Description /&gt;, document.getElementById("root"))</code></pre>
                    <p>Quoi ?! Rien ne s'affiche sauf un point d'exclamation entouré de rouge : il y a une erreur !</p>
                    <p>Pas de panique, c'est normal : deux composants doivent toujours être <span class="em">wrappés dans un seul composant parent</span>.</p>
                    <p>On peut donc faire :</p>
<pre><code>ReactDOM.render(&lt;div&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/div&gt;, document.getElementById("root"))</code></pre>
                    <p>et le problème est résolu.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>React met également à notre disposition un outil, les Fragments, si on veut wrapper deux composants dans un seul parent sans que le parent apparaisse dans le DOM. Pour ça, vous pouvez faire :</p>
<pre><code>ReactDOM.render(&lt;React.Fragment&gt;&lt;Header /&gt;&lt;Description /&gt;&lt;/React.Fragment&gt;, document.getElementById("root"))</code></pre>
                        <p>Nos éléments sont bien wrappés, et si vous inspectez votre page, ce parent n'apparaît pas dans le DOM.</p>
                    </div>
                    <p>Comme je vous l'ai expliqué, le propre de react est de nous encourager à <span class="em">réutiliser nos composants</span>. On va donc structurer notre interface en arborescences de composants.</p>
                    <p>Regroupons notre Titre et notre Description dans une bannière :</p>
<pre><code>function Banner() {
    return (&lt;div&gt;
        &lt;Header /&gt;
        &lt;Description /&gt;
    &lt;/div&gt;)
}</code></pre>
                    <p>Vous voyez ? Tout se passe bien comme prévu.</p>
                    <p>Et nous pourrions également les encapsuler, et les utiliser autant de fois que nous le souhaitons comme ci-dessous :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
    &lt;Enfant /&gt;
&lt;/Parent&gt;</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Vous remarquez d'aillez que tous nos composants sont bien fermés. En JSX, <span class="em">toutes les balises doivent être fermées</span>, y compris les éléments HTML autofermants tels que input. On l'écrira de cette manière (en lui ajoutant les attributs souhaités) :</p>
<pre><code>&lt;input /&gt;</code></pre>
                    </div>
                    <h3>Manipulez des données dans vos composants JSX :</h3>
                    <p>En React, les accolades <span class="html">{</span> et <span class="html">}</span> sont également particulièrement utiles. Dès qu'il s'agit d'expressions JavaScript, elles sont écrites entre accolades.</p>
                    <p>Ça nous permet d'<span class="em">appliquer des expressions JavaScript</span> directement dans notre JSX pour :</p>
                    <ul>
                        <li>
                            <p>faire des maths :</p>
<pre><code>&lt;div&gt;La grande réponse sur la vie, l'univers et le reste est { 6 * 7 } &lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>modifier des chaînes de caractères :</p>
<pre><code>&lt;div&gt;{ alexia.toUpperCase() }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>utiliser des <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaires</a> :</p>
<pre><code>&lt;div&gt;{ 2 &gt; 0 ? 'Deux est plus grand que zéro' : 'Ceci n\'apparaîtra jamais' }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Ou même tout simplement pour afficher une variable JS :</p>
                    <ul>
                        <li>
                            <p>pour une string :</p>
<pre><code>&lt;div&gt;{ myTitle }&lt;/div&gt;</code></pre>
                        </li>
                        <li>
                            <p>pour un nombre :</p>
<pre><code>div&gt;{ 42 }&lt;/div&gt;</code></pre>
                        </li>
                    </ul>
                    <p>Par exemple, si on décide de mettre notre texte ou description dans une variable :</p>
<pre><code>function Description() {
    const text = "Ici achetez toutes les plantes dont vous avez toujours rêvées"
    return (&lt;p&gt;{ text }&lt;/p&gt;)
}</code></pre>
                    <p>ça s'affiche bien comme prévu.</p>
                </article>
                <article>
                    <h2 id="Create_React_App">Prenez en main Create React App :</h2>
                    <p>Nous avons appris à utiliser les liens CDN de React, ReactDOM et Babel pour rapidement créer une app React. Mais cette technique n'est quasiment pas utilisée dans la vie de tous les jours d'un développeur.</p>
                    <p>À la place, les développeuses et développeurs utilisent des outils automatisés pour créer une base de code, qui dispose des outils essentiels déjà préconfigurés. Pour vous citer quelques-unes des fonctionnalités de ces outils, ils permettent de :</p>
                    <ul>
                        <li>
                            <p>gérer les différentes dépendances (bibliothèques) utilisées par notre app;</p>
                        </li>
                        <li>
                            <p>optimiser le chargement de notre code dans les navigateurs;</p>
                        </li>
                        <li>
                            <p>importer du CSS et des images;</p>
                        </li>
                        <li>
                            <p>gérer les différentes versions de JavaScript;</p>
                        </li>
                        <li>
                            <p>faciliter l'expérience de développement, en rechargeant la page lorsque le code est modifié.</p>
                        </li>
                    </ul>
                    <h3>Découvrez CRA :</h3>
                    <p>Également créé par les équipes de Facebook, <a href="https://github.com/facebook/create-react-app" target="_blank">Create React App</a> est un outil qui vous aidera à faire tout ce que je viens de citer. S'il existe d'autres outils (<a href="https://nextjs.org/" target="_blank">Next</a>, <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a>, <a href="https://parceljs.org/" target="_blank">Parcel</a>, etc.), Create React App reste la référence, notamment pour les nouveaux utilisateurs de React.</p>
                    <p>Create React App va permettre de <span class="em">générer un squelette de code</span> pour votre application. Il embarque un certain nombre d'<span class="em">outils préconfigurés</span>, tels que Webpack, Babel et ESLint, afin de vous garantie la meilleure expérience de développement possible.</p>
                    <h3>Installez et lancez CRA :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour manipuler Create React App ici, nous allons avoir besoin d'un gestionnaire de paquet (<span class="em">package manager</span>) directement dans le terminal. Ici, je vais utiliser <span class="html">yarn</span>. Si vous utilisez une autre version, telle que npm, je vous conseille de vous référer au <a href="https://github.com/facebook/create-react-app#user-guide" target="_blank">guide d'utilisation de Create React App par Facebook, sur GitHub</a> (en anglais).</p>
                        <p>D'ailleurs, si vous voulez en apprendre davantage sur pourquoi choisir npm ou Yarn, <a href="https://blog.zenika.com/2017/03/13/npm-vs-yarn/" target="_blank">je vous conseille cet excellent article de blog qui compare les deux.</a></p>
                    </div>
                    <p>Pour commencer, placez-vous dans le dossier où vous voulez créer votre projet.</p>
                    <p>Pour initialiser votre projet, nous allons faire :</p>
<pre><code>yarn create react-app la-maison-jungle</code></pre>
                    <p>Grâce à cette commande, vous avez votre premier projet créé avec Create React App !</p>
                    <h3>Découvrez les fichiers :</h3>
                    <p>Maintenant que votre projet est initialisé, il est temps de vous plonger dedans et de partir à l'exploration des fcihiers créés. On rentre dans le projet avec <span class="html">cd la-maison-jungle</span> dans votre terminal.</p>
                    <p>À partir de là, vous pouvez ouvrir votre éditeur de texte préféré pour jeter un oeil.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Votre environnement de travail est particulièrement important. Vous devez vous sentir à l'aise avec les outils que vous utilisez. VS Code vous permet d'installer des extensions qui vous offrent des fonctionnalités supplémentaires. Typiquement, pour un projet React, les extensions Prettier et ESLint sont très utiles !</p>
                    </div>
                    <p>Vous trouverez trois dossiers :</p>
                    <ul>
                        <li>
                            <p><span class="html">node_modules</span> : c'est là que sont installées toutes les <span class="em">dépendances</span> de notre code. Ce dossier peut vite devenir très volumineux.</p>
                        </li>
                        <li>
                            <p><span class="html">public</span> : dans ce dossier, vous trouverez votre <span class="em">fichier</span> <span class="html">index.html</span> et d'autres fichiers relatifs au référencement web de votre page.</p>
                        </li>
                        <li>
                            <p><span class="html">src</span> : vous venez de renrer dans le coeur de l'action. <span class="em">L'essentiel des fichiers que vous créerez et modifierez seront là.</span></p>
                        </li>
                    </ul>
                    <p>Et faisons maintenant un petit tour des fichiers importants :</p>
                    <ul>
                        <li>
                            <p><span class="html">package.json</span> situé à la racine de votre projet, il vous permet de <span class="em">gérer vos dépendances</span> (tous les outils permettant de construire votre projet), vos scripts qui peuvent être exécutés avec <span class="html">yarn</span>, etc. Si vous examinez son contenu, vous pouvez voir des dépendances que vous connaissez : React et ReactDOM :</p>
                            <ul>
                                <li>
                                    <p>vous y trouverez <span class="html">react-scripts</span>, créé par Facebook, qui permet d'installer Webpack, Babel, ESLint et d'autres pour vous faciliter la vie</p>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <p>dans <span class="html">/public</span>, vous trouvez <span class="html">index.html</span>. Il s'agit du <span class="em">template de votre application</span>. Il y a plein de lignes de code, mais vous remarquez <span class="html">&lt;div id="root"&gt;&lt;/div&gt;</span> ? Comme précédemment, nous allons y ancrer notre app React</p>
                        </li>
                        <li>
                            <p>dans <span class="html">/src</span>, il y a <span class="html">index.js</span> qui permet d'<span class="em">initialiser notre app React</span>;</p>
                        </li>
                        <li>
                            <p>et enfin, dans <span class="html">/src</span>, vous trouvez <span class="html">App.js</span> qui est <span class="em">notre premier composant React</span>.</p>
                        </li>
                    </ul>
                    <p>Deux fichiers que nous n'utiliserons pas directement mais qui ne font pas de mal à garder :</p>
                    <ul>
                        <li>
                            <p>le <span class="html">README.md</span> qui permet d'afficher une page d'explication si vous mettez votre code sur GitHub, par exemple</p>
                        </li>
                        <li>
                            <p>et le fichier <span class="html">.gitignore</span> qui précise ce qui ne doit pas être mis sur GitHub, typiquement le volumineux dossier des <span class="html">node_modules</span>.</p>
                        </li>
                    </ul>
                    <h3>Choisir une version spécifique de React :</h3>
                    <p>Pour mettre à jour les dépendances, nous allons suivre différentes étapes :</p>
                    <ol>
                        <li>
                            <p>Rendez-vous au fichier <span class="html">package.json</span> dans la section <span class="html">depencies</span>. Modifiez cette section avec le code suivant, correspondant aux dépendances nécessaires à React 17 :</p>
<pre><code>"dependencies": {
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "react-scripts": "4.0.1",
    "web-vitals": "^0.2.4"
},</code></pre>
                        </li>
                        <li>
                            <p>Supprimez le fichier <span class="html">yarn.lock</span> (ou <span class="html">package.lock</span> si vous avez utilisé npm) ainsi que le dossier de nos dépendances <span class="html">node_modules</span>.</p>
                        </li>
                        <li>
                            <p>Dans le dossier <span class="html">src</span>, modifiez le fichier <span class="html">index.js</span> qui a été généré pour la dernière version de React avec le code correspondant à la version de React 17, comme ceci :</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;App /&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
);</code></pre>
                        </li>
                        <li>
                            <p>Lancer la commande <span class="html">yarn</span> pour installer les dépendaces.</p>
                        </li>
                    </ol>
                    <p>Vous pouvez procéder de la même manière pour installer n'importe quelle version spécifique de React dans votre application. En suivant le cheminement ci-dessus vous serez à même de suivre la suite de ce cours sans difficulté.</p>
                    <h3>Prenez en main votre app avec les commandes :</h3>
                    <p>Lorsque vous vous trouvez à la racine de votre projet, vous pouvez exécuter <span class="html">yarn start</span> qui va <span class="em">démarrer votre application en mode développement</span>.</p>
                    <p>Cela vous donne quelque chose comme ça (même si votre adresse IP sera très probablement différente) :</p>
                    <img src="../images/yarn_start_React.png" alt="">
                    <p>Un onglet a dû s'ouvrir dans votre navigateur à l'URL <span class="em">http://localhost:3000/</span>. Si ce n'est pas le cas, ouvrez-le vous-même.</p>
                    <p>Vous avez le magnifique logo de React qui tourne dans votre navigateur.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Il existe d'autres commandes :</p>
                        <ul>
                            <li>
                                <p><span class="html">yarn run build</span> vous permettra de créer un <span class="html">build</span> avec votre code transformé et minifié, si vous devez déployer votre application en production (la mettre en ligne, par exemple);</p>
                            </li>
                            <li>
                                <p><span class="html">yarn test</span> pour exécuter les tests.</p>
                            </li>
                        </ul>
                        <p>Vous pouvez d'ailleurs créer vos propres commandes si vous les ajoutez dans la partie <span class="html">scripts</span>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="organisation_code">Organisez votre code :</h2>
                    <p>Nous allons maintenant <span class="em">modifier notre base de code</span> pour qu'elle soit plus à l'image de notre projet. Il existe plusieurs manières d'organiser son code, et il est important de réfléchir à comment l'organiser. Ici, nous allons séparer les fichiers selon leur type : composants/style/images, etc.</p>
                    <p>On va commencer par créer un dossier <span class="html">/components</span> dans <span class="html">/src</span>, où nous mettrons tous nos composants. On y glisse <span class="html">App.js</span> et on en profite pour changer le chemin d'import dans <span class="html">index.js</span>. Pour ce qui est des autres fichiers, le plus important est <span class="html">index.js</span> que vous devez garder. Vous pouvez également garder <span class="html">index.css</span>, mais vous pouvez supprimer les autres fichiers.</p>
                    <p>Maintenant, <span class="em">créons notre</span> <span class="html">Banner</span> dans un fichier JavaScript à part dans <span class="html">/components</span> que nous pouvons appeler <span class="html">Banner.js</span>.</p>
<pre><code>function Banner() {
    return &lt;h1&gt;La maison jungle&lt;/h1&gt;
}

export default Banner</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous remarquez la notation <span class="html">export default</span> ? Il s'agit d'une syntaxe prévue dans l'ES6, qui vous épargnera d'utiliser les accolades au moment de l'import.</p>
                    </div>
                    <p>On peut maintenant adapter le code de <span class="html">App.js</span> en supprimant le code de base, et <span class="em">y importer notre</span> <span class="html">Banner</span>.</p>
<pre><code>import Banner from './Banner'

function App() {
    return &lt;Banner /&gt;
}

export default App</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/banner_React.png" alt="">
                        <figcaption>Notre Banner s'affiche dans le navigateur.</figcaption>
                    </figure>
                    <p>Félicitations ! Comme je l'ai déjà mentionné, mais ici, c'est <a href="https://webpack.js.org/" target="_blank">Webpack</a> qui nous permet d'importer notre composant aussi facilement, avec <span class="html">import</span>. Cet outil particulièrement utile est essentiel pour lier les fichiers entre eux, afin qu'ils soient interprétés par le navigateur. Et dire que Create React App nous a permis de l'installer sans faire aucune configuration. Si ça c'est pas de la chance !</p>
                    <figure>
                        <img src="../images/webpack_React.png" alt="">
                        <figcaption>Import vos composants grâce à Webpack</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="stylisation_app">Stylisez votre app :</h2>
                    <p>C'est maintenant le moment d'ajouter un peu de style à nos composants.</p>
                    <h3>Exploitez les classNames :</h3>
                    <p>Comme en HTML, nous pouvons <span class="em">associer des attributs à nos éléments</span>. Les attributs HTML tels que <span class="html">id</span>, <span class="html">href</span> pour un lien &lt;a /&gt;, <span class="html">src</span> pour une balise &lt;img /&gt;, fonctionnent normalement en JSX.</p>
                    <p>En revanche, il existe des mots réservés en JavaScript, tels que <span class="html">class</span>. Pour attribuer du style avec une classe CSS, il suffit pour cela d'utiliser l'attribut <span class="html">className</span>, et de lui préciser une string. D'ailleurs, vous pouvez utiliser plusieurs classes sur un élément en les mettant à la suite, séparées par un espace.</p>
                    <p>Créons dans <span class="html">/src</span> un dossier <span class="html">/styles</span> qui va regrouper nos fichiers CSS. On peut y glisser <span class="html">index.css</span> en n'oubliant pas de modifier le path relatif pour importer <span class="html">index.css</span> dans <span class="html">index.js</span>.</p>
                    <p>Je crée donc mon fichier <span class="html">Banner.css</span> qui va me permettre de <span class="em">styliser mon composant</span>. Ce qui nous donne une organisation comme dans la capture ci-dessous :</p>
                    <figure>
                        <img src="../images/banner_CSS_React.png" alt="">
                        <figcaption>L'arborescence de notre app</figcaption>
                    </figure>
                    <p>Dans <span class="html">Banner.js</span>, je wrappe mon <span class="em">h1</span> dans une div à laquelle je <span class="em">précise la className lmj-banner</span> ("lmj" pour la maison jungle, bien sûr !) :</p>
<pre><code>&lt;div className='lmj-banner'&gt;
    &lt;h1&gt;La maison jungle&lt;/h1&gt;
&lt;/div&gt;</code></pre>
                    <p>Et retour dans notre fichier <span class="html">Banner.css</span>, où on <span class="em">crée la classe correspondante</span> :</p>
<pre><code>.lmj-banner {
    color: black;
    text-align: right;
    padding: 32px;
    border-bottom: solid 3px black;
}</code></pre>
                    <p>Jetons un oeil à notre page dans le navigateur.</p>
                    <p>Rien ne se passe car nous n'avons tout simplement pas <span class="em">importé le fichier</span>. Il suffit de rajouter dans notre fichier <span class="html">Banner.js</span> :</p>
<pre><code>import '../styles/Banner.css'</code></pre>
                    <p>Et ça y est ! Notre style est appliqué !</p>
                    <p>En React comme dans toutes les librairies et tous les frameworks front, <span class="em">l'accessibilité du web est essentielle</span>. Elle est nécessaire pour permettre aux technologies d'assistance et aux personnes en situation de handicap, notamment, d'interpréter les pages web. Pour en savoir plus, je vous conseille "<a href="https://openclassrooms.com/fr/courses/6691346-concevez-un-contenu-web-accessible" target="_blank">Concevez un contenu web accessible</a>", un excellent cours sur ce sujet.</p>
                </article>
                <article>
                    <h2 id="decouverte_attribut_style">Découvrez l'attribut style :</h2>
                    <p>Bonne nouvelle : les éléments React acceptent également l'attribut <span class="html">style</span> pour styliser un composant. À la différence des éléments HTML, pour lesquels cet attribut est également accepté, il faut lui passer un objet en paramètre. On appelle cette méthode du <span class="em">inline style</span> :</p>
<pre><code>import '../styles/Banner.css'

function Banner() {
    return (
        &lt;div
                style={{
                    color: 'black',
                    textAlign: 'right',
                    padding: 32,
                    borderBottom: 'solid 3px solid'
                }}
        &gt;
            &lt;h1&gt;La maison jungle&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>Cet attribut peut être pratique pour tester rapidement quelque chose, mais il n'est pas recommandé d'en faire une utilisation plus poussée. Donc, pour styliser votre application, privilégiez davantage la méthode des classNames, ou d'autres méthodes avec des librairies tierces, par exemple.</p>
                </article>
                <article>
                    <h2 id="utilisation_images">Utilisez des images :</h2>
                    <p>Vous avez peut-être vu le <span class="em">logo.svg</span> de React situé dans <span class="html">/src</span> ?</p>
                    <p>Ici, nous allons faire un peu la même chose. Mais commençons par organiser tout ça.</p>
                    <p>Toujours dans <span class="html">/src</span> , on crée un dossier <span class="html">/assets</span> dans lequel on vient mettre notre fichier <span class="em">logo.png</span> qui voici :</p>
                    <img src="../images/logo.png" alt="">
                    <p>Pour <span class="em">l'importer dans votre code</span>, vous pouvez maintenant faire de la manière suivante . Dans <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'</code></pre>
                    <p>Vous voyez ici, on déclare en fait une variable logo à laquelle on assigne le contenu de notre image.</p>
                    <p>Puis vous pouvez <span class="em">l'utiliser dans un élément img</span>, ce qui nous donne pour notre <span class="html">Banner.js</span> :</p>
<pre><code>import logo from '../assets/logo.png'
import '../styles/Banner.css'

function Banner() {
    const title = 'La maison jungle'
    return (
        &lt;div className='lmj-banner'&gt;
            &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
            &lt;h1 className='lmj-title'&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Banner</code></pre>
                    <p>En ajoutant un peu de CSS, me voilà avec la bannière telle que je la voulais.</p>
                    <p>Vous avez maintenant une très bonne base de code pour créer votre application, en utilisant du style et des assets directement dans vos composants React.</p>
                </article>
                <article>
                    <h2 id="iteration_contenu">Itérez sur votre contenu :</h2>
                    <p>En code, vous serez très souvent confronté à des listes de données qui présentent la même struture. Bonne nouvelle ! Pas besoin de vous faire des crampes à force de copier-coller : vous pouvez <span class="em">directement itérer sur votre contenu et générer des composants react dessus</span>.</p>
                    <h3>Découvrez votre allié : map() :</h3>
                    <p>La <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/map" target="_blank">méthode JavaScript <span class="html">map()</span></a> passe sur chaque élément d'un tableau. Elle lui applique une fonction, et renvoie un nouveau tableau contenant les résultats de cette fonction appliquée sur chaque élément.</p>
                    <p>Par exemple, pour une fonction qui doublerait la valeur d'un élément, cela donne :</p>
<pre><code>const numbers = [1, 2, 3, 4]
const doubles = numbers.map(x =&gt; x * 2) // [ 2, 4, 6, 8]</code></pre>
                    <p>Dans notre cas, ekke ca biys oerlerrre de <span class="em">prendre une liste de données</span>, et de la <span class="em">transformer en liste de composants</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>La méthode <span class="html">map()</span> permet facilement d'itérer sur des données et de retourner un tableau d'éléments. Comme elle, les méthodes <span class="html">forEach()</span>, <span class="html">filter()</span>, <span class="html">reduce()</span>, etc., qui permettent de manipuler des tableaux, seront également vos alliés en React.</p>
                    </div>
                    <p>On va donc créer un composant <span class="html">ShoppingList.js</span> pour notre magain de plantes.</p>
                    <p>Dans ce fichier, on déclare une variable plantList qui <span class="em">contient notre liste de plantes</span> :</p>
<pre><code>const plantList = [
    'monstera',
    'ficus lyrata',
    'pothos argenté',
    'yucca',
    'palmier'
]</code></pre>
                    <p>Et <span class="em">on ajoute en dessous le composant</span> lui-même :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant) => (
                &lt;li&gt;{plant}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Vous voyez : pour chaque entrée du tableau, on retourne un élément <span class="html">&lt;li&gt;</span>.</p>
                    <p>On <span class="em">importe ShoppingList.js dans</span> <span class="html">&lt;App /&gt;</span>. On a notre liste de composants !</p>
                    <p>Mais qu'est-ce que c'est que cette erreur rouge dans ma console ?</p>
                    <p>Oh oh ! Il semblerait que j'aie oublié la prop <span class="html">key</span>.</p>
                    <p>La <a href="https://fr.reactjs.org/docs/lists-and-keys.html" target="_blank">documentation de React</a> est claire sur ce sujet : les <span class="html">key</span> (clés) aident React à <span class="em">identifier quels éléments d'une liste ont changé, ont été ajoutés ou spprimés</span>. Vous devez donner une clé à chaque élément dans un tableau, afin d'apporter aux éléménts une identité stable.</p>
                    <p>Si vous voulez éviter kes bugs, une <span class="html">key</span> doit impérativement respecter deux principes :</p>
                    <ul>
                        <li>
                            <p>Elle doit être <span class="em">unique</span> au sein du tableau.</p>
                        </li>
                        <li>
                            <p>Et <span class="em">stable dans le temps</span> (pour la même donnée source, on aura toujours la même valeur de <span class="html">key=</span>).</p>
                        </li>
                    </ul>
                    <p>Nous avons plusieurs méthodes pour générer une <span class="em">key</span> unique :</p>
                    <ul>
                        <li>
                            <p>La méthode la plus simple et la plus fiable consiste à <span class="em">utiliser l'id associée à votre donnée</span> dans votre base de données.</p>
                        </li>
                        <li>
                            <p>Vous pouvez également trouver un moyen d'<span class="Em">exploiter la valeur de la donnée</span>, si vous avez la certitude qu'elle sera toujours unique, et stable dans le temps.</p>
                        </li>
                        <li>
                            <p>En dernier recours, vous pouvez <span class="em">définir une string et la combiner avec l'index</span> de la data dans votre tableau.</p>
                        </li>
                    </ul>
                    <p>Dans notre cas, puisqu'il n'y a pas d'id associée, on peut faire une combinaison entre l'index et le nom de la plante qui est une string :</p>
<pre><code>function ShoppingList() {
    return (
        &lt;ul&gt;
            {plantList.map((plant, index) =&gt; (
                &lt;li key={`${plant}-${index}`}&gt;{ plant }&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Cette fois-ci, pas d'erreur dans la console !</p>
                </article>
                <article>
                    <h2 id="contextualisation_contenu_composants">Contextualisez le contenu de vos composants :</h2>
                    <p>React nous permet de faire des listes de composants : un gain de temps énorme dans votre vie de développeur. Mais ce n'est pas tout ! Le JSX nous permet également d'<span class="em">afficher des éléments de manière conditionnelle dans nos composants</span>.</p>
                    <h3>Créez des conditions dans le JSX :</h3>
                    <p>Donc... Nous avons déjà vu <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_conditionnel" target="_blank">ternaire</a>. maintenant qu'on a une app complète pour nous faire la main, moi, ça me donne envie de le mettre en applicationdans notre site de plantes.</p>
                    <p>Dans notre liste de plantes <span class="html">plantList.js</span>, je vais <span class="em">rajouter une catégorie <span class="html">isBestSale</span> correspondant à un <span class="html">booléen</span></span> qui nous indique si notre plante fait partie des meilleures ventes. Ce qui nous donne pour le premier élément :</p>
<pre><code>{
    name: 'monstera',
    category: 'classique',
    id: '1ed',
    isBestSale: true
},</code></pre>
                    <p>Maintenant que nous avons notre booléen, nous allons <span class="em">utiliser un ternaire pour afficher un emoji en fonction</span>. Dans <span class="html">ShoppingList.js</span>, au niveau de l'affichage du nom, je rajoute :</p>
<pre><code>{plantList.map((plant) =&gt; (
    &lt;li key={ plant.id }&gt;
        {plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : &lt;span&gt;👎&lt;/span&gt;}
    &lt;/li&gt;
))}</code></pre>
                    <p>Ce qui nous donne :</p>
                    <figure>
                        <img src="../images/condition_React.png" alt="">
                        <figcaption>Notre condition différencie les meilleures ventes des autres.</figcaption>
                    </figure>
                    <p>Génial ! Ça marche bien !</p>
                    <p>Mais en y repensant, je ne suis pas sûre que ce soit top comme argulent de vente... À la place, n'affichons que le 🔥 pour les meilleures ventes, et rien pour les autres.</p>
                    <p>Pour ça, on peut <span class="em">retourner <span class="html">null</span> dans la condition où on ne veut rien afficher</span> :</p>
<pre><code>{plant.isBestSale ? &lt;span&gt;🔥&lt;/span&gt; : null}</code></pre>
                    <p>Et voilà ! On a ce que l'on voulait !</p>
                    <p>Mais vous savez quoi ? Il existe une manière encore plus simple d'écrirer ça : vous pouvez utiliser <span class="html">&amp;&amp;</span>.</p>
                    <p>Indiquée entre accolades, <span class="html">&amp;&amp;</span> précède un élément JSX et <span class="em">précise que l'élément ne sera généré que si la condition est respectée</span>. On peut donc écrire :</p>
<pre><code>{plant.isBestSale && &lt;span&gt;🔥&lt;/span&gt;}</code></pre>
                    <p>Yes ! Ça fonctionne comme prévu !</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous pouvez d'ailleurs chaîner les conditions.</p>
                    </div>
                    <h3>Ouvrez-vous à d'autres méthodes :</h3>
                    <p>React est particulièrement flexible : il existe d'autres méthodes permettant de contextualiser votre contenu.</p>
                </article>
                <article>
                    <h2 id="familisarisation_props">Familiarisez-vous avec les props :</h2>
                    <p>Vous l'avez compris : la réutilisation des composants est au coeur de la logique de react. Mais, pour être réutilisés, les composants requièrent souvent une conviguration. Bonne nouvelle : pour ça, vous allez pouvoir utiliser les props.</p>
                    <h3>Familiarisez-vous avec la syntaxe :</h3>
                    <p>Et si je vous disais que vous avez déjà utilisé une prop ? Eh oui, la prop <span class="html">key</span> sur les listes ! Vous avez donc déjà vu la syntaxe.</p>
                    <p>Revenons à notre site de plantes. Nous allons maintenant créer un nouveau composant qui va être réutilisé. L'idée est de créer une échelle d'arrosage et une échelle de luminosité pour chaque plante.</p>
                    <p>Rouvrons <span class="html">ShoppingList.js</span>, où nous <span class="em">ajoutons les données correspondantes dans <span class="html">plantList</span></span> :</p>
                    <ul>
                        <li>
                            <p>une donnée <span class="em">water</span> qui correspond à l'arrosage conseillé pour chaque plante;</p>
                        </li>
                        <li>
                            <p>et une donnée <span class="em">light</span> qui correspond à l'ensoleillement nécessaire.</p>
                        </li>
                    </ul>
                    <p>Commençons par la lumière : dans chaque item plante, on vient <span class="em">ajouter un composant <span class="html">CareScale</span> et on lui passe la prop value</span> :</p>
<pre><code>&lt;CareScale scalueValue={plant.light} /&gt;</code></pre>
                    <p>Les props sont récupérées dans les <span class="em">paramètres de la fonction qui définit notre composant</span>.</p>
                    <p>Pour <span class="html">CareScale</span>, on aura donc :</p>
<pre><code>function CareScale(props) {µ
    const scaleValue = props.scaleValue
    return &lt;div&gt;{scaleValue}☀️&lt;/div&gt;
}

export default CareScale</code></pre>
                    <p>Mais on avait dit qu'on voulait une échelle de 1 à 3, non ?</p>
                    <p>On va donc <span class="em">partir sur une liste</span>, qu'on peut manuellement.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>function CareScale(props) {
    const scaleValue = props.scaleValue

    const range = [1, 2, 3]

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt;
                scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;☀️&lt;/span&gt; : null
            )}
        </div>
    )
}</code></pre>
                    <p>Félicitations ! Vous venez d'utiliser les <span class="em">props</span> !</p>
                    <p>Les props sont donc des <span class="em">objets que l'on peut récupérer dans les paramètres de notre composant fonction</span>.</p>
                    <p>On va pousser la logique un peu plus loin afin de véritablement paramétrer notre composant.</p>
                    <h3>Créez des paramètres :</h3>
                    <p>Je vais commencer par <span class="em">préciser une <span class="html">prop</span> pour le type que j'appellerai <span class="html">careType</span> pour mon composant <span class="html">CareScale</span> et réutiliser ce composant</span> entre l'ensoleillement et l'arrosage :</p>
<pre><code>&lt;CareScale careType='water' scaleValue={plant.water} /&gt;
&lt;CareScale careType='light' scaleValue={plant.light} /&gt;</code></pre>
                    <p>Il faut maintenant que j'adapte <span class="html">CareScale</span> pour récupérer le <span class="html">careType</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>À partir de maintenant, je vais utiliser une syntaxe qui nous est permise depuis l'ES6 : la <span class="em">déstructuration</span>. Elle permet directement de déclarer une variable et de lui assigner la valeur d'une propriété d'un objet.</p>
                        <p>Ici on peut donc faire :</p>
<pre><code>const {scaleValue, careType} = props
// On évite de multiplier les déclarations qui sans cette syntaxe auraient été :
// const scaleValue = props.scaleValue et
// const careType = props.careType</code></pre>
                        <p>Cela nous permet de <span class="em">déclarer directement nos deux variables</span> <span class="html">scaleValue</span> et <span class="html">careType</span>, et de <span class="em">les assigner aux valeurs</span> passées en propos. On peut même directement l'écrire dans les paramètres :</p>
<pre><code>function CareScale({scaleValue, careType}) {</code></pre>
                    </div>
                    <p>On peut donc maintenant <span class="em">paramétrer notre composant <span class="html">CareScale</span> pour qu'il puisse gérer les données</span> d'arrosage et les données d'ensoleillement :</p>
<pre><code>function CareScale({ scaleValue, careType }) {
    const range = [1, 2, 3]
    
    const scaleType = careType === 'light' ? '☀️' : '💧'

    return (
        &lt;div&gt;
            {range.map((rangeElem) =&gt; scaleValue &gt;= rangeElem ? &lt;span key={rangeElem.toString()}&gt;{scaleType}&lt;/span&gt; : null
            )}
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Comme vous l'avez vu ici, nous avons utilisé <span class="em">deux syntaxes différentes pour nos props</span>. Pour <span class="html">scaleType</span>, nous lui avons assigné une <span class="html">string</span>, entre guillemets. En revanche, pour <span class="em">scaleValue</span>, nous lui avons attribué la valeur d'un objet, que nous avons passée entre accolades.</p>
                    <p>En pratique, une prop peut avoir n'importe quelle valeur possible en JavaScript, mais syntaxiquement, en JSX, on n'a en gros que deux possibilités :</p>
                    <ul>
                        <li>
                            <p>un littéral <span class="html">String</span>, matérialisé par des guillemets;</p>
                        </li>
                        <li>
                            <p>ou, pour toute le reste (booléen, number, expression JavaScript, etc.), des accolades <span class="html">{}</span>.</p>
                        </li>
                    </ul>
                    <h3>Faites descendre les données, des parents vers les enfants :</h3>
                    <p>Les props nous permettent de configurer nos composants. Elles répondent à la logique même de React selon laquelle les données descendent à travers notre arborescence de composants : il s'agit d'<span class="em">un flux de données unidirectionnel</span>.</p>
                    <figure>
                        <img src="../images/composants_parents_enfants_React.png" alt="">
                        <figcaption>Les composants parents partagent leurs données avec leurs enfants.</figcaption>
                    </figure>
                    <p>Comme vous pouvez vous en douter, un composant est le parent du composant défini dans le <span class="html">return()</span>.</p>
                    <p>Dans notre exemple, <span class="html">CareScale</span> est l'enfant, et <span class="html">ShoppingList</span> est le parent.</p>
                    <p>Pour les props, vous devez garder deux règles à l'esprit :</p>
                    <ul>
                        <li>
                            <p>Une prop est toujours <span class="em">passée par un composant parent à son enfant</span> : c'est le seul moyen normal de transmission.</p>
                        </li>
                        <li>
                            <p>Une prop est considérée <span class="em">en lecture seule</span> dans le composant qui la reçoit.</p>
                        </li>
                    </ul>
                    <h3>Découvrez la prop technique children :</h3>
                    <p>Il existe des props qui ont un comportement un peu particulier : nous les appelons les <span class="em">props techniques</span>.</p>
                    <p>La syntaxe de cette prop est particulière, puisqu'elle n'est pas fournie à l'aide d'un attribut, mais en <span class="em">imbriquant des composants</span> à l'intérieur du composant concerné.</p>
                    <p>Ce qui nous donne :</p>
<pre><code>&lt;Parent&gt;
    &lt;Enfant1 /&gt;
    &lt;Enfant2 /&gt;
&lt;/Parent&gt;</code></pre>
                    <p>Par exemple, si on <span class="em">utilise <span class="html">children</span> pour réécrire la Banner</span>, cela nous donnerait dans <span class="html">App.js</span> :</p>
<pre><code>&lt;Banner&gt;
    &lt;img src={logo} alt='La maison jungle' /&gt;
    &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
&lt;/Banner&gt;</code></pre>
                    <p>Ici, <span class="em">img</span> et <span class="em">h1</span> sont les noeuds enfants dans le DOM de <span class="html">Banner</span>.</p>
                    <p>Et on peut <span class="em">accéder à ces noeuds enfants de Banner dans ses paramètres</span>, un peu de la même manière qu'on récupérerait des props :</p>
<pre><code>function Banner({ children }) {
    return &lt;div className='lmj-banner'&gt;{children}&lt;/div&gt;
}</code></pre>
                    <p>Cette manière d'utiliser <span class="html">children</span> et particulièrement <span class="em">utile lorsqu'un composant ne connaît pas ses enfants à l'avance</span>, par exemple pour une barre de navigation (Sidebar) ou bien pour une modale.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les <span class="html">props</span> constituent un aspect clé de React. Mais, en les manipulant, vous verrez qu'il peut être très facile de faire des erreurs. Cela vient notamment de la flexibilité de JavaScript, qui fait du <a href="https://developer.mozilla.org/fr/docs/Glossaire/typage_dynamique" target="_blank">typage dynamique</a> (les types <span class="html">string</span>, <span class="html">int</span>, etc.). Pour vous donner un exemple d'erreur classique :</p>
                        <ul>
                            <li>
                                <p>Vous pouvez passer une prop value à un composant.</p>
                            </li>
                            <li>
                                <p>Vous utilisez une liste de valeurs, certaines valeurs sont des strings, d'autres des nombres.</p>
                            </li>
                            <li>
                                <p>Vous appliquez la méthode <span class="html">.toUpperCase()</span> à votre <span class="html">value</span> : <span class="em">boum</span> !</p>
                            </li>
                        </ul>
                        <p>Une erreur ! <span class="html">.toUpperCase()</span> n'existe pas sur un nombre.</p>
                        <p>Pour éviter ce genre d'erreur, je vous conseille d'être extrêmement rigoureux sur le type de props que vous passez à vos composants.</p>
                    </div>
                    <p>Pour cela, React a créé les <span class="em">PropTypes</span>, qui nous permettent de préciser dès le début le type d'une prop, si elle est requise, et de lui attribuer une valeur par défaut.</p>
                </article>
                <article>
                    <h2 id="maitrise_evenements_React">Maîtrisez les évenements en React :</h2>
                    <p>Si vous avez déjà manipulé du JavaScript, vous êtes sûrement déjà familier avec les événements. Bon, vous avez quand même droit à un petit rappel : un événement est une <span class="em">réaction</span> à une <span class="em">action</span> émise par l'utilisateur, comme le clic sur un bouton ou la saisie d'un texte dans un formulaire.</p>
                    <p>Bonne nouvelle pour vous : avec sa syntaxe pratique et concise, React facilite énormément la gestion des événements du DOM.</p>
                    <h3>Familiarisez-vous avec ka syntaxe :</h3>
                    <p>Quelques caractéristiques de la déclaration d'un événement en React :</p>
                    <ul>
                        <li>
                            <p>l'événement s'écrit dans une balise en <span class="em">camelCase</span>;</p>
                        </li>
                        <li>
                            <p>vous <span class="em">déclarez l'événement</span> à capter, et <span class="em">lui passez entre accolades la fonction</span> à appeler;</p>
                        </li>
                        <li>
                            <p>contrairement au JS, dans la quasi totalité des cas, <span class="em">vous n'avez pas besoin d'utiliser <span class="html">addEventListener</span></span>.</p>
                        </li>
                    </ul>
                    <p>Testons ça dès maintenant dans notre code. Dans <span class="html">components/PlantItem.js</span>, je vais <span class="em">déclarer une finction <span class="html">handleClick</span> qui vient faire un log</span> dans notre console :</p>
<pre><code>function handleClick() {
    console.log('Ceci est un clic')
}</code></pre>
                    <p>On <span class="em">ajoute maintenant <span class="html">onClick={handleClick}</span></span> dans la balise <span class="html">li</span> du composant <span class="html">PlantItem</span>. On a donc :</p>
<pre><code>&lt;li className='lmj-plant-item' onClick={handleClick}&gt;
    &lt;img className='img-plant-item-cover' src={cover} alt={`${name} cover`} /&gt;
    {name}
    &lt;div&gt;
        &lt;CareScale careType='water' scaleValue={water} /&gt;
        &lt;CareScale careType='light' scaleValue={light} /&gt;
    &lt;/div&gt;
&lt;/li&gt;</code></pre>
                    <p>J'ouvre la console et ça fonctionne comme prévu !</p>
                    <p>Je vais pousser cet exercice un peu plus loin : on va déclencher une alerte qui affiche le nom de la plante sur laquelle on a cliqué.</p>
                    <p>On <span class="em">passe donc <span class="html">plantName</span> en paramètre</span> de handleClick comme ici :</p>
<pre><code>function handleClick(plantName) {
    alert(`Vous voulez acheter 1 ${plantName} ? Très bon choix 🌱✨`)
}</code></pre>
                    <p>Mais si je clique, ça ne marche pas :</p>
                    <figure>
                        <img src="../images/plantName_React_1.png" alt="">
                        <figcaption>Aucune de nos plantes ne s'appelle 1 [object Object].</figcaption>
                    </figure>
                    <p>En effet, React passe par défaut un objet (que nous aborderons dans quelques minutes), mais ici, nous voulons lui spécifier notre propre argument.</p>
                    <p>Pour cela, c'est très simple : on <span class="em">déclare une fonction directement dans <span class="html">onClick</span></span> (les fonctions fléchées sont très pratiques pour ça). Cette fonction appellera handleClick en lui passant <span class="html">name</span> en paramètre. Donc on a :</p>
<pre><code>onClick={() =&gt; handleClick(name)}</code></pre>
                    <h3>Découvrez les événements synthétiques :</h3>
                    <p>Donc, je vous parlais de l'objet que React passe par défaut en paramètre aux fonctions indiquées en callback des événements. Voyons voir à quoi ça ressemble.</p>
                    <p>Si je <span class="em">récupère le paramètre dans handleClick</span> :</p>
<pre><code>function handleClick(e) {
    console.log('Cecu est mon event :', e)
}</code></pre>
                    <p>j'obtiens ça :</p>
                    <img src="../images/console_log_React_1.png" alt="">
                    <p>Il s'agit en fait d'un <span class="em">événement synthétique</span>. Pour faire bref, il s'agit de la même interface que pour les événements natifs du DOM, sauf qu'ils sont compatibles avec toues les navigateurs.</p>
                    <p>Pratique, n'est-ce pas ?</p>
                    <p>Vous pouvez utiliser les méthodes <span class="html">preventDefault</span> et <span class="html">stopPropagation</span> avec le paramètre dans la fonction passée à l'événement. Dans notre cas, vous auriez pu faire <span class="html">e.preventDefault()</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous voulez en savoir plus sur les événements synthétiques, vous trouverez <a href="https://fr.reactjs.org/docs/events.html" target="_blank">une liste de tous les événemebrs orus eb charge ici</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="creation_formulaires_React">Simplifiez votre création de formulaires avec React :</h2>
                    <p>En React, la gestion des formulaires est simplifiée : on a accès à la valeur très facilement, qu'il s'agisse d'un input checkbox, d'un textarea, ou encore d'un select avec <span class="html">onChange</span>.</p>
                    <p>Il existe deux grandes manières de gérer les formulaires : <span class="em">la manière contrôlée et la manière non contrôlée</span>. J'aborderai assez rapidement la manière non contrôlée, parce qu'elle nécessite moins d'implication de react, et que React encourage l'utilisation des formulaires contrôlés.</p>
                    <h3>Déléguez le contrôle : les formulaires non contrôlés :</h3>
                    <p>Je vous fais une petite démo d'un formulaire non contrôlé. Sur notre app; directement dans <span class="html">App.js</span>, je mets un composant <span class="html">QuestionForm</span> que je vais déclarer dans un fichier à part. Nous allons ajouter un champ pour une question.</p>
                    <p>Donc pour ça, je <span class="em">crée un form</span>, qui englobe mon input :</p>
<pre><code>&lt;form onSubmit={handleSubmit}&gt;
    &lt;input type='text' name='my_input' defaultValue='Tapez votre texte' /&gt;
    &lt;button type='submit'&gt;Entrer&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    <p>Et <span class="em">pour <span class="html">handleSubmit</span></span>, cela donne :</p>
<pre><code>function handleSubmit(e) {
    e.preventDefault()
    alert(e.target['my_input'].value)
}</code></pre>
                    <p>Vous voyez que React me permet de préciser une <span class="html">defaultValue</span> à mon champ input. Ici, j'appelle <span class="html">preventDefault</span>, sinon le <span class="html">submit</span> rafraîchirait la page.</p>
                    <p>Et j'ai bien mon alerte qui se déclenche.</p>
                    <p>Plutôt simple, n'est-ce pas ? Vous déléguez le travail à votre DOM. Effectivement, les formulaires non contrôlés nous permettent de <span class="em">ne pas avoir à gérer trop d'informations</span>. Mais cette approche est un peu moins "React", parce qu'elle ne permet pas de tout faire.</p>
                    <p>À la place, vous pouvez utiliser les composants contrôlés.</p>
                    <h3>Contrôlez vos formulaires :</h3>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, pour vous montrer l'utilisation des formulaires contrôlés, je vais avoir besoin d'une notions que nous aborderons prochainement : le state (état). Donc je vais essayer de vous faire un petit brief sans rentrer dans le détail.</p>
                    </div>
                    <p>Le <span class="em">state local</span> nous permet de <span class="html">garder des informations. Ces informations sont spécifiques à un composant et elles proviennent d'une iteraction</span> que l'utilisateur a eue avec le composant.</p>
                    <p>Donc je vais <span class="em">créer ma variable <span class="html">inputValue</span> et la fonction</span> qui va permettre de changer sa valeur dans le state local avec <span class="html">useState</span>.</p>
                    <p>Sachez juste que la ligne de code ci-dessous me permet de déclarer l'état initial pour <span class="html">inputValue</span> et la fonction correspondante pour la modifier, et de lui préciser la valeur par défaut "Posez votre question ici" :</p>
<pre><code>const [inputValue, setInputValue] = useState("Posez votre question ici")</code></pre>
                    <p>J'ai donc mon <span class="html">QuestionForm</span> comme ci-dessous :</p>
<pre><code>import { useState } from 'react'

function QuestionForm() {
    const [inputValue, setInputValue] = useState('Posez votre question ici')
    return (
        &lt;div&gt;
            &lt;textarea
                value={inputValue}
                onChange={(e) =&gt; setInputValue(e.target.value)}
            /&gt;
        &lt;/div&gt;
    )
}

export default QuestionForm</code></pre>
                    <p>Ici, je passe une fonction en callback à <span class="html">onChange</span> pour qu'elle sauvegarde dans mon state local la valeur de mon input. J'accède à la valeur tapée dans l'input avec <span class="html">e.targer.value</span>.</p>
                    <p><span class="html">inputValue</span> a maintenant accès au contenu de mon input à tout moment. Je peux donc <span class="em">créer un bouton qui déclenche une alerte</span> qui affiche le contenu de mon input, comme ici :</p>
<pre><code>&lt;div&gt;
    &lt;textarea
        value={inputValue}
        onChange={(e) =&gt; setInputValue(e.target.value)}
    /&gt;
    &lt;button onClick={() =&gt; alert(inputValue)}&gt;Alertez moi 🚨&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>Et ça marche bien !</p>
                    <h3>Comprenez les avantages des formulaires contrôlés :</h3>
                    <p>Eh bien, cela permet d'<span class="em">interagir directement avec la donnée renseignée par l'utilisateur</span>. Vous pouvez donc afficher un message d'erreur si la donnée n'est pas valide, ou bien la filtrer en interceptant une mauvaise valeur.</p>
                    <p>Si nous décidons qu'il n'est pas autorisé d'utiliser la lettre "f" (bon oui, c'est un peu bizarre), eh bien nous pouvons déclarer une variable :</p>
<pre><code>const isInputError = inputValue.includes('f')</code></pre>
                    <p>et afficher ou non un message d'erreur en fonction de ce booléen :</p>
<pre><code>{isInputError && (
    &lt;div&gt;🔥 Vous n'avez pas le droit d'utiliser la lettre "f" ici.&lt;/div&gt;
)}</code></pre>
                    <p>De la même manière, nous pouvons intercepter une mauvaise valeur entrée par l'utilisateur. Pour cela, il faut déclarer une fonction intermédiaire :</p>
<pre><code>function checkValue(value) {
    if (!value.includes('f')) {
        setInputValue(value)
    }
}</code></pre>
                    <p>et on aplique la modification dans notre fonction callback :</p>
<pre><code>onChange={(e) =&gt; checkValue(e.target.value)}</code></pre>
                    <p>Ici, vous aure be.au marteler votre touche 'f' autant de fois que vous voudrez, la valeur ne s'inscrira pas dans votre input.</p>
                    <p>Vous ne vous en rendez peut-être pas compte pour l'instant, mais ça vous laisse une très grande liberté quant aux validations que vous voulez créer; et en tant que développeur, c'est vraiment très puissant.</p>
                    <p>Quand utiliser le composant contrôlé et quand utiliser sa version non contrôlée ? Eh bien cela dépen des cas. À vous de voir selon vos contraintes. Quand vous avez un composant rapide à faire, qui n'intègre aucuene complexité, un input non contrôlé peut faire l'affaire. À l'inverse, si vous avez des vérifications à faire, il vaudra sûrement mieux passer par un composant contrôlé. Pour ma part, j'ai vu beaucoup plus de composants contrôlés dans les codebases que j'ai pu voir.</p>
                    <p>Sachez qu'il existe également des bibliothèqyes qui vous permettent de gérer les formulaires et leur validation aussi proprement que possible, par exemple <a href="https://react-hook-form.com/" target="_blank">le très bon outil <span class="html">react-hook-form</span></a>.</p>
                    <p>Et voilà, vous êtes maintenant équipé pour interagir avec vos utilisateurs grâce aux événements et aux formulaires.</p>
                </article>
                <article>
                    <h2 id="stateful_components">Découvrez les stateful components :</h2>
                    <p>Le state local est présent à l'intérieur d'un composant et <span class="em">garde sa valeur, même si l'application le re-render</span>. On peut alors dire qu'il <span class="em">stateful</span>.</p>
                    <p>Dans <span class="html">Cart.js</span>, nous allons uniquement <span class="em">permettre aux utilisateurs d'ajouter des monsteras dans leur panier</span>, supprimons donc tout le reste.</p>
                    <p>Commençons par <span class="em">importer <span class="html">useState</span></span> avec :</p>
<pre><code>import { useState } from 'react'</code></pre>
                    <p>Puis, on peut <span class="em">créer un state <span class="html">cart</span></span>. Avec <span class="html">useState</span>, nous devons déclarer en même temps une fonction pour mettre à jour ce state (<span class="html">updateCart</span>), et lui attribuer une valeur initiale, qui sera ici de 0 :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Je vais maintenant pouvoir <span class="em">ajouter un bouton dans mon panier qui permet d'ajouter un monstera</span> avec la fonction que nous venons de déclarer. Ce qui me donne dans <span class="html">Cart.js</span> :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)

    return (
        &lt;div className='lmj-cart'&gt;
            &lt;h2&gt;Panier&lt;/h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Maintenant, si on clique sur "Ajouter", le montant total est modifié en fonction du nombre d'éléments sauvegardés dans le state du panier. Lorsqu'un state est modifié, alors l'affichage du composant est rafraichit et la valeur affichée est actualisée, on dit que le composant est re-render.</p>
                    <p>Bienvenue dans la magie du state ! Notre composant Cart est maintenant devenu un <span class="em">stateful component</span>, grâce à <span class="html">useState</span>.</p>
                    <p>Concrètement, cela veut dire que le composant Cart peut être re-render autant de fois que nécessaire, mais la valeur du panier sera préservée.</p>
                </article>
                <article>
                    <h2 id="useState">Familiarisez-vous avec useState :</h2>
                    <p><span class="html">useState</span> est un hook qui permet d'ajouter le state local React à des composants fonctions.</p>
                    <p>Un hook est <span class="em">une fonction qui permet de "se brancher" (to hook up) sur des fonctionnalités React</span>. On peut d'ailleurs les importer directement depuis React. Après useState, nous verrons un autre hook : <span class="html">useEffect</span>. Il existe d'autres hooks.</p>
                    <p>Nous l'avons déjà utilisé, mais je vous le remets ici :</p>
<pre><code>const [cart, updateCart] = useState(0)</code></pre>
                    <p>Investiguons comment est construit notre state cart.</p>
                    <h3>Comprenez les crochets :</h3>
                    <p>Tout d'abord, les crochets <span class="html">[]</span>. Si cette syntaxe peut vous paraître un peu particulière, il s'agit en fait de la même pratique que nous avions vue précédemment : la déstructuration. Sauf qu'ici, ça s'appelle la <span class="em">décomposition</span> parce qu'il s'agit d'un <span class="em">tableau</span> et non d'un objet.</p>
                    <p><span class="html">useState</span> nous <span class="em">renvoie une paire de valeurs dans un tableau de 2 éléments</span>, que nous récupérons dans les variables <span class="em">cart</span> et <span class="em">updateCart</span> dans notre exemple. Le premier élément est la valeur actuelle, et le deuxième est une fonction qui permet de la modifier.</p>
                    <p>Sans la décomposition, nous aurions aussi pu faire :</p>
<pre><code>const cartState = useState(0)
const cart = cartState[0]
const updateCart = cartState[1]</code></pre>
                    <p>Dans un tableau qu'on décompose, nous pouvons librement nommer nos variables. J'aurais tout aussi bien pu faire :</p>
<pre><code>const [coucou, cavabien] = useState(0)</code></pre>
                    <h3>Initialisez votre state :</h3>
                    <p>Intéressons-nous maintenant au paramètre passé entre parenthèses à <span class="em">useState</span> : <span class="html">useState(0)</span>.</p>
                    <p>Comme je vous l'ai dit, il correspond à l'<span class="em">état initial de notre state</span>. Cet état initial peut être un nombre comme ici, une string, un booléen, un tableau ou encore un objet avec plusieurs propriétés.</p>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>Il est important de préciser une valeur initiale dans votre state. Sinon, elle sera <span class="em">undefined</span> par défaut, et ce n'est pas un comportement souhaitable : plus vous serez explicite, mieux votre application s'en portera !</p>
                    </div>
                    <h3>Créez plusieurs variables d'état :</h3>
                    <p>Nous allons encore améliorer notre panier. Cette fois-ci, je veux pouvoir <span class="em">choisir de l'afficher ou de le cacher</span>. Pour ça, nous allons utiliser une variable d'état dans notre composant Cart.</p>
                    <p>S'il y en a déjà une, comment en créer une autre ? Pas de panique. Il y a plusieurs moyens de faire. Mais le plus simple est d'utiliser plusieurs variables d'état.</p>
                    <p>Dans notre cas, il suffit de <span class="em">créer une variable <span class="html">isOpen</span> associée avec la fonction <span class="html">setIsOpen</span></span>, et de l'initialiser à false :</p>
<pre><code>const [isOpen, setIsOpen] = useState(false)</code></pre>
                    <p>Pour pouvoir interagir, on crée ensuite :</p>
                    <ul>
                        <li>
                            <p><span class="em">un bouton pour ouvrir</span> le panier qui sera le seul composant retourné par Cart si le panier est fermé;</p>
                        </li>
                        <li>
                            <p>et <span class="em">un bouton pour fermer</span> le panier.</p>
                        </li>
                    </ul>
                    <p>Cela nous donne le code suivant :</p>
<pre><code>function Cart() {
    const monsteraPrice = 8
    const [cart, updateCart] = useState(0)
    const [isOpen, setIsOpen] = useState(false)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button onClick={() =&gt; setIsOpen(false)}&gt;Fermer&lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;div&gt;
                Monstera : {monsteraPrice}€
                &lt;button onClick={() => updateCart(cart + 1)}&gt;
                    Ajouter
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
        &lt;/div&gt;
    ) : (
        &lt;button onClick={() =&gt; setIsOpen(true)}&gt;Ouvrir le Panier&lt;/button&gt;
    )
}

export default Cart</code></pre>
                    <p>En ajoutant un peu de style, j'ai donc :</p>
                    <figure>
                        <img src="../images/panier_lmj_React.jpg" alt="">
                        <figcaption>Le panier du site de la maison jungle</figcaption>
                    </figure>
                    <p>Vous voyez ? Pas de soucis à créer plusieurs variables d'état dans un même composant !</p>
                    <p>C'est bien beau, nous avons nos composants avec leur state local. Notre panier permet d'ajouter des monsteras, et le total du panier se calcule en fonction.</p>
                    <p>Mais comment faire pour <span class="em">changer le comportement d'un composant en fonction du state d'un autre composant</span> ? Par exemple, si je veux enfin ajouter un lien entre mon <span class="em">Cart</span> et mon composant <span class="em">ShoppingList</span>. Je peux créer un bouton "Ajouter au panier" dans chaque <span class="em">PlantItem</span>... Mais comment faire pour venir compléter mon panier en fonction ?</p>
                </article>
                <article>
                    <h2 id="remonter_etat_maj_composants_enfants">Faites remonter l'état et mettez-le à jour depuis vos composants enfants :</h2>
                    <p>Comme son nom l'indique, un state local... est local. Ni les parents, ni les enfants ne peuvent manipuler le state local d'un composant (ils n'en ont pas la possibilité technique).</p>
                    <p>Pour partager un élément d'état entre plusieurs composants, il faudra <span class="em">faire remonter ces données</span> vers le state local du <span class="em">plus proche composant qui est un parent commun</span>, et y garder le state. À partir de là, il sera possible de :</p>
                    <ul>
                        <li>
                            <p>Faire <span class="em">redescendre</span> ces infos avec des props jusqu'aux composants qui en ont besoin.</p>
                        </li>
                        <li>
                            <p>Faire <span class="em">"remonter" les demandes d'update</span> toujours dans les props. Pour cela, on peut utiliser la fonction de mise à jour du state récupérée dans useState, en la passant en props aux composants qui en ont besoin.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/remonter_maj_parents_props_React.png" alt="">
                        <figcaption>Remonter les mises à jour aux parents dans les props</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Vous vous demandez peut-être quelles sont les bonnes pratiques : où mettre le state ? Dans le composant parent, ou le composant enfant ? Eh bien, dans la pratique... ça dépend totalement. Il est considéré comme plus propre de garder la logique au maximum dans les composants parents, et que les enfants ne servent qu'à afficher les éléments en props. Mais dans de nombreux cas, il est bien mieux de garder le state dans le composant enfant. Vous apprendrez à le voir avec le temps et l'expérience.</p>
                    </div>
                    <p>Attaquons-nous donc à notre exemple.</p>
                    <p>Je commence à <span class="em">faire remonter <span class="html">cart</span> dans <span class="html">App.js</span></span> :</p>
<pre><code>function App() {
    const [cart, updateCart]  useState(0)

    return (
        &lt;div&gt;
            &lt;Banner&gt;
                &lt;img src={logo} alt='La maison jungle' className='lmj-logo' /&gt;
                &lt;h1 className='lmj-title'&gt;La maison jungle&lt;/h1&gt;
            &lt;/Banner&gt;
            &lt;div className='lmj-layout-inner'&gt;
                &lt;Cart cart={cart} updateCart={updateCart} /&gt;
                &lt;ShoppingList cart={cart} updateCart={updateCart} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}

export default App</code></pre>
                    <p>Et toujours dans <span class="html">App.js</span> dans le JSX, je <span class="em">passe <span class="html">cart</span> ainsi que <span class="html">updateCart</span> en props</span> :</p>
<pre><code>&lt;Cart cart={cart} updateCart={updateCart} /&gt;</code></pre>
                    <p>... <span class="em">que je récupère dans <span class="html">Cart.js</span></span>. Vous vous souvenez de la déstructuration ? Ça nous permet de récupérer notre prop en une ligne.</p>
                    <p>J'en profite pour supprimer mon bouton "Ajouter" dans <span class="html">Cart.js</span>.</p>
                    <p>On a donc un panier un peu vide :</p>
<pre><code>function Cart({ cart, updateCart }) {
    const monsteraPrice = 8
    const [isOpen, setIsOpen] = useState(true)

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(false)}
            &gt;
                Fermer
            &lt;/button&gt;
            &lt;h2&gt;Panier&lt;h2&gt;
            &lt;h3&gt;Total : {monsteraPrice * cart}€&lt;/h3&gt;
            &lt;button onClick={() =&gt;updateCart(0)}&gt;Vider le panier&lt;/button&gt;
        &lt;/div&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Du côté de <span class="html">ShoppingList</span>, je <span class="em">lui passe <span class="html">updateCart</span></span>. Je <span class="em">le récupère ensuite dans <span class="html">ShoppingList.js</span></span>.</p>
                    <p>Je <span class="em">change ensuite ma liste de plantes</span> pour avoir (toujours dans <span class="html">ShoppingList.js</span>) :</p>
<pre><code>function ShoppingList({ cart, updateCart }) {
    // Petite précision : categories permet de récupérer toutes les catégories uniques de plantes.

    const categories = plantList.renduce(
        (acc, elem) =&gt;
            acc.includes(elem.category) ? acc : acc.concat(elem.category),
            []
    )

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; updateCart(cart + 1)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Et voilà ! Maintenant, vous pouvez updater votre panier directement en cliquant sur un bouton lié à chaque plante.</p>
                    <p>Vous voyez, ce n'est pas si compliqué, il a suffit de :</p>
                    <ul>
                        <li>
                            <p>faire remonter notre state;</p>
                        </li>
                        <li>
                            <p>faire descendre le contenu de notre state et la fonction pour l'updater;</p>
                        </li>
                        <li>
                            <p>déclencher la mise à jour de notre state avec une interaction utilisateur (ici le clic sur le bouton).</p>
                        </li>
                    </ul>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous sommes sur une petite application : il n'y a qu'une seule page et nous partageons le state directement entre parents et enfants. Mais ça peut vite devenir le bazar pour une plus grosse application. C'est pourquoi la notion de state management va beaucoup plus loin. Il existe des outils dédiés au State Management tels que Flux, Redux ou des solutions natives comme React Context.</p>
                    </div>
                    <p>Nous avons vu comment partager des éléments du state entre plusieurs composants. Nous allons maintenant adapter notre application pour que le panier se comporte de manière un peu plus réaliste.</p>
                    <p>L'idée ici est que <span class="em">notre state stocke quels types</span> de plantes ont été ajoutés, <span class="em">en quelle quantité</span>, et <span class="em">de mettre à jour le montnat total</span> en fonction du prix.</p>
                    <p>Première étape : ajouter le prix à chaque plante dans le fichier <span class="em">plantList.js</span>.</p>
                    <p>Dans le fichier <span class="em">App.js</span>, on modifie le state <span class="em">cart</span> pour que ce soit un tableau comme ceci :</p>
<pre><code>const [cart, updateCart] = useState([])</code></pre>
                    <p>Troisième étape : on modifie le fichier <span class="em">Cart.js</span> pour itérer sur les <span class="em">cart</span> comme ceci :</p>
<pre><code>import { useState } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )
    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        &lt;h2&gt;Panier&lt;/h2&gt;
        {cart.map(({ name, price, amount}, index) =&gt; (
            &lt;div key={`${name}-${index}`}&gt;
                {name} {price}€ x {amount}
            &lt;/div&gt;
        ))}

        &lt;h3&gt;Total : {total}€&lt;/h3&gt;
        &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Enfin, dernière étape : on fait une modification dans le fichier <span class="em">ShoppingList.js</span> pour ajouter la fonction <span class="html">addToCart(...)</span> comme ci-dessous :</p>
<pre><code>import '../styles/ShoppingList.css'

function ShoppingList({ cart, updateCart }) {
    
    const categories = plantList.renduce(
        (acc, plant) =&gt;
            acc.includes(plant.category) ? acc : acc.concat(plant.category),
            []
    )

    function addToCart(name, price) {
        const currentPlantAdded = cart.find((plant) =&gt; plant.name === name)
        if (currentPlantAdded) {
            const cartFilteredCurrentPlant = cart.filter(
                (plant) =&gt; plant.name !== name
            )
            updateCart([
                ...cartFilteredCurrentPlant = cart.filter(
                    (plant) =&gt; plant.name !== name
                )
                updateCart([
                    ...cartFilteredCurrentPlant,
                    { name, price, amount: currentPlantAdded.amount + 1 }
                ])
            ])
        } else {
            updateCart([...cart, { name, price, amount: 1 }])
        }
    }

    return (
        &lt;div className='lmj-shopping-list'&gt;
            &lt;ul&gt;
                {categories.amp((cat) =&gt; (
                    &lt;li key={cat}&gt;{cat}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            &lt;ul class='lmj-plant-list'&gt;
                {plantList.map(({ id, cover, name, water, light }) =&gt; (
                    &lt;div key={id}&gt;
                        &lt;PlantItem cover={cover} name={name} water={water} light={light} /&gt;
                        &lt;button onClick={() =&gt; addToCart(name, price)}&gt;Ajouter&lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

export default ShoppingList</code></pre>
                    <p>Notre panier fait maintenant une liste des articles sélectionnés, et met à jour le total en fonction des plantes sélectionnées et de leur prix.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Est-ce que vous avez remarqué que lorsqu'on change le state, on crée un nouvel objet avec le spread operator ? C'est normal : le state est immutable, c'est-à-dire qu'il ne faut pas le modifier directement.</p>
                    </div>
                </article>
                <article>
                    <h2 id="useEffect">Déclenchez des effets avec useEffect :</h2>
                    <p>Est-ce que je vous ai déjà parlé du render (rendu) d'une application React ?</p>
                    <p>Dès qu'une modification intervient dans une prop ou le state, le composant concerné et ses enfants sont re-render.</p>
                    <p>Mais comment faire si on on veut effectuer une action qui ne fait pas partie du return ? Qui intervient après que React a mis à jour le DOM ? Par exemple, si vous voulez déclencher une alerte à chaque fois que votre panier est mis à jour ? Ou bien même pour sauvegarder ce panier à chaque mise à jour ?</p>
                    <p>Eh bien, ces types d'actions s'appellent des effets de bord, et pour cela, nous avons <span class="html">useEffect</span>. Ils nous permettent d'effectuer une action à un moment donné du cycle de vie de nos composants.</p>
                    <p>Disons que je veux <span class="em">créer une alert lorsque j'ajoute une plante à mon panier</span>, et que cette alerte <span class="em">affiche le montant total du panier</span>.</p>
                    <p>Pour ça, une petite ligne de code suffit dans <span class="em">Cart.js</span> :</p>
<pre><code>alert(`J'aurai ${total}€ à payer`)</code></pre>
                    <p>On la met donc directement dans notre composant, avant le <span class="em">return</span>. Mais, quand je clique, ça bloque mon code et ma valeur ne s'affiche qu'une fois que j'ai cliqué sur "OK" !</p>
                    <p>À la place, on va utiliser <span class="html">useEffect</span>.</p>
                    <p><span class="em">Importez-le</span> comme nous l'avons fait avec <span class="html">useState</span> dans <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'</code></pre>
                    <p>et <span class="em">utilisez ce snippet à la place</span> (toujours dans <span class="em">Cart.js</span>) :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
})</code></pre>
                    <p>Ce qui nous donne pour <span class="em">Cart.js</span> :</p>
<pre><code>import { useState, useEffect } from 'react'
import '../styles/Cart.css'

function Cart({ cart, updateCart }) {
    const [isOpen, setIsOpen] = useState(true)
    const total = cart.reduce(
        (acc, plantType) =&gt; acc + plantType.amount * plantType.price,
        0
    )

    useEffect(() =&gt; {
        alert(`J'aurai ${total}€ à payer`)
    })

    return isOpen ? (
        &lt;div className='lmj-cart'&gt;
        &lt;button
            className='lmj-cart-toggle-button'
            onClick={() =&gt; setIsOpen(false)}
        &gt;
            Fermer
        &lt;/button&gt;
        {cart.length &gt; 0 ? (
            &lt;h2&gt;Panier&lt;/h2&gt;
            {cart.map(({ name, price, amount}, index) =&gt; (
                &lt;div key={`${name}-${index}`}&gt;
                    {name} {price}€ x {amount}
                &lt;/div&gt;
            ))}

            &lt;h3&gt;Total : {total}€&lt;/h3&gt;
            &lt;button onClick={() =&gt; updateCart([])}&gt;Vider le panier&lt;/button&gt;            
        ) : (
            &lt;div&gt;Votre panier est vide&lt;/div&gt;
        )}
    ) : (
        &lt;div className='lmj-cart-closed'&gt;
            &lt;button
                className='lmj-cart-toggle-button'
                onClick={() =&gt; setIsOpen(true)}
            &gt;
                Ouvrir le panier
            &lt;/button&gt;
        &lt;/div&gt;
    )
}

export default Cart</code></pre>
                    <p>Et voilà ! Tout se passe comme espéré, pour la simple et bonne raison que <span class="html">useEffect</span> nous permet d'<span class="em">effectuer notre effet une fois le rendu du composant terminé</span>. Et comme <span class="html">useEffect</span> est directement dans notre composant, nous avons directement accès à notre state, à nos variables, nos props, magique n'est-ce pas ?</p>
                    <p>Quand je ferme mon, mon alerte se déclenche aussi ! Eh bien c'est normal : je vous ai dit que <span class="html">useEffect</span> se déclenche après le rendu. Eh bien il se déclenche après <span class="em">CHAQUE</span> rendu du composant. Sauf si vous...</p>
                    <h3>Précisez quand déclencher une effect avec le tableau de dépendances :</h3>
                    <p>Pour décider précisément quand on veut déclencher un effet, on peut utoliser le tableau de dépendances. Il correspond au deuxième paramètre passé à <span class="html">useEffect</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Petit rappel : le premier paramètre passé à useEffect est une fonction.</p>
                    </div>
                    <p>Cette fonction correspond à l'<span class="em">effet à exécuter</span>. Ici, il s'agit de :</p>
<pre><code>() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}</code></pre>
                    <p>Le deuxième paramètre de <span class="html">useEffect</span> accepte <span class="em">un tableau noté entre crochets</span> : il s'agit du tableau de dépendances.</p>
                    <p>Dans notrre cas, si je veux que l'<span class="em">alerte ne s'affiche que lorsque le total de mon panier change</span>, il me suffit de faire :</p>
<pre><code>useEffect(() =&gt; {
    alert(`J'aurai ${total}€ à payer`)
}, [total])</code></pre>
                    <p>Vous pouvez mettre n'imprte quelle variable ici. Si vous voulez afficher l'alerte quand le total change OU quand une nouvelle catégorie est sélectionnée, vous pourriez tout à fait :</p>
                    <ul>
                        <li>
                            <p>récupérer la catégorie sélectionnée (en faisant remonter <span class="html">activeCategory</span> et <span class="html">setActiveCategory</span> et en les passant en props);</p>
                        </li>
                        <li>
                            <p>puis mettre <span class="html">[total, activeCategory]</span> dans votre tableau de dépendances.</p>
                        </li>
                    </ul>
                    <p>L'alerte s'affiche bien quand la catégorie change ou bien quand le total change.</p>
                    <p>Est-ce que l'effet est lancé au tout premier render de mon composant ? Oui, l'alerte s'affiche.</p>
                    <p>Comment faire pour exécuter un effet uniquement après le premier render de mon composant ? Par exemple, si je veux récupérer des données sur une API ? Eh bien, dans ce cas, il faut <span class="em">renseigner un tableau de dépendances vide</span> :</p>
<pre><code>useEffect(() =&gt; {
    alert('Bienvenue dans La maison jungle')
}, [])</code></pre>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>À partir du moment où vous utilisez le tableau de dépendances, faites attention à ne pas ouvlier des dépendances, ou bien à ne pas en laisser qui n'ont plus rien à y faire, pour éviter d'exécuter à des moments inopportuns.</p>
                    </div>
                    <h3>Modifiez le titre de votre onglet :</h3>
                    <p>Bon, moi je commence à en avoir un peu marre de toutes ces alertes. J'ai plutôt envie d'utiliser <span class="html">useEffect</span> pour <span class="em">mettre à jour le titre de l'onglet de mon navigateur</span>.</p>
                    <img src="../images/titre_onglet_React_1.png" alt="">
                    <p>Vous voyez de quoi je parle ?</p>
                    <p>On va donc <span class="em">utiliser <span class="html">document.title</span></span> toujours dans <span class="em">Cart.js</span>, comme ici :</p>
<pre><code>useEffect(() =&gt; {
    document.title = `LMJ : ${total}€ d'achats`
}, [total])</code></pre>
                    <p>Et voilà ! Le litre de notre onglet change en fonction du total de notre panier !</p>
                    <figure>
                        <img src="../images/titre_onglet_React_2.png" alt="">
                        <figcaption>useEffect modifie le titre de notre onglet pour la maison jungle.</figcaption>
                    </figure>
                </article>
                <article>
                    <h2 id="regles_useEffect">Maîtrisez les règles de useEffect :</h2>
                    <h3>Intégrez les différentes étapes de useEffect :</h3>
                    <p>Repassons sur ce qu'on vient de voir de useEffect :</p>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche à chaque rendu`)
})</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche au premier rendu`)
}, [])</code></pre>
<pre><code>useEffect(() =&gt; {
    console.log(`Cette alerte s'affiche la première fois et quand mon panier est mis à jour`)
}, [cart])</code></pre>
                    <p>Il est pssoble d'effectier une action quand React démonte le composant en le retirant du DOM. Dans notre <span class="em">App.js</span>, on rajoute le state :</p>
<pre><code>const [isFooterShown, updateIsFooterShown] = useState(true)

{isFooterShown && &lt;Footer cart={cart} /&gt;}</code></pre>
                    <p>Ensuite, dans notre <span class="em">Footer.js</span>, on utilise le <span class="html">useEffect</span> suivant :</p>
<pre><code>useEffect(() =&gt; {
    return () =&gt;
        console.log(`Cette alerte s'affiche quand Footer est retiré du DOM`)
})</code></pre>
                    <p>Cela nous permet d'effectuer un "nettoyage" de notre effet. En effet, il est indispensable de nettoyer certains effets au <span class="em">unmount</span> (démontage) d'un composant pour éviter les fuites de mémoire, typiquement si on utilise <span class="html">setInterval</span>. Nous n'aurons pas besoin de tels effets pour le moment.</p>
                    <h3>Intégrez quelques règles :</h3>
                    <p>Comme je vous l'ai expliqué précédemment, <span class="html">useEffect</span> est un <span class="em">hook</span>, une fonction qui permet de "se brancher" sur la fonctionnalité des effets de React. Mais quelques règles s'appliquent au hook <span class="html">useEffect</span> :</p>
                    <ul>
                        <li>
                            <p>Appelez toujours <span class="html">useEffect</span> à la <span class="em">racine de votre composant</span>. Vous ne pouvez pas l'appeler à l'intérieur de boucles, de code conditionnel ou de fonctions imbriquées. Ainsi, vous vous assurez d'éviter des erreurs involontaires.</p>
                        </li>
                        <li>
                            <p>Comme pour <span class="html">useState</span>, <span class="html">useEffect</span> est uniquement accessible dans un <span class="em">composant fonction React</span>. Donc ce n'est pas possible de l'utiliser dans un composant classe, ou dans une simple fonction JavaScript.</p>
                        </li>
                    </ul>
                    <p>Par ailleurs, je vous conseille de séparer les différentes actions effectuées dans différents useEffect. Cela est plutôt une bonne pratique qu'une règle.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Les hooks sont assez récents. Les développeurs React y ont accès depuis début 2019. Avant, il n'était pas possible d'accéder au state ni aux effets depuis des composants fonctions. Si on voulait utiliser un effet de bord ou l'état local; il fallait forcément passer par un <span class="em">class component</span>. Vous pouvez vous estimer heureux d'avoir accès aux hooks dès le début de votre apprentissage de React, car ils représentent plusieurs avanatages pour les développeurs et développeuses :</p>
                        <ul>
                            <li>
                                <p>ils nécessitent d'écire moins de code;</p>
                            </li>
                            <li>
                                <p>ils sont donc plus faciles à tester;</p>
                            </li>
                            <li>
                                <p>mais également plus lisibles.</p>
                            </li>
                        </ul>
                    </div>
                </article>
                <article>
                    <h2 id="creation_application_React_complete">Créez une application React complète :</h2>
                    <h3>Installez votre app avec Create React App :</h3>
                    <p>Pour initialiser notre application, nous allons utiliser Create React App (CRA).</p>
                    <p>Dans votre terminal, placez-vous dans le dossier où vous souhaitez créer votre projet et faites la commande suivante :</p>
<pre><code>npx create-react-app shiny-agency</code></pre>
                    <h3>Architecturez votre projet par modules :</h3>
                    <p>Maintenant que nous avons la base de notre projet, nous allons pouvoir nous décider sur son architure.</p>
                    <p>Pas de panique ! Ici, je ne vais pas vous parler de patterns complexes. L'idée est juste de suivre des règles logiques et suffisamment claires pour que vous sachiez où placer les fichiers que vous créez, et où retrouver ceux dont vous avez besoin dans votre codebase. D'ailleurs, dans la documentation React <a href="https://fr.reactjs.org/docs/faq-structure.html" target="_blank">sur la structure de fichiers</a>, React laisse la liberté aux développeurs quant à la structure de leur projet.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Lorsque vous utilisez des frameworks tels que <a href="https://nextjs.org/" target="_blank">Next</a> ou <a href="https://www.gatsbyjs.com/" target="_blank">Gatsby</a> une structure de fichiers toute faite vous sera déjà proposée. je vous conseille d'y jeter un oeil si vous avez l'occassion !</p>
                    </div>
                    <p>Précédemment, nous avions organisé le code de sorte à regrouper les fichiers par type : chaque fiche correspondait à un composant situé dans le dossier <span class="html">/components</span>. Les fichiers CSS, quant à eux, se trouvaient dans le dossier <span class="html">/style</span>, etc.</p>
                    <p>Ici, nous allons organiser nos fichiers en suivant la même logique, sauf qu'il faudra ajouter un dossier pour les "pages", qui regroupera les composants vers lesquels chacune de nos routes renverra (pas de panique si vous ne savez pas ce qu'est une route).</p>
                    <p><span class="em">Commençons</span> donc par créer un dossier <span class="html">/components</span> et un dossier <span class="html">pages</span> dans <span class="html">src</span>. Dans <span class="html">/pages</span>, on créé un dossier <span class="html">Home</span> et l'on y insère <span class="html">App.js</span>, qu'on renomme en <span class="html">index.jsx</span>. On peut ensuite supprimer tous les fichiers que nous n'utiliserons pas.</p>
                    <p>Ce qui nous donne...</p>
<pre><code>├── README.md
├── node_modules
...
├── package.json
├── public
...
├── src
│   ├── index.js
│   ├── components
│   └── pages
│       └── Home
│            └── index.jsx 
└── yarn.lock</code></pre>
                    <p>Ici, pas d'obligation d'utiliser l'extension <span class="html">.jsx</span>. Votre fichier React fonctionnera très bien aussi avec une extension <span class="html">.js</span>, mais puisqu'on peut l'utiliser, autant être explicite, n'est-ce pas ? Ainsi, vous voyez en un coup d'oeil quand votre fichier du React, et quand il n'en contient pas.</p>
                    <p>Ce qui est important pour nous est de pouvoir retrouver rapidement nos fichiers. Pour les architectures, il n'existe pas de solution parfaite à utiliser dans tous les cas. Nous devons donc essayer de trouver une organisation qui convienne. Ici, nous aurons relativement peu de fichiers, donc une structure par type devrait bien fonctionner.</p>
                    <p>On n'oublie pas de <span class="em">mettre à jour les paths des imports</span>, par exemple dans <span class="html">index.js</span> à la racine de src :</p>
<pre><code>import Home from './pages/Home/';</code></pre>
                    <p>Les approches sont multiples. Lorsque vous travaillez sur une application complexe, avec plusieurs grosses fonctionnalités, vous pouvez envisager un découpage selon les <span class="em">fonctionnalités</span>, par exemple. Vous trouverez un petit exemple de ce type d'organisation dans <a href="https://fr.reactjs.org/docs/faq-structure.html#grouping-by-features-or-routes" target="_blank">la documentation React</a>.</p>
                    <p>Un autre type d'organisation qui fonctionne bien ces dernières années est la création et l'organisation des composants selon les principes de l'<span class="em">atom design</span>, qui facilite la collaboration avec les designers. mais dans notre cas, l'application n'a pas vocation à être très grande, et l'utilisation d'une telle structure pourrait paraître superflue. C'est pourquoi nous avons choisi d'organiser le projet de ce cours par type de fichier, afin de s'approcher au maximum de ce qui aurait été fait en entreprise.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Dans notre codebase, nous allons organiser nos fichiers de sorte à avoir <span class="html">/NomDuComposant/index.jsx</span>. Cette pproche présente des avantages (notamment de ne pas avoir à nous répéter lorsqu'on importe nos fichiers), mais peut aussi paraître un peu désorganisée dans tous vos onglets d'IDE. Comme pour tout en code, il existe plusieurs manières de faire; à vous de voir ce qui vous convient, et de vous adapter lorsque vous travaillez sur une codebase qui est un peu différente. Si ce sujet vous intéresse, vous pourrez en apprendre davantage sur l'organisation et le nommage des fichiers <a href="https://bradfrost.com/blog/post/this-or-that-component-names-index-js-or-component-js/" target="_blank">dans cet article (en anglais)</a>.</p>
                    </div>
                    <p>Et voilà pour notre architecture ! Penchons-nous maintenant sur quelques outils qui nous permettent d'écrire du code plus proprement et d'éviter des erreurs communes.</p>
                    <h3>Exploitez les outils ESLint et Prettier :</h3>
                    <p>Pour ce qui est des erreurs de code, ou tout simpelment de la mise en forme, vous le savez sûremnt déjà, JavaScript est très <span class="em">souple</span> : pas de compilation stricte qui vous signale vos erreurs. Heureusement, il existe des outils qui permettent d"crire du code plus propre !</p>
                    <p>Vous vous posez la question suivante : <q>Écrire du code plus proprement ? Pourquoi prendre du temps à configurer des outils, alors que je m'en sors très bien comme ça ?</q> Eh bien, vous vous en sortez bien actuellement, sur une codebase plutôt petite et en travaillant seul. Mais imaginez que vous travaillez dans une équipe, dans laquelle chacun a son <span class="em">propre style de code</span> (mettre des points-virgules ou non, les règles d'indentation, etc.). Croyez-moi, ce n'est vraiment pas efficace.</p>
                    <p>Dans notre cas, nous allons nous intéresser à <span class="html">ESLint</span>, qui va vous signaler des erreurs dans le code (aussi bien des erreurs de style que des erreurs basiques de code qui peuvent conduire à des bugs), et <span class="html">Prettier</span>, qui va le formater.</p>
                    <h4>Sécurisez votre code avec ESLint et son extension :</h4>
                    <p>Commençons donc par ESLint.</p>
                    <p>Si vous regardez votre <span class="html">package.json</span>, vous verrez qu'ESLint fait déjà partie des outils préconfigurés par Create React App. Cet outil permet de vous signaler des erreurs de code - si vous utilisez une variable qui n'a jamais été déclarée, par exemple.</p>
                    <p>Testons dès maintenant. Dans <span class="html">Home/index.jsx</span>, je rajoute une ligne de code en faisant un console.log d'une variable non déclarée avant le <span class="html">return</span> :</p>
<pre><code>console.log(ceciEstUneErreur)</code></pre>
                    <p>Rien de spécial ne s'affiche. Pourtant, la variable n'est pas déclarée, donc c'est bien une erreur.</p>
                    <p>... Mais si vous n'avez pas encore installé l'extension ESLint dans votre éditeur de code (IDE), rien ne se passe.</p>
                    <p>Installons donc l'extension. Pour ma part, j'utilise VS Code qui me permet d'installer une extension directement dans l'onglet "Extensions" (cela dépend de l'IDE que vous utilisez). Une fois l'extension installée, votre éditeur de code devrait souligne votre erreur, comme ici.</p>
                    <figure>
                        <img src="../images/ESLint_React.png" alt="">
                        <figcaption>La voilà notre erreur !</figcaption>
                    </figure>
                    <p>Et voilà, la configuration est prête. On peut configurer manuellement ESLint en créant le fichier <span class="html">.eslintrc</span> avec le contenu suivant :</p>
<pre><code>{
    "extends": ["react-app"],
    "rules": {
        "no-console": "error"
    }
}</code></pre>
                    <p>On peut également utiliser la configuration ESLint de Airbnb qui peut être installé via <span class="html">npx</span>.</p>
                    <h4>Formatez votre code avec Prettier :</h4>
                    <p>Alors qu'ESLint vous permet de relever des erreurs de syntaxe, Prettier est la référence pour formater votre code. Contrairement à ESLint, Prettier n'est pas installé de base avec Create-React-App.</p>
                    <p>Pour vous donner une idée de la puissance de cet outil, regardez un peu ce GIF :</p>
                    <figure>
                        <img src="../images/Prettier_React.gif" alt="">
                        <figcaption>Bien pratique de tout formater en un clic, n'est-ce pas ?</figcaption>
                    </figure>
                    <p>Pas mal, n'est-ce pas ? Alors, lançons-nous dans la config ! Pour commencer, vous pouvez installer la library (bibliothèque) dans votre terminal avec <span class="html">yarn add -D prettier</span>.</p>
                    <p>À partir de là, l'outil est installé, mais nous devons le lancer manuellement - alors que nous voulons que Prettier fasse tout à notre place sans même avoir à y penser ! La manière la plus simple est d'installer l'extension de Prettier directement dans les extensions de votre IDE.</p>
                    <p>Pour ma part, dans VSCode, j'installe l'extension.</p>
                    <figure>
                        <img src="../images/extension_Prettier_VSCode.png" alt="">
                        <figcaption>L'extension Prettier dans VSCode</figcaption>
                    </figure>
                    <p>Il vous suffit d'aller dans les paramètres de votre IDE (<span class="html">Code</span> &gt; <span class="html">Preferences</span> &gt; <span class="html">Settings</span> dans VSCode pour Windows) pour activer la commande <span class="html">formatOnSave</span>. Elle permettra de formater le fichier à chaque fois que vous sauvegardez.</p>
                    <p>Vous pouvez également aller dans la barre de recherche de votre IDE, taper "format" et activer <spab class="html">formatOnSave</spab> :</p>
                    <figure>
                        <img src="../images/formatOnSave.png" alt="">
                        <figcaption>Le parametrage à activer dans VSCode pour formater en sauvegardant</figcaption>
                    </figure>
                    <p>Mais attendez, on n'a pas encore fini ! Nous allons aussi activer l'option qui permet d'éviter de modifier tous les fichiers à tort et à travers.</p>
                    <p>Tapez <span class="html">require config</span> ey descendez sur le paramètre correspondant à Prettier. Activez le paramètre comme ci-dessous :</p>
                    <figure>
                        <img src="../images/require_config.png" alt="">
                        <figcaption>Activez cette option dans vos paramètres pour formater uniquement les fichiers qui ont une config Prettier.</figcaption>
                    </figure>
                    <p>Cela permet de préciser à VSCode de formater le fichier uniquement quand une configuration est présente dans le projet pour Prettier.</p>
                    <p>Donc à nous d'en créer une !</p>
                    <p>À la racine de votre projet, créez un fichier <span class="html">.prettierrc</span> dans lequel vous allez pouvoir préciser quelques règles. Vous trouverez l'ensemble de ces règles dans <a href="https://prettier.io/docs/en/options.html" target="_blank">la documentation de Prettier</a>. typiquement, si vous voulez supprimer tous les points-virgules, vous faites :</p>
<pre><code>{
    "semi": false
}</code></pre>
                    <p>Et voilà, si vous retournez dans votre fichier <span class="html">Home/index.jsx</span>, vous aurez bien du code sans les points-virgules !</p>
                    <p>Félicitations ! Vous venez de configurer avec succès ESLint et Prettier avec leurs extensions, vous n'aurez plus à vous soucier du formatage de votre code ou bien de faire des erreurs d'inattention !</p>
                </article>
                <article>
                    <h2 id="SPA">Transformez votre application en Single Page Application avec React Router :</h2>
                    <h3>Comprenez le principe de SPA :</h3>
                    <p>Prenons notre machine à voyager dans le temps et retournons aux débuts du Web.</p>
                    <p>À cette époque, l'immense majorité des sites consistaient en un groupe de pages, envoyées par le serveur, qui s'affichaient en fonction de la navigation. Pour chaque interaction, telle que l'envoi d'un formulaire, la page entière devait être rechargée.</p>
                    <p>Mais au début des abbées 2000, le concept de Single Page Application (SPA) commence à émerger. Les idées principales derrière ce concept sont les suivantes :</p>
                    <ul>
                        <li>
                            <p>les utilisateurs ne chargent une page Web qu'une seule fois (le fameux <span class="html">index.html</span>).</p>
                        </li>
                        <li>
                            <p>Au lieu de récupérer toute la page avec une page avec une requête HTTP, on les récupère de manière distincte, petite partie par petite partie, ce qui permet à l'utilusateur d'interagir de manière beaucoup plus dynamique.</p>
                        </li>
                        <li>
                            <p>L'utilisateur peut naviguer entre plusieurs pages et JavaScript (et dans notre cas, React) gère l'affichage de nouvelles pages au sein du même domaine, sans qu'un rafraîchissement complet de la page soit nécessaire.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/site_Web_classique_SPA.png" alt="">
                        <figcaption>L'affichage du site Web classique en haut est moins dynamique que celui de la SPA en bas.</figcaption>
                    </figure>
                    <p>Toutes les applications ne sont pas nécessairement des SPA. Lorsque vous codez votre site en Single Page Application, il faut être conscient de certains inconvénients : vos utilisateurs doivent notamment impérativement avoir JavaScript pour que votre site fonctionne, ou encore le Search Engine Optimisation (SEO, l'optimisation de l'indexation de votre site par les moteurs de recherche) est plus laborieux pour les Single Page Applications.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Je vous ai déjà parlé de Gatsby ou bien Next.js. Il s'agit de frameworks basés sur React qui permettent de générer notre application côté serveuur et donc de faire du <span class="em">Server Side Rendering</span> (SSR). C'est-à-dire qu'ils génèrent le HTML depuis React côté serveur et puis l'envoient avec chaque page déjà générée au client. Pour ce qui est de leur <span class="em">routing</span>, ils mettent leur propre solution à disposition. Elle se comporte comme du routing de SPA au niveau de l'expérience utilisateur, mais qui est un peu plus complexe qu'il n'y paraît.</p>
                    </div>
                    <p>Les projets que nous créons avec Create React App ne peuvent pas encore être considérés comme des Single Page Applications : il leur manque une solution de <span class="em">routing</span>.</p>
                </article>
                <article>
                    <h2 id="react_router">Découvrez React Router :</h2>
                    <p>Contrairement aux frameworks comme Angular, React ne nous fournit pas directement une solution pour gérer les routes de notre application. Pas de panique, comme pour quasiment tout en React, l'écosystème a vite comblé ce besoin. Il existe donc plusieurs solutions de routing. Cela à laquelle nous allons nous intéresser dans la suite est <a href="https://reactrouter.com/" target="_blank">React Router</a> (le nom est plutôt bien trouvé, n'est-ce pas ?).</p>
                    <p>Comme nous pouvons le voir dans <a href="https://reactrouter.com/en/6.8.1/start/concepts#defining-routes" target="_blank">la documentation React Router</a>, une route permet d'afficher des composants de manière conditionnelle si le path (chemin) de l'URL correspond au path de la route.</p>
                    <p>On lui passe en prop le path auquel la route correspond et elle se charge d'afficher les children qui lui sont passés.</p>
                    <p>Cette bibliothèqye, créée par <a href="https://remix.run/" target="_blank">Remix</a>, met à votre disposition tous les outils nécessaires pour gérer la navigation dans votre appliction côté client.</p>
                    <p>Alors, partons à la découverte de React Router.</p>
                    <h3>Créez votre prmeier fichier de routing :</h3>
                    <div class="important">
                        <img src="../images/important.png" alt="Important" class="float_left">
                        <p>React Router est très régulièrement mis à jour. La version utilisée pour faire ce cours est la <span class="em">V6</span>. Pour suivre ce cours, vous pourrez préciser la version que vous souhaitez installer directement dans la ligne de commande pour installer le package. Ici nous installerons la version 6.10.0.</p>
                        <p>N'hésitez pas à <a href="https://reacttraining.com/blog/" target="_blank">consulter le blog de React Router</a> pour en apprendre davantage sur les différentes versions et leurs actualités.</p>
                    </div>
                    <p>Nous allons commencer par installer la bibliothèque avec <span class="html">yarn add react-router-dom@6.10.0</span>. Si vous voulez en apprendre davantage sur la configuration, n'hésitez pas à jeter un oeil à <a href="https://reactrouter.com/en/6.10.0/start/tutorial" target="_blank">la documentation de React Router</a>.</p>
                    <p>React Router est maintenant prêt à être utilisé !</p>
                    <p>Actuellement, nous n'avons qu'une seule fonctionnalité avec <span class="html">Home</span>. Créons dès maintenant un nouveau composant pour le questionnaire.</p>
                    <p>Pour cela, on crée un dossier, on crée un dossier <span class="html">SUrvey.jsx</span> dans <span class="html">pages</span>. Pour le moment, gardons un composant très simple :</p>
<pre><code>function Survey() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Survey</code></pre>
                    <p>Votre mission, si vous l'acceptez, est de pouvoir <span class="em">naviguer entre la page d'accueil - Home - et le questionnaire - Survey</span>.</p>
                    <p>Vous vous en doutez sûrement : nous allons utiliser React Router et ses composants BrowserRouter, Routes et Route !</p>
                    <p>Dans l'exemple ci-dessous, on renomme <span class="html">BrowserRouter</span> en <span class="html">Router</span> pour une lecture plus simple. Il servira à stocker et à s'abandonner au changement de l'URL de la page courante (celle qu'on retrouve dans la barre d'URL).</p>
                    <p>Ensuite, nous ajoutons le composant <span class="em">Routes</span> qui va servir à sélectionnner le composant enfant correspondant à la location.</p>
                    <p>Finalement, le composant le plus complexe, le composant <span class="em">Route</span>. Ce composant prend de base plusieurs paramètres dont à minima :</p>
                    <ul>
                        <li>
                            <p><span class="html">path</span> qui contient l'URL dans notre navigateur qui dirigera vers le composant;</p>
                        </li>
                        <li>
                            <p><span class="html">element</span> qui va permettre de sélectionner le composant à afficher.</p>
                        </li>
                    </ul>
                    <p>Le fichier <span class="html">index.jsx</span> à la racine de votre projet se transforme donc de cette manière :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>L'idée est maintenant de mettre dans notre router toutes les routes qui seront accessibles.</p>
                    <figure>
                        <img src="../images/survey_URL_React.png" alt="">
                        <figcaption>Il faudra afficher le bon composant pour cette URL.</figcaption>
                    </figure>
                    <p>Créons donc une route pour la page d'accueil et pour notre questionnaire.</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Si vous allez sur l'URL <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a>, on a bien la page d'accueil qui s'affiche. C'est la mêem chose si vous vous mettez <a href="http://localhost:3000/survey" target="_blank">http://localhost:3000/survey</a> dans la barre d'URL.</p>
                    <p>Félicitations ! Tout fonctionne bien comme prévu !</p>
                    <p>Mais bon... Ce n'est pas vraiment pratique de devoir taper toutes nos URL à la main dans la barre du navigateur pour changer de page.</p>
                </article>
                <article>
                    <h2 id="navigation_Link">Naviguez avec les Link :</h2>
                    <p>Profitons-en pour créer notre header, avec les liens vers les différentes pages de notre application.</p>
                    <p>Dans notre dossier <span class="html">/components</span>, on crée donc un nouveau dossier <span class="html">/Header</span> avec un fichier <span class="html">index.jsx</span> à l'intérieur, ce qui nous donne <span class="html">/components/Header/index.jsx</span> :</p>
<pre><code>import { Link } from 'react-router-dom'

function Header() {
    return (
        &lt;nav&gt;
            &lt;Link to="/"&gt;Accueil&lt;/Link&gt;
            &lt;Link to="/survey"&gt;Questionnaire&lt;/Link&gt;
        &lt;/nav&gt;
    )
}

export default Header</code></pre>
                    <p>Ici, j'utilise <span class="html">Link</span>, qui nous vient de React Router et se comporte comme une balise <span class="html">anchor</span>. Il est donc très important de l'utiliser lorsque vous souhaitez naviguer pour l'accessibilité de votre application (et non utoliser des redirections déclenchées par des <span class="html">onClick</span>).</p>
                    <p>Utilisons maintenant <span class="html">Header</span> dans <span class="html">index.jsx</span> à la racine de notre projet :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, j'aurais pu utiliser <span class="html">Header</span> dans <span class="html">Home</span> et dans <span class="html">Survey</span>. Mais, encore mieux, je le place à la base du router. On considère ici que notre <span class="html">Header</span> fait partie du <span class="html">Layout</span> (agencement) de notre application.</p>
                    </div>
                    <figure>
                        <img src="../images/routes_React.png" alt="">
                        <figcaption>Nos routes renvoient bien les bons composants.</figcaption>
                    </figure>
                    <p>Vous avez maintenant la base de votre application avec navigation : félicitations à vous, vous avez fait du bon boulot.</p>
                    <p>Maintenant que nous avons vu comment mettre en place le routing, j'en profite pour vous montrer comment découper notre router quand nous avons beaucoup de routes à gérer - dans un projet de code plus important, par exemple.</p>
                </article>
                <article>
                    <h2 id="Outlets_page">Utilisez les Outlets pour afficher certaines parties de la page :</h2>
                    <p>Dans une application complexe, on peut décider d'afficher certaines parties de la page en fonction de la route que nous avons prise. Imaginons que pour notre questionnaire nous souhaitons afficher des questions différentes si la personne est porteuse de projet ou prestataire freelance.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Nous ne le ferons pas dans notre application, nous faisons juste cet exemple afin que vous avez connaissance de cette possibilité.</p>
                    </div>
                    <p>Nous commençons donc par modifier notre composant Survey comme ceci :</p>
<pre><code>import { Outlet, Link } from 'react-router'

function Survey() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
            &lt;Link to="client"&gt;Questionnaire Client&lt;/Link&gt;
            &lt;Link to="freelance"&gt;Questionnaire Freelance&lt;/Link&gt;
            &lt;Outlet /&gt;
        &lt;/div&gt;
    )
}

export default Survey</code></pre>
                    <p>Ensuite, il nous faut créer nos composants pour les formulaires client et prestataires. Je vais donc créer un dossier <span class="html">ClientForm</span> dans <span class="html">/components</span>. Dans ce dossier, je crée mon fichier <span class="html">index.js</span> avec le code suivant :</p>
<pre><code>function ClientForm() {
    return (
        &lt;div&gt;
            &lt;h2&gt;Questionnaire Client&lt;/h2&gt;
        &lt;/div&gt;
    )
}

export default ClientForm</code></pre>
                    <p>Je peux faire la même chose ensuite avec le composant FreelanceForm, puis finalement he viens de modifier mon Router afin d'inclure les composants de ma page Questionnaire de cette manière :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'
// On ajoute nos composants
import ClientForm from './components/ClientForm'
import FreelanceForm from './coimponents/FreelanceForm'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey" element={&lt;Survey /&gt;}&gt;
                    { /* Nous imbriquons nos composants dans survey */ }
                    &lt;Route path="client" element={&lt;ClientForm /&gt;} /&gt;
                    &lt;Route path="freelance" element={&lt;FreelanceForm /&gt;} /&gt;
                &lt;/Route&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Et voilà, notre affichage de survey dépendra maintenant de notre route :</p>
                    <ul>
                        <li>
                            <p><span class="html">/survey</span> : n'affichera que l'en-tête et les deux liens;</p>
                        </li>
                        <li>
                            <p><span class="html">/survey/client</span> : ajoutera le composant ClientForm;</p>
                        </li>
                        <li>
                            <p><span class="html">/survey/freelance</span> : ajoutera le composant ClientForm.</p>
                        </li>
                    </ul>
                    <figure>
                        <img src="../images/Outlets_React.png" alt="">
                        <figcaption>Nos Outlets fonctionnent !</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Si vous avez réalisé le code en même temps que moi, je vous conseille de le commit dans une nouvelle branche, car comme énoncé plus haut, nous ne servirons pas des Outlets dans notre projet.</p>
                    </div>
                </article>
                <article>
                    <h2 id="recuperation_parametres_URL">récupérez des paramètres dans vos URL :</h2>
                    <p>La navigation de notre application fonctionne bien, mais comment faire si vous voulez passer des paramètres ? Par exemple, lorsqu'on va faire le questionnaire et que le numéro de chaque question sera récupéré depuis l'URL ? Eh bien, bonne question ! Le router vous permet de récupérer des paramètres; pour cela, il suffit d'écrire votre route comme ici dans le fichier <span class="html">index.jsx</span> à la racine de <span class="html">/src</span> :</p>
<pre><code>&lt;Route path="/survey/:questionNumber element={&lt;Survey /&gt;} /&gt;</code></pre>
                    <p>Dans <span class="html">components/Header/index.jsx</span>, mettons donc un numéro de question à la suite :</p>
<pre><code>function Header() {
    return (
        &lt;nav&gt;
            &lt;Link to="/"&gt;Accueil&lt;/Link&gt;
            &lt;Link to="/survey/42"&gt;Questionnaire&lt;/Link&gt;
        &lt;/nav&gt;
    )
}</code></pre>
                    <p>Allons maintenant récupérer ce paramètre dans <span class="html">Survey/index.jsx</span> à l'aide du hook <span class="html">useParams</span>, mis à disposition par React Router :</p>
<pre><code>import { useParams } from 'react-router-dom'

function Survey() {
    const { questionNumber } = useParams()

    return (
        &lt;div&gt;
            &lt;h1&gt;Questionnaire&lt;/h1&gt;
            &lt;h2&gt;Question {questionNumber}&lt;/h2&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Félicitations à vous ! Vous avez récupéré le numéro de votre question en paramètre.</p>
                </article>
                <article>
                    <h2 id="route_404">Créez une route pour les attraper toutes : 404 :</h2>
                    <p>Quelle chance, tout fonctionne comme on le souhaite ! Mais qu'est-ce qui se passe si je commence à taper n'importe quoi dans mon URL ? par exemple, si j'essaie d'accéder au contenu de <a href="http://localhost:3000/coucouCommentCaVa" target="_blank">http://localhost:3000/coucouCommentCaVa</a> ?</p>
                    <p>Notre header s'affiche, mais rien d'autre... Moi, j'aimerais signaler à l'utilisateur que rien n'existe à cette adresse. Eh bien, ça vous dit quelque chose, les pages d'erreur ? C'est ce que nous allons faire ici : afficher une page 404.</p>
                    <p>On commence par créer un simple composant <span class="em">Error</span> dans <span class="html">components/Error/index.jsx</span> :</p>
<pre><code>function Error() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Oups ! Cette page n'existe pas&lt;/h1&gt;
        &lt;/div&gt;
    )
}

export default Error</code></pre>
                    <p>On retourne maintenant dans notre Router. Afin de gérer les erreurs qui n'existent pas nous ajouterons une route avec un <span class="html">path</span> particulier, le <span class="html">path=*</span> ainsi que toutes les routes qui ne sont pas mentionnées plus haut conduiront à ma page d'erreur.</p>
                    <p>Dans notre router, on a donc :</p>
<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import Home from './pages/Home/'
import Survey from './pages/Survey/'
import Header from './components/Header'
import Error from './components/Error/'

ReactDom.render(
    &lt;React.StrictMode&gt;
        &lt;Router&gt;
            &lt;Header /&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/survey/:questionNumber" element={&lt;Survey /&gt;} /&gt;
                &lt;Route path="*" element={&lt;Error /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
)</code></pre>
                    <p>Testons dans notre navigateur :</p>
                    <figure>
                        <img src="../images/erreur_404_React.png" alt="">
                        <figcaption>Notre Route permet d'afficher une erreur lorsque l'URL saisie n'existe pas dans le router.</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nos besoins en routing restent limités. Mais comment auriez-vous fait si vous aviez dû créer un système d'authentification ? Eh bien, le router aurait été au coeur de votre login. Vous auriez séparé votre application entre les routes non authentifiées, telles qu'une page d'inscription, de connexion, etc., et les routes authentifiées. À chaque requête sur une page authentifiée, vous auriez dû passer un token secret permettant de vous authentifier à l'API :</p>
                        <ul>
                            <li>
                                <p>Si le token est correct, pas de souci, vous récupérez vos données.</p>
                            </li>
                            <li>
                                <p>En cas d'erreur de token, vous recevez une erreur qui a pour conséquence de vous rediriger auutomatiquement côté router de React sur la partie non authentifiée avec Redirect.</p>
                            </li>
                        </ul>
                        <p>Vous pouvez en apprendre plus sur <a href="https://ui.dev/react-router-v5-protected-routes-authentication/" target="_blank">l'authentification avec React React Router dans cet article (en anglais)</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="PropTypes">Indiquez les types de vos props avec les PropTypes :</h2>
                    <h3>Découvrez le typage :</h3>
                    <p>Les PropTypes sont une des méthodes les plus répandues pour sécuriser le type des props que reçoivent vos composants.</p>
                    <p>En termes de typage, le typage de JavaScript est considéré comme "faible" : JS fonctionne sur du <a href="https://developer.mozilla.org/fr/docs/Glossary/Dynamic_typing" target="_blank">typage dynamique</a> et n'assure pas de type safety. Cela veut dire que lorsqu'on déclare une nouvelle variable, le développeur ou la développeuse <span class="em">ne précise pas de quel type</span> sera la nouvelle variable, le code s'adapte à la volée, et on peut tout à fait changer le type d'une variable.</p>
                    <p>En JS, je peux totalement faire :</p>
<pre><code>let maVariable = 42
maVariable = "quarante trois"</code></pre>
                    <p>Alors que dans un certain nombre d'autres langages, ce n'est pas du tout possible.</p>
                    <p>Typiquement, en C, je dois préciser le type <span class="em">dès la déclaration</span> et il <span class="em">ne change pas</span>. Le typage est alors qualifié de "statique". Ici, <span class="html">maVariable</span> est un <span class="html">integer</span> :</p>
<pre><code>int maVariable;
maVariable = 42; // Pas de souci ici
maVariable = "Quarante trois"; // ce code ne compilera pas !</code></pre>
                    <p>Les choses sont donc bien plus flexibles en JavaScript.</p>
                    <p>Mais ne vous réjouissez pas trop vite, cette flexibilité peut aussi causer votre perte. En effet, des bugs sont vite arrivés en JavaScript, surtout lorsque vous collaborez en équipe !</p>
                    <p>C'est pourquoi il existe des outils pour assurer ses arrières, tels que les <span class="html">PropTypes</span>.</p>
                    <h3>Installez PropTypes :</h3>
                    <p>La bibliothèque PropTypes vous permey de déclarer le type des props qui est attendu lorsque vous les récupérez dans vos composants, et de déclencher un warning si ça ne correspond pas. Bien pratique !</p>
                    <p>Comme d'habitude, pour installer la bibliothèque PropTypes, il vous suffit de lancer la commande <span class="html">yarn add prop-types</span>.</p>
                    <p>Profitons-en pour mettre les <span class="html">propTypes</span> en pratique dans notre application Shiny Agency !</p>
                    <p>Nous allons dès maintenant coder la base des <span class="html">Card</span> dans la page <span class="html">/freelances</span>.</p>
                    <p>Dans le dossier <span class="html">/components</span>, on vient créer un nouveau dossier <span class="html">/Card</span> dans lequel vous pouvez créer un fichier <span class="html">index.jsx</span>. Vous pouvez y coller le code suivant :</p>
<pre><code>function Card({ label, title, picture }) {
    return (
        &lt;div style={{ display: 'flex', flexDirection: 'column', padding: 15 }}&gt;
            &lt;span&gt;{label}&lt;/span&gt;
            &lt;img src={picture} alt="freelance" height={80} width={80} /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/div&gt;
    )
}

export default Card</code></pre>
                    <p>Ce composant récupère 3 props : <span class="html">label</span>, <span class="html">title</span> et <span class="html">picture</span>. J'ai également ajouté quelques propriétés de style pour que le tout soit plus visible.</p>
                    <p>Nous allons utiliser les <span class="html">Card</span> dans notre fichier <span class="html">Freelances/index.js</span>. Comme nous n'avons pas encore récupéré les datas que nous afficherons, nous allons créer un tableau d'objets nous-mêmes, qu'on déclare dans <span class="html">/pages/Freelances/index.jsx</span> :</p>
<pre><code>import DefaultPicture from '../../assets/profile.png'

const freelanceProfiles = [
    {
        name: 'Jane Doe',
        jobTitle: 'Devops',
        picture: DefaultPicture,
    },
    {
        name: 'John Doe',
        jobTitle: 'Développeur frontend',
        picture; DefaultPicture,
    },
    {
        name: 'Jeanne Biche',
        jobTitle: 'Développeuse Fullstack',
        picture: DefaultPicture,
    },
]</code></pre>
                    <p>Ici, on utilise une photo de profil vide standard qu'on a mise dans un dossier <span class="html">/assets</span>. Nous pouvons mapper ce tableau pour afficher le composant <span class="html">Card</span> :</p>
<pre><code>function Freelances() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Freelances&lt;/h1&gt;
            {freelanceProfiles.map((profile, index) =&gt; (
                &lt;Card
                    key={`${profile.name}-${index}`}
                    label={profile.jobTitle}
                    picture={profile.picture}
                    title={profile.name}
                /&gt;
            ))}
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Nous avons tout ce qu'il nous faut ! Sécurisons donc les props de <span class="html">Card</span> avec les propTypes !</p>
                    <p><span class="html">Card</span> récupère 3 props, <span class="html">label</span>, <span class="html">title</span> et <span class="html">picture</span>. On va donc importer <span class="html">PropTypes</span> depuis la bibliothèque et utiliser <span class="html">Card.propTypes</span> pour préciser les types de chacune des propriétés.</p>
<pre><code>import PropTupes from 'prop-types'

function Card({ label, title, picture }) {
    return (
        &lt;div style={{ display: 'flex', flexDirection: 'column', padding: 15 }}&gt;
            &lt;span&gt;{label}&lt;/span&gt;
            &lt;img src={picture} alt="freelance" height={80} width={80} /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/div&gt;
    )
}

Card.propTypes = {
    label: PropTypes.string,
    title: PropTypes.string,
    picture: PropTypes.string,
}

export default Card</code></pre>
                    <p>Vous pouvez essayer dès maintenant de passer une prop dont le type n'est pas <span class="html">string</span>, pour voir. Dans <span class="html">freelances/index.jsx</span> :</p>
<pre><code>{freelanceProfiles.map((profile, index) =&gt; (
    &lt;Card
        key={`${profile.name}-${index}`}
        label={profile.jobTitle}
        picture={profile.picture}
        title={42}
    /&gt;
))}</code></pre>
                    <figure>
                        <img src="../images/propTypes_React.jpg" alt="">
                        <figcaption>Ça me renvoie directement une erreur dans la console !</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous n'avons que des <span class="html">strings</span>, mais il existe bien plus de types supportés par <span class="html">propTypes</span>. <a href="https://fr.reactjs.org/docs/typechecking-with-proptypes.html#proptypes" target="_blank">Vous pourrez les trouver dans la doc de React.</a></p>
                    </div>
                    <p>Bravo à vous, vous venez de sécuriser votre composant <span class="html">Card</span> à l'aide des propTypes.</p>
                    <p>Mais je ne vous ai pas tout montré : vous pouvez même préciser si une prop est requise ou non !</p>
                    <h3>Exigez une prop :</h3>
                    <p>Il est très simple de préciser qu'une prop est requise pour le bon fonctionnement de l'application. Pour cela, il suffit d'ajouter <span class="html">isRequired</span> à la suite du type déclaré.</p>
                    <p>Par exemple, toujours pour <span class="html">Card</span>, si on fait :</p>
<pre><code>Card.propTypes = {
    label: PropTypes.string,
    title: PropTypes.string.isRequired,
    picture: PropTypes.string
}</code></pre>
                    <p>... et qu'on omet de déclarer la prop <span class="html">title</span>, ça nous donne :</p>
                    <figure>
                        <img src="../images/propTypes_React_1.jpg" alt="">
                        <figcaption>Une erreur apparaît dans la console lorsque vous oubliez de préciser une prop qui est requise.</figcaption>
                    </figure>
                    <p>Et voilà, vous avez réussi à "exiger une prop avec <span class="html">.isRequired</span> !</p>
                    <p>Je voulais vous montrer une dernière chose en lien avec les propTypes : comment définir une prop par défaut.</p>µ
                    <h3>Définissez des props par défaut :</h3>
                    <p>Bon, précédemment, vous avez déjà vu comment définir par défaut avec la déstructuration. Mais nous allons voir comment le faire de manière plus formelle : nous allons utiliser <span class="html">defaultProps</span>. Dans l'exemple précédent, au lieu de déclencher une erreur pour notre propriété manquante (alors qu'on avait précisé <span class="html">isRequired</span>), nous aurions pu aussi déclarer une propriété par défaut.</p>
                    <p>Il est possible d'assigner une valerur à <span class="html">title</span> directement dans la déstructuration, comme ici :</p>
<pre><code>function Card({ label, title = 'Mon titre par défaut', picture })</code></pre>
                    <p>Mais cette syntaxe déclenche malgré tout une erreur de <span class="html">PropType</span>. Dans ce cas, la meilleure manière est d'avoir recours à <span class="html">defaultProps</span>. Juste en dessous de <span class="html">Card.propTypes</span>, nous déclarons un objet <span class="html">Card.defaultProps</span> :</p>
<pre><code>Card.defaultProps = {
    title: 'Mon titre par défaut',
}</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Jusqu'à il y a quelques années, <span class="html">prop-types</span> était la solution recommandée pour typer ses props. Mais aujourd'hui, il existe d'autres solutions, telles que <span class="html">TypeScript</span> ou <span class="html">Flow</span>. Si vous voulez voir à quoi ressemble la base d'une application codée avec TypeScript, <a href="https://github.com/OpenClassrooms-Student-Center/7150606-React-intermediaire/tree/typescript" target="_blank">vous trouverez la branche "typescript" dans le projet "shiny-agency" où l'application est entièrement codée en TS</a>.</p>
                    </div>
                </article>
                <article>
                    <h2 id="styled_components">Scopez votre CSS avec styled components :</h2>
                    <p>Pour ajouter du style à votre application React, vous avez certainement jusqu'ici utilisé du CSS. Pour gagner du temps de développement sur le CSS nous pouvons même utiliser des bibliothèqyes comme <a href="https://getbootstrap.com/" target="_blank">Bootstrap</a> ou encore <a href="https://tailwindcss.com/" target="_blank">Tailwind</a>. Cependant, vous est-il déjà arrivé de réutiliser le nom d'une classe CSS dans un autre composant sans faire exprès ? Ou bien encore de trouver du style appliqué à un élément sans comprendre d'où il venait ? Si ça vous est déjà arrivé, vous devez savoir à quel point c'est frustrant !</p>
                    <p>L'enjeu de <span class="em">scoper</span> notre style aux composants concernés est réel.</p>
                    <p>Le scope correspond aux parties de notre code qui ont accès à un élément, comme une variable, ou une classe CSS. Il peut être global (comme c'est le cas pour les classes CSS dont je vous parlais il y a quelques instants), ou bien converner une partie spécifique du code.</p>
                    <p>Pour scoper le style, il existe des solutions, telles que des méthodologies d'architecture de CSS ou bien des outils spécifiques comme Sass (qui requiert un préprocesseur). Mais depuis quelques années, le <span class="em">CSS in JS</span> émerge comme l'une des solutions à notre problème.</p>
                    <h3>Découvrez le CSS in JS :</h3>
                    <p>Comme son nom l'indique, le CSS in JS est généré... avec du JavaScript. Il sera inséré dans le DOM dans un élément <span class="html">&lt;style&gt;</span>.</p>
                    <p>L'inline style est inséré dans le DOM sur l'attribut <span class="html">style</span> d'un élément spécifique (souvenez-vous, on fait <span class="html">&lt;div style={{ color: 'red' }} /&gt;</span>). Par ailleurs, l'inline style ne permetpas d'utiliser les pseudo-selectors. Ce n'est pas pareil pour le CSS in JS, avec lequel on peut utiliser autant de pseudo-selectors que nécessaire.</p>
                    <p>Mais avec le CSS in JS, on garde l'idée que <span class="em">le style est attaché à un compposant spécifique</span>, directement dans le même fichier. Beaucoup plus simple lorsqu'il faut supprimer ou modifier du style déjà existant, n'est-ce pas ?</p>
                    <p>Il existe plusieurs solutions de CSS in JS, avec leurs syntaxes propres. Ici nous allons nous intéresser à la bibliothèque <span class="em">styled components</span>.</p>
                    <p>Commençons dès maintenant par installer la bibliothèque avec <span class="html">yarn add styled-components</span> :</p>
                    <figure>
                        <img src="../images/CSS_in_JS.jpg" alt="">
                        <figcaption>Styled-components s'installe.</figcaption>
                    </figure>
                    <p>Penchons-nous dès maintenant sur le style que nous allons pouvoir créer !</p>
                    <h3>Appliquez la logique styled components :</h3>
                    <p>Dans styled components, la principale chose à comprendre est que tout est composant. Pour voir cela, créons dès maintenant notre premier styled component (styled composant).</p>
                    <p>Dans <span class="html">Card/index.jsx</span>, créons donc le style pour le <span class="html">label</span>.</p>
                    <p>On commence par ajouter l'import de styled-components puis nous créons notre composant <span class="html">CardLabel</span> de la manière suivante :</p>
<pre><code>import styled from 'styled-components'

const CardLabel = styled.span``</code></pre>
                    <p>Et on a réutilisé <span class="html">CardLabel</span> directement dans le JSX :</p>
<pre><code>&lt;CardLabel&gt;{label}&lt;/CardLabel&gt;</code></pre>
                    <p>Pas de panique ! Ici, <span class="html">styled-components</span> utilise des templates literals que vous pouvez voir <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates" target="_blank">dans la documentation Mozilla</a>. Vous pouvez écrire votre CSS directement à l'intérieur. Ce qui nous donne :</p>
<pre><code>const CardLabel = styled.span`
    color: #5843e4;
    font-size: 22px;
    font-weight: bold;
`</code></pre>
                    <p>Profitons-en pour ajouter du style à notre image. Cette fois-ci, toujours dans le même fichier <span class="html">Card/index.jsw</span>, on a :</p>
<pre><code>const CardImage = styled.img`
    height: 80px;
    width: 80px;
    border-radius: 50%;
`</code></pre>
                    <p>... qu'on utilise dans le code :</p>
<pre><code>&lt;CardImage src={picture} alt="freelance" /&gt;</code></pre>
                    <p>Bravo à vous ! Vous avez généré des éléments <span class="html">span</span> et <span class="html">img</span> auxquels vous avez appliqué du style avec <span class="html">styled-components</span> ! Vous vous en doutez, ça ne s'arrête pas à <span class="html">span</span> et <span class="html">img</span> : vous pouvez ainsi générer tous les éléments du DOM... mais pas que.</p>
                    <p>Style components prévoit ce cas ! Prenons l'exemple de <span class="html">Header/index.jsx</span>. Pour cela, il nous suffit de faire :</p>
<pre><code>import { Link } from 'react-router-dom'
import styled from 'styled-components'

const StyledLink = styled(Link)`
`

function Header() {
    return (
        &lt;nav&gt;
            &lt;StyledLink to="/"&gt;Accueil&lt;/StyledLink&gt;
            &lt;StyledLink to="/survey/1"&gt;Questionnaire&lt;/StyledLink&gt;
            &lt;StyledLink to="/freelances"&gt;Profils&lt;/StyledLink&gt;
        &lt;/nav&gt;
    )
}

export default Header</code></pre>
                    <p>Essayez ce code pour voir le rendu vous-même - pas mal, n'est-ce pas ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>D'ailleurs, vous pouvez styliser un composant que vous avez vous-même créé de la même manière. Cette technique permet d'étendre votre style.</p>
                    </div>
                    <h3>Passez des props dans votre CSS :</h3>
                    <p>C'est bien beau, nous avons créé nos styled components et nous les avons utilisés, mais quels autres avantages tire-t-on du fait d'écrire notre style avec du JS ? ...Eh bien justement, on utilise du JS. On va pouvoir passer des props à nos composants directement depuis notre composant React.</p>
                    <p>Voyons voir concrètement ce que cela donne dans notre <span class="html">Header</span>.</p>
<pre><code>&lt;styledLink to="/survey/1" $isFullLink&gt;
    Faire le test
&lt;/StyledLink&gt;</code></pre>
                    <p>Ici on passe la prop <span class="html">1isFullLink</span>. Ce qui nous permet d'utiliser la prop directement dans le style :</p>
<pre><code>const StyledLink = styled(Link)`
    padding: 15px;
    color: #8186a0;
    text-decoration: none;
    font-size: 18px;
    ${(props) =&gt;
        props.$isFullLink &&
        `color; wite; border-radius: 300px; background-color; #5843E4;`}
`</code></pre>
                    <p>C'est quoi ce <span class="html">$</span> ? Eh bien, cela permet de signaler à <span class="html">styled-components</span> que notre prop nous sert pour le style, et qu'elle ne doit pas être passée dans le DOM.</p>
                    <p>Ce <span class="html">$</span> est uniquement nécessaire pour passer une prop si le composant en question est un composant React, comme ici pour <span class="html">Link</span> (et non un élément HTML). Si mon styled component était basé sur une simple balise <span class="html">a</span>, je pourrais totalement utiliser la prop <span class="html">isFullLink</span> sans le <span class="html">$</span>.</p>
                    <p>Voyons l'utilisation du state en prop de plus près ci-dessous :</p>
<pre><code>// Dans /pages/Home/index.jsx
import { useState } from 'react'
import styled from 'styled-components'

const HomeContainer = styled.div`
    height: 100px;
    width: 100px;
    border-radius: 50px;
    background-color: #e20202;
    transform: scale(${({ size }) =&gt; size});
`

function Home() {
    const [size, setSize] = useState(1)
    return (
        &lt;HomeContainer&gt;
            &lt;h1 onClick={() =&gt; setSize(size + 0.1)}&gt;Page d'accueil&lt;/h1&gt;
            &lt;Ballon size={size} /&gt;
        &lt;/HomeContainer&gt;
    )
}

export default Home</code></pre>
                    <p>Pas mal, non ?</p>
                    <h3>Utilisez des variables :</h3>
                    <p>Vous voyez, dans notre avant-dernier snippet de code, on a encore utilisé la couleur violette <span class="html">#5843E4</span>. Qui dit JS dit aussi qu'on peut utiliser des variables, et c'est ce que nous allons faire : nous allons utiliser des variables pour <span class="em">stocker nos couleurs</span> !</p>
                    <p>Vous pourriez tout simplement déclarer un objet <span class="html">colors</span> qui reprend toutes les couleurs de notre application, mais il est considéré comme une bonne pratique de créer un thème géré par <span class="html">styled-components</span>.</p>
                    <p>On crée donc un dossier <span class="html">/utils</span> directement dans <span class="html">src/</span>, dans lequel on met un dossier <span class="html">/style</span>. On y crée notre fichier <span class="html">color.js</span>, ce qui nous donne :</p>
<pre><code>├── assets
│   └── profile.png
├── components
│   ├── Card
│   │   └── index.jsx
│   ├── Error
│   │   └── index.jsx
│   └── Header
│       └── index.jsx
├── index.jsx
├── pages
│   ├── Freelances
│   │   └── index.jsx
│   ├── Home
│   │   └── index.jsx
│   ├── Results
│   │   └── index.jsx
│   └── Survey
│       └── index.jsx
└── utils
└── style
└── colors.js</code></pre>
                    <p>Dans <span class="html">color.js</span>, on définit nos couleurs :</p>
<pre><code>const colors = {
    primary '#5843E4',
    secondary: '8186A0',
    backgroundLight: '#F9F9FC',
}

export default colors</code></pre>
                    <p>Pour l'utiliser, il nous suffit de l'importer directement dans notre template string :</p>
<pre><code>const StyledLink = styled(Link)`
    padding: 15px;
    color: #8186a0;
    text-decoration: none;
    font-size: 18px;
    ${(props) =&gt;
        props.$isFullLink && 
        `color: white; border-radius: 30px; background-color: ${colors.primary};`}
`</code></pre>
                    <p>Et on a bien ce qu'on voulait.</p>
                    <p>Par contre, comment faire si je veux styliser mon composant au survol de la souris ? Eh bien, c'est très simple ici puisque les pseudosélecteurs fonctionnent dans nos styled components.</p>
                    <p>Pour mettre tout ça en pratique, on va retourner sur nos <span class="html">Cards</span>. On y ajoutera un peu de style pour que l'effet de <span class="em">hover</span> soit plus visible. Dans <span class="html">pages/freelances.jsx</span>, on met :</p>
<pre><code>const CardContainer = styled.div`
    display: grid;
    gap: 24px;
    grid-template-rows: 350px 350px;
    grid-template-columns: repeat(2, 1fr);
`</code></pre>
                    <p>... qu'on utilise tout de suite dans le même fichier :</p>
<pre><code>function Freekabces() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Freelances&lt;/h1&gt;
            &lt;CardsContainer&gt;
                {freelanceProfiles.map((profile, index) =&gt; (
                    &lt;Card
                        key={`${profile.name}-${index}`}
                        label={profile.jobTitle}
                        title={profile.name}
                    /&gt;
                ))}
            &lt;/CardContainer&gt;
        &lt;/div&gt;
    )
}</code></pre>
                    <p>Puis dans <span class="html">Card/index.jsx</span>, on peut créer un effet d'ombre au survol de la souris. Pour ça, on crée un <span class="html">CardWrapper</span> qui vient remplacer notre précédente <span class="html">div</span> :</p>
<pre><code>function Card({ label, title, picture }) {
    return (
        &lt;CardWrapper&gt;
            &lt;CardLabel&gt;{label}&lt;/CardLabel&gt;
            &lt;CardImage src={picture} alt="freelance" /&gt;
            &lt;span&gt;{title}&lt;/span&gt;
        &lt;/CardWrapper&gt;
    )
}</code></pre>
                    <p>Et on définit CardWrapper comme suit :</p>
<pre><code>const CardWrapper = styled.div`
    display: flex;
    flex-direction: column;
    padding: 15px;
    background-color: ${colors.backgroundLight};
    border-radius: 30px;
    width: 350px;
    transition: 200ms;
    &:hover {
        cursor: pointer;
        box-shadow: 2px 2px 10px #e2e3e9;
    }
`</code></pre>
                    <p>La syntaxe <span class="html">&:hover</span> nous permet d'accéder au pseudosélecteur du survol de la souris, et on a bien l'effet souhaité !</p>
                    <figure>
                        <img src="../images/hover_React.png" alt="">
                        <figcaption>On a bien l'effet d'ombre au survol de la souris.</figcaption>
                    </figure>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, nous avons utilisé le pseudosélecteur <span class="html">:hover</span> avec <span class="html">&</span>. <span class="html">&</span> est très utile dans nos styled components, notamment pour utiliser des pseudosélecteurs, mais aussi pour accéder à d'autres éléments. Notamment si un de nos compoisants a <span class="html">className</span> et qu'on ne peut pas accéder directement à son style. Je ne vous le montrerai pas ici, mais <a href="https://styled-components.com/docs/basics#pseudoelements-pseudoselectors-and-nesting" target="_blank">vous trouverez des exemples dans la documentation de Styled Components</a>.</p>
                    </div>
                    <h3>Créez un style global :</h3>
                    <p>Nous avons déjà vu beaucoup de choses avec styled components. Encore une fois, nous ne pouvons pas tout couvrir dans ce cours, mais avant de conclure j'aimerais que nous créions un style global. Cela nous permettra de créer un style de base, notamment pour la police ou pour d'autres propriétés CSS.</p>
                    <p>Pour cela, dans <span class="html">index.jsx</span> à la racine de notre projet, vous pouvez créer un composant GlobalStyle :</p>
<pre><code>const GlobalStyle = createGlobalStyle`
    div {
        font-family: 'Trebuchet MS', Helvetica, sans-serif;
    }
`</code></pre>
                    <p>Et vous l'importez tout simplement dans vos composants :</p>
<pre><code>&lt;Router&gt;
    &lt;GlobalStyle /&gt;
    &lt;Header /&gt;
    ...
&lt;/Router&gt;</code></pre>
                    <p>Et voilà ! Ensemble, nous avons utilisé <span class="html">styled-components</span> pour styliser notre application !</p>
                </article>
                <article>
                    <h2 id="useState_useEffect_calls_API">Exploitez vos connaissances de useState et useEffect pour effectuer des calls API :</h2>
                    <h3>Rafraîchissez vos connaissances de useState et useEffect :</h3>
                    <p>Souvenez-vous...</p>
                    <p>Le <span class="em">state local</span> esy présent à l'intérieur d'un composant : ce composant peut être re-render autant de fois que l'on veut, mais les données seront <span class="em">préservées</span>. Pour cela on utilise <span class="html">useState</span>, un hook qui permet d'ajouter un state local dans un composant fonction.</p>
                    <p><span class="html">useEffect</span> est également un hook, qui permet d'exécuter des actions après le render de nos composants, en choisissant à quel moment et à quelle fréquence cette action doit être exécutée, avec le tableau de dépendances.</p>
                    <p>Vous vous en doutez sûrement, nous allons les utiliser pour faire des calls API :</p>
                    <ul>
                        <li>
                            <p><span class="html">useEffect</span> nous permettra de déclencher le <span class="html">fetch</span>;</p>
                        </li>
                        <li>
                            <p><span class="html">useState</span> permettra de stocker le retour de l'API dans le <span class="em">state</span>.</p>
                        </li>
                    </ul>
                    <h3>Récupérez les données d'une API :</h3>
                    <h4>Reprenez les bases des calls API :</h4>
                    <p>Les données sont au coeur d'une application. Qu'il s'agisse de données locales ou bien qu'elles soient récupérées depuis une API, elles viennent <span class="em">alimenter nos composants</span> et <span class="em">nourrir les interactions</span> avec les utilisateurs.</p>
                    <p>Une <span class="em">API</span> (Application Programming Interface) est littéralement une interface de programmation d'application : c'est un moyen de communication entre deux logiciels. Concrètement, pour nous, c'est ce qui nous permet de <span class="em">récupérer des données</span>.</p>
                    <p>Mais pourquoi on n'a pas mis les données directement dans le front ? Eh bien... oui, on aurait pu. Ici, on dispose de toutes les données. Mais dans les faits, ce ne sera pas toujours le cas, loin de là. Vous pouvez par exemple avoir besoin que votre contenu soit administré par une personne qui ne sait pas coder. Dans ce cas, vous pourriez <a href="https://openclassrooms.com/fr/courses/5922626-optimisez-le-referencement-de-votre-site-seo-en-ameliorant-ses-performances-techniques/6055246-accelerez-un-site-cree-avec-un-cms" target="_blank">utiliser un CMS</a> (comme <a href="https://wordpress.com/fr/" target="_blank">WordPress</a>, <a href="https://ghost.org/" target="_blank">Ghost</a>, etc.), et récupérer le contenu.</p>
                    <p>Ou bien tout silmplement, vous pouvez créer une application complexe qui requiert un système d'authentification, qui sauvegarde des données utilisateurs, etc. Dans ce cas, une application frontend ne suffit pas et doit être complémentaire avec l'application backend.</p>
                    <p>Mettons tout ça en application dès maintenant !</p>
                    <p>Pour notre projet pour l'agence Shiny, nous allons utiliser l'API <a href="https://github.com/OpenClassrooms-Student-Center/7150606-API-React-intermediaire" target="_blank">que vous trouverez ici</a>. Vous trouverez toutes les instructions nécessaires pour la faire tourner dans le <span class="html">README.md</span>. Je vous laisse un petit moment pour cloner le repo et lancer l'API en local.</p>
                    <p>... C'est bon, vous avez bien l'API qui tourne en local ? On va aller récupérer le contenu de nos questions sur l'API sur la route <a href="http://localhost:8000/" target="_blank">http://localhost:8000/</a> avec <a href="https://developer.mozilla.org/fr/docs/Web/API/Fetch_API/Using_Fetch" target="_blank">la méthode <span class="html">fetch()</span></a>.</p>
                    <p><span class="html">fetch()</span> est la méthode native pour faire des calls API. Nous aurions très bien pu utiliser des outils tels que <a href="https://github.com/axios/axios" target="_blank">axios</a>, mais ici la méthode native a été privilégiée, pour vous éviter une nouvelle installation d'outil externe.</p>
                    <h4>Développez le questionnaire avec les données :</h4>
                    <p>Pour nous atteler à l'utilisation de l'API, nous allons développer la page <span class="html">/survey</span>. Souvenez-vous, précédemment, nous avions créé des liens pour naviguer entre les questions, et rediriger l'utilisateur sur <span class="html">/results</span> quand il atteignait la dixième question. Eh bien, ici, nous allons continuer à développer cette page afo, de récupérer les données depuis l'API.</p>
                    <p>L'API nous renvoie l'ensemble de questions sur l'endpoint <a href="http://localhost:8000/survey" target="_blank">http://localhost:8000/survey</a>.</p>
                    <p>Hé, mais comment on sait ça ? Bon, c'est facile pour moi parce que j'ai aussi écrit l'API que nous utilisons. Mais vous pouvez tout simplement utiliser la documentation de l'API accessible dans le fichier <span class="html">README.md</span>.</p>
                    <p>On peut donc l'appeler, comme nous l'avons dit, dans notre <span class="html">useEffect</span> pour récupérer les questions. Si vous regardez la documentation, vous verrez que la route correspondant aux questions (<a href="http://localhost:8000/survey" target="_blank">http://localhost:8000/survey</a>) est une route <span class="html">GET</span>, et qu'elle ne requiert pas de paramètre : on pourra récupérer les données en faisant <span class="html">fetch('http://localhost:8000/survey')</span>.</p>
                    <p>Ici, on a donc uniquement besoin d'appeler l'API à la première initialisation de notre composant, et on <span class="em">précise un tableau de dépendances vide</span> dans notre fichier :</p>
<pre><code>useEffect(() =&gt; {
    fetch('http://localhost:8000/survey')
        .then((response) =&gt; response.json())
        .then(({ surveyData }) =&gt; console.log(surveyData))
        .catch((error) =&gt; console.log(error))
}, [])</code></pre>
                    <p>Et voilà : on a bien ce qu'on voulait  !</p>
                    <figure>
                        <img src="../images/donnees_questionnaire_React.png" alt="">
                        <figcaption>Les données de notre questionnaire arrivent dans la console.</figcaption>
                    </figure>
                    <p>Ici, nous avons utilisé des <span class="html">Promises</span>. Une autre syntaxe aurait été possible avec des <span class="html">async</span> / <span class="html">await</span>. Mais attention, il y a une petite subtilité avec <span class="html">useEffect</span>.</p>
                    <p>Bon, ce n'est pas tout d'afficher le retour de notre API dans la console : on veut que ce soit visible dans notre application !</p>
                    <p>Pour cela, nous allons <span class="em">utiliser le state</span>. À l'aide de <span class="html">useState</span>, on crée donc :</p>
<pre><code>const [questions, setQuestions] = useState({})</code></pre>
                    <p><span class="html">questions</span> va nous permettre de <span class="em">stocker l'objet qui a été retourné par l'API</span>. À partir de là, on peut exploiter <span class="html">questions</span> assez simplement en appelant : <span class="html">setQuestions(surveyData)</span>.</p>
                    <p>Ici, vous avez pu voir dans votre console que <span class="html">surveyData</span> est un objet ayant pour clé des nombres. C'est très pratique pour s'assurer que les questions sont toujours ordonnées, et on peut tout simplement <span class="em">accéder à une question</span> avec :</p>
<pre><code>surveyData[questionNumber]</code></pre>
                    <p>De la même manière, pour savoir s'il faut mettre un lien vers le numéro de question suivant, ou bien un lien vers les résultats, vous pouvez tout simplement <span class="em">vérifier ce que donne l'affirmation</span> :</p>
<pre><code>surveyData[questionNumberInt + 1] ?</code></pre>
                    <p>Ce qui nous donne le code suivant :</p>
<pre><code>function Survey() {
    const { questionNumber } = useParams()
    const questionNumberInt = parseInt(questionNumber)
    const prevQuestionNumber = questionNumberInt === 1 ? 1 : questionNumberInt - 1
    const nextQuestionNumber = questionNumberInt + 1
    const [surveyData, setSurveyData] = useState({})

    useEffect(() =&gt; {
        setDataLoading(true)
        fetch('http://localhost:8000/survey')
            .then((response) =&gt; response.json())
            .then(({ surveyData }) =&gt; console.log(surveyData))
            .catch((error) =&gt; console.log(error))
    }, [])

    return (
        &lt;SurveyContainer&gt;
            &lt;QuestionTitke&gt;Question {questionNumber}&lt;/questionNumber&gt;
            &lt;QuestionContent&gt;{surveyData[questionNumber]}&lt;/QuestionContent&gt;
            &lt;LinkWrapper&gt;
                &lt;Link to={`/survey/${prevQuestionNumber}`}&gt;Précédent&lt;/Précédent&lt;/Link&gt;
                {surveyData[questionNumberInt + 1] ? (
                    &lt;Link to={`/survey/${nextQuestionNumber}`}&gt;Suivant&lt;/Link&gt;
                ) : (
                    &lt;Link to="/results"&gt;Résultats&lt;/Link&gt;
                )}
            &lt;/LinkWrapper&gt;
        &lt;SurveyContainer&gt;
    )
}

export default Survey</code></pre>
                    <h3>Créez un state loading :</h3>
                    <p>C'est pas mal tout ça, n'est-ce pas ? Notre question s'affiche bien :</p>
                    <figure>
                        <img src="../images/state_loading_React.png" alt="">
                        <figcaption>Votre application affiche bien la question souhaitée.</figcaption>
                    </figure>
                    <p>Mais ça vient d'où ce petit moment de "blanc" ? Comment fait-on pour que ça ressemble plus aux sites professionnels ? Eh bien, ça correspond tout simple au temps entre lequel lequel le composant est <span class="em">render</span> (généré) et celui où leuel les données sont chargées. Effectivement, d'un point de vue UI (interface utilisateur), ce n'est pas idéal : l'utilisateur ne comprend pas que les données sont en train d'être chargées, et peut alors penser qu'uk y a un problème sur l'application.</p>
                    <p>Une pratique très répandue consiste à mettre un petit <span class="em">loader</span> pour <span class="em">signifier que les données vont bientôt s'afficher</span>. On pourrait mettre un simple texte "Chargement...", mais bon, on sait manier le CSS : autant s'amuser avec, non ?</p>
                    <p>Je vous propose de <span class="em">créer un simple <span class="html">Loader</span> en CSS</span>, directement dans le fichier <span class="html">utils.Atoms.jsx</span>. Pour cela, on a également besoin d'importer <span class="html">keyframes</span> depuis la bibliothèque <span class="html">styled-components</span>. Ce qui nous donne :</p>
<pre><code>import colors from './colors'
import styled, { keyframes } from 'styled-components'

const rotate = keyframes`
    from {
        transform: rotate(0deg);
    }

    to {
        transform: rotate(360deg);
    }
`

export const Loader = styled.div`
    padding: 10px;
    border: 6px solid ${colors.primary};
    border-bottom-color: transparent;
    border-radius: 22px;
    animation: ${rotate} 1s infinite linear;
    height: 0;
    width: 0;
`</code></pre>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Ici, ce CSS n'est pas l'objet de ce cours, donc pas de panique si vous ne comprenez pas tout : sachez juste qu'il s'agit d'une utilisation un peu détournée pour avoir un <span class="html">Loader</span> en CSS pur.</p>
                    </div>
                    <p>On va maintenant <span class="Em">utiliser le state pour afficher notre <span class="html">Loader</span></span>. Pour cela, on crée une variable <span class="html">isDataLoading</span> avec <span class="html">useState</span> :</p>
<pre><code>const [isDataLoading, setDataLoading] = useState(false)</code></pre>
                    <p>Dans le <span class="html">useEffect</span>, on vient <span class="em">modifier notre booléen</span> :</p>
<pre><code>useEffect(() =&gt; {
    setDataLoading(true)
    fetch(`http://localhost:8000/survey`)
        .then((response) =&gt; response.json())
        .then(({ surveyData }) =&gt; {
            setSurveyData(surveyData)
            setDataLoading(false)
        })
}, [])</code></pre>
                    <p>... ce ui nous permet ainsi de <span class="em">condititionner le rendu de notre composant</span> : le <span class="html">Loader</span> s'affiche tant que les données chargent, et une fois qu'on les a bien, le contenu de la question s'affiche à la place du <span class="html">Loader</span>.</p>
<pre><code>&lt;SurveyContainer&gt;
    &lt;QuestionTitle&gt;Question {questionNumber}&lt;/QuestionTitle&gt;
    {isDataLoading ? (
        &lt;Loader /&gt;
    ) : (
        &lt;QuestionContent&gt;{surveyData[questionNumber]}&lt;/QuestionContent&gt;
    )}
    ...
&lt;/SurveyContainer&gt;</code></pre>
                    <p>On a bien notre contenu qui s'affiche comme on le souhaitait !</p>
                    <figure>
                        <img src="../images/state_loading_React_1.png" alt="">
                        <figcaption>Pas mal, ce petit loader ?</figcaption>
                    </figure>
                    <p>Maintenant que nous avons le comportement que nous souhaitons, profitons-en pour implémenter une syntaxe un peu plus moderne, et pour gérer les erreurs :</p>
<pre><code>useEffect(() =&gt; {
    async function fetchSurvey() {
        try {
            const response = await fetch(`http://localhost:8000/survey`)
            const { surveyData } = await response.json()
            setSurveyData(surveyData)
        } catch(err) {
            console.log(err)
            setError(true)
        } finally {
            setDataLoading(false)
        }
    }
    fetchSurvey()
}, [])</code></pre>
                </article>
                <article>
                    <h2 id="useContext">Partagez vos données avec le Contexte et useContext :</h2>
                    <h3>Découvrez le Contexte dans React :</h3>
                    <p>Dans la famille des hooks, je veudx maintenant celui qui nous permet d'utiliser simplement le Contexte de React !</p>
                    <p>Contexte est un moyen de partage simplement les props entre les composants. Contexte est natif à React et ne nécessite pas d'installer quoi que ce soit de plus.</p>
                    <p>Précédemment, vous avez vu comment passer de simples props entre les composants parents et enfants, et comment utiliser les props pour faire remonter le state. Mais est-ce que vous imaginez ce que ça pourrait donner dans une application complexe, où pour passer une prop à un composant enfant, vous devez <span class="em">le faire par des dizaines de composants</span> parents qui n'ont eux-mêmes pas beosin de cette prop ?</p>
                    <figure>
                        <img src="../images/useContext_React_1.png" alt="">
                        <figcaption>Ça n'a pas l'air très efficace, n'est-ce pas ?</figcaption>
                    </figure>
                    <p>À l'inverse, Contexte nous permet de <span class="em">récupérer simplement nos datas sans avoir à tout passer manuellement</span>. Pour cela, on englobe le composant le plus haut dans l'arborescence de composants avec ce qu'on appelle un <span class="html">Provider</span>. Tous les composants enfants pourront alors se connecter au <span class="html">Provider</span> (littéralement en anglais, le "fournisseur") et aisi accéder aux props, sans avoir à passer par tous les composants intermédiaires. On dit que les composants enfants sont les <span class="html">Consumers</span> (consommateurs).</p>
                    <figure>
                        <img src="../images/useContext_React_2.png" alt="">
                        <figcaption>Cette fois-ci, le composant se branche tout simplement au Provider pour accéder au Contexte !</figcaption>
                    </figure>
                    <p>L'idée de passer simplement nos datas entre les composants est au coeur de nombreuses questions, afin que le code soit le plus performabr et lisible possible. Vous verre plus particulièrement des interrogations sur la manière de gérer le state de manière compréhensible et performante. On parle de <span class="em">State Management</span>. Vous en avez déjà entendu parler ?</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Comme son nom l'indique, le State Management cherche à <span class="em">optimiser la gestion du State</span>. Il existe des solutions dédiées telles que Redux (Redux nécessite d'installer une bibliothèque externe). Le Contexte permet de manipuler des variables liées au state. Mais il ne s'agit pas vraiment à proprement parler d'une solution de State Management. Contexte ne vient donc pas remplacer Redux, mais cohabite avec Redux dans la plupart des codebases. Comprendre le State Management est essentiem si vous souhaitez travailler sur une base de code en entreprise.</p>
                    </div>
                    <p>Avant les hooks, l'utilisation du Contexte était plus laborieuse, mais réjouissez-vous : vous avez mainteant le hook <span class="html">useContext</span>.</p>
                    <h3>Tirez profit du COntexte et de useContext :</h3>
                    <p>Maintenant que nous avons vu ce qu'était un OCntexte, utilisons-le dès maintenant dans notre application Shiny !</p>
                    <h4>Mettez en place un Contexte :</h4>
                    <p>Quelles données mettre dans le Contexte ? La documentation de React dit que "le Contexte est conçu pour partager des données qui peuvent être considérées comme <span class="em">globales</span>", et cite en exemple des données sur l'utilisateur actuellement authentifié, le thème, la langue utilisée, etc.</p>
                    <p>Nous allons commencer en douceur avec le contexte pour <span class="em">créer un Dark Mode (mode nuit) pour notre application</span>. Vous savez, ce thème de couleurs plutôt sombres qui permet de reposer devant l'écran.</p>
                    <p>Pour cela, nous allons <span class="em">créer un Footer dans lequel on ajoute un bouton</span>. Dans <span class="html">/components</span>, on crée donc un fichier <span class="html">Footer/index.jsx</span> au fonctionnement assez basique :</p>
<pre><code>import styled from 'styled-components'
import colors from '../../utils/style/colors'

function FooterContainer = styled.footer`
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    padding-top: 60px;
`

const NightModeButton = styled.button`
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: ${colors.secondary};
`

function Footer() {
    return (
        &lt;FooterContainer&gt;
            &lt;NightModeButton&gt;Changer de mode&lt;/NightModeButton&gt;
        &lt;/FooterContainer&gt;
    )
}

export default Footer</code></pre>
                    <p>Ce bouton dans notre Footer permettra de déclencher le dark mode de l'application. C'est mainteant le moment de <span class="em">créer notre Provider de Contexte pour le thème</span>. Pour cela, on va créer un dossier dédié au Contexte dans <span class="html">utils/context</span>. On crée un fichier <span class="html">index.jsx</span>.</p>
                    <p>On commence par importer <span class="html">{ createContext }</span> depuis <span class="html">react</span>, et initialiser notre Contexte pour le thème avec :</p>
<pre><code>export const ThemeContexte = createContext()</code></pre>
                    <p>Et on utilise ensuite <span class="html">ThemeContext</span> :</p>
<pre><code>export const ThemeProvider = ({ children }) =&gt; {
    const [theme, setTheme] = useState('light')
    const toggleTheme = () =&gt; {
        setTheme(theme === 'light' ? 'dark' : 'light')
    }

    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    )
}</code></pre>
                    <p>On a bien crée un composant qui nous permet de wrapper notre composant parent avec <span class="html">Provider</span> de thème.</p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>