<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Design Patterns - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#factory_method">Factory Method</a></li>
                        <li><a href="#strategy">Strategy</a></li>
                        <li><a href="#decorator">Decorator</a></li>
                        <li><a href="#composite">Composite</a></li>
                        <li><a href="#iterator">Iterator</a></li>
                        <li><a href="#template_method">Template Method</a></li>
                        <li><a href="#abstract_factory">Abstract Factory</a></li>
                        <li><a href="#builder">Builder</a></li>
                        <li><a href="#singleton">Singleton</a></li>
                        <li><a href="#proxy">Proxy</a></li>
                        <li><a href="#adapter">Adapter</a></li>
                        <li><a href="#bridge">Bridge</a></li>
                        <li><a href="#mediator">Mediator</a></li>
                        <li><a href="#observer">Observer</a></li>
                        <li><a href="#chain_of_responsibility">Chain of Responsibility</a></li>
                        <li><a href="#memento">Memento</a></li>
                        <li><a href="#command">Command</a></li>
                        <li><a href="#prototype">Prototype</a></li>
                        <li><a href="#state">State</a></li>
                        <li><a href="#visitor">Visitor</a></li>
                        <li><a href="#flyweight">Flyweight</a></li>
                        <li><a href="#facade">Facade</a></li>
                        <li><a href="#interpreter">Interpreter</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Design Patterns :</h1>
                    <p>Voici le guide d'apprentissage : <a href="../files/Design_Patterns_-_Tete_la_premiere.pdf" target="_blank">Design Patterns - Tête la première (PDF)</a>.</p>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <h3>Définition :</h3>
                    <p>Un pattern est un ensemble d'information auquel on a donné un nom et qui capture la structure essentielle d'une solution générale prouvée à un problème récurrent qui se produit dans divers contextes. Cette solution est générale dans le sens qu'elle s'adapte à chaque contexte.</p>
                    <h3>Composants :</h3>
                    <ul>
                        <li>
                            <p>Le <span class="em">nom</span> : grâce auquel on pourra en parler dans le design d'une application.</p>
                        </li>
                        <li>
                            <p>Le <span class="em">problème</span> : qui décrit quand appliquer le pattern. Il explique le problème et le xontexte et souvent des conditions qui doivent être remplie pour appliquer le pattern.</p>
                        </li>
                        <li>
                            <p>La <span class="em">solution</span> : décrit les éléments qui constitueront le design ainsi que leurs relations, responsabilités et collaborations. Un pattern étant une sorte de template, la solution ne décrit pas un design concret, une implémentation particulière mais un arrangement général d'objets et de classes qui résout le problème.</p>
                        </li>
                        <li>
                            <p>Les <span class="em">conséquences</span> : sont les résultats et les compromis résultant de l'application du pattern. Elles servent à évaluer et choisir l'une ou l'autre alternative et à comprendre les coûts et les bénéfices de l'usage du pattern. Par exemple, compromis espace-temps, problème d'implémentation, de choix du langage, impact sur la flexibilité, l'extensibilité et la portabilité du système.</p>
                        </li>
                    </ul>
                    <h3>Description :</h3>
                    <p>Un patterne est décrit par :</p>
                    <ul>
                        <li>
                            <p>Son <span class="em">nom</span> et sa <span class="em">classification</span>, ainsi que ses <span class="em">alias</span> (autres noms sous lequel il est connu).</p>
                        </li>
                        <li>
                            <p>Son <span class="em">but</span> : courte phrase décrivant ce que fait le pattern.</p>
                        </li>
                        <li>
                            <p>Sa <span class="em">motivation</span> : un exemple où ce pattern s'applique.</p>
                        </li>
                        <li>
                            <p>Son <span class="em">applicabilité</span> : dans quelles situations applique-t-on le pattern ? Comment les reconnaître ?</p>
                        </li>
                        <li>
                            <p>Sa <span class="em">structure</span> : réprésentation graphique (en OMT ou UML) des classes et/ou objets intervenants et éventuellement, diagrammes d'interactions illustrant la séquence des requêtes et la collaboration entre objets. Nous y inclurons la description des <span class="em">participants</span> (les classes et/ou objets intervenant dans le pattern et leurs responsabilités) et de leurs <span class="em">collaborations</span>.</p>
                        </li>
                        <li>
                            <p>Ses <span class="em">conséquences</span> : résultats et compromis. Quel aspect du système pourra désormais varier indépendamment ?</p>
                        </li>
                        <li>
                            <p>Ses problèmes d'<span class="em">implémentation</span> : indications, techniques, pièges à éviter, problèmes spécifiques au langage choisi, mais aussi description de variantes possibles.</p>
                        </li>
                        <li>
                            <p>Un <span class="em">exemple de code</span> : en C++ ou Java.</p>
                        </li>
                        <li>
                            <p>Les <span class="em">patterns associés</span> : avec quel autre pattern risque-t-on de rencontrer celui-ci ? En quoi diffère-t-il de tel autre ?</p>
                        </li>
                    </ul>
                    <h3>Classification :</h3>
                    <p>Les patterns sont classifiés selon deux critères : leur <span class="em">intention</span> et leur <span class="em">portée</span>.</p>
                    <p>L'<span class="em">intention</span> peut être :</p>
                    <ul>
                        <li>
                            <p><span class="em">créationelle</span> : lié à la cration d'objets.</p>
                        </li>
                        <li>
                            <p><span class="em">structurelle</span> : lié à la composition de classes ou d'objets.</p>
                        </li>
                        <li>
                            <p><span class="em">comportementale</span> : caractérisant la manière dont les classes ou objets interagissent et se partagent les responsabilités.</p>
                        </li>
                    </ul>
                    <p>La <span class="em">portée</span> spécifie si le pattern s'applique à des classes ou des objets.</p>
                    <ul>
                        <li>
                            <p>Les patterns de <span class="em">classes</span> traitent de la relation entre classes et leurs sous-classes via l'héritage. Ils représentent donc une relation statique, fixée à la compilation.</p>
                        </li>
                        <li>
                            <p>Les patterns d'<span class="em">objets</span> traitent de la relation entre objets qui peut être changée dynamiquement à l'exécution. Ils utiseront l'héritage, certes, mais surtout la composition et la délégation.</p>
                        </li>
                    </ul>
                    <h3>Catalogue des patterns (classiques) :</h3>
                    <dl>
                        <dt>Créationnels :</dt>
                        <dd>
                            <dl>
                                <dt>Classe :</dt>
                                <dd>
                                    <p>Factory Method (méthode Usine)</p>
                                </dd>
                                <dt>Objet :</dt>
                                <dd>
                                    <p>Abstract Factory (Usine abstraite)</p>
                                    <p>Builder</p>
                                    <p>Prototype</p>
                                    <p>Singleton</p>
                                </dd>
                            </dl>
                        </dd>
                        <dt>Structurel :</dt>
                        <dd>
                            <dl>
                                <dt>Classe :</dt>
                                <dd>
                                    <p>Adapter (Adapteur)</p>
                                </dd>
                                <dt>Objet :</dt>
                                <dd>
                                    <p>Adapter (Adapteur)</p>
                                    <p>Bridge</p>
                                    <p>Composite</p>
                                    <p>Decorator (Décorateur)</p>
                                    <p>Facade (Façade)</p>
                                    <p>Flyweight (Poids Mouche)</p>
                                    <p>Proxy</p>
                                </dd>
                            </dl>
                        </dd>
                        <dt>Comportemental :</dt>
                        <dd>
                            <dl>
                                <dt>Classe :</dt>
                                <dd>
                                    <p>Interpreter (Interprète)</p>
                                    <p>Template Method (Méthode Template)</p>
                                </dd>
                                <dt>Objet :</dt>
                                <dd>Chain of Responsability (Chaîne de Responsabilités)</dd>
                                <p>Command (Commande)</p>
                                <p>Iterator (Itérateur)</p>
                                <p>Mediator (Médiateur)</p>
                                <p>Memento (Mémento)</p>
                                <p>Observer (Observateur)</p>
                                <p>State (État)</p>
                                <p>Strategy (Stratégie)</p>
                                <p>Visitor (Visiteur)</p>
                            </dl>
                        </dd>
                    </dl>
                    <h3>Concepts Orientés Objets :</h3>
                    <h4>Héritage de classe et Héritage d'interface :</h4>
                    <p>Une <span class="em">classe</span> définit l'implémentation d'un objet : son état interne et l'implémentation de ses méthodes.</p>
                    <p>Le <span class="em">type</span> d'un objet, par contre se réfère seulement à son interface : l'ensemble des requêtes auxquelles il répond.</p>
                    <p>En héritant de plusieurs interfaces, un objet pourra avoir plusieurs types. Des objets de classes différentes peuvent avoir le même type si leurs classes implémentent toutes une même interface.</p>
                    <p>Dans l'héritage de classe, un objet hérite non seulement du type mais aussi de l'implémentation : c'est un mécanisme de partage de la structure et du code. C'est une manière facile d'obtenir une implémentation d'un nouvel objet en réutilisant celle d'un ancien.</p>
                    <p>L'héritage d'une interface indique quand un objet peut être utilisé à la place d'un autre. C'est la base même du polymorphisme.</p>
                    <p>En C++, l'héritahe d'une interface ne peut se faire qu'en héritant d'une classe abstraite sans membres et dont toutes les fonctions membres sont abstraites. L'héritage de classe en tant qu'héritage d'implémentation seule peut être réalisé approximativement par l'héritage privé.</p>
                    <h4>Règle 1 : Programmer en fonction d'une interface et non d'une implémentation :</h4>
                    <p>En manipulant des objets uniquement en fonction d'une interface, les clients ne connaissent pas les types spécifiques des objets utilisés ni les classes qui implémentent ces objets.</p>
                    <p>Bien sûr on ne peut pas se contenter d'utiliser des interfaces. Il faudra instancier des classes concrètes à un moment donné. En utilisant un pattern créationnel, on pourra abstraire le processus de création et associer de façon transparente une interface à son implémentation. Ces patterns font donc en sorte de programmer en fonction d'une interface.</p>
                    <h4>Règle 2 : Favoriser la Composition par rapport à l'Héritage :</h4>
                    <p>L'héritage et la composition permettent tous deux la réutilisation.</p>
                    <p>La réutilisation obtenue par héritage est dite réutilisation par <span class="em">boîte blanche</span> puisque la classe dérivée a accès à la structure interne de la classe de base.</p>
                    <p>La composition d'objet (des références à des objets sont membres d'une classe) conduit à une réutilisation en <span class="em">boîte noire</span> puisque la structure interne des objets n'est pas connue de la classe composée.</p>
                    <dl>
                        <dt>L'héritage</dt>
                        <dd>
                            <p>est statique,</p>
                            <p>est supporté par le langage, et donc facile à réaliser,</p>
                            <p>permet la modification de l'implémentation,</p>
                            <p></p>
                            <p>ne permet pas de modifier l'implémentation dont on hérite à l'exécution,</p>
                            <p>brise l'encapsulation en exposant la structure interne de la classe de base,</p>
                            <p>oblige souvent à modifier la sous-classe en cas de modification de la classe parent,</p>
                            <p>rend difficile la réutilisation de la classe dérivée (s'il faut légèrement la modifier, il faudra aussi modifier la classe parent).</p>
                        </dd>
                        <dt>La composition</dt>
                        <dd>
                            <p>est dynamique (les références sont acquises à l'exécution),</p>
                            <p>requiert un design soigné des interfaces auxquelles doivent se conformer les objets intervenant dans la composition,</p>
                            <p></p>
                            <p>respecte l'encapsulation</p>
                            <p>permet le remplacement d'un objet par un autre à l'exécution, modifiant ainsi l'implémentation dynamiquement,</p>
                            <p>permet de concentrer chaque classe sur une seule tâche,</p>
                            <p>permet de garder petites les hiérarchies de classes (moins de classes mais plus d'objets).</p>
                        </dd>
                    </dl>
                    <h4>La délégation :</h4>
                    <p>C'est une composition dan slaquelle la classe composée implémente les interfaces des objets qui la composent. Ces méthodes se contentent en réalité d'appeler la méthode correspondant sur l'objet membre.</p>
                    <p>Ainsi une classe <span class="em">Window</span> pourrait en cas d'héritage, dériver d'une classe <span class="em">Rectangle</span> qui contient une méthode <span class="em">surface()</span>. Dans ce cas <span class="em">Window</span> hérite de la méthode <span class="em">surface()</span>. On dit qu'une <span class="em">Window</span> est un <span class="em">Rectangle</span>.</p>
                    <p>Par contre, en délégation, on définira la classe <span class="em">Window</span> comme ayant (une référence à) un objet <span class="em">Rectangle</span> comme membre. La classe <span class="em">Window</span> implémentera elle-même la méthode <span class="em">surface()</span> qui appellera celle de <span class="em">Rectangle</span> : <span class="em">rect-&gt;surface();</span>.</p>
                    <p>La délégation montre qu'on peut toujours remplacer l'héritage par un mécanisme de composition.</p>
                    <h4>Design évolutif : Causes de changements :</h4>
                    <p>Pour maximiser la réutilisation du code, il faut prévoir les nouvelles exigences qui peuvent survenir et les changements aux exigences actuelles, puis réaliser un design tel que le système puisse évoluer de la manière prévue.</p>
                    <p>L'utilisation de design patterns appropriés permettra cette évolution. Voici une liste de motifs de redesign et les patterns à employer pour éviter la catastrophe :</p>
                    <ol>
                        <li>
                            <p><span class="em">Créer un objet en spécifiant sa classe :</span>Créer les objets de manière indirecte. Utiliser Abstract Factory, Factory Method ou Prototype.</p>
                        </li>
                        <li>
                            <p><span class="em">Dépendance d'opérations spécifiques</span> : Éviter de hard-coder les requêtes. Utiliser Chain of Responsability ou Command.</p>
                        </li>
                        <li>
                            <p><span class="em">Dépendance de la plate-forme hardware ou software</span> : Pour faciliter le portage : Utiliser Abstract Factory ou Bridge.</p>
                        </li>
                        <li>
                            <p><span class="em">Dépendance de l'implémentation, de la représentation d'un objet</span> : Cacher l'information : Utiliser Abstract Factory, Bridge, Memento ou Proxy.</p>
                        </li>
                        <li>
                            <p><span class="em">Dépendance d'un algorithme : Isoler l'algorithme. Utiliser Builder, Iterator, Strategy, Template Method ou Visitor.</span></p>
                        </li>
                        <li>
                            <p><span class="em">Couplage serré</span> : Empêche la réutilisation séparée. Utiliser Abstract Factory, Bridge, Chain of Responsibility, Command, Facade, Mediator ou Observer.</p>
                        </li>
                        <li>
                            <p><span class="em">Étendre les fonctionnalités par héritage</span> : Connaissance du parent, overhead, explosion de classes sont des problèmes. La composition, la délégation peuvent y remédier. La solution est souvent un mélange des deux on compose dans une sous-classe. Utiliser Bridge, Chain of Responsibility, Composite, Decorator, Observer ou Strategy.</p>
                        </li>
                        <li>
                            <p><span class="em">Impossibilité de modifier une classe de manière appropriée</span> : On n'a pas la source ou cela entraîne des modifications dans trop d'autres classes. Utiliser : Adapter, Decorator ou Visitor.</p>
                        </li>
                    </ol>
                    <h3>Désign évolutif : Ce qui doit varier :</h3>
                    <dl>
                        <dt>Créationnel :</dt>
                        <dd>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>Abstract Factory</td>
                                        <td>Familles d'objets</td>
                                    </tr>
                                    <tr>
                                        <td>Builder</td>
                                        <td>La manière de créer un objet complexe</td>
                                    </tr>
                                    <tr>
                                        <td>Factory Method</td>
                                        <td>La sous-classe de l'objet à instancier</td>
                                    </tr>
                                    <tr>
                                        <td>Prototype</td>
                                        <td>La classe de l'objet à instancier</td>
                                    </tr>
                                    <tr>
                                        <td>Singleton</td>
                                        <td>La seule instance de la classe</td>
                                    </tr>
                                </tbody>
                            </table>
                        </dd>
                        <dt>Structurel :</dt>
                        <dd>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>Adapter</td>
                                        <td>L'interface d'un objet</td>
                                    </tr>
                                    <tr>
                                        <td>Bridge</td>
                                        <td>L'implémentation d'un objet</td>
                                    </tr>
                                    <tr>
                                        <td>Composite</td>
                                        <td>La structure et la composition d'un objet</td>
                                    </tr>
                                    <tr>
                                        <td>Decorator</td>
                                        <td>Les responsabilités d'un objet (sans définir de sous-classes)</td>
                                    </tr>
                                    <tr>
                                        <td>Facade</td>
                                        <td>L'interface d'un sous-système</td>
                                    </tr>
                                    <tr>
                                        <td>Flyweight</td>
                                        <td>Le coût de stockage des objets</td>
                                    </tr>
                                    <tr>
                                        <td>Proxy</td>
                                        <td>La manière d'accéder à un objet; son emplacement</td>
                                    </tr>
                                </tbody>
                            </table>
                        </dd>
                        <dt>Comportemental :</dt>
                        <dd>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>Chain of Responsibility</td>
                                        <td>L'objet qui traite la requête</td>
                                    </tr>
                                    <tr>
                                        <td>Command</td>
                                        <td>Quand et comment on traite une requête</td>
                                    </tr>
                                    <tr>
                                        <td>Interpreter</td>
                                        <td>La grammaire et l'interprétation d'un langage</td>
                                    </tr>
                                    <tr>
                                        <td>Iterator</td>
                                        <td>Comment les éléments d'un agrégat sont traversés</td>
                                    </tr>
                                    <tr>
                                        <td>Mediator</td>
                                        <td>Quels objets interagissent et comment</td>
                                    </tr>
                                    <tr>
                                        <td>Memento</td>
                                        <td>Quelle information privée est stockée hors de l'objet et quand</td>
                                    </tr>
                                    <tr>
                                        <td>Observer</td>
                                        <td>Le nombre d'objet dépendant d'un autre objet; comment les objets dépendants restent à jour</td>
                                    </tr>
                                    <tr>
                                        <td>State</td>
                                        <td>Les états d'un objet</td>
                                    </tr>
                                    <tr>
                                        <td>Strategy</td>
                                        <td>Un algorithme</td>
                                    </tr>
                                    <tr>
                                        <td>Template Method</td>
                                        <td>Les étapes d'un algorithme</td>
                                    </tr>
                                    <tr>
                                        <td>Visitor</td>
                                        <td>Les opérations à appliquer à un objet (sans changer leur classe)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </dd>
                    </dl>
                    <h4>Comment choisir un design pattern :</h4>
                    <ul>
                        <li>
                            <p>Se rappeler comment les design pattens résolvent des problèmes de design.</p>
                        </li>
                        <li>
                            <p>Relire les buts de chaque pattern.</p>
                        </li>
                        <li>
                            <p>Étudier les relations entre patterns.</p>
                        </li>
                        <li>
                            <p>Étudier les patterns d'intention semblable (créationnels, structurels, comportementaux).</p>
                        </li>
                        <li>
                            <p>Examiner les causes de changements.</p>
                        </li>
                        <li>
                            <p>Prendre en considération ce qui peut varier.</p>
                        </li>
                    </ul>
                    <h4>Comment utiliser un pattern :</h4>
                    <ul>
                        <li>
                            <p>Lire le pattern de bout en bout.</p>
                        </li>
                        <li>
                            <p>Réétudier la structure, les participants et leurs collaborations.</p>
                        </li>
                        <li>
                            <p>Regarder l'exemple de code pour s'en inspirer.</p>
                        </li>
                        <li>
                            <p>Choisir les noms des participants en fonction de l'application et du pattern.</p>
                        </li>
                        <li>
                            <p>Définir les classes et modifier les classes existantes qui seraient affectées.</p>
                        </li>
                        <li>
                            <p>Définir des noms propres à l'application pour les méthodes du pattern.</p>
                        </li>
                        <li>
                            <p>Implémenter les méthodes en tenant compte des suggestions de la section Implémentation.</p>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="factory_method">Factory Method (Méthode Usine) :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Virtual Constructor (Constructeur Virtuel)</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Créationnel Classe</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Un framework d'applications qui peut gérer plusieurs documents, contient deux classes abstraites : <span class="em">Application</span> et <span class="em">Document</span>. Pour créer une application, on définira une sous-classe de chacun d'elles. Par exemple, pour un éditeur de texte, on définira <span class="em">ApplicationEditeur</span> et <span class="em">DocumentTexte</span>, pour une application de dessin, <span class="em">ApplicationDessin</span> et <span class="em">DocumentDessin</span>. La classe abstraite <span class="em">Application</span> prévoira une méthode <span class="em">creerDocument()</span> qui sera surdéfinie dans sa sous-classe afin de créer un document de la classe appropriée.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Factory Method quand :</p>
                            <ul>
                                <li>
                                    <p>une classe ne peut connaître à l'avance le type d'objets à créer.</p>
                                </li>
                                <li>
                                    <p>une classe désire que ce soit ses sous-classes qui spécifient les objets à créer.</p>
                                </li>
                                <li>
                                    <p>des classes délèguent une partie de leurs responsabilités à d'autres classes (classes aidantes) et que vous voulez que la connaissance de qui est la classe aidante soit locale à la classe qui délègue.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Produit</span> (Document, Room, Door, ...) : définit l'interface des objets à créer.</p>
                                </li>
                                <li>
                                    <p><span class="em">ProduitConcret</span> (DocumentDessin, EnchantedRoom, ...) : implémente cette interface.</p>
                                </li>
                                <li>
                                    <p><span class="em">Createur</span> (Application, MazeGame) : déclare les Factory Methods quirenvoient un Produit. Peut définir une implémentation par défaut. Il peut appeler Les Factory Methods pour créer des objets.</p>
                                </li>
                                <li>
                                    <p><span class="em">CreateurConcret</span> (ApplicationEditeur, BombedMazeGame, ...) : rédéfinit les Factory Methods pour renvoyer une instance d'un ProduitConcret.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences :</dt>
                        <dd>
                            <p>Avantage : élimine le besoin de lier des classes propres à l'application dans votre code.</p>
                            <p>Désavantage : on est obligé de définir une sous-classe pour redéfinir une Factory Method. A ne faire que si on doit de toutes façons définir cette sous-classe.</p>
                            <p>Une Factory Method augmente la flexibilité en donnant la possibilité à une sous-classe de créer une version étendue de l'objet désiré.</p>
                            <p>Les Factory Methods peuvent être appelées dans les clients et pas seulement dans le Créateur. C'est particulièrement utile pour connecter des hiérarchies parallèles. On les rencontre quand des classes délèguent certaines de leurs responsabilités à des classes aidantes (helper class).</p>
                        </dd>
                        <dt>Implémentation :</dt>
                    <dd>
                        <p>Les points suivants seront à prendre en considération :</p>
                        <ul>
                            <li>
                                <p>Deux variantes :</p>
                                <ol>
                                    <li>
                                        <p>Le Créateur est une classe abstraite.</p>
                                    </li>
                                    <li>
                                        <p>Le Créateur est une classe concrète qui définit une implémentation par défaut pour la Factory Method.</p>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <p>L'utilisation de Factory Methods paramétrées : Dans ce cas la Factory Method créera plusieurs sortes de produits, un paramètre indiquant laquelle. De manière à pouvoir renvoyer l'objet créé, tous les produits devront implémenter l'interface Produit. La forme générale en est la suivante :</p>
<pre><code>class Creator {
public:
    virtual Product * create(ProductId);
};
Product * Creator::create(ProductId id) {
    if (id == ME) return new MyProduct;
    if (id == YOU) return new YourProduct;
    ...
    return 0;
}</code></pre>
                                <p>La rédéfinition d'une telle méthode permettra d'utiliser des ids existants pour créer des produits différents mais aussi d'étendre la liste des ids.</p>
<pre><code>class MyCreator {
public:
    virtual Product * create(ProductId);
};
Product * MyCreator::create(ProductId id) {
    if (id == ME) return new YourProduct;
    if (id == YOU) return new MyProduct;
    // rôle de ME et YOU inversé
    if (id == HER) return HerProduct;
    return Creator::create(id);
    // appel du parent dans les autres cas
}</code></pre>
                            </li>
                            <li>
                                <p>L'utilisation de templates pour éviter de définir des sous-classes. Ceci n'est possible que si le langage le permet (C++ oui, Java non avant la version 1.5).</p>
<pre><code>class Creator {
public:
    virtual Product * create();
};

template &lt;class TheProduct&gt;
class StandardCreator: public Creator {
public:
    virtual Product * create();
};
template &lt;class TheProduct&gt;
Product * StandardCreator&lt;TheProduct&gt;::create() {
public:
    MyProduct();
    ...
};

template class StandardCreator&lt;MyProduct&gt; MyCreator;</code></pre>
                            </li>
                            <li>
                                <p>Respecter les conventions de noms de manière à rappeler par le nom de la méthode qu'il s'agit d'une factory method. Exemple : <span class="em">create()</span>, <span class="em">createProduct()</span>, <span class="em">doMakeProduct()</span> ...</p>
                            </li>
                        </ul>
                    </dd>
                    <dt>Exemple : La classe Maze :</dt>
                    <dd>
                        <p>Attention, l'exemple qui suit n'est qu'un exemple destiné à vous aider à comprendre l'utilité de ce pattern. Il n'est en rien une méthode à suivre pour créer un véritable jeu de labyrinthe. En effet, dans un tel jeu, on cherchera à varier le type de pièce et non, comme ci-dessous, à créer des pièces toutes d'un même type.</p>
                        <p>Voici les classes et sous-classes Clients de l'application MazeGame :</p>
                        <img src="../images/classes_clients_mazegame.png" alt="">
                        <p>Et celles de l'application :</p>
                        <img src="../images/classes_mazegame.png" alt="">
                        <h4>Comment faire d'autres Mazes ? Idée 1 - Sous-classer MazeGame, surdéfinir createMaze :</h4>
<pre><code>class MazeGame {

    public Maze createMaze() {
        Maze aMaze = new Maze();

        Room r1 = new Room(1);
        Room r2 = new Room(2);
        Door theDoor = new Door(r1, r2);

        aMaze.addRoom(r1);
        aMaze.addRoom(r2);

        r1.setSide(North, new Wall());
        r1.setSide(East, theDoor);
        r1.setSide(South, new Wall());
        r1.setSide(West, new Wall());

        r2.setSide(North, new Wall());
        r2.setSide(East, new Wall());
        r2.setSide(South, new Wall());
        r2.setSide(West, theDoor);

        return aMaze;
    }
}

class BombedMazeGame extends MazeGame {

    public Maze createMaze() {
        Maze aMaze = new Maze();

        Room r1 = new RoomWithABomb(1);
        Room r2 = new Room>ithABomb(2);
        Door theDoor = new Door(r1, r2);

        aMaze.addRoom(r1);
        aMaze.addRoom(r2);

        r1.setSide(North, new Wall());
        r1.setSide(East, theDoor);
        r1.setSide(South, new Wall());
        r1.setSide(West, new Wall());

        etc.
</code></pre>
                        <p><span class="em">À rejeter.</span> Il faut tout réécrire (en utilisant le cut and paste).</p>
                        <h4>Comment faire d'autres Mazes ? Idée 2 - Factory Method :</h4>
<pre><code>class MazeGame {

    public Maze makeMaze() { return new Maze(); }
    public Room makeRoom(int n) { return new Room(n); }
    public Wall makeWall() { return new Wall(); }
    public Door makeDoor(Room r1, Room r2) { return new Door(r1, r2); }

    public Maze createMaze() {
        Maze aMaze = makeMaze();

        Room r1 = makeRoom(1);
        Room r2 = makeRoom(2);
        Door theDoor = makeDoor(r1, r2);

        aMaze.addRoom(r1);
        aMaze.addRoom(r2);

        r1.setSide(North, makeWall());
        r1.setSide(East, theDoor);
        r1.setSide(South, makeWall());
        r1.setSide(West, makeWall());

        r2.setSide(North, makeWall());
        r2.setSide(East, makeWall());
        r2.setSide(South, makeWall());
        r2.setSide(West, theDoor);

        return aMaze;
    }

}

class BombedMazeGame extends MazeGame {

    public Room makeRoom(int n) {
        return new RoomWithABomb(n);
    }

    public Wall makeWall() {
        return new BombedWall();
    }

}</code></pre>
                        <h4>Comment faire d'autres Mazes ? Idée 3 - Factory Method dans le Produit. Mais est-ce encore le même pattern ?</h4>
<pre><code>class Room extends MapSite {
    public Room makeRoom() { return new Room(); }
    etc.
}

class RoomWithBomb extends Room {
    public Room makeRoom() { return new RoomWithBomb(); }
    etc.
}

etc.

class MazeGame {
    public Room roomMaker;
    etc.

    public MazeGame(Room rfactory) {
        roomMaker = rfactory;
    }

    public Maze createMaze() {
        Maze aMaze = new Maze();

        Room r1 = roomMaker.makeRoom(1);
        etc.
    }
}</code></pre>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="strategy">Strategy</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Policy</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Définir en les encapsulant, une famille d'algorithmes interchangeables. Laisser les algorithmes varier indépendamment des clients qui les utilisent.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Dans le design d'un éditeur de texte, il y a beaucoup de manières d'organiser le flux de texte en lignes. Inclure l'algorithme dans la classe qui en a besoin :</p>
                            <ul>
                                <li>
                                    <p>rend le client trop grand et difficile à maintenir surtout s'il y a plusieurs algorithmes,</p>
                                </li>
                                <li>
                                    <p>ne permet pas de n'instancier que les algorithmes utilisés,</p>
                                </li>
                                <li>
                                    <p>rend difficile l'ajout ou la modification d'algorithmes.</p>
                                </li>
                            </ul>
                            <p>On définira des classes qui encapsulent chacune un algorithme.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>Ce pattern sera utilisé si :</p>
                            <ul>
                                <li>
                                    <p>un grand nombre de classes diffèrent seulement par leur comportement. Le pattern permettra de ne configurer qu'une seule classe liée à plusieurs classes de comportement (stratégies).</p>
                                </li>
                                <li>
                                    <p>vous utilisez plusieurs variantes d'un algorithme, de manière, par exemple, à tenir en considération différents compromis espace-temps</p>
                                </li>
                                <li>
                                    <p>un algorithme utilise des données propres que le client devrait ignorer,</p>
                                </li>
                                <li>
                                    <p>une classe définit plusieurs comportements qui apparaissent dans des instructions conditionnelles multiples (<span class="em">if</span>s ou <span class="em">switch</span>.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_strategy.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Stratégie</span> : déclare une interface commune à tous les algorithmes. Le Contexte utilise cette interface pour appeler l'algorithme défini par Une StratégieConcrète.</p>
                                </li>
                                <li>
                                    <p><span class="em">StratégieConcrète</span> : implémente l'algorithme en respectant l'interface Stratégie.</p>
                                </li>
                                <li>
                                    <p><span class="em">Contexte</span> : est configuré avec une StratégieConcrète et maintient une référence à cet objet. Il pourra définie une interface propre à laisser la Stratégie accéder à ses données internes.</p>
                                </li>
                            </ul>
                            <p>Ils collaboreront de la manière suivante :</p>
                            <ul>
                                <li>
                                    <p>La Stratégie et le Contexte interagissent pour implémenter l'algorithme choisi. Le Contexte pourra passer à la StratégieConcrète toutes les données que celle-ci a besoin ou au contraire passer à la StratégieConcrète une référence à lui-même qui permettra à celle-ci d'obtenir du contexte, les données nécessaires, le moment voulu.</p>
                                </li>
                                <li>
                                    <p>Le contexte transmettra à la StratégieConcrète, les requêtes des Clients la concernant. Un Client créera une StratégieConcrète et la passe au Contexte. Après cela, le Client n'interagit plus qu'avec le Contexte.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences :</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Définit une famille d'algorithmes prêts à être réutilisés.</p>
                                </li>
                                <li>
                                    <p>Présente une alternative au fait de définir des sous-classes. On utilise Strategy plutt que de dériver des sous-classes du Contexte. Cette méthode de faire aurait hard-codé l'algorithme dans les sous-classes du Contexte, le rendant plus difficile à comprendre et à maintenir. De plus, on ne pourrait pas changer d'algorithme dynamiquement.</p>
                                </li>
                                <li>
                                    <p>Élimine les instructions conditionnelles.</p>
                                </li>
                                <li>
                                    <p>Offre un choix d'implémentations différentes d'un même comportement.</p>
                                </li>
                            </ul>
                            <p>Désavantages :</p>
                            <ul>
                                <li>
                                    <p>Les clients doivent savoir en quoi les diverses stratégies varient, pour pouvoir en choisir la version appropriée.</p>
                                </li>
                                <li>
                                    <p>Le pattern impose un overhead de communication entre Contexte et Stratégie. Des stratégies concrètes simples pourraient ne pas employer (tous) les paramètres passés. Si ce point est critique, il faudra plutôt coupler fortement Contexte et Stratégie.</p>
                                </li>
                                <li>
                                    <p>Le pattern implique la création d'un plus grand nombre d'objets. Ce désavantage peut être minimisé si les stratégies n'ont pas de données internes (ou peu). Le pattern Flyweight montre comment ceci peut se faire.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation :</dt>
                        <dd>
                            <p>On prendra en considération les points suivants, lors de l'implémentation du pattern.</p>
                            <ol>
                                <li>
                                    <p><span class="em">La définition des interfaces Contexte et Stratégie</span> devra permettre à une StratégieConcrète, un accès efficace aux données utiles provenant du contexte et inversement.</p>
                                    <p>Première approche : le Contexte passe des données en paramètres aux opérations de la Stratégie. Avantage : les deux classes restent découplées. Désavantage : des données inutiles peuvent être passées.</p>
                                    <p>Deuxième approche : Le contexte passe en argument une référence à lui-même et c'est la StratégieConcrète qui requiert les données nécessaires en appelant les méthodes du Contexte. Ou encore, la Stratégie garde une référence à son Contexte, auquel cas, rien ne doit être passé. Avantage : La stratégie Concrète ne requiert que ce qu'elle a besoin. Désavantage : le Contexte doit avoir une interface plus élaborée pour permettre à la StratégieConcrète d'obtenir ces renseignements, ce qui couple davantage les deux classes.</p>
                                </li>
                                <li>
                                    <p><span class="em">L'utilisation du template</span> : en C++, des templates peuvent être utilisés pour configurer une classe avec une stratégie :</p>
<pre><code>template &lt;class AStrategy&gt;
class Context {
    void Operation() { theStrategy.doAlgorithm(); }
    // ...
private:
    AStrategy theStrategy;
};

class MyStrategy {
public:
    void doAlgorithm();
};

template class Context&lt;MyStrategy&gt; MyContext;</code></pre>
                                    <p>Cette technique ne sera utilisée que si :</p>
                                    <ul>
                                        <li>
                                            <p>la stratégie peut être choisie dès la compilation,</p>
                                            <li>
                                                <p>elle ne doit pas être modifiée à l'exécution.</p>
                                            </li>
                                        </li>
                                    </ul>
                                    <p>Dans ce cas il n'y a pas d'interface Stratégie, et, comme la liaison entre Contexte et Stratégie est statique, l'efficacité s'en trouvera améliorée.</p>
                                </li>
                                <li>
                                    <p><span class="em">Rendre les objets Stratégie optionnels</span> : Le Contexte pourrait implémenter un algorithme simple, par défaut et tester s'il possède une référence à un objet Stratégie. S'il y en a un, il y fait appel; sinon il utilise le comportement par défaut. L'avantage pour les Clients est de ne pas utiliser d'objets Stratégie sauf s'ils ne sont pas satisfaits du comportement par défaut.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple : 1<sup>ère</sup> version :</dt>
                        <dd>
                            <p>Le Contexte est :</p>
<pre><code>public class SortedList {
    public SortedList(Sort theSort) {
        _sort = theSort;
    }
    public void add(String s) {
        _theData[_nombreElements++] = s;
        _sort.sort(_theData);
    }
    public void print() {
        int i;
        for (i = 0; i &lt; _nombreElements; i++)
            System.out.println(_theData[i]);
    }
    private String[] _theData = new String[100];
    private int _nombreElements = 0;
    private Sort _sort;
}</code></pre>
                    <p>La Stratégie :</p>
<pre><code>public interface Sort {
    public void sort(String[] data);
}</code></pre>
                            <p>Une StratégieConcrète :</p>
<pre><code>public class ShellSort implements Sort {
    public void sort(String[] data) {
        // code removed
    }
}</code></pre>
                            <p>Le client pourra faire :</p>
<pre><code>public class SortClient {
    public static void main(String[] args) {
        SortedList students = new SortedList(new ShellSort());
        students.add("michel");
        students.add("pierre");
        students.add("paul");
        students.add("jacques");
        students.print();
    }
}</code></pre>
                        </dd>
                        <dt>Exemple : 2<sup>ème</sup> version :</dt>
                        <dd>
                            <p>Nous avons indiqué les changements en <span class="html em">gras</span>.</p>
                            <p>Le Contexte est :</p>
<pre><code>public class SortedList {
    public SortedList(Sort theSort) {
        _sort = theSort;
    }
    public void add(String s) {
        _theData[_nombreElements++] = s;
        _sort.sort(<span class="html em">this</span>);
    }
    <span class="em">String[] getData() { return _theData; }</span>
    public void print() {
        int i;
        for (i = 0; i &lt; _nombreElements; i++)
            System.out.println(_theData[i]);
    }
    private String[] _theData = new String[100];
    private int _nombreElements = 0;
    private Sort _sort;
}</code></pre>
                            <p>La Stratégie :</p>
<pre><code>public interface Sort {
    public void sort(<span class="html em">SortedList lst</span>);
}</code></pre>
                            <p>Une StratégieConcrète :</p>
<pre><code>public class ShellSort implements Sort {
    public void sort(<span class="html em">SortedList lst</span>) {
        <span class="em">String[] table = lst.getData();</span>
        // code removed
    }
}</code></pre>
                            <p>Le client pourra faire :</p>
<pre><code>public class SortClient {
    public static void main(String[] args) {
        SortedList students = new SortedList(new ShellSort());
        students.add("michel");
        students.add("pierre");
        students.add("paul");
        students.add("jacques");
        students.print();
    }
}</code></pre>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="decorator">Decorator :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Wrapper</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Considérons une zone de texte (<span class="em">TextView</span>). Elle peut avoir un ascenseur de côté, un ascenseur en bas, un bord 2D (Flat), un bord 3D, une combinaison des précédents ou rien du tout.</p>
                            <p>Ceci conduit, par héritage à créer 12 classes :</p>
<pre><code>TextView
TextViewWithSideScrollbar
TextViewWithBottomScrollbar
TextViewWithSideAndBottomScrollbar
TextViewWithFlatBorder
TextViewWithFlatBorderAndSideScrollbar
TextViewWithFlatBorderAndBottomScrollbar
TextViewWithFlatBorderAndSideAndBottomScrollbar
TextViewWith3DBorder
TextViewWith3DBorderAndSideScrollbar
TextViewWith3DBorderAndBottomScrollbar
TextViewWith3DBorderAndSideAndBottomScrollbar</code></pre>
                            <p>Pour éviter cette explosion de classe, on peut, dans une <span class="em">première approche</span>, utiliser la composition :</p>
                            <img src="../images/premiere_approche_decorator.png" alt="">
<pre><code>public class TextView {
    Border myBorder;
    Scrollbar verticalBar;
    Scrollbar horizontalBar;

    public void draw() {
        myBorder.draw();
        verticalBar.draw();
        horizontalBar.draw();
        // code to draw itself
    }
...
}</code></pre>
                            <p>La classe <span class="em">Border</span> pourra être une simple interface. La classe <span class="em">NoBorder</span> implémentera <span class="em">draw()</span> comme une fonction ne faisant rien :</p>
<pre><code>public class NoBorder implements Border {
    public void draw() { }
}</code></pre>
                            <p>Pour la classe <span class="em">Scrollbar</span>, c'est une autre approche qui est présentée : La classe <span class="em">Scrollbar</span> est une classe concrète qui implémenter <span class="em">draw()</span> comme ne faisant rien. Ses sous-classes redéfiniront donc cette méthode.</p>
                            <p>Cette façon de procéder évite l'explosion de classes mais <span class="em">TextView</span> doit être averti de toute modification. De plus si on désire introduire d'autres types d'ornements, il faut modifier la classe <span class="em">TextView</span>.</p>
                            <p>La <span class="em">deuxième approche</span> consiste à utilser des Décorateurs :</p>
                            <img src="../images/deuxieme_approche_decorator.png" alt="">
                            <p>Au niveau d'un diagramme d'objets on aura :</p>
                            <img src="../images/diagramme_objets_decorator.png" alt="">
                            <p>Dans cette solution, on ne parle pas de <span class="em">Border</span> ni de <span class="em">Scrollbar</span> dans <span class="em">TextView</span>. Si on ajoute d'autres types d'ornements, <span class="em">TextView</span> ne doit pas être modifié.</p>
                            <p>Chaque <span class="em">VisualDecorator</span> aura un constructeur avec un paramètre de type <span class="em">VisualComponent</span>. Cela permettra d'emboîter les décorations.</p>
                            <p>Le diagramme d'objet ci-dessus s'obtiendra par :</p>
<pre><code>VisualComponent zone = new 3DBorder(new VerticalScrollbar(new TextView()));</code></pre>
                            <p>La méthode <span class="em">draw()</span> sera abstraite dans <span class="em">VisualComponent</span> qui pourra ne définir qu'une interface définissant les méthodes de dessin et de gestion des événments.</p>
                            <p>Dans <span class="em">VisualDecorator</span>, <span class="em">draw()</span> appellera la méthode <span class="em">draw()</span> de sa <span class="em">component</span> :</p>
<pre><code>public void draw() {
    component.draw();
}</code></pre>
                            <p>Chaque décorateur concret fera appel à la méthode <span class="em">draw()</span> de son parent avant de se dessiner lui-même :</p>
                            <p>Par exemple dans <span class="em">border</span> on aura :</p>
<pre><code>public void draw() {
    super.draw();
    drawBorder();
}</code></pre>
                            <p>Chaque sous-classe de <span class="em">Border</span> redéfinira la méthode <span class="em">drawBorder()</span>.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Decorator :</p>
                            <ul>
                                <li>
                                    <p>pour ajouter des responsabilités à des objets de manière dynamique et transparente et donc sans affecter d'autres objets.</p>
                                </li>
                                <li>
                                    <p>Pour des responsabilités qui doivent pouvoir être retirées.</p>
                                </li>
                                <li>
                                    <p>Quand l'héritage est impraticable parce que donnant lieu à une explosion de classes ou parce que la définition de la classe est cachée ou indisponible pour définir des sous-classes (exemple : final en Java, une méthode qu'on voudrait virtuelle ne l'est pas, en C++, ...).</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_decorator.png" alt="">
                            <p>Et au niveau Objets :</p>
                            <img src="../images/structure_participants_collaborations_objets_decorator.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Component</span> : (VisualComponent) définit l'interface pour les objets à qui on peut ajouter des responsabilités dynamiquement.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteComponent</span> : (TextView) définit un objet auquel de nouvelles responsabilités pourront être attachées.</p>
                                </li>
                                <li>
                                    <p><span class="em">Decorator</span> : (VisualDecorator) maintient une référence à un objet de type Component et définit une interface conforme à l'interface Component.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteDecorator</span> : (FlatBorder, 3DBorder, HorizontalScrollbar, ...) ajoute des responsabilités à sa Component.</p>
                                </li>
                            </ul>
                            <p>Ils collaborent de la manière suivante :</p>
                            <ul>
                                <li>
                                    <p>Le Decorator transmet les requêtes à sa Component. Éventuellement, avant et après cette transmission, il effectue d'autres opérations.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences :</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Plus de flexibilité qu'avec l'héritage qui est statique. Celui-ci donne lieu à une explosion de classes et rend le système plus complexe. À l'aide de divers Decorator, on pourra facilement mixer les responsabilités. Une propriété pourra même être donnée deux fois, par exemple un double bord.</p>
                                </li>
                                <li>
                                    <p>Évite de devoir prévoir toutes les responsabilités possibles à ajouter, tôt dans la hiérarchie des classes. Plutôt que d'avoir une classe immense prévoyant tout, on aura une classe simple et on y ajoutera des responsabilités à l'aide de Decorator simple eux aussi. Ainsi une application ne devra pas gérer des responsabilités dont elle n'a pas besoin.</p>
                                </li>
                                <li>
                                    <p>Permet de définir facilement de nouvelles responsabilités en ajoutant de nouveaux Decorator et ce indépendamment de la classe décorée.</p>
                                </li>
                            </ul>
                            <p>Désavantages :</p>
                            <ul>
                                <li>
                                    <p>Un Decorator et sa Component ne sont pas identiques. L'utilisation d'un Decorator ajouté dynamiquement ne permet plus de tester si un objet est idnetique à l'objet de départ puisque cet objet une fois décoré n'est plus le même objet.</p>
                                </li>
                                <li>
                                    <p>Ce pattern donne lieu à une multitude de petits objets qui ne diffèrent que par la manière dont ils sont connectés. Ceci peut conduire à des difficultés pour comprendre et débugger le système.</p>
                                </li>
                            </ul>
                        </dd>
                    <dt>Implémentation :</dt>
                    <dd>
                        <p>Les points suivant seront à prendre en considération :</p>
                        <ol>
                            <li>
                                <p>La conformance à l'interface : Un objet Decorator doit avoir une interface conforme à celle de la Component qu'il décore.</p>
                            </li>
                            <li>
                                <p>La classe abstraite Decorator peut parfois être omise. C'est le cas si on ne doit ajouter qu'une seule responsabilité.</p>
                            </li>
                            <li>
                                <p>Garder la classe Component légère. Elle doit surtout définir une interface commune aux composantes et aux décorateurs et non stocker de l'information. Sinon, les décorateurs seront trop lourds. Il ne faut pas mettre un grand nombre de fonctionnalités dans une Component sinon tous les objets en hériteront même s'ils n'en ont pas besoin.</p>
                            </li>
                            <li>
                                <p>Un Decorator change la peau d'un objet pas ses tripes. Une autre possibilité de modifier un comportement est de changer les tripes de l'objet. Ceci se fait avec le pattern Strategy. On préférera ce dernier pattern si la classe Component est d'office lourde. (Notre version 1 de la motivation est en fait une utilisation de Strategy). Dans ce cas l'objet devra connaître les extensions possibles (comme nous l'avons fait remarquer dans cette version). L'avantage de Strategy dans le cas d'une Component lourde est que les stratégies peuvent être légères.</p>
                            </li>
                        </ol>
                        <h3>Exemple :</h3>
                        <p>Montrons comment implémenter l'exemple de la motivation en C++.</p>
<pre><code>class VisualComponent {
    VisualComponent();
    virtual void draw();
    virtual void resize();
    // ...
};</code></pre>
                        <p>La classe <span class="em">TextView</span> sera une sous-classe de la précédente.</p>
<pre><code>class VisualDecorator : public VisualComponent
public:
    VisualDecorator(VisualComponent * component) {
        _component = component;
    }
    virtual void draw();
    virtual void resize();
    // ...
private:
    VisualComponent * _component;
};

void VisualDecorator::draw() {
    _component-&gt;draw();
}
void VisualDecorator::resize() {
    _component-&gt;resize();
}

class Border : public VisualDecorator {
public:
    Border(VisualComponent * component, int borderWidth) : VisualDecorator(component) {
        _width = borderWidth;
    }
    virtual void draw();
protected:
    virtual void drawBorder (int)=0;
private:
    int _with;
};

void Border::draw() {
    VisualDecorator::draw();
    drawBorder(_width);
}</code></pre>
                        <p>Les sous-classes de <span class="em">Border</span> rédéfiniront <span class="em">drawBorder(int)</span> de manière appropriée.</p>
                        <p>On pourra alors faire :</p>
<pre><code>VisualComponent * monTexte = new TextView;</code></pre>
                        <p>Puis plus tard, quand le besoin s'en fait sentir :</p>
<pre><code>MonTexte = new FlatBorder(new VerticalScrollbar(monTexte, 1));</code></pre>
                        <h3>Autre exemple : les Streams en Java :</h3>
                        <p>Les classes d'I/O en Java sont en réalité des classes Decorator :</p>
                        <img src="../images/classes_IO_Java_decorator.png" alt="">
<pre><code>import java.io.*;
import sdsu.io.ASCIIInputStream;
class readingFileExample {
    public static void main(String[] args) throws Exception {
        FileInputStream inputFile;
        BufferedInputStream bufferedFile;
        ASCIIInputStream cin;

        inputFile = new FileInputStream("ReadingFileExample.java");
        bufferedFile = new BufferedInputStream(inputFile);
        cin = new ASCIIInputStream(bufferedFile);

        System.out.println(cin.readWord());

        for(int k = 1; k &lt; 4; k++)
            System.out.println(cin.readLine());
    }
}</code></pre>
                        </dd>
                        <dt>Patterns reliés :</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Strategy est, comme on l'a vu, une alternative pour modifier le comportement d'un objet. Il en change les tripes au lieu de la peau.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="composite">Composite :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Composer des objets en une structure arborescente afin de représenter des hiérarchies partie - tout. Composite permet aux Clients de traiter uniformément les objets individuels et les compositions de ces objets.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Considérons un système de fenêtrage. Le problème à résoudre est de gérer les éléments contenus dans la fenêtre. Certains sont des éléments simples : boutons, zone de texte, ... d'autres des conteneurs : panels, canvas, ...</p>
                            <p>Nous allons considérer trois approches différentes, partant d'une approche naïve et peu flexible pour arriver à un design conforme au pattern Composite.</p>
                            <h3>1ère approche :</h3>
<pre><code>class Window {
    Buttons[] myButtons;
    Menus[] myMenus;
    TextAreas[] myTextAreas;
    WidgetContrainer[] myContainers;

    public void update() {
        if (myButtons != null)
            for (int k = 0; k &lt; myButtons.length; k++)
                myButtons[k].refresh();
        if (myMenus != null)
            for (int k = 0; k &lt; myMenus.length; k++)
                myMenus[k].display();
        if (myTextAreas != null)
            for (int k = 0; k &lt; myTextAreas.length; k++)
                myTextAreas[k].refresh();
        if (myContainers != null)
            for (int k = 0; k &lt; myContainers.length; k++)
                myContainers[k].updateElements();
        etc.
    }

    public void fooOperation() {
        if (blah) etc.
        if (blah) etc.
    }
}</code></pre>
                            <h3>2ème approche :</h3>
                            <img src="../images/deuxieme_approche_composite.png" alt="">
<pre><code>class Window {
    GUIWidgets[] myWidgets;
    WidgetContainer[] myContainers;

    public void update() {
        if (myWidgets != null)
            for (int k = 0; k &lt; myWidgets.length; k++)
                myWidgets[k].update();
        if (myContainers != null)
            for (int k = 0; k &lt; myContainers.length; k++)
                myContainers[k].updateElements();
        etc.
    }
}</code></pre>
                            <h3>3ème approche : le pattern Composite :</h3>
                            <img src="../images/troisieme_approche_composite.png" alt="">
                            <p>Dans cette approche :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Component</span> implémente des versions par défaut des opérations (<span class="em">update()</span>, ...).</p>
                                </li>
                                <li>
                                    <p><span class="em">Button</span>, <span class="em">Menu</span>, <span class="em">TextArea</span> redéfinissent les opérations en questions selon leurs besoins.</p>
                                </li>
                                <li>
                                    <p><span class="em">WidgetContainer</span> devra redéfinir toutes les méthodes de <span class="em">Component</span> et définira des opérations propres pour gérer l'ajout, la suppression de composants.</p>
                                </li>
                            </ul>
<pre><code>class WidgetContainer {
    Component[] myComponents;

    public void update() {
        if (myComponents != null)
            for (int k = 0; k &lt; myComponents.length; k++)
                myComponents[k].update();
    }
}</code></pre>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Composite quand :</p>
                            <ul>
                                <li>
                                    <p>on désire représenter des hiérarchies parties - tout.</p>
                                </li>
                                <li>
                                    <p>on veut que les clients ignorent la différence entre une composition d'objet et un objet individuel.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_composite.png" alt="">
                            <p>Ce qui donne le diagramme d'objet :</p>
                            <img src="../images/structure_participants_collaborations_objets_composite.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Component</span> :</p>
                                    <ul>
                                        <li>
                                            <p>déclare l'interface des objets de la composition.</p>
                                        </li>
                                        <li>
                                            <p>implémente un comportement par défaut pour les méthodes de cette interface.</p>
                                        </li>
                                        <li>
                                            <p>déclare une interface d'accès et de gestion des composantes enfants.</p>
                                        </li>
                                        <li>
                                            <p>éventuellement déclare et implémente une interface d'accès à la composite parent.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Leaf</span> :</p>
                                    <ul>
                                        <li>
                                            <p>représente les objets individuels de la composition. Ceux-ci n'ont pas d'enfants.</p>
                                        </li>
                                        <li>
                                            <p>définit le comportement de ces objets individuels.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Composite</span> :</p>
                                    <ul>
                                        <li>
                                            <p>définit le comportement des objets composés, ceux qui ont des fils dans la hiérarchie.</p>
                                        </li>
                                        <li>
                                            <p>implémente les méthodes relatives aux enfants déclarées dans Component.</p>
                                        </li>
                                        <li>
                                            <p>stocke les composantes enfants.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> :</p>
                                    <ul>
                                        <li>
                                            <p>manipule les objets de la composition via l'interface de Component.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <p>Les collaborations entre objets se feront comme suit :</p>
                            <ul>
                                <li>
                                    <p>Les Clients utilisent l'interface de Component pour interagir avec les objets de la structure composite. Pour une feuille (Leaf), les requêtes seront traitées directement. Pour un objet Composite, les requêtes seront généralement transmises aux composantes enfants, en y ajoutant peut-être un comportement propre au Composite.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Le pattern Composite :</p>
                            <ul>
                                <li>
                                    <p>définit des hiérarchies de classes permettant de composer des objets primitifs en objets complexes qui peuvent à leur tour être composés et ainsi de suite.</p>
                                </li>
                                <li>
                                    <p>rend les Clients simples, car les objets individuels et les objets composites, étant interchangeables, seront traités uniformément.</p>
                                </li>
                                <li>
                                    <p>rend facile l'ajout de nouvelles composantes. Il suffit de définir de nouvelles classes de feuilles (Leaf) ou de Composite.</p>
                                </li>
                                <li>
                                    <p>Oblige à tester nous même, à l'exécution, le type réel des composantes, si nous ne voulons pas permettre que des composantes de tous types soient rajoutées.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Les références explicites au parent</span> : cela simplifie la traversée de la hiérarchie et permet la suppression de composantes de manière aisée. Cela permettra également d'employer le pattern Chain of Responsibility, si cela s'avère utile.</p>
                                    <p>La référence au parent sera définie dans la classe Component, ainsi que les opérations la gérant.</p>
                                    <p>Dans le code, il faudra faire en sorte que le parent d'une composante a bien cette composante comme enfant. Ceci se fera en ne modifiant la référence au parent que dans les méthodes <span class="em">add()</span> et <span class="em">remove()</span> de la classe Composite.</p>
                                </li>
                                <li>
                                    <p><span class="em">Le partage des composantes</span>, en vue de limiter les besoins en espace. Si une composante ne peut avoir qu'un seul parent, c'est difficile à réaliser et permettre plusieurs parents à une composante conduit à pas mal d'ambiguïté. La seule manière d'opérer sera d'employer le pattern Flyweight.</p>
                                </li>
                                <li>
                                    <p><span class="em">Maximiser l'interface Component.</span> Cette classe doit, pour rendre tous les objets interchangeables, déclarer le plus de méthodes communes possibles. Component définira une implémentation par défaut pour chacune d'elles. Les feuilles et objets composites redéfiront celles dont ils ont besoin. Par exemple, une méthode <span class="em">listeDesEnfants()</span> aura pour comportement par défaut dans Component de renvoyer une liste vide. Ainsi les feuilles pourront se contenter d'hériter de ce comportement tandis que les objets composites le redéfiniront.</p>
                                </li>
                                <li>
                                    <p><span class="em">Déclarer les opérations de gestion des enfants.</span> Ces opérations seront implémentées dans la classe Composite. Mais où faut-il les déclarer ?</p>
                                    <ul>
                                        <li>
                                            <p>Dans Component : augmente la transparence. Les feuilles et les composites seront traités uniformément par le Client. Mais un Client, ne sachant pas si l'objet est un composite ou non, pourrait essayer d'ajouter des composantes à une feuille.</p>
                                        </li>
                                        <li>
                                            <p>Dans Composite : augmente la sécurité au détriment de la transparence.</p>
                                        </li>
                                    </ul>
                                    <p>Une approche permettant en C++ de tout déclarer dans Component, est de définir une méthode <span class="em">getComposite()</span> dans Component. Par défaut, elle renverra un pointeur nul. La classe Composite redéfinira cette méthode pour renvoyer un pointeur sur lui-même (<span class="em">this</span>). Ceci permettra de tester si l'objet est un Composite et d'utiliser le Composite renvoyé pour appeler les méthodes <span class="em">add()</span> ou <span class="em">remove()</span>. Mais la transparence n'est pas complète puisqu'il faut tester si l'objet est ou non un Composite.</p>
                                    <p>Une autre approche est de définir un <span class="em">add()</span> et un <span class="em">remove()</span> par défaut dans Component. En faire par défaut des méthodes ne faisant rien est dangereux car, si le programme essaie d'ajouter ou de retirer une composante à une feuille, il est probable qu'il s'agit d'un bug ! Il est donc préférable de générer par défaut une erreur dans ces méthodes.</p>
                                    <p>Le cas de <span class="em">remove()</span> peut se résoudre autrement : Si la composante maintient une référence à son parent, on pourrait songer à donner une autre signification à <span class="em">remove()</span> : se supprimer de la liste des enfants de son parent.</p>
                                </li>
                                <li>
                                    <p><span class="em">La liste des Composantes doit-elle être mise dans Component ?</span> Ceci entraînerait une perte de place dans les feuilles (qui n'en ont pas besoin) et n'est donc envisageable que si le système comporte peu de feuilles.</p>
                                </li>
                                <li>
                                    <p><span class="Em">L'ordre des enfants.</span> Certaines applications imposeront un ordre sur les enfants, d'autres aucun. Pour permettre l'accès aux enfants dans l'ordre voulu, il est utile d'envisager le pattern Iterator.</p>
                                </li>
                                <li>
                                    <p><span class="em">Mise d'information en Cache.</span> Si on traverse ou recherche fréquemment, cela peut être utile. Le Cache sera invalidé si la structure est modifiée (ajout ou suppression de composantes). Il faudra dès lors, définir une interface permettant à une Composite de savoir que son Cache est invalide.</p>
                                </li>
                                <li>
                                    <p><span class="em">Qui supprimera les composantes ?</span> Sans Garbage Collection (C++), le Composite devra, lors de sa destruction, détruire ses composantes. La seule exception est quand les feuilles sont immuables et peuvent être partagées.</p>
                                </li>
                                <li>
                                    <p><span class="em">Quelle structure de données utiliser pour stocker les composantes ?</span> Le choix dépendra de l'efficacité.</p>
                                </li>
                            </ol>
                            <h3>Exemple :</h3>
<pre><code>import java.util.Iterator;
import java.util.Vector;

public abstract class Component {
    protected Component parent;

    public Component getParent() {
        return parent;
    }
    public void add(Component c) throws NotCompositeException {
        throw new NotCompositeException();
    }
    public void remove(Component c) throws NotCompositeException {
        throw new NotCompositeException();
    }
    public Iterator&lt;Component&gt; listeDesEnfants() {
        return null;
    }
    public abstract void update();
}

class WidgetContainer extends Compnent {
    private Vector&lt;Component&gt; myComponents;

    public void update() {
        if (myComponents != null) {
            Iterator&lt;Component&gt; list = myComponents.iterator();
            while(list.hasNext())
                list.next().update();
        }
    }
    public Iterator&lt;Component&gt; listeDesEnfants() {
        return myComponents.iterator();
    }
    public void add(Component c) {
        myComponents.addElement(c);
        c.parent = this; // accessible : this == Component aussi !
    }
    public void remove(Component c) {
        if (c.getParent() == this) {
            myComponents.removeElement(c);
            c.parent = null;
        }
    }
}</code></pre>
                            <p>Remarque : Comme on peut le constater dans le code, si on avait voulu implémenter l'opération <span class="em">remove()</span> comme signifiant se supprimer de la liste des enfants de son parent, on aurait du déclarer la liste des enfants (<span class="em">myComponents</span>) dans <span class="em">Component</span>.</p>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Souvent le lien vers le parent est utilisé pour créer une Chain of Responsibility.</p>
                                </li>
                                <li>
                                    <p>Decorator est souvent employé avec Composite, en leur donnant une classe parent commune : Component, dont l'interface devra l'interface devra alors être implémentée par Decorator.</p>
                                </li>
                                <li>
                                    <p>Flyweight pourra être employé pour partager les composantes, si on supprime le lien vers le parent.</p>
                                </li>
                                <li>
                                    <p>Iterator sera utilisé pour parcourir un Composite.</p>
                                </li>
                                <li>
                                    <p>Visitor permettra de localiser des opérations qui, sinon, seraient dispersées dans les diverses composantes.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="iterator">Iterator :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Cursor</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Fournir un moyen d'accès séquentiel aux éléments d'un agrégat sans un divulguer la structure interne.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Une liste doit fournir un moyen d'accès à ses éléments sans révéler son implémentation. De plus, une liste peut être parcourue de différentes manières. On ne désire pas alourdir l'interface de la classe Liste afin de tenir compte de toutes les traversées utiles. Par ailleurs, il est parfois utile d'avoir plusieurs parcours simultanés de la même liste.</p>
                            <p>Ceci sera réalisé grâce au pattern Iterator. Les responsabilités d'accès et de parcours sont sorties de la classe Liste et placées dans une classe ListIterator. Cette classe définit une interface gardant trace de l'élément en cours. Une instance de la classe ListIterator sera construite en lui fournissant une Liste à traverser. Il implémentera des méthodes telles que <span class="em">first()</span>, <span class="em">next()</span>, <span class="em">isDone()</span> et <span class="em">currentItem()</span>.</p>
                            <p>Le client soit que c'est une Liste qu'il traverse. Nous avons affaire à un Iterator concret.</p>
                            <p>Une autre approche permettrait de varier le type d'agrégat traversé. On parle d'Iterator polymorphe.</p>
                            <p>Le problème est alors de créer l'Iterator. Ce sera la Liste elle-même qui sera responsable de cette création en fournissant une méthode <span class="em">CreateIterator()</span>. Cette méthode est un exemple de Factory Method.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Iterator :</p>
                            <ul>
                                <li>
                                    <p>pour accéder au contenu des objets d'un agrégat sans en divulguer la structure interne.</p>
                                </li>
                                <li>
                                    <p>pour supporter des traversées multiples.</p>
                                </li>
                                <li>
                                    <p>pour fournir une interface uniforme pour traverser des agrégats différents (Itérateurs polymorphes).</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_iterator.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Iterator</span> : définit une interface d'accès et de traversée.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteIterator</span> : implémente l'interface précédente et garde trace de la position courante de la traversée.</p>
                                </li>
                                <li>
                                    <p><span class="em">Aggregate</span> : définit une interface de création d'un objet Iterator.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteAggregate</span> : implémente cette interface de création afin de renvoyer le ConcreteIterator approprié.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre les objets tient au fait que le ConcreteIterator tient en compte la position courante de la traversée et est capable de calculer la position suivante.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Supporte différentes traversées d'un même agrégat (exemple : préordre, inordre, ...). Il suffit de remplacer un Iterator par un autre et de sous-classer afin de définir une nouvelle manière de traverser.</p>
                                </li>
                                <li>
                                    <p>Simplifie l'interface de l'Aggregate.</p>
                                </li>
                                <li>
                                    <p>Permet la prise en compte de traversées simultanées d'un Aggregate.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Qui contrôle l'itération ?</span> Ce sera soit l'Iterator (<span class="em">itérateur interne</span>, <span class="em">passif</span>), soit le Client (<span class="em">itérateur externe</span>, <span class="em">actif</span>). Dans le deuxième cas, plus flexible, c'est le Client qui requiert l'élément suivant de manière explicite. Dans le premier cas, l'itération est effectuée en une seule requête à laquelle le Client passe une opération à effectuer sur tous les éléments. Si les itérateurs internes sont plus facile à utiliser, ils sont très faibles dans des langages comme C++.</p>
                                </li>
                                <li>
                                    <p><span class="Em">Qui définit l'algorithme de la traversée ?</span> Une place de choix est bien sûr l'Iterator. Mais ce n'est pas le seul endroit possible : l'Aggregate peut définir cet algorithme et utiliser l'Iterator pour stocker l'état de l'itération. Un tel Iterator est appelé un Cursor, car il se contente de pointer sur la position courante. On appelle alors la méthode <span class="em">next()</span> sur l'Aggregate avec le Cursor comme argument. Ce sera l'opération <span class="em">next()</span> qui modifiera le Cursor.</p>
                                    <p>Placer l'algorithme dans l'Iterator permet d'utiliser plusieurs algorithmes d'itération, de réutiliser un même algorithme pour des agrégats différents. Mais si l'Iterator a besoin d'accéder à des champs privés de l'Aggregate, il y aura brise d'encapsulation.</p>
                                </li>
                                <li>
                                    <p><span class="em">À quel point l'Iterator est-il robuste ?</span> Il peut être dangereux de modifier un agrégat pendant un parcours. Si des éléments sont ajoutés ou supprimés, on pourrait arriver à accéder deux fois ou pas du tout à un élément. Copier la structure et traverser la copie est une solution souvent trop chère. Un <span class="em">Iterator robuste</span> permet les insertions et les suppressions pendant la traversée et ce sans devoir recopier l'agrégat. Pour implémenter un tel Iterator, ce dernier devra s'enregistrer aurpès de l'agrégat. Celui-ci, lors d'insertion ou de suppression, ajustera l'état interne de l'itérateur, ou maintiendra les informations nécessaires pour assurer une traversée correcte.</p>
                                </li>
                                <li>
                                    <p><span class="em">D'autres opérations dans l'Iterator.</span> Parfois des opérations supplémentaires pourront être déclarées dans l'Iterator, telle que <span class="em">previous()</span>, <span class="em">skip()</span>, ...</p>
                                </li>
                                <li>
                                    <p><span class="em">L'utilisation d'iterateur plymorphe en C++.</span> Le prix à payer pour l'utilisation d'itérateurs polymorphes est leur allocation dynamique par une Factory Method. On ne les utilisera dès lors, que lorsque ce côté polymorphe est indispensable. Un autre problème avec les itérateurs polymorphes est la nécessité pour le client de les détruire. Une solution pour ne pas oublier, est d'utiliser un Proxy alloué sur la pile qui supprimera le véritable Iterator dans son destructeur.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les itérateurs peuvent avoir des accès privilégiés.</span> En tant qu'extension de la classe Aggregate, la classe Iterator sera fortement couplée à la précédente. En C++ cela pourra se marquer en faisant de la classe Iterator une classe <span class="em">friend</span> de la classe Aggregate. Ceci rend difficile l'ajout de nouvelles traversées puisqu'il faut modifier la classe Aggregate pour déclarer une nouvelle classe <span class="em">friend</span>. On peut y remédier en définissant dans Iterator des méthodes <span class="em">protected</span> d'accès à certaines données privées de l'Aggregate. Les sous-classes de Iterator et elles seules pourront ainsi avoir accès à ces méthodes et par elles aux données privées de l'Aggregate. Seule Iterator devra être déclarée <span class="em">friend</span> de Aggregate.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les Itérateurs d'objets Composites.</span> Les itérateurs externes seront difficiles à implémenter vu le grand nombre de niveaux possibles. Dans ce cas on préférera souvent (hélas !) un itérateur interne. Un itérateur externe devrait stocker une sorte de chemin à travers l'objet Composite pour garder trace de l'objet courant. Si les noeuds du Composite ont une interface leur permettant de se déplacer vers leurs enfants, leur parent et leurs frères, une meilleure solution sera d'implémenter un Curseur. Un Composite a souvent besoin d'être traversé de diverses manières (préordre, inordre, postordre, breadth-first).</p>
                                </li>
                                <li>
                                    <p><span class="em">Itérateurs nuls.</span> C'est un itérateur dégénéré qui a tout de suite terminé sa traversée (<span class="em">isDone()</span> renvoie toujours <span class="em">true</span>). Ils sont utiles pour traiter les conditions limites. Leur emploi rendra plus aisé le parcours d'agrégats de style Composites. À chaque point de la traversée, on demande à l'élément courant un itérateur pour ses enfants. Les feuilles renverront un itérateur nul afin d'implémenter la traversée de manière uniforme.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <ol>
                                <li>
                                    <p>Les interdaces List et Iterator :</p>
<pre><code>const int DEFAULT_LIST_CAPACITY = 100;
template &lt;class Item&gt; class Iterator;

template &lt;class Item&gt;
class List {
public:
    List(long size = DEFAULT_LIST_CAPACITY);
    Iterator&lt;Item&gt;* createIterator() const;
    long count() const;
    Item& get(long index) const;
    // ...
};

template &lt;class Item&gt;
class Iterator {
public:
    virtual void first() = 0;
    virtual void next() = 0;
    virtual bool isDone() const = 0;
    virtual Item currentItem() const = 0;
protected:
    Iterator();
};</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Implémentation de la sous-classe ListIterator</span> :</p>
<pre><code>template &lt;class Item&gt;
class ListIterator : public Iterator&lt;Item&gt; {
public:
    ListIterator(const List&lt;Item&gt;* aList);
    virtual void first();
    virtual void next();
    virtual bool isDone() const;
    virtual Item currentItem() const;
private:
    const List&lt;Item&gt;* _list;
    long _current;
};

template &lt;class Item&gt;
ListIterator&lt;Item&gt;::ListIterator (const List&lt;Item&gt;* aList) : _list(aList), _current(0) {
}

template &lt;class Item&gt;
void ListIterator&lt;Item&gt;::first() {
    _current = 0;
}

template &lt;class Item&gt;
void ListIterator&lt;Item&gt;::next() {
    _current++;
}

template &lt;class Item&gt;
bool ListIterator&lt;Item&gt;::isDone() const {
    return _current &gt;= _list-&gt;Count();
}

template &lt;class Item&gt;
Item ListIterator&lt;Item&gt;::currentItem() const {
    if (isDone()) {
        throw IteratorOutOfBounds;
    }
    return _list-&gt;get(_current);
}</code></pre>
                                    <p>L'implémentation de <span class="em">ReverseListIterator</span> est similaire, si ce n'est que <span class="em">first()</span> positionne <span class="em">_current</span> à la fin de la liste (<span class="em">_list-&gt;count()</span>) et que <span class="em">next()</span> décrémente <span class="em">_current</span> jusque 0. La méthode <span class="em">isDone()</span> renverra vrai à ce moment.</p>
<pre><code>template &lt;class Item&gt;
class ReverseListIterator : punlic Iterator&lt;Item&gt; {
public:
    ReverseListIterator(const List&lt;Item&gt;* aList);
    virtual void first();
    virtual void next();
    virtual bool isDone() const;
    virtual Item currentItem() const;
};</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Utilisation</span> :</p>
<pre><code>class Employee {
    // ...
    public:
        void print();
};

void printEmployees (Iterator&lt;Employee*&gt;& i) {
    for (i.fist(); !i.isDone(); i.next()) {
        i.currentItem()-&gt;print();
    }
}</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Éviter de se lier à une implémentation spécifique</span> :</p>
<pre><code>template &lt;class Item&gt;
class SkipList : public List&lt;Item&gt; {
    public:
};

template &lt;class Item&gt;
class SkipListIterator : public ListIterator&lt;Item&gt; {
public:
    SkipListIterator(const List&lt;Item&gt;* aList);
    void first();
    void next();
    bool isDone() const;
    Item currentItem() const;
};

void dummy1() {
    List&lt;Emplyee*&gt;* employees;
    // ...
    ListIterator&lt;Employee*&gt; forward(employees);
    ReverseListIterator&lt;Employee*&gt; backward(employees);

    printEmployees(forward);
    printEmployees(backward);
}

void dummy2() {
    SkipList&lt;Employee*&gt;* employees;
    // ...
    SkipListIterator&lt;Employee*&gt; iterator(employees);
    printEmployees(iterator);
}</code></pre>
                                    <p>On préférera utiliser une classe abstraite pour définir <span class="em">createIterator()</span>.</p>
<pre><code>template &lt;class Item&gt;
class AbstractList {
public:
    virtual Iterator&lt;Item&gt;* createIterator() const = 0;
    // ...
};

template &lt;class Item&gt;
Iterator&lt;Item&gt;* List&lt;Item&gt;::createIterator() const {
    return new ListIterator&lt;Item&gt;(this);
}

void dummy3() {
    // we know only that we have an AbstractList
    AbstractList&lt;Employee*&gt;* employees;
    // ...
    Iteator&lt;Employee*&gt;* iterator = employees-&gt;createIterator();
    printEmployees(*iterator);
    delete iterator;
}</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Faire en sorte que les itérateurs créés dynamiquement soient détruits</span> :</p>
                                    <p>On utilise un pointeur intelligent alloué sur la pile, qui se comporte comme un Proxy.</p>
<pre><code>template &lt;class Item&gt;
class IteratorPtr {
public:
    IteratorPtr(Iterator&lt;Item&gt;* i): _i(i) { }
    ~IteratorPtr() { delete _i; }
    Iterator&lt;Item&gt;* operator-&gt;() { return _i; }
    Iterator&lt;Item&gt;& operator*() { return *_i; }
private:
    // disallow copy and assignment to avoid
    // multiple deletions of _i:

    IteratorPtr(const IteratorPtr&);
    IteratorPtr& operator=(const IteratorPtr&);
private:
    Iterator&lt;Item&gt;* _i;
};

void dummy4() {
    AbstractList&lt;Employee*&gt;* employees;
    // ...

    IteratorPtr&lt;Employee*&gt; iterator(employees-&gt;createIterator());
    printEmployees(*iterator);
}</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Utilisation d'un itérateur interne (écrit certes à l'aide d'un itérateur externe)</span> :</p>
<pre><code>template &lt;class Item&gt;
class ListTraverser {
public:
    ListTraverser(List&lt;Item&gt;* aList);
    bool traverse();
protected:
    virtual bool processItem(const Item&) = 0;
private:
    ListIterator&lt;Item&gt; _iterator;
};

template &lt;class Item&gt;
ListTraverser&lt;Item&gt;::ListTraverser(List&lt;Item&gt;* aList): _iterator(aList) { }

template &lt;class Item&gt;
bool ListTraverser&lt;Item&gt;::traverse() {
    bool result = false;
    for (_iterator.first(); !_iterator.isDone(); _iterator.next()) {
        result = processItem(_iterator.currentItem());
        if (result == false)
            break;
    }
    return result;
}

class PrintNEmployees : public ListTraverser&lt;Employee*&gt; {
public:
    PrintNEmployees(List&lt;Employee*&gt;* aList, int n) : ListTraverser&lt;Employee*&gt;(aList), _total(n), _count(0) { }
protected:
    bool processItem(Employee* const&);
private:
    int _total;
    int _count;
};

bool PrintNEmployees::processItem (Employee* const& e) {
    _count++;
    e-&gt;print();
    return _count &lt; _total;
}

void dummy5() {
    List&lt;Employee*&gt;* employees;
    // ...
    // avec un itérateur interne : pas de boucle
    PrintNEmployees pa(employees, 10);
    pa.traverse();

    // et avec un itérateur externe
    ListIterator&lt;Employee*&gt; i(employees);
    int count = 0;
    for (i.first(); !i.isDone(); i.next()) {
        count++;
        i.currentItem()-&gt;print();
        if (count &gt;= 10) {
            break;
        }
    }
}</code></pre>
                                    <p>Différentes sortes d'itérations peuvent être encapsulées dans un itérateur interne :</p>
<pre><code>template &lt;class Item&gt;
class FilteringListTraverser {
public:
    FilteringListTraverser(List&lt;Item&gt;* aList);
    bool traverse();
protected:
    virtual bool processItem(const Item&) = 0;
    virtual bool testItem(const Item&) = 0;
private:
    ListIterator&lt;Item&gt; _iterator;
};

template &lt;class Item&gt;
void FilteringListTraverser&lt;Item&gt;::traverse() {
    bool result = false;

    for (_iterator.first(); _iterator.isDone(); _iterator.next()) {
        if (testItem(_iterator.currentItem())) {
            result = processItem(_iterator.currentItem());
            if (result == false) {
                break;
            }
        }
    }
    return result;
}</code></pre>
                                </li>
                            </ol>
                        </dd>
                        <dt>Iterator en Java</dt>
                        <dd>
                            <p>La classe Enumeration de Java 1.1 est un cas particulier d'itérateur. Depuis Java 1.2, les <span class="em">Iterator</span> et <span class="em">ListIterator</span> sont parties intégrantes du langage. Voici un exemple de leur utilisation.</p>
<pre><code>import java.util.*;
public class TestIterator {
    public static void main(String[] args) {
        List aList = new ArrayList();
        aList.add("a");
        aList.add("cat");
        aList.add("hat");

        ListIterator myList = aList.listIterator();

        while (myList.hasNext()) {
            Object listItem = myList.next();
            if (listItem.equals("cat")) {
                myList.set("katze");
                System.out.println("Changed item at index: " + myList.previousIndex());
                break;
            }
        }
        myList.add("in");
        System.out.println("Changed aList : " + aList);
    }
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Composite utilise souvent des Iterator pour traver ses structures récursives : La classe <span class="em">PreorderIterator</span> garde une Pile <span class="em">_iterators</span> d'itérateurs des noeuds recontrés et encore à traiter.</p>
<pre><code>void PreorderIterator::first() {
    Iterator * i = _root-&gt;createIterator();
    if (i) {
        i-&gt;first();
        _iterators.removeAll();
        _iterators.push(i);
    }
}

void PreorderIterator::next() {
    Iterator* i = _iterators.top()-&gt;currentItem()-&gt;createIterator();
    i-&gt;first();
    _iterators.push(i);

    while (_iterators.size() &gt; 0 && _iterators.top()-&gt;isDone()) {
        delete _iterators.pop();
        _iterators.top()-&gt;next();
    }
}

Item * PreorderIterator::currentItem() const {
    return _iterators.size() &gt; 0 ? _iterators.top()-&gt;currentItem() : 0;
}

bool PreorderIterator::isDone() {
    return _iterators.size() == 0;
}</code></pre>
                                </li>
                                <li>
                                    <p>Factory Method instancie les itérateurs polymorphes appropriés.</p>
                                </li>
                                <li>
                                    <p>Un Cursor est un cas particulier du pattern Memento.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="template_method">Template Method :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Classe</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Définir le squelette d'un algorithle en une méthode tout en déférant certaines étapes aux sous-classes. Celles-ci pourront redéfinir ces étapes sans changer la structure de l'algorithme.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Considérons un framework d'applications gérant des documents. La classe Application est responsable d'ouvrir des documents existants. Les applications concrètes pourront préciser les étapes de l'ouverture selon leurs besoins propres. La classe abstraite Application définira :</p>
<pre><code>void Application::openDocument(char * name) {
    if (!canOpenDocument(name)) {
        // document de tupe non approprié
        return;
    }
    Document * doc = doCreateDocument();
    if (doc) {
        doc-&gt;addDocument(doc);
        aboutToOpenDocument(doc);
        doc-&gt;open();
        doc-&gt;doRead();
    }
}</code></pre>
                            <p>Les sous-classes <span class="em">ConcreteApplication</span> et <span class="em">ConcreteDocument</span> redéfiniront les méthodes <span class="em">canOpenDocument()</span>, <span class="em">doCreateDocument()</span> et <span class="em">aboutToOpenDocument()</span> d'une part et <span class="em">doRead()</span> de l'autre.</p>
                            <p>La méthode <span class="em">openDocument()</span> est une Template Method.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Template Method :</p>
                            <ul>
                                <li>
                                    <p>pour implémenter une seule fois les parties invariantes d'un algorithme et laisser les sous-classes redéfinir les parties variables.</p>
                                </li>
                                <li>
                                    <p>pour éviter de dupliquer du code en factorisant le comportement commun dans la classe parent. Dans ce cas, la Template Method est souvent définie lors d'un refactoring.</p>
                                </li>
                                <li>
                                    <p>pour contrôler les extensions que définiront les sous-classes. En effet, la Template Method donne des points d'ancrage qui seront les seuls points où seront appelées les méthodes des sous-classes.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_template_method.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">AbstractClass</span> : (Application) déclare des opérations primitives abstraites qui seront définies par les sous-classes et définit une template method qui implémente les étapes d'un algorithme. Cette méthode appelle des opérations définies dans AbstractClass et des opérations primitives définies dans les sous-classes.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteClass</span> : (ConcreteApplication) implémente les opérations primitives définissant les étapes de l'algorithme.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre ces classes vient du fait que ConcreteClass compte sur AbstractClass pour décrire les étapes de l'algorithme.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Les Template methods sont un moyen de factorisation de comportement commun dans une librairie de classes.</p>
                            <p>Elles appliquent le "Principe d'Hollywood" : "Ne nous appelez pas, nous vous appellerons." puisque ce sont les classes parents qui appellent les méthodes des sous-classes.</p>
                            <p>Les Template Methods peuvent appeler :</p>
                            <ul>
                                <li>
                                    <p>des opérations concrètes des sous-classes ou des classes Clients.</p>
                                </li>
                                <li>
                                    <p>des opérations concrètes de la AbstractClass elle-même.</p>
                                </li>
                                <li>
                                    <p>des Factory Methods.</p>
                                </li>
                                <li>
                                    <p>des opérations primitives (redéfinies dans les sous-classes).</p>
                                </li>
                                <li>
                                    <p>des opérations d'ancrage qui définissent un comportement par défaut (souvent ne rien faire) redéfini dans les sous-classes.</p>
                                </li>
                            </ul>
                            <p>Il est donc important de préciser quand on définit une Template Method, quelles sont les opérations d'ancrage (qui peuvent être redéfinies) et quelles sont les opérations abstraites (qui doivent être redéfinies).</p>
                            <p>Il arrive souvent qu'une sous-classe étende le comportement d'une opération dont elle hérite. Dans ce cas, la première idée est d'écrire :</p>
<pre><code>void DerivedClass::operation() {
    ParentClass::operation();
    // DerivedClass extended behavior
}</code></pre>
                            <p>Le risque est d'oublier d'appeler l'opération héritée de la classe parent. Plutôt que de faire cela, il faut mieux utiliser une Template method qui nous force à utiliser la méthode du parent :</p>
<pre><code>class ParentClass {
    public:
        void operation();
        virtual void hookOperation();
};

void ParentClass::operation() {
    // ParentClass behavior
    hookOperation();
}

void ParentClass::hookOperation() { }

class DerivedClass : public ParentClass {
    public:
        virtual void hookOperation();
};

void DerivedClass::hookOperation() {
    // derived class extension
}</code></pre>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">L'utilisation des contrôles d'accès.</span> Les opérations primitives pourront être déclarées protected. Ainsi, elles pourront seulement être appelées par la Template Method. Les opérations primitives qui doivent être redéfinies seront déclarées abstraites (= 0 en C++). La Template Method ne peut pas être redéfinie : elle sera déclarée <span class="em">final</span> en Java, non virtuelle en C++.</p>
                                </li>
                                <li>
                                    <p><span class="em">Minimiser les opérations primitives.</span> Moins il y en a, plus il sera simple pour les sous-classes de ne pas oublier de redéfinir un comportement.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les conventions de Noms.</span> On pourra utiliser un préfixe au nom des méthodes qui doivent être redéfinies, un autre pour les opérations d'ancrage, un troisième pour les Template Methods.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Donnons le code complet (!) de l'exemple de la motivation.</p>
<pre><code>class Document {
public:
    virtual void open();
    virtual void doRead()=0;
};

class Application {
public:
    void openDocument(const char*); // template method
    void addDocument(const Document *); // concrete operation
    virtual Document* doCreateDocument(); // factory method
protected:
    virtual bool canOpenDocument(const char*); // primitive
    virtual void aboutToOpenDocument(); // primitive
private:
    Document* doc = doCreateDocument();

    if (doc) {
       addDocument(doc);
       addToOpenDocument(doc);
       doc-&gt;open();
       doc-&gt;doRead(); 
    }
}

class MyDocument : public Document {
public:
    virtual void open() { // code removed }
    virtual void doRead() { // code removed }
};

class MyApplication : public Application {
public:
    virtual Document* doCreateDocument() { // code removed }
    virtual bool canOpenDocument(const char*) { // code removed }
    virtual void aboutToOpenDocument() { // code removed }
};</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Factory Method est souvent appelé par Template Method (ex : <span class="em">doCreateDocument()</span>).</p>
                                </li>
                                <li>
                                    <p>Strategy : Template Method varie des parties d'algorithme en utilisant l'héritage. Strategy varie l'algorithme entier en utilisant la délégation.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="abstract_factory">Abstract Factory :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Kit</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Créationnel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Fournir une interface pour créer des familles d'objets reliés ou dépendants sans spécifier leur classe concrète.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>On désire écrire un toolkit d'interface utilisation supportant plusieurs look and feel standards (Win 95/98, OS/2 Presentation Manager, X Window Motif, Mac, ...).</p>
                            <p>Pour chaque widget (window, button, menu, scrollbar, ...), on créera une classe abstraite et autant de sous-classes concrètes que de look and feel supportés.</p>
                            <p>Le problème est alors d'instancier les widgets correspondants au look and feel choisi. Pour ce faire, on définit une classe abstraite de création de tous les types de widgets et pour chaque look and feel, une sous-classe concrète de celle-là. Une classe Client instanciera une de ces sous-classes et à l'aide de celle-ci, créera les widgets voulus, tous automatiquement du même lool and feel.</p>
                            <img src="../images/motivation_abstract_factory.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Abstract Factory quand :</p>
                            <ul>
                                <li>
                                    <p>un système doit être indépendant de la manière dont ses objets sont créés, composés et représentés.</p>
                                </li>
                                <li>
                                    <p>un système doit être configuré avec une famille de produits choisie parmi plusieurs.</p>
                                </li>
                                <li>
                                    <p>une famille d'objets doit être utilisée ensemble et on veut renforcer cette contrainte.</p>
                                </li>
                                <li>
                                    <p>vous voulez fournir une librairie de classes et n'en révelant que l'interface et pas l'implémentation.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_abstract_factory.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Abstract Factory</span> : (WidgetFactory) déclare une interface de création des produits abstraits.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteFactory</span> : (Win95Factory) implémente les opérations de cette interface pour créer des objets concrets.</p>
                                </li>
                                <li>
                                    <p><span class="em">AbstractProduct</span> : (Window, Menu) déclare l'interface pour un type de produit.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteProduct</span> : (MotifWindow, Win95Menu) définit un produit concret destiné à être créé par la ConcreteFactory correspondante et implémente l'interface AbstractProduct.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : utilise seulement les deux interfaces définies dans les classes abstraites.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre objets est la suivante :</p>
                            <ul>
                                <li>
                                    <p>Normalement une seule instance d'une ConcreteFactory est créée à l'exécution. C'est elle qui créera les objets concrets. Pour en créer d'un autre type, il faut changer de ConcreteFactory.</p>
                                </li>
                                <li>
                                    <p>AbstractFactory défère la création des produits à sa sous-classe.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Les classes concrètes sont isolées.</span> Le Client en manipule les instances via des interfaces abstraites. Les noms des produits concrets sont isolés dans la ConcreteFactory. Ils n'apparaissent pas dans le code du Client.</p>
                                </li>
                                <li>
                                    <p><span class="em">On peut facilement changer de famille de produits.</span> La classe de la ConcreteFactory n'apparaît que lors de son instanciation. On peut aisément changer de ConcreteFactory dès lors. Toute la famille de produits s'en trouvera changée.</p>
                                </li>
                                <li>
                                    <p><span class="em">Le pattern garantit la consistance parmi les produits.</span>  Si des produits doivent être utilisés ensembles, il est important de n'employer que des produits d'une même famille. Ceci est obligatoire avec Abstract Factory.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p><span class="em">L'ajout de nouvelles sortes de produits est difficile.</span> En effet Abstract Factory fixe l'ensemble des objets qu'il crée. En rajouter oblige à changer l'interface et à modifier chaque sous-classe de AbstractFactory. Voir la section Implémentation pour une solution à ce problème.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Les Factories sont souvent de Singletons.</span> En effet les applications n'utilisent qu'une instance d'une ConcreteFactory. On les implémentera souvent en utilisant le pattern Singleton.</p>
                                </li>
                                <li>
                                    <p><span class="em">La création des produits.</span> Celle-ci doit être faite dans les sous-classes concrètes. La manière usuelle de le faire est d'utiliser une Factory method pour chaque produit à créer. Toutefois, si beaucoup de familles de produits légèrement différentes sont nécessaires, on préférera utiliser le pattern Prototype. Cette façon de procéder élimine le besoin de créer une nouvelle ConcreteFactory pour chaque famille de produit.</p>
                                </li>
                                <li>
                                    <p><span class="Em">Définir des Factories extensibles.</span> On a signalé la difficulté pour Abstract Factory, d'ajouter de nouveaux produits. Une solution moins sûre hélas, consiste non pas à définir une factory method pour chaque sorte de produit mais une seule opération paramétrée, qui reçoit en argument le type de produit à créer. C'est également cette méthode qui peut être employée pour utiliser Prototype. Cela nécessite pour tous les produits d'avoir la même classe parent ou d'implémenter une même interface. Mais un problème persiste : la méthode renverra toujours une référence à un objet de cette interface commune. Il sera impossible dès lors, pour le Client, d'utiliser des opérations particulières à un produit concret, si cette opération n'est pas reprise dans l'interface. Un cast peut rendre la chose possible mais n'est pas très sûr. On sacrifie de la flexibilité et de la sécurité pour obtenir de l'extensibilité.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <ol>
                                <li>
                                    <p class="em">Utilisation de Factory Method définies dans les ConcreteFactory :</p>
<pre><code>abstract class WidgetFactory {
    public Window createWindow();
    public Menu createMenu();
    public Button createButton();
}

class MacWidgetFactory extends WidgetFactory {
    public Window createWindow() {
        return new MacWindow();
    }

    public Menu createMenu() {
        return new MacMenu();
    }

    public Button createButton() {
        return new MacButton();
    }
}

class Win95WidgetFactory extends WidgetFactory {
    public Window createWindow() {
        return new Win95Window();
    }

    public Menu createMenu() {
        return new Win95Menu();
    }

    public Button createButton() {
        return new Win95Button();
    }
}</code></pre>
                                </li>
                                <li>
                                    <p class="em">Utilisation de Factory Method définies dans les produits concrets :</p>
<pre><code>abstract class WidgetFactory {
    private Window windowFactory;
    private Menu menuFactory;
    private Button buttonFactory;

    public Window createWindow() {
        return windowFactory.createWindow();
    }

    public Menu createMenu() {
        return menuFactory.createMenu();
    }

    public Button createButton() {
        return buttonFactory.createButton();
    }
}

class MacWidgetFactory extends WidgetFactory {
    public MacWidgetFactory() {
        windowFactory = new MacWindow();
        menuFactory = new MacMenu();
        buttonFactory = new MacButton();
    }
}

class MacWindow extends Window {
    public Window createWindow() { ... }
    etc.</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Utilisation du pattern Prototype :</span> Pas besoin de définir de sous-classes de WidgetFactory.</p>
<pre><code>class WidgetFactory {
    private Window windowPrototype;
    private Menu menuPrototype;
    private Button buttonPrototype;

    public WidgetFactory(Window windowPrototype, Menu menuPrototype, Button buttonPrototype) {
        this.windowPrototype = windowPrototype;
        this.menuPrototype = menuPrototype;
        this.buttonPrototype = buttonPrototype;
    }

    public Window createWindow() {
        return windowPrototype.clone();
    }

    public Menu createMenu() {
        return menuPrototype.clone();
    }

    public Button createButton() {
        return buttonPrototype.clone();
    }
}

class MacWindow extends Window, implements Cloneable {
    public Window clone() {
        ...
    }
    etc.</code></pre>
                                </li>
                            </ol>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Abstract est souvent implémenté à l'aide de Factory Method, parfois de Prototype.</p>
                                </li>
                                <li>
                                    <p>Une ConcreteFactory y est souvent un Singleton.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="builder">Builder :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Créationnel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Séparer la construction d'un objet complexe de sa représentation afin que le même processus de construction puisse créer différentes représentations.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Un lecteur de format RTF doit être capable de convertir le RTF en beaucoup de formats texte (ASCII, TEX, TextWidget, ...) et la liste doit rester ouverte : il faut pouvoir rajouter d'autres formats au fur et à mesure des besoins.</p>
                            <p>Une solution est de configurer la classe lecteur avec un objet TextConverter qui converyira le RTD en un format choisi. On sous-classera TextConverter pour obtenir une conversion vers un format particulier. Un ASCIIConverter convertit le RTF en texte simple et "ignorera" les opérations de formatages. Les autres convertisseurs réaliseront des opérations plus complexes. Chaque TextConverter implémente les opérations nécessaires à la création d'un objet complexe et est appelé un Builder.</p>
                            <p>Le lecteur effectuera le parsing du document RTF en une méthode de création de l'objet converti. Celle-ci fera appel aux méthodes du convertisseur pour construire l'objet bribe par bribe. Le lecteur est appelé un Director.</p>
                            <img src="../images/motivation_builder.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Builder quand :</p>
                            <ul>
                                <li>
                                    <p>l'algorithme de création d'un objet complexe doit être indépendant des parties qui composent l'objet et de la manière dont ils sont assemblés.</p>
                                </li>
                                <li>
                                    <p>le processus de construction doit permettre différentes représentations de l'objet à construire.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_builder.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Builder</span> : (textConverter) spécifie une interface abstraite de création des parties du Produit.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteBuilder</span> : (ASCIIConverter, ...) construit et assemble les parties du produit en implémentant l'interface Builder. Il définit et garde trace de la représentation construite et définit une interface pour récupérer l'objet (<span class="em">getASCIIText()</span>, ...).</p>
                                </li>
                                <li>
                                    <p><span class="em">Director</span> : (RTFReader) construit un objet en utilisant l'interface Builder.</p>
                                </li>
                                <li>
                                    <p><span class="em">Product</span> (ASCIIText, ...) représente l'objet complexe en construction. Il inclut les classes qui définissent les parties constituant l'objet et les interfaces nécessaires à l'assemblage de ces parties en l'objet final.</p>
                                </li>
                            </ul>
                            <p>Ils collaborent comme suit :</p>
                            <ul>
                                <li>
                                    <p>Le client crée le ConcreteBuilder désiré et le Director et configure celui-ci avec le Builder concret créé.</p>
                                </li>
                                <li>
                                    <p>Le Director notifie le Builder concret chaque fois qu'une composante de l'objet doit être créée.</p>
                                </li>
                                <li>
                                    <p>Le Builder concret traite la requête et ajoute la composante au produit en construction.</p>
                                </li>
                                <li>
                                    <p>Le Client récupère l'objet créé auprès du Builder concret.</p>
                                </li>
                            </ul>
                            <img src="../images/structure_participants_collaborations_builder_2.png" alt="">
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Builder permet de varier la représentation interne du produit, ses composantes et comment il est assemblé.</p>
                                </li>
                                <li>
                                    <p>Il isole le code de construction et de représentation de l'objet. Différents Directors pourront réutiliser le code pour créer des variantes de l'objet construit. Ainsi un lecteur d'un autre format que RTF pourra utiliser les TextConverter pour effectuer les conversions vers les mêmes formats.</p>
                                </li>
                                <li>
                                    <p>Il permet un contrôle plus fin du processus de construction et donc de la structure interne du Product.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>La classe abstraite Builder définira plutôt des opérations par défaut ne faisant rien afin que les ConcreteBuilder ne redéfinissent que les méthodes dont ils ont besoin. Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">L'interface de construction et d'assemblage.</span> Cette interface doit être suffisamment générale pour permettre la construction de produits très différents par les ConcreteBuilders. Il est la plupart du temps suffisant de faire le design d'un modèle dans lequel les résultats des diverses requêtes sont rajoytés en fin de produit. Pafois, on doit pouvoir accéder aux parties du produit construit (portes, chambres d'un labyrinthe, noeuds d'un arbre, ...).</p>
                                </li>
                                <li>
                                    <p><span class="em">Pourquoi ne pas faire une classe abstraite Product mais seuelement des produits concrets ?</span>Parce que ces produits diffèrent tellement dans la plupart des cas. Comme c'est le même Client qui configure le Directir avec un ConcreteBuilder et puis qui accède au Product construit, il sait de quel produit concret il s'agit et peut donc le traiter en conséquence.</p>
                                </li>
                                <li>
                                    <p><span class="em">Utiliser des méthodes vides comme comportement par défaut dans la classe Builder.</span> Ceci permet au ConcreteBuilder de ne redéfinir que les méthodes qu'il utilise.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Commençons par présenter les classes Composants :</p>
<pre><code>class Maze;
class MapSite;
class Wall;
class Door;
class Room;
class MazeGame;
class MazeBuilder;

classMapSite {
public:
    virtual void Enter() = 0;
};

class Room : public MapSite {
public:
    Room(int = 0);
    Room(const Room&);
    virtual Room* Clone() const;
    void InitializeRoomNo(int);
    MapSite* GetSide(Direction);
    void SetSide(Direction, MapSite*);
    virtual void Enter();
private:
    MapSite* _sides[4];
    int _roomNumber;
};

class Wall : public MapSite {
public:
    Wall();
    Wall(const Wall&);
    virtual Wall* Clone() const;
    virtual void Enter();
};

class Door : public MapSite {
public:
    Door(Room* = 0, Room* = 0);
    Door(const Room&);
    virtual Door* Clone() const;
    void Initialize(Room*, Room*);
    virtual void Enter();
    Room* OtherSideFrom(Room*);
private:
    Room* _room1;
    Room* _room2;
    bool _isOpen;
};</code></pre>
                            <p>Voici une classe Product :</p>
<pre><code>class Maze {
public:
    Maze();
    Maze(const Maze&);
    Room* RoomNo(int);
    void AddRoom(Room*);
    virtual Maze* Clone() const;
private:
    // ...
};</code></pre>
                            <p>La classe Director est la suivante. Ici, on utilise une variante : La classe n'est pas configurée à l'aide d'un Builder interne mais on précise le Builder lors de l'appel des méthodes de créations.</p>
<pre><code>class MazeGame {
    public:
        Maze* CreateMaze();
        Maze* CreateSimpleMaze();
        Maze* CreateMaze(MazeBuilder&);
        Maze* CreateCompleteMaze(MazeBuilder& builder);
};</code></pre>
                            <p>La classe Builder :</p>
<pre><code>class MazeBuilder {
public:
    virtual void BuildMaze() { }
    virtual void BuildRoom(int room) { }
    virtual void BuildDoor(int roomFrom, int roomTo) { }

    virtual Maze* GetMaze() { return 0; }
protected:
    MazeBuilder();
};

Maze* MazeGame::CreateMaze(MazeBuilder& builder) {
    builder.BuildMaze();
    builder.BuildRoom(1);
    builder.BuildRoom(2);
    builder.BuildDoor(1, 2);
    return builder.getMaze();
}

Maze* Maze* MazeGame::CreateCompleteMaze(MazeBuilder& builder) {
    builder.BuildRoom(1);
    // ...
    builder.BuildRoom(1001);

    return builder.GetMaze();
}</code></pre>
                            <p>Un ConcreteBuilder :</p>
<pre><code>class StandardMazeBuilder : public MazeBuilder {
public:
    StandardMazeBuilder();
    virtual void BuildMaze();
    virtual void BuildRoom(int);
    virtual void BuildDoor(int, int);
    virtual Maze* GetMaze();
private:
    Direction CommonWall(Room*, Room*);
    Maze* _currentMaze;
};

StandardMazeBuilder::StandardMazeBuilder() {
    _currentMaze = 0;
}

void StandardMazeBuilder::BuildMaze() {
    _currentMaze = new Maze;
}

Maze* StandardMazeBuilder::GetMaze() {
    Maze* maze = _currentMaze;
    return maze;
}

void StandardMazeBuilder::BuildRoom(int n) {
    if (!_currentMaze-&gt;RoomNo(n)) {
       Room* room = new Room(n);
       _currentMaze-&gt;AddRoom(room);
       room-&gt;SetSide(North, new Wall());
       room-&gt;SetSide(South, new Wall());
       room-&gt;SetSide(East, new Wall());
       room-&gt;SetSide(West, new Wall());
    }
}

void StandardMazeBuilder::BuildDoor(int n1, int n2) {
    Room* r1 = _currentMaze-&gt;RoomNo(n1);
    Room r2 = _currentMaze-&gt;RoomNo(n2);
    Door* d = new Door(r1, r2);
    r1-&gt;SetSide(CommonWall(r1, r2), d);
    r2-&gt;SetSide(CommonWall(r2, r1), d);
}</code></pre>
                            <p>Du code Client utilisant le tout :</p>
<pre><code>void dummy() {
    Maze* maze;
    MazeGame game;
    StandardMazeBuilder builder;

    game.CreateMaze(builder);
    maze = builder.GetMaze();
}</code></pre>
                            <p>Un autre ConcreteBuilder : celui-ci se contente de compter sans rien construire.</p>
<pre><code>class CountingMazeBuilder : public MazeBuilder {
public:
    CountingMazeBuilder();
    virtual void BuildMaze();
    virtual void BuildRoom(int);
    virtual void BuildDoor(int, int);
    virtual void AddWall(int, Direction);
    void GetCounts(int&, int&) const;
private:
    int _doors;
    int _rooms;
};

CountingMazeBuilder::CountingMazeBuilder() {
    _rooms = _doors = 0;
}

void CountingMazeBuilder::BuildRoom(int) {
    _rooms++;
}

void CountingMazeBuilder::BuildDoor(int, int) {
    _doors++;
}

void CountingMazeBuilder::GetCounts(int& rooms, int& doors) const {
    rooms = _rooms;
    doors = _doors;
}</code></pre>
                            <p>Et un peu de code Client :</p>
<pre><code>void dummy1() {
    int rooms, doors;
    MazeGame game;
    CountingMazeBuilder builder;

    game.CreateMaze(builder);
    builder.GetCounts(rooms, doors);

    count &lt;&lt; "The maze has "
          &lt;&lt; rooms &lt;&lt; " rooms and "
          &lt;&lt; doors &lt;&lt; " doors" &lt;&lt;end1;
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Abstract Factory peut également construire des objets complexes. Builder insiste sur les étapes tandis qu'Abstract Factory insiste sur les familles de produits.</p>
                                </li>
                                <li>
                                    <p>Builder construit souvent un Composite.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="singleton">Singleton :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Créationnel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Assurer qu'une classe ne peut avoir qu'une seule instance et fournir un point d'accès global à cette instance.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Bien souvent il arrive q'une classe ne puisse avoir qu'une instance : un seul spooler d'impression, un seul window manager, un seul file system, une seule Compagnie, ...</p>
                            <p>Pour éviter que plusieurs instances ne soient créées, ce sera la classe elle-même qui sera responsable de la gestion de sa seule instance. Ce sera elle qui empêchera d'en créer plusieurs. Ce sera à elle de fournir un moyen d'accéder à cette seule instance.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise quand :</p>
                            <ul>
                                <li>
                                    <p>il doit y avoir exactement une instance d'une classe et elle doit être accessible aux clients d'un point d'accès connu.</p>
                                </li>
                                <li>
                                    <p>la seule instance doit pouvoir être étendue dans des sous-classes et les clients doivent y accéder sans modification à leur code.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_singleton.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Singleton</span> : qui définit une opération <span class="html">getInstance()</span> qui permet aux clients d'accéder à son unique instance. Cette opération est une méthode de Classe (<span class="html">static</span>). Le Singleton peut être responsable de la création de son unique instance.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Accès contrôlé à la seule instance.</span> C'est la responsabilité de la classe.</p>
                                </li>
                                <li>
                                    <p><span class="em">Le pattern évite l'emploi de variables globales pour stocker cette seule instance.</span> Quand on en a besoin, on fait appel à la méthode <span class="html">getInstance()</span> qui renvoie toujours le même objet.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il permet le raffinement des opérations et de la représentation.</span> En effet, la classe Singleton peut être étendue en diverses sous-classes. On pourra configurer l'application avec une instance de la sous-classe qu'on désire.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il permet un nombre déterminé d'instances.</span> Si on change d'avis, il est aisé de permettre un autre nombre d'instances que un. Le pattern contrôlera alors le nombre d'instances qu'on peut utiliser. Seule l'opération d'accès aux instances devra être changée dans l'interface.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il est plus flexible que de définir une classe où tout est <span class="html">static</span>.</span> Une autre approche est de définir la classe Singleton en y mettant tous les champs et toutes les méthodes, y compris les constructeurs <span class="html">static</span>. Il n'y aura forcément qu'un objet pour cette classe. Mais cette façon de faire empêche de permettre plus d'une instance (voir point ci-dessus). De plus, en C++, elle ne permet pas de définir des sous-classes car une méthode <span class="html">static</span> n'est jamais <span class="html">virtual</span>.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Assurer l'unicité de l'instance.</span> La méthode <span class="html">getInstance()</span> sera <span class="html">static</span> et on utilisera un champ référençant l'unique instance. Ce champ sera également <span class="html">static</span>.</p>
                                    <p>En Java, cela donne :</p>
<pre><code>class Singleton {
    private static Singleton _instance = null;

    private Singleton() { // ... }

    public static Singleton getInstance() {
        if (_instance == null)
            _instance = new Singleton();
        return _instance;
    }

    public void otherOperations() { // ... }
}

class Program {
    public void aMethod() {
        X = Singleton.getInstance();
    }
}</code></pre>
                                    <p>En C++ :</p>
<pre><code>class Singleton {
private:
    static Singleton* _instance;
    void otherOperations();
protected:
    Singleton();
public:
    static Singleton* getInstance();
};

Singleton* Singleton::_instance = 0;

Singleton* Singleton::getInstance() {
    if (_instance == 0)
        _instance = new Singleton();
    return _instance;
}</code></pre>
                                    <p>Comme on peut le constater, l'unique instance n'est créée que lors du premier appel à la méthode <span class="html">getInstance()</span>. Avant elle reste à <span class="html">null</span>. L'objet n'est donc créé que quand on en a effectivement besoin.</p>
                                    <p>Comme le constructeur est protected, un client ne pourra pas créer directement un Singleton en appelant le constructeur : cela provoquerait une erreur de compilation.</p>
                                    <p>Comme <span class="html">_instance</span> réfère un Singleton, il pourra référer un objet d'une sous-classe.</p>
                                </li>
                                <li>
                                    <p class="em">Définir des sous-classes pour Singleton.</p>
                                    <p>Si chaque sous-classe doit être un Singleton et que le client peut avoir une instance de chacune d'elle, il suffit de faire de chaque sous-classe un Singleton.</p>
                                    <p>Si le client ne peut avoir qu'une instance du Singleton ou d'une de ses sous-classes, cela se corse.</p>
                                    <p>Définir les sous-classes n'est pas un problème. C'est installer l'instance de la sous-classe afin qu'elle puisse être utilisée par les clients qui crée des difficultés.</p>
                                    <ul>
                                        <li>
                                            <p>Le plus simple est de déterminer dans la méthode <span class="em">getInstance()</span> quelle sous-classe utiliser. Les constructeurs des sous-classes doivent toutefois rester accessibles !</p>
<pre><code>Singleton* Singleton::getInstance() {
    if (_instance == 0) {
        const char* singletonStyle = getenv("SINGLETON");
        if (strcmp(singletonStyle, "A") == 0)
            _instance = new A;
        else if (strcmp(singletonStyle, "B") == 0)
            _instance = new B;
        else
            _instance = new Singleton;
    }
    return _instance;
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Une autre façon de procéder est de placer l'implémentation de <span class="em">getInstance()</span> dans les sous-classes et pas dans le parent. Ceci permet de décider lors du link quelle sous-classe on utilise, en linkant avec le fichier objet contenant la représentation de la sous-classe voulue. La première manière permettait le choix à l'exécution mais hard-codait les choix possibles.</p>
                                        </li>
                                        <li>
                                            <p>Une approche plus flexible utilise un <span class="em">registre de singletons</span>. Les classes Singletons enregistrent leur instance par nom dans un registre connu. Celui-ci fait le rapport entre les noms (strings) et les singletons (objets). Si <span class="html">getInstance()</span> à besoin d'un singleton, il consulte le registre à l'aide du nom. Le registre trouve le singleton correspondant et le renvoie. Ainsi, <span class="html">getInstance()</span> ne doit pas connaître tous les singletons possibles.</p>
                                        </li>
                                    </ul>
                                    <p>En <span class="em">C++</span>, cela donne :</p>
<pre><code>class Singleton {
private:
    static Singleton* _instance;
    static ListOfSingletonNamePairs _registry;

    static Singleton* getSingletonFromName(char* name);
protected:
    Singleton();
public:
    static Singleton* getInstance();
    static void register(char* name, Singleton* registerer);
    void otherOperations();
};

Singleton* Singleton::getInstance() {
    if (_instance == 0) {
        const char* singletonName = getenv("SINGLETON");
        _instance = getSingleFromName(singletonName);
    }
    return _instance;
}</code></pre>
                                    <p>Les singletons s'enregistrent en faisant :</p>
<pre><code>MySingleton::Mysingleton() {
    // ...
    Singleton::register("MySingleton", this);
</code></pre>
                                    <p>Malheureusement ce constructeur ne sera jamais appelé. Quand un client voudra instancier la classe, il ne pourra le faire que via <span class="html">getInstance()</span> et le singleton ne sera jamais dans le registre ! On résoudra le problème en définissant une instance <span class="html">static</span> de chaque sous-classe dans le fichier qui définit son omplémentation :</p>
<pre><code>static MySingleton theSingletonOfMine;</code></pre>
                                    <p>La classe Singleton ne sera alors plus responsable de la création de son instance. Le défaut est que tous les singletons devront être créés alors qu'on ne pourra en utiliser qu'un seul.</p>
                                    <p>En <span class="em">Java</span>, on n'a pas de fonction <span class="em">getenv()</span> (mais on pourra utiliser les arguments de la ligne de commande ou un fichier de configuration ou la persistance).</p>
                                    <p>De plus définir le constructeur <span class="html">protected</span> le rend accessible à toutes les classes du même package. Pour résoudre ce dernier problème, on placera les sous-classes de Singleton dans des packages différents de ceux des clients.</p>
                                    <p>D'autre part, on ne peut pas créer d'instance <span class="html">static</span> dans le fichier contenant l'implémentation de la sous-classe. Le client précisera la sous-classe voulue par son nom (obtenu sur la ligne de commande, dans un fichier de configuration, ...), et le passera à <span class="html">setInstance()</span>.</p>
                                    <p>La solution suivante permet aux constructeurs des sous-classes de rester <span class="em">private</span>. La classe parent sera abstraite pour que son constructeur puisse rester <span class="html">protected</span> ou même <span class="html">public</span> puisque non appelable.</p>
<pre><code>public abstract class Singleton {
    private static Singleton instance = null;

    public static void setInstance(Singleton registerer) {
        if (instance != null) // comment if it can change
            instance = registerer;
    }

    public static void setInstance(String className) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Class aSingletonClass = Class.forName(className);
        if (isSubclassOfSingleton(aSingletonClass)) {
            Class[] noArgs = new Class[0];
            Object[] noArgms = new Object[0];
            Method register = aSingletonClass.getMethod("register", noArgs);
            register.invoke(null, noArgms);
        }
    }

    public static Singleton getInstance() {
        if (instance == null)
            instance = getDefaultSingleton();
            // or throw an Exception if no default
        return instance;
    }

    private static Singleton getDefaultSingleton() {
        // ...
    }

    private static boolean isSubclassOfSingleton(Class c) {
        do {
            if (c == Singleton.class)
                return true;
        } while ((c = c.getSuperclass()) != null);
        return false;
    }
}</code></pre>
                                    <p>Les sous-classes définiront une méthode <span class="html">register()</span> qui appellera <span class="html">setInstance()</span> et son propre constructeur. Ceci permet au constructeur de rester <span class="html">private</span>.</p>
<pre><code>public class Child extends Singleton {
    private Child() {
        // do what you have to do;
    }
    public static void register() {
        Singleton.setInstance(new Child());
    }
    // ....
}</code></pre>
                                    <p>Les clients feront par exemple :</p>
<pre><code>Singleton.setInstancr(argv[0]);
Singleton theSingleton = Singleton.getInstance();</code></pre>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Cet exemple reprend la première solution, suffisante dans ce cas-ci. La classe MazeGame est reprise ci-dessous :</p>
<pre><code>class MazeGame {
public:
    Maze* CreateMaze(MazeFactory&);
    // ...
};

classs MazeFactory {
public:
    sttaic MazeFactory* getInstance();
    virtual Maze* MakeMaze() const;
    virtual Wall* MakeWall() const;
    virtual Room* MakeRoom(int n) const;
    virtual Door* MakeDoor(Room* r1, Room* r2) const;
protected:
    MazeFactory();
private:
    static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::getInstance() {
    if (_instance == 0) {
        const char* mazeStyle = getenv("MAZESTYLE");
        if (strcmp(mazeStyle, "bombed") == 0) {
            _instance = new BombedMazeFactory;
        } else if (strcmp(mazeStyle, "enchanted") == 0) {
            _instance = new EnchantedMazeFactory;
        // ... other possible subclasses
        } else {
            _instance = new MazeFactory();
        }
    }
    return _instance;
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <p>Abstract Factory, Builder, Prototype et bien d'autres patterns peuvent s'implémenter comme un Singleton.</p>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="proxy">Proxy (Mandataire) :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Suurogate (Suppléant, Substitut)</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Fournir un suppléant pour un autre objet afin de contrôler l'accès à celui-ci.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Une des raisons de contrôler l'accès à un objet est de retarder sa création jusqu'au moment ou en a réellemnt besoin, par exemple : une image dans un document. Ainsi un objet cher serait créé à la demande. Mais que mettre à la place de l'objet tant qu'on n'en a pas réellement besoin ? Comment cacher le fait que l'objet ne soit créé qu'à la demande sans compliquer le code de l'application, ici d'un éditeur de documents ?</p>
                            <p>La solution est d'utiliser un autre objet, appelé Proxy. Un Proxy d'image contiendra le nom du fichier image. Celui-ci chargera l'image si l'afficheur de document veut afficher cette image à l'écran. Le Proxy pourra également stocker divers renseignements sur l'image telle que la taille qu'elle occupera à l'écran afin que l'éditeur puisse organiser son document sans devoir déjà charger les images qui ne sont pas affichées.</p>
                            <img src="../images/motivation_proxy.png" alt="">
                            <p>Ceci donne au runtime :</p>
                            <img src="../images/runtime_proxy.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Proxy quand on a besoin d'une référence à un objet plus sophistiquée qu'un simple pointeur ou qu'une simple référence. Les situations les plus courantes sont :</p>
                            <ul>
                                <li>
                                    <p>Un Proxy à distance (Remote Proxy) : l'objet réel est sur une autre machine. Ce type de Proxy est parfois appelé Ambassador.</p>
                                </li>
                                <li>
                                    <p>Un Proxy virtuel (Virtual Proxy) sert à optimiser par exemple en créant des objets chers à la demande.</p>
                                </li>
                                <li>
                                    <p>Un Proxy de protection (Protection Proxy) pour procurer à différents objets des accès différents à l'objet protégé par le Proxy.</p>
                                </li>
                                <li>
                                    <p>Une référence intelligente (Smart Reference) qui remplace une référence simple pour permettre des actions supplémentaires telles que compter le nombre de référence à un objet (Counter Proxy), charger un objet persistant en mémoire à la première référence, locker un objet avant d'y accéder, etc.</p>
                                </li>
                                <li>
                                    <p>Un Cache Proxy ou Server Proxy pour partager entre plusieurs clients des objets chers (situés à distances, longs à calculer, long à charger, ...).</p>
                                </li>
                                <li>
                                    <p>Un firewall Proxy pour protéger les clients locaux du monde extérieur.</p>
                                </li>
                                <li>
                                    <p>Un Proxy de synchronisation (Synchronization Proxy) pour synchroniser des accès multiples à l'objet.</p>
                                </li>
                            </ul>
<pre><code>public class Table {
    public Object elementAt(int row, int column) {
        // ...
    }
    public void setElementAt(Object element, int row, int column) {
        // ...
    }
    public void numberOfRows() { // ... }
}

public class RowLockTable {
    Table realTable;
    Integer[] locks;
    
    public RowLockTable(Table toLock) {
        realTable = toLock;
        locks = new String[toLock.numberOfRows()];
        for (int row = 0; row &lt; toLock.numberOfRows(); row++)
            locks[row] = new Integer(row);
    }

    public Object elementAt(int row, int column) {
        synchronized(locks[row]) {
            return realTable.elementAt(row, column);
        }
    }

    public void setElementAt(Object element, int row, int column) {
        synchronized(locks[row]) {
            return realTable.setElementAt(element, row, column);
        }
    }
}</code></pre>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_proxy.png" alt="">
                            <p>Cela donnera lieu à un diagramme d'objets comme suit lors de l'exécution.</p>
                            <img src="../images/structure_participants_collaborations_objets_proxy.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Proxy</span> qui maintient une référence au RealSubject (cette référence peut être une référence à un Subject, quand l'interface de RealSubject est identique à celui de Subject). Il fournit une interface identique à celle de Subject afin de pouvoir se substituer au RealSubject, contrôle l'accès à celui-ci et peut être responsable de sa création et de sa suppression.</p>
                                    <p>D'autres responsabilités dépendront du type de Proxy :</p>
                                    <ul>
                                        <li>
                                            <p>Un Remote Proxy devra encoder une requête et ses arguments (Marshaling) puis l'envoyer à l'objet distant. En réalité, il l'enverra à un objet Adapter qui décodera la requête (Unmarshaling) avant de la transmettre à l'objet réel.</p>
                                        </li>
                                        <li>
                                            <p>Un Virtual Proxy cachera des informations supplémentaires concernant le RealSubject afin de postposer l'accès à celui-ci.</p>
                                        </li>
                                        <li>
                                            <p>Un Protection Proxy vérifiera si celui qui veut accéder à l'objet en a bien le droit.</p>
                                        </li>
                                        <li>
                                            <p>...</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Subject</span> définit l'interface commune au Proxy et au RealSubject afin de pouvoir employer le Proxy partout où on peut employer le RealSubject.</p>
                                </li>
                                <li>
                                    <p><span class="em">RealSubject</span> définit l'objet réel que le Proxy représente.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre les participants peut se schématiser par le diagramme suivant :</p>
                            <img src="../images/structure_participants_collaborations_proxy_2.png" alt="">
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Les avantages d'un Proxy dépendent du type de Proxy et ont été largement expliqués à leur propos.</p>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivantts seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">En C++, songer à surdéfinir les opérateurs <span class="html">-&gt;</span> et <span class="html">*</span></span> afin que le Proxy se comporte comme un pointeur.</p>
<pre><code>class Image;
extern Image* LoadAnImageFile(conts char*);
    // external function

class ImagePtr {
public:
    ImagePtr(const char* imageFile);
    virtual ~ImagePtr();

    virtual Image* operator-&gt;();
    virtual Image& operator*();

private:
    Image* LoadImage();
private:
    Image* _image;
    const char* _imageFile;
};

ImagePtr::ImagePtr(const char* theImageFile) {
    _imageFile = theImageFile;
    _image = 0;
}

Image* ImagePtr::LoadImage() {
    if (image == 0) {
        _image = LoadAnImageFile(_imageFile);
    }
    return _image;
}

Image* ImagePtr::operator-&gt;() {
    return LoadImage();
}

Image& ImagePtr::operator*() {
    return *LoadImage();
}

void dummy() {
    ImagePtr image = ImagePtr("anImageFileName");
    image-&gt;Draw(Point(50, 100));
    // c.-à-d. (image.operator-&gt;())-&gt;Draw(Point(50, 100))
}</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Les Proxies ne doivent pas toujours connaître le type du RealSubject.</span> Si le Proxy peut se contenter d'utiliser l'interface Subject, on ne devra pas faire un Proxu pour chaque RealSubject. Une seule classe Proxy pourra traiter toutes les classes RealSubject. Mais si le Proxy doit créer le RealSubject, alors il devra le connaître.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Montrons l'implémentation du Proxy virtuel décrit dans la section Motivation.</p>
                            <p>Voici tout d'abord la classe abstraite Subject :</p>
<pre><code>class Graphic {
public:
    virtual ~Graphic();
    virtual void Draw(const Point& at) = 0;
    virtual void HandleMouse(Event& event) = 0;
    virtual const Point& GetExtent() = 0;
    virtual void Load(istream& from) = 0;
    virtual void Save(ostream& to) = 0;
protected:
    Graphic();
};</code></pre>
                            <p>La classe Image est un RealSubject :</p>
<pre><code>class Image : public Graphic {
public:
    Image(const char* file); // loads image from a file
    virtual ~Image();
    virtual void Draw(const Point& at);
    virtual void HandleMouse(Event& event);
    virtual const Point& GetExtent();
    virtual void Load(istream& from);
    virtual void Save(ostream& to);
private:
    // ...
};</code></pre>
                            <p>La classe suivante implémente le Proxy en dérivant du Subject :</p>
<pre><code>class ImageProxy : public Graphic {
public:
    ImageProxy(const char* imageFile);
    virtual ~ImageProxy();
    virtual void Draw(const Point& at);
    virtual void HandleMouse(Event& event);
    virtual const Point& GetExtent();
    virtual void Load(istream& from);
    virtual void Save(ostream& to);
protected:
    Image* GetImage();
private:
    Image* _image;
    Point _extent;
    char* _fileName;
};

ImageProxy::ImageProxy(const char* fileName) {
    _fileName = strdup(fileName);
    _extent = Point::Zero; // don't know extent yet
    _image = 0;
}

Image* ImageProxy::GetImage() {
    if (_image == 0) {
        _image = new Image(_fileName);
    }
    return _image;
}

const Point& ImageProxy::GetExtent() {
    if (_extent == Point::Zero) {
        _extent = getImage()-&gt;GetExtent();
    }
    return _extent;
}

void ImageProxy::Draw(const Point& at) {
    GetImage()-&gt;Draw(at);
}

void ImageProxy::HandleMouse(Event& event) {
    GetImage()-&gt;HandleMouse(event);
}</code></pre>
                            <p>Les deux opérations suivantes permettent d'obtenir les renseignements concernant l'image sans la charger. Ce n'est donc que la première fois qu'on devra charger l'image pour avoir ces renseignements.</p>
<pre><code>void ImageProxy::Save(ostream& to) {
    to &lt;&lt; _extent &lt;&lt; _fileName;   
}

void ImageProxy::Load(istream& from) {
    from &gt;&gt; _extent &gt;&gt; _fileName;
}</code></pre>
                            <p>Voici à présent une classe Client :</p>
<pre><code>class TextDocument {
public:
    TextDocument();
    void Insert(Graphic*);
    // ...
};</code></pre>
                            <p>Enfin, du code utilisant un Client et le Proxy :</p>
<pre><code>void dummy() {
    TextDocument* text = new TextDocument;
    // ...
    text-&gt;Insert(new ImageProxy("anImageFileName"));
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Decorator peut parfois avoir une implémentation similaire à celle d'un Proxy. Mais leur intention est différente. Le Decorator ajoute des responsabilités à un objet tandis que Proxy en contrôle l'accès. Un Protection Proxy peut être implémenté exactement comme un Decorator car il contient une référence au RealSubject. Un Virtual Proxu n'en contient pas, du moins pas au début. Un Remote Proxy n'en contient jamais.</p>
                                </li>
                                <li>
                                    <p>Adapter fournit une interface différente pour l'objet adapté. Proxy fournit la même interface. Toutefois un Protection Proxy pourra refuser certaines opérations sur le RealSubject en n'implémentant qu'une partie de l'interface de ce dernier.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="adapter">Adapter :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Wrapper</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Classe et Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Convertir l'interface d'un objet en une autre interface attendue par le client.</p>
                            <p>Permettre à des classes d'interfaces incompatobles de travailler ensemble.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Parfois des classes utilitaires ne sont pas réutilisables alors qu'elles avaient été écrites dans ce but, et ce simplement parce que les interfaces qu'elles fournissent ne correspondent pas aux interfaces propres au fomaine d'application attendues.</p>
                            <p>Par exemple des classes représentant des formes géométriques simples sont faciles à implémenter mais une sous-classe TextShape qui permet en plus d'éditer du texte à l'intérieur de la forme est plus difficile. Par ailleurs une librairie de classes définissant une interface graphique utilisateur peut vous fournir une classe TextView qui permet justement d'éditer du texte. Ce serait très intéressant de pouvoir la réutiliser pour implémenter TextShape. Mais comme cette librairie n'a pas été écrite dans ce but, il y a peu de chance que l'interface de TextView corresponde à ce que l'on veut. Pour faire en sorte qu'il se conforme à l'interface de Shape, on pourrait modifier TextView. Mais ce n'est pas souvent possible, surtout si on n'a pas la source. On préférera définir TextShape en adaptant TextView. Ceci peut être fait de deux manières : (1) en héritant l'interface de Shape et l'implémentation de TextView ou (2) en composant une intance de TextView dans TextShape et en implémentant celui-ci en terme de l'interface TextView. La première approche correspond à la version Classe du pattern Adapter, la deuxième à la version Objet.</p>
                            <img src="../images/motivation_adapter.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Adapter quand :</p>
                            <ul>
                                <li>
                                    <p>On veut utiliser une classe existante dont l'interface ne correspond pas à celle désirée.</p>
                                </li>
                                <li>
                                    <p>On veut créer une classe réutilisable qui coopère avec des classes non reliées qui n'ont pas nécessairement une interface compatible.</p>
                                </li>
                                <li>
                                    <p>On doit utiliser plusieurs sous-classes existantes et on ne veut pas adapter chacune d'elle en définissant une sous-classe de chacune d'elles. On utilisera alors un Adapter <span class="em">version Objet</span> qui lui, pourra adapter la classe parent.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <p>Adapter version Classe :</p>
                            <img src="../images/structure_participants_collaborations_adapter.png" alt="">
                            <p>Adapter version Objet :</p>
                            <img src="../images/structure_participants_collaborations_objets_adapter.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Target</span> : (Shape) définit l'interface propre à l'application, qui sera utilisé par le Client.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : (Éditeur de dessin) collabore avec les objets conformément à l'interface Target.</p>
                                </li>
                                <li>
                                    <p><span class="em">Adaptee</span> : (TextView) définit une interface existante qui doit être adaptée.</p>
                                </li>
                                <li>
                                    <p><span class="em">Adapter</span> : (TextShape) adapte l'interface d'Adaptee en l'interface de Target.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre classes prend sa source chez le Client, lorsqu'il appelle une opération d'une instance d'Adapter. Celui-ci appelle des opérations d'Adaptee pour traiter la requête.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Pour un Adapter version Classe :</p>
                            <ul>
                                <li>
                                    <p>Il adapte l'Adaptee au Target en utilisant une classe Adapter concrète. Ceci empêche ce pattern de pouvoir adapter une classe et toutes ses sous-classes.</p>
                                </li>
                                <li>
                                    <p>Adapter peut redéfinir certaines opérations d'Adaptee, puisqu'il en est une sous-classe.</p>
                                </li>
                                <li>
                                    <p>Il n'y a qu'un seul objet. L'accès à Adaptee est direct, sans nécessité de passer par une indirection.</p>
                                </li>
                            </ul>
                            <p>Pour un Adapter version objet :</p>
                            <ul>
                                <li>
                                    <p>Il permet à un seul Adapter de traiter une famille d'Adaptee. Il peut ajouter des fonctionnalités à toutes les classes de la famille en une fois.</p>
                                </li>
                                <li>
                                    <p>Il rend plus difficile la redéfinition du comportement de l'Adaptee. Il faudra définir une sous-classe d'Adaptee et faire référencer Adapter à cette sous-classe plutôt qu'à Adaptee lui-même.</p>
                                </li>
                            </ul>
                            <p>Le travail d'Adapter peut varier depuis une simple conversion d'interface (changer le nom des opérations) jusqu'à définir ensemble d'opération complètement différent. Tout dépendra du degré de similitude entre Target et Adaptee.</p>
                            <p><span class="em">Adapter bidirectionnels</span> : grâce à Adapter on pourra utiliser un Adaptee quand on a besoin d'un Target mais pas l'inverse. Si l'inverse est désiré également, on définira un Adapter bidirectionnel en implémentant les deux interfaces dans la classe Adapter.</p>
                            <p><span class="em">Pluggable Adapter</span> : Si on considère un widget TreeDisplay qui affiche un arbre graphiquement, on aura tendance à vouloir que les objets qu'il affiche obéissent à une interface spécifique. On les fera tous descendre d'une classe abstraite Tree. Mais si on désire que TreeDisplay soit facilement réutilisable, il vaut mieux éviter cette contrainte pour laisser TreeDisplay utiliser les structures d'arbres définies par diverses applications. Pour ce faire TreeDisplay devra contenir son propre adapteur d'interface pour les objets qu'il affiche.</p>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p>Pour implémenter un <span class="em">Adapter version Classe</span> en C++, on héritera publiquement de Target et de manière privée d'Adaptee. En Java, il faudra hériter d'Adaptee, donc Target devra être une interface.</p>
                                </li>
                                <li>
                                    <p><span class="em">Pluggable Adapter.</span> La première étape de l'implémentation est de trouver une interface "étroite" pour Adaptee, c'est-à-dire formée du moins d'opérations possible nécessaires à l'adaption. Dans le cas de TreeDisplay, l'Adaptee est n'importe quelle structure hiérarchique. Une interface minimale contiendra deux opérations : afficher un noeud et donner la liste des enfants d'un noeud.</p>
                                    <p>Il y a trois approches possibles pour l'implémentation :</p>
                                    <ul>
                                        <li>
                                            <p><span class="em">Utiliser des opérations abstraites</span> : On définira une sous-classe (de TreeDisplay) qui implémentera ces opérations.</p>
                                            <img src="../images/implementation_adapter.png" alt="">
                                        </li>
                                        <li>
                                            <p><span class="em">Utiliser un objet délégué</span> : TreeDisplay transmet les requêtes d'accès à la structure hiérarchique à un objet délégué. Ceci permet de changer de stratégie à l'exécution. On définira une classe abstraite TreeAccessorDelegate pour l'accès à la structure hiérarchique. Une sous-classe définira le véritable objet délégué. En C++, si cette sous-classe dérive déjà d'un autre parent, on utilisera l'héritage multiple. En Java, dans ce cas, on fera une interface de TreeAccessorDelegate.</p>
                                            <img src="../images/implementation_adapter_2.png" alt="">
                                        </li>
                                        <li>
                                            <p><span class="em">Adapters paramétrés</span> : est une manière possible (et usuelle) d'implémenter un Pluggable Adapter en Smalltalk. On paramétrise TreeDisplay avec des blocks précisé lors de l'instanciation.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Montrons l'implémentation de l'exemple qui nous a guidés dans ce chapitre :</p>
<pre><code>class Manipulator { // Client
};

class TextManipulator : public Manipulator {
    public:
        TextManipulator(const TextShape*);
};

class Shape { // Target
public:
    Shape();
    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
    virtual Manipulator* CreateManipulator() const;
};

class TextView { // Adaptee
public:
    TextView();
    void GetOrigin(Coord& x, Coord& y) const;
    void GetExtent(Coord& width, Coord& height) const;
    virtual bool IsEmpty() const;
};

class TextShape : public Shape, private TextView { // Adapter
public:
    TextShape();
    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
    virtual bool IsEmpty() const;
    virtual Manipulator* CreateManipulator() const;
};

void TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {
    Coord bottom, left, width, height;

    GetOrigin(bottom, left);
    GetExtent(width, height);

    bottomLeft = Point(bottom, left);
    topRight = Point(bottom + height, left + width);
}

bool TextShape::IsEmpty() const {
    return TextView::IsEmpty();
}

Manipulator* TextShape::CreateManipulator() const {
    return new TextManipulator(this);
}</code></pre>
                            <p>Voici maintenant l'Adapter version Objet :</p>
<pre><code>class TextShape : public Shape { // Adapter
public:
    TextShape(TextView*);
    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
    virtual bool IsEmpty() const;
    virtual Manipulator* CreateManipulator() const;
private:
    TextView* _text;
};

TextShape::TextShape(TextView* t) {
    _text = t;
}

void TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {
    Coord bottom, left, width, height;

    _text-&gt;GetOrigin(bottom, left);
    _text-&gt;GetExtent(width, height);

    bottomLeft = Point(bottom, left);
    topRight = Point(bottom + height, left + width);
}

bool TextShape::IsEmpty() const {
    return _text-&gt;IsEmpty();
}

Manipulator* TextShape::CreateManipulator() const {
    return new TextManipulator(this);
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Decorator enrichit un autre objet sans changer son interface. Il est donc plus transparent qu'Adapter. Decorator permet une composition récursive ce qui n'est pas le cas d'Adapter.</p>
                                </li>
                                <li>
                                    <p>Proxy définit un substitut à un objet et ne change pas son interface.</p>
                                </li>
                                <li>
                                    <p>Bridge est similaire mais a une intention différente : Il sépare l'interface de l'implémentation afin qu'ils puissent tous deux varier indépendamment. Adapter change l'interface d'un objet existant.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="bridge">Bridge :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Handle/Body</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Découpler une abstraction de son implémentation afin que les deux puissent varier indépendamment.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Quand une abstraction a plusieurs implémentations, on utilise généralement l'héritage : Une classe abstraite représente l'abstraction et ses sous-classes les implémentation à l'abstraction.</p>
                            <p>Considérons l'exemple du système de fenêtrage déjà abordé dans le chapitre Abstract Factory. On désire plusieurs implémentations telles que X Window, NT Window, ...</p>
                            <img src="../images/motivation_bridge.png" alt="">
                            <p>Il est intéressant de dériver la classe Window pour supporter différentes sortes de fenêtres : IconWindow, DialogWindow,. Va-t-on définir des sous-classes d'implémentation de ces sous-classes également :</p>
                            <img src="../images/motivation_bridge_2.png" alt="">
                            <p>Ce qui donne finalement lieu à un très joli embrouillamini.</p>
                            <img src="../images/motivation_bridge_3.png" alt="">
                            <p>D'autre part, de cette manière le code est dépendant de la plate-forme puisque du code Client devra préciser l'implémentation (la sous-classe) pour instancier une fenêtre.</p>
                            <p>La solution est d'utiliser le pattern Bridge : une hiérarchie pour les interfaces, une autre pour les implémentations :</p>
                            <img src="../images/motivation_bridge_4.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Bridge quand :</p>
                            <ul>
                                <li>
                                    <p>on veut éviter un couplage permanent entre une abstraction et son implémentation, en particulier si l'implémentation doit être choisie à l'exécution.</p>
                                </li>
                                <li>
                                    <p>l'abstraction et l'implémentation donnent lieu à une famille de sous-classes.</p>
                                </li>
                                <li>
                                    <p>les changements dans l'implémentation ne doivent pas avoir d'effet sur le Client (pas de recompilation).</p>
                                </li>
                                <li>
                                    <p>vous avez une prolifération de sous-classes. Ceci indique le besoin de séparer l'objet en deux parties.</p>
                                </li>
                                <li>
                                    <p>en C++, vous voulez cacher complètement l'implémentation d'une abstraction, puisque dans ce langage l'implémentation est visible dans l'interface (fichier .h).</p>
                                </li>
                                <li>
                                    <p>vous voulez partager une implémentation entre plusieurs objets en cachant ce fait au client. Par exemple la classe StringRep de J. Copelien permet à de multiples objets de partager la même string.</p>
                                    <img src="../images/applicabilite_bridge.png" alt="">
                                    <p>StringRep garde le texte de la String et un compteur de références. String délègue toutes les opérations à StringRep. Quand le compteur de référence tombe à 0, le texte est désalloué (en supprimant l'objet StringRep). Par exemple :</p>
                                    <img src="../images/applicabilite_bridge_2.png" alt="">
                                    <p>Voici l'implémentation de J. Coplien :</p>
<pre><code>class StringRep {
    friend String;
private:
    char* text;
    int refCount;

    StringRep() { *(text = new char[1]) = n'\0'; }
    StringRep(const StringRep& s) {
        ::strcpy(text = new char[::strlen(s.text) + 1], s.text);
    }
    StringRep(const char* s) {
        ::strcpy(text = new char[::strlen(s.text) + 1], s.text);
    }
    ~StringRep() { delete[] text; }
    StringRep operator=(const StringRep& s) {
        if (rep != s.rep) {
            delete[] rep;
            ::strcpy(rep = new char[::strlen(s.rep)+1], s.rep);
        }
        return * this;
    }
    StringRep operator+(const StringRep& s) const {
        char * buf = new char[s.length() + length() + 1];
        ::strcpy(buf, rep);
        ::strcat(buf, s.rep);
        StringRep retVal(buf);
        delete[] buf;
        return retVal;
    }
    int length() const { return strlen(text); }
    void print() const { printf("%s\n", text); }
};

class String {
    friend StringRep;
private:
    StringRep* imp;
public:
    String() { (imp = new StringRep()) -&gt; refCount = 1; }
    String(const String & s) {
        (imp = s.imp) -&gt; refCount++;
    }
    String(const char* charStr) {
        (imp = new StringRep(charStr)) -&gt; refCount = 1;
    }
    ~String() {
        if (--imp-&gt;refCount &lt;= 0) delete imp;
    }
    String& operator=(const String& s) {
        s.imp-&gt;refCount++;
        if (--imp-&gt;refCount &lt;= 0) delete imp;
        imp = s.imp;
        return *this;
    }
    String operator+(const String& s) const {
        StringRep y = *imp + *s.imp;
        return String(y.text);
    }
    int length() const { return imp-&gt;length(); }
    int print() const { return imp)&gt;print(); }
};

int main() {
    String a("abcd");
    String b("efgh");
    printf("a is "); a.print();
    printf("b is "); b.print();
    printf("length of b is %d\n", b.length());
}</code></pre>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_bridge.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Abstraction</span> : (Window) qui définit l'interface de l'abstraction et maintient une référence à un objet Implementor.</p>
                                </li>
                                <li>
                                    <p><span class="em">RefinedAbstraction</span> : (IconWindow) étend l'interface d'Abstraction.</p>
                                </li>
                                <li>
                                    <p><span class="em">Implementor</span> : (WindowImp) définit l'interface des classes d'implémentation. Celle-ci ne doit pas correspondre à celle d'Abstraction. Elles sont au contraire, souvent très différentes. Typiquement Implementor ne définit que des opérations primitives tandis qu'Abstraction définit des opérations de plus haut niveau.</p>
                                </li>
                                <li>
                                    <p><span class="em">COncreteImplementor</span> : (XWindowImp) implémente l'interface Implementor en définissant une implémentation concrète.</p>
                                </li>
                            </ul>
                            <p>Ces classes collaborent quand l'Abstraction transmet les requêtes des clients à l'objet Implementor avec lequel elle a été configurée.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p><span class="em">Ce pattern découple l'interface de l'implémentation.</span> L'implémentation pourra être configurée et même changée à l'exécution. Si on change d'implémentation, il ne faudra pas recompiler les clients ni l'Abstraction. Ceci est très utile avec des librairies pour passer d'une version à une autre. De plus ce découplage encourage une programmation en couche et donc une meilleure structuration du système.</p>
                                </li>
                                <li>
                                    <p><span class="em">L'extensibilité est améliorée.</span> On peut étendre les hiérarchies Abstraction et Implementor séparément.</p>
                                </li>
                                <li>
                                    <p class="em">Il permet de cacher les détails d'implémentation aux clients.</span></p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Les cas où il n'y a qu'un seul Implementor.</span> Dans ce cas la classe Implementor ne sera pas abstraite. C'est en fait un cas dégénéré du pattern. Il est utile si on doit pouvoir modifier l'implémentation (nouvelle version) sans devoir recompiler les clients.</p>
                                </li>
                                <li>
                                    <p class="em">Créer l'objet Implementor approprié.</p>
                                    <p>S'il y a plusieurs implémentations, comment, quand et où décider quelle sous-classe est instanciée</p>
                                    <p>Si l'Abstraction connaît toutes les implémentations, il peut l'instancier via un paramètre passé à son constructeur.</p>
                                    <p>Ou alors, on peut avoir une implémentation par défaut qui pourra être remplacée ensuite.</p>
                                    <p>On peut aussi déléguer la décision à un autre objet : par exemple à une Abstract Factory. Ceci découple encore plus Abstraction et Implementor.</p>
                                </li>
                                <li>
                                    <p><span class="em">Partager les Implementor.</span> Voir l'exemple des StringRep de Coplien plus haut.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
<pre><code>class Window;

class View {
    public:
        DrawOn(Window*);
};

class WindowImp;</code></pre>
                            <p>Nous utiliserons une <span class="em">Abstract Factory</span> pour créer le bridge :</p>
<pre><code>class WindowSystemFactory {
    public:
        static WindowSystemFactory* Instance();
        WindowImp* MakeWindowImp();
};</code></pre>
                            <p>Voici la classe <span class="em">Abstraction</span> :</p>
<pre><code>class Window {
public:
    Window(View* contents);

    // requests handled by window
    virtual void DrawContents();
    virtual void Open();
    virtual void Close();
    virtual void Iconify();
    virtual void Deiconify();

    // requests forwarded to implementation
    virtual void SetOrigin(const Point& at);
    virtual void SetExtent(const Point& extent);
    virtual void Raise();
    virtual void Lower();

    virtual void DrawLine(const Point&, const Point&);
    virtual void DrawRect(const Point&, const Point&);
    virtual void DrawPolygon(const Point[], int n);
    virtual void DrawText(const char*, const Point&);

protected:
    WindowImp* GetWindowImp();
    View* GetView();

private:
    WindowImp* _imp;
    View* _contents; // the window's contents
};</code></pre>
                            <p>Donnons l'implémentation d'une des méthodes transférant la requête à l'Implementor :</p>
<pre><code>voic Window::DrawRect(const Point& p1, const Point& p2) {
    WindowImp* imp = GetWindowImp();
    imp-&gt;DeviceRect(p1.X(), p1.Y(), p2.X(), p2.Y());
</code></pre>
                            <p>Voici la fonction qui configure le Bridge :</p>
<pre><code>WindowImp* Window::GetWindowImp() {
    if (_imp == 0) {
        _imp = WindowSystemFactory::Instance()-&gt;MakeWindowImp();
    }
    return _imp;
}</code></pre>
                            <p>Définissons une sous-classe de Abstraction, bref une <span class="em">RefinedAbstraction</span> :</p>
<pre><code>class ApplicationWindow : public Window {
public:
    // ...
    virtual void DrawContents();
};

void ApplicationWindow::DrawContents() {
    GetView()-&gt;DrawOn(this);
}</code></pre>
                            <p>Définissons une autre <span class="em">RefinedAbstraction</span> :</p>
<pre><code>class IconWindow : public Window {
public:
    // ...
    virtual void DrawContents();
private:
    const char* _bitmapName;
};

void IconWindow::DrawContents() {
    WindowImp* imp = GetWindowImp();
    if (imp != 0) {
        imp-&gt;DeviceBitmap(_bitmapName, 0.0, 0.0);
    }
}</code></pre>
                            <p>Passons à la classe <span class="em">Implementor</span> :</p>
<pre><code>class WindowImp {
public:
    virtual void ImpTop() = 0;
    virtual void ImpBottom() = 0;
    virtual void ImpSetExtent(const Point&) = 0;
    virtual void ImpSetOrigin(const Point&) = 0;

    virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;
    virtual void DeviceText(const char*, Coor, Coord) = 0;
    virtual void DeviceBitmap(const char*, Coord, Coord) = 0;
    // lots more functions for drawing on windows...
protected:
    WindowImp();
};</code></pre>
                            <p>Il est temps de définir des <span class="em">ConcreteImplementor</span>. Un premier sera <span class="em">XWindowImp</span>. Pour cela nous avons besoin de quelques préliminaires :</p>
<pre><code>struct Display;
typedef unsigned int Drawable;
typedef struct XXX { int y; } *GC;
extern XDrawRectangle(Display*, Drawable, GC, int, int, unsigned int, unsigned int);

class XWindowImp : public WindowImp {
public:
    XWindowImp();

    virtual void DeviceRect(Coord, Coord, Coord, Coord);
    // remainder of public interface...
private:
    // lots of X window system-specific state, including:
    Display* _dpy;
    Drawable _wind; // Window id
    GC _gc; // window graphic context
};

void XWindowImp::DeviceRect(Coord x0, Coord y0, Coord x1, Coord y1) {
    int x = round(min(x0, x1));
    int y = round(min(y0, y1));
    int w = round(abs(x0 - x1));
    int h = round(abs(y0 - y1));
    XDrawRectangle(_dpy, _wind, _gc, x, y, w, h);
}</code></pre>
                            <p>Pour définir un deuxième <span class="em">ConcreteImplementor</span>, <span class="em">PMWindowImp</span>, pour OS/2 Presentation Manager, nous avons aussi besoins de définitions préliminaires :</p>
<pre><code>struct PPOINTL {
    Coord x;
    Coord y;
};
const int GPI_ERROR = 1;

typedef int HPS;
int GpiBeginPath(HPS, unsigned long);
int GpiSetCurrentPosition(HPS, PPOINTL*);
int GpiPolyLine(HPS, unsigned long, PPOINTL*);
int GpiEndPath(HPS);
void ReportError();
void GpiStrokePath(HPS, unsigned long, unsigned long);

class PMWindowImp : public WindowImp {
public:
    PMWindowImp();
    virtual void DeviceRect(Coord, Coord, Coord, Coord);

    // remainder of public interface...
private:
    // lots of PM window system-specific state, including:
    HPS _hps;
};

void PMWindowImp::DeviceRect(Coord x0, Coord y0, Coord x1, Coord y1) {
    Coord left = min(x0, x1);
    Coord right = max(x0, x1);
    Coord bottom = min(y0, y1);
    Coord top = max(y0, y1);

    PPOINTL point[4];

    point[0].x = left; point[0].y = top;
    point[1].x = right; point[1].y = top;
    point[2].x = right; point[2].y = bottom;
    point[3].x = left; point[3].y = bottom;

    if ((GpiBeginPath(_hps, 1L) == false) || (GpiSetCurrentPosition(_hps, &point[3]) == false) || (GpiPolyLine(_hps, 4L, point) == GPI_ERROR) || (GpiEndPath(_hps) == false)) {
        // report error
    } else {
        GpiStrokePath(_hps, 1L, 0L);
    }
}</code></pre>
                        </dd>
                        <dt>Paterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Abstract Factory est souvent utilisé pour créer et configurer un Bridge.</p>
                                </li>
                                <li>
                                    <p>Adapter sert à utiliser ensemble des classes non reliées. On l'applique à des systèmes déjà réalisés. Au contraire, Bridge est utilisé tôt dans le design pour laisser l'abstraction et son implémentation varier indépendamment.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="mediator">Mediator :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Définir un objet qui encapsule la manière dont un ensemble d'objets interagissent. Mediator diminue le couplage entre ces objets en leur permettant de ne pas devoir se référencer les uns les autres. Il permet de varier l'interaction indépendamment.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>En design orienté-objet, en voulant promouvoir la réutilisation de code, on répartit le comportement entre diverses classes s'occupant chacune d'une fonctionnalité. Ceci conduit à une prolifération d'objets devant collaborer entre eux. Une telle collaboration oblige, si on veut réutiliser une classe à devoir réutiliser toutes les autres classes avec lesquelles elle collabore (puisqu'elle en appelle une méthode). On en arrive ainsi à réduire la réutilisation, ce qui est contraire au but recherché. Le problème à résoudre est donc de réduire les interconnections, les dépendances entre classes.</p>
                            <p>Considérons par exemple, une boîte de dialogue. Celle-ci utilisera une fenêtre où placer divers boutons, menus, combo boxes, zone d'entrée, ... Tous ces objets vont devoir communiquer les uns avec les autres : Un bouton pourra être déconnecté si un champ n'est pas rempli. Si un choix est fait dans une combo box, il devra peut être, être reporté dans une zone de texte. De plus, une autre boîte de dialogue aura d'autres dépendances entre objets.</p>
                            <p>On pourra éviter ces problèmes en encapsulant le comportement dans un objet séparé appelé Mediator. Celui-ci sera responsable du contrôle et de la coordination d'un groupe d'objets. Il servira d'intermédiaire empêchant ainsi les objets du groupe de se référencer les uns les autres. Comme les objets ne connaissent plus que le Mediator, le nombre de dépendances est diminué. Dans notre exemple, FontDialogDirector sert de Mediator entre les widgets.</p>
                            <img src="../images/motivation_mediator.png" alt="">
                            <p>Si un choix est fait dans une combo box, les collaborations entre objets peuvent être représentées sur le diagramme de séquence suivant. Comme on peut le voir, tout passe par le Mediator.</p>
                            <img src="../images/motivation_mediator_2.png" alt="">
                            <p>La structure des classes se présentera comme ci-dessous :</p>
                            <img src="../images/motivation_mediator_3.png" alt="">
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_mediator.png" alt="">
                            <p>Ce qui donne, à l'exécution, un diagramme d'objets :</p>
                            <img src="../images/structure_participants_collaborations_objets_mediator.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Mediator</span> : (DialogDirector) définit une interface de communication entre objets Colleague.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteMediator</span> : (FontDialogDirector) implémente la coopération en coordonnant les objets Colleague.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les différentes classes Colleague</span> : (ListBox, EntryField, ...) Chaque objet Colleague connaît son objet Mediator. Il communique avec lui chaque fois qu'il veut communiquer avec un autre objet Colleague.</p>
                                </li>
                            </ul>
                            <p>Ces classes collaborent via le Mediator. Les Colleagues envoient et reçoivent des requêtes de celui-ci. Le Mediator implémente le comportement de coopération en routant les requêtes vers le Colleague approprié.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Mediateur limite le nombre de sous-classes</span> : Pour changer le comportement, il suffit d'une sous-classe de Mediator au lieu d'une pour chaque classe Colleague.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il découple les classes Colleague</span> : On pourra varier et réutiliser les Colleagues et le Mediator indépendamment.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il simplifie le protocole de collaboration entre objets</span> : Il remplace en effet des associations n - n en des associations 1 - n avec le Mediator. De telles associations sont plus compréhensibles, plus facile à maintenir et à éteindre.</p>
                                </li>
                                <li>
                                    <p><span class="em">Il abstrait la coopération entre objets</span> : Il sépare le comportement individuel des objets et leurs interactions. Ceci clarifie les interactions au sein du système.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Il centralise le contrôle</span> : La complexité du système d'interactions est remplacée par de la complexité dans le Mediator. Celui-ci risque de devenir plus complexe que chacun des Colleagues et d'être finalement difficile à maintenir.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Ne pas déclarer de classe abstraite Mediator</span> : Si les Colleagues ne travaillent qu'avec un seul Mediator, il n'y a nul besoin de déclarer une classe abstraite que l'on étend en une sous-classe concrète.</p>
                                </li>
                                <li>
                                    <p><span class="em">La communication entre Colleague et Mediator</span> :</p>
                                    <ul>
                                        <li>
                                            <p>Le Mediator peut définir des <span class="em">méthodes explicites</span> appelées par le Colleague qui a subit un changement d'état.</p>
<pre><code>class DialogDirector {
    private Button ok;
    private Button cancel;
    private ListBox courses;

    public void ListBoxItemSelected() { // ... }

    public void ListBoxScrolled() { // ... }
    // etc.
}</code></pre>
                                        </li>
                                        <li>
                                            <p>L'objet Colleague changé se passe en argument à une <span class="em">méthode générique</span> du Mediator :</p>
<pre><code>class DialogDirector {
    private Button ok;
    private Button cancel;
    private ListBox courses;

    public void widgetChanged(Object changedWidget) {
        if (changedWidget == ok) {
            // ...
        } else if (changedWidget == cancel) {
            // ...
        } else if (changedWidget == courses) {
            // ...
        }
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Uriliser des <span class="em">méthodes génériques surdéfinies</span> :</p>
<pre><code>class DialogDirector {
    private Button ok;
    private Button cancel;
    private ListBox courses;

    public void widgetChanged(Button changedWidget) {
        if (changedWidget ==  ok) {
            // ...
        } else if (changedWidget == cancel) {
            // ...
        }
    }


}</code></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Développons l'exemple de la boîte de dialogue.</p>
                            <p>L'interface Mediator est :</p>
<pre><code>class DialogDirector {
public:
    virtual ~DialogDirector();
    virtual void ShowDialog();
    virtual void WidgetChanged(Widget*) = 0;
protected:
    DialogDirector();
    virtual void CreateWidgets() = 0;
};</code></pre>
                            <p>Voici la classe abstraite de base des Colleagues. On remarquera qu'un Widget connaît son Mediator :</p>
<pre><code>class Widget {
public:
    Widget(DialogDirector*);
    virtual void Changed();
    virtual void HandleMouse(MouseEvent& event);
    // ...
private:
    DialogDirector* _director;
};

void Widget::Changed() {
    _director-&gt;WidgetChanged(this);
}</code></pre>
                            <p>Les sous-classes de Widget sont des Colleagues :</p>
<pre><code>class ListBox : public Widget {
public:
    ListBox(DialogDirector*);
    virtual const char* GetSelection();
    virtual void SetList(List&lt;char*&gt;* listItems);
    virtual void HandleMouse(MouseEvent& event);
    // ...
};

class EntryField : public Widget {
public:
    EntryField(DialogDirector*);
    virtual void SetText(const char* text);
    virtual const char* GetText();
    virtual void HandleMouse(MouseEvent& event);
    // ...
};

class Button : public Widget {
public:
    Button(DialogDirector*);
    virtual void SetText(const char* text);
    virtual void HandleMouse(MouseEvent& event);
    // ...
};

void Button;:HandleMouse(MouseEvent& event) {
    // ...
    Changed();
}</code></pre>
                            <p>Présentons le Mediator concret :</p>
<pre><code>class FontDialogDirector : public DialogDirector {
public:
    FontDialogDirector();
    virtual ~FontDialogDirector();
    virtual void WidgetChanged(Widget*);
protected:
    virtual void CreateWidgets();
private:
    Button* _ok;
    Button* _cancel;
    ListBox* _fontList;
    EntryField* _fontName;
};

void FontDialogDirector::CreateWidgets() {
    _ok = new Button(this);
    _cancel = new Button(this);
    _fontList = new ListBox(this);
    _fontName = new EntryField(this);
    
    // fill the listBox with the available font names
    
    // assemble the widgets in the dialog
}

void FontDialogDirector::WidgetChanged(Widget* theChangedWidget) {
    if (theChangedWidget == _fontList) {
        _fontName-&gt;SetText(_fontList-&gt;GetSelection());
    } else if (theChangedWidget == _ok) {
        // apply font change and dismiss dialog
        // ...
    } else if (theChangedWidget == _cancel) {
        // dismiss dialog
    }
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Une autre manière pour les Colleagues, de communiquer avec le Mediator est d'utiliser une variante du pattern Observer. Dans cette variante, il y a plusieurs Subject et un seul Observer.</p>
                                </li>
                                <li>
                                    <p>Facade diffère de Mediator car il abstrait un sous-système pour fournir une interface plus adaptée. C'est un protocole unidirectionnel : Facade fait des requêtes au sous-système, pas l'inverse. Mediator est un protocole multidirectionnel qui permet un comportement de coopération entre objets qui ne fournissent pas ce comportement.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="observer">Observer :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Dependents, Push - Subscribe</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Définit une dépendance 1 - n entre objets de sorte que si l'objet maître change d'état, tous ses dépendants en sont avertis et automatiquement mis à jour.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Le fait de partitionner un système en une collection de classes collaborant entre elles a pour conséquence le besoin de maintenir la consistance entre objets reliés.</p>
                            <p>Ainsi, une application orientée données peut avoir plusieurs interfaces graphiques, par exemple sous forme de spreadsheet, d'histogramme ou d'autres graphiques présentant les données. Aucune de ces vues ne connaît les autres afin qu'on puisse les réutiliser indépendamment. Pourtant si l'utilisateur change des données via le spreadsheet, les graphiques sont modifiés en conséquence. En réalité le spreadsheet et les graphiques dépendent des données. Celles-ci forment le Subject du pattern tandis que les autres sont les Observers. Tous les Observers sont notifiés d'un changement intervenant dans le Subject. En réponse à cette notification, chaque Observer questionnera le Subject afin de synchroniser leurs états.</p>
                            <p>Ce type d'interaction est aussi appelé Publish and Subscribe. Les Observers s'enregistrent auprès du Subject. Ce sont les subscribers, les abonnés. Le Subject joue le rôle du publisher, de l'éditeur en envoyant les notifications à tous les abonnés.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Observer quand :</p>
                            <ul>
                                <li>
                                    <p>une abstraction a deux aspects dépendant l'un de l'autre. Encapsuler chaque aspect dans une classe différente permet de réutiliser chacune séparément.</p>
                                </li>
                                <li>
                                    <p>un changement d'un objet entraîne des modifications dans d'autres objets et qu'on ne sait pas combien d'objets doivent être modifiés.</p>
                                </li>
                                <li>
                                    <p>Un objet doit être capable de notifier d'autres objets sans devoir savoir ce que sont ces autres objets, c'est-à-dire sans couplage serré.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_observer.png" alt="">
                            <p>ce qui donne le diagramme d'objets :</p>
                            <img src="../images/structure_participants_collaborations_objets_observer.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Subject</span> : qui connaît ses Observers et fournit l'interface permettant d'attacher et de détacher les Observers. Ces derniers peuvent être en nombre quelconque.</p>
                                </li>
                                <li>
                                    <p><span class="em">Observer</span> : qui définit une interface de mise à jour pour les objets qui doivent être notifiés des changements du Subject.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteSubject</span> : qui stocke l'état qui intéresse les ConcreteObservers et qui envoie des notifications à ceux-ci quand son état change.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteObserver</span> : qui maintient une référence à un ConcreteSubject et stocke un état qui doit être consistant avec celui du sujet. Cette classe implémente l'interface de mise à jour d'Observer afin de garder son état synchronisé avec celui du sujet.</p>
                                </li>
                            </ul>
                            <p>La collaboration entre les divers participants peut se schématiser comme suit :</p>
                            <img src="../images/structure_participants_collaborations_observer_2.png" alt="">
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Ce pattern permet de varier indépendamment les sujets et les observateurs. On pourra réutiliser l'un sans l'autre.</p>
                                </li>
                                <li>
                                    <p>Il rend possible l'ajout d'observateurs sans modification dans le sujet ou les autres observateurs.</p>
                                </li>
                                <li>
                                    <p>Le couplage entre Subject et Observer est abstrait et minimal : le Subject sait seulement qu'il doit tenir une liste d'observateurs qui se conforment à l'interface simple d'Observer.</p>
                                </li>
                                <li>
                                    <p>Le pattern Observer supporte l'utilisation de communication de type broadcast. Les notifications n'ont nul besoin de préciser leur destinataire. Elles sont envoyées à tous les objets enregistrés comme observateurs auprès du sujet.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p>Une petite modification dans le sujet risque d'entraîner une cascade de mise à jour des observateurs. Ceci est aggravé par le fait que rien dans l'interface ne permet de savoir ce qui a changé dans le sujet. Tout changement n'entraîne pas nécessairement une modification chez tous les observateurs. Ceux-ci auront un dur labeur pour découvrir ce qui a été modifié.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Comment un sujet garde-t-il trace de ses observateurs ?</span> Il peut stocker une liste de références à ceux-ci. C'est le plus simple, le plus immédiat mais s'il y a beaucoup de sujets, cela risque d'occuper trop de mémoire, surtout pour les sujets sans observateurs ou avec peu d'observateurs. On pourra gagner de l'espace au détriment du temps d'exécution en gardant une table associative des couplages sujets - observateurs.</p>
                                </li>
                                <li>
                                    <p><span class="em">Observer plus d'un sujet à la fois.</span> Dans ce cas, le sujet qui notifie l'observateur passera une référence à lui-même lors de l'appel de <span class="html">update()</span>.</p>
                                </li>
                                <li>
                                    <p class="em">Qui déclenche les updates ?</p>
                                    <ul>
                                        <li>
                                            <p>Toutes les opérations de modification du sujet appellent <span class="html">notify()</span>. Les clients ne doivent s'occuper de rien mais plusieurs petites opérations de modifications consécutives entraînent autant de notifications, ce qui peut être inefficace.</p>
                                        </li>
                                        <li>
                                            <p>Au contraire, ce sont les clients qui appellent <span class="html">notify()</span> après avoir changé le sujet. Ceci évite les mises à jour intermédiaires inutiles mais augmente la responsabilité des clients et le risque d'erreur qu'engendrerait un oubli d'appelé <span class="html">notify()</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">Les références à des sujets qui n'existent plus.</span> Si on supprime un sujet, il faut le signaler aux observateurs afin qu'ils piossent prendre une décision appropriée (remise à null de la référence au sujet par exemple). Détruire les observateurs automatiquemnt n'a pas de sens parce que d'autres objets peuvent les référencer ou ils peuvent observer plusieurs sujets.</p>
                                </li>
                                <li>
                                    <p><span class="em">S'assurer que l'état du sujet est cohérent avant notification.</span> Cette règle de cohérence est violée facilement de manière non intentionnelle si des opérations d'une sous-classe Subject appellent des méthodes héritées. Par exemple la notification faite dans le code ci-après est déclenchée alors que le sujet est dans un état inconsistant.</p>
<pre><code>class BaseClassSubject {
public:
    void Operation(int newValue);
};

class MySubject : public BaseClassSubject {
public:
    void Operation(int newValue);
private:
    int _myInstVar;
};

void BaseClassSubject::Operation(int newValue) {
    // ...
    notify();
}

void MySubject::Operation(int newValue) {
    BaseClassSubject::Operation(newValue); // ceci déclenche la notification
    _myInstVar += newValue; // update subclass state (too late !)
}</code></pre>
                                    <p>Dans ce cas il est préférable que les notifications ne soient envoyées que par des Template Method décrites dans la classe abstraite Subject. Dans ces méthodes l'appel à <span class="html">notify()</span> sera la dernière instruction. Par exemple :</p>
<pre><code>typedef int TextRange;
class Text {
public:
    void Cut(int newValue); // Template Method
protected:
    void ReplaceRange(int newValue);
private:
    void Notify();
};

void Text::Cut(TextRange r) {
    ReplaceRange(r); // redéfinie dans les sous-classes
    Notify();
}</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Choisir entre les modèles <span class="html">push</span> et <span class="html">pull</span>.</span> Dans le modèle push, le sujet, lors de la notification, envoie tous les renseignements concernant le changement. Dans le modèle pull, la notification est minimale et l'observateur devra demander les détails par la suite. Le modèle push est préférable s'il y a peu de sujets et beaucoup d'observateurs différents. En effet, ce modèle tend à simplidfier le code du côté des observateurs qui ne doivent pas essayer de savoir ce qui a provoqué la notification. Pour une discussion complète de ces modèles nous vous renvoyons à l'article de D. Schmidt et S. Vinoski : The OMG Event Object Service paru dans le C++ Report et disponible sur Internet au site du premier auteur (<a href="http://www.cs-wustl.edu/~schmidt" target="_blank">http://www.cs-wustl.edu/~schmidt</a>). L'OMG utilise en fait deux modèles dans l'Event Service de CORBA :</p>
                                    <img src="../images/implementation_observer.png" alt="">
                                    <p>Quand un sujet push génère un événement, l'event channel l'envoie à tous ses observateurs enregistrés push et stocke les informations jusqu'à ce que tous les observateurs pull on requis ces renseignements.</p>
                                    <p>L'event channel doit périodiquement demander les informations à ses sujets pull. Cette demande se fera suiyte à la demande d'un observateur pull ou sur l'initiative de l'event channel.</p>
                                </li>
                                <li>
                                    <p><span class="em">Spécification explicite des modifications auxquelles on est intéressé.</span> Pour améliorer l'efficacité, les observateurs peuvent ne s'enregistrer que pour certains événements. Ils ne seront alors notifiés que pour ceux-là. Les interfaces seront légèrement modifiées. Par exemple, comme suit :</p>
                                    <p>Dans Subject :</p>
<pre><code>Subject::attach(Observer *, Aspect& interest);</code></pre>
                                    <p>Dans Observer :</p>
<pre><code>Observer::update(Subject *, Aspect& interest);</code></pre>
                                </li>
                                <li>
                                    <p><span class="em">Songer à encapsuler la sémantique d'updates complexes.</span> Si la dépendance entre sujets et observateurs devient trop complexe, on devra utiliser un objet intermédiaire pour gérer ves dépendances. Un tel objet, appelé ChangeManager, est un exemple d'utilisation du pattern Mediator. En général, il n'y a qu'un ChangeManager, et donc il sera implémenté en Singleton. Ses responsabilités seront :</p>
                                    <ul>
                                        <li>
                                            <p>Garder la correspondance sujets - observateurs.</p>
                                        </li>
                                        <li>
                                            <p>Définir une (ou plusieurs, par simple héritage) stratégie(s) de mise à jour.</p>
                                        </li>
                                        <li>
                                            <p>Mettre à jour tous les observateurs à la requête d'un sujet.</p>
                                        </li>
                                    </ul>
                                    <p>Dans l'exemple de l'Event Service de CORBA, l'event channel est un tel ChangeManager.</p>
                                </li>
                                <li>
                                    <p><span class="em">Regrouper les classes Subject et Observer.</span> Dans les langages sans héritage multiple, il est souvent utile de regrouper les interfaces de Subject et d'Observer dans une même classe. C'est le cas de Smalltalk, où les interfaces Subject et Observer sont déclarés dans la classe Object, et donc toutes les classes en héritent.</p>
                                    <p>En Java, le problème est différent, puisqu'une classe peut hériter de plusieurs interfaces. Java nous facilite le travail en définissant une interface java.util.Observer et une classe java.util.Observable qui est notre classe abstraite Subject. L'interface <span class="html">Observer</span> ne déclare qu'une méthode :</p>
<pre><code>public abstract void update(Observable o, Object arg);</code></pre>
                                    <p>La classe <span class="html">Observable</span> déclare les méthodes :</p>
<pre><code>public synchronized void addObserver(Observer o);
protected synchronized void clearChanged();
public synchronized int countObservers();
public synchronized void deleteObserver(Observer o);
public synchronized void deleteObservers();
public synchronized boolean hasChanged();
public void notifyObservers();
public void notifyObservers(Object arg);
protected synchronized void setChanged();</code></pre>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Donnons un exemple en Java utilisant les possibilités de ce langage.</p>
                            <p>Les classes intervenant sont les suivantes :</p>
                            <img src="../images/exemple_observer.png" alt="">
                            <p>où la classe entourée dans le schéma désigne une interface.</p>
                            <p><span class="em">Counter</span> peut augmenter ou diminuer de un. À chaque changement il notifie ses observateurs.</p>
                            <p><span class="em">IncreaseCounter</span> est à la fois observateur et sujet (il dérive d'Observable). Il observe les Counter et notifie ses observateurs du changement.</p>
                            <p><span class="em">CounterButton</span> est une classe abstraite pour changer la valeur d'un Counter.</p>
                            <p><span class="em">IncreaseButton</span> étend CounterButton et augmente la valeur du Counter.</p>
                            <p><span class="em">DecreaseButton</span> étend CounterButton et diminue la valeur du Counter.</p>
                            <p><span class="em">CounterView</span> est une classe parent observant les Counter. Elle ne fait rien.</p>
                            <p><span class="em">CounterTextView</span> étend la classe précédente et affiche la valeur du Counter en ASCII.</p>
                            <p><span class="em">ButtonController</span> étend CounterView et change la valeur d'un Counter via un IncreaseButton et un DecreaseButton.</p>
                            <p><span class="em">RectangleView</span> étend CounterView et observe deux Counter, l'un pour la largeur et l'autre pour la hauteur du rectangle affiché. Sa couleur varie avec sa forme.</p>
                            <p class="html">class Counter</p>
<pre><code>/**
* A counter can increase/decrease by 1. Each time a counter
* changes value, it notifies its observers of the type of
* change.
*/

class Counter extends Observable {
    public static final String INCREASE = "increase";
    public static final String DECREASE = "decrease";

    private int count = 0;
    private String label;

    public Counter(String label) { this.label = label; }

    public String label() { return label; }
    public int value() { return count; }
    public String toString() { return String.valueOf(count); }

    public void increase() {
        count++;
        setChanged();
        notifyObservers(INCREASE);
    }

    public void decrease() {
        count--;
        setChanged();
        notifyObservers(DECREASE);
    }
}</code></pre>
                            <p class="html">class IncreaseDetector</p>
<pre><code>/**
* IncreaseDetector is an observer that observes counters.
* IncreaseDetector counts the number of times one of its
* observables increases.
*/

class IncreaseDetector extends Counter implements Observer {
    public IncreaseDetector(String label) {
        super(label);
    }

    public void update(Observable whatChanged, Object message) {
        if (message.equals(Counter.INCREASE))
            increase();
    }
}</code></pre>
                            <p class="html">abstract class CounterButton</p>
<pre><code>/**
* An abstract class for changing a counter each time the button is
* pressed
*/

abstract class CounterButton extends Button {
    protected Counter count;

    public CounterButton(String buttonName, Counter count) {
        super(buttonName);
        this.count = count;
    }

    public boolean action(Event processNow, Object argument) {
        changeCounter();
        return true;
    }

    abstract protected void changeCounter();
}</code></pre>
                            <p class="html">class IncreaseButton</p>
<pre><code>/**
* A button that increases a counter each time it is pressed
*/

class IncreaseButton extends CounterButton {
    public IncreaseButton(Counter count) {
        super("Increase", count);
    }

    protected void changeCounter() { count.increase(); }
}</code></pre>
                            <p class="html">class DecreaseButton</p>
<pre><code>/**
* A button that decreases a counter each time it is pressed
*/

class DecreaseButton extends CounterButton {
    public DecreaseButton(Counter count) {
        super("Decrease", count);
    }

    protected void changeCounter() { count.decrease(); }
}</code></pre>
                            <p class="html">class CounterView</p>
<pre><code>/**
* A parent window view that observes a counter
*/

class CounterView extends Frame implements Observer {
    public CounterView(String label, int x, int y, int witdth, int height) {
        setTitle(label);
        reshape(x, y, width, height);
        setLayout(new FlowLayout());
    }

    /**
    * Redraw the window when an observed counter changes
    */

    public void update(Observable counter, Object argument) {
        repaint();
    }
}</code></pre>
                            <p class="html">class CounterTextView</p>
<pre><code>/**
* A window for displaying the value of a counter in ASCII
*/

class CounterTextView extends CounterView {
    Counter model;

    public CounterTextView(Counter model, String label, int x, int y, int width, int height) {
        super(label, x, y, width, height);
        this.model = model;
        model.addObserver(this);
        show();
    }

    public void paint(Graphics display) {
        int y = bounds().height - 20;
        int x = 20;
        display.drawString("The value of " + model.label() + " is " + model, x, y);
    }
}</code></pre>
                            <p class="html">class ButtonController</p>
<pre><code>/**
* A window for changing the value of a counter
*/

class ButtonController extends CounterView {
    public ButtonController(Counter model, int x, int y, int width, int height) {
        super(model.label(), x, y, width, height);
        model.addObserver(this);

        // show the value of the counter
        new CounterTextView(model, "Value of " + model.label(), x + width + 5, y, 150, 50);

        // buttons to change counter
        add(new IncreaseButton(model));
        add(new DecreaseButton(model));
        show();
    }
}</code></pre>
                            <p class="html">class RectangleView</p>
<pre><code>/**
* Draws a colored rectangle that depends on two counters.
* One counter is the width, the other counter is the height
* of the rectangle. The color of rectangle varies with its shape
*/

class RectangleView extends CounterView {
    Counter width;
    Counter height;

    public RectangleView(Counter rectWidth, Counter rectHeight, int x, int y) {
        super("Rectangle", x, y, 150, 150);
        height = rectHeight;
        width = rectWidth;
        rectWidth.addObserver(this);
        rectHeight.addObserver(this);
        show();
    }

    public void paint(Graphics display) {
        int x = 10;
        int y = 10;

        // Magnify value by 5 to get a bigger visual effect
        int height = 5 * this.height.value();
        int width = 5 * this.width.value();

        // Determine color. Colors chosen for fun.
        // The factor of 3 is just to magnify effect of change
        if (width &gt;= 0 && height &gt;= 0)
            display.setColor(new Color(3*width, 3*height, width + height));
        else if (width &lt; 0 && height &gt;= 0)
            display.setColor(Color.pink);
        else if (width &gt;= 0 && height &lt; 0)
            display.setColor(Color.orange);
        else if (width &lt; 0 && height &lt; 0)
            display.setColor(Color.red);

        display.fillRect(x, y, Math.abs(width), Math.abs(height));
    }
}</code></pre>
                            <p class="html">Programme de test</p>
<pre><code>class TestButton {
    public static void main(String[] args) {
        Counter x = new Counter("x");
        Counter y = new Counter("y");

        IncreaseDetector plus = new IncreaseDetector("Pluses");
        x.addObserver(plus);
        y.addObserver(plus);

        new ButtonController(x, 30, 30, 150, 50);
        new ButtonController(y, 30, 100, 150, 50);

        new CounterTextView(plus, "# of increases", 30, 170, 150, 50);
        new RectangleView(x, y, 340, 30);
    }
}</code></pre>
                            <p>À l'exécution on a les fenêtre suivantes :</p>
                            <img src="../images/implementation_observer_2.png" alt="">
                            <p>et les collaborations ci-dessous :</p>
                            <img src="../images/implementation_observer_3.png" alt="">
                        </dd>
                        <dt>Le Model / View / Controller (MVC) de Smalltalk</dt>
                        <dd>
                            <p>Smalltalk utilise une "triade de classes" appelée Model / View / Controller pour construire les interfaces utilisateurs. On y trouve trois sortes de classes : model qui représente l'application, View qui en est l'interface utilisateur et Controller qui indique comment l'interface réagit à des entrées de l'utilisateur.</p>
                            <p>Le lien entre Model et View obéit au protocole push and subscribe. Il s'agit donc d'une application du pattern <span class="em">Observer</span>. Il permet d'avoir plusieurs Views pour un même Model et les deux notions sont ainsi découplées.</p>
                            <p>MVC permet de plus de définir des Views emboîtées. Celles-ci sont dès lors implémentées comme des <span class="em">Composites</span>.</p>
                            <p>La relation entre View et Controller est une utilisation du pattern <span class="em">Strategy</span>.</p>
                            <p>MVC utilise encore d'autres patterns : une <span class="em">Factory Method</span> est employée pour définir un Controller par défaut, <span class="em">Decorator</span> sert à ajouter du scrolling au Views, mais les relations principales dans MVC sont données par Observer, Composite et Strategy.</p>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <p>Mediator est utilisé pour implémenter le ChangeManager.</p>
                            <p>Singleton peut être employé pour rendre le ChangeManager unique et accessible globalement.</p>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="chain_of_responsibility">Chain of Responsibility :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Éviter un couplage entre l'envoyeur d'une requête et son destinataire en donnant à plusieurs objets l'occassion de traiter la requête. Le pattern crée une chaîne d'objets destinataire et propage la requête le long de la chaîne jusqu'à ce qu'un objet la traite.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Plusieurs exemples justifient ce pattern : la gestion des événements dans une interface graphique utilisateur, la gestion des exceptions dans une chaîne d'objets. L'exemple qui nous guidera sera celui d'une aide en ligne contextuelle pour une interface graphique utilisateur. L'aide sera différente selon l'objet sélectionné. Si cet objet n'a pas d'information d'aide, ce sera à l'objet contenant à afficher l'aide, etc.</p>
                            <p>Le problème est que l'objet qui finalement donnera l'aide n'est pas connu explicitement de l'objet qui initie la demande. La solution sera de créer une chaîne d'objets le long de laquelle la requête sera passée.</p>
                            <img src="../images/motivation_chain_of_responsibility.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Chain of Responsibility quand :</p>
                            <ul>
                                <li>
                                    <p>plus d'un objet peut traiter la requête et que celui qui la traitera n'est pas connu à priori.</p>
                                </li>
                                <li>
                                    <p>on veut envoyer une requête à un objet parmi plusieurs sans préciser le destinataire de la requête.</p>
                                </li>
                                <li>
                                    <p>l'ensemble des objets pouvant traiter la requête devra être spécifié à l'exécution.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_chain_of_responsibility.png" alt="">
                            <p>ce qui donnera lieu lors de l'exécution à une chaîne d'objets telle que :</p>
                            <img src="../images/structure_participants_collaborations_objets_chain_of_responsibility.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Handler</span> : qui définit l'interface de traitement des requêtes et implémente éventuellement un lien vers le successeur.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteHandler</span> : qui traitera les requêtes dont il est responsable et pourra accéder à son successeur pour lui transmettre les requêtes dont il n'est pas responsable.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : qui initie la requête.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Le couplage est réduit puisque ni l'envoyeur ni le destinataire n'ont une connaissance explicite l'un de l'autre. Un envoyeur ne devra pas garder de références vers tous les objets pouvant traiter une requête.</p>
                                </li>
                                <li>
                                    <p>La flexibilité est augmentée en répartissant les responsabilités entre différents objets. On pourra, à l'exécution, modifier ou ajouter des responsabilités de traitement d'une requête en modifiant ou augmentant la chaîne.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p>La réception n'est pas garantie. Une requête peut arriver en bout de chaîne sans avoir été traitée. Une requête pourrait également ne pas être traitée en cas de mauvaise configuration de la chaîne.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Comment implémenter la chaîne ?</span> Deux manières sont possibles :</p>
                                    <ul>
                                        <li>
                                            <p>Définir de nouveaux liens dans Handler le plus souvent mais aussi parfois dans ConcreteHandler.</p>
                                        </li>
                                        <li>
                                            <p>Utiliser des liens existants, par exemple le lien vers le parent dans un pattern Composite.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">La maintenance des successeurs.</span> Quand il n'y a pas de lien existant, non seulement Handler définira un lien vers le successeur mais de plus, il fournira une implémentation par défaut du traitement d'une requête : comme Handler ne traite lui-même aucune requête, ce traotement par défaut sera d'appeler le successeur :</p>
<pre><code>class HelpHandler {
public:
    HelpHandler(HelpHandler* s) : _successor(s) { }
    virtual void HandleHelp();
private:
    HelpHandler* _successor;
};

void HelpHandler::HandleHelp() {
    if (_successor) {
        _successor-&gt;HandleHelp();
    }
}</code></pre>
                                    <p>Une sous-classe de type ConcreteHandler qui ne serait pas intéressée par cette requête n'a dès lors pas à redéfinir <span class="html">HandleHelp()</span>.</p>
                                </li>
                                <li>
                                    <p><span class="em">La représentation des requêtes.</span> Différentes options sont possibles :</p>
                                    <ul>
                                        <li>
                                            <p>Les requêtes peuvent être hard-codées.</p>
<pre><code>abstract class HardCodedHandler {
    private HardCodedHandler successor;

    public HardCodedHandler(HardCodedHandler aSuccessor) { successor = aSuccessor; }

    public void handleOpen() {
        if (successor != null)
            successor.handleOpen();
    }

    public void handleClose() {
        if (successor != null)
            successor.handleClose();
    }

    public void handleNew(String fileName) {
        if (successor != null)
            successor.handleNew(fileName);
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Une seule méthode peut implémenter toutes les requêtes.</p>
<pre><code>abstract class SingleHandler {
    private SingleHandler successor;

    public SingleHandler(SingleHandler aSuccessor) {
        successor = aSuccessor;
    }

    public void handle(String request) {
        if (sucessor != null)
            successor.handle(request);
    }
}

class ConcreteOpenHandler extends SingleHandler {
    public void handle(String request) {
        switch(request) {
            case "Open" : trt_open(); break;
            case "Close" : trt_close(); break;
            case "New" : trt_new(); break;
            default : super.handle(request); break;
        }
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Utiliser une classe Request qui sera passée en paramètre à une méthode de traitement unique.</p>
<pre><code>abstract class SingleHandler {
    private SingleHandler successor;

    public SingleHandler(SingleHandler aSuccessor) {
        successor = aSuccessor;
    }

    public void handle(Request data) {
        if (successor != null)
            successor.handle(data);
    }
}

class ConcreteOpenHandler extends SingleHandler {
    public void handle(Request data) {
        switch(data.getKind()) {
            case OPEN:
                // traiter l'ouverture
                break;
            default:
                super.handle(data);
                break;
        }
    }
}

class Request {
    private int kind;
    private String name;
    public Request(int myKind, String myName) { kind = myKind; name = myName; }

    public int getKind() { return kind; }
    public String getName() { return name; }
}

class Open extends Request {
    // placer ici du code spécifique à Open
}

class Close extends Request {
    // placer ici du code spécifique à Close
}</code></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Développons l'exemple d'écrit dans la section Motivation :</p>
<pre><code>class Application;
class Dialog;
class HelpHandler;

typedef int Topic;
const Topic NO_HELP_TOPIC = -1;

class HelpHandler {
public:
    HelpHandler(HelHandler* = 0, Topic = NO_HELP_TOPIC);
    virtual bool HasHelp();
    virtual void SetHandler(HelpHandler*, Topic);
    virtual void HandleHelp();
private:
    HelpHandler* _successor;
    Topic _topic;
};

HelpHandler::HelpHandler(HelHandler* h, Topic t) : _successor(h), _topic(t) { }

bool HelpHandler::HasHelp() {
    return _topic != NO_HELP_TOPIC;
}

void HelpHandler::HandleHelp() {
    if (_successor != 0) {
        _successor-&gt;HandleHelp();
    }
}</code></pre>
                            <p>Tous les widgets seront des sous-classes de la classe Widget qui dérive elle-même de HelpHandler.</p>
<pre><code>class Widget : public HelpHandler {
protected:
    Widget(Widget* parent, Topic t = NO_HELP_TOPIC);
private:
    Widget* _parent;
};

Widget::Widget(Widget* w, Topic t) : HelpHandler(w, t) {
    _parent = w;
}</code></pre>
                            <p>Le premier widget de la chaîne sera un Button. Le premier paramètre de son constructeur est le Widget qui contient le Button.</p>
<pre><code>class Button : public Widget {
public:
    Button(Widget* d, Topic t = NO_HELP_TOPIC);

    virtual void HandleHelp();
    // Widgte operations that Button overrides...
};

Button::Button(Widget* h, Topic t) : Widget(h, t) { }

void Button::HandleHelp() {
    if (HasHelp()) {
        // offer help on the button
    } else {
        HelpHandler::HandleHelp();
    }
}</code></pre>
                            <p>La classe Dialog n'a pas comme successeur un Widget mais n'importe quel HelpHandler, par exemple une Application.</p>
<pre><code>class Dialog : public Widget {
public:
    Dialog(HelpHandler* h, Topic t = NO_HELP_TOPIC);
    virtual void HandleHelp();

    // Widget operations that Dialog overrides...
    // ...
};

Dialog::Dialog(HelHandler* h, Topic t) : Widget(0) {
    SetHandler(h, t);
}

void Dialog::HandleHelp() {
    if (HasHelp()) {
        // offer help on the dialog
    } else {
        HelpHandler::HandleHelp();
    }
}</code></pre>
                            <p>La classe Appplication qui terminera la chaîne dans notre exemple, n'est pas un Widget mais dérive de HelpHandler.</p>
<pre><code>class Application : public HelpHandler {
public:
    Application(Topic t) : HelpHandler(0, t) { }

    virtual void HandleHelp();
    // application-specific operations...
};

void Application::HandleHelp() {
    // show a list of help topics
}</code></pre>
                            <p>Donnons enfin un exemple de programme utilisant ce qui a été décrit ci-dessus.</p>
<pre><code>void dummy() {
    const Topic PRINT_TOPIC = 1;
    const Topic PAPER_ORIENTATION_TOPIC = 2;
    const Topic APPLICATION_TOPIC = 3;

    Application* application = new Application(APPLICATION_TOPIC);
    Dialog* dialog = new Dialog(application, PRINT_TOPIC);
    Button* button = new Button(dialog, PAPER_ORIENTATION_TOPIC);

    button-&gt;HandleHelp();
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <p>Chain of Responsibility est souvent employé conjointement à Composite. Dans ce cas, le parent pourra servir de successeur.</p>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="memento">Memento :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Token</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Capturer et externaliser l'état interne d'un objet sans briser l'encapsulation afin de pouvoir restaurer l'objet dans cet état plus tard.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Restaurer l'état d'un objet est nécessaire pour implémenter des checkpoints et permettre des rollbacks. De même pour mettre en oeuvre des undos. Mais un objet cache l'information qu'il contient. Il n'est donc pas facile de sauver son état sans briser cette encapsulation. Considérons un éditeur graphique qui permet de déplacer les éléments d'un dessin en étirant les autres pour garder les liens entre ces éléments :</p>
                            <img src="../images/motivation_memento.png" alt="">
                            <p>Une opération d'undo mal gérée remettrait uniquement le rectangle en place :</p>
                            <img src="../images/motivation_memento_2.png" alt="">
                            <p>Il faudra donc encapsuler les contraintes de connectivité dans un objet de classe ConstraintSolver. Malheureusement, si le ConstraintSolver enregistre le déplacement fait et doit calculer à partir de celui-ci le mouvement inverse à réaliser pour défaire le déplacement, ce mouvement inverse risque d'être trop difficile à calculer (il n'est pas toujours possible de trouver une fonction inverse d'une fonction donnée !). Il faudra donc plus de renseignements. Le plus simple sera, avant le mouvement, de stocker une représentation de l'état interne des objets (au moins leur position pour un déplacement). Un objet stockant cette information sera un Mementp et l'objet qui demande sa création sera son Originator (ici ce sera ConstraintSolver). Si l'utilisateur demande de défaire le déplacement, le Memento sera utilisé pour rétablir la position de départ.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Memento quand :</p>
                            <ul>
                                <li>
                                    <p>(une partie de) l'état d'un objet doit être sauvé(e) afin de pouvoir restaurer l'objet dans cet état plus tard et quand le faire via une interface directe exposerait trop les détails d'implémentation de l'objet et briserait l'encapsulation.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_memento.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Memento</span> : stocke ce qu'il a besoin de l'état de l'objet Originator et protège contre l'accès par d'autres objets que l'Originator. Pour ce faire, il aura deux interfaces : l'une étroite qu'il présente au Carataker et l'autre large, pour l'Originator. Il serait même préférable que seul l'<span class="em">objet</span> Originator qui a créé le Memento ait accès à cette interface.</p>
                                </li>
                                <li>
                                    <p><span class="em">Originator</span> : crée un Memento contenant une vue de son état actuel et l'utilise pour restaurer cet état.</p>
                                </li>
                                <li>
                                    <p><span class="em">Caretaker</span> : qui est responsable de la sécurité du Memento et n'examine jamais le contenu de celui-ci.</p>
                                </li>
                            </ul>
                            <p>Ces objets collaborent depuis l'instant où le Caretaker demande la création d'un Memento à un Originator, le conserve un temps puis le repasse à l'Originator pour que celui-ci restaure son état précédent :</p>
                            <img src="../images/structure_participants_collaborations_memento_2.png" alt="">
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Ce pattern préserve l'encapsulation : il évite d'exposer des informations que l'Originator doit être seul à connaître mais qui doivent pourtant être stockée en dehors de l'Originator.</p>
                                </li>
                                <li>
                                    <p>Il simplifie l'Originator : sans lui, l'Originator : sans lui, l'Originator devrait se charger lui-même de la sauvegarde.</p>
                                </li>
                            </ul>
                            <p>Désavantages :</p>
                            <ul>
                                <li>
                                    <p>L'utiliser peut être cher : particulièrement si de grandes quantités d'informations doivent être recopiées. Dans un tel cas le pattern pourrait ne pas être approprié.</p>
                                </li>
                                <li>
                                    <p>La définition d'une interface étroite et d'une interface large peut être difficile.</p>
                                </li>
                                <li>
                                    <p>Le Caretaker ne sait pas combien d'information stocke le Memento.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Les possibilités du langage</span> : C++ permet de définir une interface étroite et de donner accès à tout Memento en faisant d'Originator une classe amie de Memento :</p>
<pre><code>class Memento;
class State;

class Originator {
public:
    Memento* createMemento();
    void setMemento(const Memento*);
    // ...
private:
    State* _state; // internal data structure
    // ...
};

class Memento {
public:
    // narrow public interface
    virtual ~Memento();
private:
    // private members accessible only to Originator
    <span class="html">friend class Originator;</span>
    Memento();

    void setState(State*);
    State* getState();
    // ...
private:
    State* _state;
    // ...
};</code></pre>
                                    <p>En Java, on n'a pas cette possibilité. On obtiendra un semblant de protection en plaçant Memento et Originator dans le même package et en déclarant <span class="html">protected</span> les méthodes de l'interface large de Memento.</p>
<pre><code>package MyMemento;

class Memento {
    private Hashtable savedState = new Hashtable();

    protected Memento() {}; // Give some protection

    protected void setState(String stateName, Object stateValue) {
        savedState.put(stateName, stateValue);
    }

    protected Object getState(String stateName) {
        return savedState.get(stateName);
    }

    protected Object getState(String stateName, Object defaultValue) {
        if (savedState.containsKey(stateName))
            return savedState.get(stateName);
        else
            return defaultValue;
    }
}

package MyMemento;

class Originator {
 private String name;
 private int someData;
 private Vector objectAsState = new Vector();   

 public Memento createMemento() {
    Memento currentState = new Memento();
    currentState.setState("name", name);
    currentState.setState("someData", new Integer(someData));
    currentState.setState("objectAsState", objectAsState.clone());
    return currentState;
 }

 public void setMemento(Memento oldState)  { // to restore state
    name = (String) oldState.getState("name", name);
    objectAsState = (Vector) oldState.getState("objectAsState");
    Integer data = (Integer) oldState.getState("someData");
    someData = data.intValue();
 }
}</code></pre>
                                    <p>Si la classe <span class="em">Memento</span> ne doit pas être accessible on pourra la mettre en classe interne d'<span class="em">Originator</span>.</p>
                                </li>
                                <li>
                                    <p><span class="em">Stocker seulement les modifications incrémentales</span> : Si la création et le renvoi des Mementos à leur Originator sont faits de manière prévisible, on pourra ne stocker que les modifications incrémentales. Par exemple les undos d'un éditeur de texte sont faits dans l'ordre inverse des modifications. On ne stockera donc que ce qui vient d'être changé.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Voici le code C++ pour l'exemple du ConstraintSolver vu plus haut :</p>
<pre><code>class ConstraintSolverMemento;
class ConstraintSolver;

class Graphic {
    public:
        void Move(const Point&);
};

class MoveCommand { // exemple du pattern Command
public:
    MoveCommand(Graphic* target, const Point& delta);
    void Execute();
    void Unexecute();
private:
    ConstraintSolverMemento* _state;
    Point _delta;
    Graphic* _target;
};

class ConstraintSolver { // implémenté comme un Singleton
public:
    static ConstraintSolver* Instance();

    void Solve();
    void AddConstraint(Graphic* startConnection, Graphic* endConnection);
    void RemoveConstraint(Graphic* startCollection, Graphic* endConnection);

    ConstraintSolverMemento* CreateMemento();
    void SetMemento(ConstraintSolverMemento*);
private:
    // nontrivial state and operations for enforcing
    // connectivity semantics
};

class ConstraintSolverMemento {
public:
    virtual ~ConstraintSolverMemento();
private:
    friend class ConstraintSolver;
    ConstraintSolverMemento();

    // private constraint solver state
};

void MoveCommand::Execute() {
    ConstraintSolver* solver = ConstraintSolver::Instance();
    _state = solver-&gt;CreateMemento(); // create a memento
    _target-&gt;Move(_delta);
    solver-&gt;Solve();
}

void MoveCommand::Unexecute() {
    ConstraintSolver* solver = ConstraintSolver::Instance();
    _target-&gt;Move(-_delta);
    solver-&gt;SetMemento(_state); // restore solver state
    solver-&gt;Solve();
}</code></pre>
                        </dd>
                        <dt>Iterator et Memento</dt>
                        <dd>
                            <p>Un Iterator peut utiliser un Memento pour stocker l'état actuel de l'itération. Cette manière de procéder a été utilisée pour la première fois dans le langage orienté objet Dylan. Celui-ci définit la notion de Collection et pour celle-ci un objet d'état qui est en réalité un Memento. Voici ce que cela donne en traduction C++ :</p>
<pre><code>class IterationState; // c'est un Memento

template &lt;class Item&gt;
class Collection {
public:
    Collection();

    IterationState* CreateInitialState();
    void Next(IterationState*);

    bool IsDone(const IterationState*) const;
    Item CurrentItem(const IterationState*) const;
    IterationState* Copy(const IterationState*) const;

    void Append(const Item&);
    void Remove(const Item&);
    // ...
};</code></pre>
                            <p>Montrons comment ceci peut être utilisé pour parcourir la collection :</p>
<pre><code>class ItemType {
public:
    void Process();
    // ...
};

void dummy() {
    Collection&lt;ItemType*&gt; aCollection;
    IterationState* state;

    state = aCollection.CreateInitialState();

    while (!aCollection.IsDone(state)) {
        aCollection.CurrentItem(state)-&gt;Process();
        aCollection.Next(state);
    }
    delete state;
}</code></pre>
                            <p>L'utilisation d'un Memento est particulièrement utile avec un Iterator interne. Dans ce cas, rappelons que l'objet à itérer est lui-même son Iterator et garde une référence à la position courante. Ceci empêche de définir plusieurs itérations simultanées du même objet. L'utilisation d'un Memento pourra permettre d'effectuer plusieurs itérations parallèles avec un Iterator interne. Montrons-le d'abord sur une collection linéaire. Tout d'abord présentons le code sans utiliser de Memento :</p>
<pre><code>class Sequence {
    protected Object[] elementData;
    protected int elementCount;
    protected int currentPosition;

    public boolean hasMoreElements() {
        return currentPosition &lt; elementCount;
    }

    public Object nextElement() {
        if (currentPosition &lt; elementCount)
            return elementData[currentPosition++];
        throw new NoSuchElementException("VectorIterator");
    }

    // all Sequence methods not shown
}</code></pre>
                            <p>Montrons mainteant comment l'emploi de Memento pourra permettre des itérations simultanées : On définira un Memento en se basant sur ce qui est fait pour itérer les Collections de Dylan.</p>
<pre><code>class IteratorState { // C'est le Memento
    int currentPosition = 0;

    protected IteratorState() {}

    protected int getPosition() { return currentPosition; }

    protected void advancePosition() { currentPosition++; }
    // Other methods ?
}

class Sequence {
    protected Object[] elementData;
    protected int elementCount;

    public IteratorState newIteration() { return new IteratorState(); }

    public boolean hasMoreElements(IteratorState aState) {
        return aState.getPosition() &lt; elementCount;
    }

    public Object nextElement(IteratorState aState) {
        if (hasMoreElements(aState)) {
            int currentPosition = aState.getPosition();
            aState.advancePosition();
            return elementData[currentPosition];
        }
        throw new NoSuchElementException("SequenceIterator");
    }
    // all Sequence methods not shown
}</code></pre>
                            <p>Grâce à la méthode <span class="html">newIteration()</span> on pourra définir plusieurs itérations en parallèle.</p>
                            <p>Le travail que nous avons fait eu peu intéressant dans le cas d'une structure linéaire où il aurait été très simple de définir plutôt un Iterator externe. Mais c'est nettement plus utile pour des arbres. Dans ce cas un Iterator externe est fort difficile à écrire. Par contre un itérateur interne est facile à mettre en oeuvre de manière récursive. Dans ce cas, l'utilisation conjointe de Memento permettra d'avoir les avantages d'un Iterator externe avec un Iterator interne plus simple à réaliser.</p>
                            <p>Dans le cas d'un arbre, le Memento devra stocker plus d'information que la position courante. Commençons par remarquer qu'un noeud sera traversé trois fois : on stockera la position courante et le numéro de visite dans le Memento. De plus, la traversée utilisera une pile pour remonter vers le parent.</p>
                            <img src="../images/iterator_memento.png" alt="">
<pre><code>package treeTraversal;

public class TraversalStorage { // le Memento
    private BinaryNode storedNode;
    private int visitNumber = 1;

    protected TraversalStorage(BinaryNode aNode, int visitNumber) {
        storedNode = aNode;
        this.visitNumber = visitNumber;
    }

    portected BinaryNode getNode() {
        return storedNode;
    }

    protected int getVisitNumber() {
        return visitNumber;
    }
}</code></pre>
                            <p>La classe suivante parcourt chaque noeud de l'arbre mais n'y fait rien.</p>
<pre><code>package treeTraversal;

import java.util.Stack;

public class TreeTraversal {
    Stack history = new Stack();

    BinaryNode currentNode;
    int visitNumber;

    public TreeTraversal(BinaryNode startNode) {
        currentNode = startNode;
        visitNumber = 1;
    }

    public void visitAllNodes() {
        while((!history.empty()) || (visitNumber != 3)) {
            switch(visitNumber) {
                case 1:
                    processFirstVisit(currentNode);
                    break;
                case 2:
                    processSecondVisit(currentNode);
                    break;
                case3:
                    processThirdVisit(currentNode);
                    break;
            }
        }
    }

    private void processFirstVisit(BinaryNode currentNode) {
        if (currentNode.getLeftChild() != null) {
            history.push(new TraversalStorage(currentNode, 2));
            currentNode = (BinaryNode) currentNode.getLeftChild();
            visitNumber = 1;
        } else
            processSecondVisit(currentNode);
    }

    private void processSecondVisit(BinaryNode currentNode) {
        if (currentNode.getRightChild() != null) {
            history.push(new TraversalStorage(currentNode, 3));
            currentNode = (BinaryNode) currentNode.getRightChild();
            visitNumber = 1;
        } else
            processThirdVisit(currentNode);
    }

    private void processThirdVisit(BinaryNode currentNode) {
        if (!history.empty()) {
            TraversalStorage nextNode = (TraversalStorage) history.pop§);
            currentNode = nextNode.getNode();
            visitNumber = nextNode.getVisitNumber();
        }
    }
}</code></pre>
                            <p>On voit comment Memento facilite le parcours de l'arbre.</p>
                            <p>Pour effectuer un travail en chaque noeud, on utilisera le pattern Visitor : la classe BinaryNode implémentera une méthode <span class="html">accept(Visitor)</span>. On pourra alors définir de surcroît, un champ <span class="html">traversalType</span> dans la classe <span class="html">TreeTraversal</span> et modifier comme suit le constructeur et les méthodes <span class="html">processFirstVisit()</span>, <span class="html">processSecondVisit()</span> et <span class="html">processThirdVisit</span> :</p>
<pre><code>private int traversalType;
private Visitor myVisitor;

public static final int PREORDER = 1;
public static final int INORDER = 2;
public static final int POSTORDER = 3;

public TreeTraversal(BinaryNode startNode, int traversalType, Visitor aVisitor) {
    currentNode = startNode;
    visitNumber = 1;
    this.traversalType = traversalType;
    myVisitor = aVisitor; 
}

private void processFirstVisit(BinaryNode currentNode) {
    if (traversalType == PREORDER)
        currentNode.accept(myVisitor);
    if (currentNode.getLeftChild() != null) {
        history.push(new TraversalStorage(currentNode, 2));
        currentNode = (BinaryNode) currentNode.getLeftChild();
        visitNumber = 1;
    } else
        processSecondVisit(currentNode);
}

private void processSecondVisit(BinaryNode currentNode) {
    if (traversalType == INORDER)
        currentNode.accept(myVisitor);
    if (currentNode.getRightChild() != null) {
        history.push(new TraversalStorage(currentNode, 3));
        currentNode = (BinaryNode) currentNode.getRightChild();
        visitNumber = 1;
    } else
        processThirdVisit(currentNode);
}

private void processThirdVisit(BinaryNode currentNode) {
    if (traversalType == POSTORDER)
        currentNode.accept(myVisitor);
    if (!history.empty()) {
        TraversalStorage nextNode = (TraversalStorage) history.pop§);
        currentNode = nextNode.getNode();
        visitNumber = nextNode.getVisitNumber();
    }
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Iterator : la discussion précédente a montré comment Memento pouvait être utilisé par Iterator.</p>
                                </li>
                                <li>
                                    <p>Command : utilisera Memento si l'opération doit être défaite.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="command">Command :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Action, Transaction</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Encapsuler une requête comme un objet, afin de pouvoir paramétrer les clients avec différentes requêtes, placer les requêtes en file d'attente ou dans un log file et supporter des opérations de type undo.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Il est parfois nécessaire d'émettre des requêtes à des objets sans connaître l'opération demandée ni le destinataire de la requête. Par exemple un toolkit d'interface a des boutons et des menus mais ne sait pas implémenter les requêtes qui y sont associées car c'est seulement l'application qui utilise le toolkit qui saura quoi faire. Le pattern Command permet à un toolkit de gérer des requêtes inconnues en faisant de la requête un objet.</p>
                            <p>Considérons l'exemple de menus. Chaque choix est un objet de classe MenuItem. L'application configurera chaque MenuItem avec une instance de Command. Quand un utilisateur sélectionnera un MenuItem, ce dernier appellera la méthode <span class="html">execute()</span> de son objet Command sans savoir quelle sous-classe de Command est utilisée. Les sous-classes de Command seront configurées avec le ou les objets sur le(s)quel(s) appliquer l'exécution. Parfois un MenuItem doit exécuter une suite de commandes. On définira alors une classe MacroCommand comme une sous-classe de Command. MacroCommand ne sera pas configurée avec les objets destinataires mais sera composée des objets Command qui devront être exécutés (void Composite).</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Command quand :</p>
                            <ul>
                                <li>
                                    <p>on veut paramétrer l'objet avec une action à exécuter. Command est la façon orientée objet d'implémenter des callback functions, c'est-à-dire des fonctions enregistrées quelque part pour être appelées plus tard.</p>
                                </li>
                                <li>
                                    <p>on veut spécifier, mettre en attente et exécuter des requêtes à un autre moment. Le cycle de vie de l'objet Command peut être indépendant de la requête qu'il implémente. Si le destinataire de la requête peut être précisé de façon indépendante de l'espace d'adressage où on se trouve, on pourra transférer la requête à un autre processus pour qu'elle soit traitée par lui.</p>
                                </li>
                                <li>
                                    <p>on veut rendre possibles des opérations de type undo. La méthode <span class="html">execute()</span> de Command pourra stocker l'état pour annuler son effet si désiré. On pourra de plus stocker les commandes exécutées dans une liste d'historique ce qui permettra des undos et redos d'un nombre quelconque de niveaux.</p>
                                </li>
                                <li>
                                    <p>On veut enregistrer les requêtes dans un log file pour les réappliquer après un crash. Il faudra rajouter des méthodes <span class="html">load()</span> et <span class="html">store()</span> dans l'interface de Command.</p>
                                </li>
                                <li>
                                    <p>On veut structurer le système autour d'opérations de haut niveau construites à l'aide de primitives. Command donne la possibilité d'encapsuler de telles opérations, comme par exemple des transactions.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_command.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Command</span> : déclare l'interface d'exécution d'une opération.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteCommand</span> : définit la liaison entre le destinataire (Receiver) et l'action en implémentant la méthode <span class="html">execute()</span> pour invoquer cette opération sur le destinataire.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : crée une ConcreteCommand et précise son Receiver.</p>
                                </li>
                                <li>
                                    <p><span class="em">Invoker</span> : demande à la Command (concrète) de traiter la requête.</p>
                                </li>
                                <li>
                                    <p><span class="em">Receiver</span> : sait comment exécuter les opérations associées à une requête.</p>
                                </li>
                            </ul>
                            <p>Ces classes collaborent entre elles comme le montre le diagramme de séquence suivant :</p>
                            <img src="../images/structure_participants_collaborations_command_2.png" alt="">
                        </dd>
                        <dt>COnséquences</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Command découple l'objet qui invoque une opération de celui qui la traite.</p>
                                </li>
                                <li>
                                    <p>Les Commands sont des objets comme les autres et peuvent être traités comme tels.</p>
                                </li>
                                <li>
                                    <p>Les commandes peuvent être regroupées selon le pattern Composite pour créer des MacroCommands par exemple.</p>
                                </li>
                                <li>
                                    <p>On peut facilement ajouter de nouvelles Commands, puis qu'il ne faut pas changer les classes existantes.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Jusqu'à quel point Command doit-il être intelligent ?</span> Il peut se contenter d'une simple interface de liaison avec le Receiver mais aussi, à l'autre extrême, tout faire lui-même sans passer par un Receiver ou trouver son Receiver dynamiquement.</p>
                                </li>
                                <li>
                                    <p><span class="em">Le support d'opérations undo et redo.</span> Pour un niveau, Command stockera l'état avant d'effectuer l'opération <span class="html">execute()</span> ou <span class="html">unexecute()</span>. Pour un nombre quelconque de niveaux, une liste d'historique sera nécessaire. Si l'état de Command ne change jamais à l'exécution, une référence sera suffisante, sinon Command devra être copiée dans la liste (par exemple en utilisant le pattern Prototype).</p>
                                </li>
                                <li>
                                    <p><span class="em">Éviter l'accumulation d'erreurs lors d'une suite d'undo/redo.</span> Ceci se fera en stockant plus d'information qu'on pourrait le prévoir. Memento sera utile dans ce cas.</p>
                                </li>
                                <li>
                                    <p><span class="em">Employer les templates en C++.</span> On évitera la création de sous-classes pour Command de cette manière, mais ce n'est possible que si les opérations à effectuer n'ont pas d'arguments et ne doivent pas être défaites.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Développons quelque peu l'exemple de la motivation :</p>
<pre><code>class Document {
    public:
        Document(const char*);
        void Open();
        void Paste();
};

class Application {
    public:
        Application();
        void Add(Document*);
};

class Command {
public:
    virtual ~Command();

    virtual void Execute() = 0;
protected:
    Command();
};</code></pre>
                            <p>OpenCommand ouvre un document dont le nom est donné par la méthode <span class="html">AskUser()</span>. Le Receiver est une Application.</p>
<pre><code>class OpenCommand : public Command {
public:
    OpenCommand(Application*);

    virtual void Execute();
protected:
    virtual const char* AskUser();
private:
    Application* _application;
    char* _response;
};

OpenCommand::OpenCommand(Application* a) {
    _application = a;
}

void OpenCommand::Execute() {
    const char* name = AskUser();

    if (name != 0) {
        Document* document = new Document(name);
        _application-&gt;Add(document);
        document-&gt;Open();
    }
}</code></pre>
                            <p>Le Receiver de PasteCommand est un Document.</p>
<pre><code>class PasteCommand : public Command {
public:
    PasteCommand(Document*);

    virtual void Execute();
private:
    Document* _document;
};

PasteCommand::PasteCommand(Document* doc) {
    _document = doc;
}

void PasteCommand::Execute() {
    _document-&gt;Paste();
}</code></pre>
                            <p>Si les commandes ne doivent pas être défaites et n'ont pas de paramètres, on pourra utiliser des templates pour paramétrer le Receiver dans Command :</p>
<pre><code>template &lt;class Receiver&gt;
class SimpleCommand : public Command {
public:
    typedef void(Receiver::*Action) ();

    SimpleCommand(Receiver* r, Action a) : receiver(r), _action(a) { }

    virtual void Execute();
private:
    Action _action;
    Receiver* _receiver;
};

template &lt;class Receiver&gt;
void SimpleCommand&lt;Receiver&gt;::Execute() {
    (_receiver-&gt;*_action) ();
}</code></pre>
                            <p>Appliquons le template à un Receiver de classe MyClass :</p>
<pre><code>class MyClass {
public:
    void Action();
};

void dummy() {
    MyClass* receiver = new MyClass;
    // ...
    Command* aCommand = new SimpleCommand&lt;MyClass&gt;(receiver, &MyClass::Action);
    // ...
    aCommand-&gt;Execute();
}</code></pre>
                            <p>Indiquons enfin comment implémenter MacroCommand :</p>
<pre><code>class MacroCommand : public Command {
public:
    MacroCommand();
    virtual ~MacroCommand();

    virtual void Add(Command*);
    virtual void Remove(Command*);

    virtual void Execute();
private:
    List&lt;Commande*&gt;* _cmds;
};

void MacroCommand::Execute() {
    ListIterator&lt;Command*&gt; i(_cmds);

    for (i.First(); !i.IsDone(); i.Next()) {
        Command* c = i.CurrentItem();
        c-&gt;Execute();
    }
}

void MacroCommand::Add(Command* c) {
    _cmds-&gt;Append(c);
}

void MacroCommand::Remove(Command* c) {
    _cmds-&gt;Remove(c);
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Composite peut être utile pour mettre en oeuvre des MacroCommands.</p>
                                </li>
                                <li>
                                    <p>Memento sera utile pour stocker de l'information supplémentaire à l'installation d'un mécanisme d'undo/redo.</p>
                                </li>
                                <li>
                                    <p>Si une Command doit être copiée dans une liste d'historique, elle le sera par Prototype.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="prototype">Prototype :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Créationnel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Spécifier les sortes d'objets à créer en utilisant une instance prototype et créer ces objets en copiant ce prototype.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Considérons l'exemple d'un éditeur de partitions musicales créé à partir d'un framework d'éditeurs graphiques. Dans ce framework on trouve des outils pour sélectionner, déplacer des objets graphiques. Pour faire le design de l'éditeur de partitions nous définirons des sous-classes Note, Staff (portée), etc. d'une classe Graphic fournie par le framework. Le framework fourni également une classe abstraite Tool (Outil) pour nous permettre de rajouter des outils de manipulations de nos objets graphiques. Le framework définit de plus une sous-classe GraphicTool pour créer des objets graphiques et les placer dans le document. Le problème est que GraphicTool ne connaît pas nos sous-classes (Note, Staff, ...). Nous pourrions définir des sous-classes de GraphicTool pour chaque objet graphique que nous définirions. Mais cela générerait un très grand nombre de sous-classes vu le nombre d'objets graphiques différents qu'on peut trouver sur une partition (clef, armature, fraction de mesure, barre de mesure, sans compter les différentes sortes de notes et de silences !). Il sera donc préférable d'utiliser la composition plutôt que l'héritage. On devra donc configurer GraphicTool avec l'objet graphique à manipuler. Mais comment le framework peut-il employer la composition pour configurer GraphicTool avec la <span class="em">classe</span> qu'il doit créer et manipuler ? La solution sera pour GraphocTool de créer l'objet en clonant une instance d'une des sous-classes de Graphic. Une telle instance sera appelée prototype. Pour ce faire, chaque sous-classe de Graphic implémentera une méthode clone() afin que GraphicTool puisse cloner n'importe quel type d'objet graphique. Chaque outil sera donc une instance de GraphicTool initialisée avec un prototype différent.</p>
                            <img src="../images/motivation_prototype.png" alt="">
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Prototype quand un système doit être indépendant de la façon dont ses objets sont créés, composés et représentés et que de plus :</p>
                            <ul>
                                <li>
                                    <p>soit les classes à instancier sont spécifiées à l'exécution (par exemple par dynamic loading).</p>
                                </li>
                                <li>
                                    <p>soit on désire éviter de construire une hiérarchie de classes usines parallèle à la hiérarchie des produits à créer.</p>
                                </li>
                                <li>
                                    <p>soit les instances d'une classe ne peuvent avoir qu'un nombre restreint de combinaisons d'état. Plutôt que d'instancier manuellement dans chaque cas, il sera plus utile d'installer un prototype par état et de les copier.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_prototype.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Prototype</span> : (Graphic) déclare une interface de clonage de lui-même.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcretePrototype</span> : (Staff, WholeNote, ...) implémente l'interface de Prototype.</p>
                                </li>
                                <li>
                                    <p><span class="Em">Client</span> : (GraphicTool) crée un nouvel objet en demandant à un prototype de se cloner.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Les avantages de Prototype sont ceux déjà signalés pour Abstract Factory et Builder : cacher les classes de produits concrets aux clients, permettre à ceux-ci de travailler avec des classes propres à l'application sans modification. De plus, Prototype a comme avantages :</p>
                            <ul>
                                <li>
                                    <p>La possibilité d'ajouter et de supprimer des produits à l'exécution : Il suffit d'enregistrer un prototype d'un nouveau produit auprès du client. Ceci est plus souple que pour les autres patterns créationnels.</p>
                                </li>
                                <li>
                                    <p>La spécification de nouveaux objets en changeant simplement les valeurs : On crée de "nouvelles classes" en enregistrant auprès d'elles un autre prototype auquel les requêtes pourront être différées.</p>
                                </li>
                                <li>
                                    <p>La spécification de nouveaux objets en changeant la structure : Un objet composite pourra être placé comme prototype.</p>
                                </li>
                                <li>
                                    <p>La réduction du nombre de sous-classes : En effet on ne doit pas définir une hiérarchie de classes de création. L'avantage est surtout important en C++ où il n'y a pas de classe des classes.</p>
                                </li>
                                <li>
                                    <p>La possibilité de configurer une application dynamiquement en chargeant les classes nécessaires à l'exécution. C'est en utilisant ce pattern qu'on pourra exploiter cette facilité puis qu'on ne pourra pas référencer le constructeur d'une telle classe. En revanche, on pourra instancier des prototypes au chargement et les cloner par la suite.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p>La difficulté principale vient de l'oblogation pour chaque sous-classe de prototype d'implémenter la méthode <span class="html">clone()</span>, ce qui peut être compliqyé. Par exemple, si les classes existent déjà ou si la classe est formée d'objets qui ne supportent pas le clonage ou qui présentent des références circulaires.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Prototype est surtout dans un langage statique comme C++ où les classes ne sont pas des objets et aucune information de type n'est disponible à l'exécution.</p>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Utiliser un manager de prototype</span> : Si le nombre de prototype n'est pas fixé, autrement dit s'ils peuvent être créés et détruits dynamiquement, on gardera un registre des prototypes disponibles. Les clients les rechercheront dans le registre. Un tel registre sera un tableau associatif dans lequel on retrouvera un prototype à partir d'une clef. Ce manager de prototype implémentera des méthodes d'enregistrement de suppression et de recherche d'un prototype suivant une clé.</p>
                                </li>
                                <li>
                                    <p><span class="em">L'implémentation de l'opération <span class="html">clone()</span></span> : En C++, on utilisera le constructeur par recopie :</p>
<pre><code>class Door {
    public:
        Door();
        Door(const Door&);

        virtual Door* clone() const;
        virtual void Initialize(Room*, Room*);
    
    private:
        Room* room1;
        Room* room2;
};

Door::Door(const Door& other) { // Copy Constructor
    room1 = other.room1;
    room2 = other.room2;
}

Door* Door::clone() const {
    return new Door(*this);
}</code></pre>
                                    <p>En Java la méthode en implémentant l'interface Cloneable et en implémentant la méthode :</p>
<pre><code>protected Object clone() throws CloneNotSupportedException;</code></pre>
                                    <p>dont tout objet hérite.</p>
<pre><code>class Door implements Cloneable {
    public void Initialize(Room a, Room b) {
        room1 = a; room2 = b;
    }

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    Room room1;
    Room room2;
}</code></pre>
                                    <p>On fera attention à choisir à bon escient entre copie creuse (shallow copy) et copie profonde (deep copy). Souvent une copie creuse est suffisante. C'est elle qui est fournie par le constructeur par recopie par défaut de C++. Toutefois, si l'original et la copie doivent être indépendants, on devra réaliser une copie profonde.</p>
                                    <p>Si l'original est :</p>
                                    <img src="../images/implementation_prototype.png" alt="">
                                    <p>Une copie creuse sera :</p>
                                    <img src="../images/implementation_prototype_2.png" alt="">
                                    <p>tandis qu'une copie profonde se présentera comme suit :</p>
                                    <img src="../images/implementation_prototype_3.png" alt="">
                                    <p>Une autre manière d'implémenter <span class="html">clone()</span> est d'utiliser, si elles existent les méthodes <span class="html">load()</span> et <span class="html">save()</span>. Un <span class="html">save()</span> sauvera l'objet dans un buffer. Un <span class="html">load()</span> subséquent recréera un double de l'objet à partir de la sauvegarde.</p>
                                </li>
                                <li>
                                    <p><span class="em">L'initialisation des clones.</span> Si l'état du clone ne nous satisfait pas, nous voudons initialiser différemment tout ou une partie de son état interne. Plutôt que d'ajouter des paramètres à la méthode <span class="html">clone()</span>, ce qui briserait l'uniformité de l'interface, on préférera fournir d'autres méthodes qui seront appelées immédiatement après le clonage.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Définissons une sous-classe MazePrototypeFactory de la classe MazeFactory :</p>
<pre><code>class MazeFactory {
public:
    MazeFactory();

    virtual Maze* MakeMaze() const { return new Maze(); }
    virtual Wall* MakeWall() const { return new Wall(); }
    virtual Room* MakeRoom(int n) const { return new Room(n); }
    virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1, r2); }
};

class MazePrototypeFactory : public MazeFactory {
public:
    MazePrototypeFactory(Maze*, Wall*, Room*, Door*);

    virtual Maze* MakeMaze() const;
    virtual Room* MakeRoom(int) const;
    virtual Wall* MakeWall() const;
    virtual Door* MakeWall() const;

private:
    Maze* _prototypeMaze;
    Room* _prototypeRoom;
    Wall* _prototypeWall;
    Door* _prototypeDoor;
};

MazePrototypeFactory::MazePrototypeFactory(Maze* m, Wall* w, Room* r, Door* d) {
    _prototypeMaze = m;
    _prototypeWall = w;
    _prototypeRoom = r;
    _prototypeDoor = d;
}

Wall* MazePrototypeFactory::MakeWall() const {
    return _prototypeWall-&gt;Clone();
}

Door* MazePrototypeFactory::MakeDoor(Room* r1, Room* r2) const {
    Door* door = _prototypeDoor-&gt;Clone();
    door-&gt;Initialize(r1, r2);
    return door;
}</code></pre>
                            <p>Rappelons la méthode CreateMaze de la classe MazeGame :</p>
<pre><code>Maze* MazeGame::CreateMaze(MazeFactory& factory) {
    Maze* aMaze = factory.MakeMaze();
    Room* r1 = factory.MakeRoom(1);
    Room* r2 = factory.MakeRoom(2);
    Door* aDoor = factory.MakeDoor(r1, r2);

    aMaze-&gt;AddRoom(r1);
    aMaze-&gt;AddRoom(r2);

    r1-&gt;SetSide(North, factory.MakeWall());
    r1-&gt;SetSide(East, aDoor);
    r1-&gt;SetSide(South, factory.MakeWall());
    r1-&gt;SetSide(West, factory.MakeWall());

    r2-&gt;SetSide(North, factory.MakeWall());
    r2-&gt;SetSide(East, factory.MakeWall());
    r2-&gt;SetSide(South, factory.MakeWall());
    r2-&gt;SetSide(West, aDoor);

    return aMaze;
}</code></pre>
                            <p>Ici, il n'y aura nul besoin de définir de sous-classes de MazeGame : pour obtenir des jeux de types différents, il suffira de changer de factory :</p>
<pre><code>void dummy() {
    MazeGame game;
    MazePrototypeFactory simpleMazeFactory(new Maze, new Wall, new Room, new Door);

    Maze* maze = game.CreateMaze(simpleMazeFactory);
}</code></pre>
                            <p>Pour un autre jeu on utilisera :</p>
<pre><code>void dummy2() {
    // ...
    MazePrototypeFactory BombedMazeFactory(new Maze, new BombedWall, new RoomWithABomb, new Door);
    // ...
}</code></pre>
                            <p>Il reste à montrer le code pour Door, Wall, ... et l'implémentation de la méthode clone dans ces classes. Montrons le pour Door qui nécessite une méthode Initialize afin de configurer l'objet après clonage. Sinon toutes les portes relieraient les deux mêmes chambres : celles du prototype.</p>
<pre><code>class Door : public MapSite {
public:
    Door();
    Door(const Door&);

    virtual void Initialize(Room*, Room*);
    virtual Door* Clone() const;
    virtual void Enter();
    Room* otherSideFrom(Room*);
private:
    Room* _room1;
    Room* _room2;
};

Door::Door(const Door& other) {
    _room1 = other._room1;
    _room2 = other._room2;
}

void Door::Initialize(Room* r1, Room* r2) {
    _room1 = r1;
    _room2 = r2;
}

Door* Door::Clone() const {
    return new Door(*this);
}</code></pre>
                            <p>Les classes Room et Wall seraient similaires. Pour les autres types de jeux, on doit définir les autres produits comme des sous-classes : RoomWithABomb, EnchantedRoom, DoorNeedingSpell, BombedWall, ... Montrons par exemple comment BombedWall dérive de Wall et redéfinit la méthode Clone.</p>
<pre><code>class BombedWall : public Wall {
public:
    BombedWall();
    BombedWall(const BombedWall&);

    virtual Wall* Clone() const;
    bool HasBomb();
private:
    bool _bomb;
};

BombedWall::BombedWall(const BombedWall& other) : Wall(other) {
    _bomb = other._bomb;
}

Wall* BombedWall::Clone() const {
    return new BombedWall(*this);
}</code></pre>
                            <p>Donnons à présent un <span class="em">deuxième exemple</span> :</p>
                            <p>On désire implémenter une classe JavaServer pour traiter les connexions avec les clients (serveur concurrent) :</p>
                            <img src="../images/implementation_prototype_4.png" alt="">
                            <p>L'algorithme sera le suivant : le serveur effectuera sans cesse les opérations :</p>
                            <ul>
                                <li>
                                    <p>Attendre une connexion d'un client.</p>
                                </li>
                                <li>
                                    <p>Créer des streams d'entrée/sortie pour le client.</p>
                                </li>
                                <li>
                                    <p>Créer un objet de classe ServerEngine pour traiter la requête.</p>
                                </li>
                                <li>
                                    <p>Laisser cet objet s'en occuper et recommencer à attendre.</p>
                                </li>
                            </ul>
                            <p><span class="em">Sans Prototype</span>, pour différents ServiceEngine, on aura différents JavaServer comme le montre le graphique ci-après et le code qui suit :</p>
                            <img src="../images/implementation_prototype_5.png" alt="">
                            <p>Les classes de bases sont :</p>
<pre><code>interface ServerEngine {
    public void processClientRequest(InputStream in, OutputStream out);
}

abstract class JavaServer {
    private ServerSocket acceptor;

    public JavaServer(int portNumber) {
        acceptor = new ServerSocket(portNumber);
    }

    public void run() {
        while (true) {
            Socket client = acceptor.accept();
            InputStream cin = client.getInputStream();
            OutputStream cout = client.getOutputStream();
            ServerEngine requestHandler = makeServerEngine();

            requestHandler.processClientRequest(cin, cout);
        }
    }

    abstract protected ServerEngine makeServerEngine();
}</code></pre>
                            <p>Les sous-classes seront implémentées comme indiqué ici :</p>
<pre><code>class AirlineJavaServer extends JavaServer {
    public AirlineJavaServer(int portNumber) {
        super(portNumber);
    }

    protected ServerEngine makeServerEngine() {
        return new AirlineJavaServer();
    }
}

class AirlineReservation implements ServerEngine {
    public void processClientRequest(InputStream in, OutputStream out) {
        // ...
    }
    // ...
}</code></pre>
                            <p>et même chose pour DateJavaServer et DateServer.</p>
                            <p>Si <span class="em">utilise Prototype</span>, il ne sera plus nécessaire de définir des sous-classes de JavaServer. Une seule classe suffira pour tous les serveurs concrets. Pour chaque serveur concret on définira un JavaServer avec comme prototype une instance de ce serveur concret.</p>
                            <p>Remarquez que ceci ne diminue pas le nombre d'objets. Il diminue le nombre de classes et donc la taille du code à écrire.</p>
                            <img src="../images/implementation_prototype_6.png" alt="">
<pre><code>interface ServerEngine {
    public ServerEngine clone();
    public void processClientRequest(InputStream in, OutputStream out);
}

class JavaServer {
    private ServerSocket acceptor;
    private ServerEngine serverPrototype;

    public JavaServer(int portNumber, ServerEngine aCopy) {
        acceptor = new ServerSocket(portNumber);
        serverPrototype = aCopy;
    }

    public void run() {
        while (true) {
            Socket client = acceptor.accept();
            InputStream cin = client.getInputStream();
            OutputStream cout = client.getOutputStream();
            ServerEngine requestHandler = serverPrototype.clone();

            requestHandler.processClientRequest(cin, cout);
        }
    }
}

class AirlineReservation implements ServerEngine {
    public void processClientRequest(InputStream in, OutputStream out) {
        // ...
    }

    public ServerEngine clone() {
        // ...
    }
    // ...
}</code></pre>
                            <p>et même chose pour DateServer. Montrons comment tout cela s'utilise :</p>
<pre><code>class DriverProgram {
    public static void main(String[] args) {
        ServerEngine aPrototype = new DateServer();
        JavaServer networkListener;
        networkListener = new JavaServer(666, aPrototype);
        networkListener.run();
    }
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Abstract Factory et Prototype sont en quelque sorte riveaux pour créer des objets. Pourtant on peut également utiliser les deux simultanément. On configurera une Abstract Factory avec une table associative contenant des paires nom, prototype pour tous les prototypes nécessaires à l'application. Ces prototypes seront utilisés pour configurer les clients. Ceux-ci pourront les obtenir via leur nom.</p>
                                </li>
                                <li>
                                    <p>Si dans un design on utilise Composite et Decorator de nombreuse fois, on aura intérêt à employer Prototype.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="state">State :</h2>
                    <dl>
                        <dt>Alias</dt>
                        <dd>
                            <p>Objects for States</p>
                        </dd>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Permettre à un objet de changer de comportement quand son état interne change. L'objet donnera l'impression d'avoir changé de classe.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Souvent on doit implémenter un diagramme d'état. Ou encore on constate dans le code écrit de grands <span class="html">switch</span> qui rendent le code illisible.</p>
                            <p>Considérons par exemple un club vidéo louaant des cassettes, des DVD, ... :</p>
                            <p>Une programmation directe produirait dans la classe Movie du code tel que :</p>
<pre><code>double charge(int daysRented) {
    double result = 0;
    switch(priceCode()) {
        case REGULAR:
            result += 2;
            if (daysRented &gt; 2)
                result += (daysRented - 2) * 1.5;
            break;
        case NEW_RELEASE:
            result += daysRented * 3;
            break;
        case CHILDRENS:
            result += 1.5;
            if (daysRented &gt; 3)
                result += (daysRented - 3) * 1.5;
            break;
    }
    return result;
}</code></pre>
                            <p>Pour éviter une telle instruction switch on songe à sous-classer :</p>
                            <img src="../images/motivation_state.png" alt="">
                            <p>Malheureusement ceci ne fonctionne pas, car une cassette pourra changer d'état au cours de son cycle de vie. C'est ici que le pattern State vient à notre rescousse :</p>
                            <img src="../images/motivation_state_2.png" alt="">
                            <p>De cette façon, un Movie pourra changer son code prix dynamiquement, reflétant les modifications de l'état de l'objet.</p>
                            <p>Le code deviendra :</p>
<pre><code>public class Movie {
    public static Movie newNewRelease(String name) {
        Movie result = new Movie(name);
        result.beNewRelease();
        return result;
    }
    public static Movie newRegular(String name) {
        Movie result = new Movie(name);
        result.beRegular();
        return result;
    }
    public static Movie newChildrens(String name) {
        Movie result = new Movie(name);
        result.beChildrens();
        return result;
    }

    private Movie(String name) {
        _name = name;
    }

    public void beRegular() {
        _price = Price.regular();
    }

    public void beNewRelease() {
        _price = Price.newRealease();
    }

    public void beChildrens() {
        _price = Price.childrens();
    }

    double charge(int daysRented) {
        return _price.charge(daysRented);
    }

    private String _name;
    private Price _price;
    // ...
}

abstract class Price {
    static Price regular() {
        return _regular;
    }

    static Price childrens() {
        return _childrens;
    }

    static Price newRelease() {
        return _newRelease;
    }

    abstract double charge(int daysRented);

    private static Price _childrens = ChildrensPrice.getInstance();
    private static Price _newRelease = NewReleasePrice.getInstance();
    private static Price _regular = RegularPrice.getInstance();
}

public class ChildrensPrice extends Price {

    private static Childrens Price _childrensPrice;

    private ChildrensPrice() {}

    public static ChildrensPrice getInstance() {
        if (_childrensPrice == null)
            _childrensPrice = new ChildrensPrice();
        return _childrensPrice;
    }

    double charge(int daysRented) {
        double result = 1.5;
        if (daysRented &gt; 3)
            result += (daysRented - 3) * 1.5;
        return result;
    }
}

public class NewReleasePrice extends Price {

    private static NewReleasePrice _newReleasePrice;

    private NewReleasePrice() {}

    public static NewReleasePrice getInstance() {
        if (_newReleasePrice == null)
            _newReleasePrice = new NewReleasePrice();
        return _newRealeasePrice;
    }

    double charge(int daysRented) {
        return daysRented * 3;
    }
}

public class RegularPrice extends Price {

    private static RegularPrice _regularPrice;

    private RegularPrice() {}

    public static RegularPrice getInstance() {
        if (_regularPrice == null)
            _regularPrice = new RegularPrice();
        return _regularPrice;
    }

    double charge(int daysRented) {
        double result = 2;
        if (daysRented &gt; 2)
            result += (daysRented - 2) * 1.5;
        return result;
    }
}</code></pre>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise State quand :</p>
                            <ul>
                                <li>
                                    <p>le comportement d'un objet dépend de son état et doit changer à l'exécution suite à un changement d'état.</p>
                                </li>
                                <li>
                                    <p>les opérations comportent des instructions conditionnelles (if imbriqués, switch) de grande taille dépendants de l'état de l'objet. Le pattern State placera chaque branchement dans une classe différente. L'état de l'objet sera traité de cette manière comme un objet à part pouvant varier séparément.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_state.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Context</span> : définit l'interface qui intéresse les clients et maintient une référence à une sous-classe ConcreteState qui définit l'état actuel.</p>
                                </li>
                                <li>
                                    <p><span class="em">State</span> : définit l'interface encapsulant le comportement associé à un état particulier du Context.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteState</span> : diverses sous-classes implémentant un comportement associé à un état du Context.</p>
                                </li>
                            </ul>
                            <p>Ces classes collaborent entre elles comme suit :</p>
                            <ul>
                                <li>
                                    <p>Le Context délègue les requêtes propres à son état à son ConcreteState actuel.</p>
                                </li>
                                <li>
                                    <p>Il pourra se passer en argument lors d'une telle délégation, afin de permettre à son ConcreteState d'accéder à ses données.</p>
                                </li>
                                <li>
                                    <p>Les Clients invoquent des requêtes via l'interface définie par Context. Ils peuvent configurer un Context avec des objets ConcreteState mais après cela, ils n'accèdent plus à ces ConcreteState.</p>
                                </li>
                                <li>
                                    <p>C'est le Context ou les ConcreteState qui décide quel est l'état suivant du Context et dans quelles circonstances le changement à lieu.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Localiser le comportement propre à l'état de l'objet et partager ce comportement entre plusieurs objets, un pour chaque état.</span> Ceci permet d'ajouter de nouveaux états en définissant une nouvelle sous-classe.</p>
                                </li>
                                <li>
                                    <p class="em">Supprimer de longues procédures, de longues instructions conditionnelles.</p>
                                </li>
                                <li>
                                    <p><span class="em">Rendre les transitions d'états explicites et protéger le Context contre des états inconsistants.</span> En effet un changement d'état nécessite la modification d'un seul champ du Context (la référence à son COncreteState) et non de plusieurs ce qui pourrait conduire à des incohérences.</p>
                                </li>
                                <li>
                                    <p><span class="em">Permettre le partage d'objets State.</span> Si les ConcreteState n'ont pas de données internes, différents Context peuvent se les partager. Voir à ce sujet le pattern Flyweight.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p class="em">Le nombre de classes est augmenté.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Qui définit les transitions d'états ?</span> Si les critères sont fixes, on pourra les implémenter dans Context. Les implémenter dans les sous-classes ConcreteState est plus flexible et souvent plus approprié. Ils définiront leur successeur et quand a lieu la transition. Toutefois, pour ce faire, il sera nécessaire d'introduire une méthode dans Context pour permettre de mettre à jour la référence à un ConcreteState. La décentralisation de la logique de transition ainsi obtenue, rend aisé la modification et l'extension de cette logique en définissant de nouvelles sous-classes. Un désavantage de cette décentralisation est la connaissance qu'à une sous-classe ConcreteState d'une autre au moins. Cela introduit des dépendances entre sous-classes.</p>
                                </li>
                                <li>
                                    <p><span class="em">Utiliser la méthode traditionnelle des tables.</span> Traditionnellement, une machine d'états peut être implémenté par une table indiquant pour chaque état et chaque input, le nouvel état obtenu. Ceci remplace les instructions conditionnelles par un accès à la table.</p>
                                    <p>Les désavantages de cette façon de faire sont :</p>
                                    <ul>
                                        <li>
                                            <p>L'inefficacité d'un accès table par rapport à un appel de fonction.</p>
                                        </li>
                                        <li>
                                            <p>Le format tabulaire rend la logique de transition moins explicite et plus difficile à comprendre.</p>
                                        </li>
                                        <li>
                                            <p>La difficulté d'ajouter des actions quelconques accompagnant les transitions.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p><span class="em">La création et la destuction des objets ConcreteState.</span> Deux choix sont possibles : (1) créer les bjets au besoin et les détruire après. (2) créer les objets à l'avance et ne jamais les détruire. Le choix (1) sera préférable si les états ne sont pas connus à l'exécution et que les changements d'états sont rares. Ne pas garder en mémoire ces objets sera avantageux si ceux-ci stockent une grande quantité d'information. On évite de créer et de détruire des objets qu'on réutilisera sous peu. Mais dans ce cas, le Context devra garder des références à tous les objets State possibles.</p>
                                    <p>L'exemple donné en motivation utilise le choix (2) car régulièrement des cassettes changent d'état. De plus un seul exemplaire de chaque état est conservé (on les a implémentés comme des Singletons).</p>
                                    <p>L'exemple donné plus loin, au contraire, utilisera le choix (1) car les états conservent de l'information propre à l'objet et ne seront donc pas des Singletons. Une fois utilisés, ces états seront inutiles.</p>
                                </li>
                                <li>
                                    <p><span class="em">Étendre le pattern pour permettre plus états simultanés.</span> L'objet semblera faire parties de plusieurs classes. Plutôt de garder référence à un objet ConcreteState, le Context gardera une liste de références. Ceci pourra être utile pour une classe Employe. Chaque employé pouvant être Vendeur, Technicien mais en même temps Manager.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Considérons l'exemple d'un protocole SPOP basé sur le protocole POP utilisé pour le courrier électronique. SPOP (Simple Post Office Protocol) sera utilisé pour récupérer les e-mails à partir du server. Il supporte les commandes suivantes :</p>
                            <ul>
                                <li>
                                    <p class="html">USER &lt;username&gt;</p>
                                </li>
                                <li>
                                    <p class="html">PASS &lt;password&gt;</p>
                                </li>
                                <li>
                                    <p class="html">LIST</p>
                                </li>
                                <li>
                                    <p class="html">RETR &lt;message number&gt;</p>
                                </li>
                                <li>
                                    <p class="html">QUIT</p>
                                </li>
                            </ul>
                            <p>La commande <span class="html">accompagnée d'un nom d'utilisateur doit être la première.</span></p>
                            <p>Elle sera suivie de <span class="html">PASS</span> avec un mot de passe ou alors de <span class="html">QUIT</span>. Après introduction d'un nom d'utilisateur et d'un mot de passe valide, les autres commandes seront accessibles.</p>
                            <p><span class="html">LIST</span> peut avoir un argument. Ce sera alors le numéro d'un message. La commande renvoie la taille du message passé en argument ou de tous les messages si aucun argument n'est précisé. Elle renvoie également le nombre de message.</p>
                            <p><span class="html">RETR</span> a pour argument un numéro de message et rapatrie ce message.</p>
                            <p><span class="html">QUIT</span> met à jour la mailbox pour réfléter les transactions effectuées et termine la session.</p>
                            <p>Si la session se termine autrement que par <span class="html">QUIT</span>, aucune mise à jour de la mailbox n'est effectuée.</p>
                            <p>Ceci peut se représenter par un diagramme d'état :</p>
                            <img src="../images/exemple_state.png" alt="">
                            <p>Sans utiliser State, ceci se représentera par un énorme <span class="html">switch</span> :</p>
<pre><code>class SPop {
    static final int QUIT = 1;
    static final int HAVE_USER_NAME = 2;
    static final int START = 3;
    static final int AUTHORIZED = 4;

    private int state = START;

    String userName;
    String password;

    public void user(String userName) {
        switch(state) {
            case START:
                this.userName = userName;
                state = HAVE_USER_NAME;
                break;
            default:
                // invalid command
                sendErrorMessageOrWhatEver();
                endLastSessionWithoutUpdate();
                userName = null;
                password = null;
                state = START;
        }
    }

    public void pass(String password) {
        switch(state) {
            case HAVE_USER_NAME:
                this.password = password;
                if (validateUser())
                    state = AUTHORIZED;
                else {
                    sendErrorMessageOrWhatEver();
                    userName = null;
                    password = null;
                    state = START;
                }
            default:
                // invalid command
                sendErrorMessageOrWhatEver();
                endLastSessionWithoutUpdate();
                state = START;
        }
    }

    // etc.
}</code></pre>
                            <p>Si on utilise le pattern State, on obtient :</p>
                            <img src="../images/exemple_state_2.png" alt="">
<pre><code>class SPop {
    private SPopState state = new Start();

    public void user(String userName) {
        state = state.user(userName);
    }

    public void pass(String password) {
        state = state.pass(password);
    }

    public void list(int messageNumber) {
        state = state.list(messageNumber);
    }
    // etc.
}

abstract class SPopState {
    public SPopState user(String userName) {
        sendErrorMessageOrWhatEver();
        endLastSessionWithoutUpdate();
        return new Start();
    }

    public SPopState pass(String password) {
        sendErrorMessageOrWhatEver();
        endLastSessionWithoutUpdate();
        return new Start();
    }

    public SPopState list(int messageNumber) {
        sendErrorMessageOrWhatEver();
        endLastSessionWithoutUpdate();
        return new Start();
    }

    public SPopState retr(int messageNumber) {
        sendErrorMessageOrWhatEver();
        endLastSessionWithoutUpdate();
        return new Start();
    }

    public SPopState quit() {
        updateMailbox();
        return new Start();
    }
}

class Sart extends SPopState {
    public SPopState user(String userName) {
        return new HaveUserName(userName);
    }
}

class HaveUserName extends SPopState {
    String userName;

    public HaveUserName(String userName) {
        this.userName = userName;
    }

    public SPopState pass(String password) {
        if (validateUser(userName, password))
            return new Authorized(userName);
        else
            return new Start();
    }
}

// etc.</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Le pattern Flyweight explique quand et comment partager les objets State.</p>
                                </li>
                                <li>
                                    <p>Les objets State sont souvent des Singletons.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="vistor">Visitor :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Représenter une opération à exécuter sur les éléments d'une structure. Visitor nous permet de définir de nouvelles opérations sans changer les classes des éléments sur lesquels il opère.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Lors du parcours d'un arbre, diverses opérations de traitement peuvent être faites. Par exemple, divers calculs sur les valeurs contenues en chaque noeud, affichage graphique de l'arbre, ajouter des éléments dans la structure (par exemple, dans un arbre binaire de recherche). On pourrait bien sûr prévoir toutes ces opérations dans la classe <span class="em">Noeud</span>. Mais non seulement celle-ci risquerait de devenir un monstre mais de plus, la situation serait figée et rajouter une opération renviendrait à modifier notre classe <span class="em">Noeud</span>. Une meilleure solution consiste à définir une classe séparée <span class="em">Visitor</span> dont les sous-classes implémentent un traitement particulier et dans chaque noeud, prévoir une méthode <span class="html">accept(Visitor)</span> pour permettre à un objet d'une sous-classe de <span class="em">Visitor</span> d'effectuer le traitement. Par exemple, pour évaluer un arbre représentant une expression arithmétique, la classe <span class="em">Visitor</span> prévoirait des méthodes :</p>
<pre><code>visiteNombre(NoeudNombre),
visiteOperateurBinaire(NoeudBinaire),
visiteOperateurUnaire(NoeudUnaire), ...</code></pre>
                            <p>tandis que la classe <span class="em">Noeud</span> aurait une méthode <span class="html">accept(Visitor)</span> redéfinie dans chaque sous-classe. Par exemple, dans la classe <span class="em">NoeudNombre</span>, cette méthode s'écrirait :</p>
<pre><code>void accepter(Visitor v) {
    v.visiteNombre(this);
}</code></pre>
                            <p>tandis que dans <span class="em">NoeudBinaire</span> on aurait :</p>
<pre><code>void accept(Visitor v) {
    v.visiteOperateurBinaire(this);
}</code></pre>
                            <p>Avec le pattern Visitor, on aura donc deux hiérarchies, une pour les sous-classes de Noeud et une pour les sous-classes de Visitor. Ces dernières implémentent chacune un traitement différent tandis que la première hiérarchie indique la structure de l'arbre. Ces deux hiérarchies ne sont donc pas parallèles.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Visitor quand :</p>
                            <ul>
                                <li>
                                    <p>une structure d'objets contient beaucoup de classes présentant des interfaces différentes et qu'on désire exécuter sur ces objets des traitements dépendant de leur classe concrète.</p>
                                </li>
                                <li>
                                    <p>beaucoup d'opérations distinctes sans relations les unes avec les autres doivent être exécutées sur les objets d'une structure et qu'on ne veut pas saturer ces objets avec toutes ces opérations. Ce sera le cas si une structure est partagée par plusieurs applications.</p>
                                </li>
                                <li>
                                    <p>la classe définissant la structure d'objets change rarement mais on désire rajouter régulièrement de nouvelles opérations sur ces objets. Si on change la structure, il faudra redéfinir l'interace de toutes les sous-classes de Visitor, ce qui est coûteux. Dans un tel cas, on préférera définir les opérations dans les objets de la structure.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_visitor.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Visitor</span> : déclare une opération de visite pour chaque classe de ConcreteElement dans la structure d'objet. Le nom et la signature de cette opération identifient la classe qui envoie la requête au Visitor. Ce qui permet au Visitor de déterminer la classe concrète de l'élément visité. Il sait dès lors accéder aux méthodes propres à l'interface de cette classe concrète.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteVisitor</span> : implémente les opérations déclarées par Visitor. Chaque opération implémente un fragment de l'algorithme défini pour la classe correspondante dans la structure. ConcreteVisitor fournit le contexte pour l'algorithme et stocke des données locales qui accumulent souvent des informations tout au long de la traversée de la structure.</p>
                                </li>
                                <li>
                                    <p><span class="em">Element</span> : définit une opération accept qui prend un Visitor en argument.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteElement</span> : implémente la méthode accept.</p>
                                </li>
                                <li>
                                    <p><span class="em">ObjectStructure</span> : sait énumérer ses éléments, peut fournir une interface de haut niveau permettant à un Visitor de visiter ses éléments et pourra être un Composite ou une collection telle qu'une liste, une séquence, un arbre, ...</p>
                                </li>
                            </ul>
                            <p>Ces classes collaborent comme suit :</p>
                            <ul>
                                <li>
                                    <p>Un client créera un ConcreteVisitor et traversera la structure visitant chaque élément.</p>
                                </li>
                                <li>
                                    <p>Quand l'élément est visité, il appelle l'opération du Visitor qui correspond à sa propre classe, se passant en argument afin que le Visitor puisse accéder à son état, si nécessaire.</p>
                                </li>
                            </ul>
                            <p>Le diagramme de séquence suivant illustre cette collaboration :</p>
                            <img src="../images/structure_participants_collaborations_visitor_2.png" alt="">
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>L'ajout de nouvelles opérations est facilité. Il suffit de définir une nouvelle sous-classe de Visitor.</p>
                                </li>
                                <li>
                                    <p>Les opérations reliées sont conservées ensemble et les autres sont séparées. Les premières sont en effet localisées dans un Visitor. Les autres seront situées dans d'autres Visitor. Les structures de données propres à un algorithme seront cachées au sein d'un Visitor.</p>
                                </li>
                                <li>
                                    <p>Les éléments visités ne doivent pas nécessairement avoir d'ancêtre commun. Contrairement à Iterator qui l'exigeait puisqu'il devait renvoyer l'Item courant. Visitor ne fait, lui, aucune allusion à Element mais seulement aux ConcreteElement. Si dans le diagramme de structure du pattern on supprime Element, Visitor continue à s'appliquer.</p>
                                </li>
                                <li>
                                    <p>Un Visitor peut accumuler des informations. Sans Visitor, ces informations devront être passées en argument supplémentaires aux opérations effectuées, à moins qu'elles ne soient mises dans des variables globales.</p>
                                </li>
                            </ul>
                            <p>Désavantages :</p>
                            <ul>
                                <li>
                                    <p>L'ajout d'une nouvelle sous-classe ConcreteElement est difficile. Il faut en effet rajouter une nouvelle opération de visite abstraite dans Visitor et l'implémenter dans tous les ConcreteVisitor. Si de tels ajouts sont fréquents, on n'utilisera pas Visitor.</p>
                                </li>
                                <li>
                                    <p>Violation de l'encapsulation : un ConcreteElement doit permettre à son Visitor de faire son travail en lui fournissant une interface suffisamment puissante. Aussi fournit-il des méthodes publiques donnant accès à son état interne ce qui peut briser l'encapsulation.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Chaque structure formée d'objets aura sa classe Visitor propre. Les sous-classes concrètes de celle-ci feront le travail de visite des éléments de la structure. Cette classe Visitor déclarera une méthode visitConcreteElement différente pour chaque classe d'élément de la structure. L'argument de cette méthode sera un ConcreteElement particulier dont la classe est celle pour laquelle la méthode a été déclarée. Cet argument permettra au Visitor d'accéder à l'interface de ConcreteElement. Les sous-classes ConcreteVisitor implémenteront toutes ces méthodes afin de mettre en oeuvre un traitement particulier sur les éléments de la structure.</p>
                            <p>En C++, cela donnera ce qui suit :</p>
<pre><code>class ElementA;
class ElementB;
class CompositeElement;
class Visitor {
public:
    virtual void VisitElementA(ElementA*);
    virtual void VisitElementB(ElementB*);
    virtual void visitCompositeElement(CompositeElement*);
    // and so for other concrete elements
protected:
    Visitor();
};

class Element {
public:
    virtual ~Element();
    virtual void Accept(Visitor&) = 0;
protected:
    Element();
};

class ElementA : public Element {
public:
    ElementA();
    virtual void Accept(Visitor& v) { v.VisitElementA(this); }
};

class ElementB : public Element {
public:
    ElementB();
    virtual void Accept(Visitor& v) { v.VisitElementB(this); }
};</code></pre>
                            <p>Un élément composite pourra définir Accept en fonction de ses composants avant d'accepter son visiteur propre :</p>
<pre><code>class CompositeElement : public Element {
public:
    virtual void Accept(Visitor&);
private:
    List&lt;Element*&gt;* _children;
};

void CompositeElement::Accept(Visitor& v) {
    ListIterator&lt;Element*&gt; i(_children);

    for (i.First(); !i.IsDone(); i.Next()) {
        i.CurrentItem()-&gt;Accept(v);
    }
    v.VisitCompositeElement(this);
}</code></pre>
                            <p>De plus les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p>L'implémentation de Visitor est basée sur le <span class="em">double-dispatch</span>. La plupart des langages supportent le single-dispatch : l'opération à utiliser pour traiter une requête est déterminée par le nom de la requête et le type du destinataire. En double-dispatch, cette opération sera déterminée par le nom de la requête et les types de deux destinataires. C'est le cas d'accept : sa signification dépend du visiteur et de l'élément visité. Ce pattern nous montre comment implémenter le double-dispatch dans un langage qui ne le supporte pas directement. Certains langages orientés objets comme CLOS supportent le double et même le multiple-dispatch.</p>
                                </li>
                                <li>
                                    <p>Qui est responsable de la traversée de la structure ? Trois solutions sont possibles : la structure elle-même, le Visitor ou un Iterator séparé.</p>
                                    <p>Certaines structures seront responsables de l'itération : un Composite, une liste, ...</p>
                                    <p>Une autre solution est d'utiliser un Iterator pour visiter les éléments. Si on utilise un Iterator interne, le double-dispatch n'est pas nécessaire. Puisque l'Iterator connaît l'élément courant, il peut directement appeler la méthode appropriée chez le Visitor. Dans l'exemple du parcours d'arbre vu lors de l'étude du pattern Memento, plutôt que d'écrire :</p>
<pre><code>private void processFirstVisit(BinaryNode currentNode) {
    if (traversalType == PREORDER)
        <span class="em">currentNode.accept(myVisitor);</span>
    if (currentNode.getLeftChild() != null) {
        history.push(new TraversalStorage(currentNode, 2));
        currentNode = (BinaryNode) currentNode.getLeftChild();
        visitNumber = 1;
    } else {
        processSecondVisit(currentNode);
    }
}</code></pre>
                                    <p>On pourra écrire :</p>
<pre><code>private void processFirstVisit(BinaryNode currentNode) {
    if (traversalType == PREORDER)
        <span class="em">myVisitor.visitNode(currentNode);</span>
    if (currentNode.getLeftChild() != null) {
        history.push(new TraversalStorage(currentNode, 2));
        currentNode = (BinaryNode) currentNode.getLeftChild();
        visitNumber = 1;
    } else {
        processSecondVisit(currentNode);
    }
}</code></pre>
                                    <p>Remarquons que dans cet exemple, tous les noeuds sont de même type et donc le Visitor ne devra implémenter qu'une seule méthode : <span class="html">visitNode()</span>.</p>
                                    <p>Un troisième endroit pour placer la responsabilité de la traversée est le Visitor lui-même. Ce sera le cas pour des algorithmes particulièrement complexes qui dépendent des résultats des opérations sur les éléments de la structure. L'ennui de cette façon de procéder vient du fait qu'on risque de devoir dupliquer le code de traversée dans toutes les sous-classes ConcreteVisitor.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Notre exemple montre comment un Visitor est utilisé pour calculer l'inventaire de matériels informatiques (organisés en Composite) et le coût total de l'équipement.</p>
<pre><code>typedef int Watt;
typedef int Currency;
typedef int Power;
class EquipmentVisitor;
class Equipment;
class Card;
class Bus;
class Cabinet;
class Chassis;
class FloppyDisk;

class Inventory {
    public:
        void Accumulate(Equipment*);
        friend ostream& operator&lt;&lt;(ostream&, const Inventory&);
    private:
        // ...
};</code></pre>
                            <p><span class="html">Accumulate()</span> stockera, par exemple dans une table de Hashing, le nom de l'équipement passé en paramètre et incrémentera le nombre de fois que cet équipement a déjà été rencontré.</p>
<pre><code>class Equipment { // selon le pattern Composite
public:
    virtual ~Equipment();

    const char* Name() { return _name; }

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();

    virtual void Add(Equipment*);
    virtual void Remove(Equipment*);
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
    virtual Iterator&lt;Equipment*&gt;* CreateIterator();
protected:
    Equipment(const char*);
private:
    const char* _name;
};

class CompositeEquipment : public Equipment {
public:
    virtual ~CompositeEquipment();

    virtual Watt Power();
    virtual Currency NetPrice();
    vitual Currency DiscountPrice();

    virtual void Add(Equipment*);
    virtual void Remove(Equipment*);
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
    virtual Iterator&lt;Equipment*&gt;* CreateIterator();
protected:
    CompositeEquipment(const char*);
private:
    List&lt;Equipment*&gt; _parts;
};

Currency CompositeEquipment::NetPrice() {
    Iterator&lt;Equipment*&gt;* i = CreateIterator();
    Currency total = 0;

    for (i-&gt;First(); !i.IsDone(); i-&gt;Next()) {
        total += i-&gt;CurrentItem()-&gt;NetPrice();
    }
    delete i;
    return total;
}

class Chassis : public CompositeEquipment {
public:
    Chassis(const char*);
    virtual ~Chassis();

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
};

class Cabinet : public CompositeEquipment {
public:
    Cabinet(const char*);
    virtual ~Cabinet();

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
};

class Bus : public CompositeEquipment {
public:
    Bus(const char*);
    virtual ~Bus();

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
};

class FloppyDisk : public CompositeEquipment {
public:
    FloppyDisk(const char*);
    virtual ~FloppyDisk();

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
};

class Card : public CompositeEquipment {
public:
    Card(const char*);
    virtual ~Card();

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();
    <span class="em">virtual void Accept(EquipmentVisitor&);</span>
};</code></pre>
                            <p>Montrons l'implémentation de la méthode Accept pour une composante simple (<span class="em">FloppyDisk</span>) et un conteneur (<span class="em">Chassis</span>) :</p>
<pre><code>void FloppyDisk::Accept(EquipmentVisitor& visitor) {
    visitor.VisitFloppyDisk(this);
}

void Chassis::Accept(EquipmentVisitor& visitor) {
    for (ListIterator&lt;Equipment*&gt; i(_parts); !i.IsDone(); i.Next()) {
        i.CurrentItem()-&gt;Accept(visitor);
    }
    visitor.VisitChassis(this);
}</code></pre>
                            <p>Voici quelques sous-classes de notre Visitor :</p>
<pre><code>class PricingVisitor : public EquipmentVisitor {
public:
    PricingVisitor();

    virtual void VisitFloppyDisk(FloppyDisk*);
    virtual void VisitCard(Card*);
    virtual void VisitChassis(Chassis*);
    virtual void VisitBus(Bus*);
    // ...
private:
    Currency _total;
};

void PricingVisitor::VisitFloppyDisk(FloppyDisk* e) {
    _total += e-&gt;NetPrice();
}

void PricingVisitor::VisitChassis(Chassis* e) {
    _total += e-&gt;DiscountPrice();
}

class InventoryVisitor : public EquipmentVisitor {
public:
    InventoryVisitor();

    Inventory& GetInventory();

    virtual void VisitFloppyDisk(FloppyDisk*);
    virtual void VisitCard(Card*);
    virtual void VisitChassis(Chassis*);
    virtual void VisitBus(Bus*);
    // ...
private:
    Inventory _inventory;
};

void InventoryVisitor::VisitFloppyDisk(FloppyDisk* e) {
    _inventory.Accumulate(e);
}

void InventoryVisitor::VisitChassis(Chassis* e) {
    _inventory.Accumulate(e);
}</code></pre>
                            <p>Enfin un peu de code utilisant le tout :</p>
<pre><code>void dummy() {
    Equipment* component;
    InventoryVisitor visitor;

    component-&gt;Accept(visitor);
    count &lt;&lt; "Inventory "
          &lt;&lt; component-&gt;Name();
          &lt;&lt; visitor.GetInventory();
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Composite : Visitor est utilisé pour appliquer une opération sur toutes les composantes.</p>
                                </li>
                                <li>
                                    <p>Interpreter : Visitor pourra faire l'interprétation.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="flyweight">Flyweight :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Utiliser le partage pour supporter un grand nombre de petits objets.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>De nombreuses applications réutilisent des objets tout au long de leur design. Une implémentation naïve serait probablement très chère. Dans un éditeur de texte, par exemple, ce serait une mauvaise idée d'utiliser un objet différent pour représenter chaque caractère. C'est pourtant une excellente idée de traiter les caractères comme des objets afin de pouvoir traiter uniformément tout ce qui compose le document (tables, figures, ...). Chaque caractère consiste en un certain nombre d'informations : sa valeur (A, y, ...), sa police, sa taille, son emplacement dans le texte, etc. Beaucoup de ces caractéristiques sont communes : ainsi la plupart des caractères 'a' du document utilisent la même police, la même taille. On songe alors à partager les caractéristiques communes de ces objets. Un tel objet partagé sera appelé un flyweight (poids mouche). On dera donc la distinction entre l'état intrinsèque et l'état extrinsèque de l'objet. Le premier pourra être partagé et sera stocké dans le flyweight. Les clients seront responsables de passer l'état extrinsèque au flyweight quand besoin s'en fera sentir pour reconstituer l'objet complet.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Flyweight quand <span class="em">toutes</span> les conditions suivantes sont vraies :</p>
                            <ul>
                                <li>
                                    <p>Une application utilise un grand nombre d'objets.</p>
                                </li>
                                <li>
                                    <p>Le coût de stockage est élevé à cause de cette grande quantité d'objets.</p>
                                </li>
                                <li>
                                    <p>La plus grande partie de l'état de l'objet peut être rendue extrinsèque.</p>
                                </li>
                                <li>
                                    <p>Une fois l'état extrinsèque retiré, beaucoup de groupes d'objets peuvent être remplacés par un petit nombre d'objets partagés.</p>
                                </li>
                                <li>
                                    <p>L'application ne dépend pas de l'identité des objets. En effet comme les objets seraient partagés, un test d'identité peut renvoyer vrai pour des objets différents.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <p>Les participants sont :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Flyweight</span> : déclare une interface qui permet aux flyweights de recevoir et d'agir sur leur état extrinsèque.</p>
                                </li>
                                <li>
                                    <p><span class="em">ConcreteFlyweight</span> : implémente l'interface Flyweight et ajoute le stockage de l'état intrinsèque. Il représente un objet partageable ne stockant que l'état indépendant du contexte.</p>
                                </li>
                                <li>
                                    <p><span class="em">UnsharedConcreteFlyweight</span> : représente un objet non partageable. Le pattern Flyweight permet le partage mais ne l'oblige pas.</p>
                                </li>
                                <li>
                                    <p><span class="em">FlyweightFactory</span> : crée et gère les flyweights renvoyant, à la demande d'un client, un flyweight qui existerait ou le créant s'il n'existe pas.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : maintient des références aux flyweights, calcule/stocke leur état extrinsèque.</p>
                                </li>
                            </ul>
                            <img src="../images/structure_participants_collaborations_flyweight.png" alt="">
                            <p>Les clients passent l'état extrinsèque lors de l'invocation d'une méthode d'un flyweight. Ils n'instancient pas les flyweights directement mais obtiennent exclusivement les références aux flyweights de la FlyweightFactory.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantage :</p>
                            <ul>
                                <li>
                                    <p>Réduction du coût de stockage.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p>Ralentissement dû au calcul, à la recherche et au transfert de l'état extrinsèque. L'avantage prendra le pas sur le désavantage en fonction de la réduction du nombre d'objets, de la qualité d'état intrinsèque, du fait que l'état extrinsèque peut être stocké ou de préférence, calculé.</p>
                                </li>
                            </ul>
                            <p>Si Flyweight est utilisé pour partager les objets d'un Composite, on ne pourra pas stocker de référence au parent. Cette référence fera partie de l'état extrinsèque.</p>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ul>
                                <li>
                                    <p>La suppression de l'état extrinsèque : Idéalement cet état extrinsèque devrait pouvoir être calculé à partir d'une structure d'objets séparée. Par exemple dans un éditeur, on gardera les renseignements concernant la police et la taille dans une structure séparée car c'est souvent la même police et la même taille pour une grande partie de document. Ce sera donc plus efficace que les garder avec les flyweights (caractères).</p>
                                </li>
                                <li>
                                    <p>La gestion des objets partagés. Ils ne doivent pas être instanciés directement par les clients mais obtenus auprès d'une Factory. Si les flyweight doivent être détruits, on se reposera sur le garbage collection si c'est possible, sinon on utilisera un compteur de référence. Mais s'il y a peu de flyweights, il est préférable de les garder de façon permanente.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Considérons l'exemple d'un formateur de texte. La classe de basse Glyph, organisée en Composite sera constituée de flyweights pour représenter les caractères, mais aussi de lignes, de colonnes qui ne seront pas partagées. Dans ce qui suit nous montrons comment traiter les polices de caractères. On ferait de même pour d'autres attributs graphiques.</p>
<pre><code>class Window;
class GlyphContext;
class Font {
    public:
        Font(char*);
};
class BTree;

class Glyph {
public:
    virtual ~Glyph();

    virtual void Draw(Window*, GlyphContext&);

    virtual void SetFont(Font*, GlyphContext&);
    virtual Font* GetFont(GlyphContext&);

    virtual void First(GlyphContext&);
    virtual void Next(GlyphContext&);
    virtual void IsDone(GlyphContext&);
    virtual Glyph* Current(GlyphContext&);

    virtual void Insert(Glyph*, GlyphContext&);
    virtual void Remove(GlyphContext&);
protected:
    Glyph();
};</code></pre>
                            <p>La sous-classe <span class="em">Character</span> représente nos flyweights et ne garde en intrinsèque que la valeur de ceux-ci.</p>
<pre><code>class Character : public Glyph {
public:
    Character(char);

    virtual void Draw(Window*, GlyphContext&);
private:
    char _charcode;
};</code></pre>
                            <p>Les attributs graphiques (police) seront conservés dans la classe suivante. Elle sert d'entrepôt des états extrinsèques. Pour connaître le glyph entièrement, on passera un paramètre GlyphContext à chaque opération. Ce contexte dépendra de l'endroit où est situé le glyph dans le texte et donc dans la structure du Composite.</p>
<pre><code>class GlyphContext {
public:
    GlyphContext();
    virtual ~GlyphContext();

    virtual void Next(int step = 1);
    virtual void Insert(int quantity = 1);

    virtual Font* GetFont();
    virtual void SetFont(Font*, int span = 1);
private:
    int _index;
    BTree* _fonts;
};</code></pre>
                            <p>Le <span class="em">GlyphContext</span> devra rester informé de la position courante dans la structure des glyph (Composite) tout au long de la traversée. La méthode <span class="html">Next</span> incrémente le champ <span class="em">_index</span> au fur et à mesure que la traversée se déroule. Les sous-classes de <span class="em">Glyph</span> ayant des efnants (<span class="em">Row</span>, <span class="em">Column</span>, ...) implémenteront cette méthode pour appeler <span class="html">Next</span> lors de chaque étape.</p>
                            <p>La méthode <span class="html">GetFont</span> utilise cet index comme une clé de recherche dans un B-Arbre qui stocke la correspondance entre glyph et police. Chaque noeud de l'arbre indique la longueur de la chaîne pour laquelle il donne l'information concernant la police. Les feuilles pointent sur une police. Les noeuds intérieurs brise bien la chaîne en ssous-chaînes pour tenir compte des modifications de polices.</p>
                            <p>Si on considère l'extrait de texte suivant :</p>
                            <img src="../images/exemple_flyweight.png" alt="">
                            <p>le B-Arbre pourrait se présenter comme suit :</p>
                            <img src="../images/exemple_flyweight_2.png" alt="">
                            <p>La chaîne de 500 caractères est séparée en trois sous-chaînes respectivement de 1, 300 et 199 caractères. Ces deux dernières sous-chaînes ont elles-mêmes été brisées pour comporter des polices différentes. La structure reflète les changements de polices successifs.</p>
                            <p>Le code suivant suppose qu'on se trouve au caractère 102 et qu'on désire supprimer la présentation en italique du mot <span class="em">expect</span>, l'arbre devient :</p>
<pre><code>void dummy() {
    GlyphContext gc;
    Font* times12 = new Font("Times-Roman-12");
    Font* timesItalic12 = new Font("Times-Italic-12");
    // ...

    gc.SetFont(times12, 6);</code></pre>
                            <img src="../images/exemple_flyweight_3.png" alt="">
                            <p>Si on désire à présent insérer le mot "<span class="em">don't </span>" (y compris l'espace final) en italique, on aura :</p>
<pre><code> gc.Insert(6);
    gc.SetFont(timesItalic12, 6);
}</code></pre>
                            <p>ce qui conduira à l'arbre suivant :</p>
                            <img src="../images/exemple_flyweight_4.png" alt="">
                            <p>Pour retrouver la police du glyph en cours, on descend l'arbre en ajoutant les indices, jusqu'à trouver la police de l'indice courant. Ce temps de recherche n'est pas très long et dépend en fait du nombre de modification de polices faites. En général, ceux-ci sont rares et la taille de l'arbre reste petite.</p>
                            <p>Montrons l'implémentation de la <span class="em">FlyweightFactory</span> :</p>
<pre><code>class Row {
    // ...
};
class Column {
    // ...
};

const int NCHARCODES = 128;

class GlyphFactory {
public:
    GlyphFactory();
    virtual ~GlyphFactory();

    virtual Character* CreateCharacter(char);
    virtual Row* CreateRow();
    virtual Column* CreateColumn();
    // ...
private:
    Character* _character[NCHARCODES];
};

GlyphFactory::GlyphFactory() {
    for (int i = 0; i &lt; NCHARCODES; ++i) {
        _character[i] = 0;
    }
}

Character* GlyphFactory::CreateCharacter(char c) {
    if (!character[c]) {
        _character[c] = new Character(c);
    }

    return _character[c];
}</code></pre>
                            <p>La création des objets non partagés se fait en appelant leur constructeur. On aurait pu laisser les clients le faire directement mais cela aurait rendu le code plus difficile à modifier si on décide plus tard de les partager.</p>
<pre><code>Row* GlyphFactory::CreateRow() {
    return new Row();
}

Column* GlyphFactory::CreateColumn() {
    return new Column();
}</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Flyweight est souvent utilisé en combinaison avec Composite pour implémenter une structure logique hiérarchique sous forme de graphe dirigé acyclique dont les feuilles seront partagées.</p>
                                </li>
                                <li>
                                    <p>On a souvent intérêt à implémenter des objets State ou Strategy sous forme de flyweights.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="facade">Facade :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Structurel Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Fournir une interface unifiée pour un ensemble d'interfaces d'un sous-système. Facade définit une interface de plus haut niveau qui rend le sous-système plus facile à utiliser.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Toute analyse commence par une phase exploratoire. Les questions qu'on s'y pose sont tout d'abord : "Qui fera partie du groupe de développement ?", "Quels sont les buts du systèmz à developper ?", "Que doit accomplir ce système ?", "Quels sont les objets requis pour modéliser le système et accomplir ces buts ?". Ensuite, pour chaque objet, on essaiera de déterminer quelles sont ses tâches et ses responsabilités, que doit-il savoir pour accomplir les buts et de quelles étapes il est responsable dans l'accomplissement d'un de ces buts. On recherchera ensuite les collaborations entre les objets en précisant la nature de ces collaborations.</p>
                            <p>La phase d'analyse proprement dite précisera ces relations entre objets en indiquant quelles sont les liaisons par héritage, en déterminant les classes abstraites et en précisant le contrat à remplir par chaque classe. Cette phase recherchera ensuite des sous-sytèmes en décomposant le groupe de développeur et en divisant les responsabilités entre sous-sytèmes. Elle définira les interfaces des classes et des sous-systèmes. Elle se terminera en regroupant le tout : construction de protocoles de collaboration pour chaque classe, spécification du design pour chaque classe, chaque sous-système et chaque sous-système et chaque contrat.</p>
                            <p>Strutcurer un système en sous-systèmes réduit la complexité. Un sous-système sera un ensemble de classes qui collaborent entre elles ou avec d'autres sous-syst§mes pour supporter un ensemble de contrats. La seule différence entre les responsabilités d'une classe et celles d'un sous-sytème est une question d'échelle.</p>
                            <p>Il faudrait qu'un sous-système corresponde à une bonne abstraction au sein du système complet et qu'il y ait le moins de communications possibles entre les sous-syst§mes. Aussi pourvoira-t-on une interface de haut niveau au sous-sytème. Pour ce faire, on introduira une classe Facade qui définira cette interface unique plus simple que l'ensemble des fonctionnalités du sous-système.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Facade quand :</p>
                            <ul>
                                <li>
                                    <p>On désire fournir une interface plus simple à un sous-sytème complexe. D'autant plus qu'au cours de son évolution, un sous-système aura tendance à devenir de plus en plus complexe. L'ajout de patterns rendra ce sous-sytème plus flexible, plus réutilisable mais plus difficile à comprendre pour quelqu'un qui désire seulement avoir accès à quelques fonctionnalités. Une classe Facade définira la vue par défaut du sous-système. Seul les clients avec des besoins spécifiques iront voir plus loin.</p>
                                </li>
                                <li>
                                    <p>Il y a beaucoup de dépendances entre les clients et les classes implémentant une abstraction. La Facde découplera le sous-système de ses clients.</p>
                                </li>
                                <li>
                                    <p>On désire développer un logiciel en couche dont chaque sous-sytsème sera une couche. La Facade définira la communication entre deux couches.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_facade.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="em">Facade</span> : qui connaît quelles classes du sous-sytème sont responsables de quelles requêtes et délègue celles-ci aux objets appropriés.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les classes du sous-système</span> : implémentent les fonctionnalités du sous-système, traitent les requêtes retransmises par la Facade mais n'ont aucune connaissance de celle-ci, autrement dit, ne gardent aucune référence à elle.</p>
                                </li>
                            </ul>
                            <p>Les clients enverront leurs requêtes à la Facade qui transmettra. La Facade devra peut-être faire un travail de traduction d'une requête client en diverses requêtes aux objets du sous-sytème.</p>
                            <p>Les clients qui utilisent la Facade n'auront pas accès directement à ces objets.</p>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Facade masque aux clients les composantes du sous-système, réduisant le nombre d'objets connus par les clients et rendant le sous-système plus facile à utiliser.</p>
                                </li>
                                <li>
                                    <p>Il favorise un couplage faible entre clients et sous-sytèmes. Comme souvent dans un sous-système le couplage est fort, le remplacement d'une composante affectera le sous-système mais, grpace à Facade, pas les clients. Il apporte une aide au développement en couche et aide à éliminer des dépendances complexes, voire circulaires. Tout ceci aura pour conséquence de réduire le temps de compilation du système.</p>
                                </li>
                                <li>
                                    <p>Il n'empêche pas aux clients d'accéder directement aux objets du sous-sytème. Ils peuvent donc choisir entre facilité et généralité.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>Les points suivants seront à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">Réduire le couplage client - sous-système.</span> Le couplage peut encore être réduit en faisant de Facade une classe abstraite dont les sous-classes concrètes correspondront à diverses implémentations du sous-syst§me. Si le client communique avec le sous-système via l'interface abstraite, il ne connaîtra même pas quelle implémentation est en cours d'utilisation. Plutôt que d'employer l'héritage, on peut configurer la Facade avec différents objets du sous-système. Remplacer l'un ou l'autre de ces objets permettra d'adapter la Facade.</p>
                                </li>
                                <li>
                                    <p><span class="em">Les classes du sous-sytème sont-elles publiques ou privées ?</span> On mettra publique les classes auxquelles les clients peuvent avoir accès. Facade en fera partie mais ce n'est pas nécessairement la seule. En C++, on utilisera les namespaces pour rendre les classes publiques ou privées. En Java, on utilisera les packages : les classes publiques seront déclarées <span class="html">public</span>, les autres pas et seront donc uniquement accessibles dans leur package.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Abstract Factory pourra être utilisé avec Facade pour fournir une interface de création des objets du sous-système. Il pourra même être utilisé en remplacement de Facade pour cacher des classes spécifiques.</p>
                                </li>
                                <li>
                                    <p>Mediator est semblable à Facade dans son abstraction des fonctionnalités de classes existantes. Mais les collègues du Mediator le connaissent et celui-ci centralise du comportement qui n'existe chez aucun d'entre eux. Le but de Mediator est différent : abstraire la communication entre les collègues. Facade, au contraire, abstrait l'interface vers le sous-sytème ne coonnaissent pas la classe Facade.</p>
                                </li>
                                <li>
                                    <p>Comme souvent on n'aura besoin que d'une seule Facade, on utilisera Singleton pour l'implémenter.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="interpreter">Interpreter :</h2>
                    <dl>
                        <dt>Classification</dt>
                        <dd>
                            <p>Comportemental Objet</p>
                        </dd>
                        <dt>But</dt>
                        <dd>
                            <p>Étant donné un langage, définit une représentation pour sa grammaire et un interpréteur qui utilise cette représentation pour interpréter les phrases du langage.</p>
                        </dd>
                        <dt>Motivation</dt>
                        <dd>
                            <p>Si un travail à faire se présente fréquemment (exemple : chercher une chaîne de caractère dans un texte), on a parfois intérêt à construire un langage simple qui nous permettra de faire le travail (exemple : les expressions régulières). Le pattern Interpreter nous aidera à définir la grammaire de ce langage, à représenter les phrases du langage puis à les interpréter.</p>
                            <p>Pour notre exemple, une grammaire pourrait être :</p>
<pre><code>
expression  : litteral
            | alternative
            | suite
            | repetition
            | '(' expression ')'
alternative : expression '|' expression
suite       : expression expression
repetition  : expression '*'
litteral    : ('a'' | 'b' | ...) ('a' | 'b' | ...)*
</code></pre>
                            <p>Le pattern utilisera une classe pour chaque règle de grammaire. Les champs de ces classes seront les membres de droite de la règle. La grammaire ci-dessus pourra se représenter comme suit :</p>
                            <img src="../images/motivation_interpreter.png" alt="">
                            <p>Toute expression régulière sera alors représentée par un arbre syntaxique. Par exemple l'expression <span class="em">raining(dogs|cats)*</span> se représentera par l'arbre :</p>
                            <img src="../images/motivation_interpreter_2.png" alt="">
                            <p>Attention, ce pattern n'a rien à voir avec l'analyse syntaxique. C'est elle et non le pattern qui construira l'arbre ci-dessus. Le pattern indique quelle représentation il faut faut obtenir et indique comment interpréter le résultat.</p>
                            <p>L'interprétation se fera en ajoutant dans chaque classe une méthode <span class="html">interpret()</span> qui prend comme argument le contexte dans lequel interpréter l'expression. Ce contexte contient le texte dans lequel on recherche et de l'information concernant l'état d'avancement du matching de l'expression dans ce texte.</p>
                        </dd>
                        <dt>Applicabilité</dt>
                        <dd>
                            <p>On utilise Interpreter quand il y a un langage à interpréter et qu'on peut aisément représenter les phrases de ce langage sous forme d'arbre syntaxique. Ce pattern fonctionnera d'autant mieux que :</p>
                            <ul>
                                <li>
                                    <p>la grammaire est simple.</p>
                                </li>
                                <li>
                                    <p>l'efficacité n'est pas critique (les interpréteurs efficaces n'interprètent pas directement l'arbre syntaxique).</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Structure, Participants et Collaborations</dt>
                        <dd>
                            <img src="../images/structure_participants_collaborations_interpreter.png" alt="">
                            <p>Les participants sont donc :</p>
                            <ul>
                                <li>
                                    <p><span class="html">AbstractExpression</span> : déclare l'opération abstraite <span class="html">interpret()</span> commune à tous les noeuds de l'arbre syntaxique.</p>
                                </li>
                                <li>
                                    <p><span class="em">TerminalExpression</span> : implémente <span class="html">interpret()</span> pour les symboles terminaux de la grammaire. Une instance sera requise pour chaque symbole terminal.</p>
                                </li>
                                <li>
                                    <p><span class="em">NonTerminalExpression</span> : Une instance en est requise pour chaque règle. Maintient une référence à une AbstractExpression pour chaque symbole de la partie droite de la règle et implémente <span class="html">interpreter()</span> pour les symboles non terminaux. Cette méthode s'appellera récursivement sur les symboles de la partie droite de la règle.</p>
                                </li>
                                <li>
                                    <p><span class="em">Context</span> : contient de l'information globale à l'interpréteur. L'opération <span class="html">interpret()</span> de chaque noeud de l'arbre syntaxique l'utilisera pour stocker et accéder à l'état de l'interpréteur.</p>
                                </li>
                                <li>
                                    <p><span class="em">Client</span> : constuit ou reçoit l'arbre syntaxique d'une phrase du langage. Celui-ci est constitué d'instances de TerminalExpression et de NonTerminalExpression. Il invoque l'opération <span class="html">interpret()</span> après avoir initialisé le Context.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Conséquences</dt>
                        <dd>
                            <p>Avantages :</p>
                            <ul>
                                <li>
                                    <p>Il est facile de changer ou d'étendre la grammaire. L'héritage permet de définir de nouvelles règles.</p>
                                </li>
                                <li>
                                    <p>L'implémentation de la grammaire est aisée. Les classes constituant les noeuds de l'arbre sont similaires, faciles à écrire et peuvent même être générées automatiquement par un générateur de parser tel que <span class="em">yacc</span>.</p>
                                </li>
                                <li>
                                    <p>De nouvelles façons d'interpréter sont faciles à ajouter. On définira une nouvelle opération dans chaque classe de la grammaire. Si on ajoute souvent de nouvelles interprétations, il sera utile de songer à utiliser Visitor.</p>
                                </li>
                            </ul>
                            <p>Désavantage :</p>
                            <ul>
                                <li>
                                    <p>Des grammaires complexes sont difficiles à maintenir.</p>
                                </li>
                            </ul>
                        </dd>
                        <dt>Implémentation</dt>
                        <dd>
                            <p>On se reportera aux considérations d'implémentation de Composite qui sont valables aussi pour Interpreter.</p>
                            <p>Les points suivants seront de plus à prendre en considération :</p>
                            <ol>
                                <li>
                                    <p><span class="em">La création de l'arbre syntaxique.</span> Elle n'est pas faite par le pattern. Elle pourra l'être par un parser généré (par <span class="em">yacc</span>) ou écrit à la main (descente récursive).</p>
                                </li>
                                <li>
                                    <p><span class="em">La définition de l'opération <span class="html">interpreter()</span>.</span> Elle ne doit pas nécessairement se trouver dans les classes de la grammaire. On peut songer à employer Visitor pour la définir en dehors.</p>
                                </li>
                                <li>
                                    <p class="em">Partager les symboles terminaux en utilisant Flyweight.</p>
                                </li>
                            </ol>
                        </dd>
                        <dt>Exemple :</dt>
                        <dd>
                            <p>Considérons un système pour manipuler et évaluer des expressions booléennes. La grammaire est la suivante :</p>
<pre><code>Boolean Expression : Variable
                   | Constant
                   | Or
                   | And
                   | Not
                   | '(' BooleanExpression ')'

And      : BooleanExpression AND BooleanExpression
Or       : BooleanExpression OR BooleanExpression
Not      : NOT BooleanExpression

Constant : TRUE | FALSE
Variable : ID</code></pre>
                            <p>Les tokens <span class="html">AND</span>, <span class="html">OR</span>, <span class="html">NOT</span>, <span class="html">TRUE</span>, <span class="html">FALSE</span>, <span class="html">ID</span> sont supposés renvoyés par une analyse lexicale (simpliste) à la rencontre respective des textes <span class="html">&&</span>, <span class="html">||</span>, <span class="html">!</span>, <span class="html">true</span>, <span class="html">false</span> et de tout autre identificateur.</p>
                            <p>Nous définirons deux opérations d'interprétations sur ces expressions booléennes. La première <span class="html">evaluate()</span> évalue l'expression, la deuxième <span class="html">replace()</span> permet de remplacer dans l'expression, une variable par une autre expression. Cette opération s'appellera récursivement dans les classes correspondant aux symboles non terminaux et, dans la classe <span class="em">Variable</span>, renverra le nom de la variable sauf si ce nom est justement celui à remplacer auquel cas on renverra le remplacement.</p>
                            <p>La classe <span class="em">Context</span> garde la liaison entre variable et valeur qui permettra l'évaluation.</p>
<pre><code>public interface <span class="em">BooleanExpression</span> {
    public boolean evaluate(Context values);
    public BooleanExpression replace(String varName, BooleanExpression replacement);
    public Object clone();
    public String toString();
}

public class <span class="em">And</span> implements BooleanExpression {
    private BooleanExpression leftOperand;
    private BooleanExpression rightOperand;

    public And(BooleanExpression leftOperand, BooleanExpression rightOperand) {
        this.leftOperand = leftOperand;
        this.rightOperand = rightOperand;
    }

    public boolean evaluate(Context values) {
        return leftOperand.evaluate(values) && rightOperand.evaluate(values);
    }

    public BooleanExpression replace(String varName, BooleanExpression replacement) {
        return new And(leftOperand.replace(varName, replacement), rightOperand.replace(varName, replacement));
    }

    public Object clone() {
        return new And((BooleanExpression) leftOperand.clone(), (BooleanExpression) rightOperand.clone());
    }

    public String toString() {
        return "(" + leftOperand.toString() + " and " + rightOperand.toString() + ")";
    }
}

public class <span class="em">Or</span> implements BooleanExpression {
    private BooleanExpression leftOperand;
    private BooleanExpression rightOperand;

    public Or(BooleanExpression leftOperand, BooleanExpression rightOperand) {
        this.leftOperand = leftOperand;
        this.rightOperand = rightOperand;
    }

    public boolean evaluate(Context values) {
        return leftOperand.evaluate(values) || rightOperand.evaluate(values);
    }

    public BooleanExpression replace(String varName, BooleanExpression replacement) {
        return new Or(leftOperand.replace(varName, replacement), rightOperand.replace(varName, replacement));
    }

    public Object clone() {
        return new Or((BooleanExpression) leftOperand.clone(), (BooleanExpression) rightOperand.clone());
    }

    public String toString() {
        return "(" + leftOperand.toString() + " or " + rightOperand.toString() + ")";
    }
}

public class <span class="em">Not</span> implements BooleanExpression {
    private BooleanExpression operand;

    public And(BooleanExpression operand) {
        this.operand = operand;
    }

    public boolean evaluate(Context values) {
        return !operand.evaluate(values);
    }

    public BooleanExpression replace(String varName, BooleanExpression replacement) {
        return new Not(operand.replace(varName, replacement));
    }

    public Object clone() {
        return new Not((BooleanExpression) operand.clone());
    }

    public String toString() {
        return "( not " + operand.toString() + ")";
    }
}

public class <span class="em">Constant</span> implements BooleanExpression {
    private boolean value;
    private static Constant True = new Constant(true);
    private static Constant False = new Constant(false);

    public static Constant getTrue() {
        return True;
    }

    public static Constant getFalse() {
        return False;
    }

    private Constant(boolean value) {
        this.value = value;
    }

    public boolean evaluate(Context values) {
        return value;
    }

    public BooleanExpression replace(String varName, BooleanExpression replacement) {
        return this;
    }

    public Object clone() {
        return this;
    }

    public String toString() {
        return String.valueOf(value);
    }
}

public class <span class="em">Variable</span> implements BooleanExpression {
    private static Hashtable flyWeights = new Hashtable();

    private String name;

    public static Variable get(String name) {
        if (!flyWeights.contains(name))
            flyWeights.put(name, new Variable(name));
        
        return (Variable) flyWeights.get(name);
    }

    private Variable(String name) {
        this.name = name;
    }

    public boolean evaluate(Context values) {
        return values.getValue(name);
    }

    public BooleanExpression replace(String varName, BooleanExpression replacement) {
        if (varName.equals(name))
            return (BooleanExpression) replacement.clone();
        else
            return this;
    }

    public Object clone() {
        return this;
    }

    public String toString() { return name; }
}

public class <span class="em">Context</span> {
    Hashtable values = new Hashtable();

    public boolean getValue(String variableName) {
        Boolean wrappedValue = (Boolean) values.get(variableName);
        return wrappedValue.booleanValue();
    }

    public void setValue(String variableName, boolean value) {
        values.put(variableName, new Boolean(value));
    }
}</code></pre>
                            <p>Montrons comment tout cela peut être utilisé :</p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        BooleanExpression left = new Or(Constant.getTru(), Variable.get("x"));
        BooleanExpression right = new And(Variable.get("w"), Variable.get("x"));

        BooleanExpression all = new And(left, right);

        System.out.println(all);
        Context values = new Context();
        values.setValue("x", true);
        values.setValue("w", false);

        System.out.println(all.evaluate(values));
        System.out.println(all.replace("x", right));
    }
}</code></pre>
                            <p>Ceci donnera en sortie :</p>
<pre><code>((true or x) and (w and x))
false
((true or (w and x)) and (w and (w and x)))</code></pre>
                        </dd>
                        <dt>Patterns reliés</dt>
                        <dd>
                            <ul>
                                <li>
                                    <p>Composite : l'arbre syntaxique est un Composite.</p>
                                </li>
                                <li>
                                    <p>Flyweight : pour stocker les symboles terminaux.</p>
                                </li>
                                <li>
                                    <p>Iterator : pour traverser l'arbre syntaxique.</p>
                                </li>
                                <li>
                                    <p>Visitor : pour maintenir les interprétations de chaque noeud dans une seule classe.</p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
                <article>
                    <h2 id="exercices">Exercices :</h2>
                    <ol>
                        <li>
                            <h3>Semaine 1 :</h3>
                            <p>Vous venez d'être engagé par la société LeRobert qui est spécialisée dans l'analyse de texte. Elle vous demande d'écrire un programme qui lira le fichier texte dont le nom est passé en paramètre et calculera certaines statistiques dessus : le nombre de lignes, le nombre de mots, le nombre de palindromes et le nombre de lignes contenant le mot Belgique. Le premier jet du programme donne donc :</p>
<pre><code>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class AnalyseurDeTexte {
    public static void main(String[] args) throws IOException {
        BufferedReader lecteurAvecBuffer = null;
        String ligne;
        int nbrMots = 0, nbrLignes = 0, nbrPalindromes = 0, nbrBelgique = 0;
        try {
            lecteurAvecBuffer = new BufferedReader(new FileReader(args[0]));
        } catch (FileNotFoundException e) {
            System.out.println("Erreur d'ouverture");
        }
        while ((ligne = lecteurAvecBuffer.readLine()) != null) {
            nbrLignes++;
            if (ligne.contains("Belgique")) {
                nbrBelgique++;
            }
            for (String mot : ligne.trim().split(" ")) {
                nbrMots++;
                StringBuffer temp = new StringBuffer(mot);
                if (mot.equals(temp.reverse().toString())) {
                    nbrPalindromes++;
                }
            }
        }
        lecteurAvecBuffer.close();
        System.out.println("Il y avait " + nbrLignes + " lignes.";)
        System.out.println("Il y avait " + nbrMots + " mots.";)
        System.out.println("Il y avait " + nbrPalindromes + " palindromes.";)
        System.out.println("Il y avait " + nbrBelgique + " lignes contenant Belgique.";)
    }
}</code></pre>
                            <p>Content de l'efficacité avec laquelle vous venez de rédiger ce programme, votre employeur demande immédiatement d'étendre les analyses des phrases : il veut le comptage des lignes contenant une certaine expression régulière, il veut le comptage des lignes contenant une certaine expression régulière, il veut une analyse du nombre de fois que chaque mot apparaît dans le texte, et vous voyez dans ses yeux qu'il a encore plein d'autres idées derrière la tête... De plus suivant les cas, seules certaines statistiques seront utiles et il ne faut pas perdre de temps à calculer les autres. Il faut donc trouver une architecture logicielle permettant de facilement créer de nouvelles statistiques en ayant un minimum de travail à accomplir pour les ajouter ou les supprimer.</p>
                            <ol type="a">
                                <li>
                                    <p>Quel pattern allez-vous utiliser ? <span class="em html">Observer</span></p>
                                </li>
                                <li>
                                    <p>Donnez la correspondance entre les noms des classes utilisées dans la théorie et celle utilisées dans le code que vous écrirez.</p>
                                </li>
                                <li>
                                    <p>Réalisez la solution.</p>
<pre><code>public interface Observer {

    void update(String ligne);
    void imprimer();

}</code></pre>
<pre><code>public class LigneObserver implements Observer {

	private int cpt;
	
	@Override
	public void update(String ligne) {
		cpt++;
	}
	
	@Override
	public void imprimer() {
		System.out.println("Il y avait " + cpt + " lignes.");
	}

}</code></pre>
<pre><code>public class MotObserver implements Observer {

	private int cpt;
	
	public void update(String mot) {
		cpt++;
	}
	
	public void imprimer() {
		System.out.println("Il y avait " + cpt + " mots.");	
	}

}</code></pre>
<pre><code>public class PalindromeObserver implements Observer {
	
	private int cpt;
	
	public void update(String palindrome) {
		cpt++;
	}
	
	public void imprimer() {
		System.out.println("Il y avait " + cpt + " palindromes.");
	}

}</code></pre>
<pre><code>public class BelgiqueObserver implements Observer {
	
	private int cpt;
	
	@Override
	public void update(String ligne) {
		cpt++;
	}
	
	public void imprimer() {
		System.out.println("Il y avait " + cpt + " lignes contenant le mot Belgique.");
	}

}</code></pre>
<pre><code>public interface Subject {

	void addObserver (Observer o);
	void removeObserver (Observer o);
	void notifyObservers ();
	
}</code></pre>
<pre><code>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class SubjectConcret implements Subject {

	private List<Observer> observers;
	private String ligne;
	private BufferedReader lecteurAvecBuffer = null;

	public SubjectConcret() {
		this.observers = new ArrayList<>();
	}

	public void notifyObservers() {
		for (Observer o : observers) {
			o.imprimer();
		}
	}

	public void addObserver(Observer o) {
		observers.add(o);
	}

	public void removeObserver(Observer o) {
		observers.remove(o);
	}

	public void readFile(String file) throws IOException {
		try {
			lecteurAvecBuffer = new BufferedReader(new FileReader("Hello.txt"));
		} catch (FileNotFoundException e) {
			System.out.println("Erreur d'ouverture");
		}
		while ((ligne = lecteurAvecBuffer.readLine()) != null) {
			Observer ligneObserver = (LigneObserver) observers.get(0);
			ligneObserver.update(ligne);
			if (ligne.contains("Belgique")) {
				Observer belgiqueObserver = (BelgiqueObserver) observers.get(1);
				belgiqueObserver.update(ligne);
			}
			for (String mot : ligne.trim().split(" ")) {
				Observer motObserver = (MotObserver) observers.get(2);
				motObserver.update(mot);
				StringBuffer temp = new StringBuffer(mot);
				String palindrome = temp.reverse().toString();
				System.out.println("mot = " + mot + ", palindrome = " + palindrome);
				if (mot.equals(palindrome)) {
					Observer palindromeObserver = observers.get(3);
					palindromeObserver.update(palindrome);
				}
			}
		}
		lecteurAvecBuffer.close();
		notifyObservers();
	}

}</code></pre>
<pre><code>import java.io.IOException;

public class Main {

	public static void main(String[] args) throws IOException {
		SubjectConcret subject = new SubjectConcret();
		subject.addObserver(new LigneObserver());
		subject.addObserver(new BelgiqueObserver());
		subject.addObserver(new MotObserver());
		subject.addObserver(new PalindromeObserver());
		subject.readFile("Hello.txt");
	}
}</code></pre>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Semaine 2 :</h3>
                            <ol>
                                <li>
                                    <p>On désire écrire un petit logiciel permettant de lister les mots présents dans un fichier et répondant à une certaine condition. Une approche naïve a produit les programmes suivants :</p>
                                    <p>Le premier permet de lister les mots commençant par '<span class="em">t</span>' :</p>
<pre><code>import java.io.*;
import java.util.*;

public class ListerMots1 { // mal foutu
    private String fichier;

    public ListerMots1(String fichier) {
        this.fichier = fichier;
    }

    public void imprimerSiCommenceParT() throws IOException {
        BufferedReader input = new BufferedReader(new FileReader(this.fichier));
        String buffer = null;
        while ((buffer = input.readLine()) != null) {
            StringTokenizer mots = new StringTokenizer(buffer, " \t.;(){}\"'*=!/\\");
            while (mots.hasMoreTokens()) {
                String mot = mots.nextToken();
                if (mot.chatAt(0) == 't')
                    System.out.println(mot);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        if (args.length == 0) {
            System.out.println("Usage : java ListerMots1 fichier");
            System.exit(1);
        }
        new ListerMots1(args[0]).imprimerSiCommenceParT();
    }
}</code></pre>
                                    <p>Un deuxième programme permet de lister les mots d'une longueur précisée :</p>
<pre><code>import java.io*;
import java.util.*;

public class ListerMots2 { // mal foutu
    private String fichier;

    public ListerMots2(String fichier) {
        this.fichier = fichier;
    }

    public void imprimerSiDeLongueur(int longueur) throws IOException {
        BufferedReader input = new BufferedReader(new FileReader(this.fichier));
        String buffer = null;
        while ((buffer = input.readLine()) != null) {
            StringTokenizer mots = new StringTokenizer(buffer, " \t.;(){}\"'*=!/\\");
            while (mots.hasMoreTokens()) {
                String mot = mots.nextToken();
                if (mot.length == longueur)
                    System.out.println(mot);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        if (args.length == 0) {
            System.out.println("Usage : java ListerMots2 fichier");
            System.exit(1);
        }
        new ListerMots2(args[0]).imprimerSiDeLongueur(5);
    }
}</code></pre>
                                    <p>Un troisième permet de lister les palindromes :</p>
<pre><code>import java.io*;
import java.util.StringTokenizer;

public class ListerMots3 { // mal foutu
    
    private String fichier;

    public ListerMots3(String fichier) {
        this.fichier = fichier;
    }

    public void imprimerPalindromes() throws IOException {
        BufferedReader input = new BufferedReader(new FileReader(this.fichier));
        String buffer = null;
        while ((buffer = input.readLine()) != null) {
            StringTokenizer mots = new StringTokenizer(buffer, " \t.;(){}\"'*=!/\\");
            while (mots.hasMoreTokens()) {
                String mot = mots.nextToken();
                if (estPalindrome(mot))
                    System.out.println(mot);
            }
        }
    }

    public boolean estPalindrome(String mot) {
        if (mot == null)
            return false;
        StringBuffer stringbuffer = new StringBuffer(mot);
        return mot.equals(stringbuffer.reverse().toString());
    }

    public static void main(String[] args) throws IOException {
        if (args.length == 0) {
            System.out.println("Usage : java ListerMots3 fichier");
            System.exit(1);
        }
        new ListerMots3(args[0]).imprimerPalindromes();
    }
}</code></pre>
                                    <p>On vous demande de modifier ces programmes afin de n'écrire qu'une seule fois le programme de base et de pouvoir choisir la condition que doivent vérifier les mots listés. On généralisera aussi le premier programme afin de lister les mots commençant par n'importe quelle chaîne de caractères. Quel pattern utiliserez-vous pour cela ? <span class="em html">Strategy</span></p>
<pre><code>public interface Strategy {

	boolean traiterMot (String s);
	
}</code></pre>
<pre><code>public class CommencePar implements Strategy {
	
	private char c;
	
	public CommencePar(char c) {
		this.c = c;
	}
	
	@Override
	public boolean traiterMot(String s) {
		return s.charAt(0) == this.c;
	}
	
}</code></pre>
<pre><code>public class LongueurDe implements Strategy {

	private int longueur;
	
	public LongueurDe(int longueur) {
		this.longueur = longueur;
	}
	
	@Override
	public boolean traiterMot(String s) {
		return s.length()  == this.longueur;
	}
	
}</code></pre>
<pre><code>import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class ListerMots {

    private String fichier;

    public ListerMots(String file) {
        this.fichier = file;
    }

    void imprimerSi(Strategy s) throws IOException {
        BufferedReader input = new BufferedReader(new FileReader(this.fichier));
        String buffer = null;
        while ((buffer = input.readLine()) != null) {
            StringTokenizer mots = new StringTokenizer(buffer, " \t.;(){}\"'*=:!/\\");
            while (mots.hasMoreTokens()) {
                String mot = mots.nextToken();
                if (s.traiterMot(mot)) {
                    System.out.println(mot);
                }
            }
        }
        input.close();
    }

}</code></pre>
<pre><code>import java.io.IOException;

public class Main {

    public static void main(String[] args) throws IOException {
        Strategy strat1 = new CommencePar('t');
        Strategy strat2 = new LongueurDe(4);
        ListerMots listeMots = new ListerMots("Hello.txt");
    }

}</code></pre>
                                </li>
                                <li>
                                    <p>Jusqu'ici notre application n'a implémenté que des sélections primitives. On désire à présent combiner plusieurs sélections.</p>
                                    <ol type="a">
                                        <li>
                                            <p>Écrivez une classe <span class="em">And</span> qui permet de combiner deux sélections selon la règle</p>
                                            <p>sélection : sélection AND sélection</p>
<pre><code>public class And implements Strategy {

	private Strategy s1;
	private Strategy s2;

	public And(Strategy s1, Strategy s2) {
		this.s1 = s1;
		this.s2 = s2;
	}
	
	public boolean traiterMot(String s) {
		return s1.traiterMot(s) && s2.traiterMot(s); 
	}

}</code></pre>
                                        </li>
                                        <li>
                                            <p>Écrivez de même une classe <span class="em">Or</span> et une classe <span class="em">Not</span> en respectant les règles :</p>
                                            <p>sélection : sélection OR sélection</p>
                                            <p>sélection : NOT sélection</p>
<pre><code>public class Or implements Strategy {

	private Strategy s1;
	private Strategy s2;

	public Or(Strategy s1, Strategy s2) {
		this.s1 = s1;
		this.s2 = s2;
	}

	public boolean traiterMot(String s) {
		return s1.traiterMot(s) || s2.traiterMot(s);
	}

}</code></pre>
<pre><code>public class Not {

    private Strategy s1;

    public Not(Strategy s1) {
        this.s1 = s1;
    }
    
    public boolean traiterMot(String s) {
        return !s1.traiterMot(s); 
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Quel pattern est utilisé dans cette construction ? <span class="em html">Strategy</span></p>
                                        </li>
                                        <li>
                                            <p>Donnez la correspondance entre les noms des classes utilisées dans la théorie et celles utilisées dans le code que vous écrirez.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <ol type="a">
                                        <li>
                                            <p>Écrivez à présent une classe <span class="em">Et</span> qui combine un nombre quelconque de sélections pour ne sélectionner que les mots qui satisfassent à toutes. Écrivez semblablement une classe <span class="em">Ou</span>.</p>
<pre><code>public class Et {

	private Strategy[] strats;

	public Et(Strategy... strats) {
		this.strats = strats;
	}
	
	public boolean traiterMot(String s) {
		for (Strategy strat : strats) {
			if (!strat.traiterMot(s)) {
				return false;
			}
		}
		return true; 
	}
	
}</code></pre>
<pre><code>public class Ou {

	private Strategy[] strats;
	
	public Ou(Strategy... strats) {
		this.strats = strats;
	}
	
	public boolean traiterMot(String s) {
		for (Strategy strat : strats) {
			if (strat.traiterMot(s)) {
				return true;
			}
		}
		return false;
	}
	
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Quel pattern est utilisé dans cette construction ? <span class="em html">Interpreter</span></p>
                                        </li>
                                        <li>
                                            <p>Donnez la correspondance entre les noms des classes utilisées dans la théorie et celles utilisées dans votre code.</p>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <p>On voudrait à présent que, si l'utilisateur le désire, il puisse connaître le nombre de mots sélectionnés. Il est clair qu'on ne va pas écrire une sous-classe de chaque classe de sélection pour arriver au résultat. Un pattern permet de le faire en n'écrivant qu'une seule classe : la classe <span class="em">Compteur</span>.</p>
                                    <ol type="a">
                                        <li>
                                            <p>Écrivez cette classe.</p>
<pre><code>public class Compteur  implements Strategy {

	private int cpt = 0;
	private Strategy strat;
	
	public Compteur(Strategy strat) {
		this.strat = strat;
	}
	
	
	public int getCpt() {
		return cpt;
	}
	
	@Override
	public boolean traiterMot(String s) {
		boolean b = strat.traiterMot(s);
		if (b) {
			cpt++;
		}
		return b;
	}
		
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Quel pattern avez-vous utilisé pour résoudre ce problème ? <span class="em html">Decorator</span></p>
                                        </li>
                                        <li>
                                            <p>Donnez la correspondance entre les noms des classes utilisées dans la théorie et celles utilisées dans votre code.</p>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Semaine 3 :</h3>
                            <ol>
                                <li>
                                    <p>Implémentation :</p>
                                    <p>Soient les classes DVD, Livre, MagasinDeDVD et MagasinDeLivre.</p>
<pre><code>public class DVD {
    public static final double PRIX = 19.99;
	private String name;
	private int anneeDeParution;
	private double prix;
	public DVD(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}
	public String getName() {
		return name;
	}
	public int getAnneeDeParution() {
		return anneeDeParution;
	}
	public double getPrix() {
		return prix;
	}
	public void setPrix(double prix) {
		this.prix = prix;
	}
	
}</code></pre>
<pre><code>public class Livre {
	public static final double PRIX = 14.99;
	private String name;
	private int anneeDeParution;
	private double prix;
	public Livre(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}
	public String getName() {
		return name;
	}
	public int getAnneeDeParution() {
		return anneeDeParution;
	}
	public double getPrix() {
		return prix;
	}
	public void setPrix(double prix) {
		this.prix = prix;
	}
	
}</code></pre>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class MagasinDeDVD {
	private Map&lt;String,DVD&gt; bac = new HashMap&lt;String,DVD&gt;();
	public void ajouterDVD(String name, int anneeDeParution) {
		DVD dvd = new DVD(name, anneeDeParution);
		bac.put(name, dvd);
	}
	public DVD retourneDVD(String name) {
		return bac.get(name);
	}
}</code></pre>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class MagasinDeLivre {
    private Map&lt;String,Livre&gt; etagere = new HashMap&lt;String,Livre&gt;();
    public void ajouterLivre(String name, int anneeDeParution) {
        Livre livre=new Livre(name, anneeDeParution);
        etagere.put(name, livre);
    }
    public Livre retourneLivre(String name) {
        return etagere.get(name);
    }
}</code></pre>
                                    <ol type="a">
                                        <li>
                                            <p>Refactorez le code afin qu'il implémente le pattern Factory Method. Écrivez un main qui instancie un magasin de DVD et y ajoute 3 DVDs, puis qui instancie un magasin de Livre et y ajoute 4 livres.</p>
<pre><code>public interface Product {

	String getName();
	int getAnneeDeParution();
	double getPrix();
	void setPrix(double prix);

}</code></pre>
<pre><code>public class DVD implements Product {
	
	public static final double PRIX = 19.99;
	private String name;
	private int anneeDeParution;
	private double prix;

	public DVD(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}

	public String getName() {
		return name;
	}

	public int getAnneeDeParution() {
		return anneeDeParution;
	}

	public double getPrix() {
		return prix;
	}

	public void setPrix(double prix) {
		this.prix = prix;
	}

}</code></pre>
<pre><code>public class Livre implements Product {
	
	public static final double PRIX = 14.99;
	private String name;
	private int anneeDeParution;
	private double prix;

	public Livre(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}

	public String getName() {
		return name;
	}

	public int getAnneeDeParution() {
		return anneeDeParution;
	}

	public double getPrix() {
		return prix;
	}

	public void setPrix(double prix) {
		this.prix = prix;
	}

}</code></pre>
<pre><code>import java.util.HashMap;
import java.util.Map;

public abstract class Magasin {

    private Map&lt;String, Product&gt; bac = new HashMap&lt;String, Product&gt;();

    public void ajouterProduct(String name, int anneeDeParution) {
        Product product = createProduct(name, anneeDeParution);
        bac.put(name, product);
    }

    public Product retourneProduct(String name) {
        return bac.get(name);
    }
    
    public abstract Product createProduct(String name, int anneeDeParution);
}</code></pre>
<pre><code>public class MagasinDeDVD extends Magasin {

	@Override
	public Product createProduct(String name, int anneeDeParution) {
		return new DVD(name, anneeDeParution);
	}
	
}</code></pre>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class MagasinDeLivre extends Magasin {

    @Override
    public Product createProduct(String name, int anneeDeParution) {
        return new Livre(name, anneeDeParution);
    }

}</code></pre>
<pre><code>public class Main {

	public static void main(String[] args) {
		MagasinDeDVD md = new MagasinDeDVD();
		MagasinDeLivre ml = new MagasinDeLivre();
	}
	
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Dans une autre projet, refactorez le code afin qu'il implémente le pattern Abstract Factory. Écrivez un main qui instancie un magasin de DVD et y ajoute 4 DVDs, puis qui instancie un magasin de Livre et y ajoute 3 livres.</p>
<pre><code>public interface Product {

	String getName();
	int getAnneeDeParution();
	double getPrix();
	void setPrix(double prix);

}</code></pre>
<pre><code>public interface ProductAbsFact {

	Product createProduct(String name, int anneeDeParution);

}</code></pre>
<pre><code>public class DVD implements Product {
	
	public static final double PRIX = 19.99;
	private String name;
	private int anneeDeParution;
	private double prix;

	public DVD(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}

	public String getName() {
		return name;
	}

	public int getAnneeDeParution() {
		return anneeDeParution;
	}

	public double getPrix() {
		return prix;
	}

	public void setPrix(double prix) {
		this.prix = prix;
	}

}</code></pre>
<pre><code>public class Livre implements Product {
	
	public static final double PRIX = 14.99;
	private String name;
	private int anneeDeParution;
	private double prix;

	public Livre(String name, int anneeDeParution) {
		this.name = name;
		this.anneeDeParution = anneeDeParution;
		this.prix = PRIX;
	}

	public String getName() {
		return name;
	}

	public int getAnneeDeParution() {
		return anneeDeParution;
	}

	public double getPrix() {
		return prix;
	}

	public void setPrix(double prix) {
		this.prix = prix;
	}

}</code></pre>
<pre><code>import java.util.HashMap;
import java.util.Map;

public class MagasinDeProduitAbstractFactory {

    private ProductAbsFact absFact;
    private Map&lt;String, Product&gt; bac = new HashMap&lt;String, Product&gt;();

    public MagasinDeProduitAbstractFactory(ProductAbsFact absFact) {
        this.absFact = absFact;
    }

    public void ajouterProduct(String name, int anneeDeParution) {
        Product product = absFact.createProduct(name, anneeDeParution);
        bac.put(name, product);
    }

    public Product retourneProduct(String name) {
        return bac.get(name);
    }
}</code></pre>
<pre><code>public class MagasinDeDVD implements ProductAbsFact {

	@Override
	public Product createProduct(String name, int anneeDeParution) {
		return new DVD(name, anneeDeParution);
	}

}</code></pre>
<pre><code>public class MagasinDeLivre implements ProductAbsFact {

	@Override
	public Product createProduct(String name, int anneeDeParution) {
		return new Livre(name, anneeDeParution);
	}

}</code></pre>
<pre><code>public class Main {

	public static void main(String args) {
		MagasinDeDVD md = new MagasinDeDVD();
		MagasinDeLivre ml = new MagasinDeLivre();
	}
	
}</code></pre>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <p>Reconnaissance (question de septembre 2016) :</p>
                                    <p>Pour écrire le code source du langage Java, les développeurs ont utilisé intensivement les patterns.</p>
                                    <p>Dans les deux codes proposés suivants issus des librairies Java, identifiez un pattern utilisé. Donnez la correspondance entre les noms des classes utilisées dans la théorie et celle du code.</p>
                                    <p>Pour plus d'informations à propos de ces codes, n'hésitez pas à consulter l'API Java. Le code suivant provient de la classe java.lang.Integer.</p>
                                    <ol type="a">
                                        <li>
<pre><code>public static Integer valueOf(int i) {
    final int offset = 128;
    if (i &gt;= -128 && i &lt;= 127) { // must cache
        return IntegerCache.cache[i + offset];
    }
    return new Integer(i);
}

private static class IntegerCache {
    private IntegerCache() {}

    static final Integer cache[] = new Integer[-(-128) + 127 + 1];

    static {
        for (int i = 0; i &lt; cache.length; i++)
            cache[i] = new Integer(i - 128);
    }
}</code></pre>
                                        </li>
                                        <li>
                                            <p>Le code suivant provient des classes java.io.Reader et java.io.BufferedReader.</p>
<pre><code>public abstract class Reader implements Readable, Closeable {

    public int read() throws IOException {
        char[] cb = new char[1];
        if (read(cb, 0, 1) == -1)
            return -1;
        else
            return cb[0];
    }

    abstract public int read(char[] cbuf, int off, int len) throws IOException;
}

public class BufferedReader extends Reader {
    public int read(char[] cbuf, int off, int len) throws IOException {
        synchronized(lock) {
            ensureOpen();
            if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return 0;
            }

            int n = read1(cbuf, off, len);
            if (n &lt;= 0)
                return n;
            while ((n &lt; len) && in.ready()) {
                int n1 = read1(cbuf, off + n, len - n);
                if (n1 &lt;= 0)
                    break;
                n += n1;
            }
            return n;
        }
    }
}</code></pre>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <h3>Semaine 4 :</h3>
                            <p>L'application Machine à café qui vous est fournie aurait un avantage à utiliser le pattern State. Modifiez cette application afin de répondre à ce souhait.</p>
                            <p>Voici le code qui vous est fourni :</p>
<pre><code>public class Piece {
	private String nom;
	private int valeur; // en cents
	
	public static final Piece vingtCents = new Piece("20 cents", 20);
	public static final Piece cinquanteCents = new Piece("50 cents", 50);
	public static final Piece unEuro = new Piece("1 Euro", 100);
	public static final Piece deuxEuros = new Piece("2 Euros", 200);
	
	
	private Piece(String nom, int valeur) {
		this.nom = nom;
		this.valeur = valeur;
	}

	public String getNom() {
		return nom;
	}

	public int getValeur() {
		return valeur;
	}

	@Override
	public String toString() {
		return nom;
	}
		
}</code></pre>
<pre><code>public class ToucheBoisson {
	private String type;
	private boolean auLait;
	private boolean sucre;
	private int prix; // en cents
	
	public static final ToucheBoisson cafeNoir = new ToucheBoisson("Café", false, false, 50);
	public static final ToucheBoisson cafeAuLait = new ToucheBoisson("Café", true, false, 70);
	public static final ToucheBoisson cafeNoirSucre = new ToucheBoisson("Café", false, true, 70);
	public static final ToucheBoisson cafeAuLaitSucre = new ToucheBoisson("Café", true, true, 90);
	
	public static final ToucheBoisson expresso = new ToucheBoisson("Expresso", false, false, 100);
	public static final ToucheBoisson expressoAuLait = new ToucheBoisson("Expresso", true, false, 120);
	public static final ToucheBoisson expressoSucre = new ToucheBoisson("Expresso", false, true, 120);
	public static final ToucheBoisson expressoAuLaitSucre = new ToucheBoisson("Expresso", true, true, 140);
	
	public static final ToucheBoisson decaNoir = new ToucheBoisson("Café décaféiné", false, false, 50);
	public static final ToucheBoisson decaAuLait = new ToucheBoisson("Café décaféiné", true, false, 70);
	public static final ToucheBoisson decaNoirSucre = new ToucheBoisson("Café décaféiné", false, true, 70);
	public static final ToucheBoisson decaAuLaitSucre = new ToucheBoisson("Café décaféiné", true, true, 90);
	
	public static final ToucheBoisson choco = new ToucheBoisson("Chocolat chaud", false, false, 70);
	public static final ToucheBoisson chocoAuLait = new ToucheBoisson("Chocolat chaud", true, false, 90);
	public static final ToucheBoisson chocoSucre = new ToucheBoisson("Chocolat chaud", false, true, 90);
	public static final ToucheBoisson chocoAuLaitSucre = new ToucheBoisson("Chocolat chaud", true, true, 110);

	public static final ToucheBoisson cappuccino = new ToucheBoisson("Cappuccino", false, false, 120);
	public static final ToucheBoisson viennois = new ToucheBoisson("Café Viennois", false, false, 120);
	public static final ToucheBoisson laitRusse = new ToucheBoisson("Lait russe", false, false, 100);
	public static final ToucheBoisson chocafe = new ToucheBoisson("Choco-Café", false, false, 120);
	
	public static final ToucheBoisson lait = new ToucheBoisson("Lait chaud", false, false, 70);
	public static final ToucheBoisson eau = new ToucheBoisson("Eau chaud", false, false, 0);
	
	
	private ToucheBoisson(String type, boolean lait, boolean sucre, int prix) {
		this.type = type;
		auLait = lait;
		sucre = sucre;
		this.prix = prix;
	}

	public String getType() {
		return type;
	}

	public boolean auLait() {
		return auLait;
	}

	public boolean estSucre() {
		return sucre;
	}

	public int getPrix() {
		return prix;
	}

	@Override
	public String toString() {
		return type + (auLait() ? " au lait" : "") + (estSucre() ? " sucré" : "");
	}
		
}</code></pre>
<pre><code>public class MachineACafe {
	public final int idle = 0;
	public final int collecte = 1;
	public final int pasAssez = 2;
	
	private int montantEnCours = 0;
	private int etatCourant = idle;
	private ToucheBoisson boisson = null;
	
	public void afficherMontant() {
		System.out.println(montantEnCours + " cents disponibles");
	}
	
	public void afficherRetour() {
		System.out.println(montantEnCours + " cents rendus");
	}
	
	public void afficherPasAssez(ToucheBoisson toucheBoisson) {
		System.out.println("Vous n'avez pas introduit un montant suffisant pour un " + toucheBoisson);
		System.out.println("Il manque encore " + (toucheBoisson.getPrix() - montantEnCours) + " cents");
	}

	public void afficherBoisson(ToucheBoisson toucheBoisson) {
		System.out.println("Voici un " + toucheBoisson);
		
	}

	public void entrerMonnaie(Piece piece) {
		montantEnCours += piece.getValeur();
		afficherMontant();
		if (etatCourant != pasAssez)
			etatCourant = collecte;
		else if (boisson.getPrix() > montantEnCours) {
				afficherPasAssez(boisson);
		} else {
			montantEnCours -= boisson.getPrix();
			afficherBoisson(boisson);
			boisson = null;
			afficherMontant();
			if (montantEnCours == 0)
				etatCourant =  idle;
			else
				etatCourant =  collecte;
		}
	}
	
	public void selectionnerBoisson(ToucheBoisson toucheBoisson) {
		if (etatCourant == pasAssez)
			throw new IllegalStateException();
		if (etatCourant == idle) {
			afficherPasAssez(toucheBoisson);
			return;			
		}
		if (toucheBoisson.getPrix() > montantEnCours) {
			boisson = toucheBoisson;
			afficherPasAssez(boisson);
			boisson = toucheBoisson;
			etatCourant =  pasAssez;
			return;
		}
		montantEnCours -= toucheBoisson.getPrix();
		afficherBoisson(toucheBoisson);
		afficherMontant();
		if (montantEnCours == 0)
			etatCourant = idle;
		else
			etatCourant = collecte;
	}
	
	public void rendreMonnaie() {
		if (etatCourant != idle) {
			afficherRetour();
			montantEnCours = 0;
			boisson = null;
		}
		etatCourant = idle;
	}

}</code></pre>
<pre><code>public class MainMachine {
	public static void main(String[] args) {
		MachineACafe mq = new MachineACafe();
		mq.selectionnerBoisson(ToucheBoisson.decaNoir);
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.selectionnerBoisson(ToucheBoisson.decaNoir);
		mq.entrerMonnaie(Piece.vingtCents);
		mq.selectionnerBoisson(ToucheBoisson.chocoAuLaitSucre);
		try {
			mq.selectionnerBoisson(ToucheBoisson.cafeNoir);
		} catch (IllegalStateException e) {
			System.out.println("Teet");
		}
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.rendreMonnaie();
	}

}</code></pre>
                            <p>Dans le diagramme d'état suivant prix est le prix de la boisson sélectionnée et montantEnCOurs, la quantité de monnaie introduite dans la machine.</p>
                            <p>Dans l'état collecte, quand on sélectionne une boisson et que le prix est inférieur au montantEnCours, la boisson est servie et le montantEnCours diminue. On peut alors éventuellement sélectionner une deuxième boisson.</p>
                            <p>On arrive à l'état pasAssez si on sélectionne une boisson dans l'état collecte et qu'il n'y a pas assez de monnaie dans la machine pour se payer cette boisson.</p>
                            <p>Dans l'état pasAssez, on ne peut pas sélectionner d'autre boisson. On doit ajouter de la monnaie jusqu'à atteindre le prix voulu. À ce moment, la boisson est servie par la machine. On peut aussi annuler la sélection, en demandant de rendre la monnaie.</p>
                            <img src="../images/exercice1_semaine4_design_patterns.png" alt="">
<pre><code>public class Piece {
	
	private String nom;
	private int valeur; // en cents
	
	public static final Piece vingtCents = new Piece("20 cents", 20);
	public static final Piece cinquanteCents = new Piece("50 cents", 50);
	public static final Piece unEuro = new Piece("1 Euro", 100);
	public static final Piece deuxEuros = new Piece("2 Euros", 200);
	
	private Piece(String nom, int valeur) {
		this.nom = nom;
		this.valeur = valeur;
	}

	public String getNom() {
		return nom;
	}

	public int getValeur() {
		return valeur;
	}

	@Override
	public String toString() {
		return nom;
	}
		
}</code></pre>
<pre><code>public class ToucheBoisson {
	private String type;
	private boolean auLait;
	private boolean sucre;
	private int prix; // en cents
	
	public static final ToucheBoisson cafeNoir = new ToucheBoisson("Café", false, false, 50);
	public static final ToucheBoisson cafeAuLait = new ToucheBoisson("Café", true, false, 70);
	public static final ToucheBoisson cafeNoirSucre = new ToucheBoisson("Café", false, true, 70);
	public static final ToucheBoisson cafeAuLaitSucre = new ToucheBoisson("Café", true, true, 90);
	
	public static final ToucheBoisson expresso = new ToucheBoisson("Expresso", false, false, 100);
	public static final ToucheBoisson expressoAuLait = new ToucheBoisson("Expresso", true, false, 120);
	public static final ToucheBoisson expressoSucre = new ToucheBoisson("Expresso", false, true, 120);
	public static final ToucheBoisson expressoAuLaitSucre = new ToucheBoisson("Expresso", true, true, 140);
	
	public static final ToucheBoisson decaNoir = new ToucheBoisson("Café décaféiné", false, false, 50);
	public static final ToucheBoisson decaAuLait = new ToucheBoisson("Café décaféiné", true, false, 70);
	public static final ToucheBoisson decaNoirSucre = new ToucheBoisson("Café décaféiné", false, true, 70);
	public static final ToucheBoisson decaAuLaitSucre = new ToucheBoisson("Café décaféiné", true, true, 90);
	
	public static final ToucheBoisson choco = new ToucheBoisson("Chocolat chaud", false, false, 70);
	public static final ToucheBoisson chocoAuLait = new ToucheBoisson("Chocolat chaud", true, false, 90);
	public static final ToucheBoisson chocoSucre = new ToucheBoisson("Chocolat chaud", false, true, 90);
	public static final ToucheBoisson chocoAuLaitSucre = new ToucheBoisson("Chocolat chaud", true, true, 110);

	public static final ToucheBoisson cappuccino = new ToucheBoisson("Cappuccino", false, false, 120);
	public static final ToucheBoisson viennois = new ToucheBoisson("Café Viennois", false, false, 120);
	public static final ToucheBoisson laitRusse = new ToucheBoisson("Lait russe", false, false, 100);
	public static final ToucheBoisson chocafe = new ToucheBoisson("Choco-Café", false, false, 120);
	
	public static final ToucheBoisson lait = new ToucheBoisson("Lait chaud", false, false, 70);
	public static final ToucheBoisson eau = new ToucheBoisson("Eau chaud", false, false, 0);
	
	
	private ToucheBoisson(String type, boolean lait, boolean sucre, int prix) {
		this.type = type;
		auLait = lait;
		sucre = sucre;
		this.prix = prix;
	}

	public String getType() {
		return type;
	}

	public boolean auLait() {
		return auLait;
	}

	public boolean estSucre() {
		return sucre;
	}

	public int getPrix() {
		return prix;
	}

	@Override
	public String toString() {
		return type + (auLait() ? " au lait" : "") + (estSucre() ? " sucré" : "");
	}
		
}</code></pre>
<pre><code>public class MachineACafe {

	private enum State {
		INACTIF {
			@Override
			public void entrerMonnaie(Piece piece, MachineACafe parent) {
				parent.etatCourant = State.COLLECTE;
			}

			@Override
			public void selectionnerBoisson(ToucheBoisson toucheBoisson, MachineACafe parent) {
				parent.afficherBoisson(toucheBoisson);
			}

			@Override
			public void rendreMonnaie(MachineACafe parent) {
			}
		},
		COLLECTE {
			@Override
			public void entrerMonnaie(Piece piece, MachineACafe parent) {
			}

			@Override
			public void selectionnerBoisson(ToucheBoisson toucheBoisson, MachineACafe parent) {
				if (toucheBoisson.getPrix() > parent.montantEnCours) {
					parent.boisson = toucheBoisson;
					parent.afficherPasAssez(parent.boisson);
					parent.boisson = toucheBoisson;
					parent.etatCourant = State.PASASSEZ;
					return;
				}
				parent.montantEnCours -= toucheBoisson.getPrix();
				parent.afficherBoisson(toucheBoisson);
				parent.afficherMontant();
				if (parent.montantEnCours == 0) {
					parent.etatCourant = State.INACTIF;
				} else {
					parent.etatCourant = State.COLLECTE;
				}

			}

		},
		PASASSEZ {
			@Override
			public void entrerMonnaie(Piece piece, MachineACafe parent) {
				if (parent.boisson.getPrix() > parent.montantEnCours) {
					parent.afficherPasAssez(parent.boisson);
				} else {
					parent.montantEnCours -= parent.boisson.getPrix();
					parent.afficherBoisson(parent.boisson);
					parent.boisson = null;
					parent.afficherMontant();
					if (parent.montantEnCours == 0) {
						parent.etatCourant = State.INACTIF;
					} else {
						parent.etatCourant = State.COLLECTE;
					}
				}
			}

			@Override
			public void selectionnerBoisson(ToucheBoisson toucheBoisson, MachineACafe parent) {
				throw new IllegalStateException();
			}

		};
		public abstract void entrerMonnaie(Piece piece, MachineACafe parent);

		public abstract void selectionnerBoisson(ToucheBoisson toucheBoisson, MachineACafe parent);

		public void rendreMonnaie(MachineACafe parent) {
			parent.afficherRetour();
			parent.montantEnCours = 0;
			parent.boisson = null;
			parent.etatCourant = State.INACTIF;
		}
	}

	private int montantEnCours = 0;
	private State etatCourant = State.INACTIF;
	private ToucheBoisson boisson = null;

	public void afficherMontant() {
		System.out.println(montantEnCours + " cents disponibles");
	}

	public void afficherRetour() {
		System.out.println(montantEnCours + " cents rendus");
	}

	public void afficherPasAssez(ToucheBoisson toucheBoisson) {
		System.out.println("Vous n'avez pas introduit un montant suffisant pour un " + toucheBoisson);
		System.out.println("Il manque encore " + (toucheBoisson.getPrix() - montantEnCours) + " cents");
	}

	public void afficherBoisson(ToucheBoisson toucheBoisson) {
		System.out.println("Voici un " + toucheBoisson);

	}

	public void entrerMonnaie(Piece piece) {
		montantEnCours += piece.getValeur();
		afficherMontant();
		etatCourant.entrerMonnaie(piece, this);
	}

	public void selectionnerBoisson(ToucheBoisson toucheBoisson) {
		etatCourant.selectionnerBoisson(toucheBoisson, this);
	}

	public void rendreMonnaie() {
		etatCourant.rendreMonnaie(this);
	}

}</code></pre>
<pre><code>public class MainMachine {
	
	public static void main(String[] args) {
		MachineACafe mq = new MachineACafe();
		mq.selectionnerBoisson(ToucheBoisson.decaNoir);
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.selectionnerBoisson(ToucheBoisson.decaNoir);
		mq.entrerMonnaie(Piece.vingtCents);
		mq.selectionnerBoisson(ToucheBoisson.chocoAuLaitSucre);
		try {
			mq.selectionnerBoisson(ToucheBoisson.cafeNoir);
		} catch (IllegalStateException e) {
			System.out.println("Teet");
		}
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.entrerMonnaie(Piece.cinquanteCents);
		mq.rendreMonnaie();
	}

}</code></pre>
                        </li>
                        <li>
                            <h3>Semaine 5 :</h3>
                            <p>L'IPL fait appel à vos services pour développer une application de streaming annexe à ecampus : SpotIPLy. Dans un premier temps, on ne désire implémenter qu'une classe Album qui garde le plus d'information possible sur les albums disponibles en écoute. Seuls le titre de l'albul et le nom de l'artiste sont obligatoires. Les autres renseignements proposés sont le label de la marque de disque, le producteur, le pays de l'artiste, la version (ex. DeLuxe Edition, Japonese Edition, ...), le genre, l'année de parution et, s'il s'agit d'un album remastérisé, l'année de parution originale, le débit en qualité standard et le débit en mode abonné.</p>
                            <p>Comme on le voit, plusieurs solutions s'offrent à nous pour créer un album :</p>
                            <ol type="a">
                                <li>
                                    <p>Définir un unique constructeur qui accepte des valeurs null pour tous les champs sauf le titre et l'artiste : désavantage : il faut préciser des valeurs pour tous les autres champs, ne fut-ce que null.</p>
                                </li>
                                <li>
                                    <p>Définir une série de constructeur "téléscopiques" en classant les champs dans l'ordre décroissant de fréquence d'utilisation :</p>
<pre><code>Album(String titre, String artiste);
Album(String titre, String artiste, int annee);
Album(String titre, String artiste, int annee, String genre);</code></pre>
                                    <p>Il est en effet difficile de définir des constructeurs différents ayant le même nombre de paramètre vu que les types de ceux-ci sont trop souvent les mêmes.</p>
                                    <ul>
                                        <li>
                                            <p>Désavantages : similaire à la solution précédente. On doit bien souvent préciser la valeur de champs qu'on ne veut pas initialiser.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Utiliser le pattern JavaBeans : un constructeur sans paramètre et des getters et setteurs pour les autres champs.</p>
                                    <ul>
                                        <li>
                                            <p>Désavantages : il ne permet pas l'immuabilité (pas de champs final par exemple).</p>
                                        </li>
                                    </ul>
                                    <p>De plus la construction se fait en différents appels. L'objet constuit peut donc être dans un état inconsistant à un moment donné.</p>
                                </li>
                            </ol>
                            <p>Le problème est lié au langage qui, contrairement à d'autres (Ada, Python) ne permet pas (encore) de définir des paramètres nommés optionnels.</p>
                            <p>Dans un tel cas, la bonne manière de faire est de définir une classe <span class="html">public static Builder</span> interne à la classe à construire (ici <span class="em">Album</span>).</p>
                            <ol>
                                <li>
                                    <p>La classe <span class="em">Album</span> a :</p>
                                    <ul>
                                        <li>
                                            <p>un seul constructeur <span class="em">private</span> prenant un <span class="em">Builder</span> en paramètre, tous ses champs final.</p>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <p>Cette classe <span class="em">Builder</span> a :</p>
                                    <ul>
                                        <li>
                                            <p>les mêmes champs que la classe qu'elle doit construire (ici <span class="em">Album</span>).</p>
                                        </li>
                                        <li>
                                            <p>un constructeur reprenant uniquement les champs obligatoires,</p>
                                        </li>
                                        <li>
                                            <p>des méthodes (sorte de setters) portant le nom des autres champs mais qui renvoient le builder,</p>
                                        </li>
                                        <li>
                                            <p>une méthode <span class="html">public build()</span> qui appelle le constructeur <span class="em">private</span> d'<span class="em">Album</span>.</p>
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                            <p>Un album est donc construit par exemple comme suit :</p>
<pre><code>Album lonerism = new Album.Builder("Lonerism", "Tame Impala").pays("Australie").annee(2012).genre("indie rock").build();
Album orange = new Album.Builder("channel ORANGE", "Frank Ocean").annee(2012).genre("R&B").build();
Album visions = new Album.Builder("Visions", "Grimes").annee(2 012).label("4AD").genre("Electronic").build();</code></pre>
<pre><code>public class Album {

    private final String titreAlbum;
	private final String nomArtiste;
	private final String labelMarqueDisque;
	private final String producteur;
	private final String paysArtiste;
	private final String version;
	private final String genre;
	private final int anneeParution;
	private final boolean remasterise;
	private final int anneeParutionOriginale;
	private final int debitStandard;
	private final int debitAbonne;

	private Album(AlbumBuilder builder) {
		this.titreAlbum = builder.titreAlbum;
		this.nomArtiste = builder.nomArtiste;
		this.labelMarqueDisque = builder.labelMarqueDisque;
		this.producteur = builder.producteur;
		this.paysArtiste = builder.paysArtiste;
		this.version = builder.version;
		this.genre = builder.genre;
		this.anneeParution = builder.anneeParution;
		this.remasterise = builder.remasterise;
		this.anneeParutionOriginale = builder.anneeParutionOriginale;
		this.debitStandard = builder.debitStandard;
		this.debitAbonne = builder.debitAbonne;
	}
	
	public String getTitreAlbum() {
		return titreAlbum;
	}

	public String getNomArtiste() {
		return nomArtiste;
	}

	public String getLabelMarqueDisque() {
		return labelMarqueDisque;
	}

	public String getProducteur() {
		return producteur;
	}

	public String getPaysArtiste() {
		return paysArtiste;
	}

	public String getVersion() {
		return version;
	}

	public String getGenre() {
		return genre;
	}

	public int getAnneeParution() {
		return anneeParution;
	}

	public boolean isRemasterise() {
		return remasterise;
	}

	public int getAnneeParutionOriginale() {
		return anneeParutionOriginale;
	}
	
	public int getDebitStandard() {
		return debitStandard;
	}
	
	public int getDebitAbonne() {
		return debitAbonne;
	}

	public static class AlbumBuilder {
		private final String titreAlbum;
		private final String nomArtiste;
		private String labelMarqueDisque;
		private String producteur;
		private String paysArtiste;
		private String version;
		private String genre;
		private int anneeParution;
		private boolean remasterise;
		private int anneeParutionOriginale;
		private int debitStandard;
		private int debitAbonne;

		public AlbumBuilder(String titreAlbum, String nomArtiste) {
			this.titreAlbum = titreAlbum;
			this.nomArtiste = nomArtiste;
		}

		public AlbumBuilder labelMarqueDisque(String labelMarqueDisque) {
			this.labelMarqueDisque = labelMarqueDisque;
			return this;
		}

		public AlbumBuilder producteur(String producteur) {
			this.producteur = producteur;
			return this;
		}

		public AlbumBuilder paysArtiste(String paysArtiste) {
			this.paysArtiste = paysArtiste;
			return this;
		}

		public AlbumBuilder version(String version) {
			this.version = version;
			return this;
		}
		
		public AlbumBuilder genre(String genre) {
			this.genre = genre;
			return this;
		}
		
		public AlbumBuilder anneeParution(int anneeParution) {
			this.anneeParution = anneeParution;
			return this;
		}
		
		public AlbumBuilder remasterise(boolean remasterise) {
			this.remasterise = remasterise;
			return this;
		}
		
		public AlbumBuilder anneeParutionOriginale(int anneeParutionOriginale) {
			this.anneeParutionOriginale = anneeParutionOriginale;
			return this;
		}
		
		public AlbumBuilder debitStandard(int debitStandard) {
			this.debitStandard = debitStandard;
			return this;
		}
		
		public AlbumBuilder debitAbonne(int debitAbonne) {
			this.debitAbonne = debitAbonne;
			return this;
		}
		
		public Album build() {
			return new Album(this);
		}
	}

}</code></pre>
<pre><code>public class Main {

	public static void main(String[] args) {
		Album lonerism = new Album.AlbumBuilder("Lonerism", "Tame Impala").paysArtiste("Australie").anneeParution(2012).genre("indie rock").build(); 
		Album orange = new Album.AlbumBuilder("channel ORANGE", "Frank Ocean").anneeParution(2012).genre("R&B").build();
		Album visions = new Album.AlbumBuilder("Visions", "Grimes").anneeParution(2012).labelMarqueDisque("4AD").genre("Electronic").build();
		System.out.println(orange.getTitreAlbum());
	}
	
}</code></pre>
                        </li>
                        <li>
                            <h3>Semaine 6 :</h3>
                            <p>Une autre fonction de notre machine à café est la sélection de la boisson. La technique consiste à choisir une boisson de base (Moka, Dessert ou Décaféiné) et d'y ajouter éventuellement du lait, du sucre et/ou de la crème fraîche. Un programme utilisant cette sélection pourra être :</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Boisson b = new Lait(new Sucre(new Decafeine()));
        System.out.println(b + " au prix de " + b.prix() + " euros.");
        b = new Sucre(new Creme(new Dessert()));
        System.out.println(b + " au prix de " + b.prix() + " euros.");
    }
}</code></pre>
                            <p>Ce programme donnera en sortie :</p>
<pre><code>Café décaféiné sucré au lait au prix de 0.55 euros.
Café dessert crème sucré au prix de 0.57 euros.</code></pre>
                            <p>Les classes sont implémentées comme suit :</p>
                            <p>Boisson.java :</p>
<pre><code>public interface Boisson {
    String getNom();
    double prix();
}</code></pre>
                            <p>Cafe.java :</p>
<pre><code>public abstract class Cafe implements Boisson {
    private String nom;
    public Cafe(String nom) {
        this.nom = nom;
    }
    public String getNom() {
        return nom;
    }
    public abstract double prix();
    public String toString() {
        return "Café " + getNom();
    }
}</code></pre>
                            <p>Dessert.java :</p>
<pre><code>public class Dessert extends Cafe {
    public Dessert() {
        super("dessert");
    }
    public double prix() {
        return 0.37;
    }
}</code></pre>
                            <p>Moka.java :</p>
<pre><code>public class Moka extends Cafe {
    public Moka() {
        super("moka");
    }
    public double prix() {
        return 0.35;
    }
}</code></pre>
                            <p>Decafeine.java :</p>
<pre><code>public class Decafeine extends Cafe {
    public Decafeine() {
        super("décaféiné");
    }
    public double prix() {
        return 0.40;
    }
}</code></pre>
                            <p>Additif.java :</p>
<pre><code>public abstract class Additif implements Boisson {
    private Boisson boisson;
    public Additif(Boisson boisson) {
        if (boisson == null) throw new IllegalArgumentException();
        this.boisson = boisson;
    }
    public String getNom() {
        return boisson.getNom();
    }
    public double prix() {
        return boisson.prix();
    }
    public String toString() {
        return boisson.toString();
    }
}</code></pre>
                            <p>Creme.java :</p>
<pre><code>public class Creme extends Additif {
    public Creme(Boisson boisson) {
        super(boisson);
    }
    public double prix() {
        return 0.15 + super.prix();
    }
    public String toString() {
        return super.toString() + " crème";
    }
}</code></pre>
                        <p>Lait.java :</p>
<pre><code>public class Lait extends Additif {
    public Lait(Boisson boisson) {
        super(boisson);
    }
    public double prix() {
        return 0.10 + super.prix();
    }
    public String toString() {
        return super.toString() + " au lait";
    }
}</code></pre>
                        <p>Sucre.java :</p>
<pre><code>public class Sucre extends Additif {
    public Sucre(Boisson boisson) {
        super(boisson);
    }
    public double prix() {
        return 0.05 + super.prix();
    }
    public String toString() {
        return super.toString() + " sucré";
    }
}</code></pre>
                        </li>
                        <li>
                            <h3>Semaine 7 :</h3>
                            <p>Une structure de liste pouvant contenir des sous-listes peut être représentée sous forme parenthésée mais aussi sous forme d'arbre général. Par exemple la liste :</p>
<pre><code>( 1 2 ( 6 ( 13 14 15 ) 7 8 ) 3 4 5 ( 9 10 11 ( 16 17 ( 20 ) 18 ) 12 ( 19 )))</code></pre>
                            <p>correspond à l'arbre :</p>
                            <img src="../images/exercice6B_design_patterns_1.png" alt="">
                            <p>Le programme suivant construit l'arbre à partir de la chaîne située dans le fichier question.txt. Ensuite il demande différents traitements sur cet arbre : d'abord reconstruire la chaîne de départ à partir de l'arbre ensuite calculer certaines statistiques : nombre de valeurs, nombre de groupe de parenthèses, somme des valeurs et moyenne de celles-ci. Enfin, il affiche le contenu de chaque groupe. La sortie est la suivante :</p>
<pre><code>( 1 2 ( 6 ( 13 14 15 ) 7 8 ) 3 4 5 ( 9 10 11 ( 16 17 ( 20 ) 18 ) 12 ( 19 ) ) )
nombre de valeurs : 20
nombre de groupes : 7
somme des valeurs : 210
moyenne des valeurs : 10.5</code></pre>
                            <img src="../images/exercice6B_design_patterns_2.png" alt="">
                            <p>Voici le code complet de ce programme. Pour chacun d'eux, indiquez son nom et faites un tableau de correspondance entre les noms des participants théoriques (tels que vu au cours) et les noms des classes dans le code donné. Si le cours théorique propose des noms pour certaines méthodes, indiquez également la correspondance à ce niveau, en indiquant le nom théorique de la méthode et, en regard, le nom employé ici.</p>
                            <p>Partie.java :</p>
<pre><code>public interface Partie {
    void demande(Traitement traitement);
    int getNiveau();
}</code></pre>
                            <p>Valeur.java :</p>
<pre><code>public class Valeur implements Partie {
    private int nombre;
    private int niveau = 0;
    public Valeur(int nombre, int niveau) {
        this.nombre = nombre;
        this.niveau = niveau;
    }
    public void demande(Traitement traitement) {
        traitement.traiteValeur(this);
    }
    public int getValeur() {
        return nombre;
    }
    public int getNiveau() {
        return niveau;
    }
}</code></pre>
                            <p>Groupe.java :</p>
<pre><code>import java.util.Collections;
import java.util.Iterator;
import java.util.Vector;

public class Groupe implements Partie {
    private static int dernier = 0;
    private Vector parties = new Vector();
    private int niveau;
    private String nom;
    private int numero;
    public Groupe(String nom, int niveau) {
        this.nom = nom;
        this.niveau = niveau;
        numero = dernier++;
    }
    public void add(Partie nouveau) {
        parties.add(nouveau);
    }
    public Iterator getParties() {
        return Collections.unmodifiableList(parties).iterator();
    }
    public int getNiveau() {
        return niveau;
    }
    public String getNom() {
        return nom;
    }
    public int getNumero() {
        return numero;
    }
    public void demande(Traitement traitement) {
        traitement.traiteGroupe(this);
    }
}</code></pre>
                            <p>Fabriquant.java :</p>
<pre><code>public class Fabriquant {
    private Pile pile = new PileImpl();
    private Partie resultat;
    private int niveau = 0;
    char c = 'a';
    public void construireGroupe() {
        if (!pile.estVide()) {
            Groupe sommet = (Groupe) pile.pop();
            Groupe nouveau = new Groupe(String.valueOf(c++), ++niveau);
            sommet.add(nouveau);
            pile.push(sommet);
            pile.push(nouveau);
        } else {
            Groupe nouveau = new Groupe(String.valueOf(c++), 0);
            pile.push(nouveau);
            if (resultat == null) {
                resultat = nouveau;
            } else {
                throw new RuntimeException(); // fichier malformé
            }
        }
    }
    public void fermerGroupe() {
        pile.pop(); niveau--;
    }
    public void construireValeur(int nombre) {
        Valeur number = new Valeur(nombre, niveau + 1);
        if (!pule.estVide()) {
            Groupe sommet = (Groupe) pile.pop();
            sommet.add(number);
            pile.push(sommet);
        } else resultat = number;
    }
    public Partie getResultat() {
        return resultat;
    }
}</code></pre>
                            <p>Lecteur.java :</p>
<pre><code>import java.io.*;

public class Lecteur {
    private PushbackReader buffer;
    private Fabriquant fabriquant = new Fabriquant();

    public Lecteur(String fichier) throws FileNotFoundException {
        buffer = new PushbackReader(new BufferedReader(new FileReader(fichier)));
    }
    public Partie construire() throws IOException {
        int car;
        while ((car = buffer.read()) != -1) {
            if (car == '(') {
                fabriquant.construireGroupe();
            } else if (car == ')') {
                fabriquant.fermerGroupe();
            } else if (Character.isDigit((char) car)) {
                int nombre = 0;
                do {
                    nombre *= 10;
                    nombre += Character.digit((char) car, 10);
                    if ((car = buffer.read()) == -1) break;
                } while(Character.isDigit((char) car));
                if (car != -1) buffer.unread(car);
                fabriquant.construireValeur(nombre);
            }
        }
        return fabriquant.getResultat();
    }
}</code></pre>
                            <p>Traitement.java :</p>
<pre><code>public interface Traitement {
    void traiteValeur(Valeur unique);
    void traiteGroupe(Groupe plusieurs);
}</code></pre>
                            <p>Listeur.java :</p>
<pre><code>import java.util.Iterator;

public class Listeur implements Traitement {
    public void traiteValeur(Valeur valeur) {
        System.out.print(valeur.getValeur + " ");
    }
    public void traiteGroupe(Groupe groupe) {
        System.out.print("( ");
        Iterator it = groupe.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next(); p.demande(this);
        }
        System.out.print(") ");
    }
}</code></pre>
                            <p>Totaliseur.java :</p>
<pre><code>import java.util.Iterator;
public class Totaliseur implements Traitement {
    private int nombreDeValeurs = 0;
    private int nombreDeGroupes = 0;
    private int sommeDesValeurs = 0;
    public void traiteValeur(Valeur valeur) {
        nombreDeValeurs++;
        sommeDesValeurs += valeur.getValeur();
    }
    public void traiteGroupe(Groupe groupe) {
        nombreDeGroupes++;
        Iterator it = groupes.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next();
            p.demande(this);
        }
    }
    public int getNombreDeGroupes() {
        return nombreDeGroupes;
    }
    public int getNombreDeValeurs() {
        return nombreDeValeurs;
    }
    public int getSommeDesValeurs() {
        return sommeDesValeurs;
    }
}</code></pre>
                            <p>ListeurNom.java :</p>
<pre><code>import java.util.Iterator;
import java.util.Vector;

public class ListeurNom implements Traitement {
    private Vector lesNoms = new Vector();
    private int enCours = -1;
    public void traiteValeur(Valeur valeur) {
        String val = valeur.getValeur() + " ";
        if (enCours == -1) {
            lesNoms.add(val);
        } else {
            String s = (String) lesNoms.get(enCours);
            lesNoms.set(enCours, s + val);
        }
    }
    public void traiteGroupe(Groupe groupe) {
        if (enCours != -1) {
            String s = (String) lesNoms.get(enCours);
            lesNoms.set(enCours, s + groupe.getNom() + " ");
        }
        int exEnCours = enCours;
        enCours = groupe.getNumero();
        lesNoms.setSize(enCours + 1);
        lesNoms.set(enCours, groupe.getNom() + ": ");
        Iterator it = groupe.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next();
            p.demande(this);
        }
        enCours = exEnCours;
    }
    public Iterator getLesNoms() {
        return lesNoms.iterator();
    }
}</code></pre>
                            <p>Pile.java :</p>
<pre><code>public interface Pile {
    boolean estVide();
    void push(Object n);
    Object pop();
    Object sommet();
    int taille();
    String toString();
}</code></pre>
                            <p>PileImpl.java :</p>
<pre><code>public class PileImpl implements Pile {
    private NoeudPile tete;
    private int taille;
    public PileImpl() {
        this.tete = null;
    }
    public void push(Object element) {
        this.tete = new NoeudPile(element, tete);
        this.taille++;
    }
    public Object pop() {
        Object resultat = sommet();
        this.tete = this.tete.getSuivant();
        this.taille--;
        return resultat;
    }
    public Object sommet() {
        return this.tete.getElement();
    }
    public boolean estVide() {
        return this.tete == null;
    }
    public int taille() {
        return this.taille;
    }
    public String toString() {
        NoeudPile courant = this.tete;
        String resultat = "";
        while (courant != null) {
            resultat += courant.getElement() + " ";
            courant = courant.getSuivant();
        }
        return resultat;
    }
    class NoeudPile {
        private Object element;
        private NoeudPile suivant;
        public NoeudPile(Object element) {
            this(element, null);
        }
        public NoeudPile(Object element, NoeudPile suivant) {
            setElement(element);
            setSuivant(suivant);
        }
        public void setElement(Object elem) {
            this.element = elem;
        }
        public void setSuivant(NoeudPile suiv) {
            this.suivant = suiv;
        }
        public Object getElement() {
            return this.element;
        }
        public NoeudPile getSuivant() {
            return this.suivant;
        }
    }
}</code></pre>
                            <p>Donnons enfin un exemple de programme principal illustrant l'usage de ces classes :</p>
                            <p>Main.java :</p>
<pre><code>import java.io.IOException;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) throws IOException {
        Lecteur lecteur = new Lecteur("question.txt");
        Partie partie = lecteur.construire();
        Listeur listeur = new Listeur();
        Totaliseur total = new Totaliserur();
        partie.demande(listeur);
        System.out.println();
        System.out.println();
        partie.demande(total);
        System.out.println("nombre de valeurs : " + total.getNombreDeValeurs());
        System.out.println("nombre de groupes : " + total.getNombreDeGroupes());
        System.out.println("somme des valeurs : " + total.getSommeDesValeurs());
        System.out.println("moyenne des valeurs : "+ total.getSommeDesValeurs() / (double) total.getNombreDeValeurs());
        System.out.println();
        ListeurNom listeurNom = new ListeurNom();
        partie.demande(listeurNom);
        Iterator iterateur = listeurNom.getLesNoms();
        while (iterateur.hasNext()) {
            String s = (String) iterateur.next();
            System.out.println();
        }
        System.out.println();
    }
}</code></pre>
                        </li>
                        <li>
                            <h3>Semaine 8 :</h3>
                            <p>Le code suivant a été développé en implémentant expressément cinq patterns. Attention, implémenter n'est pas la même chose qu'utiliser un pattern déjà existant en Java. Quels sont ces cinq patterns ? Indiquer la correspondance entre la théorie et le code fourni. Il peut être utile de dessiner un diagramme de classe simplifié (sans attributs si méthodes).</p>
                            <p>ConstantesJeu.java :</p>
<pre><code>package vie;

public interface ConstantesJeu {
    int NBR_LIGNES = 40; // Nombre de lignes de cellules dans le jeu
    int NBR_COLONNES = 40; // Nombre de colonnes dans le jeu
    int PAD_EN_LARGEUR = 50; // Largeur en pixels du pad autour du jeu
    int PAD_EN_HAUTEUR = 100; // Hauteur en pixels du pad autour du jeu
    int LARGEUR_GRILLE = 400; // Largeur en pixels de la grille
    int HAUTEUR_GRILLE = 400; // Hauteur en pixels de la grille
}</code></pre>
                            <p>JeuDeLaVieGUI.java :</p>
<pre><code>package vie;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class JeuDeLaVieGUI extends JFrame implements ConstantesJeu, Espion {
    
    private final static Color COULEUR_VIVANT_PAR_DEFAUT = Color.RED;
    private final static Color COULEUR_MORT_PAR_DEFAUT = Color.BLACK;
    private JeuDeLaVie jeu;
    private JeuDeLaViePanel vue;
    private JPanel contentPane;
    private JButton boutonAvance;

    public JeuDeLaVieGUI(String titre, JeuDeLaVie jeu) {
        this(titre, jeu, COULEUR_VIVANT_PAR_DEFAUT, COULEUR_MORT_PAR_DEFAUT);
    }

    public JeuDeLaVieGUI(String titre, JeuDeLaVie jeu, Color couleurVie, Color couleurMort) {
        super(titre);
        this.jeu = jeu;
        vue = new JeuDeLaViePanel(jeu, couleurVie, couleurMort);
        boutonAvance = new JButton("Avance");
        contentPane = new JPanel();
        jeu.attacher(this);
        initialiser();
    }

    // Construit le GUI et permet au bouton "Avance" de passer à la
    // génération suivante.
    private void initialiser() {
        this.setSize(vue.getWidth() + PAD_EN_LARGEUR, vue.getHeight() + PAD_EN_HAUTEUR);
        contentPane.setLayout(new FlowLayout());
        contentPane.add(vue);
        contentPane.add(boutonAvance);
        this.setContentPane(contentPane);
        this.setVisible(true);
        boutonAvance.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                jeu.avancer();
            }
        });
        this.setDefaultCloseOperation(DISPOSE_ON_CLOSE);
    }

    // Redessine pour afficher les changements.
    public void utiliserRenseignements() {
        repaint();
    }
}</code></pre>
                            <p>JeuDeLaViePanel.java :</p>
<pre><code>package vie;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.BorderFactory;
import javax.swing.JPanel;

public class JeuDeLaViePanel extends JPanel implements ConstantesJeu {
	
	private JeuDeLaVie jeu;
	private int hauteurCellule;
	private int largeurCellule;
	private Color couleurVie;
	private Color couleurMort;

	public JeuDeLaViePanel(JeuDeLaVie jeu, Color couleurVie, Color couleurMort) {
		this.jeu = jeu;
		this.largeurCellule = LARGEUR_GRILLE / jeu.getColonnes();
		this.hauteurCellule = HAUTEUR_GRILLE / jeu.getLignes();
		this.couleurVie = couleurVie;
		this.couleurMort = couleurMort;
		initialiser();
	}

	private void initialiser() {
		this.setSize(LARGEUR_GRILLE, HAUTEUR_GRILLE);
		this.setPreferredSize(this.getSize());
		this.setBackground(couleurMort);
		this.setBorder(BorderFactory.createLineBorder(Color.black));
		// Ajouter un listener sur la souris afin de mettre
		// la cellule où se trouve la souris on ou off.
		this.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				jeu.toggle(e.getPoint().y / hauteurCellule, e.getPoint().x / largeurCellule);
			}
		});
	}

	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		dessinerGrille(g);
		dessineVie(g);
	}

	// Dessine les lignes de la grille.
	private void dessinerGrille(Graphics g) {
		g.setColor(couleurVie);
		for (int i = 0; i &lt;= jeu.getLignes(); i++) {
			g.drawLine(0, i * hauteurCellule, LARGEUR_GRILLE, i * hauteurCellule);
		}
		for (int i = 0; i &lt;= jeu.getColonnes(); i++) {
			g.drawLine(i * largeurCellule, 0, i * largeurCellule, HAUTEUR_GRILLE);
		}
	}

	// Dessine toutes les cellules en vie.
	private void dessineVie(Graphics g) {
		g.setColor(couleurVie);
		for (int i = 0; i &lt; jeu.getLignes(); i++) {
			for (int j = 0; j &lt; jeu.getColonnes(); j++) {
				if (jeu.estVivante(i, j)) {
					g.fillRect(j * largeurCellule, i * hauteurCellule, largeurCellule, hauteurCellule);
				}
			}
		}
	}
}</code></pre>
                            <p>Espion.java :</p>
<pre><code>package vie;
public interface Espion {
    void utiliserRenseignements();
}</code></pre>
                            <p>JeuDeLaVie.java :</p>
<pre><code>package vie;
    
import java.util.*;

/** Cette classe implémente le jeu de la vie */
public class JeuDeLaVie {
    private int lignes;
    private int colonnes;
    private Cellule grille[][];
    private List&lt;Espion&gt; espions;
    private Parcourir parcourt;

    public JeuDeLaVie(int lignes, int colonnes, Parcourir parcourt) {
        this.lignes = lignes;
        this.colonnes = colonnes;
        this.parcourt = parcourt;
        grille = new Cellule[lignes][colonnes];
        espions = new ArrayList&lt;Espion&gt;();
        for (int i = 0; i &lt; lignes; i++) {
            for (int j = 0; j &lt; colonnes; j++) {
                grille[i][j] = new Cellule(i, j);
            }
        }
    }

    protected void effacerGrille(Cellule[][] g) {
        for (int i = 0; i &lt; lignes; i++) {
            for (int j = 0; j &lt; colonnes; j++) {
                g[i][j] = new Cellule(i, j);
            }
        }
    }

    public int getLignes() {
        return lignes;
    }

    public int getColonnes() {
        return colonnes;
    }

    public boolean estVivante(int li, int co) {
        return grille[li][co].estVivante();
    }

    public Cellule cellulleEn(int li, int co) {
        return grille[li][co];
    }

    // Inverse le statut de la cellule de position li,co
    public void toggle(int li, int co) {
        grille[li][co].toggle();
        prevenirEspions();
    }

    // Cette méthode implemente les règles du Jeu de la Vie.
    // Pour chaque cellule,
    // on trouve le nombre de voisins et on rend la cellule vivante selon
    // les r§gles définies dans le parcourt
    public void avancer() {
        ArrayListélt;Activite&gt; activites = new ArrayList&lt;Activite&gt;();
        for (int i = 0; i &lt; lignes; i++)
            for (int j = 0; j &lt; colonnes; j++)
                grille[i][j].generer(this, activites, parcourt);
        for (Activite activite : activites)
            activite.activer();
        prevenirEspions();
    }

    // Ajoute un espion.
    public void attacher(Espion espion) {
        if (espion == null)
            return;
        this.espions.add(espion);
    }

    // Supprime un espion.
    public void detacher(Espion espion) {
        this.espions.remove(espion);
    }

    // Informe tous les espions de tenir compte des renseignements obtenus.
    public void prevenirEspions() {
        for (Espion espion : espions)
            espion.utiliserRenseignements();
    }
}</code></pre>
                            <p>Cellule.java :</p>
<pre><code>package vie;

import java.util.*;

public class Cellule {
    private int ligne;
    private int colonne;
    private Situation situation;

    public Cellule(int ligne, int colonne) {
        this.ligne = ligne;
        this.colonne = colonne;
        this.situation = EstMorte.getInstance();
    }

    public void vit() {
        situation = situation.vit();
    }

    public void meurt() {
        situation = situation.meurt();
    }

    public boolean estVivante() {
        return situation.estVivante();
    }

    public void toggle() {
        situation = situation.toggle();
    }

    public void ajouterAuxVoisinsVivants(List&lt;Situation&gt; voisinsVivants) {
        situation.ajouterAuxVoisinsVivants(voisinsVivants);
    }

    // Compte le nombre de voisins vivants de cette cellule ci dans le jeu
    public int nombreDeVoisins(JeuDeLaVie jeu) {
        int x = 0;
        int y = ligne - 1;
        List&lt;Situation&gt; voisinsVivants = new ArrayList&lt;Situation&gt;();
        if (y &lt; 0) {
            y = jeu.getLignes() - 1;
        }
        for (int liCpt = 1; liCpt &lt;= 3; liCpt++) {
            x = colonne - 1;
            if (x &lt; 0) {
                x = jeu.getColonnes() - 1;
            }
            for (int coCpt = 1; coCpt &lt;= 3; coCpt++) {
                if (x != colonne || y != ligne) {
                    jeu.cellulleEn(y, x).ajouterAuxVoisinsVivants(voisinsVivants);
                }
                x = (x + 1) % jeu.getColonnes();
            }
            y = (y + 1) % jeu.getLignes();
        }
        return voisinsVivants.size();
    }

    public void generer(JeuDeLaVie jeu, List&lt;Activite&gt; activites, Parcourir parcourt) {
        situation.generer(this, jeu, activites, parcourt);
    }
}</code></pre>
                            <p>Situation.java :</p>
<pre><code>package vie;
    
import java.util.List;

public abstract class Situation {
    public abstract Situation vit();

    public abstract Situation meurt();

    public abstract Situation toggle();

    public abstract boolean estVivante();

    public abstract void ajouterAuxVoisinsVivants(List<Situation> voisinsVivants);

    public abstract void generer(Cellule cellule, JeuDeLaVie jeu, List<Activite> activites, Parcourir visiteur);
}</code></pre>
                            <p>EstVivante.java :</p>
<pre><code>package vie;

import java.util.List;

public class EstVivante extends Situation {
    private static EstVivante instance = null;

    private EstVivante() {
    }

    public static EstVivante getInstance() {
        if (instance == null)
            instance = new EstVivante();
        return instance;
    }

    public Situation vit() {
        return this;
    }

    public Situation meurt() {
        return EstMorte.getInstance();
    }

    public boolean estVivante() {
        return true;
    }

    public Situation toggle() {
        return meurt();
    }

    public void ajouterAuxVoisinsVivants(List&lt;Situation&gt; voisinsVivants) {
        voisinsVivants.add(this);
    }

    public void generer(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites, Parcourir parcourt) {
        parcourt.parcourtCelluleVivante(cellule, jeu, activites);
    }
}</code></pre>
                            <p>EstMorte.java :</p>
<pre><code>package vie;

import java.util.List;

public class EstMorte extends Situation {
    private static EstMorte instance = null;

    private EstMorte() {
    }

    public static EstMorte getInstance() {
        if (instance == null)
            instance = new EstMorte();
        return instance;
    }

    public Situation vit() {
        return EstVivante.getInstance();
    }

    public Situation meurt() {
        return this;
    }

    public boolean estVivante() {
        return false;
    }

    public Situation toggle() {
        return vit();
    }

    public void ajouterAuxVoisinsVivants(List&lt;Situation&gt; voisinsVivants) { // ne pas s'ajouter : on est mort
    }

    public void generer(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites, Parcourir parcourt) {
        parcourt.parcourtCelluleMorte(cellule, jeu, activites);
    }
}</code></pre>
                            <p>Activite.java :</p>
<pre><code>package vie;

public abstract class Activite {
    private Cellule cellule;

    public Activite(Cellule cellule) {
        this.cellule = cellule;
    }

    // Envoyer la requête sauvée (vit ou meurt) à la cellule.
    public abstract void activer();

    public Cellule getCellule() {
        return cellule;
    }
}</code></pre>
                            <p>Vit.java :</p>
<pre><code>package vie;

public class Vit extends Activite {
    public Vit(Cellule cellule) {
        super(cellule);
    }

    public void activer() {
        getCellule().vit();
    }
}</code></pre>
                            <p>Meurt.java :</p>
<pre><code>package vie;

public class Meurt extends Activite {
    public Meurt(Cellule cellule) {
        super(cellule);
    }

    public void activer() {
        getCellule().meurt();
    }
}</code></pre>
                            <p>Parcourir.java :</p>
<pre><code>package vie;

import java.util.*;

public abstract class Parcourir {
    public abstract void parcourtCelluleVivante(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites);

    public abstract void parcourtCelluleMorte(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites);
}</code></pre>
                            <p>ParcourtNormal.java :</p>
<pre><code>package seance6;

import java.util.List;

public class ParcourtNormal extends Parcourir {
    // Une cellule devient vivante si :
    // soit elle était vivante et a 2 ou 3 voisins vivants // soit elle était morte
    // et a exactement 3
    // voisins vivants.
    // Dans les autres cas la cellule meurt ou reste morte.
    public void parcourtCelluleVivante(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites) {
        int n = cellule.nombreDeVoisins(jeu);
        if (n != 2 && n != 3) {
            activites.add(new Meurt(cellule));
        }
    }

    public void parcourtCelluleMorte(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites) {
        int n = cellule.nombreDeVoisins(jeu);
        if (n == 3) {
            activites.add(new Vit(cellule));
        }
    }
}</code></pre>
                            <p>ParcourtFort.java :</p>
<pre><code>package vie;

import java.util.List;

public class ParcourtFort extends Parcourir {
    public void parcourtCelluleVivante(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites) {
        int n = cellule.nombreDeVoisins(jeu);
        if (n != 2 && n != 3) {
            activites.add(new Meurt(cellule));
        }
    }

    public void parcourtCelluleMorte(Cellule cellule, JeuDeLaVie jeu, List&lt;Activite&gt; activites) {
        int n = cellule.nombreDeVoisins(jeu);
        if (n == 3 || n == 2) {
            activites.add(new Vit(cellule));
        }
    }
}</code></pre>
                            <p>Enfin un programme principal met ceci en oeuvre :</p>
                            <p>Principale.java :</p>
<pre><code>package vie;

import java.awt.*;

public class Principale implements ConstantesJeu {
    public static void main(String[] args) {
        Parcourir parcourt = new ParcourtNormal();
        // Parcourir parcourt = new ParcourtFort();
        JeuDeLaVie jeu = new JeuDeLaVie(NBR_LIGNES, NBR_COLONNES, parcourt);
        JeuDeLaVieGUI vie = new JeuDeLaVieGUI("Le Jeu de la Vie", jeu, Color.red, Color.black);
    }
}</code></pre>
                        </li>
                        <li>
                            <h3>Semaine 9 :</h3>
                        </li>
                    </ol>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
    </body>
</html>