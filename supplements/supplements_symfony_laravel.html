<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Symfony et Laravel - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="supplements_php.html">Retour au sommaire</a></li>
                        <li><a href="#choix_symfony_laravel">Le choix entre Symfony et Laravel</a></li>
                        <li><a href="#developpement_SOLID">Le développement SOLID</a></li>
                        <li><a href="#intro_symfony">Introduction à Symfony</a></li>
                        <li><a href="#intro_laravel">Introduction à Laravel</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Symfony et Laravel :</h1>
                    <p>Ce cours est un mélange de ce que je connais et que j'ai appris et <a href="https://grafikart.fr/formations/apprendre-symfony-7" target="_blank">la formation de Grafikart sur Symfony 7</a>.</p>
                    <p>* Si certaines notions existent mais que les notations sont anciennes dans ce cours, je vous conseille de toujours suivre la documentation.</p>
                </article>
                <article>
                    <p>Pour ceux qui utilisent Visual Studio Code, vous devez installer les extensions "PHP Namespace Resolver" et "PHP Docblocker" pour PHP mais également "PHP Intelephense" et "PHP Getters &amp; Setters" si besoin.</p>
                    <h2 id="choix_symfony_laravel">Le choix entre Symfony et Laravel :</h2>
                    <p>Symfony et Laravel sont les deux frameworks PHP les plus populaires.</p>
                    <p>Ce choix dépend de plusieurs facteurs, notamment vos besoins spécifiques, vos compétences en programmation, la taille du projet et la communauté de soutien. Les deux frameworks sont populaires et largement utilisés dans le développement web en PHP, mais ils ont des approches et des fonctionnalités différentes. Voici un bref aperçu de chacun :</p>
                    <h3>Symfony :</h3>
                    <ul>
                        <li>
                            <p>Symfony est un framework PHP mature et robuste, qui suit les principes de développement SOLID et encourage une approche modulaire pour la construction d'application web.</p>
                        </li>
                        <li>
                            <p>Il est hautement personnalisable et modulaire, vous permettant de choisir les composants dont vous avez besoin pour votre projet spécifique.</p>
                        </li>
                        <li>
                            <p>Symfony est connu pour sa stabilité, sa documentation détaillée et sa grande communauté de développeurs. Il est souvent préféré pour les projets d'entreprise de grande envergure.</p>
                        </li>
                        <li>
                            <p>Il met l'accent sur la réutilisation du code grâce à ses composants réutilisables, ce qui peut accélérer le processus de développement.</p>
                        </li>
                        <li>
                            <p>Cependant, il peut être plus verbeux que Laravel, nécessitant parfois plus de code pour accomplir certaines tâches.</p>
                        </li>
                    </ul>
                    <h3>Laravel :</h3>
                    <ul>
                        <li>
                            <p>Laravel est également un framework PHP populaire qui se concentre sur la simplicité et l'élégance du code. Il suit le modèle MVC (Modèle-Vue-Contrôleur) et propose une syntaxe expressive et concise.</p>
                        </li>
                        <li>
                            <p>Il est livré avec de nombreuses fonctionnalités intégrées, telles que l'ORM Eloquent, la gestion des migrations de base de données, le système de routage convivial, l'intégration de la messagerie et bien plus encore.</p>
                        </li>
                        <li>
                            <p>Laravel est souvent choisi pour les projets de taille moyenne à grande, mais il est également adapté aux petites applications en raison de sa courbe d'apprentissage douce.</p>
                        </li>
                        <li>
                            <p>Il dispose d'une communauté active et de documentation complète, ce qui facilite la résolution des problèmes et l'apprentissage du framework.</p>
                        </li>
                        <li>
                            <p>Cependant, en raison de son approche "magique", il peut être moins prévisible et modulaire que Symfony.</p>
                        </li>
                    </ul>
                    <h3>Tableau comparatif :</h3>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Critère</th>
                                <th>Symfony</th>
                                <th>Laravel</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Installation</td>
                                <td>CLI ou Composer</td>
                                <td>Composer</td>
                            </tr>
                            <tr>
                                <td>Courbe d'apprentissage</td>
                                <td>Moyenne à difficile</td>
                                <td>Facile à moyenne</td>
                            </tr>
                            <tr>
                                <td>Structure</td>
                                <td>Modulaire</td>
                                <td>Orientée développeur</td>
                            </tr>
                            <tr>
                                <td>ORM intégré</td>
                                <td>Doctrine (flexible, mais complexe)</td>
                                <td>Eloquent (intuitif, mais moins flexible)</td>
                            </tr>
                            <tr>
                                <td>Outils intégrés</td>
                                <td>Profiler Symfony, Webpack Encore</td>
                                <td>Artisan CLI, Laravel Mix</td>
                            </tr>
                            <tr>
                                <td>Usage typique</td>
                                <td>Projets complexes, d'entreprise</td>
                                <td>Projets rapides, MVP</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En fin de compte, le choix entre Symfony et Laravel dépend de vos préférences personnelles, de votre expérience en développement PHP et des besoins spécifiques de votre projet. Si vous appréciez la modularité, la personnalisation et la réutilisation du code, Symfony pourrait être un bon choix. Si vous recherchez la simplicité, l'efficacité et la rapidité de développement, Laravel pourrait mieux vous convenir.</p>
                    <p>Il est recommandé de prendre le temps de tester les deux frameworks, de lire leur documentation, de consulter des tutoriels (dans la suite, j'introduis chacun d'eux) et de participer aux communautés pour vous faire une idée plus précise de leurs avantages et de leurs inconvénients. Quel que soit votre choix, les deux frameworks offrent d'excellentes solutions pour le développement web en PHP.</p>
                </article>
                <article>
                    <h2 id="developpement_SOLID">Le développement SOLID :</h2>
                    <p>Le développement SOLID est un ensemble de principes fondamentaux de conception de logiciels qui visent à créer des systèmes logiciels flexibles, maintenables et évolutifs. Le terme SOLID est un acronyme qui représente les cinq principes individuels qui le composent. Ces principes ont été formulés par Robert C. Martin (également connu sous le nom de "Uncle Bob") et sont largement utilisés dans le développement logiciel orienté objet.</p>
                    <p>Voici une brève description de chaque principe SOLID :</p>
                    <ol>
                        <li>
                            <h3>Principe de Responsabilité Unique (Single Responsibility Principle - SRP) :</h3>
                            <p>Ce principe stipule qu'une classe (ou un module) ne devrait avoir qu'une seule raison de changer. En d'autres termes, une classe ne doit être responsable que d'une seule fonctionnalité ou tâche spécifique. Cela favorise la sépération des responsabilités et permet de rendre les classes plus cohérentes et plus facilement modifiables.</p>
                        </li>
                        <li>
                            <h3>Principe Ouvert/Fermé (Open/Closed Principle - OCP) :</h3>
                            <p>Le principe OCP indique qu'une classe doit être ouverte à l'extension (ajout de nouvelles fonctionnalités) mais fermée à la modification (le comportement existant ne doit être modifié). Plutôt que de modifier une classe existante, vous devriez étendre ses fonctionnalités en créant de nouvelles classes qui héritent des fonctionnalités de la classe de base.</p>
                        </li>
                        <li>
                            <h3>Principe de Substitution de Liskov (Liskov Substitution Principle - LSP) :</h3>
                            <p>Ce principe souligne que les objets d'une classe dérivée doivent pouvoir être substitués aux objets de la classe de base sans affecter la cohérence du programme. En d'autres termes, une classe dérivée doit être en mesure de remplacer sa classe de base sans provoquer d'effets indésirables ou d'erreurs.</p>
                        </li>
                        <li>
                            <h3>Principe de Ségrégation des Interfaces (Interface Segregation Principle - ISP) :</h3>
                            <p>L'ISP suggère que les interfaces clients ne devraient pas être forcées de dépendre des méthodes qu'elles n'utilisent pas. Plutôt que de créer de grandes interfaces contenant de nombreuses méthodes, vous devriez diviser les interfaces en petites interfaces spécifiques à chaque client.</p>
                        </li>
                        <li>
                            <h3>Principe d'Inversion des Dépendances (Dependency Inversion Principle - DIP) :</h3>
                            <p>Le DIP met l'accent sur le fait que les modules de haut niveau ne doivent pas dépendre des modules de bas niveau, mais des abstractions. Cela signifie que les détails d'implémentation doivent dépendre des abstractions plutôt que l'inverse. En utilisant l'inversion des dépendances, vous pouvez rendre vos applications plus flexibles et plus faciles à étendre.</p>
                        </li>
                    </ol>
                    <p>En suivant ces principes SOLID, les développeurs peuvent créer des codes plus robustes, éviter les dépendances rigides et faciliter la maintenance et l'évolution des applications. Les principes SOLID sont largement considérés comme les meilleures pratiques de conception orientée objet et sont utilisés pour créer des logiciels de haute quantité et faciles à maintenir.</p>
                </article>
                <article>
                    <h2 id="intro_symfony">Introduction au Framework PHP Symfony :</h2>
                    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Symfony. Symfony est un framework web puissant et flexible qui facilite le développement d'applications web évolutives et de haute qualité.</p>
                    <p>Symfony est un framework PHP qui vous permettra d'écrire une application web de manière plus organisée avec une séparation de la logique en plusieurs composants.</p>
                    <p>Il va vous fournir un ensemble de classes préconçues qui vont vous permettre de simplifier les tâches récurrentes dans la création d'une application web (vous allez avoir des classes pour communiquer avec la base de données, valider les données, gérer les URL...).</p>
                    <p>Symfony suit la structure MVC (pour Model View Controller), qui est une manière d'organiser le code qui est très répandue et que l'on retrouve sur la plupart des frameworks modernes aujourd'hui. Aussi, ce que vous allez apprendre avec Symfony sera aussi valable pour d'autres frameworks.</p>
                    <p>Vous trouverez la documentation complète de Symfony à l'adresse suivante : <a href="https://symfony.com/doc/current/index.html" target="_blank">https://symfony.com/doc/current/index.html</a>.</p>
                    <h3>Étape 1 : Installation de Symfony :</h3>
                    <p>Avant de commencer, assurez-vous que vous disposez d'une installation de PHP et du gestionnaire de dépendances Composer sur votre système.</p>
                    <p>Symfony a besoin de la version 8.2 ou supérieure de PHP. Pour vérifier la version de votre <span class="html">PHP</span> et de votre <span class="html">Composer</span>, vous pouvez utiliser les commandes suivantes :</p>
<pre><code>php --version</code></pre>
<pre><code>composer --version</code></pre>
                        <p><span class="html">Symfony CLI</span> est optionnel, mais recommandé pour une gestion simplifiée.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Symfony en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project symfony/skeleton:"7.0.*" nom_du_projet</code></pre>
                            <p>Ou encore, si vous avez installé le Symfony CLI et que vous l'avez mis dans le PATH, vous pouvez faire la même chose avec la commande :</p>
<pre><code>symfony new nom_du_projet --full</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                            <p>Remarque : Au moment où j'écris ces lignes, l'option <span class="em">--full</span> est déprécié, mais il existe l'option <span class="em">--webapp</span> à la place.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                            <p>Si vous avez utilisez la commande <span class="html">skeleton</span> qui installe une version "vide" de Symfony dans laquelle on peut charger les modules que l'on souhaite utiliser,  mais que vous voulez faire une application web complète, vous pouvez installer la dépendance <span class="em">webapp</span> avec la commande suivante pour ajouter tous les composants nécessaires à la création d'une application web :</p>
<pre><code>composer require webapp</code></pre>
                            <p><span class="html">Profiler Symfony</span> permet au développeur d'utiliser <span class="html">/app_dev.php/_profiler</span> pour déboguer et analyser vos requêtes, performances, etc.</p>
                            <p>Dans un projet Symfony typique, vous trouverez généralement les dossiers suivants à la racine du projet :</p>
                            <ol>
                                <li>
                                    <p><span class="em">assets/</span> : Contient les assets (JavaScript, CSS) front-end.</p>
                                </li>
                                <li>
                                    <p><span class="em">bin/</span> : Contient des scripts exécutables, tels que <span class="html">console</span>, qui est utilisé pour exécuter des commandes Symfony en ligne de commande.</p>
                                </li>
                                <li>
                                    <p><span class="em">config/</span> : Contient les fichiers de configuration de l'application au format <span class="em">yaml</span>, tels que <span class="html">config.yaml</span> (ou <span class="html">config.yml</span>), <span class="html">services.yaml</span>, <span class="html">routes.yaml</span>, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">migrations/</span> : Dans les projets Symfony qui utilisent Doctrine, un outil de mapping objet-relationnel (ORM) pour PHP, contient les fichiers de migration de base de données pour détailler les évolutions de la base de données.</p>
                                </li>
                                <li>
                                    <p><span class="em">public/</span> : Contient les fichiers accessibles publiquement par le navigateur, tels que les fichiers CSS, JavaScript, les images, ainsi que le fichier <span class="em">index.php</span> qui est le point d'entrée de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">src/</span> : Contient le code source de l'application. C'est ici que vous trouverez généralement les contrôleurs, les entités, les formulaires, les services, etc. Il correspond au namespace <span class="em">\App</span> (branché grâce à la clef <span class="em">autoload</span> dans le fichier <span class="em">composer.json</span>).</p>
                                </li>
                                <li>
                                    <p><span class="em">templates/</span> : Contient les fichiers de templates Twig utilisés pour générer les vues de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">tests/</span> : Contient les tests unitaires et fonctionnels de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">translations/</span> : Contient les fichiers de traduction de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">var/</span> : Contient les fichiers générés par l'application, tels que les caches, les logs, les sessions, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">vendor/</span> : Contient les dépendances installées via Composer, le gestionnaire de dépendances de PHP.</p>
                                </li>
                                <li>
                                    <p><span class="html">.env</span> : Fichier de configuration de l'environnement, utilisé pour définir des variables d'environnement telles que les paramètres de connexion à la base de données, les clés secrètes, etc. Ce fichier est versionné et il est possible de créer un nouveau fichier <span class="html">.env.local</span> pour des variables qui sont spécifiques à votre environnement.</p>
                                </li>
                                <li>
                                    <p><span class="html">composer.json</span> et <span class="html">composer.lock</span> : Fichiers utilisés par Composer pour gérer les dépendances du projet.</p>
                                </li>
                                <li>
                                    <p><span class="html">symfony.lock</span> : Fichier utilisé par Symfony pour verouiller les versions des composants Symfony installés.</p>
                                </li>
                            </ol>
                            <p>Ce sont les principaux dossiers et fichiers que vous trouverez dans un projet Symfony standard. Le contenu exact peut varier en fonction de la version de Symfony et des besoins spécifiques du projet.</p>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Symfony fournit un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>symfony server:start
# Ou
symfony serve</code></pre>
                    <p>Ou encore en utilisant la commande <span class="em">php</span> :</p>
<pre><code>php -S localhost:8000 -t public</code></pre>
                    <p>Pour l'arrêter complètement, on peut faire la commande :</p>
<pre><code>symfony server:stop</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <p>Un contrôleur est une classe qui classe qui va contenir des méthodes permettant de répondre à une requête utilisateur.</p>
                    <ol>
                        <li>
                            <p>Créez le contrôleur nommé <span class="em">DefaultController</span> en utilisant la commande suivante :</p>
<pre><code>php bin/console make:controller DefaultController</code></pre>
                            <p>Ou encore, si et seulement si on a bien configuré le PATH de Windows, on utilise la syntaxe suivante qui fait la même chose :</p>
<pre><code>symfony console make:controller DefaultController</code></pre>
                            <p>En résumé, <span class="html">php bin/console</span> peut être remplacé par <span class="html">symfony console</span>.</p>
                        </li>
                        <li>
                            <p>Ouvrez le fichier <span class="em">`src/Controller/DefaultController.php`</span> avec votre éditeur de code préféré et voici le code généré par la commande :</p>
<pre><code>&lt;?php

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    
    class DefaultController extends AbstractController
    {
        #[Route('/default', name: 'app_default')]
        public function index(): Response
        {
            return $this-&gt;render('default/index.html.twig', [
                'controller_name' =&gt; 'DefaultController',
            ]);
        }
    }

?&gt;</code></pre>
                        </li>
                        <li>
                            <p>Créez une nouvelle action (méthode) dans le contrôleur pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette méthode à la classe DefaultController
#[Route('/', 'home.index', methods: ['GET'])]
public function homepage() : Response {
    return $this-&gt;render('pages/homepage.html.twig');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Création de la vue (template) :</h3>
                    <p>Le moteur de template <span class="html">Twig</span> va nous permettre de générer des pages HTML complexes.</p>
                    <p>On peut se poser la question suivante : <q>Pourquoi ne pas utiliser du PHP ?</q> PHP est déjà un moteur de template, car il nous permet de mélanger logique et rendu, on peut alors se poser également la question de la pertinence de l'utilisateur d'un moteur de template.</p>
                    <ul>
                        <li>
                            <p><span class="em">Twig</span> inègre un système d'<a href="https://twig.symfony.com/doc/3.x/tags/extends.html" target="_blank">extensions</a> qui permet de définir un template de base que l'on pourra étendre en fonction de la page courante.</p>
                        </li>
                        <li>
                            <p>Les variables sont automatiquement échappées.</p>
                        </li>
                        <li>
                            <p>La syntaxe est plus simple que celle de PHP et permet à des personnes non familières avec le lanagage de pouvoir éditer la structure des pages.</p>
                        </li>
                        <li>
                            <p>Le langage est plus limité et empêche de faire n'importe quoi dans les fichiers de template.</p>
                        </li>
                    </ul>
                    <p>Les templates seront placés dans le dossier <span class="em">templates</span> à la racine de notre projet.</p>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`templates/pages/homepage.html.twig`</span> dans le répertoire du projet (si le dossier "pages" n'existe pas encore, créez-le).</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Symfony&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                        <li>
                            <p>Modifiez le template pour qu'il étend de celui de base dans le fichier <span class="em">`templates/base.html.twig`</span> :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Mon Projet Symfony{% endblock %}

{% block body %}
    &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
{% endblock %}</code></pre>
                            <p>On uilise ici deux tags (délimités par <span class="html">{% %}</span>) :</p>
                            <ul>
                                <li>
                                    <p><span class="html">extends</span> permet d'indiquer qu'on souhaite étendre d'un autre template, ici <span class="em">base.html.twig</span> qui est en général créé par défaut lors d'une installation classique de Symfony.</p>
                                </li>
                                <li>
                                    <p><span class="html">block</span> permet de placer du contenu dans un block qui est utilisé dans le template dont on hérite.</p>
                                    <p>Si on a juste du texte dans un bloc comme ceci :</p>
<pre><code>{% block title %}Toutes mes recettes{% endblock %}</code></pre>
                                    <p>On peut le remplacer avec cela :</p>
<pre><code>{% block title 'Toutes mes recettes' %}</code></pre>
                                </li>
                            </ul>
                            <p>On peut concaténer plusieurs variables via le <span class="html">~</span> dans une vue <span class="em">Twig</span> :</p>
<pre><code>{{ person.lastname ~ person.firstname }}</code></pre>
                            <p>On peut également faire un <span class="html">dd</span> dans la vue <span class="em">Twig</span> :</p>
<pre><code>{{ dump(person) }}</code></pre>
                        </li>
                        <li>
                            <p>Vous pouvez également modifier votre template de base pour intégrer Bootstrap : au-dessus du block <span class="em">stylesheets</span>, on met <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" target="_blank">le lien CDN CSS de Bootstrap</a> et, au-dessus du block <span class="em">javascripts</span>, <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" target="_blank">le lien CDN JS de Bootstrap</a>.</p>
                        </li>
                        <li>
                            <p>On peut également inclure un template Twig dans un autre comme par exemple :</p>
<pre><code>{% include "partials/_header.html.twig" %}</code></pre>
                            <p>Ça permet donc d'inclure le fichier partiel "header" pour avoir le même header sur toutes les pages.</p>
                        </li>
                    </ol>
                    <p>Pour découvrir les fonctionnalités de <span class="em">Twig</span>, il y a deux liens essentiels :</p>
                    <ul>
                        <li>
                            <p><a href="https://twig.symfony.com/doc/3.x/" target="_blank">Documentation de Twig</a>.</p>
                        </li>
                        <li>
                            <p><a href="https://symfony.com/doc/current/reference/twig_reference.html" target="_blank">Extension de Symfony</a> qui rajoute des fonctions par défaut dans <span class="em">Twig</span>.</p>
                        </li>
                    </ul>
                    <h3>Étape 5 : Définir la route :</h3>
                    <p>Une fois ce contrôleur créé, il va falloir indiquer au framework quelle URL correspondra à quelle action. Cela peut se faire de deux manières :</p>
                    <ol>
                        <li>
                            <p>Dans le dossier <span class="em">config</span>, on peut éditer le fichier <span class="em">routes.yaml</span> pour enregistrer notre route.</p>
<pre><code># Ajoutez cette ligne au fichier routes.yaml
home:
    path: /
    controller: App\Controller\DefaultController::index</code></pre>
                        </li>
                        <li>
                            <p>Les routes peuvent aussi être définies en utilisant des attributs PHP directement au niveau des méthodes de notre contrôleur comme dans le code du DefaultController ci-dessus.</p>
                        </li>
                        <li>
                            <p>Pour lister la liste des routes utilisées dans notre application, on utilise la commande :</p>
<pre><code>php bin/console debug:router</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenur sur Mon Projet Symfony !" sur la page d'accueil.</p>
                    <p>C'est tout ! Vous avez maintenant créé une application web simple en utilisant Symfony. Vous pouvez continuer à explorer la documentation officielle de Symfony pour découvrir plus de fonctionnalités et d'outils puissants offerts par ce framework.</p>
                    <p>En 2024, je rajoute de nouvelles étapes pour améliorer ce tutoriel sur Symfony. Voici les nouveautés :</p>
                    <h3>Étape 7 : Objet Request :</h3>
                    <p>Maintenant, comment ça se passe si on veut gérer des paramètres dans l'url ? Par exemple : <span class="em">?name=john</span>. Par défaut, ce qu'on ferait dans une application PHP standard, c'est qu'on mettrait un appel à <span class="html">$_GET</span> et on irait récupérer la clef <span class="em">name</span>. Ce n'est pas la bonne manière de faire ça dans le cadre d'une appplication Symfony. Avec le framework, lorsque j'utilise une fonction, je peux lui injecter un paramètre supplémentaire qui va permettre de récupérer les informations sur la requête. Ce paramètre devra être de type <span class="em">Symfony\Component\HttpFoundation\Request</span>.</p>
<pre><code>&lt;?php
    
    namespace App\Controller;
    
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;

    class HomeController
    {
        
        #[Route('/', name: 'home')]
        function index (Request $request): Response
        {
            return new Response('Bonjour ' . $request-&gt;query-&gt;get('name', 'Anonyme'));
        }

    }

?&gt;</code></pre>
                    <p>Dès lors que l'on veut récupérer des informations sur la requête de l'utilisateur, on utilisera cet objet.</p>
                    <p>On aura sûrement l'occassion de revenir sur cet objet <span class="em">Request</span> et ses méthodes plus tard.</p>
                    <h3>Étape 8 : URLs dynamiques :</h3>
                    <p>Maintenant, ce qu'on aimerait bien faire c'est avoir des URLs qui soient plus proches de la réalité. Par exemple, si je me rends sur un blog, souvent les URLs des articles contiennt un slug suivi d'un ID.</p>
<pre><code>https://drissv.github.io/Syllabus/mon-premier-article-32</code></pre>
                    <p>Et on aimerait bien faire pareil avec notre Routing, pour cela on va déclarer une nouvelle route qui aura des paramètre mis entre accolades.</p>
<pre><code>#[Route('/recettes/{slug}-{id}', name: 'recipe.show', requirements: ['id' =&gt; Requirement::DIGITS, 'slug' =&gt; '[a-z0-9]+'])]
public function index (Request $request): Response
{

}</code></pre>
                    <p>Les paramètres sont ensuite accessibles dans l'objet requête.</p>
<pre><code>$request-&gt;attributes-&gt;get('id)</code></pre>
                    <p>Mais peuvent aussi être automatiquement injectés en modifiant les paramètres de la fonction.</p>
<pre><code>#[Route('/recettes/{slug}-{id}', name: 'recipe.show', requirements: ['id' =&gt; '\d+', 'slug' =&gt; '[a-z0-9]+'])]
public function index (Request $request, string $slug, int $id): Response
{

}</code></pre>
                    <h3>Étape 9 : Notre première entité :</h3>
                    <p>Cette étape nous permet de découvrir comment stocker et afficher des données provenant d'une base de données en utilisant l'ORM Doctrine qui va nous permettre de récupérer et de modifier des informations plus facilement.</p>
                    <p>Pour commencer, on va modifier notre fichier <span class="em">.env</span> ou <span class="em">.env.local</span> pour définir la configuration permettant de se connecter à la base de données via la variable <span class="html">DATABASE_URL</span>. Sa syntaxe sera :</p>
<pre><code>DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=8.0.31&amp;charset=utf8mb4"</code></pre>
                    <p>On doit remplacer "db_user", "db_password" et "db_name" par les valeurs que l'on a définies. Vous pouvez vous inspirer des lignes en commentaire pour adapter à votre SGBD. Le numéro de version est important car cela permet à doctrine de générer des requêtes SQL compatibles avec votre version. Si la base de données avec le nom stocké dans "db_name" n'est pas encore dans PHP My Admin, on peut la créer avec la commande suivante :</p>
<pre><code>php bin/console doctrine:database:create</code></pre>
                    <p>Ou on peut utiliser la commande abrégée :</p>
<pre><code>symfony console d:d:c</code></pre>
                    <p>Remarque : Ça lance une erreur si la base de données existe déjà. On verra sûrement un peu plus tard comment faire pour la supprimer.</p>
                    <p>L'ORM permet de représenter nos données sous forme d'objets qui pourront ensuite être persistés en base de données grâce à des méthodes spécifiques. Il se chargera de générer les requêtes SQL et de s'adapter au système de gestion de base de données utilisé.</p>
                    <p>Dans un projet de recettes de cuisine, on a besoin d'une entité pour l'ingrédient qui sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui ne pourra pas excéder plus de 50 caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un prix au kg (par exemple 2 euros le kilo) qui ne pourra être inférieur à 1 et supérieur à 200. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>Un champ contenant la date de création qui doit être générée automatiquement une fois l'ingrédient créé.</p>
                        </li>
                    </ul>
                    <p>Pour créer cette entité, on utilise la commande :</p>
<pre><code>php bin/console make:entity Ingredient</code></pre>
                    <p>Cette commande crée deux fichiers : <span class="em">`src/Entity/Ingredient.php`</span> et <span class="em">`src/Repository/IngredientRepository.php`</span>.</p>
                    <p>Ensuite, cette commande va vous poser des questions pour définir les champs dont vous avez besoin : le nom des propriétés, son type, sa longueur et s'il est nullable en base de données. Par exemple, la propriété "name" est une "string" de "50" caractères "no" nullable.</p>
                    <p>Une fois terminée cette commande va générer deux fichiers :</p>
                    <ul>
                        <li>
                            <p>Une <span class="em">entité</span> qui est un objet PHP classique qui va représenter les données. Cet objet possède des attributs PHP qui permettent à Doctrine de comprendre comment sont sauvegardées les données dans la base de données.</p>
                        </li>
                        <li>
                            <p>Un <span class="em">repository</span>, qui permet de récupérer les enregistrements en utilisant des requêtes SQL.</p>
                        </li>
                    </ul>
                    <p>Voici la classe entité "Ingredient.php" (je ne mettrais pas tous les getters et les setters) :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this-&gt;createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <p>Ensuite, une fois que l'on a créé nos entités, il va falloir créer les tables associées dans notre base de données, et, comme avec Laravel, on va faire une migration pour migrer les entités dans la base de données avec la commande :</p>
<pre><code>php bin/console make:migration</code></pre>
                    <p>Cette commande va comparer la structure actuelle de la base de données avec la structure attendue. Dans cette migration, on a du SQL pur et dur. Il gén!rera un fichier de migration qui contiendra les requêyes SQL à effectuer pour changer la structure de la base de données pour correspondre au code de notre application. Symfony a interprété l'entité en SQL et donc a fait un <span class="html">CREATE TABLE</span> dans la fonction <span class="em">up</span> et un <span class="html">DROP TABLE</span> dans la fonction <span class="em">down</span>.</p>
                    <p>Maintenant on va migrer toutes les migrations vers la base de données avec la commande :</p>
<pre><code>php bin/console doctrine:migrations:migrate</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Si la base de données était vide, ça rajoute une table supplémentaire de la table "Ingredient" de notre migration qui est nommée "doctrine_migration_versions" et qui contient la version de la migration, la date d'exécution et le temps d'exécution en milisecondes.</p>
                    <p>Maintenant que notre entité et notre table sont créés, on va pouvoir utiliser l'ORM pour récupérer et modifier nos données.</p>
                    <p>Pour gérer les différentes contraintes des données, comme par exemple que le prix ne doit pas être inférieur à 1, on utilise des <span class="html">Assert</span>.</p>
                    <p>La validation va se faire au travers d'attributs que l'on va pouvoir placer sur nos entités et nos différents modèles et qui permettront de définir ce qui constitue une structure valide. Ces attributs seront automatiquement lus par le composant formulaire et permettront de vérifier si les données qui ont été postées par l'utilisateur sont justes.</p>
                    <p>Reprenons l'exemple de notre entité "Ingredient" :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        #[Assert\NotNull()]
        #[Assert\Positive()]
        #[Assert\LessThan(200)]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this-&gt;createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <p>Il sera aussi possible d'utiliser le composant de validation de manière isolée pour valider des données dans un contexte autre que celui du formulaire.</p>
                    <p>Pour créer une contrainte personnalisée, vous pouvez utiliser la commande :</p>
<pre><code>symfony console make:validator</code></pre>
                    <h4>Liens utiles :</h4>
                    <ul>
                        <li><a href="https://symfony.com/doc/current/validation.html" target="_blank">Documentation sur la Validation</a></li>
                        <li><a href="https://symfony.com/doc/current/validation/custom_constraint.html" target="_blank">Créer une contrainte personnalisée</a></li>
                        <li><a href="https://symfony.com/doc/current/reference/constraints.html" target="_blank">Liste des contraintes disponibles dans Symfony</a></li>
                    </ul>
                    <h3>Étape 10 : Création des Fixtures :</h3>
                    <p>Quand on travaille sur une application, on a souvent besoin de données pour tester nos fonctionnalités. Dans la suite de ce cours, on va créer des fixtures qui permettent de nous générer un jeu de fausses données de test comme un Faker.</p>
<pre><code>php bin/console make:fixture</code></pre>
                    <p>Pour faire cela, on va installer les packages en développement :</p>
<pre><code>composer require --dev orm-fixtures</code></pre>
                    <p>Ainsi que la commande :</p>
<pre><code>composer require --dev fakerphp/faker</code></pre>
                    <p>Ces commandes ont créer le dossier <span class="em">`src/DataFixtures`</span> et dedans le fichier <span class="em">AppFixtures</span> avec le contenu que l'on va modifier comme cela :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $manager-&gt;persist($ingredient);
            }

            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on va les charger avec la commande :</p>
<pre><code>php bin/console doctrine:fixtures:load</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>symfony console d:f:l</code></pre>
                    <p>Cette commande va commencer par effacer les enregistrements de votre base de données, et la remplira ensuite avec les données définies dans les fixtures.</p>
                    <h3>Étape 11 : CRUD sur la table "Ingredient" :</h3>
                    <p>Maintenant, on va enfin faire des CRUD sur la table "Ingredient". D'abord, on va afficher la liste des ingrédients.</p>
                    <p>Premièrement, on va créer un nouveau contrôleur "IngredientController" avec la commande :</p>
<pre><code>php bin/console make:controller IngredientController</code></pre>
                    <p>Remarque : Ça va créer le fichier <span class="em">`templates/ingredient/index.html.twig`</span>, mais, pour faire un peu le ménage, on va créer un dossier "pages" et donc on va y insérer dedans le dossier "ingredient".</p>
                    <h4>Lister tous les ingrédients :</h4>
                    <p>Modifions la fonction "index" de notre contrôleur fraîchement créé :</p>
<pre><code>#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository) : Response
{
    $ingredients = $repository-&gt;findAll();
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>On va modifier le fichier TWIG comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Mes ingréidents{% endblock %}

{% block body %}
    &lt;div class="container mt-4"&gt;
        &lt;h1&gt;Mes ingrédients&lt;/h1&gt;

        &lt;table class="table table-hover"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th scope="col"&gt;Numéro&lt;/th&gt;
                    &lt;th scope="col"&gt;Nom&lt;/th&gt;
                    &lt;th scope="col"&gt;Prix&lt;/th&gt;
                    &lt;th scope="col"&gt;Date de création&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                {% for ingredient in ingredients %}
                    &lt;tr class="table-primary"&gt;
                        &lt;th scope="row"&gt;{{ ingredient.id }}&lt;/th&gt;
                        &lt;td&gt;{{ ingredient.name }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.price }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.createdAt|date('d/m/Y') }}&lt;/td&gt;
                    &lt;/tr&gt;
                {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
        
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour récupérer toutes les recettes avec une durée plus petite ou égale à un certain nombre de minutes, on peut créer une nouvelle méthode dans le repository de l'entité <span class="em">Recipe</span>, c'est-à-dire le <span class="em">RecipeRepository</span> :</p>
<pre><code>/**
* return Recipe[]
*/
public function findWithDurationLowerThan(int $duration): array
{
    return $this-&gt;createQueryBuilder('r')
                -&gt;where('r.duration &lt;= :duration')
                -&gt;orderBy('r.duration', 'ASC')
                -&gt;setMaxResults(10)
                -&gt;setParameter('duration', $duration)
                -&gt;getQuery()
                -&gt;getResult();
}</code></pre>
                    <p>Jusqu'à maintenant, nous avons utilisé un <span class="html">findAll()</span> pour lister l'ensemble des résultats. Mais, dans un cas réel, on va vouloir imposer une limite sur le nombre de résultats à afficher et on va souhaiter mettre en place un système de pagination.</p>
                    <p>Doctrine dispose d'une classe permettant de gérer la pagination.</p>
<pre><code>&lt;?php

    namespace App\Repository;

    use Doctrine\ORM\Tools\Pagination\Paginator;

    // ...

    class RecipeRepository extends ServiceEntityRepository
    {

        public function paginateRecipes(int $page, int $limit): Paginator
        {
            $query = $this
                        -&gt;createQueryBuilder('r')
                        -&gt;setFirstResult(($page -1) * $limit)
                        -&gt;setMaxResults($limit)
                        -&gt;getQuery()
                        -&gt;setHint(Paginator::HINT_ENABLE_DISTINCT, false);

            $paginator = new Paginator($query, fetchJoinCollection: false);
        }

    }

?&gt;</code></pre>
                    <p>Cet objet <span class="em">paginator</span> implémente les interfaces <span class="html">Countable</span> et <span class="html">IteratorAggregate</span>. Lors du <span class="html">count()</span>, il génèrera une requête permettant de compter l'ensemble des résultats.</p>
                    <p>Voici le code dans notre contrôleur :</p>
<pre><code>$page = $request-&gt;query-&gt;getInt('page', 1);
$limit = 2;
$recipes = $repository-&gt;paginateRecipes($page, $limit);
$maxPage = ceil($recipes-&gt;count() / $limit);</code></pre>
                    <p>Voilà le code dans ma vue :</p>
<pre><code>{% if page &gt; 1 %}
    &lt;a href="{{ path('recipe.index', {page: page - 1}) }}" class="btn btn-secondary"&gt;Page précédente&lt;/a&gt;
{% endif %}
{% if page &lt; maxPage %}
    &lt;a href="{{ path('recipe.index', {page: page + 1}) }}" class="btn btn-secondary"&gt;Page suivante&lt;/a&gt;
{% endif %}</code></pre>
                    <p>Pour la pagination dans la page, on va utiliser le bundle <a href="https://github.com/KnpLabs/KnpPaginatorBundle" target="_blank">KnpPaginatorBundle</a> qui offre plus de fonctionnalités avec la possibilité de gérer l'organisation mais aussi la partie template avec la structure HTML d'une pagination. Aussi, si votre objectif est de paginer des résultats dans une page Web, je vous conseille d'utiliser ce bundle. On peut l'installer avec la commande :</p>
<pre><code>composer require knplabs/knp-paginator-bundle</code></pre>
                    <p>On va créer le fichier <span class="em">`config/packages/knp_paginator.yaml`</span> avec le contenu suivant :</p>
<pre><code>knp_paginator:
    page_range: 5                       # number of links shown in the pagination menu (e.g: you have 10 pages, a page_range of 3, on the 5th page you'll see links to page 4, 5, 6)
    default_options:
        page_name: page                 # page query parameter name
        sort_field_name: sort           # sort field query parameter name
        sort_direction_name: direction  # sort direction query parameter name
        distinct: true                  # ensure distinct results, useful when ORM queries are using GROUP BY statements
        filter_field_name: filterField  # filter field query parameter name
        filter_value_name: filterValue  # filter value query parameter name
    template:
        pagination: '@KnpPaginator/Pagination/bootstrap_v5_pagination.html.twig'     # sliding pagination controls template
        # rel_links: '@KnpPaginator/Pagination/rel_links.html.twig'     # &lt;link rel=...&gt; tags template
        sortable: '@KnpPaginator/Pagination/bootstrap_v5_bi_sortable_link.html.twig' # sort link template
        filtration: '@KnpPaginator/Pagination/bootstrap_v5_filtration.html.twig'  # filters template</code></pre>
                    <p>Modifions notre fonction "index" de notre cotrôleur pour qu'elle prenne en compte la pagination :</p>
<pre><code>use Knp\Component\Pager\PaginatorInterface;
use Symfony\Component\HttpFoundation\Request;

/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository-&gt;findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10,
        [
            'distinct' =&gt; false,
            'sortFieldAllowList' =&gt; ['r.id', 'r.title']
        ]
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>Ou on peut placer ce code dans le repository :</p>
<pre><code>public function paginateRecipes(int $page): PaginatorInterface
{
    return $this-&gt;paginator-&gt;paginate(
        $this-&gt;createQueryBuilder('r')-&gt;leftJoin('r.category', 'c')-&gt;select('r', 'c'),
        $page,
        20,
        [
            'distinct' =&gt; false,
            'sortFieldAllowList' =&gt; ['r.id', 'r.title']
        ]
    );
}</code></pre>
                    <p>On va modifier également le fichier TWIG en ajoutant ceci :</p>
<pre><code>&lt;div class="count mt-4"&gt;
    &lt;p&gt;Il y a {{ ingredients.getTotalItemCount }} ingrédients au total&lt;/p&gt;
&lt;/div&gt;
    
&lt;div class="navigation d-flex justify-content-center mt-4"&gt;
    {{ knp_pagination_render(ingredients) }}
&lt;/div&gt;</code></pre>
                    <p>On peut faire un <span class="html">{% if not ingredients.items is same as([]) %}</span> pour vérifier que la liste n'est pas vide.</p>
                    <p>On peut également trier le tableau :</p>
<pre><code>&lt;table class="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;{{ knp_pagination_sortable(recipes, 'ID', 'r.id') }}&lt;/th&gt;
            &lt;th&gt;{{ knp_pagination_sortable(recipes, 'Titre', 'r.title') }}&lt;/th&gt;
            // ...
        &lt;/tr&gt;
    &lt;/thead&gt;
    // ...
&lt;/table&gt;</code></pre>
                    <h4>Créer un nouvel ingrédient :</h4>
                    <p>La gestion des formulaires se faire au travers de classes qui étendent de <span class="em">Symfony\Component\Form\AbstractType</span> et qui vont décrire la structure du formulaire.</p>
                    <p>Pour la création d'un nouvel ingrédient, on va créer un nouveau formulaire "IngredientType" avec l'entité "Ingredient" via la commande :</p>
<pre><code>php bin/console make:form</code></pre>
                    <p>Ça permet de créer le fichier <span class="em">`src/Form/IngredientType.php`</span> avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Form;

    use App\Entity\Ingredient;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\MoneyType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\OptionsResolver;

    use Symfony\Component\Validator\Constraints as Assert;

    class IngredientType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                -&gt;add('name', TextType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                        'minlength' =&gt; '2',
                        'maxlength' =&gt; '50'
                    ],
                    'label' =&gt; 'Nom',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                        new Assert\NotBlank()
                    ]
                ])
                -&gt;add('price', MoneyType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                    ],
                    'label' =&gt; 'Prix',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Positive(),
                        new Assert\LessThan(200),
                        new Assert\NotNull()
                    ]
                ])
                -&gt;add('submit', SubmitType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'btn btn-primary mt-4'
                    ],
                    'label' =&gt; 'Créer mon ingrédient'
                ]);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver-&gt;setDefaults([
                'data_class' =&gt; Ingredient::class,
            ]);
        }
    }

?&gt;</code></pre>
                    <p>Il est possible d'utiliser ce formulaire dans notre controller.</p>
                    <p>Dans notre IngredientController, on va créer une nouvelle fonction "new" :</p>
<pre><code>/**
*
* This controller show a form which create an ingredient
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/nouveau', 'ingredient.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $ingredient = new Ingredient();
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été créé avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Il y a plusieurs méthodes qui nous intéressent :</p>
                    <ul>
                        <li>
                            <p><span class="html">createForm</span>, permet de créer une instance de notre formulaire remplit avec les données passées en second paramètre.</p>
                        </li>
                        <li>
                            <p><span class="html">handleRequest()</span>, permet de passer les informations soumises dans le formulaire (si le formulaire a été rempli) et de mettre à jour les données qui sont à l'intérieur.</p>
                        </li>
                        <li>
                            <p><span class="html">isSubmitted()</span>, vérifie si le formulaire a été envoyé.</p>
                        </li>
                        <li>
                            <p><span class="html">isValid()</span>, utilisera les contraintes de validation définies sur l'entité et sur les champs pour vérifier que les données sont valides.</p>
                        </li>
                    </ul>
                    <p>L'onjet formulaire est envoyé dans la vue Twig qui pourra utiliser des <a href="https://symfony.com/doc/current/form/form_customization.html#reference-form-twig-functions" target="_blank">fonctions spéciales</a> pour générer les différents champs.</p>
                    <p>On va également créer le nouveau template <span class="em">`templates/ingredient/new.html.twig`</span> avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour ajouter des messages d'erreur, on va modifier le code précédent pour donner ceci :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form_start(form) }}
        
        &lt;div class="form-group"&gt;
            {{ form_label(form.name) }}
            {{ form_widget(form.name) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.name) }}
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="form-group"&gt;
            {{ form_label(form.price) }}
            {{ form_widget(form.price) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.price) }}
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="form-group"&gt;
            {{ form_row(form._token) }}
        &lt;/div&gt;

        &lt;div class="form-group"&gt;
            {{ form_row(form.submit) }}
        &lt;/div&gt;

        {{ form_end(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Si on met en style quelques champs du formulaire, on peut utiliser le code ci-dessous pour afficher le reste du formulaire :</p>
<pre><code>{{ form_rest(form) }}</code></pre>
                    <p>On va afficher un message FLASH dans l'index pour dire que la création d'un ingrédient a eu un statut de succès ainsi qu'un lien qui permet d'accéder à la page de création d'un nouvel ingrédient. Voici le code à rajouter :</p>
<pre><code>&lt;a href="{{ path('ingredient.new') }} class="btn btn-primary"&gt;Créer un ingrédient&lt;/a&gt;

{# read and display just one flash message type #}
{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}</code></pre>
                    <p>Comme ça peut être des messages flash génériques qui peuvent être utilisés dans plusieurs autres pages, on peut créer un nouveau fichier qu'on va nommer `<span class="em">_partials/flash.html.twig</span>` :</p>
<pre><code>{% for type, messages in app.flashes %}
    &lt;div class="alert alert-{type}"&gt;
        {{ messages | join('. ') }}
    &lt;/div&gt;
{% endfor %}</code></pre>
                    <p>Dans la navbar, on oublie pas de rajouter un lien vers "ingredient.index" pour accéder plus facilement à la liste des ingrédients.</p>
                    <h4>Éditer un ingrédient :</h4>
                    <p>Dans notre contrôleur, on va rajouter une nouvelle fonction pour pouvoir éditer un ingrédient :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param IngredientRepository $repository
* @param int $id
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(IngredientRepository $repository, int $id, Request $request, EntityManagerInterface $manager) : Response
{
    $ingredient = $repository-&gt;findBy(['id' =&gt; $id]);
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On peut utiliser directement la méthode <span class="html">find</span> du repository au lieu de la méthode <span class="html">findBy</span> :</p>
<pre><code>$ingredient = $repository-&gt;find($id);</code></pre>
                    <p>Ça c'est ce que la plupart des gens font d'habitude, mais nous on va utiliser un <span class="html">@ParamConverter</span> comme ceci :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param Ingredient $ingredient
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(Ingredient $ingredient, Request $request, Entity $manager) : Response
{
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Ensuite, dans le "edit.html.twig", on va copier le contenu du "new.html.twig" et modifier "Création" par "Modification".</p>
                    <h4>Supprimer un ingrédient :</h4>
                    <p>Pour le delete, on rajoute une nouvelle fonction "delete" dans le contrôleur :</p>
<pre><code>#[Route('/ingredient/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Ingredient $ingredient) : Response
{
    $manager-&gt;remove($ingredient);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre ingrédient a été supprimé avec succès !');

    return $this-&gt;redirectToRoute('ingredient.index');
}</code></pre>
                    <p>Dans la liste des ingrédients, on va rajouter deux nouvelles colonnes : une pour l'édition et l'autre pour la suppression :</p>
<pre><code>&lt;th scope="col"&gt;Édition&lt;/th&gt;
&lt;th scope="col"&gt;Suppression&lt;/th&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.edit', { id: ingredient.id }) }}" class="btn btn-info"&gt;Modifier&lt;/a&gt;
&lt;/td&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.delete', { id: ingredient.id }) }}" class="btn btn-danger"&gt;Supprimer&lt;/a&gt;
&lt;/td&gt;</code></pre>
                    <p>Pour faire que ce soit une méthode <span class="html">DELETE</span>, on doit remplacer le lien par un formulaire :</p>
<pre><code>&lt;form action="{{ path('ingredient.delete', { id: ingredient.id }) }}" method="post"&gt;
    &lt;input type="hidden" name="_method" value="DELETE"&gt;
    &lt;button type="submit" class="btn btn-danger btn-danger"&gt;Supprimer&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    <p>Et on doit également modifier le fichier de configuration <span class="em">`package/framework.yaml`</span>, on va rajouter le code suivant dans la partie <span class="em">framework</span> :</p>
<pre><code>http_method_override: true</code></pre>
                    <p>On peut utiliser un système d'événements au niveau des formulaires, les <span class="em">Form Events</span>. Lorsqu'on soumet un formulaire, il y a différents événements qui sont envoyés : <span class="html">PRE_SUBMIT</span>, <span class="html">SUBMIT</span> et <span class="html">POST_SUBMIT</span>.</p>
                    <p>Dans notre formulaire, on rajoute l'événement :</p>
<pre><code>&lt;?php

    namespace App\Form;

    use Symfony\Component\Form\Event\PreSubmitEvent;
    use Symfony\Component\Form\Event\PostSubmitEvent;
    use Symfony\Component\String\Slugger\AsciiSlugger;

    // ...

    // ... {

        $builder
            // ...
            -&gt;addEventListener(FormEvents::PRE_SUBMIT, $this-&gt;autoSlug(...))
            -&gt;addEventListener(FormEvents::POST_SUBMIT, $this-&gt;attachTimestamps(...))
    }

    public function autoSlug(PreSubmitEvent $event): void
    {
        $data = $event-&gt;getData();

        if (empty($data['slug'])) {
            $slugger = new AsciiSlugger();
            $data['slug'] = strtolower($slugger-&gt;slug($data['title']));
            $event-&gt;setData($data);
        }
    }

    public function attachTimestamps(PostSubmitEvent $event): void
    {
        $data = $event-&gt;getData();

        if (!($data instanceof Recipe)) {
            return;
        }

        $data-&gt;setUpdatedAt(new \DateTimeImmutable());

        if (!$data-&gt;getId()) {
            $data-&gt;setCreatedAt(new \DateTimeImmutable());
        }
    }

    // ...

?&gt;</code></pre>
                    <p>Pour rendre générique notre listener, on peut créer la classe `<span class="em">FormListenerFactory</span>` :</p>
<pre><code>&lt;?php

    namespace App\Form;

    use Symfony\Component\Form\Event\PreSubmitEvent;
    use Symfony\Component\Form\Event\PostSubmitEvent;
    use Symfony\Component\String\Slugger\AsciiSlugger;

    class FormListenerFactory
    {

        public function autoSlug(string $field): callable
        {
            return function (PreSubmitEvent $event) us ($field) {
                $data = $event-&gt;getData();

                if (empty($data['slug'])) {
                    $slugger = new AsciiSlugger();
                    $data['slug'] = strtolower($slugger-&gt;slug($data[$field]));
                    $event-&gt;setData($data);
                }
            };
        }

        public funtion timestamps(): callable
        {
            return function (PostSubmitEvent $event) {
                $data = $event-&gt;getData();

                $data-&gt;setUpdatedAt(new \DateTimeImmutable());

                if (!$data-&gt;getId()) {
                    $data-&gt;setCreatedAt(new \DateTimeImmutable());
                }
            };
        }

    }

?&gt;</code></pre>
                    <p>On va pouvoir modifier notre formulaire <span class="em">RecipeType</span> :</p>
<pre><code>&lt;?php

    // ...

    public function __construct(private FormListenerFactory $listenerFactory)
    {

    }

    // ... {
        // ...
        -&gt;addEventListener(FormEvents::PRE_SUBMIT, $this-&gt;listenerFactory-&gt;autoSlug('title'))
        -&gt;addEventListener(FormEvents::POST_SUBMIT, $this-&gt;listenerFactory-&gt;timestamps());
    }

?&gt;</code></pre>
                    <h3>Étape 12 : CRUD pour la table "Recipe" :</h3>
                    <p>Maintenant, on va faire le CRUD pour la table "Recipe". Pour information, une recette sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui sera obligatoire et ne pourra pas être vide, il ne pourra également pas excéder plus de 5à caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un temps (en minutes) qui n'est pas obligatoire. S'il est rempli, il ne pourra pas être inférieur à une minute et ne pourra pas dépasser les 24h.</p>
                        </li>
                        <li>
                            <p>Un nombre de personnes qui n'est pas obligatoire. S'il est rempli, il devra être inférieur à 50.</p>
                        </li>
                        <li>
                            <p>Une difficulté n'est pas obligatoire. Si elle esy rentrée, elle sera comprise entre 1 et 5.</p>
                        </li>
                        <li>
                            <p>Une liste d'étapes à suivre/description qui sera obligatoire et ne pourra pas être vide.</p>
                        </li>
                        <li>
                            <p>Un prix qui ne sera pas obligatoire. S'il est renseigné, le prix ne pourra pas être inférieur à 0 et supérieur à 1000. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>La possibilité de définir la recette comme étant favorite ou non.</p>
                        </li>
                        <li>
                            <p>Une date de création.</p>
                        </li>
                        <li>
                            <p>Une date de mise à jour.</p>
                        </li>
                        <li>
                            <p>Une liste d'ingrédients.</p>
                        </li>
                    </ul>
                    <p>Remarque : La date de création et la date de mise à jour seront générées automatiquement une fois la recette créée et/ou modifiée.</p>
                    <p>Jusqu'à maintenant, nous n'avons travaillé qu'avec une seule entité à la fois mais, dans un cas réel, on a souvent besoin de lier des données ensemble pour par exemple mettre en place un système de catégorie pour les recettes.</p>
                    <p>Premièrement, on doit créer l'entité "Recipe" avec les propriétés "name" de type "string" non nullable, "time" de type "integer" nullable, "nbPeople" de type "integer" nullable, "difficulty" de type "integer" nullable, "description" de type "text" non nullable, "price" de type "float" nullable, "isFavorite" de type "boolean" non nullable, "createdAt" de type "datetime_immutable" non nullable, "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Pour la propriété "ingredients" qui définit la liste des ingrédients, on va dire qu'il est de type "relation" lié à l'entité "Ingredient" dont le type de relation est "ManyToMany" et on veut pas récupérer depuis les ingrédients les recettes qui ont cet ingrédient.</p>
                    <p>Au niveau de la gestion, l'ORM fait abstraction de la relation et, si vous souhaitez modifier des données croisées, il vous suffit de manipuler des objets de manière traditionnelle.</p>
                    <p>Voici donc le code généré par la commande <span class="html">php bin/console make:entity Recipe</span> sans tous les getters et les setters et qu'on va modifier en ajoutant les <span class="em">Assert</span> :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\RecipeRepository;
    use Doctrine\Common\Collections\ArrayCollection;
    use Doctrine\Common\Collections\Collection;
    use Doctrine\ORM\Mapping as ORM;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('name')]
    #[ORM\HasLifecycleCallbacks]
    #[ORM\Entity(repositoryClass: RecipeRepository::class)]
    class Recipe
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank()]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1441)]
        private ?int $time;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(51)]
        private ?int $nbPeople;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(6)]
        private ?int $difficulty;

        #[ORM\Column(type: 'text')]
        #[Assert\NotBlank()]
        private string $description;

        #[ORM\Column(type: 'float', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1001)]
        private ?float $price;

        #[ORM\Column(type: 'boolean')]
        private bool $isFavorite;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $updatedAt;

        #[ORM\ManyToMany(targetEntity: Ingredient::class)]
        private $ingredients;

        public function __construct() {
            $this-&gt;ingredients = new ArrayCollection();
            $this-&gt;createdAt = new \DateTimeImmutable();
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        #[ORM\PrePersist]
        public function setUpdatedAt()
        {
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;string;
        }

        public function setName(string $name) : self
        {
            $this-&gt;name = $name;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Dans ma solution, je vais d'abord "DROP" toute la base de données avec la commande :</p>
<pre><code>symfony console d:d:d --force</code></pre>
                    <p>Avant de la recréer avec la commande :</p>
<pre><code>symfony console d:d:c</code></pre>
                    <p>Afin de créer une nouvelle migration avec la commande :</p>
<pre><code>symfony console make:migration</code></pre>
                    <p>Et de migrer dans la base de données toutes les migrations avec la commande :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Deuxièmement, on va créer les fixtures en modifiant le fichier <span class="em">`src/DataFixtures/AppFixtures.php`</span> comme ceci :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use App\Entity\Recipe;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            $ingredients = [];
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $ingredients[] = $ingredient;
                $manager-&gt;persist($ingredient);
            }

            // Recipes
            $recipes = [];
            for ($j = 0; $j &lt; 25; $j++) {
                $recipe = new Recipe();
                $recipe-&gt;setName($this-&gt;faker-&gt;word())
                    -&gt;setTime(mt_rand(0, 1) == 1 ? mt_rand(1, 1440) : null)
                    -&gt;setNbPeople(mt_rand(0, 1) == 1 ? mt_rand(1, 50) : null)
                    -&gt;setDifiiculty(mt_rand(0, 1) == 1 ? mt_rand(1, 5) : null)
                    -&gt;setDescription($this-&gt;faker-&gt;text(300))
                    -&gt;setPrice(mt_rand(0, 1) == 1 ? mt_rand(1, 1000) : null)
                    -&gt;setIsFavorite(mt_rand(0, 1) == 1);
                
                for ($k = 0; $k &lt; mt_rand(5, 15); $k++) {
                    $recipe-&gt;addIngredient($ingredients[array_rand($ingredients)]);
                }
            }

            $recipes[] = $recipe;
            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Et on va pouvoir charger les nouvelles données factives avec la commande :</p>
<pre><code>symfony console d:f:l</code></pre>
                    <p>Troisièmement, on va commencer le CRUD par lister toutes les recettes. Pour cela, on va créer le contrôleur "RecipeController" avec la commande :</p>
<pre><code>php bin/console make:controller RecipeController</code></pre>
                    <p>Remarque : On oublie pas de déplacer le dossier templates "recipe" dans le dossier "pages" et d'ajouter un lien vers cette page dans la navbar :</p>
<pre><code>&lt;li class="nav-item"&gt;
    &lt;a class="nav-link {{ app.current_route starts with 'recipe.' ? 'active' : '' }}" href="{{ path('recipe.index') }}"&gt;Recettes&lt;/a&gt;
&lt;/li&gt;</code></pre>
                    <p>Maintenant, modifions la fonction "index" du contrôleur comme ceci :</p>
<pre><code>/**
* This controller display all recipes
*
* @param RecipeRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/recette', name: 'recipe.index', methods: ['GET'])]
public function index(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe/index.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>Quatrièmement, on va créer un nouveau formulaire pour la création d'une recette en rajoutant déjà dans le contrôleur la fonction "new" :</p>
<pre><code>#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(): Response
{
    return $this-&gt;render('pages/recipe/new.html.twig');
}</code></pre>
                    <p>Cinquièmement, on va créer le formulaire "RecipeType" lié à l'entité "Recipe" avec la commande suivante :</p>
<pre><code>php bin/console make:form RecipeType Recipe</code></pre>
                    <p>On va améliorer sa fonction "buildForm" en ajoutant par exemple un submit :</p>
<pre><code>public function buildForm(FormBuilderInterface $builder, array $options): void
{
    $builder
        -&gt;add('name', TextType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'minlength' =&gt; '2',
                'maxlength' =&gt; '50'
            ],
            'label' =&gt; 'Nom',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('time', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 1440
            ],
            'required' =&gt; false,
            'label' =&gt; 'Temps (en minutes)',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(1441)
            ]
        ])
        -&gt;add('nbPeople', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 50
            ],
            'required' =&gt; false,
            'label' =&gt; 'Nombre de personnes',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(51)
            ]
        ])
        -&gt;add('difficulty', RangeType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-range',
                'min' =&gt; 1,
                'max' =&gt; 5
            ],
            'required' =&gt; false,
            'label' =&gt; 'Difficulté',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(6)
            ]
        ])
        -&gt;add('description', TextareaType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Description',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('price', MoneyType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
            ],
            'required' =&gt; false,
            'label' =&gt; 'Prix',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Positive(),
                new Assert\LessThan(1001),
                new Assert\NotNull()
            ]
        ])
        -&gt;add('isFavorite', CheckboxType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-check-input',
            ],
            'label' =&gt; 'Favoris ?',
            'label_attr' =&gt; [
                'class' =&gt; 'form-check-label'
            ],
            'constraints' =&gt; [
                new Assert\NotNull()
            ]
        ])
        -&gt;add('ingredients', EntityType::class, [
            'class' =&gt; Ingredient::class,
            'query_builder' =&gt; function(IngredientRepository $r) {
                return $r-&gt;createQueryBuilder('i')
                    -&gt;orderBy('i.name', 'ASC');
            },
            'label' =&gt; 'Les ingrédients',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'choice_label' =&gt; 'name',
            'multiple' =&gt; true,
            'expanded' =&gt; true,
            // 'by_reference' =&gt; false
        ])
        -&gt;add('submit', SubmitType::class, [
            'attr' =&gt; [
                'class' =&gt; 'btn btn-primary mt-4'
            ],
            'label' =&gt; 'Créer ma recette'
        ]);
}</code></pre>
                    <p>On va modifier la fonction "new" précédemment créée :</p>
<pre><code>/**
* This controller allow us to create a new recipe
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $recipe = new Recipe();
    $form = $this-&gt;createForm(RecipeType::class, $recipe);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été créée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Sixièmement, on va créer dans le contrôleur la fonction "edit" :</p>
<pre><code>/**
* This controller allow us to edit a recipe
*
* @param Recipe $recipe
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/edition/{id}', 'recipe.edit', methods: ['GET', 'POST'])]
public function edit(Recipe $recipe, Request $request, EntityManagerInterface $manager): Response
{
    $form = $this-&gt;createForm(RecipeType::class, $recipe);
    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été modifiée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Septièmement, on rajoute également la méthode "delete" dans le contrôleur :</p>
<pre><code>/**
* This controller allows us to delete a recipe
*
* @param EntityManagerInterface $manager
* @param Recipe $recipe
* @return Response
*/
#[Route('/recette/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Recipe $recipe): Response
{
    $manager-&gt;remove($recipe);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre recette a été supprimée avec succès !');

    return $this-&gt;redirectToRoute('recipe.index');
}</code></pre>
                    <p>Dans notre entité, on peut persister ou supprimer une relation en cascade comme par exemple :</p>
<pre><code>#[ORM\ManyToOne(inversedBy: 'recipes', cascade: ['persist'])]
private ?Category $category = null;</code></pre>
<pre><code>#[ORM\OneToMany(targetEntity: Recipe::class, mappedBy: 'category', cascade: ['remove'])]
private Collection $recipes;</code></pre>
                    <h4>Liens utiles :</h4>
                    <ul>
                        <li>
                            <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/3.0/reference/working-with-associations.html" target="_blank">Documentation Doctrine</a>
                        </li>
                        <li>
                            <a href="https://symfony.com/doc/current/reference/forms/types/entity.html" target="_blank">EntityType pour créer un champs de sélection</a>
                        </li>
                    </ul>
                    <h3>Étape 13 : Sécurité &amp; compte utilisateur :</h3>
                    <p>Un compte utilisateur sera défini par :</p>
                    <ul>
                        <li>
                            <p>Un nom et un prénom qui seront obligatoires. Ils devront faire entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Un pseudo qui sera facultatif et, s'il est renseigné, il devra également entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Une adresse email qui sera unique et servira d'identifiant lors de la connexion.</p>
                        </li>
                        <li>
                            <p>Un mot de passe qui sera encodé en base de données pour des questions de sécurité.</p>
                        </li>
                        <li>
                            <p>Une date de création qui sera générée seule.</p>
                        </li>
                        <li>
                            <p>Une date de modificaton sera également générée seule lors de la modification du profil utilisateur.</p>
                        </li>
                    </ul>
                    <p>Pour cela, on utilise le composant <span class="em">Security</span> de Symfony déjà installé, qui est un outil puissant et flexible qui permet de mettre en place un système d'authentification et d'autorisation et qui a généré le fichier <span class="em">`config/packages/security.yaml`</span>. Dans Symfony, il y a une façon très simple de générer une entité qui permettra de représenter un utilisateur pour gérer la sécurité avec la commande :</p>
<pre><code>php bin/console make:user</code></pre>
                    <p>On nomme notre classe utilisateur "User", on la stocke dans la DB via Doctrine, on dit que la propriété "email" doit être unique et on a besoin de hasher les mots de passe. Voici le code généré (sans les getters et les setters) et que je modifie un peu :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\UserRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('email')]
    #[ORM\Entity(repositoryClass: UserRepository::class)]
    class User implements UserInterface, PasswordAuthenticatedUserInterface
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 180, unique: true)]
        #[Assert\Email()]
        #[Assert\Length(min: 2, max: 180)]
        private string $email;

        #[ORM\Column(type; 'json')]
        #[Assert\NotNull()]
        private array $roles = [];

        private ?string $plainPassword = null;

        #[ORM\Column(type: 'string')]
        #[Assert\NotBlank()]
        private string $password = 'password';

        public function __construct()
        {

        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        /**
        * A visual identifier that represents this user
        *
        * @see UserInterface
        */
        public function getUserIdentifier(): string
        {
            return (string) $this-&gt;email;
        }

        /**
        * @see UserInterface
        */
        public function getRoles(): array
        {
            $roles = $this-&gt;roles;
            // guarantee every user at least has ROLE_USER
            $roles[] = 'ROLE_USER';

            return array_unique($roles);
        }

        public function setRoles(array $roles): self
        {
            $this-&gt;roles = $roles;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Dans le <span class="em">UserRepository</span>, il a crée une méthode utilisée pour rehashé le mot de passe au fil du temps :</p>
<pre><code>/**
* Used to upgrade (rehash) to user's password Automatically over time.
*/
public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
{
    if (!$user instanceof User) {
        throw new UnsupportedUserException(sprintf('Instance of "%s" are not supported.', $user::class));
    }

    $user-&gt;setPassword($newHashedPassword);
    $this-&gt;getEntityManager()-&gt;persist($user);
    $this-&gt;getEntityManager-&gt;flush();
}</code></pre>
                    <p>Avant de créer une migration pour cette entité et de la migrer, il faut modifier l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:entity User</code></pre>
                    <p>On va rajouter les propriétés "fullName" de taille "50" non nullable, "pseudo" de taille "50" nullable, "createdAt" de type "datetime_immutable" non nullable et "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Donc, avec la commande `<span class="html">php bin/console make:migration</span>` on crée la migration et avec `<span class="em">php bin/console d:m:m</span>` pour la migrer.</p>
                    <p>Ensuite, dans le fichier "<span class="em">security.yaml</span>", on va rajouter le provider comme suit :</p>
<pre><code>providers:
        # used to reload user from session &amp; other features (e.g. switch user)
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email</code></pre>
                    <p>Pour hasher le mot de passe, on va définir un <span class="em">password_hashers</span> s'il n'est pas défini dans le fichier <span class="em">security.yaml</span> :</p>
<pre><code>password_hashers:
    Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: "auto"</code></pre>
                    <p>Dans nos contrôleurs, si on veut limiter l'accès à certaines routes, on peut utiliser :</p>
<pre><code>$this-&gt;denyAccessUnlessGranted('ROLE_USER');</code></pre>
                    <p>Dans notre fixture, on va créer des utilisateurs fictifs :</p>
<pre><code>// Users
$users = [];
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPassword('password');

    $users[] = $user;
    $manager-&gt;persist($user);
}</code></pre>
                    <p>On charge les nouveaux utilisateurs avec la commande :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <p>Ici, on peut voir que le mot de passe n'est pas encore crypté dans la base de données. Pour faire cela, on rajoute une propriété dans la classe "AppFixtures" et on modifie la fonction "load" :</p>
<pre><code>private UserPasswordHasherInterface $hasher;</code></pre>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER']);
    
    $hashPassword = $this-&gt;hasher-&gt;hashPassword($user, 'password');

    $user-&gt;setPassword($hashPassword);

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Le problème avec cette solution, c'est que n'importe où on doit toujours demander que le mot de passe soit hashé.</p>
                    <p>On voudrait exporter la logique de hashage du mot de passe à l'extérieur. Pour ce faire, on va utiliser les <span class="html">Entity Listeners</span> de Symfony qui, comme leur nom l'indique, vont écouter ce qui se passe au niveau des entités et faire plusieurs actions. On va de nouveau modifier la fonction "load" :</p>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPlainPassword('password');

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Ensuite, on va rajouter un nouveau service dans le fichier <span class="em">`config/services.yaml`</span> :</p>
<pre><code>App\EntityListener\
    resource: "../src/EntityListener/"
    tags: ["doctrine.orm.entity_listener"]
</code></pre>
                    <p>Avant la déclaration de la classe de l'entité "User", on rajoute la ligne suivante :</p>
<pre><code>#[ORM\EntityListeners(['App\EntityListener\UserListener'])]</code></pre>
                    <p>Dans le dossier "src", on va créer un dossier "EntityListener" et y insérer le fichier "UserListener.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\EntityListener;

    use App\Entity\User;
    use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

    class UserListener
    {

        private UserPasswordHasherInterface $hasher;

        public function __construct(UserPasswordHasherInterface $hasher)
        {
            $this-&gt;hasher = $hasher;
        }

        public function prePersist(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        public function preUpdate(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        /**
        * Encode password based on plain password
        *
        * @param User $user
        * @return void
        */
        public function encodePassword(User $user)
        {
            if (is_null($user-&gt;getPlainPassword())) {
                return;
            }

            $user-&gt;setPassword(
                $this-&gt;hasher-&gt;hashPassword($user, $user-&gt;getPlainPassword())
            );

            $user-&gt;setPlainPassword(null);
        }
    }

?&gt;</code></pre>
                    <p>Remarques : Maintenant qu'on a le "$hasher" dans le "UserListener", on peut le supprimer dans les fixtures.</p>
                    <h3>Étape 14 : Firewall et formulaire de connexion :</h3>
                    <p>La section "Firewall" est la section la plus importante en terme de sécurité. Pour faire simple, le firewall sert à définir les parties de notre application qui sont sécurisées et comment les utilisateurs vont avoir la possibilité de s'authentifier (par exemple que ce soit via un formulaire de connexion ou par rapport à un token si on fait une API, etc).</p>
                    <p>On a deux firewalls : le "dev" et le "main". Le "dev" qui est un faux Firewall et le "main" qui de base n'est pas très sécurisé.</p>
                    <p>Maintenant, on va créer un nouveau contrôleur pour afficher la page de connexion que l'on nomme "SecurityController" avec la commande :</p>
<pre><code>php bin/console make:controller SecurityController</code></pre>
                    <p>Remarques : on déplace le dossier "templates/security" dans le dossier "templates/pages" et on renomme le fichier "index.html.twig" par "login.html.twig". Modifions la fonction "index" de ce nouveau contrôleur pour que ça devienne ceci :</p>
<pre><code>use Symfony\Component\Security\Http\authentification\AuthenticationUtils;

/**
* This controller allow us to login
*
* @param AuthenticationUtils $authenticationUtils
* @return Response
*/
#[Route('/connexion', name: 'security.login', methods: ['GET', 'POST'])]
public function login(AuthenticationUtils $authenticationUtils): Response
{
    $lastUsername = $authenticationUtils-&gt;getLastUsername();
    $error = $authenticationUtils-&gt;getLastAuthenticationError();

    return $this-&gt;render('pages/security/login.html.twig', [
        'last_username' =&gt; $lastUsername,
        'error' =&gt; $error
    ]);
}</code></pre>
                    <p>On va rajouter les lignes suivantes dans la configuration de notre "main" Firewall :</p>
<pre><code>form_login:
    login_path: security.login
    check_path: security.login</code></pre>
                    <p>On va ensuite créer la structure de notre formulaire de connexion dans "login.html.twig" :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Connexion{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de connexion&lt;/h1&gt;

        {% if error %}
            &lt;div class="alert alert-danger"&gt;
                {{ error.messageKey|trans(error.messageData, 'security') }}
            &lt;/div&gt;
        {% endif %}

        &lt;form action="{{ path('security.login') }}" method="post" name="login"&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="username" class="form-label mt-4"&gt;Adresse email&lt;/label&gt;
                &lt;input type="email" class="form-control" id="username" name="_username" value="{{ last_username }}"&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password" class="form-label mt-4"&gt;Mot de passe&lt;/label&gt;
                &lt;input type="password" class="form-control" id="password" name="_password"&gt;
            &lt;/div&gt;

            &lt;button type="submit" class="btn btn-primary mt-4"&gt;
                Se connecter
            &lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire fonctionne bien ! Passons vite fait à la déconnexion. Pour ce faire, on crée la fonction logout dans notre contrôleur et on rajoute les lignes suivantes dans le "main" Firewall :</p>
<pre><code>/**
* This controller allow us to logout
*
* @return void
*/
#[Route('/deconnexion', 'security.logout', methods: ['GET'])]
public function logout()
{
    // Nothing to do here...
}</code></pre>
<pre><code>logout:
    path: security.logout
    # target: app_login # route de redirection
    # invalidate_session: false # empêche la suppression de la session après la déconnexion</code></pre>
                    <h3>Étape 15 : Formulaire d'inscription :</h3>
                    <p>D'abord, on va créer le formulaire "RegistrationType" basé sur l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form RegistrationType User</code></pre>
                    <p>Ça génèrera le code suivant dans la fonction "buildForm" qu'on va modifier :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'label' =&gt; 'Nom / Prénom',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('email', EmailType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '180',
        ],
        'label' =&gt; 'Adresse email',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Email(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 180])
        ]
    ])
    -&gt;add('plainPassword', RepeatedType::class, [
        'type' =&gt; PasswordType::class,
        'first_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'second_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Confirmation du mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !',
        'constraints' =&gt; [
            new Assert\Length([
                'min' =&gt; 8,
                'minMessage' =&gt; 'Le mot de passe doit contenir au moins  {{ limit }} caractères !'
            ])
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'S\'inscrire'
    ]);</code></pre>
                    <p>Dans notre "SecurityController", on rajoute la fonction "registration" :</p>
<pre><code>/**
* This controller allow us to RegistrationType
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/inscription', 'security.registration', methods: ['GET', 'POST'])]
public function registration(Request $request, EntityManagerInterface $manager): Response
{
    $user = new User();
    $user-&gt;setRoles(['ROLE_USER']);

    $form = $this-&gt;createForm(RegistrationType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $user = $form-&gt;getData();

        $manager-&gt;persist($user);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre compte a bien été créé !');

        return $this-&gt;redirectToRoute('security.login');
    }

    return $this-&gt;render('pages/security/registration.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va créer notre template avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Inscription{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire d'inscription&lt;/h1&gt;

        {{ form(form) }}

    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire d'inscription est fonctionnel.</p>
                    <h3>Étape 16 : Édition du profil et du mot de passe :</h3>
                    <p>On va créer le formulaire "UserType" lié à l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form UserType User</code></pre>
                    <p>Comme précédemment, on va modifier la fonction "buildForm" comme ceci :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
    'attr' =&gt; [
        'class' =&gt; 'form-control',
        'minlength' =&gt; '2',
        'maxlength' =&gt; '50',
    ],
    'label' =&gt; 'Nom / Prénom',
    'label_attr' =&gt; [
        'class' =&gt; 'form_label mt-4'
    ],
    'constraints' =&gt; [
        new Assert\NotBlank(),
        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
    ]
])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('plainPassword', PasswordType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Modifier le profil'
    ]);</code></pre>
                    <p>Ensuite, on va créer un contrôleur "UserController", on met le dossier de template "user" dans le dossier "pages", on modifie le fichier "index.html.twig" en "edit.html.twig" et on modifie la fonction "index" du contrôleur en "edit" :</p>
<pre><code>/**
* This controller allow us to edit user's profile
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edition/{id}', name: 'user.edit', methods: ['GET', 'POST'])]
public function edit(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    if (!$this-&gt;getUser()) {
        return $this-&gt;redirectToRoute('security.login');
    }

    if ($this-&gt;getUser() !== $user) {
        return $this-&gt;redirectToRoute('recipe.index');
    }

    $form = $this-&gt;createForm(UserType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()-&gt;getPlainPassword()))
        {
            $user = $form-&gt;getData();
            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Les informations de votre compte ont bien été modifiées !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions le template ainsi :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification des informations de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>On crée un  nouveau formulaire "UserPasswordType" associer à l'entité "User" pour modifier le mot de passe :</p>
<pre><code>$builder-&gt;add('plainPassword', RepeatedType::class, [
    'type' =&gt; PasswordType::class,
    'first_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'second_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Confirmation du mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !',
    'constraints' =&gt; [
        new Assert\Length([
            'min' =&gt; 8,
            'minMessage' =&gt; 'Le mot de passe doit contenir au moins  {{ limit }} caractères !'
        ])
    ]
])
    -&gt;add('newPassword', PasswordType::class, [
        'attr' =&gt; ['class' =&gt; 'form-control'],
        'label' =&gt; 'Nouveau mot de passe',
        'label_attr' =&gt; ['class' &gt;= 'form-label mt-4'],
        'constraints' =&gt; [new Assert\NotBlank()]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Changer mon mot de passe'
    ]);</code></pre>
                    <p>On rajoute la fonction "editPassword" dans le contrôleur :</p>
<pre><code>/**
* This controller allow us to edit user's password
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edit-mot-de-passe/{id}', 'user.edit.password', methods: ['GET, 'POST'])]
public function editPassword(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    $form = $this-&gt;createForm(UserPasswordType::class);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()['plainPassword'])) {
            $user-&gt;setUpdatedAt(new \DateTimeImmutable());
            $user-&gt;setPlainPassword($form-&gt;getData()['newPassword']);

            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Le mot de passe a été modifié !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit_password.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions également le template :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification du mot de passe de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification du mot de passe de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <h3>Étape 17 : Assigner les entités à un utilisateur (ingrédient, recette) :</h3>
                    <p>Dans cette partie, on va mettre en place la relation entre l'entité "User" et l'entité "Ingredient". On doit également modifier les fixtures pour lier les ingrédients à un utilisateur, ainsi que lier un ingrédient à l'utilisateur connecté lors de la création et afficher uniquement les ingrédients reliés à l'utilisateur.</p>
                    <p>Pour commencer, on rajoute la propriété "ingredients" dans l'entité "User" de type "relation" lié à l'entité "Ingredient" et de type de relation "OneToMany".</p>
                    <p>On va dire que la propriété "user" non nullable sera rajouté dans l'entité "Ingredient" et on va ajouter le fait de supprimer l'ingrédient orphelin.</p>
                    <p>Dans les fixtures, on déplace le code des users au-dessus de celui des ingrédients que l'on va modifier ainsi :</p>
<pre><code>// Ingredients
$ingredients = [];
for ($i = 0; $i &lt; 50; $i++) {
    $ingredient = new Ingredient();
    $ingredient-&gt;setName($this-&gt;faker-&gt;word())
        -&gt;setPrice(mt_rand(0, 100))
        -&gt;setUser($users[array_range($users)]);
}</code></pre>
                    <p>On crée une nouvelle migration, on la migre et on load à nouveau les fixtures. Enfin, on modifie la fonction "index" de notre "IngredientController" pour qu'il affiche seulement les ingrédients lié à l'utilisateur connecté :</p>
<pre><code>/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository-&gt;findBy(['user' =&gt; $this-&gt;getUser()]),
        $request-&gt;query-&gt;getInt('page', 1),
        10    
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>Pour lier l'utilisateur à un ingrédient lors de sa création, on va modifier la fonction "new" du "IngredientController" pour ajouter la ligne suivante :</p>
<pre><code>$ingredient-&gt;setUser($this-&gt;getUser());</code></pre>
                    <p>Ce sera pareil pour l'entité "Recipe" afin de la lier à celle de "User". On doit ajouter un constructeur et on doit modifier le "QueryBuilder" du formulaire pour lors de la création d'une recette, on affiche seulement tous les ingrédients de l'utilisateur connecté :</p>
<pre><code>use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;

private $token;

public function __construct(TokenStorageInterface $token)
{
    $this-&gt;token = $token;
}</code></pre>
<pre><code>'query_builder' =&gt; function(IngredientRepository $r) {
    return $r-&gt;createQueryBuilder('i')
        -&gt;where('i.user = :user')
        -&gt;orderBy('i.name', 'ASC')
        -&gt;setParameter('user', $this-&gt;token-&gt;getToken()-&gt;getUser());
}</code></pre>
                    <p>On va modifier la navbar qui sera différente si l'utilisateur est connecté ou pas avec <span class="html">{% if app.user %}</span>.</p>
                    <p>Les liens vers la connexion et l'inscription si l'utilisateur n'est pas connecté sinon les liens vers mes ingrédients et mes recettes comme par exemple :</p>
<pre><code>&lt;div class="d-flex"&gt;
    &lt;ul class="navbar-nav me-auto"&gt;
        {% if app.user %}
            &lt;li class="nav-item dropdown"&gt;
                &lt;a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false"&gt;{{ app.user.fullName }}&lt;/a&gt;
                &lt;div class="dropdown-menu dropdown-menu-end"&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit', {id: app.user.id}) }}"&gt;Modifier mes informations&lt;/a&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit.password', {id: app.user.id}) }}"&gt;Modifier mon mot de passe&lt;/a&gt;
                    &lt;div class="dropdown-divider"&gt;&lt;/div&gt;
                    &lt;a class="dropdown-item" href="{{ path('security.logout') }}"&gt;Déconnexion&lt;/a&gt;
                &lt;/div&gt;
            &lt;/li&gt;
        {% else %}
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.login') }}"&gt;Connexion&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.registration') }}"&gt;Inscription&lt;/a&gt;
            &lt;/li&gt;
        {% endif %}
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    <h3>Étape 18 : Sécuriser les routes avec IS_GRANTED et SECURITY :</h3>
                    <p>Dans cette partie, on va gérer la gestion de l'accès des pages, c'est-à-dire qu'on va interdire l'accès à certaines pahes en fonction de différents critères.</p>
                    <p>Les annotations <span class="html">@Security</span> et <span class="html">@IsGranted</span> restreint l'accès aux contrôleurs et donc par extension aux pages.</p>
                    <p>L'annotation <span class="em">@IsGranted</span> est la plus simple pour restreindre par rôle ou encore par les variables passées au contrôleur.</p>
                    <p>L'annotation <span class="em">@Security</span> est plus flexible et plus complète qui permet de passer des expressions contenant de la logique.</p>
                    <p>Pour la page de la liste des ingrédients, on va donner l'accès aux utilisateurs ayant le rôle "ROLE_USER" en ajoutant sur la méthode "index" du "IngredientController" la ligne suivante :</p>
<pre><code>#[IsGranted('ROLE_USER')]</code></pre>
                    <p>Pour la modification des ingrédients, on doit aussi vérifier qu'en plus du rôle "ROLE_USER" que l'utilisateur connecté soit bien celui lié à cet ingrédient avec la ligne suivante :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === ingredient.getUser()")]</code></pre>
                    <p>Ce sera pareil pour les recettes. Pour la modification du profil de l'utilisateur ou encore pour la modification du mot de passe, on va supprimer les if de vérification pour les remplacer par la ligne suivante au-dessus de la fonction "edit" de l'"UserController" :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === choosenUser")]
public function edit(User $choosenUser, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    ...
}</code></pre>
                    <p>Remarque : On a modifié le "$user" par "$choosenUser" car il existe déjà la variable "user" dans l'annotation "Security".</p>
                    <h3>Étape 19 : Partager une recette :</h3>
                    <p>Pour partager une recette, on la rendre publique ou non avec les spécificités suivantes :</p>
                    <ul>
                        <li>Un utilisateur connecté aura à disposition un champ, pour chaque recette, lui permettant de choisir si la recette en question est disponible pour l'ensemble de la communauté.</li>
                        <li>Si la recette est rendue publique, alors les utilisateurs pourront la consulter.</li>
                        <li>Sinon, elle ne pourra pas être consultée par quelqu'un d'autre que le créateur.</li>
                    </ul>
                    <p>On va rajouter la propriété "isPublic" de type "boolean" non nullable dans l'entité "Recipe" avec la valeur par défaut à "false". On fait une nouvelle migration et on la migre. On va modifier la fixture pour ajouter la ligne suivante :</p>
<pre><code>-&gt;setIsPublic(mt_rand(0, 1) == 1);</code></pre>
                    <p>Dans le contrôleur "RecipeController", on va rajouter la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET'])]
public function show(Recipe $recipe): Response
{
    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe
    ]);
}</code></pre>
                    <p>Créons donc ce template avec le contenu suivant :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}
    {{ recipe.name }}
{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;{{ recipe.name }}&lt;/h1&gt;
        &lt;div&gt;
            &lt;span class="badge bg-primary"&gt;Créée le {{ recipe.createdAt|date('d/m/Y') }}&lt;/span&gt;
        &lt;/div&gt;

        {% if recipe.time %}
            &lt;p&gt;Temps (en minutes) : {{ recipe.time }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Temps non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.nbPeople %}
            &lt;p&gt;Pour {{ recipe.nbPeople }} personnes&lt;/p&gt;
        {% else %}
            &lt;p&gt;Nombre de personnes non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.difficulty %}
            &lt;p&gt;Difficulté : {{ recipe.difficulty }}/5&lt;/p&gt;
        {% else %}
            &lt;p&gt;Difficulté non renseignée&lt;/p&gt;
        {% endif %}

        {% if recipe.price %}
            &lt;p&gt;Prix (en €) : {{ recipe.price }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Prix non renseigné&lt;/p&gt;
        {% endif %}

        &lt;div class="mt-4"&gt;
            {{ recipe.description|raw }}
        &lt;/div&gt;

        &lt;p class="mt-4"&gt;Ingrédients :&lt;/p&gt;
        {% for ingredient in recipe.ingredients %}
            &lt;span class="badge bg-primary"&gt;{{ ingredient.name }}&lt;/span&gt;
        {% endfor %}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour afficher la page qui liste toutes les recettes qui ont été partagées par l'ensemble des personnes, on va créer dans le "RecipeController" une nouvelle fonction :</p>
<pre><code>#[Route('/recette/pblique', 'recipe.public', methods: ['GET'])]
public function indexPublic(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findPublicRecipe(null),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe.index_public.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>On peut copier le même template que la liste des recettes mais sans les boutons de modification et de suppression. Ensuite, on va créer une fonction dans le "RecipeRepository" qui va permettre de récupérer un nombre x de recettes publiques :</p>
<pre><code>/**
* This method allow us to find public recipes based on number of recipes
*
* @param integer $nbRecipes
* @return array
*/
public function findPublicRecipe(?int $nbRecipes): array
{
    $queryBuilder = $this-&gt;createQueryBuilder('r')
        -&gt;where('r.isPublic = 1')
        -&gt;orderBy('r.createdAt', 'DESC');
    
    if ($nbRecipes !== 0 || !is_null($nbRecipes)) {
        $queryBuilder-&gt;setMaxResults($nbRecipes);
    }
    
    return $queryBuilder-&gt;getQuery()
        -&gt;getResult();
}</code></pre>
                    <p>Sur la page d'accueil, on pourrait afficher les 3 dernières recettes de la communauté en précisant la valeur de "$nbRecipes" à 3.</p>
                    <h3>Étape 20 : Noter une recette :</h3>
                    <p>Cette fonctionnalité va permettre aux différents utilisateurs de noter les recettes mises en mode "public" sur l'application. Une fois la recette mise en mode "public", elle est éligible aux votes des utilisateurs.</p>
                    <p>Un utilisateur connecté pourra donner une note entre 1 et 5. L'ensemble des notes deront une moyenne, et les utilisateurs pourront voir cette moyenne sur la page de la recette.</p>
                    <p>En logique et c'est très compréhensible, un utilisateur ne pourra pas noter sa propre recette et un utilisateur ne pourra pas non plus noter deux fois la même recette.</p>
                    <p>Pour commencer à coder cette fonctionnalité, on va d'abord créer une entité "Mark" ("note" en anglais) avec la commande suivante :</p>
<pre><code>php bin/console make:entity Mark</code></pre>
                    <p>Avec les propriétés "mark" de type "integer" non nullable, "user" de type "ManyToOne" non nullable liée à l'entité "User", "recipe" de type "ManyToOne" non nullable liée à l'entité "Recipe" et "createdAt" de type "datetime_immutable" non nullable.</p>
                    <p>On va modifier l'entité "Mark" comme ceci :</p>
<pre><code>#[ORM\Entity(repositoryClass: MarkRepository::class)]
#[UniqueEntity(
    fields: ['user', 'recipe'],
    errorpath: 'user',
    message: 'Cet utilisateur a déjà noté cette recette !'
)]
class Mark
{

    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'integer')]
    #[Assert\Positive()]
    #[Assert\LessThan(6)]
    private int $mark;

    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private User $user;

    #[ORM\ManyToOne(targetEntity: Recipe::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private Recipe $recipe;

    #ORM\Column(type: 'datetime_immutable')]
    private ?\DateTimeImmutable $createdAt;

    public function __construct()
    {
        $this-&gt;createdAt = new \DateTimeImmutable();
    }

}</code></pre>
                    <p>On oublie pas de créer la migration et la migrer. Dans nos fixtures, on va rajouter les marks :</p>
<pre><code>// Marks
foreach ($recipes as $recipe) {
    for ($i = 0; $i &lt; mt_rand(0, 4); $i++) {
        $mark = new Mark();
        $mark-&gt;setMark(mt_rand(1, 5))
            -&gt;setUser($users[array_range($users)])
            -&gt;setRecipe($recipe);
        
        $manager-&gt;persist($mark);
    }
}</code></pre>
                    <p>Pour calculer la moyenne des notes de la recette, on rajouter un <span class="em">private ?float $average = null;</span> dans l'entité "Recipe" et y rajouter la fonction "getAverage" :</p>
<pre><code>/**
* Get the value of average
*/
public function getAverage()
{
    $marks = $this-&gt;marks;

    if ($marks-&gt;toArray() === []) {
        $this-&gt;average = null;
    } else {
        $total = 0;
        foreach ($marks as $mark) {
            $total += $mark-&gt;getMark();
        }
        $this-&gt;average = $total / count($marks);
    }

    return $this-&gt;average;
}</code></pre>
                    <p>On va créer un petit formulaire "MarkType" basé sur l'entité "Mark" pour pouvoir noter les recettes avec la commande suivante :</p>
<pre><code>php bin/console make:form MarkType Mark</code></pre>
                    <p>On va ensuite modifier la fonction "buildForm" de ce nouveau fichier comme ceci :</p>
<pre><code>$builder
    -&gt;add('mark', ChoiceType::class, [
        'choices' =&gt; [
            '1' =&gt; 1,
            '2' =&gt; 2,
            '3' =&gt; 3,
            '4' =&gt; 4,
            '5' =&gt; 5,
        ],
        'attr' =&gt; [
            'class' =&gt; 'form-select'
        ],
        'label' =&gt; 'Noter la recette',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Noter la recette'
    ]);</code></pre>
                    <p>On va modfifier dans le "RecipeController" la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @param Request $request
* @param MarkRepository $markRepository
* @param EntityManagerInterface $manager
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET', 'POST'])]
public function show(Recipe $recipe, Request $request, MarkRepository $markRepository, EntityManagerInterface $manager): Response
{

    $mark = new Mark();
    $form = $this-&gt;createForm(MarkType::class, $mark);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $mark-&gt;setUser($this-&gt;getUser())
            -&gt;setRecipe($recipe);

        $existingMark = $markRepository-&gt;findOneBy([
            'user' =&gt; $this-&gt;getUser(),
            'recipe' =&gt; $recipe
        ]);

        if (!$existingMark) {
            $manager-&gt;persist($mark);
        } else {
           $existingMark-&gt;setMark($form-&gt;getData()-&gt;getMark());
        }

        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre note a bien été prise en compte !');

        return $this-&gt;redirectToRoute('recipe.show', ['id' =&gt; $recipe-&gt;getId()]);
    }

    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe,
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va modifier le template lié à cette fonction pour ajouter les lignes suivantes au bon endroit :</p>
<pre><code>{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}

&lt;p&gt;La moyenne de cette recette est de {{ recipe.average|number_format(2, '.', ',') }}/5 !&lt;/p&gt;

&lt;div class="mark"&gt;
    {{ form(form) }}
&lt;/div&gt;</code></pre>
                    <h3>Étape 21 : Upload une image :</h3>
                    <p>Symfony permet la gestion de fichier avec une classe qui permet de représenter les fichiers envoyés. Cette classe contiendra une méthode <span class="html">move()</span> qui permettra de le déplacer dans le système de fichier du serveur.</p>
                    <h4>Via le formulaire :</h4>
                    <p>Du côté du formulaire, on peut définir un champs qui accueillera le fichier.</p>
<pre><code>-&gt;add('thumbnailFile', FileType::class, [
    'required' =&gt; false,
    'constraints' =&gt; [new Image()],
    'mapped' =&gt; false,
])</code></pre>
                    <p><span class="html">mapped</span> permet d'indiquer que le champs n'est pas relié à une donnée de l'entité (il n'essaiera pas de récupérer la valeur ni de trouver le setter qui correspondra).</p>
                    <p>Ensuite, du côté du contrôleur, on peut récupérer le fichier envoyé en utilisant la donnée contenue dans le formulaire.</p>
<pre><code>/** @var UploadedFile $file */
$file = $form-&gt;get('thumbnailFile')-&gt;getData(); // UploadedFile
if ($file) {
    $file-&gt;move(sprintf(
        "%s/public/image/monfichier.%s",
        $this-&gt;getParameter('kernel.project_dir'),
        $file-&gt;getClientOriginalExtension()
    ));
}</code></pre>
                    <p>Si le dossier de destination n'existe pas, il sera automatiquement créé par Symfony.</p>
                    <p>Pour afficher tous les services contenus dans les containers avec leurs valeurs associées, on peut utiliser la commande suivante :</p>
<pre><code>php bin/console debug:container --parameters</code></pre>
                    <p>À vous ensuite d'ajouter la logique pour persister le nom du fichier en base de données et gérer la suppression lorsque l'entité est supprimée. Pour interagir avec le système de fichiers, il est possible d'utiliser <a href="https://symfony.com/doc/current/components/filesystem.html" target="_blank">le composant FileSystem</a>.</p>
                    <h4>Exemple :</h4>
                    <p>Pour gérer plus facilement le système d'envoi de fichier, il est possible d'utiliser le bundle "<a href="https://github.com/dustin10/VichUploaderBundle" target="_blank">VichUploaderBundle</a>" qui permet d'attacher automatiquement un système d'upload de fichier aux événements de notre entité.</p>
                    <p>Pour uploader une image pour chaque recette, on va d'abord utiliser ce fameux bundle et on va l'installer avec la commande suivante :</p>
<pre><code>composer require vich/uploader-bundle</code></pre>
                    <p>Cette commande va générer le fichier <span class="em">`config/packages/vich_uploader.yaml`</span> qui est le fichier de configuration de ce bundle qu'on va modifier :</p>
<pre><code>vich_uploader:
    db_driver: orm
    metadata:
        type: attribute

    mappings:
        recipe_images:
            uri_prefix: /images/recette
            upload_destination: "%kernel.project_dir%/public/images/recette"
            namer: Vich\UploaderBundle\Naming\SmartUniqueNamer
</code></pre>
                    <p>On va rajouter des informations pour l'upload des images dans l'entité "Recipe" :</p>
<pre><code>// ...

use Symfony\Component\HttpFoundation\File\File;
use Vich\UploaderBundle\Mapping\Annotation as Vich;

// ...

#[Vich\Uploadable]
class Recipe
{

    // ...

    /**
    * NOTE : This is not a mapped field of entity metadata, just a simple property.
    */
    #[Vich\UploadableField(mapping: 'recipe_images', fileNameProperty: 'imageName')]
    // #[Assert\Image()]
    private ?File $imageFile = null;

    #[ORM\Column(type: 'string', nullable: true)]
    private ?string $imageName = null;

    // ...

    /**
    * If manually uploading a file (i.e. not using Symfony Form) ensure an instance
    * of 'UploadedFile' is injected into this setter to trigger the update. If this
    * bundle's configuration parameter 'inject_on_load' is set to 'true' this setter
    * must be able to accept an instnace of 'File' as the bundle will inject one here
    * during Doctrine hydration.
    *
    * @param File|\Symfony\Component\HttpFoundation\File\UpdloadedFile|null $imageFile
    */
    public function setImageFile(?File $imageFile = null): static
    {
        $this-&gt;imageFile = $imageFile;

        if (null !== $imageFile) {
            // It is required that at least one field changes if you are using doctrine
            // otherwise the event listeners won't be called and the file is lost
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        return $this;
    }

    public function getImageFile(): ?File
    {
        return $this-&gt;imageFile;
    }

    public function setImageName(?string $imageName): static
    {
        $this-&gt;imageName = $imageName;

        return $this;
    }

    // ...
    
}</code></pre>
                    <p>Dans le formulaire de création d'une recette, on va rajouter un champ "imageFile" comme ceci :</p>
<pre><code>-&gt;add('imageFile', VichImageType::class, [
    'label' =&gt; 'Image de la recette',
    'label_attr' =&gt; [
        'class' =&gt; 'form-label mt-4'
    ]
])</code></pre>
                    <p>Et dans le template du formulaire de création/modification d'une recette :</p>
<pre><code>{{ form_row(form.imageFile) }}</code></pre>
                    <p>On oublie pas de créer la migration et de la migrer. Pour afficher l'image dans le détail de la recette (show), on fait :</p>
<pre><code>&lt;div class="recipe_image"&gt;
    &lt;img style="max-width: 500px;" src="{{ vich_uploader_asset(recipe, 'imageFile') }}" alt=""&gt;
&lt;/div&gt;</code></pre>
                    <p>Si on veut récupérer le chemin du fichier depuis un contrôleur, on a un helper que l'on peut injecter :</p>
<pre><code>// ...
public function edit(// ..., UploaderHelper $helper)
{
    dd($helper-&gt;asset($recipe, 'imageFile'));
    // ...
}</code></pre>
                    <h3>Étape 22 : Formulaire de contact, email et reCaptcha v3 :</h3>
                    <p>Maintenant que l'on a vu les concepts de base, je vous propose d'attaquer un premier cas pratique : un formulaire de contact.</p>
                    <p>Ce formulaire contiendra :</p>
                    <ul>
                        <li>
                            <p>Un nom</p>
                        </li>
                        <li>
                            <p>Un prénom</p>
                        </li>
                        <li>
                            <p>Une adresse email</p>
                        </li>
                        <li>
                            <p>Un sujet</p>
                        </li>
                        <li>
                            <p>Un message</p>
                        </li>
                    </ul>
                    <p>Le nom et le prénom seront optionnels. Ils devront faire entre 2 et 50 caractères. L'adresse email sera obligatoire, comme le message. Le sujet sera lui optionnel et contiendra macimum 50 caractères.</p>
                    <p>Si l'utilisateur est connecté, alors son nom, prénom et adresse email seront automatiquement remplis.</p>
                    <p>Le formulaire contiendra également un système reCaptcha.</p>
                    <p>D'abord, on va créer une entité "Contact" avec les propriétés "fullName" de type "string" de taille "50" nullable, "email" de type "string" de taille "180" non nullable, "subject" de type "string" de taille "100" nullable, "message" de type "text" non nullable et "createdAt" de type "datetime_immutable" non nullable avec la commande :</p>
<pre><code>php bin/console make:entity Contact</code></pre>
                    <p>On va modifier cette entité pour rajouter les "Assert" :</p>
<pre><code>#[ORM\Entity(repositoryClass: ContactRepository::class)]
class Contact
{
 
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id;

    #[ORM\Column(type: 'string', length: 50, nullable: true)]
    #[Assert\Length(min: 2, max: 50)]
    private ?string $fullName = null;

    #[ORM\Column(type: 'string', length: 180)]
    #[Assert\Email()]
    #[Assert\Length(min: 2, max: 180)]
    private string $email;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    #[Assert\Length(min: 2, max: 100)]
    private ?string $subject = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank()]
    private string $message;

    #[ORM\Column(type: 'datetime_immutable')]
    #[Assert\NotNull()]
    private ?\DateTimeImmutable $createdAt;
    
    public function __construct()
    {
        $this-&gt;createdAt = new \DateTimeImmutable();
    }

    ...

}</code></pre>
                    <p>On crée donc la migration et on la migre. On va rajouter des fixtures pour les contacts :</p>
<pre><code>// Contact
for ($i = 0; $i &lt; 5; $i++) {
    $contact = new Contact();
    $contact-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setEmail($this-&gt;faker-&gt;-&gt;email())
        -&gt;setSubject('Demande n°' . ($i + 1))
        -&gt;setMessage($this-&gt;faker-&gt;text());

    $manager-&gt;persist($contact);
}</code></pre>
                    <p>Si on ne veut pas sauvegarder en base de données, on ne crée pas une entité mais bien un objet "ContactFormDTO" pour représenter les données de ce formulaire ("DTO" est l'abréviation de "Data Transfer Object") :</p>
<pre><code>&lt;?php

    namespace App\DTO;

    use Symfony\Component\Validator\Constraints as Assert;

    class ContactDTO
    {

        #[Assert\NotBlank]
        #[Assert\Length(min: 3, max: 200)]
        public string $name = '';

        #[Assert\NotBlank]
        #[Assert\Email]
        public string $email = '';

        #[Assert\NotBlank]
        #[Assert\Length(min: 3, max: 200)]
        public string $message = '';

    }

?&gt;</code></pre>
<pre><code>&lt;?php

    namespace App\Form;

    namespace App\Form;

    use App\DTO\ContactDTO;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\EmailType;
    use Symfony\Component\Form\Extension\Core\Type\TextareaType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\OptionsResolver;

    use Symfony\Component\Validator\Constraints as Assert;

    class ContactType AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                -&gt;add('name', TextType::class, [
                    'empty_data' =&gt; '',
                ])
                -&gt;add('email', EmailType::class, [
                    'empty_data' =&gt; '',
                ])
                -&gt;add('message', TextareaType::class, [
                    'empty_data' =&gt; '', 
                ])
                -&gt;add('save', SubmitType::class, [
                    'label' =&gt; 'Envoyer',
                ]);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver-&gt;setDefaults([
              'data_class' =&gt; ContactDTO::class,  
            ]);
        }
    }

?&gt;</code></pre>
                    <p>On va créer un contrôleur "ContactController" avec la commande :</p>
<pre><code>php bin/console make:controller ContactController</code></pre>
                    <p>On va créer un formulaire de contact nommé "ContactType" avec la commande :</p>
<pre><code>php bin/console make:form ContactType Contact</code></pre>
                    <p>Et on va modifier sa fonction "buildForm" :</p>
<pre><code>$builder
    -&gt;add('fullName', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'label' =&gt; 'Nom / Prénom',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('email', EmailType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '180',
        ],
        'label' =&gt; 'Adresse email',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank(),
            new Assert\Email(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 180])
        ]
    ])
    -&gt;add('subject', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '100',
        ],
        'label' =&gt; 'Sujet',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 100])
        ]
    ])
    -&gt;add('message', TextareaType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
        ],
        'label' =&gt; 'Message',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank()
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Soumettre ma demande'
    ]);</code></pre>
                    <p>On va modifier la fonction "index" de notre contrôleur pour ajouter le formulaire :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Pour envoyer un email à chaque soumission du formulaire de contact, on va utiliser le composant "Mailer" avec le fichier de configuration <span class="em">`config/packages/mailer.yaml`</span>.</p>
                    <p>Pour tester l'envoi des emails en local, vous pouvez utiliser un de ces outils :</p>
                    <ul>
                        <li>
                            <p><a href="https://github.com/axllent/mailpit" target="_blank">Mailpit</a>, disponible sous forme de simple exécutable.</p>
                        </li>
                        <li>
                            <p><a href="https://github.com/maildev/maildev" target="_blank">Maildev</a>, disponible sous forme d'image Docker.</p>
                        </li>
                        <li>
                            <p><a href="https://mailtrap.io/" target="_blank">Mailtrap</a> qui est un service tiers avec une formule gratuite limitée à 100 emails / mois.</p>
                        </li>
                    </ul>
                    <p>Dans le dossier `<span class="em">bin/</span>` de notre projet, on va mettre l'exécutable de Mailpit par exemple au même niveau que <span class="em">console</span> et <span class="em">phpunit</span>. On peut le lancer avec la commande :</p>
<pre><code>./bin/mailpit</code></pre>
                    <p>Cette commande va automatiquement démarrer un serveur sur le port 8025, c'est-à-dire accessible via l'url <a href="http://localhost:1025" target="_blank">http://localhost:1025</a>, avec la variable d'environnement <span class="em">MAILER_DSN</span> à la valeur de l'url du serveur.</p>
                    <p>Dans notre fichier ".env", on doit définir le système de transport d'email via la variable "MAILER_DSN" avec la syntaxe suivante :</p>
<pre><code>MAILER_DSN=smtp://user:pass@smtp.example.com:port</code></pre>
                    <p>Et on va modifier la configuration <span class="em">messenger.yaml</span> pour que l'envoi des emails se fasse de manière synchrone.</p>
<pre><code>framework:
    messenger:
        failure_transport: failed

        transports:
            async:
                dsn: '%env(MESSENGER_TRANSPORT_DSN)%'
                options:
                    use_notify: true
                    check_delayed_interval: 60000
                retry_strategy:
                    max_retries: 3
                    multiplier: 2
            failed: 'doctrine://default?queue_name=failed'
            sync: 'sync://'
        
        routing:
            Symfony\Component\Mailer\Messenger\SendEmailMessage: sync
            Symfony\Component\Notifier\Message\ChatMessage: sync
            Symfony\Component\Notifier\Message\SmsMessage: sync
</code></pre>
                    <p><a href="https://symfony.com/doc/current/mailer.html" target="_blank">Documentation sur le composant Mailer</a></p>
                    <p>Ensuite, on va modifier la fonction "index" de notre contrôleur :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager, MailerInterface $mailer): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        // Email
        $email = (new TemplatedEmail())
            -&gt;from($contact-&gt;getEmail())
            -&gt;to('admin@symrecipe.com')
            -&gt;subject($contact-&gt;getSubject())
            -&gt;htmlTemplate('emails/contact.html.twig')
            // pass variables (name =&gt; value)to the template
            -&gt;context([
                'contact' =&gt; $contact
            ]);

        $mailer-&gt;send($email);

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va créer le dossier "emails" et dedans le fichier "contact.html.twig" avec le contenu suivant :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
     &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Demande de {{ contact.fullName }}&lt;/h1&gt;

        &lt;p&gt;Email : {{ contact.email }}&lt;/p&gt;
        &lt;p&gt;Sujet : {{ contact.subject }}&lt;/p&gt;
        &lt;p&gt;Message :&lt;/p&gt;
        &lt;div&gt;
            {{ contact.message|raw }}
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>On va mettre en place le reCaptcha qui, d'après Google, est la façon ultime de lutter contre les robots. On va utiliser le bundle "KarserRecaptcha3Bundle" qu'on va installer avec la commande :</p>
<pre><code>composer require karser/karser-recaptcha3-bundle</code></pre>
                    <p>On va dire "non" au "google/recaptcha" et "oui" au "karser/karser-recaptcha3-bundle". Dans son fichier de configuration <span class="em">`config/packages/karser_recaptcha3.yaml`</span>, on peut voir qu'il faut rajouter les variables "RECAPTCHA3_KEY" et "RECAPTCHA3_SECRET" dans notre fichier ".env".</p>
                    <p>Dans notre formulaire "ContactType", on va rajouter le captcha comme ceci :</p>
<pre><code>-&gt;add('captcha', Recaptcha3Type::class, [
    'constraints' =&gt; new Recaptcha3(),
    'action_name' =&gt; 'contact',
])</code></pre>
                    <p>Si on veut contacter un service en particulier, on peut rajouter une propriété <span class="em">service</span> dans notre DTO :</p>
<pre><code>#[Assert\NotBlank]
public string $service = '';</code></pre>
                    <p>On va ensuite ajouter dans le formulaire un <span class="em">select</span> pour sélectionner le bon service, donc dans notre <span class="em">ContactType</span> on va rajouter un <span class="em">ChoiceType</span> dans le <span class="em">builder</span> du formulaire :</p>
<pre><code>-&gt;add('service', ChoiceType::class, [
    'choices' =&gt; [
        'Compta' =&gt; 'compta@demo.com',
        'Support' =&gt; 'support@demo.com',
        'marketing' =&gt; 'marketing@demo.com',
    ],
])</code></pre>
                    <p>On peut également récupérer les erreurs lors de l'envoi d'un email :</p>
<pre><code>try {
    $email = (new TemplatedEmail())
        -&gt;to($contact-&gt;service)
        -&gt;from($contact-&gt;email)
        -&gt;subject('Demande de contact')
        -&gt;htmlTemplate('emails/contact.html.twig')
        -&gt;context(['contact' =&gt; $contact]);

    $mailer-&gt;sender($email);
    $this-&gt;addFlash('success', 'Votre email a bien été envoyé !');
    return $this-&gt;redirectToRoute('contact.index');
} catch (\Exception $e) {
    $this-&gt;addFlash('danger', 'Impossible d\'envoyer votre email !');
}</code></pre>
                    <h3>Étape 23 : Les services :</h3>
                    <p>Le système de services et d'injection de dépendances de Symfony est un outil puissant qui permet de découpler les composants de son application et de les rendre plus testables et maintenables.</p>
                    <p>Les services sont simplement des objets PHP qui vont remplir une fonction particulière. Précédemment, on a déjà utilisé des services sans le savoir comme le service "EntityManager" ou encore le service "Mailer".</p>
                    <p>Tous ces services sont à l'intérieur d'une classe PHP qui est assez spéciale et qui s'appelle le container de services et va centraliser tous les services au sein de notre application Symfony.</p>
                    <p>En gros, un service est un objet qui fournit une fonctionnalité spécifique à l'application. Ce n'est qu'une classe qui peut être plus ou moins complexe en fonction de la situation.</p>
                    <p>Au coeur de Symfony se cache un conteneur d'inversion de contrôle (IoC) qui permet de gérer les services de votre application. C'est un objet qui permet de construire des objets en fonction des besoins en indexant les objets avec une clef particulière.</p>
                    <p>Si on regarde le code source de la fonction <span class="html">render()</span> que l'on utilise depuis le début de ce cours, on retrouve le code suivant :</p>
<pre><code>$twig = $this-&gt;container-&gt;get('twig');</code></pre>
                    <p>Symfony demande au conteneur une instance de l'objet Twig qui gère le rendu HTML.</p>
                    <h4>L'injection de dépendances :</h4>
                    <p>L'injection de dépendances est un principe de conception qui consiste à fournir aux objets les dépendances dont ils ont besoin pour fonctionner. Cela se fait en injectant les dépendances dans le constructeur de l'objet (ou plus rarement via un setter).</p>
<pre><code>class MailNotification
{

    public function __construct(private readonly MailerInterface $mailer)
    {

    }

    // ...

}</code></pre>
                    <p>L'avantage est que le conteneur va être capable de résoudre les dépendances d'un objet automatiquement et injecter les services nécessaires automatiquement.</p>
                    <p>Pour visualiser tous les services disponibles par défaut et câblés automatiquement, on utilise la commande :</p>
<pre><code>php bin/console debug:autowiring --all</code></pre>
                    <p>Si on cherche un service en particulier, on peut utiliser :</p>
<pre><code>php bin/console debug:autowiring mailer.mailer</code></pre>
                    <p>Les contrôleurs sont des classes spéciales qui bénéficient aussi de ce système d'injection dans leurs actions. C'est ce qui permet par exemple de récupérer le manageur d'entité ou les repositories.</p>
<pre><code>&lt;?php

    namespace App\Controller\Admin;

    use App\Form\RecipeType;
    use App\Repository\RecipeRepository;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\response;
    use Symfony\Component\Routing\Attribute\Route;

    #[Route('/admin/recettes', name: 'admin.recipe.')]
    class RecipeController extends AbstractController
    {

        #[Route('/', name: 'index')]
        public function index(
            RecipeRepository $repository,
            Request $request,
        ): Response
        {
            $page = $request-&gt;query-&gt;getInt('page', 1);
            $recipes = $repository-&gt;paginateRecipes($page);
            return $this-&gt;render('admin/recipe/index.html.twig', [
                'recipes' =&gt; $recipes,
            ]);
        }
    }
    
?&gt;</code></pre>
                    <p><a href="https://symfony.com/doc/current/service_container.html" target="_blank">Documentation sur le Service Container</a></p>
                    <p>Ce qui est également très intéressant, c'est que nous pouvons également nos propres services car ça permettra d'utiliser une fonctionnalité précise à plusieurs endroits de notre code.</p>
                    <p>Par exemple, chaque fichier a son rôle à jouer et il faut un service email pour être cohérent avec ce système car actuellement l'envoi est géré au sein du contrôleur et on doit mettre le moins de logique dans le contrôleur.</p>
                    <p>On va créer le dossier <span class="em">`src/Service`</span> et dedans on y insère le fichier "MailService.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Symfony\Bridge\Twig\Mime\TemplatedEmail;
    use Symfony\Component\Mailer\MailerInterface;

    class MailService
    {

        /**
        * @var MailerInterface
        */
        private MailerInterface $mailer;

        public function __construct(MailerInterface $mailer)
        {
            $this-&gt;mailer = $mailer;
        }

        public function sendEmail(string $from, string $subject, string $htmlTemplate, array $context, string $to = 'admin@symrecipe.com'): void
        {
            $email = (new TemplatedEmail())
                -&gt;from($from)
                -&gt;to($to)
                -&gt;subject($subject)
                -&gt;htmlTemplate($htmlTemplate)
                -&gt;context($context);

            $this-&gt;mailer-&gt;send($email);
        }
    }

?&gt;</code></pre>
                    <p>On va de nouveau modifier la fonction "index" de notre contrôleur pour remplacer notre "MailerInterface" par notre "MailService" :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager, MailService $mailService): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        // Email
        $mailService-&gt;sendEmail(
            $contact-&gt;getEmail(),
            $contact-&gt;getSubject(),
            'emails/contact.html.twig',
            ['contact' =&gt; $contact]
        );

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <h3>Étape 24 : Administration avec EasyAdmin :</h3>
                    <p>Pour utiliser des interfaces d'Administration simple, on va utiliser le bundle "EasyAdmin" et on va l'installer avec la commande :</p>
<pre><code>composer require easycorp/easyadmin-bundle</code></pre>
                    <p>Pour bien commencer, la première étape est les dashboards qui est le point d'entré de la partie administrateur. Pour créer notre dashboard, on utilise la commande suivante :</p>
<pre><code>php bin/console make:admin:dashboard</code></pre>
                    <p>On le nomme "DashboardController" et on le stocke dans le dossier <span class="em">`src/Controller/Admin`</span>. On peut voir que cette classe étend de <span class="em">AbstractDashboardController</span> qui lui-même étend de <span class="em">AbstractController</span>. On y modifie sa fonction "index" :</p>
<pre><code>#[Route('/admin', name: 'admin')]
public function index(): Response
{
    return $this-&gt;render('admin/dashboard.html.twig');
}</code></pre>
                    <p>On oublie pas de créer le dossier <span class="em">`templates/admin`</span> et dedans le fichier "dashboard.html.twig" :</p>
<pre><code>{% extends "@EasyAdmin/pahe/content.html.twig" %}

{% block content %}
    &lt;h1&gt;Bienvenue au sein de l'administration de SymRecipe&lt;/h1&gt;
{% endblock %}</code></pre>
                    <p>On va configurer le dashboard en modifiant la fonction "configureDashboard" de notre contrôleur :</p>
<pre><code>public function configureDashboard(): Dashboard
{
    return Dashboard::new()
        -&gt;setTitle('SymRecipe - Administration')
        -&gt;renderContentMaximized();
}</code></pre>
                    <p>On va configurer les éléments du menu du Dashboard dans la fonction "configureMenuItems" de notre contrôleur :</p>
<pre><code>public function configureMenuItems(): iterable
{
    yield MenuItem::linkToDashBoard('Dashboard', 'fa fa-home');
    yield MenuItem::linkToCrud('Utilisateurs', 'fas fa-user', User::class);
}</code></pre>
                    <p>Si on relance la page, on va voir qu'il y a une erreur car il n'y a pas de "UserCrudController".</p>
                    <p>Un "CRUD controller" est un contrôleur qui va nous fournir les opérations de base d'un CRUD classique pour les entités. Il étend de <span class="em">AbstractCrudController</span> qui étend lui-même de <span class="em">AbstractController</span>. Pour faire ce fameux "CRUD controller", on utilise la commande suivante en sélectionnant l'entité sur lequel on veut le faire :</p>
<pre><code>php bin/console make:admin:crud</code></pre>
                    <p>Il sera généré dans le dossier <span class="em">`src/Controller/Admin`</span> avec le namespace "<span class="em">App\Controller\Admin</span>".</p>
                    <p>On va rajouter la fonction "configureCrud" dans notre contrôleur :</p>
<pre><code>public function configureCrud(Crud $crud): Crud
{
    return $crud
        -&gt;setEntityLabelInPlural('Utilisateurs')
        -&gt;setEntityLabelInSingular('Utilisateur');
        -&gt;setPageTitle('index', 'Symrecipe - Administration des utilisateurs')
        -&gt;setPaginatorPageSize(10);
}</code></pre>
                    <p>On va également configurer les champs à afficher dans le tableau dans la fonction "configureFields" de notre contrôleur :</p>
<pre><code>public function configureFields(string $pageName): iterable
{
    return [
        IdField::new('id')-&gt;hideOnForm(),
        TextField::new('fullName'),
        TextField::new('pseudo'),
        TextField::new('email')-&gt;hideOnForm(),
        ArrayField::new('roles')-&gt;hideOnIndex(),
        DteTimeField::new('createdAt')-&gt;hideOnForm()
    ];
}</code></pre>
                    <p>Pour le champ textarea pour le message de contact, on doit mettre en place un WYSIWYG (abréviation de "What You See Is What You Get", c'est-à-dire litéralement "ce que vous voyez est ce que vous obtenez"). On va installer le bundle "CKEditor" avec la commande :</p>
<pre><code>composer require friendsofsymfony/ckeditor-bundle</code></pre>
                    <p>Ensuite, on va installer "drop" de CKEditor avec la commande :</p>
<pre><code>php bin/console ckeditor:install</code></pre>
                    <p>On va installer les assets de CKEditor avec la commande :</p>
<pre><code>php bin/console assets:install public</code></pre>
                    <p>Enfin, on va modifier notre fichier de configuration <span class="em">`config/packages/fos_ckeditor.yaml`</span> :</p>
<pre><code>fos_ck_editor:
    configs:
        main_config:
            toolbar:
                - {
                    name: "styles",
                    items:
                        [
                            "Bold",
                            "Italic",
                            "Underline",
                            "Strike",
                            "Blockquote",
                            "-",
                            "Link",
                            "-",
                            "RemoveFormat",
                            "-",
                            "NumberedList",
                            "BulletedList",
                            "-",
                            "Outdent",
                            "Indent",
                            "-",
                            "-",
                            "JustifyLeft",
                            "JustifyCenter",
                            "JustifyRight",
                            "JustifyBlock",
                            "-",
                            "Image",
                            "Table",
                            "-",
                            "Styles",
                            "Format",
                            "Font",
                            "FontSize",
                            "-",
                            "TextColor",
                            "BGColor",
                            "Source",
                        ],
                }</code></pre>
                    <p>On va modifier notre ContactCrudController avec les fonctions suivantes :</p>
<pre><code>public function configureCrud(Crud $crud): Crud
{
    return $crud
        -&gt;setEntityLabelInSingular('Demande de contact')
        -&gt;setEntityLabelInPlural('Demandes de contact')
        -&gt;setPageTitle('index', 'SymRecipe - Administration des demandes de contact')
        -&gt;setPaginatorPageSize(20)
        -&gt;addFormTheme('@FOSCKEditor/Form/ckeditor_widget.html.twig');
}

public function configureFields(string $pageName): iterable
{
    return [
        IdField::new('id')-&gt;hideOnForm(),
        TextField::new('fullName'),
        TextField::new('email'),
        TextareaField::new('message')-&gt;setFormType(CKEditor::class)-&gt;hideOnIndex(),
        DateTimeField::new('createdAt')-&gt;hideOnForm()
    ];
}</code></pre>
                    <p>On va mettre en place la sécurité en ajoutant un admin dans les fixtures :</p>
<pre><code>$admin = new User();
$admin-&gt;setFullName('Administrateur de SymRecipe')
    -&gt;setPseudo(null)
    -&gt;setEmail('admin@symrecipe.fr')
    -&gt;setRoles(['ROLE_USER', 'ROLE_ADMIN'])
    -&gt;setPlainPassword('password');

$user[] = $admin;
$manager-&gt;persist($admin);</code></pre>
                    <p>On va rajouter le "IsGranted" sur les fonctions du DashboardController pour qu'il soit accessible aux utilisateurs ayant le rôle "ROLE_ADMIN" :</p>
<pre><code>#[IsGranted('ROLE_ADMIN')]</code></pre>
                    <p>Dans notre navbar, on peut ajouter le lien vers le dashboard :</p>
<pre><code>{% if 'ROLE_ADMIN' in app.user.roles %}
    &lt;a class="dropdown-item" href="{{ path('admin') }}"&gt;Administration&lt;/a&gt;
    &lt;div class="dropdown-divider"&gt;&lt;/div&gt;
{% endif %}</code></pre>
                    <h3>Étape 25 : Tester notre application :</h3>
                    <p>Dans cette partie, on va mettre en place des tests unitaires et des tests fonctionnels. En programmation, le test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme. Les tests fonctionnels sont destinés à s'assurer que, dans le contexte d'utilisation réelle, le comportement fonctionnel obtenu est bien conforme avec celui attendu.</p>
                    <p>Pour ce faire, Symfony nous propose d'utiliser le framework <span class="em">PHPUnit</span>. Pour exécuter les tests, on utilise la commande :</p>
<pre><code>php bin/phpunit</code></pre>
                    <p>Pour séparer les deux types de tests, je vous propose de créer deux dossiers différents dans le dossier "tests" : "Unit" et "Functional". On va ensuite créer notre premier test unitaire avec la commande :</p>
<pre><code>php bin/console make:test TestCase \App\Tests\Unit\BasicTest</code></pre>
                    <p>On va créer notre premier test fonctionnel avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\BasicTest</code></pre>
                    <p>On va copier les variables "DATABASE_URL" et "MAILER_DSN" dans le fichier ".env.test" et on va mettre la variable "RECAPTCHA3_ENABLED" à "0". On va créer la base de données de test avec la commande :</p>
<pre><code>php bin/console d:d:c --env=test</code></pre>
                    <p>On va migrer toutes les migrations dans cette nouvelle base de données avec la commande :</p>
<pre><code>php bin/console d:m:m --env=test</code></pre>
                    <p>On va loader les fixtures dans notre base de données avec la commande :</p>
<pre><code>php bin/console d:f:l --env=test</code></pre>
                    <p>Maintenant que cette base de données est créée, on va enfin faire les différents tests en commençant par les tests unitaires. Pour tester l'entité "Recipe", on utilise la commande suivante :</p>
<pre><code>php bin/console make:test KernelTestCase \App\Tests\Unit\RecipeTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

        namespace App\Tests\Unit;

        use App\Entity\Recipe;
        use App\Entity\User;
        use App\Entity\Mark;
        use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

        class RecipeTest extends KernelTestCase
        {
            public function getEntity(): Recipe
            {
                return (new Recipe())-&gt;setName('Recipe #1')
                    -&gt;setDescription('Description #1')
                    -&gt;setIsFavorite(true)
                    -&gt;setCreatedAt(new \DateTimeImmutable())
                    -&gt;setupdatedAt(new \DateTimeImmutable());
            }

            public function testEntityIsValid(): void
            {
                self::bootKernel();
                $container = static::getContainer();

                $recipe = $this-&gt;getEntity();

                $errors = $container-&gt;get('validator')-&gt;validate($recipe);

                $this-&gt;assertCount(0, $errors);
            }
        }

        public function testInvalidName()
        {
            self::bootKernel();
            $container = static::getContainer();

            $recipe = $this-&gt;getEntity();
            $recipe-&gt;setName('');

            $errors = $container-&gt;get('validator')-&gt;validate($recipe);

            $this-&gt;assertCount(2, $errors);
        }

        public function testGetAverage()
        {
            $recipe = $this-&gt;getEntity();
            $user = static::getContainer()-&gt;get('doctrine.orm.entity_manager')-&gt;find(User::class, 1);

            for ($i = 0; $i &lt; 5; $i++) {
                $mark = new Mark();
                $mark-&gt;setMark(2)
                    -&gt;setUser($user)
                    -&gt;setRecipe($recipe);
                
                $recipe-&gt;addMark($mark);
            }

            $this-&gt;assertTrue(2.0 === $recipe-&gt;getAverage());
        }
?&gt;</code></pre>
                    <p>Pour les tests fonctionnels, on va tester si on arrive sur telle ou telle page, si le formulaire est valide, etc. On va faire un nouveau test fonctionnel avec la commande suivante :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\HomePageTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class HomePageTest extends WebTestCase
    {
        public function testSomething(): void
        {
            $client = static::createClient();
            $crawler = $client-&gt;request('GET', '/');

            $this-&gt;assertResponseIsSuccessful();

            $button = $crawler-&gt;filter('.btn.btn-primary.btn-lgz');
            $this-&gt;assertEquals(1, count($button));

            $recipes = $crawler-&gt;filter('.recipes .card');
            $this-&gt;assertEquals(3, count($recipes));

            $this-&gt;assertSelectorTextContains('h1', 'Bienvenue sur SymRecipe');
        }
    }

?&gt;</code></pre>
                    <p>Pour le test fonctionnel pour le formulaire de contact dans notre "App\Tests\Functional\ContactTest.php", on va avoir le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Response;

    class ContactTest extends WebTestCase
    {
        public function testIfSubmitContactFormIsSuccessful(): void
        {
            $client = static::createClient();
            $crawler = $client-&gt;request('GET', '/contact');

            $this-&gt;assertResponseIsSuccessful();
            $this-&gt;assertSelectorTextContains('h1', 'Formulaire de contact');

            // Récupérer le formulaire
            $submitButton = $crawler-&gt;selectButton('Soumettre ma demande');
            $form = $submitButton-&gt;form();

            $form["contact[fullName]"] = "Jean Dupont";
            $form["contact[email]"] = "jd@symrecipe.com";
            $form["contact[subject]"] = "Test";
            $form["contact[message]"] = "Test";

            // Soumettre le formulaire
            $client-&gt;submit($form);

            // Vérifier le statut HTTP
            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            // Vérifier l'envoi du mail
            $this-&gt;assertEmailCount(1);

            $client-&gt;followRedirect();

            // Vérifier la présence du message de succès
            $this-&gt;assertSelectorTextContains('div.alert.alert-success.mt-4', 'Votre demande a été envoyée avec succès !');
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on va créer un test fonctionnel pour tester la logique de connexion avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\LoginTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Response;

    class LoginTest extends WebTestCase
    {
        public function testIfLoginIsSuccessful(): void
        {
            $client = static::createClient();

            /** @var urlGeneratorInterface $urlGenerator */
            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            $crawler = $client-&gt;request('GET', $urlGenerator-&gt;generate('security.login'));

            $form = $crawler-&gt;filter("form[name=login]")-&gt;form([
                "_username" =&gt; "admin@symrecipe.fr",
                "_password" =&gt; 'password',
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertRouteSame('home.index');
        }
    }

    public function testIfLoginFailedWhenPasswordIsWrong(): void
    {
        $client = static::createClient();

            /** @var urlGeneratorInterface $urlGenerator */
            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            $crawler = $client-&gt;request('GET', $urlGenerator-&gt;generate('security.login'));

            $form = $crawler-&gt;filter("form[name=login]")-&gt;form([
                "_username" =&gt; "admin@symrecipe.fr",
                "_password" =&gt; 'password_',
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertRouteSame('security.login');

            $this-&gt;assertSelectorTextContains("div.alert-danger", "Invalid credentials.");
    }
?&gt;</code></pre>
                    <p>On va créer un "Makefile" avec toutes les commandes à faire, c'est-à-dire avec le contenu suivant :</p>
<pre><code>.PHONY: tests
tests:
    php bin/console d:d:d --force --if-exists --env=test
    php bin/console d:d:c --env=test
    php bin/console d:m:m --no-interaction --env=test
    php bin/console d:f:l --no-interaction --env=test
    php bin/phpunit --testdox tests/Unit/
    php bin/phpunit --testdox tests/Functional/</code></pre>
                    <p>On exécute le "Makefile" avec la commande :</p>
<pre><code>make tests</code></pre>
                    <p>On peut également faire des tests sur un CRUD simple, comme par exemple le CRUD d'un ingrédient avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\IngredientTest</code></pre>
                    <p>On peut modifier le contenu de notre classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use App\Entity\User;
    use App\Entity\Ingredient;
    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class IngredientTest extends WebTestCase
    {
        public function testIfCreateIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            // Recup urlGenerator
            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            // Recup entity manager
            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);

            $client-&gt;loginUser($user);

            // Se rendre sur la page de création d'un ingrédient
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.new'));

            // Gérer le formulaire
            $form = $crawler-&gt;filter('form[name=ingredient]')-&gt;form([
                'ingredient[name]' =&gt; "Un ingrédient",
                'ingredient[price]' =&gt; floatval(33)
            ]);

            $client-&gt;submit($form);

            // Gérer la redirection
            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            // Gérer l'alert box et la route
            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été créé avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfListIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);

            $client-&gt;loginUser($user);

            $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.index'));

            $this-&gt;assertResponseIsSuccessful();

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfUpdateAnIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);
            
            $ingredient = $entityManager-&gt;getRepository(Ingredient::class)-&gt;findOneBy([
            'user' =&gt; $user
            ]);
            
            $client-&gt;loginUser($user);
            
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.edit', [
                'id' =&gt; $ingredient-&gt;getId()
            ]));

            $this-&gt;assertResponseIsSuccessful();

            $form = $crawler-&gt;filter('form[name=ingredient]')-&gt;form([
                'ingredient[name]' =&gt; "Un ingrédient 2",
                'ingredient[price]' =&gt; floatval(34)
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été modifié avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfDeleteAnIngredient(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;get('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);
            
            $ingredient = $entityManager-&gt;getRepository(Ingredient::class)-&gt;findOneBy([
                'user' =&gt; $user
            ]);
            
            $client-&gt;loginUser($user);
            
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.delete', [
                'id' =&gt; $ingredient-&gt;getId()
            ]));

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été supprimé avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }
    }

?&gt;</code></pre>
                    <p>On peut aussi tester le CRUD des ingrédients via EasyAdmin. On va créer un nouveau dossier "Admin" dans le dossier "tests/Functional" et on va créer le fichier "ContactTest.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Tests\Funtional\Admin;

    use App\Entity\User;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Request;

    class ContactTest extends WebTestCase
    {
        public function testCrudIsHere(): void
        {
            $client = static::createClient();

            /** @var EntityManagerInterface $entityManager */
            $entityManager = $client-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');

            $user = $entityManager-&gt;getRepository(User::class)-&gt;findOneBy(['id' =&gt; 1]);

            $client-&gt;loginUser($user);

            $client-&gt;request(Request::METHOD_GET, '/admin');

            $this-&gt;assertResponseIsSuccessful();

            $crawler = $client-&gt;clickLink('Demandes de contact');

            $this-&gt;assertResponseIsSuccessful();

            $client-&gt;click($crawler-&gt;filter('.action-new')-&gt;link());

            $this-&gt;assertResponseIsSuccessful();

            $client-&gt;request(Request::METHOD_GET, '/admin');

            $client-&gt;click($crawler-&gt;filter('.action-edit')-&gt;link());

            $this-&gt;assertResponseIsSuccessful();
        }
    }

?&gt;</code></pre>
                    <h3>Étape 26 : Créer une commande :</h3>
                    <p>Dans cette partie, on va pouvoir créer un administrateur en ligne de commandes. Cela permettra d'ajouter des administrateurs par la suite si le site se développe. Donc, on va créer une commande "app:create-administrator" avec la commande suivante :</p>
<pre><code>php bin/console make:command app:create-administrator</code></pre>
                    <p>Cela génèrera le fichier <span class="em">`src/Command/CreateAdministratorCommand.php`</span> avec le contenu modifié suivant :</p>
<pre><code>&lt;?php

    namespace App\Command;

    use App\Entity\User;
    use Doctrine\ORM\EntityManagerInterface
    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputArgument;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;
    use Symfony\Component\Console\Question\Question;
    use Symfony\Component\Console\Style\SymfonyStyle;

    #[AsCommand(
        name: 'app:create-administrator',
        description: 'Create an Administrator',
    )]
    class CreateAdministratorCommand extends Command
    {
        private EntityManagerInterface $entityManager;

        public function __construct(EntityManagerInterface $entityManager)
        {
            parent::__construct('app:create-administrator');

            $this-&gt;entityManager = $entityManager;
        }

        protected function configure(): void
        {
            $this
                -&gt;addArgument('full_name', InputArgument::OPTIONAL, 'Full Name')
                -&gt;addArgument('email', InputArgument::OPTIONAL, 'Email')
                -&gt;addArgument('password', InputArgument::OPTIONAL, 'Password');
        }

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $helper = $this-&gt;getHelper('question');
            $io = new SymfonyStyle($input, $output);

            $fullName = $input-&gt;getArgument('full_name');
            if (!$fullName) {
                $question = new Question('Quel est le nom de l\'adminstrateur : ');
                $fullName = $helper-&gt;ask($input, $output, $question);
            }

            $email = $input-&gt;getArgument('email');
            if (!$email) {
                $question = new Question('Quel est l\'email de ' . $fullName . ' : ');
                $email = $helper-&gt;ask($input, $output, $question);
            }

            $plainPassword = $input-&gt;getArgument('password');
            if (!$plainPassword) {
                $question = new Question('Quel est le mot de passe de ' . $fullName . ' : ');
                $plainPassword = $helper-&gt;ask($input, $output, $question);
            }

            $user = (new User())-&gt;setFullName($fullName)
                -&gt;setEmail($email)
                -&gt;setPlainPassword($plainPassword)
                -&gt;setRoles(['ROLE_USER', 'ROLE_ADMIN']);

            $this-&gt;entityManager-&gt;persist($user);
            $this-&gt;entityManager-&gt;flush();

            $io-&gt;success('Le nouvel administrateur a été créé !');

            return Command::SUCCESS;
        }
    }

?&gt;</code></pre>
                    <p>La commande devient donc ceci :</p>
<pre><code>php bin/console app:create-administrator</code></pre>
                    <p>Et avec les arguments :</p>
<pre><code>php bin/console app:create-administrator "Emilien" "emilien@symrecipe.fr" "password"</code></pre>
                    <h3>Étape 27 : Créer un filtre Twig :</h3>
                    <p>Par exemple si la recette a un temps en minutes avec une valeur de "1005", on pourrait afficher le temps en heures/minutes et donc créer/utiliser un filtre Twig (ou encore "extension Twig").</p>
                    <p>Pour cela, dans le dossier "src", on crée le dossier "Twig" et on y insère le fichier "AppExtension.php" ou on utilise la commande suivante :</p>
<pre><code>php bin/console make:twig-extension AppExtension</code></pre>
                    <p>On va modifier son contenu comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Twig;

    use Twig\Extension\AbstractExtension;
    use Twig\TwigFilter;

    class AppExtension extends AbstractExtension
    {
        public function getFilters(): array
        {
            return [
                new TwigFilter('min_to_hour', [$this, 'minutesToHours']);  
            ];
        }

        public function minutesToHours($value)
        {
            if ($value &lt; 60 || !$value) {
                return $value;
            }

            $hours = floor($value / 60);
            $minutes = $value % 60;

            if ($minutes &lt; 10) {
                $minutes = '0' . $minutes;
            }

            $time = sprintf('%sh%s'; $hours, $minutes);

            return $time;
        }
    }
?&gt;</code></pre>
                    <p>Une fois le filtre créé, dans notre template, on peut l'utiliser comme ceci :</p>
<pre><code>&lt;p&gt;Temps : {{ recipe.time|min_to_hour }}&lt;/p&gt;</code></pre>
                    <h3>Étape 28 : Mise en place d'un cache pour notre application :</h3>
                    <p>Un cache va permettre de stocker les pages de nombreux sites Web, c'est-à-dire que les pages peuvent toujours être consultées même si le site Web d'origine est hors ligne.</p>
                    <p>Dans le "Cache Component" qui couvre les besoins simples et plus avancés au niveau du cache, on a deux grandes familles : le "Cache Contracts" qui est un sytème plus simple et plus puissant mettant en cache des valeurs appelées ou recalculées très fréquemment, et le "PSR-6 Caching" qui est un système générique de cache basé sur des systèmes de "pools" et de "items".</p>
                    <p>Dans notre application, comme on affiche très souvent les recettes publiques, ce sera intéressant de mettre un "Cache Contracts" dessus.</p>
                    <p>Dans notre fonction "findPublicRecipe" de notre "RecipeRepository", on a un "sleep(3);". Dans le "RecipeController", on va ajouter le cache dans la fonction "indexPublic" comme ceci :</p>
<pre><code>#[Route('/recette/communaute', 'recipe.community', methods: ['GET'])]
public function indexPublic(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $cache = new FilesystemAdapter();
    $data = $cache-&gt;get('recipes', function(ItemInterface $item) use ($repository) {
        $item-&gt;expiresAfter(15);
        return $repository-&gt;findPublicRecipe(null);
    });

    $recipes = $paginator-&gt;paginate(
        $data,
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe/commuity.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <h3>Webpack Encore :</h3>
                    <p>Symfony nous permet de manager correctement nos fichiers CSS et JavaScript, notamment avec "Webpack Encore". Cela va nous permettre de rendre notre travail plus agréable et plus qualicatif au niveau des fichiers de style et des fichiers de script. Ça va nous éviter d'avoir des fichiers dans le dossier "public" et de les inclure un à un.</p>
                    <p>D'après Wikipédia, <q>Webpack est un modules bundle open source. Son objectif principal est de regrouper des fichiers JavaScript pour les utiliser dans un navigateur. Cet outil est également capable de transformer, regrouper ou empaqueter à peu près n'importe quelle ressource."</q></p>
                    <p>Webpack Encore est un moyen plus simple d'intégrer Webpack dans notre application car de base il n'est pas facile à configurer. La première étape est d'installer le bundle avec la commande suivante :</p>
<pre><code>composer require symfony/webpack-encore-bundle</code></pre>
                    <p>Il nous demande ensuite de faire :</p>
<pre><code>yarn install</code></pre>
                    <p>Cela permet donc de faire un "vendor" pour JavaScript : les "node_modules" avec un fichier "package.json". On peut également utiliser le "<span class="em">npm install</span>"" à la place. Pour voir les modifications instantanées sur notre style sur Symfony avec la commande :</p>
<pre><code>yarn watch</code></pre>
                    <p>Ça permet de compiler tous nos fichiers dans le dossier "assets" dans le dossier "public/build". Dans ce nouveau dossier, on aura les fichiers "app.css" et "app.js". Dans le fichier "webpack.config.js", on a des "entry".</p>
                    <p>Grâce à "<span class="em">{{ encore_entry_link_tags('app') }}</span>" et à "<span class="em">{{ encore_entry_script_tags('app') }}</span>", Symfony sait qu'on utilise Webpack Encore.</p>
                    <h3>Étape 29 : Les Event Listener &amp; Event Subscriber :</h3>
                    <p>Dans le cadre d'une application complexe, on a souvent besoin de rajouter de la logique supplémentaire sur des logiques déjà existantes. Pour répondre à cette problématique, Symfony propose un système d'événements qui permettra d'ajouter des écouteurs pour venir greffer la logique que l'on souhaite.</p>
                    <p>Durant l'exécution d'une application Symfony, plusieurs notifications d'évènements sont déclenchées. Par exemple, plusieurs évènements sont déclenchés lors d'une requête HTTP classique.</p>
                    <p>Un événement est une simple classe PHP que l'on va en général construire avec les éléments significatifs.</p>
                    <p>La façon la plus commune pour écouter un évènement est d'enregistrer un "event listener". Dans le dossier "src", on crée le dossier "EventListener" et créer le fichier "ExceptionListener.php" ou avec la commande suivante :</p>
<pre><code>php bin/console make:listener ExceptionListener</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\EventListener;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface;

    class ExceptionListener
    {
        public function onKernelException(ExceptionEvent $event)
        {
            // You get the exception object from the reveived event
            $exception = $event-&gt;getThrowable();
            $message = sprintf(
                'My error says: %s with code: %s',
                $exception-&gt;getMessage(),
                $exception-&gt;getCode()
            );

            // Customize your response object to display the exception details
            $response = new Response();
            $response-&gt;setContent($message);

            // HttpExceptionInterface is a special type of exception that
            // holds status code and header details
            if ($exception instanceof HttpExceptionInterface) {
                $response-&gt;setStatusCode($exception-&gt;getStatusCode());
                $response-&gt;headers-&gt;replace($exception-&gt;getHeaders());
            } else {
                $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);
            }

            // sends the modified response object to the event
            $event-&gt;setResponse($response);
        }
    }

?&gt;</code></pre>
                    <p>Dans le fichier de configuration "services.yaml", on doit ajouter les lignes suivantes :</p>
<pre><code>App\EventListener\ExceptionListener:
    tags:
        - { name: kernel.event_listener, event: kernel.exception }</code></pre>
                    <p>L'"event subscriber" est une classe qui définit une ou plusieurs méthodes qui écoutent un ou plusieurs évènements. La principale différence entre les deux est que les subscribers connaissent toujours les évènements qu'ils écoutent.</p>
                    <p>Dans le dossier "src", on crée le dossier "EventSubscriber" et dedans le fichier "kernelSubscriber.php" ou le créer via la commande :</p>
<pre><code>php bin/console make:subscriber</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\RequestEvent;

    class kernelSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents()
        {
            return [RequestEvent =&gt; 'onKernelRequest'];
        }

        public function onKernelRequest(RequestEvent $event)
        {
            dd($event-&gt;getRequest()-&gt;getPathInfo());
        }
    }

?&gt;</code></pre>
                    <h4>Exemples :</h4>
<pre><code>&lt;?php

    namespace App\Event;

    use App\DTO\ContactDTO;

    class ContactRequestEvent
    {

        public function __construct(public readonly ContactDTO $data)
        {

        }

    }

?&gt;</code></pre>
                    <p>Ensuite, on pourra émettre cet événement via l'EventDispatcher.</p>
<pre><code>#[Route('/contact', name: 'contact')]
public function contact(Request $request, MailerInterface $mailer, EventDispatcherInterface $dispatcher): Response
{
    $data = new ContactDTO();
    $form = $this-&gt;createForm(ContactType::class, $data);
    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
        try {
            $dispatcher-&gt;dispatch(new ContactRequestEvent($data));
            $this-&gt;addFlash('success', 'Votre email a bien été envoyé !');
        } catch(\Exception $e) {
            $this-&gt;addFlash('danger', 'Impossible d\'envoyer votre email !');
        }
    }

    return $this-&gt;render('contact/contact/contact.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Maintenant, si on souhaite ajouter de la logique lorsque cet événement se produit, on peut créer un listener. Cela peut se faire facilement à l'aide l'attribut <a href="https://symfony.com/doc/current/event_dispatcher.html#defining-event-listeners-with-php-attributes" target="_blank">AsEventListener</a>. C'est un mécanisme simple et moderne introduit dans Symfony 6.1.</p>
<pre><code>#[AsEventListener]
fincal class ContactListener
{
    publc function __invoke(ContactRequestEvent $event): void
    {
        // ...
    }
}</code></pre>
                    <p>Il est aussi possible de définir un Subscriber dans le cas où on veut pouvoir ajouter une logique similaire à plusieurs événements.</p>
<pre><code>&lt;?php

    namespace App\EventSubscriber;

    use App\Entity\User;
    use App\Event\ContactRequestEvent;
    use Symfonyy\Bridge\Twig\Mime\TemplatedEmail;
    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\Email;
    use Symfony\Component\Security\Http\Event\InteractiveLoginEvent;

    class MailingSubscriber implements EventSubscriberInterface
    {
        public function __construct(private readonly MailerInterface $mailer)
        {

        }

        public function onContactRequestEvent(ContactRequestEvent $event): void
        {
            $data = $event-&gt;data;
            $mail = (new TemplatedEmail())
                        -&gt;to($data-&gt;service)
                        -&gt;from($data-&gt;email)
                        -&gt;subject('Demande de contact')
                        -&gt;htmlTemplate('emails/contact.html.twig')
                        -&gt;context(['data' =&gt; $data]);
            $this-&gt;mailer-&gt;send($mail);
        }

        public function onLogin(InteractiveLoginEvent $event): void
        {
            $user = $event-&gt;getAuthenticationToken()-&gt;getUser();
            
            if (!$user instanceof User) {
                return;
            }

            $mail = (new Email())
                        -&gt;to($user-&gt;getEmail())
                        -&gt;from('support@demo.fr')
                        -&gt;subject('Connexion')
                        -&gt;text('Vous vous êtes connecté !');
            $this-&gt;mailer-&gt;send($mail);
        }

        public static function getSubscribedEvents(): array
        {
            return [
                ContactRequestEvent::class =&gt; 'onContactRequestEvent',
                InteractiveLoginEvent::class =&gt; 'onLogin',
            ];
        }
    }

?&gt;</code></pre>
                    <p>Ou on peut également faire ceci :</p>
<pre><code>&lt;?php

    namespace App\EventListener;

    use App\Entity\User;
    use App\Event\ContactRequestEvent;
    use Symfonyy\Bridge\Twig\Mime\TemplatedEmail;
    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\Email;
    use Symfony\Component\Security\Http\Event\InteractiveLoginEvent;

    class MailingListener
    {
        public function __construct(private readonly MailerInterface $mailer)
        {

        }

        #[AsEventListener(event: ContactRequestEvent::class)]
        public function onContactRequestEvent(ContactRequestEvent $event): void
        {
            $data = $event-&gt;data;
            $mail = (new TemplatedEmail())
                        -&gt;to($data-&gt;service)
                        -&gt;from($data-&gt;email)
                        -&gt;subject('Demande de contact')
                        -&gt;htmlTemplate('emails/contact.html.twig')
                        -&gt;context(['data' =&gt; $data]);
            $this-&gt;mailer-&gt;send($mail);
        }

        #[AsEventListener(event: InteractiveLoginEvent::class)]
        public function onLogin(InteractiveLoginEvent $event): void
        {
            $user = $event-&gt;getAuthenticationToken()-&gt;getUser();
            
            if (!$user instanceof User) {
                return;
            }

            $mail = (new Email())
                        -&gt;to($user-&gt;getEmail())
                        -&gt;from('support@demo.fr')
                        -&gt;subject('Connexion')
                        -&gt;text('Vous vous êtes connecté !');
            $this-&gt;mailer-&gt;send($mail);
        }
    }

?&gt;</code></pre>
                    <p>Si tu utilises des services, assure-toi que l'autoconfiguration est activée dans <span class="em">services.yaml</span>. Symfony détectera automatiquement les <span class="html">#[AsEventListener]</span> :</p>
<pre><code>services:
    App\EventListener\:
        resource: '../src/EventListener/*'
        tags: ['kernel.event_listener']
</code></pre>
                    <p>Tu peux également avoir plusieurs méthodes pour le même évènement si elles gèrent des aspects différents. Par exemple :</p>
<pre><code>#[AsEventListener(event: InteractiveLoginEvent::class, method: 'addCartToSession')]
#[AsEventListener(event: InteractiveLoginEvent::class, method: 'logUserLogin')]</code></pre>
                    <p>Dans ce cas, chaque méthode est appelée à son tour. Symfont exécutera toutes les méthodes dans l'ordre de priorité par défaut (0).</p>
                    <p>Symfony te permet également de gérer l'ordre d'exécution des liners avec une priorioté :</p>
<pre><code>#[AsEventListener(event: InteractiveLoginEvent::class, priority: 10)]
public function onInteractiveLogin(InteractiveLoginEvent $event): void
{
    // Cette méthode sera appelée en premier
}

#[AsEventListener(event: InteractiveLoginEvent::class, priority: 5)]
public function logLoginDetails(InteractiveLoginEvent $event): void
{
    // Cette méthode sera appelée ensuite
}</code></pre>
                    <h3>Étape 30 : Authentification à double facteur :</h3>
                    <p>Pour cette partie, on va créer un nouveau projet Symfony avec la commande :</p>
<pre><code>symfony new 2FA --webapp</code></pre>
                    <p>On duplique le contenu du fichier ".env" dans un nouveau fichier ".env.local". On va décommenter la ligne de la DB en SQLite par exemple et on va la créer avec la commande :</p>
<pre><code>symfony console d:d:c</code></pre>
                    <p>On va créer un contrôleur "Home" avec la commande :</p>
<pre><code>symfony console make:controller Home</code></pre>
                    <p>On va modifier la fonction "index" et on ajoute une fonction "home" comme ceci :</p>
<pre><code>#[Route('/home', name: 'home')]
public function home(): Response
{
    return $this-&gt;render('home/index.html.twig');
}

#[Route('/', name: 'index')]
public function index(): Response
{
    return $this-&gt;redirectToRoute('home');
}</code></pre>
                    <p>Pour sécuriser la page "/home" pour dire que seul l'utilisateur ayant le rôle "ROLE_USER" peut y accéder, on peut ajouter dans le "access_control" du fichier "security.yaml" un path comme ceci :</p>
<pre><code>access_control:
    - { path: ^/home, roles: ROLE_USER }</code></pre>
                    <p>On va créer un entité "User" avec la commande :</p>
<pre><code>symfony console make:user</code></pre>
                    <p>On oublie pas tout de suite dans la foulée de créer une migration avec la commande :</p>
<pre><code>symfony console make:migration</code></pre>
                    <p>Et bien sûr de migrer cette migration avec :</p>
<pre><code>symfony console d:m:m</code></pre>
                    <p>Dans notre <span class="em">UserRepository</span>, on va créer une nouvelle méthode pour trouver l'utilisateur selon l'email ou le username :</p>
<pre><code>public function findUserByEmailOrUsername(string $emailOrUsername): ?User
{
    return $this-&gt;createQueryBuilder('u')
                -&gt;where('u.email = :identifier')
                -&gt;orWhere('u.username = :identifier')
                -&gt;setParameter('identifier', $emailOrUsername)
                -&gt;setMaxResults(1)
                -&gt;getQuery()
                -&gt;getSingleResults();
}</code></pre>
                    <p>On va ensuite initialiser l'<span class="em">Authenticator</span> qui créera une page d'authentification avec la commande :</p>
<pre><code>symfony console make:auth</code></pre>
                    <p>On va donc créer un login form authenticator dans une classe "<span class="em">AppAuthenticator</span>". Vous pourrez ensuite personnaliser la classe générée par la commande pour personnaliser le processus de connexion.</p>
<pre><code>&lt;?php

    namespace App\Security;

    use // ...

    class AppAuthenticator extends AbstractLoginFormAuthenticator
    {
        use TargetPathTrait;

        public const LOGIN_ROUTE = 'app_login';

        public function __construct(private UrlGeneratorInterface $urlGenerator, private UserRepository $UserRepository)
        {

        }

        public function authenticate(Request $request): Passport
        {
            $username = $request-&gt;request-&gt;get('username', '');

            $request-&gt;getSession()-&gt;set(SecurityRequestAttributes::LAST_USERNAME, $username);

            return new Passport(
                new UserBadge($username, fn (string $identifier) =&gt; $this-&gt;UserRepository-&gt;findUserByEmailOrUsername($identifier)),
                new PasswordCredentials($request-&gt;request-&gt;get('password', '')),
                [
                    new CsrfTokenBadge('authenticate', $request-&gt;request-&gt;get('_csrf_token')),
                    new RememberBadge(),
                ]
            );
        }

        public function onAuthenticationSuccess(Request $request, TokenInterface, string $firewallName): ?Response
        {
            if ($targetPath = $this-&gt;getTargetPath($request-&gt;getSession(), $firewallName)) {
                return new RedirectResponse($argetPath);
            }

            // For example :
            // return new RedirectResponse($this-&gt;urlGenerator-&gt;generate('same_route'));
            // throw new \Exception('TODO: provide a valid redirect inside ' . __FILE__);
            return new RedirectResponse('/');
        }

        protected function getLoginUrl(Request $request): string
        {
            return $this-&gt;urlGenerator-&gt;generate(self::LOGIN_ROUTE);
        }

    }

?&gt;</code></pre>
                    <p>Dans le <span class="em">security.yaml</span>, il y a maintenant le code ci-dessus :</p>
<pre><code>main:
        lazy: true
        provider: app_user_provider
        custom_authenticator: App\Security\AppAuthenticator
        logout:
            path: app_logout
            # where to redirect after logout
            # target: app_any_route

        remember_me:
            secret: '%kernel.secret%'
            lifetime: 684800
            path: /
            # always_remeber_me: true
</code></pre>
                    <p>Si l'option <span class="em">always_remeber_me</span> est décommentée, alors, dans notre vue <span class="em">login.html.twig</span>, on rajoute le champ <span class="em">remember_me</span> :</p>
<pre><code>&lt;label&gt;
    &lt;input type="checkbox" name="_remember_me" checked"&gt;
    Keep me logged in
&lt;/label&gt;</code></pre>
                    <p>Pour la partie enregistrement des utilisateurs, on peut également la commande qui créera un contrôleur et un formulaire pour gérer l'inscription des utilisateurs :</p>
<pre><code>symfony console make:registration-form</code></pre>
                    <p>Grâce à la commande précédente, on peut ajouter une validation "<span class="html">@UniqueEntity</span>" à l'entité <span class="em">User</span>. Ça peut également envoyer un email pour vérifier l'adresse email de l'utilisateur après l'inscription ainsi qu'authentifier l'utilisateur après l'inscription. Après l'inscription, on veut être redirigé vers la page "home".</p>
                    <p>La première étape est d'installer le package manquant :</p>
<pre><code>composer require symfonycasts/verify-email-bundle</code></pre>
                    <p>Voyons voir le code généré dans le <span class="em">RegistrationController</span> :</p>
<pre><code>&lt;?php

    namespace App\Controller;

    use // ...

    class RegistrationController extends AbstractController
    {

        private EmailVerifier $emailVerifier;

        public function __construct(EmailVerifier $emailVerifier)
        {
            $this-&gt;emailVerifier = $emailVerifier;
        }

        #[Route('/register', name: 'app_register')]
        public function register(Request $request, UserPasswordHasherInterface $userPasswordHasher, UserAuthenticatorInterface $userAuthenticator, AppAuthenticator $authenticator, EntityManagerInterface $entityManager): Response
        {
            $user = new User();
            $form = $this-&gt;createForm(RegistrationFormType::class, $user);
            $form-&gt;handleRequest($request);

            if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {
                // encode the plain password
                $user-&gt;setPassword(
                    $userPasswordHasher-&gt;hashPassword(
                        $user,
                        $form-&gt;get('plainPassword')-&gt;getData()
                    )
                );

                $entityManager-&gt;persist($user);
                $entityManager-&gt;flush();

                // generate a signed url and email it to the user
                $this-&gt;emailVerifier-&gt;sendEmailConfirmation('app_verify_email', $user,
                    (new TemplatedEmail())
                        -&gt;from(new Address('support@demo.fr', 'Support'))
                        -&gt;to($user-&gt;getEmail())
                        -&gt;subject('Please confirm your email')
                        -&gt;htmlTemplate('registration.confirmation_email')
                );

                // do anything else you need here, like send an email

                return $userAuthenticator-&gt;authenticateUser(
                    $use,
                    $authenticator,
                    $request
                );
            }

            return $this-&gt;render('registration/register', [
                'registrationForm' =&gt; $form-&gt;createView(),
            ]);
        }

        #[Route('/verify/email', name: 'app_verify_email')]
        public function verifyUserEmail(Request $request, TranslatorInterface $translate): Response
        {
            $this-&gt;denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');

            // validate email confirmation link, sets User::isVerified=true and persists
            try {
                $this-&gt;emailVerifier-&gt;handleEmailConfirmation($request, $this-&gt;getUser());
            } catch (VerifyEmailExceptionInterface $exception) {
                $this-&gt;addFlash('verify_email_error', $translator($exception-&gt;getReason(), [], 'VerifyEmailBundle'));

                return $this-&gt;redirectToRoute('/register');
            }

            // @TODO Change the redirect on success and handle or remove the flash message in your templates
            $this-&gt;addFlash('success', 'your email address has been verified.');

            return $this-&gt;redirectToRoute('/register');
        }

    }

?&gt;</code></pre>
                    <p>Pour mettre en place l'authentification à double facteur, on doit installer le bundle "2FA" avec la commande :</p>
<pre><code>composer require 2fa</code></pre>
                    <p>On va aussi installer une extension à ce bundle qui est "scheb/2fa-email" avec la commande suivante :</p>
<pre><code>composer require scheb/2fa-email</code></pre>
                    <p>Dans le "main firewall" de "security.yaml", on va rajouter les lignes suivantes :</p>
<pre><code>two_factor:
    auth_form_path: 2fa_login # The route name you have used in the routes.yaml
    check_path: 2fa_login_check # The route name you have used in the routes.yaml</code></pre>
                    <p>Dans le fichier de configuration "<span class="em">scheb_2fa.yaml</span>", on va modifier son contenu comme ceci :</p>
<pre><code>scheb_two_factor:
    security_tokens:
        - Symfony\Component\Security\Http\Authenticator\token\PostAuthenticationToken
    email:
        digits: 6
        enabled: true
        sender_email: no-reply@test.com
        sender_name: John Doe</code></pre>
                    <p>On va implémenter le "<span class="em">Scheb\TwoFactorBundle\Model\Email\TwoFactorInterface</span>" dans notre entité "User" avec les lignes suivantes :</p>
<pre><code>#[ORM\Column(type: 'string', nullable: true)]
private $authCode;

public function isEmailAuthEnabled(): bool
{
    return true;    // This can be a persist field to switch email code authentication on/off
}

public function getEmailAuthRecipient(): string
{
    return $this-&gt;email;
}

public function getEmailAuthCode(): string
{
    if (null === $this-&gt;authCode) {
        throw new \LogicException('The email authentication code was not set');
    }

    return $this-&gt;authCode;
}

public function setEmailAuthCode(string $authCode): void
{
    $this-&gt;authCode = $authCode;
}</code></pre>
                    <p>Maintenant qu'on a modifié l'entité "User", on va créer une nouvelle migration et on va la migrer. On va configurer le "MAILER_DSN" via Docker par exemple dans le fiche "docker-compose.yml" avec le contenu suivant :</p>
<pre><code>version: '3.7'
services:
    mailer:
    image: schickling/mailcatcher
    ports: [1025, 1080]</code></pre>
                    <p>On va démarrer notre petit serveur de mail Docker avec la commande :</p>
<pre><code>docker-compose up -d</code></pre>
                    <p>Ensuite, on va mettre en place les appareils de confiance pour ne pas chaque fois récupérer un code par email lors de la double authentification.</p>
                    <p>On va installer une nouvelle extension à ce bundle avec la commande :</p>
<pre><code>composer require scheb/2fa-trusted-device</code></pre>
                    <p>Dans notre fichier de configuration "scheb_2fa.yaml", on va rajouter les lignes suivantes :</p>
<pre><code>trusted_device:
    enabled: true   # If the trusted device feature should be enabled
    lifetime: 5184000   # Lifetime of the trusted device token
    extend_lifetime: false  # Automatically extend lifetime of the trusted cookie on re-login
    cookie_name: trusted_device # Name of the trusted device cookie
    cookie_secure: false    # Set the 'Secure' (HTTPS Only) flag on the trusted device cookie
    cookie_same_site: "lax" # The same-site option of the cookie, can be "lax" or "strict"
    cookie_path: "/"    # Path to use when setting the cookie</code></pre>
                    <p>Dans le "two_factor" de notre "main firewall" de notre "security.yaml", on rajoute la ligne :</p>
<pre><code>trusted_parameter_name: _trusted # Name of the parameter for the trusted device option</code></pre>
                    <h3>Étape 31 : Authentification à deux facteurs avec Google Authenticator :</h3>
                    <p>Avec le prochain package qu'on va installer, le site web va générer un QR Code qui va partager une "OTP Secret Key", l'"issuer" (l'émetteur) et la "period" (durée de validation du QR Code définie par défaut à 30 secondes).</p>
                    <p>Dans un terminal, on va cloner <a href="https://github.com/pentiminax/symfony-google-authenticator" target="_blank">le repository "symfony-google-authenticator" du youtubeur "Pentiminax"</a> dont les explications sont tirées avec la commande :</p>
<pre><code>git clone https://github.com/pentiminax/symfony-google-authenticator.git</code></pre>
                    <p>On va installer les packages composer et Symfony avec la commande :</p>
<pre><code>composer install</code></pre>
                    <p>On va lancer le serveur local avec la commande :</p>
<pre><code>php -S localhost:8000 -t public/</code></pre>
                    <p>Dans notre entité "User", on a une nouvelle propriété qui va stocker la clé secrète :</p>
<pre><code>#[ORM\Column(length: 255, nullable: true)]
private ?string $secret = null;</code></pre>
                    <p>Dans notre fichier de configuration des services, "services.yaml", on a un paramètre "app.issuer" avec la valeur "Amazaune" par exemple.</p>
                    <p>Pour commencer on va créer le service "AuthenticatorService" dans le dossier "src/Service" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Doctrine\ORM\EntityManagerInterface;
    use OTPHP\TOTP;
    use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

    class AuthenticatorService
    {
        public function __construct(
            private readonly ParameterBagInterface $parameters,
            private readonly EntityManagerInterface $em
        )
        {

        }

        public function getCodeUri(User $user): array
        {
            $totp = TOTP::generate();

            $totp-&gt;setIssuer($this-&gt;parameters-&gt;get('app.issuer'));
            $totp-&gt;setLabel($user-&gt;getUserIdentifier());

            $qrCodeUri = $totp-&gt;getQRCodeUri(
                'https://api.qrserver.com/v1/create-qr-code/?color=000&bgcolor=FFF&data=[DATA]&qzone=2&margin=0&size=300x300&ecc=M',
                '[DATA]'
            );

            return [$qrCodeUri, $totp-&gt;getSecret()];
        }

        public function validatePairing(User $user, string $secret): void
        {
            if (!$secret) {
                return;
            }

            $user-&gt;setSecret($secret);

            $this-&gt;em-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Dans le "AuthenticatorController", on va y modifier sa fonction "pair" comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Controller;

    use App\Service\AuthenticatorService;
    ...

    class AuthenticatorController extends AbstractController
    {
        #[Route('authenticator/pair', name: 'app_authenticator_pair')]
        public function pair(AuthenticatorService $authenticatorService, Request $request): Response
        {
            if ($request-&gt;isMethod(Request::METHOD_POST)) {
                $authenticatorService-&gt;validatePairing($this-&gt;getUser(), $request-&gt;request-&gt;get('secret'));

                return $this-&gt;redirectToRoute('app_home_index');
            }

            [$qrCodeUri, $secret] = $authenticatorService-&gt;getQRCodeUri($this-&gt;getUser());

            return $this-&gt;render('authenticator/pair.html.twig', [
                'qrCodeUri' =&gt; $qrCodeUri,
                'secret' =&gt; $secret
            ]);
        }
    }

?&gt;</code></pre>
                    <p>On va modifier également le template pour qu'il puisse afficher les nouvelles valeurs comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}
    
{% block title %}Pair{% endblock %}

{% block body %}
    &lt;img alt="QR Code" src="{{ qrCodeUri }}"&gt;

    &lt;form method="post"&gt;
        &lt;input type="hidden" name="secret" value="{{ secret }}"&gt;
        &lt;button type="submit"&gt;Validate Pairing&lt;/button&gt;
    &lt;/form&gt;
{% endblock %}</code></pre>
                    <p>Enfin, on va vérifier le code dans la fonction "verify" du "AuthenticatorController" :</p>
<pre><code>#[Route('/authenticator/verify', name: 'app_authenticator_verify')]
public function verify(Request $request): Response
{
    if (is_null($this-&gt;getUser()-&gt;getSecret())) {
        return $this-&gt;redirectToRoute('app_authenticator_pair');
    }

    if ($request-&gt;isMethod(Request::METHOD_POST)) {
        $totp = TOTP::createFromSecret($this-&gt;getUser()-&gt;getSecret());

        $result = $totp-&gt;verify($request-&gt;request-&gt;getString('otp'));
    }

    return $this-&gt;render('authenticator/verify.html.twig', [
        'result' =&gt; $result ?? null;
    ]);
}</code></pre>
                    <p>On modifie également son template comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Verify{% endblock %}

{% block body %}
    &lt;form method="post"&gt;
        &lt;label for="otp"&gt;OTP Code&lt;/label&gt;
        &lt;input type="text" name="otp" id="otp"&gt;
        &lt;button type="submit"&gt;Verify&lt;/button&gt;
    &lt;/form&gt;

    &lt;br/&gt;

    {% if result is not null %}
        &lt;p&gt;{{ result == true ? 'Le code est bon' : "C'est pas bon" }}&lt;/p&gt;
    {% endif %}
{% endblock %}</code></pre>
                    <h3>À la découverte des variables d'environnement de Symfony :</h3>
                    <p>Dans cette partie, nous allons partir à la découverte des variables d'environnement de Symfony, et vous allez voir qu'il y a une infinité de façons de les définir ou de les utiliser !</p>
                    <h4>Initier notre projet Symfony :</h4>
                    <p>Crérons notre projet et entrons dans le dossier :</p>
<pre><code>symfony new variables_environnement --webapp
cd variables_environnement</code></pre>
                    <p>Créons un contrôleur de test :</p>
<pre><code>symfony console make:controller TestController</code></pre>
                    <p>Démarrons notre application :</p>
<pre><code>symfony serve -d</code></pre>
                    <p>Et supprimons toutes références à Webpack dans le fichier <span class="em">`templates/bas.html.twig`</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;{% block title %}Welcome!{% endblock %}&lt;/title&gt;
        &lt;link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 128 128%22&gt;&lt;text y=%221.2em%22 font-size=%2296%22&gt;⚫️&lt;/text&gt;&lt;/svg&gt;"&gt;
        {# Run `composer require symfony/webpack-encore-bundle` to start using Symfony UX #}
        {% block stylesheets %}
        {% endblock %}

        {% block javascripts %}
        {% endblock %}
    &lt;/head&gt;
    &lt;body&gt;
        {% block body %}{% endblock %}
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <h4>Définir des variables d'environnement :</h4>
                    <h5>Définir des variables d'environnement avec un fichier `.env` et `.env.local` :</h5>
                    <p>Par défaut, Symfony utilise les variables d'environnement définies dans le fichier <span class="em">`.env`</span> pour définir les variables d'environnement.</p>
                    <p>Si on consulte ce fichier on peut voir qu'il y a plusieurs variables d'environnement (j'ai supprimé les commentaires) :</p>
<pre><code>APP_ENV=dev
APP_SECRET=d039c490ad66d067877186a6640183ab
MESSENGER_TRANSPORT_DSN=doctrine://default?auto_setup=0
DATABASE_URL="postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8"</code></pre>
                    <p>La bonne façon de définir des variables d'environnement est de créer un fichier <span class="em">`.env.local`</span> qui contient les variables d'environnement à utiliser pour le développement sur votre machine et de ne jamais définir des variables d'environnement dans le fichier <span class="em">`.env`</span> (qui est commit sur Git).</p>
                    <p>Finalement, le fichier <span class="em">`.env`</span> est une sorte de <span class="em">template</span> qui permet de définir des variables d'environnement utilisées dans le projet.</p>
                    <p>Copions donc le fichier <span class="em">`.env`</span> dans un fichier <span class="em">`.env.local`</span>.</p>
<pre><code>cp .env .env.local</code></pre>
                    <p>Nous pouvons checker les variables d'environnement avec la debug barre :</p>
                    <img src="../images/symfony_variables_environnement_1.webp" alt="">
                    <p>Ajoutons une variable d'environnement :</p>
                    <ul>
                        <li>
                            <p>Dans le fichier <span class="em">`.env`</span> <span class="em">`DEMO=`</span></p>
                        </li>
                        <li>
                            <p>Dans le fichier <span class="em">`.env.local`</span> <span class="em">`DEMO="Ceci est une démo"`</span></p>
                        </li>
                    </ul>
                    <p>Et checkons les variables d'environnement :</p>
                    <img src="../images/symfony_variables_environnement_2.webp" alt="">
                    <h5>Hiérarchie des fichiers de variables d'environnement :</h5>
                    <p>Nous l'avons vu juste avant, le fichier <span class="em">`.env.local`</span> est prioritaire sur le fichier <span class="em">`.env`</span>.</p>
                    <p>Mais il est possible d'ajouter encore de la finesse dans votre architecture de projet en créant un fichier <span class="em">`.env.dev`</span> qui contient des variables d'environnement spécifiques à un environnement de développement.</p>
                    <p>Et copions le contenu du fichier <span class="em">`.env.local`</span> dans le fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>cp .env.local .env.dev</code></pre>
                    <p>Et modifions légèrement le contenu du fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>DEMO="Ceci est une démo depuis le fichier .env.local"</code></pre>
                    <p>Nous constatons que le fichier <span class="em">`env.dev`</span> est prioritaire sur le fichier <span class="em">`.env.local`</span> :</p>
                    <img src="../images/symfony_variables_environnement_3.webp" alt="">
                    <p>Poussons encore plus loin dans notre architecture de projet en créant un fichier <span class="em">`.env.dev.local`</span> en y copiant le contenu du fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>cp .env.dev .env.dev.local</code></pre>
                    <p>Nous constatons que le fichier <span class="em">`.env.dev.local`</span> est prioritaire sur le fichier <span class="em">`.env.dev`</span> :</p>
                    <img src="../images/symfony_variables_environnement_3.webp" alt="">
                    <h4>La CLI :</h4>
                    <h5>Dumper les variables d'environnement :</h5>
                    <p>Pour des raisons de performances, notamment en production, et afin d'évier de passer les fichiers <span class="em">`.env`</span> à chaque requête, nous pouvons utiliser la commande <span class="em">`dump-env`</span> pour afficher les variables d'environnement dans un fichier PHP :</p>
<pre><code>composer dump-env dev # ou prod</code></pre>
    <p>Un fichier <span class="em">`.env.php`</span> sera crée à la racine du projet :</p>
<pre><code>&lt;?php

    // This file was generated by running "composer dump-env dev"

    return array (
        'APP_ENV' =&gt; 'dev',
        'APP_SECRET' =&gt; 'd039c490ad66d067877186a6640183ab',
        'MESSENGER_TRANSPORT_DSN' =&gt; 'doctrine://default?auto_setup=0',
        'DATABASE_URL' =&gt; 'postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8',
        'DEMO' =&gt; 'Ceci est une démo depuis le fichier .env.dev.local',
    );

?&gt;</code></pre>
                    <p>Modifions le contenu du fichier <span class="em">`.env.php`</span> (À ne jamais faire, c'est uniquement pour la démo) :</p>
<pre><code>&lt;?php

    // This file was generated by running "composer dump-env dev"

    return array (
        'APP_ENV' =&gt; 'dev',
        'APP_SECRET' =&gt; 'd039c490ad66d067877186a6640183ab',
        'MESSENGER_TRANSPORT_DSN' =&gt; 'doctrine://default?auto_setup=0',
        'DATABASE_URL' =&gt; 'postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8',
        'DEMO' =&gt; 'Ceci est une démo depuis le fichier .env.local.php',
    );

?&gt;</code></pre>
                    <p>Et vérifions que les variables d'environnement sont bien modifiées :</p>
                    <img src="../images/symfony_variables_environnement_4.webp" alt="">
                    <h5>Lister les vaériables d'environnement en CLI :</h5>
                    <p>La multiplicité des fichiers peut rendre la lecture des variables d'environnement difficile. C'est pourquoi il existe une commande qui permet de lister les variables d'environnement :</p>
<pre><code>symfony console debug:dotenv</code></pre>
                    <p>Le résultat de la commande est hyper clair :</p>
                    <img src="../images/symfony_variables_environnement_5.webp" alt="">
                    <h4>Accéder aux variables d'environnement :</h4>
                    <p>Maintenant que nous avons vu comment récupérer les variables d'environnement, nous pouvons les utiliser dans notre application.</p>
                    <h5>Accéder aux variables d'environnement depuis les contrôleurs :</h5>
                    <p>Afin d'accéder à vos variables d'environnement depuis les contrôleurs, nous devons les ajouter dans notre fichier <span class="em">`config/services.yaml`</span> :</p>
<pre><code>parameters:
    demo: '%env(DEMO)%'</code></pre>
                    <p>Vérifions avec une nouvelle commande que notre variable d'environnement est bien présente :</p>
<pre><code>symfony console debug:container --env-vars</code></pre>
                    <p>Dans notre contrôleur <span class="em">`src/Controller/TestController.php`</span> ajoutons de quoi accéder à la variable d'environnement :</p>
<pre><code>#[Route('/test', name: 'app_test')]
public function index(): Response
{
    $demo = $this-&gt;getParameter('DEMO');
    dd($demo);

    return $this-&gt;render('test/index.html.twig', [
    'controller_name' =&gt; 'TestController',
    ]);
}</code></pre>
                    <p>Et vérifions !</p>
                    <img src="../images/symfony_variables_environnement_6.webp" alt="">
                    <h5>Accéder aux variables d'environnement depuis les services :</h5>
                    <p>Voyons maintenant comment accéder aux variables d'environnement depuis les services.</p>
                    <h6>la méthode "manuelle" :</h6>
                    <p>Commençons par créer un service dans le fichier <span class="em">`src/Service/DemoService.php`</span> qui permet de récupérer les variables d'environnement :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

    class DemoService
    {
        public function __construct(ParameterBagInterface $parameterBag)
        {
            $this-&gt;parameterBag = $parameterBag;
        }

        public function getDemo(): string
        {
            return $this-&gt;parameterBag-&gt;get('DEMO');
        }
    }

?&gt;</code></pre>
                    <p>Et modifions notre contrôleur <span class="em">`src/Controller/TestController.php`</span> pour utiliser notre service :</p>
<pre><code>&lt;?php

    namespace App\Controller;

    use App\Service\DemoService;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Annotation\Route;

    class TestController extends AbstractController
    {

        #[Route('/test', name: 'app_test')]
        public function index(DemoService $demoService): Response
        {
            dd($demoService-&gt;getDemo());

            return $this-&gt;render('test/index.html.twig', [
                'controller_name' =&gt; 'TestController',
            ]);
        }
    }

?&gt;</code></pre>
                    <p>On rafraîchit notre page, c'est bien le contenu de la variable d'environnement qui est affiché :</p>
                    <img src="../images/symfony_variables_environnement_7.webp" alt="">
                    <h6>La méthode "automatique" :</h6>
                    <p>Plutôt que d'utiliser le <span class="em">`ParameterBagInterface`</span> dans le service pour récupérer les variables d'environnement, nous pouvons utiliser la méthode "automatique de Symfony pour injecter les variables d'environnement.</p>
                    <p>Dans notre fichier <span class="em">`config/services.yaml`</span> ajoutons :</p>
<pre><code>parameters:
    DEMO: '%env(DEMO)%'

services:
    # ...
    App\Service\DemoService:
        arguments:
            $demo: '%env(DEMO)%'</code></pre>
                    <p>Et utilions notre argument <span class="em">`$demo`</span> dans notre service :</p>
<pre><code>&lt;?php

    namespace App\Service;

    class DemoService
    {
        public function __construct(public string $demo)
        {

        }

        public function getDemo(): string
        {
            return $this-&gt;demo;
        }
    }

?&gt;</code></pre>
                    <p>Nous pouvons vérifier que tout fonctionne :</p>
                    <img src="../images/symfony_variables_environnement_8.webp" alt="">
                    <h5>Accéder aux variables d'environnement depuis Twig :</h5>
                    <p>Nous pouvons aussi accéder aux variables d'environnement depuis Twig.</p>
                    <p>Pour cela, nous devons ajouter une variable d'environnement dans notre fichier <span class="em">`config/packages/twig.yaml`</span> :</p>
<pre><code>twig:
    default_path: '%kernel.project_dir%/templates'
    globals:
        DEMO: '%env(DEMO)%'</code></pre>
                    <p>Et dansd notre fichier <span class="em">`templates/test/index.html.twig`</span> nous pouvons accéder à la variable d'environnement directement :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Hello TestController{% endblock %}

{% block body %}

    {{ DEMO }}

{% endblock %}</code></pre>
                    <p>Et on rafraîchit notre page, c'est bien le contenu de la variable d'environnement qui est affiché :</p>
                    <img src="../images/symfony_variables_environnement_9.webp" alt="">
                    <h4>Mettez vos variables d'environnement en sécurité :</h4>
                    <p>Comme nous l'avons vu jusqu'ici, nous pouvons accéder aux variables d'environnement depuis n'importe quel endroit de notre application. Nos stockons les variables d'environnement dans un <span class="em">simple</span> fichier.</p>
                    <p>C'est certes pratique mais pas nécessairement sécurisé.</p>
                    <h5>Utilisation du système de gestion des secrets de Symfony :</h5>
                    <p>Symfony propose un système de gestion des secrets basé sur un système de clés cryptographiques.</p>
                    <h6>Génération des clés :</h6>
                    <p>Première étape, nous allons générer les clés :</p>
<pre><code>php bin/console secrets:generate-keys</code></pre>
    <p>Nous constatons que les clés sont générées avec succès dans les deux fichiers suivants :</p>
                    <ul>
                        <li>
                            <p>config/secrets/dev/dev.decrypt.private.php</p>
                        </li>
                        <li>
                            <p>config/secrets/dev/dev.decrypt.public.php</p>
                        </li>
                    </ul>
                    <p>Si vous souhaitez générer les clés pour la production :</p>
<pre><code>APP_ENV=prod php bin/console secrets:generate-keys</code></pre>
                    <p>Nous constatons que les clés sont générées avec succès dans le deux fichiers suivants :</p>
                    <ul>
                        <li>
                            <p>config/secrets/prod/prod.decrypt.private.php</p>
                        </li>
                        <li>
                            <p>config/secrets/prod/prod.decrypt.public.php</p>
                        </li>
                    </ul>
                    <p class="em">Pensez à vérifier que votre fichier <span class="html">`prod.decrypt.private.php`</span> est bien présent dans votre <span class="html">`.gitignore`</span> :</p>
<pre><code>/config/secrets/prod/prod.decrypt.private.php</code></pre>
                    <h6>Ajouter une variable d'environnement à la liste des secrets :</h6>
                    <p>Pour ajouter un nouveau secret (<span class="em">`DEMO_SECRET: Ceci est un secret`</span>) nous devons utiliser la commande suivante :</p>
<pre><code>php bin/console secrets:set DEMO_SECRET</code></pre>
    <p>Pour la production :</p>
<pre><code>APP_RUNTIME_ENV=prod php bin/console secrets:set DEMO_SECRET</code></pre>
                    <p>Nous constatons la création d'un nouveau fichier <span class="em">`config/secrets/dev/dev/DEMO_SECRET.80921a.php`</span> qui contient notre variable d'environnement chiffrée :</p>
<pre><code>&lt;?php // dev.DEMO_SECRET.80921a on Mon, 07 Mar 2022 10:07:38 +0100

    return "\xCD\x9B\x7F6\xDC\xC9\x82\xE6\xEB\xE2\x808\xBF\xA9P\xA8\x9BL\x3A\xA5\xC0\xBD\xA6\xA6\xA7\x7D\x10\xCD\xE9\xD0\xBEg\xA3ez\x8A\xC2\x91k\xD04DDLo\x9D\xB9\x17\xCD\xC9\x989\x24\x3A\xC3U\xFCFP\x5CQ\xC0\xB9\xA3T\x60";

?&gt;</code></pre>
                    <p>Et accédons à notre variable d'environnement depuis Twig :</p>
<pre><code>twig:
        default_path: '%kernel.project_dir%templates'
        globals:
            DEMO: '%env(DEMO)%'
            DEMO_SECRET: '%env(DEMO_SECRET)%'</code></pre>
                    <p>Modifions notre fichier twig <span class="em">`templates/test/index.html.twig`</span> :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Hello TestController!{% endblock %}

{% block body %}

    {{ DEMO_SECRET }}

{% endblock %}</code></pre>
                    <p>Dumpons nos variables d'environnement :</p>
<pre><code>composer dump-env dev</code></pre>
                    <p>Et constatons le résultat :</p>
                    <img src="../images/symfony_variables_environnement_10.webp" alt="">
                    <h6>Set d'un secret en local :</h6>
                    <p>Vous pouvez aussi <span class="em">set</span> un secret en local (valable uniquement sur votre machine) :</p>
<pre><code>php bin/console secrets:set --local DEMO_SECRET</code></pre>
                    <p>Dumpons nos variables d'environnement :</p>
<pre><code>composer dump-env dev</code></pre>
                    <p>Et vérifions :</p>
                    <img src="../images/symfony_variables_environnement_11.webp" alt="">
                    <h6>Quelques outils pour gérer les secrets :</h6>
                    <ul>
                        <li>
                            <p>Lister les secrets :</p>
                <pre><code><span class="html">php bin/console secrets:list --reveal</span>
                ------------- ---------------------- ---------------------------- 
                Secret        Value                  Local Value                 
                ------------- ---------------------- ---------------------------- 
                DEMO_SECRET   "Ceci est un secret"   "Ceci est un secret local"  
                ------------- ---------------------- ----------------------------</code></pre>
                        </li>
                        <li>
                            <p>Supprimer un secret :</p>
                <pre><code>php bin/console secrets:remove DEMO_SECRET</code></pre>
                        </li>
                    </ul>
                    <h3>Étape 32 : Doctrine avancé (select partiel, DTO &amp; DQL) :</h3>
                    <p>Dans cette partie, je vous propose de voir quelques notions avancés concernant Doctrine qui vous permettront d'améliorer les performances et d'écrire des requêtes plus complexes.</p>
                    <h4>Select partiel :</h4>
                    <p>Doctrine est pensé par défaut pour hydrater des entités et ses requêtes sélectionneront systématiquement l'ensemble des champs de l'entité. Cependant, dans certaines situations, on n'a pas besoin de forcément tout récupérer. Dans cette situation, il est possible d'utiliser la méthode <span class="html">select()</span> sur le queryBuilder pour spécifier les champs souhaités.</p>
<pre><code>$recipes = $this
                        -&gt;createQueryBuilder('r')
                        -&gt;select('r.id', 'r.name')
                        -&gt;getQuery()
                        -&gt;getResult();</code></pre>
                    <p>Dans ce cas-là, chaque enregistrement sera renvoyé sous forme de tableau associatif. Mais, on va aussi pouvoir construire des objets qui serviront à représenter nos données (ce qui permet ensuite un typage). Pour cela, on peut utiliser <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/2.17/reference/dql-doctrine-query-language.html#new-operator-syntax" target="_blank">l'opérateur NEW de Doctrine.</a></p>
<pre><code>$recipes = $this
            -&gt;createQueryBuilder('r')
            -&gt;select('NEW App\\DTO\\LightRecipeDTO(r.id, r.name)')
            -&gt;getQuery()
            -&gt;getResult();</code></pre>
                    <p>Cela utilisera le constructeur de l'objet en lui passant les champs sélectionnés (on ne peut utiliser que des données scalaires).</p>
                    <h4>DQL : Doctrine Query Language :</h4>
                    <p>Doctrine offre aussi un langage appelé <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/3.0/reference/dql-doctrine-query-language.html#doctrine-query-language" target="_blank">DQL</a> qui est un langage proche du SQL mais qui permet les requêtes sur les objets plutôt que les tables.</p>
<pre><code>&lt;?php
    $query = $em-&gt;createQuery('SELECT u FROM MyProject\Model\User u WHERE u.age &gt; 20');
    $users = $query-&gt;getResult();
?&gt;</code></pre>
                    <p>Pour plus de détails sur les fonctionnalités du DQL, n'hésitez pas à vous rendre sur <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/3.0/reference/dql-doctrine-query-language.html" target="_blank">la documentation de Doctrine</a>.</p>
                    <h3>Étape 33 : Asset Mapper :</h3>
                    <p>Parlons maintenant un peu de la partie front-end et de la gestion des assets dans le cadre d'une application Symfony. Même si, pour des besoins de base, il est est possible de placer nos ressources dans le dossier <span class="em">public</span>, le dossier <span class="em">assets</span> offre plusieurs avantages :</p>
                    <ul>
                        <li>
                            <p>Le <span class="em">versionning</span>, qui ajoutera un suffixe après le nom des fichiers qui permet de configurer un cache longue durée sur les fichiers CSS, JS, images...</p>
                        </li>
                        <li>
                            <p>Le <span class="em">mapping</span>, qui permettra de faire référence à un fichier par son chemin original.</p>
                        </li>
                        <li>
                            <p><span class="em">Importmaps</span> qui permettra d'importer une ressource depuis un import JavaScript.</p>
                        </li>
                    </ul>
                    <p>Pendant le développement, les ressources sont automatiquement distribuées si vous utilisez le serveur disponible via la commande Symfony <span class="html">symfony serve</span>.</p>
                    <p>Quand on passera en production, il faudra utiliser la commande <span class="html">asset-map:compile</span> pour compiler les assets dans le dossier <span class="em">public</span> afin de les rendre accessibles.</p>
<pre><code>php bin/console asset-map:compile</code></pre>
                    <h4>Librairie tierce :</h4>
                    <p>Il est aussi possible d'importer des librairies tierces à l'aide de la commande <span class="html">importmap:require</span> qui téléchargera le fichier du module et qui mettra à jour l'<span class="em">importmap</span>.</p>
<pre><code>php bin/console importmap:require canvas-confetti</code></pre>
                    <p>On peut ensuite utiliser la librairie classiqueemnt dans notre code JS.</p>
<pre><code>import confetti from 'canvas-confetti';

document.body.addEventListener('click', () =&gt; {
    confetti();
});</code></pre>
                    <h3>Étape 34 : Le serializer :</h3>
                    <p>Dans cette partie, nous allons voir comment on peut utiliser Symfony dans le cadre de la création d'une API. On a vu lors de la découverte des contrôleurs que l'on disposait d'une méthode <span class="html">json()</span> sur le <span class="em">AbstractController</span> qui permet de renvoyer du JSON.</p>
<pre><code>class RecipesController extends AbstractController
{

    #[Route('/api/recipes', methods: ['GET'])]
    public function index(
        RecipeRepository $repository,
    )
    {
        $recipes = $repository-&gt;findAll();
        return $this-&gt;json($recipes);
    }

}</code></pre>
                    <p>Par défaut, cette méthode va nous renvoyer un tableau contenant l'ensemble des champs de nos recettes. Cela est rendu possible par le système de sérialisation du framework qui repose sur deux composants :</p>
                    <ul>
                        <li>
                            <p>Le <span class="em">normalizer</span> qui va convertir un objet en tableau PHP classique.</p>
                        </li>
                        <li>
                            <p>L'<span class="em">encodeur</span> qui va convertir un tableau dans le format choisi (JSON, CSV, XML...).</p>
                        </li>
                    </ul>
                    <p>Dans notre cas, c'est l'<span class="em">ObjectNormalizer</span> qui va être capable de scanner notre objet pour en extirper les informations. Si on souhaite contrôler les champs à exposer, on peut utiliser le contexte de normalisation et notamment les groupes.</p>
<pre><code>return $this-&gt;json($recipes, 200, [], [
    'groups' =&gt; ['recipes.index'],
]);</code></pre>
                    <p>Ensuite, dans notre entité, on pourra annoter les propriétés que l'on souhaite assigner au groupe.</p>
<pre><code>use Symfony\Component\Serializer\Attribute\Groups;

class Recipe
{
    #[Groups(['recipes.index'])]
    private ?int $id = null;

    #[Groups(['recipes.index', 'recipes.create'])]
    private string $title = '';

    #[Groups(['recipes.show', 'recipes.create'])]
    private string $content = '';

    // ...
}</code></pre>
                    <p>Ces groupes marchent aussi pour les entités imbriquées.</p>
                    <h4>Normalizer personnalisé :</h4>
                    <p>Pour des cas plus complexes, il est aussi possible de créer un normalizer personnalisé.</p>
<pre><code>php bin/console make:serializer:normalizer</code></pre>
                    <p>Ce normalizer sera automatiquement enregistré grâce au système d'autoconfiguration du gestionnaire de services de Symfony.</p>
<pre><code>&lt;?php

    namespace App\Normalizer;

    use App\Entity\Recipe;
    use Knp\Component\Pager\Pagination\PaginationInterface;
    use Symfony\Component\DependencyInjection\Attribute\Autowire;
    use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

    class PaginationNormalizer implements NormalizerInterface
    {

        public function __construct(
            #[Autowire(service: 'serializer.normalizer.object')]
            private readonly NormalizerInterface $normalizer
        )
        {

        }

        public function normalize(mixed $object, ?string $format = null, array $context = []): array|string|int|float|bool|\ArrayObject|null
        {
            if (!($object instanceof PaginationInterface)) {
                throw new \RuntimeException();
            }

            return [
                'items' =&gt; array_map(fn (Recipe $recipe) =&gt; $this-&gt;normalizer-&gt;normalize($recipe, $format, $context), $object-&gt;getItems()),
                'total' =&gt; $object-&gt;getTotalItemCount(),
                'page' =&gt; $object-&gt;getCurrentPageNumber(),
                'lastPage' =&gt; ceil($object-&gt;getTotalItemCount() / $object-&gt;getItemNumberPerPage())
            ];
        }

        public function supportsNormalization(miwed $data, ?string $format = null, array $context = []): bool
        {
            return $data instanceof PaginationInterface;
        }

        public function getSupportedTypes(?string $format): array
        {
            return [
                PaginationInterface::class =&gt; true,
            ];
        }

    }

?&gt;</code></pre>
                    <h3>Étape 35 : Désérialisation et MapRequestPayload :</h3>
                    <p>La désérialisation est le fonctionnement inverse à celui que l'on a vu précédemment. L'objectif est de convertir les données fournies dans un certain format dans un objet de notre application.</p>
<pre><code>public function index(
    Request $request,
    SerializerInterface $serializer
): Response
{
    $recipe = $serializer-&gt;deserialize($request-&gt;getContent(), Recipe::class, 'json');
}</code></pre>
                    <p>Le fonctionnement est similaire à celui que l'on a vu pour le Serializer (on peut utiliser les groupes pour définir les champs à sérialiser).</p>
                    <h4>MapRequestPayload :</h4>
                    <p>Il existe un raccourci permettant de gérer la sérialisation d'une requête dès les arguments du contrôleur. Cela se fait à l'aide de l'attribut <a href="https://symfony.com/doc/current/controller.html#mapping-request-payload" target="_blank">MapRequestPayload</a>.</p>
<pre><code>#[Route('/api/recipes', methods: ['POST'])]
public function create(
    Request $request,
    #[MapRequestPayload(
        serializationContext: [
            'groups' =&gt; ['recipes.create']
        ]
    )]
    Recipe $recipe,
    EntityManagerInterface $em
)
{
    $recipe-&gt;setCreatedAt(new \DateTimeImmutable());
    $recipe-&gt;setUpdatedAt(new \DateTimeImmutable());
    $em-&gt;persist($recipe);
    $em-&gt;flush();
    return $this-&gt;json($recipe, 200, [], [
        'groups' =&gt; ['recipes.index', 'recipes.show'],
    ]);
}</code></pre>
                    <p>Cet attribut va aussi utiliser la validation et, si les données soumises ne sont pas valides, une erreur sera directement renvoyée à l'utilisateur.</p>
                    <p>Il existe aussi un équivalent pour générer un objet à partir des informations provenant de l'URL à l'aide de <a href="https://symfony.com/doc/current/controller.html#mapping-the-whole-query-string" target="_blank">MapQueryString</a>.</p>
                    <p>On peut créer des DTO à la volée. Par exemple, dans le code suivant, si on rentre un numéro de page négatif, ça va lancer une erreur :</p>
<pre><code>#[Route('/api/recipes', methods: ['GET'])]
public function index(RecipeRepository $repository, Request $request)
{
    $recipes = $repository-&gt;paginateRecipes($request-&gt;query-&gt;getInt('page', 1));
    return $this-&gt;json($recipes, 200, [], [
        'groups' =&gt; ['recipes.index'],
    ]);
}</code></pre>
                    <p>Pour corriger cette erreur, on va créer le DTO <span class="em">PaginationDTO</span> :</p>
<pre><code>&lt;?php

    namespace App\DTO;

    use Symfony\Component\Validator\Constraints as Assert;

    class PaginationDTO
    {

        public function __construct(
            #[Assert\Positive()]
            public readonly ?int $page = 1
        )
        {

        }

    }

?&gt;</code></pre>
                    <p>On modifiera donc notre code pour utiliser ce DTO :</p>
<pre><code>#[Route('/api/Recipes', methods: ['GET'])]
public function index(
    RecipeRepository $repository,
    #[MapQueryString]
    ?PaginationDTO $paginationDTO = null;
)
{
    $recipes = $repository-&gt;paginateRecipes($paginationDTO?-&gt;page);
    return $this-&gt;json($recipes, 200, [], [
        'groups' =&gt; ['recipes.index'],
    ]);
}</code></pre>
                    <h3>Étape 36 : Authenticator stateless :</h3>
                    <p>Dans cette partie, je vous propose de revenir sur le composant <span class="em">Security</span> et on va découvrir comment créer un système d'authentification stateless pour notre partie API.</p>
                    <p>Le composant <span class="em">Security</span> est composé de plusieurs éléments :</p>
                    <ul>
                        <li>
                            <p>Le <a href="https://github.com/symfony/security-core/blob/7.0/User/UserProviderInterface.php" target="_blank">UserProvider</a> permet de trouver un utilisateur à partir de son identifier.</p>
                        </li>
                        <li>
                            <p>L'<a href="https://github.com/symfony/symfony/blob/7.1/src/Symfony/Component/Security/Http/Authenticator/AuthenticatorInterface.php" target="_blank">Authenticator</a> qui lui se charge d'authentifier l'utilisateur lors de certaines requêtes.</p>
                        </li>
                    </ul>
                    <p>Dans le cadre d'une API, on aura en général une enquête particulière <span class="html">Authorization</span> qui nous permet d'identifier l'utilisateur qui est à l'origine de la requête.</p>
<pre><code>&lt;?php

    namespace App\Security;

    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Exception\AuthenticationException;
    use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
    use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
    use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
    use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

    class APIAuthenticator extends AbstractAuthenticator
    {

        public function supports(Request $request): ?bool
        {
            return $request-&gt;headers-&gt;has('Authorization') &amp;&amp; str_contains($request-&gt;headers-&gt;get('Authorization'), 'Bearer ');
        }

        public function authenticate(Request $request): Passport
        {
            $identifier = str_replace('Bearer ', '', $request-&gt;headers-&gt;get('Authorization'));
            return new SelfValidatingPassport(
                new UserBadge($identifier),
            );
        }

        public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
        {
            return null;
        }

        public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
        {
            return new JsonResponse([
                'message' =&gt; $exception-&gt;getMessage(),
            ], Response::HTTP_UNAUTHORIZED);
        }

    }

?&gt;</code></pre>
                    <p>Dans notre cas, on crée un passeport qui contient comme identifier la clef d'API. Il faudra ensuite modifier la configuration pour ajouter cet authenticator sur les URLs qui commencent par <span class="em">/api</span>.</p>
<pre><code>security:
    password_hashers:
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
    providers:
        api_user_provider:
            entity:
                class: App\Entity\user
                property: apiToken
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|xss|images|js)/
            security: false
        api:
            pattern: ^/api/
            provider: api_user_provider
            custom_authenticator: App\Security\APIAuthenticator
            stateless: true
            lazy: true
</code></pre>
                    <p>Dans mon cas, je me contente de chercher l'utilisateur qui a la propriété <span class="em">apiToken</span> qui correspond à la clef d'<span class="em">Authorization</span>. Pour des cas plus complexes, vous pouvez <a href="https://symfony.com/doc/current/security/user_providers.html#creating-a-custom-user-provider" target="_blank">utiliser un provider personnalisé</a>.</p>
                    <h3>Étape 37 : Permissions avancées avec les Voter :</h3>
                    <p>Dans cette partie, nous allons revenir sur l'aspect sécurité et voir comment gérer des permissions plus fines qu'un simple système de rôle. Pour cela, on va se reposer sur l'utilisation de <a href="https://symfony.com/doc/current/security/voters.html" target="_blank">Voters</a> qui permettent de juger de l'accès de l'utilisateur à certaines opérations.</p>
                    <p>Pour créer un voter, on utilise la commande :</p>
<pre><code>php bin/console make:voter RecipeVoter</code></pre>
                    <h4>Exemple :</h4>
                    <p>Par exemple, on permet à tout le monde de lister ses propres recettes, mais il faut être l'autre d'une recette pour l'éditer.</p>
<pre><code>&lt;?php
    
    namespace App\Security\Voter;

    use App\Entity\Recipe;
    use App\Entity\User;
    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;
    use Symfony\Component\Security\Core\User\UserInterface;

    class RecipeVoter extends Voter
    {
        public const EDIT = 'RECIPE_EDIT';
        public const DELETE = 'RECIPE_DELETE';
        public const VIEW = 'RECIPE_VIEW';
        public const CREATE = 'RECIPE_CREATE';
        public const LIST = 'RECIPE_LIST';
        public const LIST_ALL = 'RECIPE_ALL';

        protected function supports(string $attribute, mixed $subject): bool
        {
            return
                in_array($attribute, [self::CREATE, self::LIST, self::LIST_ALL]) || (
                    in_array($attribute, [self::EDIT, self::VIEW])
                    &amp;&amp; $subjet instanceof \App\Entity\Recipe
                );
        }

        /**
        * @param Recipe|null $subject
        */
        protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
        {
            $user = $token-&gt;getUser();
            // if the user is anonymous, do not grant access_control
            if (!$user instanceof User) {
                return false;
            }

            switch($attribute) {
                case self::EDIT:
                case self::DELETE:
                    return $subject-&gt;getUser()-&gt;getId() === $user-&gt;getId();
                    break;
                case self::LIST:
                case self::CREATE:
                case self::VIEW:
                    return true;
                    break;
            }

            return false;
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, dans mon contrôleur, je peux utiliser l'attribut <span class="html">IsGranted</span> pour valider le niveau de permission de l'utilisateur.</p>
<pre><code>#[Route('/', name: 'index')]
#[IsGranted(RecipeVoter::LIST)]
public function index(Security $security): Response {
    $page = $request-&gt;query-&gt;getInt('page', 1);
    $userId = $security-&gt;getUser()-&gt;getId();
    $canListAll = $security-&gt;isGranted(RecipeVoter::LIST_ALL);
    // On limite la liste des recettes à celle de l'utilisateur s'il n'a pas les permissions de tout voir
    $recipes = $repository-&gt;paginateRecipes($page, $canListAll ? null : $userId);
    // ...
}

#[Route('/create', name: 'create')]
#[IsGranted(RecipeVoter::CREATE)]
public function create(Request $request): Response
{
    // ...
}

#[Route('/{id}', name: 'edit', methods: ['GET', 'POST'], requirements: ['id' =&gt; Requirement::DIGITS])]
#[IsGranted(RecipeVoter::EDIT, subject: 'recipe')]
public function edit(Recipe $recipe, Request $request $request): Response
{
    // ...
}

#[Route('/{id}', name: 'delete', methods: ['DELETE'], requirements: ['id' =&gt; Requirement::DIGITS])]
public function remove(Recipe $recipe)
{
    // ...
}</code></pre>
                    <h4>Super admin :</h4>
                    <p>Par défaut, le système est affirmative, il suffit d'un seul voter qui vote "oui" pour donner l'accès à l'utilisateur à un système. Aussi, on peut créer un voter basé sur le rôle qui répondra "oui" à tout si l'utilisateur a le rôle administrateur.</p>
<pre><code>&lt;?php

    namespace App\Security\Voter;

    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;
    use Symfony\Component\Security\Core\User\UserInterface;

    class AdminVoter extends Voter
    {

        protected function supports(string $attribute, mixed $subject): bool
        {
            return true;
        }

        protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
        {
            $user = $token-&gt;getUser();
            if (!user instanceof UserInterface) {
                return false;
            }

            return in_array('ROLE_ADMIN', $user-&gt;getRoles());
        }

    }

?&gt;</code></pre>
                    <p>Cela permet de ne pas polluer les autres voters tout en créant une règle qui outrepasse toutes les autres.</p>
                    <h3>Étape 38 : Symfony UX :</h3>
                    <p><a href="https://ux.symfony.com/" target="_blank">Symfony UX</a> est une initiative de l'équipe de Symfony pour fournir un ensemble de bibliothèques visant à simplifier l'intégration d'outils JavaScript dans vos applications Symfony.</p>
                    <h4>Comment ça marche ?</h4>
                    <p>Symfony UX s'appuie sur le framework JavaScript <a href="https://stimulus.hotwired.dev/" target="_blank">Stimulus</a>, qui permet d'ajouter des comportements interactifs aux éléments HTML de manière automatique. Lorsque l'on va installer un paquet, une nouvelle ligne sera ajoutée au fichier <span class="em">assets/controller.json</span> pour enregistrer automatiquement le contrôleur associé au module. Ce fichier sera lu par l'asset mapper et chargera le fichier JavaScript associé dans votre page de manière automatique.</p>
                    <h3>Étape 39 : Formulaires imbriqués :</h3>
                    <p>Dans cette partie, je vous propose de découvrir comment gérer un système de formulaire imbriqué. Cela sera l'occassion de découvrir le type <span class="html">CollectionType</span> qui permet par exemple de gérer les données du relation <span class="html">OneToMany</span>.</p>
                    <p>Pour commencer, on va créer une classe de formulaire pour la donnée liée, classe que l'on pourra utiliser dans notre formulaire principal.</p>
<pre><code>-&gt;add('quantites', CollectionType::class, [
    'entry_type' =&gt; QuantityType::class,
    'allow_add' =&gt;true,
    'allow_delete' =&gt; true,
    'by_reference' =&gt; false,
    'entry_options' =&gt; [
        'label' =&gt; false,
    ],
    'attr' =&gt; [
        'data-controller' =&gt; 'form-collection',
    ],
])</code></pre>
                    <ul>
                        <li>
                            <p><span class="html">allow_add</span> permet l'ajout de nouvel élément, cela ajoutera un attribut <span class="html">data-prototype</span> au niveau du conteneur HTML.</p>
                        </li>
                        <li>
                            <p><span class="html">allow_delete</span> permet de supprimer un élément à la volée.</p>
                        </li>
                        <li>
                            <p><span class="html">by_reference</span> indique qu'on ne modifie pas directement la collection, mais que l'on doit appeler les méthodes addXXX / removeXXX sur notre entité à la place.</p>
                        </li>
                    </ul>
                    <p>On doit ensuite ajouter du code JavaScript pour ajouter les boutons d'action.</p>
<pre><code>// assets/controller/form-collection_controller.js
import { Controller } from '@hotwired/stimulus';

export default class extends Controller {

    static values = {
        addLabel: String,
        deleteLabel: String,
    };

    /**
    * Injecte dynamiquement le bouton "Ajouter" et les boutons "Supprimer"
    */
    connect() {
        this.index = this.element.childElementCount;
        const btn = document.createElement('button');
        btn.setAttribute('class', 'btn btn-secondary');
        btn.innerText = this.addLabelValue || 'Ajouter un élément';
        btn.setAttribute('type', 'button');
        btn.addEventListener('click', this.addElement);
        this.element.childNodes.forEach(this.addDeleteButton);
        this.element.append(btn);
    };

    /**
    * AJoute une nouvelle entrée dans la structure HTML
    *
    * @param {MouseEvent} e
    */
    addElement = () =&gt; {
        e.preventDefault();
        const element = document.createRange().createContextualFragment(
            this.element.dataset['prototype'].replaceAll('__name__', this.index)
        ).firstElementChild;
        this.addDeleteButton(element);
        this.index++;
        e.currentTarget.insertAdjacentElement('beforebegin', element);
    };

    /**
    * Ajoute le bouton pour supprimer une ligne
    *
    * @param {HTMLElement} item
    */
    addDeleteButton = (item) =&gt; {
        const btn = document.createElement('button');
        btn.setAttribute('class', 'btn btn-secondary');
        btn.innerText = this.deleteLabelValue || Supprimer;
        btn.setAttribute('type', 'button');
        item.append(btn);
        btn.addEventListener('click', (e) =&gt; {
            e.preventDefault();
            item.remove();
        });
    };

};</code></pre>
                    <p>Et voilà, notre entité sera automatiquement hydratée et Doctrine saura porter les modifications en base de données.</p>
                    <h3>Étape 40 : Tâche asynchrone avec Messenger :</h3>
                    <p>Dans cette partie, je vous propose de découvrir comment gérer un système de <a href="https://symfony.com/doc/current/messenger.html" target="_blank">fil d'attente sur Symfony avec Messenger</a>.</p>
                    <h3>Étape 41 : Internationnalisation :</h3>
                    <p>Dans cette partie, nous allons voir comment gérer l'internationalisation d'une application web avec Symfony.</p>
                    <h4>Traduction de chaîne :</h4>
                    <p>Pour les chaînes présentes dans le code source, il est possible de les traduire de différentes manières en fonction de la situation.</p>
<pre><code>&lt;!-- Via un filtre --&gt;
{{ 'Welcome' | trans }}

&lt;!-- Via un tag --&gt;
{% trans %}Welcome{% endtrans %}</code></pre>
                    <p>Dans les contrôleurs et les services, il est possible d'utiliser le service de traduction pour obtenir la version traduite d'une chaîne.</p>
<pre><code>use Symfony\Contracts\Translation\TranslatorInterface;

public function index(TranslatorInterface $translator): Response
{
    $translated = $translator-&gt;trans('Welcome');
}</code></pre>
                    <p>Ensuite, les traductions de nos chaînes seront placées dans le dossier <span class="em">translations</span> au format yaml. Ce dossier, et la locale à utiliser par défaut sont configurés dans le fichier de configuration <span class="em">translation.yaml</span>.</p>
<pre><code># messages.fr.yaml
welcome: Bienvenue</code></pre>
                    <p>Pour des traductions plus complexes (genre et pluralisation), il est possible d'utiliser le <a href="https://symfony.com/doc/current/reference/formats/message_format.html" target="_blank">format ICU pour les messages</a>.</p>
                    <h4>Sélection de la langue :</h4>
                    <p>Maintenant que nous avons nos traductions, il faut pouvoir passer d'une traduction à l'autre. Cela peut se faire de plusieurs manières.</p>
                    <h5>Via l'URL :</h5>
                    <p>Le cas classique est de préfixer nos URL avec la langue choisie par l'utilisateur.</p>
<pre><code># config/routes.yaml
controllers:
    prefix: "{_locale}"
    requirements:
        _locale: en|fr|de
    resource:
        path: .../src/Controller/
        namespace: App\Controller
    type: attribute</code></pre>
                    <p>L'attribut <span class="em">_locale</span> sera automatiquement pris en compte par le système de traduction qui appliquera la locale associée à ce paramètre. Vous pouvez utiliser cet attribut n'importe où dans votre application.</p>
                    <h5>Via une prédérence utilisateur :</h5>
                    <p>Une autre possibilité est d'utiliser une préférence utilisateur pour définir la langue de l'interface. Dans ce cas-là, il sera possible d'utiliser un écouteur d'événement et d'utiliser le service <span class="html">LocaleSwitcher</span> pour changer la locale du site.</p>
<pre><code>&lt;?php

    namespace App\EventListener;

    use App\Entity\User;
    use Symfony\Bundle\SecurityBundle\Security;
    use Symfony\Component\EventDispatcher\Attribute\AsEventListener;
    use Symfony\Component\HttpKernel\Event\RequestEvent;
    use Symfony\Component\HttpKernel\KernelEvents;
    use Symfony\Component\Translation\LocaleSwitcher;

    final class UserLocaleListener
    {

        public function __construct(
            private readonly Security $security,
            private readonly LocaleSwitcher $LocaleSwitcher
        )
        {

        }

        #[AsEventListener(event: KernelEvents::REQUEST)]
        public function onKernelRequest(RequestEvent $event): void
        {
            $user = $this-&gt;security-&gt;getUser();
            if ($user &amp;&amp; $user instanceof User) {
                $this-&gt;LocaleSwitcher-&gt;setLocale($user-&gt;getLocale());
            }
        }
    }

?&gt;</code></pre>
                    <h4>Traduction des entités :</h4>
                    <p>En revanche, Symfony n'intègre pas d'outil interne pour la traduction des champs de votre base de données. Cependant, il est possible d'utiliser le module <a href="https://github.com/doctrine-extensions/DoctrineExtensions" target="_blank">DoctrineExtension</a> qui permet l'ajout de comportements supplémentaires. Pour simplifier son intégration au sein de Symfony, on pourra utiliser le bundle <a href="https://symfony.com/bundles/StofDoctrineExtensionsBundle/current/index.html" target="_blank">StofDoctrineExtensionsBundle</a>.</p>
<pre><code>composer require stof/doctrine-extensions-bundle</code></pre>
                    <p>Vous pourrez ensuite suivre <a href="https://symfony.com/bundles/StofDoctrineExtensionsBundle/current/configuration.html" target="_blank">les instructions de la documentation pour activer l'extension <span class="em">gedmo_translatable</span></a>.</p>
                    <h3>Étape 42 : Les ValueResolver :</h3> 
                    <p>Dans Symfony, les contrôleurs sont au coeur de la logique de notre application. Les méthodes peuvent recevoir des paramètres qui sont automatiquement résolue par le système de <a href="https://symfony.com/doc/current/controller/value_resolver.html" target="_blank">Value Resolver</a>. Ce système peut aussi être étendu avec des attribus pour rajouter de la logique supplémentaire.</p>
<pre><code>// ...
use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;
use Symfony\Bridge\Doctrine\Attribute\MapEntity;
use Symfony\Component\Routing\Attribute\Route;

class BlogController
{
    #[Route('/post/{$post}')]
    public function create(
        #[MapEntity] Post $post,
        #[MapRequestPayload] CreatePostDTO $data,
    ): Response
    {

    }
}</code></pre>
                    <p>Ce système peut être étendu pour créer votre propre système de résolution de paramètre. Pour cela, il suffit de créer une classe qui implémente l'interface <span class="em">Symfony\Component\HttpKernel\Controller\ValueResolverInterface</span>.</p>
                    <h4>Exemple :</h4>
                    <p>Par exemple, voici un exemple de <span class="html">ValueResolver</span> que j'utilise pour fusionner la logique d'un <span class="html">MapEntity</span> et d'un <span class="html">MapRequestPayload</span>.</p>
                    <p>Pour commencer, je crée un attribut qui me permettra de marquer le paramètre de mon contrôler comme hydratable.</p>
<pre><code>&lt;?php

    namespace App\Http\ValueResolver\Attribute;

    use App\Http\ValueResolver\EntityHydratorValueResolver;
    use Symfony\Component\HttpKernel\Attribute\ValueResolver;
    use Symfony\Component\HttpKernel\ControllerMetadata\ArgumentMetadata;
    use Symfony\Component\Validator\Constraints\GroupSequence;

    /**
    * Attribut permettant une fusion entre MapEntity &amp; MapRequestPayload
    * - Récupère l'entité depuis la base de données (comme MapEntity)
    * - Injecte les données provenant de la requête
    * - Valide les données.
    */
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    final readonly class MapHydratedEntity extends ValueResolver
    {

        public function __construct(
            public array $groups = [],
            public string|GroupSequence|array|null $validationGroups = null,
        )
        {
          parent::__construct(EntityHydratorValueResolver::class);  
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on crée un <span class="html">ValueResolver</span> qui ne déclenchera sa logique que pour les paramètres avec l'attribut <span class="html">MapHydratedEntity</span>. Cette classe doit implémenter une méthode <span class="html">resolve()</span> qui devra renvoyer un tableau contenant l'élément à injecter dans le contrôleur (ou renvoyer un tableau vide pour passer au <span class="html">ValueResolver</span> suivant).</p>
<pre><code>&lt;?php

    namespace App\Http\ValueResolver;

    use App\Http\ValueResolver\Attribute\MapHydratedEntity;
    use Doctrine\Persistence\ManagerRegistry;
    use Symfony\Bridge\Doctrine\ArgumentResolver\EntityValueResolver;
    use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Controller\ValueResolverInterface;
    use Symfony\Component\HttpKernel\ControllerMetadata\ArgumentMetadata;
    use Symfony\Component\HttpKernel\Exception\HttpException;
    use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
    use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
    use Symfony\Component\Serializer\SerializerInterface;
    use Symfony\Component\Validator\Exception\ValidationFailedException;
    use Symfony\Component\Validator\Validator\ValidatorInterface;

    /**
    * Récupère une entité (comme MapEntity), l'hydrate et la valide
    * Agit comme une combinaison entre MapEntity &amp; MapRequestPayload.
    */
    final readonly class EntityHydratorValueResolver implements ValueResolverInterface
    {
        private EntityValueResolver $entityValueResolver;

        public function __construct(
            private SerializerInterface $serializer,
            private ValidatorInterface $validator,
            ManagerRegistry $registry,
            ?ExpressionLanguage $expressionLanguage = null,
        )
        {
            $this-&gt;entityValueResolver = new EntityHydratorValueResolver($registry, $expressionLanguage);
        }

        public function resolve(Request, ArgumentMetadata $argument): iterable
        {
            // On ne s'active que sur les paramètres avec l'attribut MapHydratedEntity
            $attribute = $argument-&gt;getAttributes(MapHydratedEntity::class, ArgumentMetadata::IS_INSTANCEOF)[0] ?? null;

            if (!($attribute instanceof MapHydratedEntity)) {
                return [];
            }

            // Agit comme un MapEntity
            $entity = $this-&gt;entityValueResolver-&gt;resolve($request, $argument)[0] ?? null;
            if (!$entity::class || $entity::class !== $argument-&gt;getType()) {
                throw new NotFoundHttpException(sprintf('"%s" object not found by "%s".', $argument-&gt;getType(), self::class));
            }

            // Hydrate l'objet avec le contenu de la requête
            $this-&gt;serialize-&gt;deserialize($request-&gt;getContent(), $entity::class, $request-&gt;getContentTypeFormat() ?? 'json', [
                'groups' =&gt; $attribute-&gt;groups,
                AbstractNormalizer::OBJECT_TO_POPULATE =&gt; $entity,
            ]);
            $violations = $this-&gt;validator-&gt;validate($entity, groups: $attribute-&gt;validationGroups);

            if (\count($violations)) {
                throw HttpException::fromStatusCode(Response::HTTP_UNPROCESSABLE_ENTITY, implode("\n", array_map(static fn ($e) =&gt; $e-&gt;getMessage(), iterator_to_array($violations))), new ValidationFailedException($entity, $violations));
            }

            return [
                $entity,
            ];
        }

    }

?&gt;</code></pre>
                    <h3>Étape 43 : Héberger Symfony sur un hébergement mutualisé O2Switch (via SSH / Git) :</h3>
                    <p>Dans cette partie, nous allons voir comment déployer notre application Symfony sur un hébergeur qui utilise l'interface CPanel. Ici, nous utiliserons l'hébergement <a href="https://osw.yt/r/o2switch-site" target="_blank">O2Swith</a>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour intéragir avec le serveur, nous utiliserons le protocole SSH. Vous pouvez voir <a href="https://grafikart.fr/tutoriels/clef-ssh-server-2203" target="_blank">comment utiliser une clef SSH</a>.</p>
                    </div>
                    <h4>Préparation de l'environnement :</h4>
                    <p>La première étape est de préparer le serveur pour accueillir notre site :</p>
                    <ul>
                        <li>
                            <p>On ajoute notre IP à la liste des IPs autorisées à se connecter en SSH au serveur via <span class="em">Autorisation SSH</span>.</p>
                        </li>
                        <li>
                            <p>On commence par <span class="em">Ajouter un domaine</span> que l'on fait pointer vers un possible spécifique (on pensera à ponter vers le dossier public). Par exemple :<span class="em">~/sites/mondomaine.tld/public</span>.</p>
                        </li>
                        <li>
                            <p>On génère un certificat SSL, depuis "<span class="em">Lets Encrypt<sup>TM</sup> SSL</span>".</p>
                        </li>
                        <li>
                            <p>On crée une base de données avec son utilisateur associé (vous pouvez utiliser l'option "assistant" pour faire cette opération en une fois).</p>
                        </li>
                        <li>
                            <p>Sur "<span class="em">Sélectionner une version de PHP</span>", on activera la version 8.2 nécessaire au fonctionnement de <span class="em">Symfony</span>.</p>
                        </li>
                    </ul>
                    <h4>Préparation du site :</h4>
                    <p>Pour que l'application Symfony soit déployée, il faut faire pointer les liens vers le fichier <span class="em">index.php</span> du dossier public. Les hébergeurs utilisent souvent Apache et il faudra ajouter un fichier de configuration <span class="html">.htaccess</span>. Cela peut se faire facilement à l'aide de <span class="em">symfony/apache-pack</span>.</p>
<pre><code>composer require symfony/apache-pack</code></pre>
                    <p>Maintenant que notre serveur est configuré, on va devoir copier le code source de notre site sur le serveur. Dans notre cas, nous allons cloner notre projet depuis le dépôt distant git.</p>
<pre><code>cd ~/sites
git clone git@github.com:DrissV/mondomaine.tld</code></pre>
                    <p>Ensuite, on va modifier la configuration du site en créant un fichier <span class="em">.env.local</span>. À adapter en fonction de votre environnement.</p>
<pre><code>APP_ENV=prod
DATABASE_URL="mysql://user:password@127.0.0.1:3306/monsite?serverVersion=11.2.2-MariaDB&charset=utf8mb4"
MAILER_DSN=native://default</code></pre>
                    <p>Enfin, on installe les dépendances, et on lance les migrations pour mettre à jour notre base de données.</p>
<pre><code>composer install --no-dev --optimize-autoloader
composer dump-env prod
php bin/console importmap:install
php bin/console asset-map:compile
php bin/console doctrine:migrations:migrate
APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear</code></pre>
                    <p>Et voilà ! Le site devrait maintenant être visible et fonctionnel.</p>
                    <h4>Automatiser avec Make :</h4>
                    <p>Pour automatiser le processus de déploiement d'une nouvelle version, il est possible d'utiliser un fichier <span class="html">Makefile</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p><a href="https://grafikart.fr/tutoriels/makefile-953" target="_blank">Connaissance de Makefile</a></p>
                    </div>
<pre><code>server := "user@mondomain.ltd"
domain := "mondomain.ltd"

.PHONY: install deploy

deploy:
    ssh -A $(server)$ 'cd sites/$(domain) &amp;&amp; git pull origin main &amp;&amp; make install'

install: vendor/autoload.php
    php bin/console doctrine:migrations:migrate -n
    php bin/console importmap:install
    php bin/console asset-map:compile
    composer dump-env prod
    php bin/console cache:clear

vendor/autoload.php: composer.lock composer.json
    composer install --no-dev --optimize-autoloader
    touch vendor/autoload.php</code></pre>
                    <p>Si vous souhaitez déployer une mise à jour, il vous suffira de taper la commande <span class="html">make deploy</span>.</p>
                    <h4>Messenger :</h4>
                    <p>Malheureusement, il n'est pas possible d'utiliser un superviseur pour faire fonctionner <span class="em">Messenger</span>. Une solution alternative est d'utiliser une tâche récurrente qui traitera les tâches toutes les 5 minutes.</p>
<pre><code>/usr/local/bin/php /home/USER/sites/mondomain.ltd/bin/console messenger:consume --time-limit=295 --memory-limit=128M async &gt; /home/USER/sites/mondomain.ltd/var/log/cron.log 2&gt;&amp;1</code></pre>
                    <h3>Étape 44 : Héberger Symfony sur un hébergement mutualisé Infomaniak (SSH / Git) :</h3>
                    <p>Dans cette partie, nous allons voir comment héberger notre application Symfony sur un hébergement mutualisé qui supporte SSH. Ici, je vais utiliser l'offre d'hébergement <a href="https://www.infomaniak.com/goto/fr/hosting.classic?utm_term=59f74db50448d" target="_blank">Infomaniak</a> mais vous pouvez reproduire ce que l'on va faire sur n'importe quel hébergeur qui vous laisse un accès SSH sur le serveur.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p>Pour intéragir avec le serveur, nous utiliserons le protocole SSH. Vous pouvez voir <a href="https://grafikart.fr/tutoriels/clef-ssh-server-2203" target="_blank">comment utiliser une clef SSH</a>.</p>
                    </div>
                    <h4>Préparation du site :</h4>
                    <p>Pour que l'application Symfony soit déployée, il faut faire pointer les liens vers le fichier <span class="em">index.php</span> du dossier <span class="em">public</span>. Les hébergeurs utilisent souvent Apache et il faudra ajouter un fichier de configuration <span class="html">.htaccess</span>. Cela peut se faire facilement à l'aide de <span class="em">symfony/apache-pack</span>.</p>
<pre><code>composer require symfony/apache-pack</code></pre>
                    <h4>Clonage du projet en ligne :</h4>
                    <p>Pour déployer le code source, nous allons utiliser git et cloner le dépôt distant. Pour m'organiser, je met les sites dans un dossier <span class="em">sites</span> mais vous être libres de suivre la convention que vous préférez.</p>
<pre><code>cd ~/sites
git clone git@github.com:DrissV/DemoSF.git</code></pre>
                    <p>On modifiera ensuite les variables d'environnements en créant un fichier <span class="em">.env.local</span> qui contiendra les variables spécifiques à notre environnement.</p>
                    <p>Pour la base de données, <a href="https://www.infomaniak.com/goto/fr/hosting.classic?utm_term=59f74db50448d" target="_blank">Infomaniak</a> utilise MariaDB et vous pouvez créer une base depuis votre espace d'Administration. Je vous conseille de créer un utilisateur en même temps pour limiter l'accès à cette base de données seulement.</p>
<pre><code>APP_ENV=prod
APP_SECRET=descaracteresaleatoireici

DATABASE_URL="mysql://user:pass@user.myd.infomaniak.com:3306/database?serverVersion=10.4.25-MariaDB&charset=utf8mb4"

MAILER_DSN=native://default</code></pre>
                    <p>Une fois l'environnement modifié, on pourra lancer l'installation des dépendances.</p>
<pre><code>/opt/php8.2/bin/composer install --no-dev --optimize-autoloader
/opt/php8.2/bin/composer dump-env prod
/opt/php8.2/bin/php bin/console importmap:install
/opt/php8.2/bin/php bin/console asset-map:compile
/opt/php8.2/bin/php bin/console doctrine:migrations:migrate
APP_ENV=prod APP_DEBUG=0 /opt/php8.2/bin/php bin/console cache:clear</code></pre>
                    <h4>Configuration de l'hébergement :</h4>
                    <p>Maintenant que nos sources sont en ligne, il va falloir configurer l'hébergeur afin de lui dire comment résoudre notre nom de domaines. Pour Infomaniak, cela se passe dans la partie <span class="em">Mes sites &gt; Gestion des sites &gt; Ajouter un site</span>. Sélectionnez l'option "Continuez sans installer d'outil". Ensuite, vous pouvez sélectionner le domaine (ou le sous-domaine) à associer à ce nouveau site et cliquer sur <span class="em">continuer</span> pour finaliser la création du site.</p>
                    <p>Une fois le site créé, vous devrez faire plusieurs changements :</p>
                    <ul>
                        <li>
                            <p>Modifier la version de PHP pour correspondre au besoin de Symfony (version 8.2 minimum) et activer des extensions supplémentaires si nécessaire.</p>
                        </li>
                        <li>
                            <p>Installer le certificat avec Let's encrypt (en un clic).</p>
                        </li>
                        <li>
                            <p>Aller dans les <span class="em">Paramètres avancés</span> pour modifier le dossier du site et pointer vers le dossier public de Symfony <span class="em">/sites/monsite.tld/public</span>.</p>
                        </li>
                        <li>
                            <p>Dans les <span class="em">Paramètres avancés</span> puis dans l'onglet <span class="em">Apache</span>, vous pourrez activer la compression des fichiers mais aussi gérer des variables d'environnement que vous souhaitez ajouter à votre application Symfony.</p>
                        </li>
                    </ul>
                    <p>À partir de cette étape, votre site devrait fonctionner et être visible lorsque vous tapez votre nom de domaine.</p>
                    <h4>Automatiser avec Make :</h4>
                    <p>Pour automatiser le processus de déploiement d'une nouvelle version, il est posssible d'utiliser un fichier <span class="html">Makefile</span>.</p>
                    <div class="information">
                        <img src="../images/information.png" alt="Information" class="float_left">
                        <p><a href="https://grafikart.fr/tutoriels/makefile-953" target="_blank">Connaissance de Makefile</a></p>
                    </div>
<pre><code>server := "user@mondomain.ltd"
domain := "mondomain.ltd"

.PHONY: install deploy

deploy:
    ssh -A $(server)$ 'cd sites/$(domain) &amp;&amp; git pull origin main &amp;&amp; make install'

install: vendor/autoload.php
    /opt/php8.2/bin/php bin/console d:m:m -n
    /opt/php8.2/bin/composer dump-env prod
    /opt/php8.2/bin/php bin/console cache:clear

vendor/autoload.php: composer.json composer.lock
    /opt/php8.2/bin/composer install --no-dev --optimize-autoloader
    touch vendor/autoload.php</code></pre>
                    <p>Si vous souhaitez déployer une mise à jour, il vous suffira de taper la commande <span class="html">make deploy</span>.</p>
                    <p>Dans le tutoriel suivant, nous aborderons Laravel, un autre framework PHP populaire pour le développement web.</p>
                </article>
                <article>
                    <h2 id="intro_laravel">Introduction au Framework PHP Laravel :</h2>
                    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Laravel. Laravel est un framework web élégant et puissant qui facilite le développement rapide d'applications web modernes.</p>
                    <h3>Étape 1 : Installation de Laravel :</h3>
                    <p>Avant de commencer, assurez-vous d'avoir PHP et le grestionnaire de dépendances Composer installés sur votre système.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Laravel en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project --prefer-dist laravel/laravel nom_du_projet</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Laravel propose un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>php artisan serve</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvre le fichier <span class="em">`routes/web.php`</span> avec votre éditeur de code préféré.</p>
                        </li>
                        <li>
                            <p>Définissez une nouvelle route pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette ligne au fichier web.php
Route::get('/', 'App\Http\Controllers\HomeController@index');</code></pre>
                        </li>
                        <li>
                            <p>Créez un nouveau contrôleur pour gérer cette route :</p>
<pre><code>php artisan make:controller HomeController</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Implémenter la logique du contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvrez le fihcier <span class="em">`app/Http/Controllers/HomeController.php`</span> avec votre éditeur de code.</p>
                        </li>
                        <li>
                            <p>Implémentez la logique du contôleur pour retourner la vue (template) :</p>
<pre><code>// Ajoutez cette méthode à la classe HomeController
public function index() {
    return view('homepage');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 5 : Création de la vue (template) :</h3>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`ressources/views/homepage.blade.php`</span> dans le répertoire du projet.</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Laravel&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Laravel !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenue sur Mon Projet Laravel !" sur la page d'accueil.</p>
                    <p>Félicitations ! Vous avez maintenant créé une application web simple en utilisant Laravel. Laravel propose de nombreuses fonctionnalités pratiques telles que la gestion des migrations de base de données, l'ORM Eloquent, les formulaires, l'authentification et bien olus encore.</p>
                    <p>Vous pouvez continuer à explorer la documentation officielle de Laravel pour découvrir davantage de fonctionnalités et d'outils puissants offerts par ce framework. Laravel dispose également d'une communauté active qui partage de nombreux packages et ressources pour faciliter le développement de vos projets web.</p>    
                </article>
                <article>
                    <p>Pour plus d'informations pour savoir comment choisir entre Laravel et Symfony, voici <a href="https://grafikart.fr/tutoriels/laravel-symfony-866" target="_blank">le tutoriel vidéo de Grafikart</a>.</p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>