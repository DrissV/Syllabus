<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Symfony et Laravel - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="supplements_php.html">Retour au sommaire</a></li>
                        <li><a href="#choix_symfony_laravel">Le choix entre Symfony et Laravel</a></li>
                        <li><a href="#developpement_SOLID">Le développement SOLID</a></li>
                        <li><a href="#intro_symfony">Introduction à Symfony</a></li>
                        <li><a href="#intro_laravel">Introduction à Laravel</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Symfony et Laravel :</h1>
                </article>
                <article>
                    <p>Pour ceux qui utilisent Visual Studio Code, vous devez installer les extensions "PHP Namespace Resolver" et "PHP Docblocker" pour PHP mais également "PHP Intelephense" et "PHP Getters & Setters" si besoin.</p>
                    <h2 id="choix_symfony_laravel">Le choix entre Symfony et Laravel :</h2>
                    <p>Ce choix dépend de plusieurs facteurs, notamment vos besoins spécifiques, vos compétences en programmation, la taille du projet et la communauté de soutien. Les deux frameworks sont populaires et largement utilisés dans le développement web en PHP, mais ils ont des approches et des fonctionnalités différentes. Voici un bref aperçu de chacun :</p>
                    <h3>Symfony :</h3>
                    <ul>
                        <li>
                            <p>Symfony est un framework PHP mature et robuste, qui suit les principes de développement SOLID et encourage une approche modulaire pour la construction d'application web.</p>
                        </li>
                        <li>
                            <p>Il est hautement personnalisable et modulaire, vous permettant de choisir les composants dont vous avez besoin pour votre projet spécifique.</p>
                        </li>
                        <li>
                            <p>Symfony est connu pour sa stabilité, sa documentaion détaillée et sa grande communauté de développeurs. Il est souvent préféré pour les projets d'entreprise de grande envergure.</p>
                        </li>
                        <li>
                            <p>Il met l'accent sur la réutilisation du code grâce à ses composants réutilisables, ce qui peut accélérer le processus de développement.</p>
                        </li>
                        <li>
                            <p>Cependant, il peyt être plus verbeux que Laravel, nécessitant parfois plus de code pour accomplir certaines tâches.</p>
                        </li>
                    </ul>
                    <h3>Laravel :</h3>
                    <ul>
                        <li>
                            <p>Laravel est également un framework PHP populaire qui se concentre sur la simplicité et l'élégance du code. Il suit le modèle MVC (Modèle-Vue-Contrôleur) et propose une syntaxe expressive et concise.</p>
                        </li>
                        <li>
                            <p>Il est livré avec de nombreuses fonctionnalités intégrées, telles que l'ORM Eloquent, la gestion des migrations de base de données, le système de routage convivial, l'intégration de la messagerie et bien plus encore.</p>
                        </li>
                        <li>
                            <p>Laravel est souvent choisi pour les projets de taille moyenne à grande, mais il est également adapté aux petites applications en raison de sa courbe d'apprentissage douce.</p>
                        </li>
                        <li>
                            <p>Il dispose d'une communauté active et de documentation complète, ce qui facilite la résolution des problèmes et l'apprentissage du framework.</p>
                        </li>
                        <li>
                            <p>Cependant, en raison de son approche "magique", il peut être moins prévisible et modulaire que Symfony.</p>
                        </li>
                    </ul>
                    <p>En fin de compte, le choix entre Symfony et Laravel dépend de vos préférences personnelles, de votre expérience en développement PHP et des besoins spécifiques de votre projet. Si vous appréciez la modularité, la personnalisation et la réutilisation du code, Symfont pourrait être un bon choix. Si vous recherchez la simplicité, l'efficacité et la rapidité de développement, Laravel pourrait mieux vous convenir.</p>
                    <p>Il est recommandé de prendre le temps de tester les deux frameworks, de lire leur documentation, de consulter des tutoriels (dans la suite, j'introduis chacun d'eux) et de participer aux communautés pour vous faire une idée plus précise de leurs avantages et de leurs inconvénients. Quel que soit votre choix, les deux frameworks offrent d'excellentes solutions pour le développement web en PHP.</p>
                </article>
                <article>
                    <h2 id="developpement_SOLID">Le développement SOLID :</h2>
                    <p>Le développement SOLID est un ensemble de principes fondamentaux de conception de logiciels qui visent à créer des systèmes logiciels flexibles, maintenables et évolutifs. Le terme SOLID est un acronyme qui représente les cinq principes individuels qui le composent. Ces principes ont été formulés par Robert C. Martin (également connu sous le nom de "Uncle Bob") et sont largement utilisés dans le développement logiciel orienté objet.</p>
                    <p>Voici une brève description de chaque principe SOLID :</p>
                    <ol>
                        <li>
                            <h3>Principe de Responsabilité Unique (Single Responsibility Principle - SRP) :</h3>
                            <p>Ce principe stipule qu'une classe (ou un module) ne devrait avoir qu'une seule raison de changer. En d'autres termes, une classe ne doit être responsable que d'une seule fonctionnalité ou tâche spécifique. Cela favorise la sépération des responsabilités et permet de rendre les classes plus cohérentes et plus facilement modifiables.</p>
                        </li>
                        <li>
                            <h3>Principe Ouvert/Fermé (Open/Closed Principle - OCP) :</h3>
                            <p>Le principe OCP indique qu'une classe doit être ouverte à l'extension (ajout de nouvelles fonctionnalités) mais fermée à la modification (le comportement existant ne doit être modifié). Plutôt que de modifier une classe existante, vous devriez étendre ses fonctionnalités en créant de nouvelles classes qui héritent des fonctionnalités de la classe de base.</p>
                        </li>
                        <li>
                            <h3>Principe de Substitution de Liskov (Liskov Substitution Principle - LSP) :</h3>
                            <p>Ce principe souligne que les objets d'une classe dérivée doivent pouvoir être substitués aux objets de la classe de base sans affecter la cohérence du programme. En d'autres termes, une classe dérivée doit être en mesure de remplacer sa classe de base sans provoquer d'effets indésirables ou d'erreurs.</p>
                        </li>
                        <li>
                            <h3>Principe de Ségrégation des Interfaces (Interface Segregation Principle - ISP) :</h3>
                            <p>L'ISP suggère que les interfaces clients ne devraient pas être forcées de dépendre des méthodes qu'elles n'utilisent pas. Plutôt que de créer de grandes interfaces contenant de nombreuses méthodes, vous devriez diviser les interfaces en petites interfaces spécifiques à chaque client.</p>
                        </li>
                        <li>
                            <h3>Principe d'Inversion des Dépendances (Dependency Inversion Principle - DIP) :</h3>
                            <p>Le DIP met l'accent sur le fait que les modules de haut niveau ne doivent pas dépendre des modules de bas niveau, mais des abstractions. Cela signifie que les détails d'implémentation doivent dépendre des abstractions plutôt que l'inverse. En utilisant l'inversion des dépendances, vous pouvez rendre vos applications plus flexibles et plus faciles à étendre.</p>
                        </li>
                    </ol>
                    <p>En suivant ces principes SOLID, les développeurs peuvent créer des codes plus robustes, éviter les dépendances rigides et faciliter la maintenance et l'évolution des applications. Les principes SOLID sont largement considérés comme les meilleures pratiques de conception orientée objet et sont utilisés pour créer des logiciels de haute quantité et faciles à maintenir.</p>
                </article>
                <article>
                    <h2 id="intro_symfony">Introduction au Framework PHP Symfony :</h2>
                    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Symfony. Symfony est un framework web puissant et flexible qui facilite le développement d'applications web évolutives et de haute qualité.</p>
                    <p>Vous trouverez la documentation complète de Symfony à l'adresse suivante : <a href="https://symfony.com/doc/current/index.html" target="_blank">https://symfony.com/doc/current/index.html</a>.</p>
                    <h3>Étape 1 : Installation de Symfony :</h3>
                    <p>Avant de commencer, assurez-vous que vous disposez d'une installation de PHP et du gestionnaire de dépendances Composer sur votre système.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Symfony en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project symfony/website-skeleton nom_du_projet</code></pre>
                            <p>Ou encore, si vous avez installé le Symfony CLI et que vous l'avez mis dans le PATH, vous pouvez faire la même chose avec la commande :</p>
<pre><code>symfony new nom_du_projet --full</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                            <p>Remarque : Au moment où j'écris ces lignes, l'option <span class="em">--full</span> est déprécié, mais il existe l'option <span class="em">--webapp</span> à la place.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                            <p>Dans un projet Symfony typique, vous trouverez généralement les dossiers suivants à la racine du projet :</p>
                            <ol>
                                <li>
                                    <p><span class="em">bin/</span> : Contient des scripts exécutables, tels que <span class="html">console</span>, qui est utilisé pour exécuté des commandes Symfony en ligne de commande.</p>
                                </li>
                                <li>
                                    <p><span class="em">config/</span> : Contient les fichiers de configuration de l'application, tels que <span class="html">config.yaml</span> (ou <span class="html">config.yml</span>), <span class="html">services.yaml</span>, <span class="html">routes.yaml</span>, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">migrations/</span> : Dans les projets Symfony qui utilisent Doctrine, un outil de mapping objet-relationnel (ORM) pour PHP, contient les fichiers de migration de base de données.</p>
                                </li>
                                <li>
                                    <p><span class="em">public/</span> : Contient les fichiers accessibles publiquement par le navigateur, tels que les fichiers CSS, JavaScript, les images, ainsi que le fichier <span class="em">index.php</span> qui est le point d'entrée de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">src/</span> : Contient le code source de l'application. C'est ici que vous trouverez généralement les contrôleurs, les entités, les formulaires, les services, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">templates/</span> : Contient les fichiers de templates Twig utilisés pour générer les vues de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">tests/</span> : Contient les tests unitaires et fonctionnels de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">translations/</span> : Contient les fichiers de traduction de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">var/</span> : Contient les fichiers générés par l'application, tels que les caches, les logs, les sessions, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">vendor/</span> : Contient les dépendances installées via Composer, le gestionnaire de dépendances de PHP.</p>
                                </li>
                                <li>
                                    <p><span class="html">.env</span> : Fichier de configuration de l'environnement, utilisé pour définir des variables d'environnement telles que les paramètres de connexion à la base de données, les clés secrètes, etc.</p>
                                </li>
                                <li>
                                    <p><span class="html">composer.json</span> et <span class="html">composer.lock</span> : Fichiers utilisés par Composer pour gérer les dépendances du projet.</p>
                                </li>
                                <li>
                                    <p><span class="html">symfony.lock</span> : Fichier utilisé par Symfony pour verouiller les versions des composants Symfony installés.</p>
                                </li>
                            </ol>
                            <p>Ce sont les principaux dossiers et fichiers que vous trouverez dans un projet Symfony standard. Le contenu exact peut varier en fonction de la version de Symfony et des besoins spécifiques du projet.</p>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Symfony fournit un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>symfony server:start</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Créez le contrôleur nommé <span class="em">DefaultController</span> en utilisant la commande suivante :</p>
<pre><code>php bin/console make:controller DefaultController</code></pre>
                            <p>Ou encore on utilise la syntaxe suivante qui fait la même chose :</p>
<pre><code>symfony console make:controller DefaultController</code></pre>
                        </li>
                        <li>
                            <p>Ouvrez le fichier <span class="em">`src/Controller/DefaultController.php`</span> avec votre éditeur de code préféré et voici le code généré par la commande :</p>
<pre><code>&lt;?php

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    
    class DefaultController extends AbstractController
    {
        #[Route('/default', name: 'app_default')]
        public function index(): Response
        {
            return $this->render('default/index.html.twig', [
                'controller_name' =&gt; 'DefaultController',
            ]);
        }
    }

?&gt;</code></pre>
                        </li>
                        <li>
                            <p>Créez une nouvelle action (méthode) dans le contrôleur pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette méthode à la classe DefaultController
#[Route('/', 'home.index', methods: ['GET'])]
public function homepage() : Response {
    return $this-&gt;render('pages/homepage.html.twig');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Création de la vue (template) :</h3>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`templates/pages/homepage.html.twig`</span> dans le répertoire du projet (si le dossier "pages" n'existe pas encore, créez-le).</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Symfony&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                        <li>
                            <p>Modifiez le template pour qu'il étend de celui de base dans le fichier <span class="em">`templates/base.html.twig`</span> :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Mon Projet Symfony{% endblock %}

{% block body %}
    &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
{% endblock %}</code></pre>
                        </li>
                        <li>
                            <p>Vous pouvez également modifier votre template de base pour intégrer Bootstrap : dans le block <span class="em">stylesheets</span>, on met <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" target="_blank">le lien CDN CSS de Bootstrap</a> et, dans le block <span class="em">javascripts</span>, <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" target="_blank">le lien CDN JS de Bootstrap</a>.</p>
                        </li>
                        <li>
                            <p>On peut également inclure un template Twig dans un autre comme par exemple :</p>
<pre><code>{% include "partials/_header.html.twig" %}</code></pre>
                            <p>Ça permet donc d'inclure le fichier partiel "header" pour avoir le même header sur toutes les pages.</p>
                        </li>
                    </ol>
                    <h3>Étape 5 : Définir la route :</h3>
                    <ol>
                        <li>
                            <p>Ouvrez le fichier <span class="em">`config/routes.yaml`</span> avec votre éditeur de code.</p>
                        </li>
                        <li>
                            <p>Définissez une nouvelle route pour accéder à la page d'accueil :</p>
<pre><code># Ajoutez cette ligne au fichier routes.yaml
homepage:
    path: /
    controller: App\Controller\DefaultController::homepage</code></pre>
                            <p>En Symfony 7 et plus, on a plus besoin de la définir car elle est directement écrit dans le contrôleur.</p>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenur sur Mon Projet Symfony !" sur la page d'accueil.</p>
                    <p>C'est tout ! Vous avez maintenant créé une application web simple en utilisant Symfony. Vous pouvez continuer à explorer la documentation officielle de Symfony pour découvrir plus de fonctionnalités et d'outils puissants offerts par ce framework.</p>
                    <p>En 2024, je rajoute de nouvelles étapes pour améliorer ce tutoriel sur Symfony. Voici les nouveautés :</p>
                    <h3>Étape 7 : Notre première entité :</h3>
                    <p>Dans le fichier <span class="em">.env</span>, on va modifier la variable <span class="html">DATABASE_URL</span> pour que ça correspond bien à notre base de données. Sa syntaxe sera :</p>
<pre><code>DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7"</code></pre>
                    <p>On doit remplacer "db_user", "db_password" et "db_name" par les valeurs que l'on a définies. Si la base de données avec le nom stocké dans "db_name" n'est pas encore dans PHP My Admin, on peut la créer avec la commande suivante :</p>
<pre><code>php bin/console doctrine:database:create</code></pre>
                    <p>Ou on peut utiliser la commande abrégée :</p>
<pre><code>php bin/console d:d:c</code></pre>
                    <p>Remarque : Ça lance une erreur si la base de données existe déjà. On verra sûrement un peu plus tard comment faire pour la supprimer.</p>
                    <p>Dans un projet de recettes de cuisine, on a besoin d'une entité pour l'ingrédient qui sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui ne pourra pas excéder plus de 50 caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un prix au kg (par exemple 2 euros le kilo) qui ne pourra être inférieur à 1 et supérieur à 200. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>Un champ contenant la date de création qui doit être générée automatiquement une fois l'ingrédient créé.</p>
                        </li>
                    </ul>
                    <p>Pour créer cette entité, on utilise la commande :</p>
<pre><code>php bin/console make:entity Ingredient</code></pre>
                    <p>Cette commande crée deux fichiers : <span class="em">`src/Entity/Ingredient.php`</span> et <span class="em">`src/Repository/IngredientRepository.php`</span>.</p>
                    <p>Ensuite, il demande le nom des propriétés, son type, sa longueur et s'il est nullable en base de données. Par exemple, la propriété "name" est une "string" de "50" caractères "no" nullable.</p>
                    <p>Voici la classe entité "Ingredient.php" (je ne mettrais pas tous les getters et les setters) :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this->createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <p>Ensuite, comme avec Laravel, on va faire une migration pour migrer les entités dans la base de données avec la commande :</p>
<pre><code>php bin/console make:migration</code></pre>
                    <p>Dans cette migration, on a du SQL pur et dur. Symfony a interprété l'entité en SQL et donc a fait un <span class="html">CREATE TABLE</span> dans la fonction <span class="em">up</span> et un <span class="html">DROP TABLE</span> dans la fonction <span class="em">down</span>.</p>
                    <p>Maintenant on va migrer toutes les migrations vers la base de données avec la commande :</p>
<pre><code>php bin/console doctrine:migrations:migrate</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Si la base de données était vide, ça rajoute une table supplémentaire de la table "Ingredient" de notre migration qui est nommée "doctrine_migration_versions" et qui contient la version de la migration, la date d'exécution et le temps d'exécution en milisecondes.</p>
                    <p>Pour gérer les différentes contraintes des données, comme par exemple que le prix ne doit pas être inférieur à 1, on utilise des <span class="html">Assert</span>. Reprenons l'exemple de notre entité "Ingredient" :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        #[Assert\NotNull()]
        #[Assert\Positive()]
        #[Assert\LessThan(200)]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this->createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <h3>Étape 8 : Création des Fixtures :</h3>
                    <p>Dans la suite de ce tutoriel, on va créer des fixtures qui permettent de nous générer un jeu de fausses données comme un Faker.</p>
                    <p>Pour faire cela, on va installer les packages en développement :</p>
<pre><code>composer require --dev orm-fixtures</code></pre>
                    <p>Ainsi que la commande :</p>
<pre><code>composer require --dev fakerphp/faker</code></pre>
                    <p>Ces commandes ont créer le dossier <span class="em">`src/DataFixtures`</span> et dedans le fichier <span class="em">AppFixtures</span> avec le contenu que l'on va modifier comme cela :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $manager-&gt;persist($ingredient);
            }

            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on va les charger avec la commande :</p>
<pre><code>php bin/console doctrine:fixtures:load</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <h3>Étape 9 : CRUD sur la table "Ingredient" :</h3>
                    <p>Maintenant, on va enfin faire des CRUD sur la table "Ingredient". D'abord, on va afficher la liste des ingrédients.</p>
                    <p>Premièrement, on va créer un nouveau contrôleur "IngredientController" avec la commande :</p>
<pre><code>php bin/console make:controller IngredientController</code></pre>
                    <p>Remarque : Ça va créer le fichier <span class="em">`templates/ingredient/index.html.twig`</span>, mais, pour faire un peu le ménage, on va créer un dossier "pages" et donc on va y insérer dedans le dossier "ingredient".</p>
                    <h4>Lister tous les ingrédients :</h4>
                    <p>Modifions la fonction "index" de notre contrôleur fraîchement créé :</p>
<pre><code>#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository) : Response
{
    $ingredients = $repository->findAll();
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>On va modifier le fichier TWIG comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Mes ingréidents{% endblock %}

{% block body %}
    &lt;div class="container mt-4"&gt;
        &lt;h1&gt;Mes ingrédients&lt;/h1&gt;

        &lt;table class="table table-hover"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th scope="col"&gt;Numéro&lt;/th&gt;
                    &lt;th scope="col"&gt;Nom&lt;/th&gt;
                    &lt;th scope="col"&gt;Prix&lt;/th&gt;
                    &lt;th scope="col"&gt;Date de création&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                {% for ingredient in ingredients %}
                    &lt;tr class="table-primary"&gt;
                        &lt;th scope="row"&gt;{{ ingredient.id }}&lt;/th&gt;
                        &lt;td&gt;{{ ingredient.name }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.price }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.createdAt|date('d/m/Y') }}&lt;/td&gt;
                    &lt;/tr&gt;
                {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
        
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour la pagination dans la page, on va utiliser le bundle "KnpPaginatorBundle" en l'instalalnt avec la commande :</p>
<pre><code>composer require knplabs/knp-paginator-bundle</code></pre>
                    <p>On va créer le fichier <span class="em">`config/packages/knp_paginator.yaml`</span> avec le contenu suivant :</p>
<pre><code>knp_paginator:
    page_range: 5                       # number of links shown in the pagination menu (e.g: you have 10 pages, a page_range of 3, on the 5th page you'll see links to page 4, 5, 6)
    default_options:
        page_name: page                 # page query parameter name
        sort_field_name: sort           # sort field query parameter name
        sort_direction_name: direction  # sort direction query parameter name
        distinct: true                  # ensure distinct results, useful when ORM queries are using GROUP BY statements
        filter_field_name: filterField  # filter field query parameter name
        filter_value_name: filterValue  # filter value query parameter name
    template:
        pagination: '@KnpPaginator/Pagination/bootstrap_v5_pagination.html.twig'     # sliding pagination controls template
        rel_links: '@KnpPaginator/Pagination/rel_links.html.twig'     # &lt;link rel=...&gt; tags template
        sortable: '@KnpPaginator/Pagination/sortable_link.html.twig' # sort link template
        filtration: '@KnpPaginator/Pagination/filtration.html.twig'  # filters template</code></pre>
                    <p>Modifions notre fonction "index" de notre cotrôleur pour qu'elle prenne en compte la pagination :</p>
<pre><code>use Knp\Component\Pager\PaginatorInterface;
use Symfony\Component\HttpFoundation\Request;

/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository->findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10    
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>On va modifier également le fichier TWIG en ajoutant ceci :</p>
<pre><code>&lt;div class="count mt-4"&gt;
    &lt;p&gt;Il y a {{ ingredients.getTotalItemCount }} ingrédients au total&lt;/p&gt;
&lt;/div&gt;
    
&lt;div class="navigation d-flex justify-content-center mt-4"&gt;
    {{ knp_pagination_render(ingredients) }}
&lt;/div&gt;</code></pre>
                    <p>On peut faire un <span class="html">{% if not ingredients.items is same as([]) %}</span> pour vérifier que la liste n'est pas vide.</p>
                    <h4>Créer un nouvel ingrédient :</h4>
                    <p>Pour la création d'un nouvel ingrédient, on va créer un nouveau formulaire "IngredientType" avec l'entité "Ingredient" via la commande :</p>
<pre><code>php bin/console make:form</code></pre>
                    <p>Ça permet de créer le fichier <span class="em">`src/Form/IngredientType.php`</span> avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Form;

    use App\Entity\Ingredient;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\MoneyType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\OptionsResolver;

    use Symfony\Component\Validator\Constraints as Assert;

    class IngredientType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                -&gt;add('name', TextType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                        'minlength' =&gt; '2',
                        'maxlength' =&gt; '50'
                    ],
                    'label' =&gt; 'Nom',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                        new Assert\NotBlank()
                    ]
                ])
                -&gt;add('price', MoneyType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                    ],
                    'label' =&gt; 'Prix',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Positive(),
                        new Assert\LessThan(200),
                        new Assert\NotNull()
                    ]
                ])
                -&gt;add('submit', SubmitType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'btn btn-primary mt-4'
                    ],
                    'label' =&gt; 'Créer mon ingrédient'
                ]);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver-&gt;setDefaults([
                'data_class' =&gt; Ingredient::class,
            ]);
        }
    }

?&gt;</code></pre>
                    <p>Dans notre IngredientController, on va créer une nouvelle fonction "new" :</p>
<pre><code>/**
*
* This controller show a form which create an ingredient
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/nouveau', 'ingredient.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $ingredient = new Ingredient();
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été créé avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va également créer le nouveau template <span class="em">`templates/ingredient/new.html.twig`</span> avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour ajouter des messages d'erreur, on va modifier le code précédent pour donner ceci :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form_start(form) }}
        
        &lt;div class="form-group"&gt;
            {{ form_label(form.name) }}
            {{ form_widget(form.name) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.name) }}
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="form-group"&gt;
            {{ form_label(form.price) }}
            {{ form_widget(form.price) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.price) }}
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="form-group"&gt;
            {{ form_row(form._token) }}
        &lt;/div&gt;

        &lt;div class="form-group"&gt;
            {{ form_row(form.submit) }}
        &lt;/div&gt;

        {{ form_end(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>On va afficher un message FLASH dans l'index pour dire que la création d'un ingrédient a eu un statut de succès ainsi qu'un lien qui permet d'accéder à la page de création d'un nouvel ingrédient. Voici le code à rajouter :</p>
<pre><code>&lt;a href="{{ path('ingredient.new') }} class="btn btn-primary"&gt;Créer un ingrédient&lt;/a&gt;

{# read and display just one flash message type #}
{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}</code></pre>
                    <p>Dans la navbar, on oublie pas de rajouter un lien vers "ingredient.index" pour accéder plus facilement à la liste des ingrédients.</p>
                    <h4>Éditer un ingrédient :</h4>
                    <p>Dans notre contrôleur, on va rajouter une nouvelle fonction pour pouvoir éditer un ingrédient :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param IngredientRepository $repository
* @param int $id
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(IngredientRepository $repository, int $id, Request $request, EntityManagerInterface $manager) : Response
{
    $ingredient = $repository-&gt;findBy(['id' =&gt; $id]);
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Ça c'est ce que la plupart des gens font d'habitude, mais nous on va utiliser un <span class="html">@ParamConverter</span> comme ceci :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param Ingredient $ingredient
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(Ingredient $ingredient, Request $request, Entity $manager) : Response
{
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Ensuite, dans le "edit.html.twig", on va copier le contenu du "new.html.twig" et modifier "Création" par "Modification".</p>
                    <h4>Supprimer un ingrédient :</h4>
                    <p>Pour le delete, on rajoute une nouvelle fonction "delete" dans le contrôleur :</p>
<pre><code>#[Route('/ingredient/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Ingredient $ingredient) : Response
{
    $manager-&gt;remove($ingredient);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre ingrédient a été supprimé avec succès !');

    return $this-&gt;redirectToRoute('ingredient.index');
}</code></pre>
                    <p>Dans la liste des ingrédients, on va rajouter deux nouvelles colonnes : une pour l'édition et l'autre pour la suppression :</p>
<pre><code>&lt;th scope="col"&gt;Édition&lt;/th&gt;
&lt;th scope="col"&gt;Suppression&lt;/th&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.edit', { id: ingredient.id }) }}" class="btn btn-info"&gt;Modifier&lt;/a&gt;
&lt;/td&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.delete', { id: ingredient.id }) }}" class="btn btn-danger"&gt;Supprimer&lt;/a&gt;
&lt;/td&gt;</code></pre>
                    <h3>Étape 10 : CRUD pour la table "Recipe" :</h3>
                    <p>Maintenant, on va faire le CRUD pour la table "Recipe". Pour information, une recette sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui sera obligatoire et ne pourra pas être vide, il ne pourra également pas excéder plus de 5à caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un temps (en minutes) qui n'est pas obligatoire. S'il est rempli, il ne pourra pas être inférieur à une minute et ne pourra pas dépasser les 24h.</p>
                        </li>
                        <li>
                            <p>Un nombre de personnes qui n'est pas obligatoire. S'il est rempli, il devra être inférieur à 50.</p>
                        </li>
                        <li>
                            <p>Une difficulté n'est pas obligatoire. Si elle esy rentrée, elle sera comprise entre 1 et 5.</p>
                        </li>
                        <li>
                            <p>Une liste d'étapes à suivre/description qui sera obligatoire et ne pourra pas être vide.</p>
                        </li>
                        <li>
                            <p>Un prix qui ne sera pas obligatoire. S'il est renseigné, le prix ne pourra pas être inférieur à 0 et supérieur à 1000. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>La possibilité de définir la recette comme étant favorite ou non.</p>
                        </li>
                        <li>
                            <p>Une date de création.</p>
                        </li>
                        <li>
                            <p>Une date de mise à jour.</p>
                        </li>
                        <li>
                            <p>Une liste d'ingrédients.</p>
                        </li>
                    </ul>
                    <p>Remarque : La date de création et la date de mise à jour seront générées automatiquement une fois la recette créée et/ou modifiée.</p>
                    <p>Premièrement, on doit créer l'entité "Recipe" avec les propriétés "name" de type "string" non nullable, "time" de type "integer" nullable, "nbPeople" de type "integer" nullable, "difficulty" de type "integer" nullable, "description" de type "text" non nullable, "price" de type "float" nullable, "isFavorite" de type "boolean" non nullable, "createdAt" de type "datetime_immutable" non nullable, "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Pour la propriété "ingredients" qui définit la liste des ingrédients, on va dire qu'il est de type "relation" lié à l'entité "Ingredient" dont le type de relation est "ManyToMany" et on veut pas récupérer depuis les ingrédients les recettes qui ont cet ingrédient.</p>
                    <p>Voici donc le code généré par la commande <span class="html">php bin/console make:entity Recipe</span> sans tous les getters et les setters et qu'on va modifier en ajoutant les <span class="em">Assert</span> :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\RecipeRepository;
    use Doctrine\Common\Collections\ArrayCollection;
    use Doctrine\Common\Collections\Collection;
    use Doctrine\ORM\Mapping as ORM;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('name')]
    #[ORM\HasLifecycleCallbacks]
    #[ORM\Entity(repositoryClass: RecipeRepository::class)]
    class Recipe
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank()]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1441)]
        private ?int $time;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(51)]
        private ?int $nbPeople;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(6)]
        private ?int $difficulty;

        #[ORM\Column(type: 'text')]
        #[Assert\NotBlank()]
        private string $description;

        #[ORM\Column(type: 'float', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1001)]
        private ?float $price;

        #[ORM\Column(type: 'boolean')]
        private bool $isFavorite;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $updatedAt;

        #[ORM\ManyToMany(targetEntity: Ingredient::class)]
        private $ingredients;

        public function __construct() {
            $this-&gt;ingredients = new ArrayCollection();
            $this-&gt;createdAt = new \DateTimeImmutable();
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        #[ORM\PrePersist]
        public function setUpdatedAtValue()
        {
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;string;
        }

        public function setName(string $name) : self
        {
            $this-&gt;name = $name;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Dans ma solution, je vais d'abord "DROP" toute la base de données avec la commande :</p>
<pre><code>php bin/console d:d:d --force</code></pre>
                    <p>Avant de la recréer avec la commande :</p>
<pre><code>php bin/console d:d:c</code></pre>
                    <p>Afin de créer une nouvelle migration avec la commande :</p>
<pre><code>php bin/console make:migration</code></pre>
                    <p>Et de migrer dans la base de données toutes les migrations avec la commande :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Deuxièmement, on va créer les fixtures en modifiant le fichier <span class="em">`src/DataFixtures/AppFixtures.php`</span> comme ceci :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use App\Entity\Recipe;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            $ingredients = [];
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $ingredients[] = $ingredient;
                $manager-&gt;persist($ingredient);
            }

            // Recipes
            $recipes = [];
            for ($j = 0; $j &lt; 25; $j++) {
                $recipe = new Recipe();
                $recipe-&gt;setName($this-&gt;faker-&gt;word())
                    -&gt;setTime(mt_rand(0, 1) == 1 ? mt_rand(1, 1440) : null)
                    -&gt;setNbPeople(mt_rand(0, 1) == 1 ? mt_rand(1, 50) : null)
                    -&gt;setDifiiculty(mt_rand(0, 1) == 1 ? mt_rand(1, 5) : null)
                    -&gt;setDescription($this-&gt;faker-&gt;text(300))
                    -&gt;setPrice(mt_rand(0, 1) == 1 ? mt_rand(1, 1000) : null)
                    -&gt;setIsFavorite(mt_rand(0, 1) == 1);
                
                for ($k = 0; $k &lt; mt_rand(5, 15); $k++) {
                    $recipe-&gt;addIngredient($ingredients[array_rand($ingredients)]);
                }
            }

            $recipes[] = $recipe;
            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Et on va pouvoir charger les nouvelles données factives avec la commande :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <p>Troisièmement, on va commencer le CRUD par lister toutes les recettes. Pour cela, on va créer le contrôleur "RecipeController" avec la commande :</p>
<pre><code>php bin/console make:controller RecipeController</code></pre>
                    <p>Remarque : On oublie pas de déplacer le dossier templates "recipe" dans le dossier "pages" et d'ajouter un lien vers cette page dans la navbar.</p>
                    <p>Maintenant, modifions la fonction "index" du contrôleur comme ceci :</p>
<pre><code>/**
* This controller display all recipes
*
* @param RecipeRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/recette', name: 'recipe.index', methods: ['GET'])]
public function index(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe/index.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>Quatrièmement, on va créer un nouveau formulaire pour la création d'une recette en rajoutant déjà dans le contrôleur la fonction "new" :</p>
<pre><code>#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(): Response
{
    return $this-&gt;render('pages/recipe/new.html.twig');
}</code></pre>
                    <p>Cinquièmement, on va créer le formulaire "RecipeType" lié à l'entité "Recipe" avec la commande suivante :</p>
<pre><code>php bin/console make:form RecipeType Recipe</code></pre>
                    <p>On va améliorer sa fonction "buildForm" en ajoutant par exemple un submit :</p>
<pre><code>public function buildForm(FormBuilderInterface $builder, array $options): void
{
    $builder
        -&gt;add('name', TextType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'minlength' =&gt; '2',
                'maxlength' =&gt; '50'
            ],
            'label' =&gt; 'Nom',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('time', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 1440
            ],
            'required' =&gt; false,
            'label' =&gt; 'Temps (en minutes)',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(1441)
            ]
        ])
        -&gt;add('nbPeople', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 50
            ],
            'required' =&gt; false,
            'label' =&gt; 'Nombre de personnes',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(51)
            ]
        ])
        -&gt;add('difficulty', RangeType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-range',
                'min' =&gt; 1,
                'max' =&gt; 5
            ],
            'required' =&gt; false,
            'label' =&gt; 'Difficulté',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(6)
            ]
        ])
        -&gt;add('description', TextareaType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Description',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('price', MoneyType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
            ],
            'required' =&gt; false,
            'label' =&gt; 'Prix',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Positive(),
                new Assert\LessThan(1001),
                new Assert\NotNull()
            ]
        ])
        -&gt;add('isFavorite', CheckboxType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-check-input',
            ],
            'label' =&gt; 'Favoris ?',
            'label_attr' =&gt; [
                'class' =&gt; 'form-check-label'
            ],
            'constraints' =&gt; [
                new Assert\NotNull()
            ]
        ])
        -&gt;add('ingredients', EntityType::class, [
            'class' =&gt; Ingredient::class,
            'query_builder' =&gt; function(IngredientRepository $r) {
                return $r-&gt;createQueryBuilder('i')
                    -&gt;orderBy('i.name', 'ASC');
            },
            'label' =&gt; 'Les ingrédients',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'choice_label' =&gt; 'name',
            'multiple' =&gt; true,
            'expanded' =&gt; true
        ])
        -&gt;add('submit', SubmitType::class, [
            'attr' =&gt; [
                'class' =&gt; 'btn btn-primary mt-4'
            ],
            'label' =&gt; 'Créer ma recette'
        ]);
}</code></pre>
                    <p>On va modifier la fonction "new" précédemment créée :</p>
<pre><code>/**
* This controller allow us to create a new recipe
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $recipe = new Recipe();
    $form = $this-&gt;createForm(RecipeType::class, $recipe);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été créée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Sixièmement, on va créer dans le contrôleur la fonction "edit" :</p>
<pre><code>/**
* This controller allow us to edit a recipe
*
* @param Recipe $recipe
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/edition/{id}', 'recipe.edit', methods: ['GET', 'POST'])]
public function edit(Recipe $recipe, Request $request, EntityManagerInterface $manager): Response
{
    $form = $this-&gt;createForm(RecipeType::class, $recipe);
    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été modifiée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Septièmement, on rajoute également la méthode "delete" dans le contrôleur :</p>
<pre><code>/**
* This controller allows us to delete a recipe
*
* @param EntityManagerInterface $manager
* @param Recipe $recipe
* @return Response
*/
#[Route('/recette/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Recipe $recipe): Response
{
    $manager-&gt;remove($recipe);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre recette a été supprimée avec succès !');

    return $this-&gt;redirectToRoute('recipe.index');
}</code></pre>
                    <h3>Étape 11 : Sécurité & compte utilisateur :</h3>
                    <p>Un compte utilisateur sera défini par :</p>
                    <ul>
                        <li>
                            <p>Un nom et un prénom qui seront obligatoires. Ils devront faire entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Un pseudo qui sera facultatif et, s'il est renseigné, il devra également entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Une adresse email qui sera unique et servira d'identifiant lors de la connexion.</p>
                        </li>
                        <li>
                            <p>Un mot de passe qui sera encodé en base de données pour des questions de sécurité.</p>
                        </li>
                        <li>
                            <p>Une date de création qui sera générée seule.</p>
                        </li>
                        <li>
                            <p>Une date de modificaton sera également générée seule lors de la modification du profil utilisateur.</p>
                        </li>
                    </ul>
                    <p>Pour cela, on utilise le bundle "Security" déjà installé et qui a généré le fichier <span class="em">`config/packages/security.yaml`</span>. Dans Symfony, il y a une façon très simple de générer une classe utilisateur pour gérer la sécurité avec la commande :</p>
<pre><code>php bin/console make:user</code></pre>
                    <p>On nomme notre classe utilisateur "User", on la stocke dans la DB via Doctrine, on dit que la propriété "email" doit être unique et on a besoin de hasher les mots de passe. Voici le code généré (sans les getters et les setters) et que je modifie un peu :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\UserRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('email')]
    #[ORM\Entity(repositoryClass: UserRepository::class)]
    class User implements UserInterface, PasswordAuthenticatedUserInterface
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 180, unique: true)]
        #[Assert\Email()]
        #[Assert\Length(min: 2, max: 180)]
        private string $email;

        #[ORM\Column(type; 'json')]
        #[Assert\NotNull()]
        private array $roles = [];

        private ?string $plainPassword = null;

        #[ORM\Column(type: 'string')]
        #[Assert\NotBlank()]
        private string $password = 'password';

        public function __construct()
        {

        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        /**
        * A visual identifier that represents this user
        *
        * @see UserInterface
        */
        public function getUserIdentifier(): string
        {
            return (string) $this-&gt;email;
        }

        /**
        * @see UserInterface
        */
        public function getRoles(): array
        {
            $roles = $this-&gt;roles;
            // guarantee every user at least has ROLE_USER
            $roles[] = 'ROLE_USER';

            return array_unique($roles);
        }

        public function setRoles(array $roles): self
        {
            $this-&gt;roles = $roles;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Avant de créer une migration pour cette entité et de la migrer, il faut modifier l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:entity User</code></pre>
                    <p>On va rajouter les propriétés "fullName" de taille "50" non nullable, "pseudo" de taille "50" nullable, "createdAt" de type "datetime_immutable" non nullable et "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Donc, avec la commande `<span class="html">php bin/console make:migration</span>` on crée la migration et avec `<span class="em">php bin/console d:m:m</span>` pour la migrer.</p>
                    <p>Ensuite, dans le fichier "<span class="em">security.yaml</span>", on va rajouter le provider comme suit :</p>
<pre><code>providers:
        # used to reload user from session & other features (e.g. switch user)
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email</code></pre>
                    <p>Pour hasher le mot de passe, on va définir un <span class="em">password_hashers</span> s'il n'est pas défini dans le fichier <span class="em">security.yaml</span> :</p>
<pre><code>password_hashers:
    Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: "auto"</code></pre>
                    <p>Dans notre fixture, on va créer des utilisateurs fictifs :</p>
<pre><code>// Users
$users = [];
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPassword('password');

    $users[] = $user;
    $manager-&gt;persist($user);
}</code></pre>
                    <p>On charge les nouveaux utilisateurs avec la commande :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <p>Ici, on peut voir que le mot de passe n'est pas encore crypté dans la base de données. Pour faire cela, on rajoute une propriété dans la classe "AppFixtures" et on modifie la fonction "load" :</p>
<pre><code>private UserPasswordHasherInterface $hasher;</code></pre>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER']);
    
    $hashPassword = $this-&gt;hasher-&gt;hashPassword($user, 'password');

    $user-&gt;setPassword($hashPassword);

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Le problème avec cette solution, c'est que n'importe où on doit toujours demander que le mot de passe soit hashé.</p>
                    <p>On voudrait exporter la logique de hashage du mot de passe à l'extérieur. Pour ce faire, on va utiliser les <span class="html">Entity Listeners</span> de Symfony qui, comme leur nom l'indique, vont écouter ce qui se passe au niveau des entités et faire plusieurs actions. On va de nouveau modifier la fonction "load" :</p>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPlainPassword('password');

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Ensuite, on va rajouter un nouveau service dans le fichier <span class="em">`config/services.yaml`</span> :</p>
<pre><code>App\EntityListener\
    resource: "../src/EntityListener/"
    tags: ["doctrine.orm.entity_listener"]
</code></pre>
                    <p>Avant la déclaration de la classe de l'entité "User", on rajoute la ligne suivante :</p>
<pre><code>#[ORM\EntityListeners(['App\EntityListener\UserListener'])]</code></pre>
                    <p>Dans le dossier "src", on va créer un dossier "EntityListener" et y insérer le fichier "UserListener.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\EntityListener;

    use App\Entity\User;
    use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

    class UserListener
    {

        private UserPasswordHasherInterface $hasher;

        public function __construct(UserPasswordHasherInterface $hasher)
        {
            $this-&gt;hasher = $hasher;
        }

        public function prePersist(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        public function preUpdate(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        /**
        * Encode password based on plain password
        *
        * @param User $user
        * @return void
        */
        public function encodePassword(User $user)
        {
            if (is_null($user-&gt;getPlainPassword())) {
                return;
            }

            $user-&gt;setPassword(
                $this-&gt;hasher-&gt;hashPassword($user, $user-&gt;getPlainPassword())
            );

            $user-&gt;setPlainPassword(null);
        }
    }

?&gt;</code></pre>
                    <p>Remarques : Maintenant qu'on a le "$hasher" dans le "UserListener", on peut le supprimer dans les fixtures.</p>
                    <h3>Étape 12 : Firewall et formulaire de connexion :</h3>
                    <p>La section "Firewall" est la section la plus importante en terme de sécurité. Pour faire simple, le firewall sert à définir les parties de notre application qui sont sécurisées et comment les utilisateurs vont avoir la possibilité de s'authentifier (par exemple que ce soit via un formulaire de connexion ou par rapport à un token si on fait une API, etc).</p>
                    <p>On a deux firewalls : le "dev" et le "main". Le "dev" qui est un faux Firewall et le "main" qui de base n'est pas très sécurisé.</p>
                    <p>Maintenant, on va créer un nouveau contrôleur pour afficher la page de connexion que l'on nomme "SecurityController" avec la commande :</p>
<pre><code>php bin/console make:controller SecurityController</code></pre>
                    <p>Remarques : on déplace le dossier "templates/security" dans le dossier "templates/pages" et on renomme le fichier "index.html.twig" par "login.html.twig". Modifions la fonction "index" de ce nouveau contrôleur pour que ça devienne ceci :</p>
<pre><code>use Symfony\Component\Security\Http\authentification\AuthenticationUtils;

/**
* This controller allow us to login
*
* @param AuthenticationUtils $authenticationUtils
* @return Response
*/
#[Route('/connexion', name: 'security.login', methods: ['GET', 'POST'])]
public function login(AuthenticationUtils $authenticationUtils): Response
{
    $lastUsername = $authenticationUtils-&gt;getLastUsername();
    $error = $authenticationUtils-&gt;getLastAuthenticationError();

    return $this-&gt;render('pages/security/login.html.twig', [
        'last_username' =&gt; $lastUsername,
        'error' =&gt; $error
    ]);
}</code></pre>
                    <p>On va rajouter les lignes suivantes dans la configuration de notre "main" Firewall :</p>
<pre><code>form_login:
    login_path: security.login
    check_path: security.login</code></pre>
                    <p>On va ensuite créer la structure de notre formulaire de connexion dans "login.html.twig" :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Connexion{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de connexion&lt;/h1&gt;

        {% if error %}
            &lt;div class="alert alert-danger"&gt;
                {{ error.messageKey|trans(error.messageData, 'security') }}
            &lt;/div&gt;
        {% endif %}

        &lt;form action="{{ path('security.login') }}" method="post" name="login"&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="username" class="form-label mt-4"&gt;Adresse email&lt;/label&gt;
                &lt;input type="email" class="form-control" id="username" name="_username" value="{{ last_username }}"&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password" class="form-label mt-4"&gt;Mot de passe&lt;/label&gt;
                &lt;input type="password" class="form-control" id="password" name="_password"&gt;
            &lt;/div&gt;

            &lt;button type="submit" class="btn btn-primary mt-4"&gt;
                Se connecter
            &lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire fonctionne bien ! Passons vite fait à la déconnexion. Pour ce faire, on crée la fonction logout dans notre contrôleur et on rajoute les lignes suivantes dans le "main" Firewall :</p>
<pre><code>/**
* This controller allow us to logout
*
* @return void
*/
#[Route('/deconnexion', 'security.logout', methods: ['GET'])]
public function logout()
{
    // Nothing to do here...
}</code></pre>
<pre><code>logout:
    path: security.logout</code></pre>
                    <h3>Étape 13 : Formulaire d'inscription :</h3>
                    <p>D'abord, on va créer le formulaire "RegistrationType" basé sur l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form RegistrationType User</code></pre>
                    <p>Ça génèrera le code suivant dans la fonction "buildForm" qu'on va modifier :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'label' =&gt; 'Nom / Prénom',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('email', EmailType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '180',
        ],
        'label' =&gt; 'Adresse email',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Email(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 180])
        ]
    ])
    -&gt;add('plainPassword', RepeatedType::class, [
        'type' =&gt; PasswordType::class,
        'first_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'second_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Confirmation du mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !',
        'constraints' =&gt; [
            new Assert\Length([
                'min' =&gt; 8,
                'minMessage' =&gt; 'Le mot de passe doit contenir au moins  {{ limit }} caractères !'
            ])
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'S\'inscrire'
    ]);</code></pre>
                    <p>Dans notre "SecurityController", on rajoute la fonction "registration" :</p>
<pre><code>/**
* This controller allow us to RegistrationType
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/inscription', 'security.registration', methods: ['GET', 'POST'])]
public function registration(Request $request, EntityManagerInterface $manager): Response
{
    $user = new User();
    $user-&gt;setRoles(['ROLE_USER']);

    $form = $this-&gt;createForm(RegistrationType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $user = $form-&gt;getData();

        $manager-&gt;persist($user);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre compte a bien été créé !');

        return $this-&gt;redirectToRoute('security.login');
    }

    return $this-&gt;render('pages/security/registration.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va créer notre template avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Inscription{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire d'inscription&lt;/h1&gt;

        {{ form(form) }}

    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire d'inscription est fonctionnel.</p>
                    <h3>Étape 14 : Édition du profil et du mot de passe :</h3>
                    <p>On va créer le formulaire "UserType" lié à l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form UserType User</code></pre>
                    <p>Comme précédemment, on va modifier la fonction "buildForm" comme ceci :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
    'attr' =&gt; [
        'class' =&gt; 'form-control',
        'minlength' =&gt; '2',
        'maxlength' =&gt; '50',
    ],
    'label' =&gt; 'Nom / Prénom',
    'label_attr' =&gt; [
        'class' =&gt; 'form_label mt-4'
    ],
    'constraints' =&gt; [
        new Assert\NotBlank(),
        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
    ]
])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('plainPassword', PasswordType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Modifier le profil'
    ]);</code></pre>
                    <p>Ensuite, on va créer un contrôleur "UserController", on met le dossier de template "user" dans le dossier "pages", on modifie le fichier "index.html.twig" en "edit.html.twig" et on modifie la fonction "index" du contrôleur en "edit" :</p>
<pre><code>/**
* This controller allow us to edit user's profile
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edition/{id}', name: 'user.edit', methods: ['GET', 'POST'])]
public function edit(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    if (!$this-&gt;getUser()) {
        return $this-&gt;redirectToRoute('security.login');
    }

    if ($this-&gt;getUser() !== $user) {
        return $this-&gt;redirectToRoute('recipe.index');
    }

    $form = $this-&gt;createForm(UserType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()-&gt;getPlainPassword()))
        {
            $user = $form-&gt;getData();
            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Les informations de votre compte ont bien été modifiées !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions le template ainsi :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification des informations de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>On crée un  nouveau formulaire "UserPasswordType" associer à l'entité "User" pour modifier le mot de passe :</p>
<pre><code>$builder-&gt;add('plainPassword', RepeatedType::class, [
    'type' =&gt; PasswordType::class,
    'first_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'second_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Confirmation du mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !',
    'constraints' =&gt; [
        new Assert\Length([
            'min' =&gt; 8,
            'minMessage' =&gt; 'Le mot de passe doit contenir au moins  {{ limit }} caractères !'
        ])
    ]
])
    -&gt;add('newPassword', PasswordType::class, [
        'attr' =&gt; ['class' =&gt; 'form-control'],
        'label' =&gt; 'Nouveau mot de passe',
        'label_attr' =&gt; ['class' &gt;= 'form-label mt-4'],
        'constraints' =&gt; [new Assert\NotBlank()]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Changer mon mot de passe'
    ]);</code></pre>
                    <p>On rajoute la fonction "editPassword" dans le contrôleur :</p>
<pre><code>/**
* This controller allow us to edit user's password
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edit-mot-de-passe/{id}', 'user.edit.password', methods: ['GET, 'POST'])]
public function editPassword(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    $form = $this-&gt;createForm(UserPasswordType::class);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()['plainPassword'])) {
            $user-&gt;setUpdatedAt(new \DateTimeImmutable());
            $user-&gt;setPlainPassword($form-&gt;getData()['newPassword']);

            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Le mot de passe a été modifié !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit_password.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions également le template :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification du mot de passe de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification du mot de passe de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <h3>Étape 15 : Assigner les entités à un utilisateur (ingrédient, recette) :</h3>
                    <p>Dans cette partie, on va mettre en place la relation entre l'entité "User" et l'entité "Ingredient". On doit également modifier les fixtures pour lier les ingrédients à un utilisateur, ainsi que lier un ingrédient à l'utilisateur connecté lors de la création et afficher uniquement les ingrédients reliés à l'utilisateur.</p>
                    <p>Pour commencer, on rajoute la propriété "ingredients" dans l'entité "User" de type "relation" lié à l'entité "Ingredient" et de type de relation "OneToMany".</p>
                    <p>On va dire que la propriété "user" non nullable sera rajouté dans l'entité "Ingredient" et on va ajouter le fait de supprimer l'ingrédient orphelin.</p>
                    <p>Dans les fixtures, on déplace le code des users au-dessus de celui des ingrédients que l'on va modifier ainsi :</p>
<pre><code>// Ingredients
$ingredients = [];
for ($i = 0; $i &lt; 50; $i++) {
    $ingredient = new Ingredient();
    $ingredient-&gt;setName($this-&gt;faker-&gt;word())
        -&gt;setPrice(mt_rand(0, 100))
        -&gt;setUser($users[array_range($users)]);
}</code></pre>
                    <p>On crée une nouvelle migration, on la migre et on load à nouveau les fixtures. Enfin, on modifie la fonction "index" de notre "IngredientController" pour qu'il affiche seulement les ingrédients lié à l'utilisateur connecté :</p>
<pre><code>/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository->findBy(['user' =&gt; $this-&gt;getUser()]),
        $request-&gt;query-&gt;getInt('page', 1),
        10    
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>Pour lier l'utilisateur à un ingrédient lors de sa création, on va modifier la fonction "new" du "IngredientController" pour ajouter la ligne suivante :</p>
<pre><code>$ingredient-&gt;setUser($this-&gt;getUser());</code></pre>
                    <p>Ce sera pareil pour l'entité "Recipe" afin de la lier à celle de "User". On doit ajouter un constructeur et on doit modifier le "QueryBuilder" du formulaire pour lors de la création d'une recette, on affiche seulement tous les ingrédients de l'utilisateur connecté :</p>
<pre><code>use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;

private $token;

public function __construct(TokenStorageInterface $token)
{
    $this-&gt;token = $token;
}</code></pre>
<pre><code>'query_builder' =&gt; function(IngredientRepository $r) {
    return $r-&gt;createQueryBuilder('i')
        -&gt;where('i.user = :user')
        -&gt;orderBy('i.name', 'ASC')
        -&gt;setParameter('user', $this-&gt;token-&gt;getToken()-&gt;getUser());
}</code></pre>
                    <p>On va modifier la navbar qui sera différente si l'utilisateur est connecté ou pas avec <span class="html">{% if app.user %}</span>.</p>
                    <p>Les liens vers la connexion et l'inscription si l'utilisateur n'est pas connecté sinon les liens vers mes ingrédients et mes recettes comme par exemple :</p>
<pre><code>&lt;div class="d-flex"&gt;
    &lt;ul class="navbar-nav me-auto"&gt;
        {% if app.user %}
            &lt;li class="nav-item dropdown"&gt;
                &lt;a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false"&gt;{{ app.user.fullName }}&lt;/a&gt;
                &lt;div class="dropdown-menu dropdown-menu-end"&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit', {id: app.user.id}) }}"&gt;Modifier mes informations&lt;/a&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit.password', {id: app.user.id}) }}"&gt;Modifier mon mot de passe&lt;/a&gt;
                    &lt;div class="dropdown-divider"&gt;&lt;/div&gt;
                    &lt;a class="dropdown-item" href="{{ path('security.logout') }}"&gt;Déconnexion&lt;/a&gt;
                &lt;/div&gt;
            &lt;/li&gt;
        {% else %}
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.login') }}"&gt;Connexion&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.registration') }}"&gt;Inscription&lt;/a&gt;
            &lt;/li&gt;
        {% endif %}
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    <h3>Étape 16 : Sécuriser les routes avec IS_GRANTED et SECURITY :</h3>
                    <p>Dans cette partie, on va gérer la gestion de l'accès des pages, c'est-à-dire qu'on va interdire l'accès à certaines pahes en fonction de différents critères.</p>
                    <p>Les annotations <span class="html">@Security</span> et <span class="html">@IsGranted</span> restreint l'accès aux contrôleurs et donc par extension aux pages.</p>
                    <p>L'annotation <span class="em">@IsGranted</span> est la plus simple pour restreindre par rôle ou encore par les variables passées au contrôleur.</p>
                    <p>L'annotation <span class="em">@Security</span> est plus flexible et plus complète qui permet de passer des expressions contenant de la logique.</p>
                    <p>Pour la page de la liste des ingrédients, on va donner l'accès aux utilisateurs ayant le rôle "ROLE_USER" en ajoutant sur la méthode "index" du "IngredientController" la ligne suivante :</p>
<pre><code>#[IsGranted('ROLE_USER')]</code></pre>
                    <p>Pour la modification des ingrédients, on doit aussi vérifier qu'en plus du rôle "ROLE_USER" que l'utilisateur connecté soit bien celui lié à cet ingrédient avec la ligne suivante :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === ingredient.getUser()")]</code></pre>
                    <p>Ce sera pareil pour les recettes. Pour la modification du profil de l'utilisateur ou encore pour la modification du mot de passe, on va supprimer les if de vérification pour les remplacer par la ligne suivante au-dessus de la fonction "edit" de l'"UserController" :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === choosenUser")]
public function edit(User $choosenUser, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    ...
}</code></pre>
                    <p>Remarque : On a modifié le "$user" par "$choosenUser" car il existe déjà la variable "user" dans l'annotation "Security".</p>
                    <h3>Étape 17 : Partager une recette :</h3>
                    <p>Pour partager une recette, on la rendre publique ou non avec les spécificités suivantes :</p>
                    <ul>
                        <li>Un utilisateur connecté aura à disposition un champ, pour chaque recette, lui permettant de choisir si la recette en question est disponible pour l'ensemble de la communauté.</li>
                        <li>Si la recette est rendue publique, alors les utilisateurs pourront la consulter.</li>
                        <li>Sinon, elle ne pourra pas être consultée par quelqu'un d'autre que le créateur.</li>
                    </ul>
                    <p>On va rajouter la propriété "isPublic" de type "boolean" non nullable dans l'entité "Recipe" avec la valeur par défaut à "false". On fait une nouvelle migration et on la migre. On va modifier la fixture pour ajouter la ligne suivante :</p>
<pre><code>-&gt;setIsPublic(mt_rand(0, 1) == 1);</code></pre>
                    <p>Dans le contrôleur "RecipeController", on va rajouter la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET'])]
public function show(Recipe $recipe): Response
{
    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe
    ]);
}</code></pre>
                    <p>Créons donc ce template avec le contenu suivant :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}
    {{ recipe.name }}
{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;{{ recipe.name }}&lt;/h1&gt;
        &lt;div&gt;
            &lt;span class="badge bg-primary"&gt;Créée le {{ recipe.createdAt|date('d/m/Y') }}&lt;/span&gt;
        &lt;/div&gt;

        {% if recipe.time %}
            &lt;p&gt;Temps (en minutes) : {{ recipe.time }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Temps non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.nbPeople %}
            &lt;p&gt;Pour {{ recipe.nbPeople }} personnes&lt;/p&gt;
        {% else %}
            &lt;p&gt;Nombre de personnes non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.difficulty %}
            &lt;p&gt;Difficulté : {{ recipe.difficulty }}/5&lt;/p&gt;
        {% else %}
            &lt;p&gt;Difficulté non renseignée&lt;/p&gt;
        {% endif %}

        {% if recipe.price %}
            &lt;p&gt;Prix (en €) : {{ recipe.price }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Prix non renseigné&lt;/p&gt;
        {% endif %}

        &lt;div class="mt-4"&gt;
            {{ recipe.description|raw }}
        &lt;/div&gt;

        &lt;p class="mt-4"&gt;Ingrédients :&lt;/p&gt;
        {% for ingredient in recipe.ingredients %}
            &lt;span class="badge bg-primary"&gt;{{ ingredient.name }}&lt;/span&gt;
        {% endfor %}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour afficher la page qui liste toutes les recettes qui ont été partagées par l'ensemble des personnes, on va créer dans le "RecipeController" une nouvelle fonction :</p>
<pre><code>#[Route('/recette/pblique', 'recipe.public', methods: ['GET'])]
public function indexPublic(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findPublicRecipe(null),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe.index_public.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>On peut copier le même template que la liste des recettes mais sans les boutons de modification et de suppression. Ensuite, on va créer une fonction dans le "RecipeRepository" qui va permettre de récupérer un nombre x de recettes publiques :</p>
<pre><code>/**
* This method allow us to find public recipes based on number of recipes
*
* @param integer $nbRecipes
* @return array
*/
public function findPublicRecipe(?int $nbRecipes): array
{
    $queryBuilder = $this-&gt;createQueryBuilder('r')
        -&gt;where('r.isPublic = 1')
        -&gt;orderBy('r.createdAt', 'DESC');
    
    if ($nbRecipes !== 0 || !is_null($nbRecipes)) {
        $queryBuilder-&gt;setMaxResults($nbRecipes);
    }
    
    return $queryBuilder-&gt;getQuery()
        -&gt;getResult();
}</code></pre>
                    <p>Sur la page d'accueil, on pourrait afficher les 3 dernières recettes de la communauté en précisant la valeur de "$nbRecipes" à 3.</p>
                    <h3>Étape 18 : Noter une recette :</h3>
                    <p>Cette fonctionnalité va permettre aux différents utilisateurs de noter les recettes mises en mode "public" sur l'application. Une fois la recette mise en mode "public", elle est éligible aux votes des utilisateurs.</p>
                    <p>Un utilisateur connecté pourra donner une note entre 1 et 5. L'ensemble des notes deront une moyenne, et les utilisateurs pourront voir cette moyenne sur la page de la recette.</p>
                    <p>En logique et c'est très compréhensible, un utilisateur ne pourra pas noter sa propre recette et un utilisateur ne pourra pas non plus noter deux fois la même recette.</p>
                    <p>Pour commencer à coder cette fonctionnalité, on va d'abord créer une entité "Mark" ("note" en anglais) avec la commande suivante :</p>
<pre><code>php bin/console make:entity Mark</code></pre>
                    <p>Avec les propriétés "mark" de type "integer" non nullable, "user" de type "ManyToOne" non nullable liée à l'entité "User", "recipe" de type "ManyToOne" non nullable liée à l'entité "Recipe" et "createdAt" de type "datetime_immutable" non nullable.</p>
                    <p>On va modifier l'entité "Mark" comme ceci :</p>
<pre><code>#[ORM\Entity(repositoryClass: MarkRepository::class)]
#[UniqueEntity(
    fields: ['user', 'recipe'],
    errorpath: 'user',
    message: 'Cet utilisateur a déjà noté cette recette !'
)]
class Mark
{

    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'integer')]
    #[Assert\Positive()]
    #[Assert\LessThan(6)]
    private int $mark;

    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private User $user;

    #[ORM\ManyToOne(targetEntity: Recipe::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private Recipe $recipe;

    #ORM\Column(type: 'datetime_immutable')]
    private ?\DateTimeImmutable $createdAt;

    public function __construct()
    {
        $this-&gt;createdAt = new \DateTimeImmutable();
    }

}</code></pre>
                    <p>On oublie pas de créer la migration et la migrer. Dans nos fixtures, on va rajouter les marks :</p>
<pre><code>// Marks
foreach ($recipes as $recipe) {
    for ($i = 0; $i &lt; mt_rand(0, 4); $i++) {
        $mark = new Mark();
        $mark-&gt;setMark(mt_rand(1, 5))
            -&gt;setUser($users[array_range($users)])
            -&gt;setRecipe($recipe);
        
        $manager-&gt;persist($mark);
    }
}</code></pre>
                    <p>Pour calculer la moyenne des notes de la recette, on rajouter un <span class="em">private ?float $average = null;</span> dans l'entité "Recipe" et y rajouter la fonction "getAverage" :</p>
<pre><code>/**
* Get the value of average
*/
public function getAverage()
{
    $marks = $this-&gt;marks;

    if ($marks-&gt;toArray() === []) {
        $this-&gt;average = null;
    } else {
        $total = 0;
        foreach ($marks as $mark) {
            $total += $mark-&gt;getMark();
        }
        $this-&gt;average = $total / count($marks);
    }

    return $this-&gt;average;
}</code></pre>
                    <p>On va créer un petit formulaire "MarkType" basé sur l'entité "Mark" pour pouvoir noter les recettes avec la commande suivante :</p>
<pre><code>php bin/console make:form MarkType Mark</code></pre>
                    <p>On va ensuite modifier la fonction "buildForm" de ce nouveau fichier comme ceci :</p>
<pre><code>$builder
    -&gt;add('mark', ChoiceType::class, [
        'choices' =&gt; [
            '1' =&gt; 1,
            '2' =&gt; 2,
            '3' =&gt; 3,
            '4' =&gt; 4,
            '5' =&gt; 5,
        ],
        'attr' =&gt; [
            'class' =&gt; 'form-select'
        ],
        'label' =&gt; 'Noter la recette',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Noter la recette'
    ]);</code></pre>
                    <p>On va modfifier dans le "RecipeController" la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @param Request $request
* @param MarkRepository $markRepository
* @param EntityManagerInterface $manager
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET', 'POST'])]
public function show(Recipe $recipe, Request $request, MarkRepository $markRepository, EntityManagerInterface $manager): Response
{

    $mark = new Mark();
    $form = $this-&gt;createForm(MarkType::class, $mark);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $mark-&gt;setUser($this-&gt;getUser())
            -&gt;setRecipe($recipe);

        $existingMark = $markRepository-&gt;findOneBy([
            'user' =&gt; $this-&gt;getUser(),
            'recipe' =&gt; $recipe
        ]);

        if (!$existingMark) {
            $manager-&gt;persist($mark);
        } else {
           $existingMark-&gt;setMark($form-&gt;getData()-&gt;getMark());
        }

        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre note a bien été prise en compte !');

        return $this-&gt;redirectToRoute('recipe.show', ['id' =&gt; $recipe-&gt;getId()]);
    }

    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe,
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va modifier le template lié à cette fonction pour ajouter les lignes suivantes au bon endroit :</p>
<pre><code>{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}

&lt;p&gt;La moyenne de cette recette est de {{ recipe.average|number_format(2, '.', ',') }}/5 !&lt;/p&gt;

&lt;div class="mark"&gt;
    {{ form(form) }}
&lt;/div&gt;</code></pre>
                    <h3>Étape 19 : Upload une image :</h3>
                    <p>Pour uploader une image pour chaque recette, on va d'abord utiliser le bundle "VichUploaderBundle" et on va l'installer avec la commande suivante :</p>
<pre><code>composer require vich/uploader-bundle</code></pre>
                    <p>Cette commande va générer le fichier <span class="em">`config/packages/vich_uploader.yaml`</span> qui est le fichier de configuration de ce bundle qu'on va modifier :</p>
<pre><code>vich_uploader:
    db_driver: orm
    metadata:
        type: attribute

    mappings:
        recipe_images:
            uri_prefix: /images/recette
            upload_destination: "%kernel.project_dir%/public/images/recette"
            namer: Vich\UploaderBundle\Naming\SmartUniqueNamer
</code></pre>
                    <p>On va rajouter des informations pour l'upload des images dans l'entité "Recipe" :</p>
<pre><code>...

use Symfony\Component\HttpFoundation\File\File;
use Vich\UploaderBundle\Mapping\Annotation as Vich;

...

#[Vich\Uploadable]
class Recipe
{

    ...

    /**
    * NOTE : This is not a mapped field of entity metadata, just a simple property.
    */
    #[Vich\UploadableField(mapping: 'recipe_images', fileNameProperty: 'imageName')]
    private ?File $imageFile = null;

    #[ORM\Column(type: 'string', nullable: true)]
    private ?string $imageName = null;

    ...

    /**
    * If manually uploading a file (i.e. not using Symfony Form) ensure an instance
    * of 'UploadedFile' is injected into this setter to trigger the update. If this
    * bundle's configuration parameter 'inject_on_load' is set to 'true' this setter
    * must be able to accept an instnace of 'File' as the bundle will inject one here
    * during Doctrine hydration.
    *
    * @param File|\Symfony\Component\HttpFoundation\File\UpdloadedFile|null $imageFile
    */
    public function setImageFile(?File $imageFile = null): void
    {
        $this-&gt;imageFile = $imageFile;

        if (null !== $imageFile) {
            // It is required that at least one field changes if you are using doctrine
            // otherwise the event listeners won't be called and the file is lost
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }
    }

    public function getImageFile(): ?File
    {
        return $this-&gt;imageFile;
    }

    public function setImageName(?string $imageName): void
    {
        $this-&gt;imageName = $imageName;
    }

    ...
    
}</code></pre>
                    <p>Dans le formulaire de création d'une recette, on va rajouter un champ "imageFile" comme ceci :</p>
<pre><code>-&gt;add('imageFile', VichImageType::class, [
    'label' =&gt; 'Image de la recette',
    'label_attr' =&gt; [
        'class' =&gt; 'form-label mt-4'
    ]
])</code></pre>
                    <p>Et dans le template du formulaire de création/modification d'une recette :</p>
<pre><code>{{ form_row(form.imageFile) }}</code></pre>
                    <p>On oublie pas de créer la migration et de la migrer. Pour afficher l'image dans le détail de la recette (show), on fait :</p>
<pre><code>&lt;div class="recipe_image"&gt;
    &lt;img style="max-width: 500px;" src="{{ vich_uploader_asset(recipe, 'imageFile') }}"&gt;
&lt;/div&gt;</code></pre>
                    <h3>Étape 20 : Formulaire de contact, email et reCaptcha v3 :</h3>
                    <p>Cette fonctionnalité consiste en l'implémentation d'un formulaire de contact classique.</p>
                    <p>Ce formulaire contiendra :</p>
                    <ul>
                        <li>
                            <p>Un nom</p>
                        </li>
                        <li>
                            <p>Un prénom</p>
                        </li>
                        <li>
                            <p>Une adresse email</p>
                        </li>
                        <li>
                            <p>Un sujet</p>
                        </li>
                        <li>
                            <p>Un message</p>
                        </li>
                    </ul>
                    <p>Le nom et le prénom seront optionnels. Ils devront faire entre 2 et 50 caractères. L'adresse email sera obligatoire, comme le message. Le sujet sera lui optionnel et contiendra macimum 50 caractères.</p>
                    <p>Si l'utilisateur est connecté, alors son nom, prénom et adresse email seront automatiquement remplis.</p>
                    <p>Le formulaire contiendra également un système reCaptcha.</p>
                    <p>D'abord, on va créer une entité "Contact" avec les propriétés "fullName" de type "string" de taille "50" nullable, "email" de type "string" de taille "180" non nullable, "subject" de type "string" de taille "100" nullable, "message" de type "text" non nullable et "createdAt" de type "datetime_immutable" non nullable avec la commande :</p>
<pre><code>php bin/console make:entity Contact</code></pre>
                    <p>On va modifier cette entité pour rajouter les "Assert" :</p>
<pre><code>#[ORM\Entity(repositoryClass: ContactRepository::class)]
class Contact
{
 
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id;

    #[ORM\Column(type: 'string', length: 50, nullable: true)]
    #[Assert\Length(min: 2, max: 50)]
    private ?string $fullName = null;

    #[ORM\Column(type: 'string', length: 180)]
    #[Assert\Email()]
    #[Assert\Length(min: 2, max: 180)]
    private string $email;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    #[Assert\Length(min: 2, max: 100)]
    private ?string $subject = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank()]
    private string $message;

    #[ORM\Column(type: 'datetime_immutable')]
    #[Assert\NotNull()]
    private ?\DateTimeImmutable $createdAt;
    
    public function __construct()
    {
        $this-&gt;createdAt = new \DateTimeImmutable();
    }

    ...

}</code></pre>
                    <p>On crée donc la migration et on la migre. On va rajouter des fixtures pour les contacts :</p>
<pre><code>// Contact
for ($i = 0; $i &lt; 5; $i++) {
    $contact = new Contact();
    $contact-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setEmail($this-&gt;faker-&gt;-&gt;email())
        -&gt;setSubject('Demande n°' . ($i + 1))
        -&gt;setMessage($this-&gt;faker-&gt;text());

    $manager-&gt;persist($contact);
}</code></pre>
                    <p>On va créer un contrôleur "ContactController" avec la commande :</p>
<pre><code>php bin/console make:controller ContactController</code></pre>
                    <p>On va créer un formulaire de contact nommé "ContactType" avec la commande :</p>
<pre><code>php bin/console make:form ContactType Contact</code></pre>
                    <p>Et on va modifier sa fonction "buildForm" :</p>
<pre><code>$builder
    -&gt;add('fullName', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'label' =&gt; 'Nom / Prénom',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('email', EmailType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '180',
        ],
        'label' =&gt; 'Adresse email',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank(),
            new Assert\Email(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 180])
        ]
    ])
    -&gt;add('subject', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '100',
        ],
        'label' =&gt; 'Sujet',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 100])
        ]
    ])
    -&gt;add('message', TextareaType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
        ],
        'label' =&gt; 'Message',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank()
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Soumettre ma demande'
    ]);</code></pre>
                    <p>On va modifier la fonction "index" de notre contrôleur pour ajouter le formulaire :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Pour envoyer un email à chaque soumission du formulaire de contact, on va utiliser le composant "Mailer" avec le fichier de configuration <span class="em">`config/packages/mailer.yaml`</span>. Dans notre fichier ".env", on doit définir le système de transport d'email via la variable "MAILER_DSN" avec la syntaxe suivante :</p>
<pre><code>MAILER_DSN=smtp://user:pass@smtp.example.com:port</code></pre>
                    <p>Pour avoir une configuration SMTP, on peut utiliser <a href="https://mailtrap.io/">l'outil "mailtrap"</a>. Ensuite, on va modifier la fonction "index" de notre contrôleur :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager, MailerInterface $mailer): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        // Email
        $email = (new TemplatedEmail())
            -&gt;from($contact-&gt;getEmail())
            -&gt;to('admin@symrecipe.com')
            -&gt;subject($contact-&gt;getSubject())
            -&gt;htmlTemplate('emails/contact.html.twig')
            // pass variables (name =&gt; value)to the template
            -&gt;context([
                'contact' =&gt; $contact
            ]);

        $mailer-&gt;send($email);

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va créer le dossier "emails" et dedans le fichier "contact.html.twig" avec le contenu suivant :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Demande de {{ contact.fullName }}&lt;/h1&gt;

        &lt;p&gt;Email : {{ contact.email }}&lt;/p&gt;
        &lt;p&gt;Sujet : {{ contact.subject }}&lt;/p&gt;
        &lt;p&gt;Message :&lt;/p&gt;
        &lt;div&gt;
            {{ contact.message|raw }}
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <p>On va mettre en place le reCaptcha qui, d'après Google, est la façon ultime de lutter contre les robots. On va utiliser le bundle "KarserRecaptcha3Bundle" qu'on va installer avec la commande :</p>
<pre><code>composer require karser/karser-recaptcha3-bundle</code></pre>
                    <p>On va dire "non" au "google/recaptcha" et "oui" au "karser/karser-recaptcha3-bundle". Dans son fichier de configuration <span class="em">`config/packages/karser_recaptcha3.yaml`</span>, on peut voir qu'il faut rajouter les variables "RECAPTCHA3_KEY" et "RECAPTCHA3_SECRET" dans notre fichier ".env".</p>
                    <p>Dans notre formulaire "ContactType", on va rajouter le captcha comme ceci :</p>
<pre><code>-&gt;add('captcha', Recaptcha3Type::class, [
    'constraints' =&gt; new Recaptcha3(),
    'action_name' =&gt; 'contact',
])</code></pre>
                    <h3>Étape 21 : Les services :</h3>
                    <p>Les services sont simplement des objets PHP qui vont remplir une fonction particulière. Précédemment, on a déjà utilisé des services sans le savoir comme le service "EntityManager" ou encore le service "Mailer".</p>
                    <p>Tous ces services sont à l'intérieur d'une classe PHP qui est assez spéciale et qui s'appelle le container de services et va centraliser tous les services au sein de notre application Symfony.</p>
                    <p>Pour visualiser tous les services présents au sein de Symfony, on utilise la commande :</p>
<pre><code>php bin/console debug:autowiring --all</code></pre>
                    <p>Si on cherche un service en particulier, on peut utiliser :</p>
<pre><code>php bin/console debug:autowiring mailer.mailer</code></pre>
                    <p>Ce qui est aussi très intéressant, c'est que nous pouvons également nos propres services car ça permettra d'utiliser une fonctionnalité précise à plusieurs endroits de notre code.</p>
                    <p>Par exemple, chaque fichier a son rôle à jouer et il faut un service email pour être cohérent avec ce système car actuellement l'envoi est géré au sein du contrôleur et on doit mettre le moins de logique dans le contrôleur.</p>
                    <p>On va créer le dossier <span class="em">`src/Service`</span> et dedans on y insère le fichier "MailService.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Symfony\Bridge\Twig\Mime\TemplatedEmail;
    use Symfony\Component\Mailer\MailerInterface;

    class MailService
    {

        /**
        * @var MailerInterface
        */
        private MailerInterface $mailer;

        public function __construct(MailerInterface $mailer)
        {
            $this-&gt;mailer = $mailer;
        }

        public function sendEmail(string $from, string $subject, string $htmlTemplate, array $context, string $to = 'admin@symrecipe.com'): void
        {
            $email = (new TemplatedEmail())
                -&gt;from($from)
                -&gt;to($to)
                -&gt;subject($subject)
                -&gt;htmlTemplate($htmlTemplate)
                -&gt;context($context);

            $this-&gt;mailer-&gt;send($email);
        }
    }

?&gt;</code></pre>
                    <p>On va de nouveau modifier la fonction "index" de notre contrôleur pour remplacer notre "MailerInterface" par notre "MailService" :</p>
<pre><code>#[Route('/contact', name: 'contact.index')]
public function index(Request $request, EntityManagerInterface $manager, MailService $mailService): Response
{
    $contact = new Contact();

    if ($this-&gt;getUser()) {
        $contact-&gt;setFullName($this-&gt;getUser()-&gt;getFullName())
            -&gt;setEmail($this-&gt;getUser()-&gt;getEmail());
    }

    $form = $this-&gt;createForm(ContactType::class, $contact);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $contact = $form-&gt;getData();

        $manager-&gt;persist($contact);
        $manager-&gt;flush();

        // Email
        $mailService-&gt;sendEmail(
            $contact-&gt;getEmail(),
            $contact-&gt;getSubject(),
            'emails/contact.html.twig',
            ['contact' =&gt; $contact]
        );

        $this-&gt;addFlash('success', 'Votre demande a été envoyée avec succès !');

        return $this-&gt;redirectToRoute('contact.index');
    }

    return $this-&gt;render('pages/contact/index.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <h3>Étape 22 : Administration avec EasyAdmin :</h3>
                    <p>Pour utiliser des interfaces d'Administration simple, on va utiliser le bundle "EasyAdmin" et on va l'installer avec la commande :</p>
<pre><code>composer require easycorp/easyadmin-bundle</code></pre>
                    <p>Pour bien commencer, la première étape est les dashboards qui est le point d'entré de la partie administrateur. Pour créer notre dashboard, on utilise la commande suivante :</p>
<pre><code>php bin/console make:admin:dashboard</code></pre>
                    <p>On le nomme "DashboardController" et on le stocke dans le dossier <span class="em">`src/Controller/Admin`</span>. On peut voir que cette classe étend de <span class="em">AbstractDashboardController</span> qui lui-même étend de <span class="em">AbstractController</span>. On y modifie sa fonction "index" :</p>
<pre><code>#[Route('/admin', name: 'admin')]
public function index(): Response
{
    return $this-&gt;render('admin/dashboard.html.twig');
}</code></pre>
                    <p>On oublie pas de créer le dossier <span class="em">`templates/admin`</span> et dedans le fichier "dashboard.html.twig" :</p>
<pre><code>{% extends "@EasyAdmin/pahe/content.html.twig" %}

{% block content %}
    &lt;h1&gt;Bienvenue au sein de l'administration de SymRecipe&lt;/h1&gt;
{% endblock %}</code></pre>
                    <p>On va configurer le dashboard en modifiant la fonction "configureDashboard" de notre contrôleur :</p>
<pre><code>public function configureDashboard(): Dashboard
{
    return Dashboard::new()
        -&gt;setTitle('SymRecipe - Administration')
        -&gt;renderContentMaximized();
}</code></pre>
                    <p>On va configurer les éléments du menu du Dashboard dans la fonction "configureMenuItems" de notre contrôleur :</p>
<pre><code>public function configureMenuItems(): iterable
{
    yield MenuItem::linkToDashBoard('Dashboard', 'fa fa-home');
    yield MenuItem::linkToCrud('Utilisateurs', 'fas fa-user', User::class);
}</code></pre>
                    <p>Si on relance la page, on va voir qu'il y a une erreur car il n'y a pas de "UserCrudController".</p>
                    <p>Un "CRUD controller" est un contrôleur qui va nous fournir les opérations de base d'un CRUD classique pour les entités. Il étend de <span class="em">AbstractCrudController</span> qui étend lui-même de <span class="em">AbstractController</span>. Pour faire ce fameux "CRUD controller", on utilise la commande suivante en sélectionnant l'entité sur lequel on veut le faire :</p>
<pre><code>php bin/console make:admin:crud</code></pre>
                    <p>Il sera généré dans le dossier <span class="em">`src/Controller/Admin`</span> avec le namespace "<span class="em">App\Controller\Admin</span>".</p>
                    <p>On va rajouter la fonction "configureCrud" dans notre contrôleur :</p>
<pre><code>public function configureCrud(Crud $crud): Crud
{
    return $crud
        -&gt;setEntityLabelInPlural('Utilisateurs')
        -&gt;setEntityLabelInSingular('Utilisateur');
        -&gt;setPageTitle('index', 'Symrecipe - Administration des utilisateurs')
        -&gt;setPaginatorPageSize(10);
}</code></pre>
                    <p>On va également configurer les champs à afficher dans le tableau dans la fonction "configureFields" de notre contrôleur :</p>
<pre><code>public function configureFields(string $pageName): iterable
{
    return [
        IdField::new('id')-&gt;hideOnForm(),
        TextField::new('fullName'),
        TextField::new('pseudo'),
        TextField::new('email')-&gt;hideOnForm(),
        ArrayField::new('roles')-&gt;hideOnIndex(),
        DteTimeField::new('createdAt')-&gt;hideOnForm()
    ];
}</code></pre>
                    <p>Pour le champ textarea pour le message de contact, on doit mettre en place un WYSIWYG (abréviation de "What You See Is What You Get", c'est-à-dire litéralement "ce que vous voyez est ce que vous obtenez"). On va installer le bundle "CKEditor" avec la commande :</p>
<pre><code>composer require friendsofsymfony/ckeditor-bundle</code></pre>
                    <p>Ensuite, on va installer "drop" de CKEditor avec la commande :</p>
<pre><code>php bin/console ckeditor:install</code></pre>
                    <p>On va installer les assets de CKEditor avec la commande :</p>
<pre><code>php bin/console assets:install public</code></pre>
                    <p>Enfin, on va modifier notre fichier de configuration <span class="em">`config/packages/fos_ckeditor.yaml`</span> :</p>
<pre><code>fos_ck_editor:
    configs:
        main_config:
            toolbar:
                - {
                    name: "styles",
                    items:
                        [
                            "Bold",
                            "Italic",
                            "Underline",
                            "Strike",
                            "Blockquote",
                            "-",
                            "Link",
                            "-",
                            "RemoveFormat",
                            "-",
                            "NumberedList",
                            "BulletedList",
                            "-",
                            "Outdent",
                            "Indent",
                            "-",
                            "-",
                            "JustifyLeft",
                            "JustifyCenter",
                            "JustifyRight",
                            "JustifyBlock",
                            "-",
                            "Image",
                            "Table",
                            "-",
                            "Styles",
                            "Format",
                            "Font",
                            "FontSize",
                            "-",
                            "TextColor",
                            "BGColor",
                            "Source",
                        ],
                }</code></pre>
                    <p>On va modifier notre ContactCrudController avec les fonctions suivantes :</p>
<pre><code>public function configureCrud(Crud $crud): Crud
{
    return $crud
        -&gt;setEntityLabelInSingular('Demande de contact')
        -&gt;setEntityLabelInPlural('Demandes de contact')
        -&gt;setPageTitle('index', 'SymRecipe - Administration des demandes de contact')
        -&gt;setPaginatorPageSize(20)
        -&gt;addFormTheme('@FOSCKEditor/Form/ckeditor_widget.html.twig');
}

public function configureFields(string $pageName): iterable
{
    return [
        IdField::new('id')-&gt;hideOnForm(),
        TextField::new('fullName'),
        TextField::new('email'),
        TextareaField::new('message')-&gt;setFormType(CKEditor::class)-&gt;hideOnIndex(),
        DateTimeField::new('createdAt')-&gt;hideOnForm()
    ];
}</code></pre>
                    <p>On va mettre en place la sécurité en ajoutant un admin dans les fixtures :</p>
<pre><code>$admin = new User();
$admin-&gt;setFullName('Administrateur de SymRecipe')
    -&gt;setPseudo(null)
    -&gt;setEmail('admin@symrecipe.fr')
    -&gt;setRoles(['ROLE_USER', 'ROLE_ADMIN'])
    -&gt;setPlainPassword('password');

$user[] = $admin;
$manager-&gt;persist($admin);</code></pre>
                    <p>On va rajouter le "IsGranted" sur les fonctions du DashboardController pour qu'il soit accessible aux utilisateurs ayant le rôle "ROLE_ADMIN" :</p>
<pre><code>#[IsGranted('ROLE_ADMIN')]</code></pre>
                    <p>Dans notre navbar, on peut ajouter le lien vers le dashboard :</p>
<pre><code>{% if 'ROLE_ADMIN' in app.user.roles %}
    &lt;a class="dropdown-item" href="{{ path('admin') }}"&gt;Administration&lt;/a&gt;
    &lt;div class="dropdown-divider"&gt;&lt;/div&gt;
{% endif %}</code></pre>
                    <h3>Étape 22 : Tester notre application :</h3>
                    <p>Dans cette partie, on va mettre en place des tests unitaires et des tests fonctionnels. En programmation, le test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme. Les tests fonctionnels sont destinés à s'assurer que, dans le contexte d'utilisation réelle, le comportement fonctionnel obtenu est bien conforme avec celui attendu.</p>
                    <p>Pour ce faire, Symfony nous propose d'utiliser le framework <span class="em">PHPUnit</span>. Pour exécuter les tests, on utilise la commande :</p>
<pre><code>php bin/phpunit</code></pre>
                    <p>Pour séparer les deux types de tests, je vous propose de créer deux dossiers différents dans le dossier "tests" : "Unit" et "Functional". On va ensuite créer notre premier test unitaire avec la commande :</p>
<pre><code>php bin/console make:test TestCase \App\Tests\Unit\BasicTest</code></pre>
                    <p>On va créer notre premier test fonctionnel avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\BasicTest</code></pre>
                    <p>On va copier les variables "DATABASE_URL" et "MAILER_DSN" dans le fichier ".env.test" et on va mettre la variable "RECAPTCHA3_ENABLED" à "0". On va créer la base de données de test avec la commande :</p>
<pre><code>php bin/console d:d:c --env=test</code></pre>
                    <p>On va migrer toutes les migrations dans cette nouvelle base de données avec la commande :</p>
<pre><code>php bin/console d:m:m --env=test</code></pre>
                    <p>On va loader les fixtures dans notre base de données avec la commande :</p>
<pre><code>php bin/console d:f:l --env=test</code></pre>
                    <p>Maintenant que cette base de données est créée, on va enfin faire les différents tests en commençant par les tests unitaires. Pour tester l'entité "Recipe", on utilise la commande suivante :</p>
<pre><code>php bin/console make:test KernelTestCase \App\Tests\Unit\RecipeTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

        namespace App\Tests\Unit;

        use App\Entity\Recipe;
        use App\Entity\User;
        use App\Entity\Mark;
        use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

        class RecipeTest extends KernelTestCase
        {
            public function getEntity(): Recipe
            {
                return (new Recipe())-&gt;setName('Recipe #1')
                    -&gt;setDescription('Description #1')
                    -&gt;setIsFavorite(true)
                    -&gt;setCreatedAt(new \DateTimeImmutable())
                    -&gt;setupdatedAt(new \DateTimeImmutable());
            }

            public function testEntityIsValid(): void
            {
                self::bootKernel();
                $container = static::getContainer();

                $recipe = $this-&gt;getEntity();

                $errors = $container-&gt;get('validator')-&gt;validate($recipe);

                $this-&gt;assertCount(0, $errors);
            }
        }

        public function testInvalidName()
        {
            self::bootKernel();
            $container = static::getContainer();

            $recipe = $this-&gt;getEntity();
            $recipe-&gt;setName('');

            $errors = $container-&gt;get('validator')-&gt;validate($recipe);

            $this-&gt;assertCount(2, $errors);
        }

        public function testGetAverage()
        {
            $recipe = $this-&gt;getEntity();
            $user = static::getContainer()-&gt;get('doctrine.orm.entity_manager')-&gt;find(User::class, 1);

            for ($i = 0; $i &lt; 5; $i++) {
                $mark = new Mark();
                $mark-&gt;setMark(2)
                    -&gt;setUser($user)
                    -&gt;setRecipe($recipe);
                
                $recipe-&gt;addMark($mark);
            }

            $this-&gt;assertTrue(2.0 === $recipe-&gt;getAverage());
        }
?&gt;</code></pre>
                    <p>Pour les tests fonctionnels, on va tester si on arrive sur telle ou telle page, si le formulaire est valide, etc. On va faire un nouveau test fonctionnel avec la commande suivante :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\HomePageTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class HomePageTest extends WebTestCase
    {
        public function testSomething(): void
        {
            $client = static::createClient();
            $crawler = $client-&gt;request('GET', '/');

            $this-&gt;assertResponseIsSuccessful();

            $button = $crawler-&gt;filter('.btn.btn-primary.btn-lgz');
            $this-&gt;assertEquals(1, count($button));

            $recipes = $crawler-&gt;filter('.recipes .card');
            $this-&gt;assertEquals(3, count($recipes));

            $this-&gt;assertSelectorTextContains('h1', 'Bienvenue sur SymRecipe');
        }
    }

?&gt;</code></pre>
                    <p>Pour le test fonctionnel pour le formulaire de contact dans notre "App\Tests\Functional\ContactTest.php", on va avoir le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Response;

    class ContactTest extends WebTestCase
    {
        public function testIfSubmitContactFormIsSuccessful(): void
        {
            $client = static::createClient();
            $crawler = $client-&gt;request('GET', '/contact');

            $this-&gt;assertResponseIsSuccessful();
            $this-&gt;assertSelectorTextContains('h1', 'Formulaire de contact');

            // Récupérer le formulaire
            $submitButton = $crawler-&gt;selectButton('Soumettre ma demande');
            $form = $submitButton-&gt;form();

            $form["contact[fullName]"] = "Jean Dupont";
            $form["contact[email]"] = "jd@symrecipe.com";
            $form["contact[subject]"] = "Test";
            $form["contact[message]"] = "Test";

            // Soumettre le formulaire
            $client-&gt;submit($form);

            // Vérifier le statut HTTP
            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            // Vérifier l'envoi du mail
            $this-&gt;assertEmailCount(1);

            $client-&gt;followRedirect();

            // Vérifier la présence du message de succès
            $this-&gt;assertSelectorTextContains('div.alert.alert-success.mt-4', 'Votre demande a été envoyée avec succès !');
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on va créer un test fonctionnel pour tester la logique de connexion avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\LoginTest</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Response;

    class LoginTest extends WebTestCase
    {
        public function testIfLoginIsSuccessful(): void
        {
            $client = static::createClient();

            /** @var urlGeneratorInterface $urlGenerator */
            $urlGenerator = $client-&gt;getContainer()-&gt;get("router");

            $crawler = $client-&gt;request('GET', $urlGenerator-&gt;generate('security.login'));

            $form = $crawler-&gt;filter("form[name=login]")-&gt;form([
                "_username" =&gt; "admin@symrecipe.fr",
                "_password" =&gt; 'password',
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertRouteSame('home.index');
        }
    }

    public function testIfLoginFailedWhenPasswordIsWrong(): void
    {
        $client = static::createClient();

            /** @var urlGeneratorInterface $urlGenerator */
            $urlGenerator = $client-&gt;getContainer()-&gt;get("router");

            $crawler = $client-&gt;request('GET', $urlGenerator-&gt;generate('security.login'));

            $form = $crawler-&gt;filter("form[name=login]")-&gt;form([
                "_username" =&gt; "admin@symrecipe.fr",
                "_password" =&gt; 'password_',
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertRouteSame('security.login');

            $this-&gt;assertSelectorTextContains("div.alert-danger", "Invalid credentials.");
    }
?&gt;</code></pre>
                    <p>On va créer un "Makefile" avec toutes les commandes à faire, c'est-à-dire avec le contenu suivant :</p>
<pre><code>.PHONY: tests
tests:
    php bin/console d:d:d --force --if-exists --env=test
    php bin/console d:d:c --env=test
    php bin/console d:m:m --no-interaction --env=test
    php bin/console d:f:l --no-interaction --env=test
    php bin/phpunit --testdox tests/Unit/
    php bin/phpunit --testdox tests/Functional/</code></pre>
                    <p>On exécute le "Makefile" avec la commande :</p>
<pre><code>make tests</code></pre>
                    <p>On peut également faire des tests sur un CRUD simple, comme par exemple le CRUD d'un ingrédient avec la commande :</p>
<pre><code>php bin/console make:test WebTestCase \App\Tests\Functional\IngredientTest</code></pre>
                    <p>On peut modifier le contenu de notre classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Tests\Functional;

    use App\Entity\User;
    use App\Entity\Ingredient;
    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;

    class IngredientTest extends WebTestCase
    {
        public function testIfCreateIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            // Recup urlGenerator
            $urlGenerator = $client-&gt;getContainer()-&gt;('router');

            // Recup entity manager
            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);

            $client-&gt;loginUser($user);

            // Se rendre sur la page de création d'un ingrédient
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.new'));

            // Gérer le formulaire
            $form = $crawler-&gt;filter('form[name=ingredient]')-&gt;form([
                'ingredient[name]' =&gt; "Un ingrédient",
                'ingredient[price]' =&gt; floatval(33)
            ]);

            $client-&gt;submit($form);

            // Gérer la redirection
            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            // Gérer l'alert box et la route
            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été créé avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfListIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);

            $client-&gt;loginUser($user);

            $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.index'));

            $this-&gt;assertResponseIsSuccessful();

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfUpdateAnIngredientIsSuccessful(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);
            
            $ingredient = $entityManager-&gt;getRepository(Ingredient::class)-&gt;findOneBy([
            'user' =&gt; $user
            ]);
            
            $client-&gt;loginUser($user);
            
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.edit', [
                'id' =&gt; $ingredient-&gt;getId()
            ]));

            $this-&gt;assertResponseIsSuccessful();

            $form = $crawler-&gt;filter('form[name=ingredient]')-&gt;form([
                'ingredient[name]' =&gt; "Un ingrédient 2",
                'ingredient[price]' =&gt; floatval(34)
            ]);

            $client-&gt;submit($form);

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été modifié avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }

        public function testIfDeleteAnIngredient(): void
        {
            $client = static::createClient();

            $urlGenerator = $client-&gt;getContainer()-&gt;('router');

            $entityManager = $client-&gt;getContainer()-&gt;get('doctirne.orm.entity_manager');

            $user = $entityManager-&gt;find(User::class, 1);
            
            $ingredient = $entityManager-&gt;getRepository(Ingredient::class)-&gt;findOneBy([
                'user' =&gt; $user
            ]);
            
            $client-&gt;loginUser($user);
            
            $crawler = $client-&gt;request(Request::METHOD_GET, $urlGenerator-&gt;generate('ingredient.delete', [
                'id' =&gt; $ingredient-&gt;getId()
            ]));

            $this-&gt;assertResponseStatusCodeSame(Response::HTTP_FOUND);

            $client-&gt;followRedirect();

            $this-&gt;assertSelectorTextContains('div.alert-success', 'Votre ingrédient a été supprimé avec succès !');

            $this-&gt;assertRouteSame('ingredient.index');
        }
    }

?&gt;</code></pre>
                    <p>On peut aussi tester le CRUD des ingrédients via EasyAdmin. On va créer un nouveau dossier "Admin" dans le dossier "tests/Functional" et on va créer le fichier "ContactTest.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Tests\Funtional\Admin;

    use App\Entity\User;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfont\Bundle\FrameworkBundle\Test\WebTestCase;
    use Symfony\Component\HttpFoundation\Request;

    class ContactTest extends WebTestCase
    {
        public function testCrudIsHere(): void
        {
            $client = static::createClient();

            /** @var EntityManagerInterface $entityManager */
            $entityManager = $client-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');

            $user = $entityManager-&gt;getRepository(User::class)-&gt;findOneBy(['id' =&gt; 1]);

            $client-&gt;loginUser($user);

            $client-&gt;request(Request::METHOD_GET, '/admin');

            $this-&gt;assertResponseIsSuccessful();

            $crawler = $client-&gt;clickLink('Demandes de contact');

            $this-&gt;assertResponseIsSuccessful();

            $client-&gt;click($crawler-&gt;filter('.action-new')-&gt;link());

            $this-&gt;assertResponseIsSuccessful();

            $client-&gt;request(Request::METHOD_GET, '/admin');

            $client-&gt;click($crawler-&gt;filter('.action-edit')-&gt;link());

            $this-&gt;assertResponseIsSuccessful();
        }
    }

?&gt;</code></pre>
                    <h3>Étape 23 : Créer une commande :</h3>
                    <p>Dans cette partie, on va pouvoir créer un administrateur en ligne de commandes. Cela permettra d'ajouter des administrateurs par la suite si le site se développe. Donc, on va créer une commande "app:create-administrator" avec la commande suivante :</p>
<pre><code>php bin/console make:command app:create-administrator</code></pre>
                    <p>Cela génèrera le fichier <span class="em">`src/Command/CreateAdministratorCommand.php`</span> avec le contenu modifié suivant :</p>
<pre><code>&lt;?php

    namespace App\Command;

    use App\Entity\User;
    use Doctrine\ORM\EntityManagerInterface
    use Symfony\Component\Console\Attribute\AsCommand;
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputArgument;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Output\OutputInterface;
    use Symfony\Component\Console\Question\Question;
    use Symfony\Component\Console\Style\SymfonyStyle;

    #[AsCommand(
        name: 'app:create-administrator',
        description: 'Create an Administrator',
    )]
    class CreateAdministratorCommand extends Command
    {
        private EntityManagerInterface $entityManager;

        public function __construct(EntityManagerInterface $entityManager)
        {
            parent::__construct('app:create-administrator');

            $this-&gt;entityManager = $entityManager;
        }

        protected function configure(): void
        {
            $this
                -&gt;addArgument('full_name', InputArgument::OPTIONAL, 'Full Name')
                -&gt;addArgument('email', InputArgument::OPTIONAL, 'Email')
                -&gt;addArgument('password', InputArgument::OPTIONAL, 'Password');
        }

        protected function execute(InputInterface $input, OutputInterface $output): int
        {
            $helper = $this-&gt;getHelper('question');
            $io = new SymfonyStyle($input, $output);

            $fullName = $input-&gt;getArgument('full_name');
            if (!$fullName) {
                $question = new Question('Quel est le nom de l\'adminstrateur : ');
                $fullName = $helper-&gt;ask($input, $output, $question);
            }

            $email = $input-&gt;getArgument('email');
            if (!$email) {
                $question = new Question('Quel est l\'email de ' . $fullName . ' : ');
                $email = $helper-&gt;ask($input, $output, $question);
            }

            $plainPassword = $input-&gt;getArgument('password');
            if (!$plainPassword) {
                $question = new Question('Quel est le mot de passe de ' . $fullName . ' : ');
                $plainPassword = $helper-&gt;ask($input, $output, $question);
            }

            $user = (new User())-&gt;setFullName($fullName)
                -&gt;setEmail($email)
                -&gt;setPlainPassword($plainPassword)
                -&gt;setRoles(['ROLE_USER', 'ROLE_ADMIN']);

            $this-&gt;entityManager-&gt;persist($user);
            $this-&gt;entityManager-&gt;flush();

            $io-&gt;success('Le nouvel administrateur a été créé !');

            return Command::SUCCESS;
        }
    }

?&gt;</code></pre>
                    <p>La commande devient donc ceci :</p>
<pre><code>php bin/console app:create-administrator</code></pre>
                    <p>Et avec les arguments :</p>
<pre><code>php bin/console app:create-administrator "Emilien" "emilien@symrecipe.fr" "password"</code></pre>
                    <h3>Étape 24 : Créer un filtre Twig :</h3>
                    <p>Par exemple si la recette a un temps en minutes avec une valeur de "1005", on pourrait afficher le temps en heures/minutes et donc créer/utiliser un filtre Twig (ou encore "extension Twig").</p>
                    <p>Pour cela, dans le dossier "src", on crée le dossier "Twig" et on y insère le fichier "AppExtension.php" ou on utilise la commande suivante :</p>
<pre><code>php bin/console make:twig-extension AppExtension</code></pre>
                    <p>On va modifier son contenu comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Twig;

    use Twig\Extension\AbstractExtension;
    use Twig\TwigFilter;

    class AppExtension extends AbstractExtension
    {
        public function getFilters(): array
        {
            return [
                new TwigFilter('min_to_hour', [$this, 'minutesToHours']);  
            ];
        }

        public function minutesToHours($value)
        {
            if ($value &lt; 60 || !$value) {
                return $value;
            }

            $hours = floor($value / 60);
            $minutes = $value % 60;

            if ($minutes &lt; 10) {
                $minutes = '0' . $minutes;
            }

            $time = sprintf('%sh%s'; $hours, $minutes);

            return $time;
        }
    }
?&gt;</code></pre>
                    <p>Une fois le filtre créé, dans notre template, on peut l'utiliser comme ceci :</p>
<pre><code>&lt;p&gt;Temps : {{ recipe.time|min_to_hour }}&lt;/p&gt;</code></pre>
                    <h3>Étape 25 : Mise en place d'un cache pour notre application :</h3>
                    <p>Un cache va permettre de stocker les pages de nombreux sites Web, c'est-à-dire que les pages peuvent toujours être consultées même si le site Web d'origine est hors ligne.</p>
                    <p>Dans le "Cache Component" qui couvre les besoins simples et plus avancés au niveau du cache, on a deux grandes familles : le "Cache Contracts" qui est un sytème plus simple et plus puissant mettant en cache des valeurs appelées ou recalculées très fréquemment, et le "PSR-6 Caching" qui est un système générique de cache basé sur des systèmes de "pools" et de "items".</p>
                    <p>Dans notre application, comme on affiche très souvent les recettes publiques, ce sera intéressant de mettre un "Cache Contracts" dessus.</p>
                    <p>Dans notre fonction "findPublicRecipe" de notre "RecipeRepository", on a un "sleep(3);". Dans le "RecipeController", on va ajouter le cache dans la fonction "indexPublic" comme ceci :</p>
<pre><code>#[Route('/recette/communaute', 'recipe.community', methods: ['GET'])]
public function indexPublic(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $cache = new FilesystemAdapter();
    $data = $cache-&gt;get('recipes', function(ItemInterface $item) use ($repository) {
        $item-&gt;expiresAfter(15);
        return $repository-&gt;findPublicRecipe(null);
    });

    $recipes = $paginator-&gt;paginate(
        $data,
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe/commuity.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <h3>Webpack Encore :</h3>
                    <p>Symfony nous permet de manager correctement nos fichiers CSS et JavaScript, notamment avec "Webpack Encore". Cela va nous permettre de rendre notre travail plus agréable et plus qualicatif au niveau des fichiers de style et des fichiers de script. Ça va nous éviter d'avoir des fichiers dans le dossier "public" et de les inclure un à un.</p>
                    <p>D'après Wikipédia, <q>Webpack est un modules bundle open source. Son objectif principal est de regrouper des fichiers JavaScript pour les utiliser dans un navigateur. Cet outil est également capable de transformer, regrouper ou empaqueter à peu près n'importe quelle ressource."</q></p>
                    <p>Webpack Encore est un moyen plus simple d'intégrer Webpack dans notre application car de base il n'est pas facile à configurer. La première étape est d'installer le bundle avec la commande suivante :</p>
<pre><code>composer require symfony/webpack-encore-bundle</code></pre>
                    <p>Il nous demande ensuite de faire :</p>
<pre><code>yarn install</code></pre>
                    <p>Cela permet donc de faire un "vendor" pour JavaScript : les "node_modules" avec un fichier "package.json". On peut également utiliser le "<span class="em">npm install</span>"" à la place. Pour voir les modifications instantanées sur notre style sur Symfony avec la commande :</p>
<pre><code>yarn watch</code></pre>
                    <p>Ça permet de compiler tous nos fichiers dans le dossier "assets" dans le dossier "public/build". Dans ce nouveau dossier, on aura les fichiers "app.css" et "app.js". Dans le fichier "webpack.config.js", on a des "entry".</p>
                    <p>Grâce à "<span class="em">{{ encore_entry_link_tags('app') }}</span>" et à "<span class="em">{{ encore_entry_script_tags('app') }}</span>", Symfony sait qu'on utilise Webpack Encore.</p>
                    <h3>Étape 26 : Les Event Listener & Event Subscriber :</h3>
                    <p>Durant l'exécution d'une application Symfony, plusieurs notifications d'évènements sont déclenchées. Par exemple, plusieurs évènements sont déclenchés lors d'une requête HTTP classique.</p>
                    <p>La façon la plus commune pour écouter un évènement est d'enregistrer un "event listener". Dans le dossier "src", on crée le dossier "EventListener" et créer le fichier "ExceptionListener.php" ou avec la commande suivante :</p>
<pre><code>php bin/console make:listener ExceptionListener</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\EventListener;

    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Event\ExceptionEvent;
    use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface;

    class ExceptionListener
    {
        public function onKernelException(ExceptionEvent $event)
        {
            // You get the exception object from the reveived event
            $exception = $event-&gt;getThrowable();
            $message = sprintf(
                'My error says: %s with code: %s',
                $exception-&gt;getMessage(),
                $exception-&gt;getCode()
            );

            // Customize your response object to display the exception details
            $response = new Response();
            $response-&gt;setContent($message);

            // HttpExceptionInterface is a special type of exception that
            // holds status code and header details
            if ($exception instanceof HttpExceptionInterface) {
                $response-&gt;setStatusCode($exception-&gt;getStatusCode());
                $response-&gt;headers-&gt;replace($exception-&gt;getHeaders());
            } else {
                $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);
            }

            // sends the modified response object to the event
            $event-&gt;setResponse($response);
        }
    }

?&gt;</code></pre>
                    <p>Dans le fichier de configuration "services.yaml", on doit ajouter les lignes suivantes :</p>
<pre><code>App\EventListener\ExceptionListener:
    tags:
        - { name: kernel.event_listener, event: kernel.exception }</code></pre>
                    <p>L'"event subscriber" est une classe qui définit une ou plusieurs méthodes qui écoutent un ou plusieurs évènements. La principale différence entre les deux est que les subscribers connaissent toujours les évènements qu'ils écoutent.</p>
                    <p>Dans le dossier "src", on crée le dossier "EventSubscriber" et dedans le fichier "kernelSubscriber.php" ou le créer via la commande :</p>
<pre><code>php bin/console make:subscriber</code></pre>
                    <p>On va modifier le contenu de cette classe comme ceci :</p>
<pre><code>&lt;?php

    namespace App\EventSubscriber;

    use Symfony\Component\EventDispatcher\EventSubscriberInterface;
    use Symfony\Component\HttpKernel\Event\RequestEvent;

    class kernelSubscriber implements EventSubscriberInterface
    {
        public static function getSubscribedEvents()
        {
            return [RequestEvent =&gt; 'onKernelRequest'];
        }

        public function onKernelRequest(RequestEvent $event)
        {
            dd($event-&gt;getRequest()-&gt;getPathInfo());
        }
    }

?&gt;</code></pre>
                    <h3>Étape 27 : Authentification à double facteur :</h3>
                    <p>Pour cette partie, on va créer un nouveau projet Symfony avec la commande :</p>
<pre><code>symfony new 2FA --webapp</code></pre>
                    <p>On duplique le contenu du fichier ".env" dans un nouveau fichier ".env.local". On va décommenter la ligne de la DB en SQLite par exemple et on va la créer avec la commande :</p>
<pre><code>symfony console d:d:c</code></pre>
                    <p>On va créer un contrôleur "Home" avec la commande :</p>
<pre><code>symfony console make:controller Home</code></pre>
                    <p>On va modifier la fonction "index" et on ajoute une fonction "home" comme ceci :</p>
<pre><code>#[Route('/home', name: 'home')]
public function home(): Response
{
    return $this-&gt;render('home/index.html.twig');
}

#[Route('/', name: 'index')]
public function index(): Response
{
    return $this-&gt;redirectToRoute('home');
}</code></pre>
                    <p>Pour sécuriser la page "/home" pour dire que seul l'utilisateur ayant le rôle "ROLE_USER" peut y accéder, on peut ajouter dans le "access_control" du fichier "security.yaml" un path comme ceci :</p>
<pre><code>access_control:
    - { path: ^/home, roles: ROLE_USER }</code></pre>
                    <p>On va créer un entité "User" avec la commande :</p>
<pre><code>symfony console make:user</code></pre>
                    <p>On oublie pas tout de suite dans la foulée de créer une migration avec la commande :</p>
<pre><code>symfony console make:migration</code></pre>
                    <p>Et bien sûr de migrer cette migration avec :</p>
<pre><code>symfony console d:m:m</code></pre>
                    <p>On va ensuite créer une page d'authentification avec la commande :</p>
<pre><code>symfony console make:auth</code></pre>
                    <p>On va donc créer un login form authenticator dans une classe "AppAuthenticator". On peut également créer une page d'inscription avec la commande :</p>
<pre><code>symfony console make:registration-form</code></pre>
                    <p>Grâce à la commande précédente, on peut ajouter une validation "<span class="em">@UniqueEntity</span>" à l'entité "User". Ça peut également envoyer un email pour vérifier l'adresse email de l'utilisateur après l'inscription ainsi qu'authentifier l'utilisateur après l'inscription. Après l'inscription, on veut être redirigé vers la page "home".</p>
                    <p>Pour mettre en place l'authentification à double facteur, on doit installer le bundle "2FA" avec la commande :</p>
<pre><code>composer require 2fa</code></pre>
                    <p>On va aussi installer une extension à ce bundle qui est "scheb/2fa-email" avec la commande suivante :</p>
<pre><code>composer require scheb/2fa-email</code></pre>
                    <p>Dans le "main firewall" de "security.yaml", on va rajouter les lignes suivantes :</p>
<pre><code>two_factor:
    auth_form_path: 2fa_login # The route name you have used in the routes.yaml
    check_path: 2fa_login_check # The route name you have used in the routes.yaml</code></pre>
                    <p>Dans le fichier de configuration "<span class="em">scheb_2fa.yaml</span>", on va modifier son contenu comme ceci :</p>
<pre><code>scheb_two_factor:
    security_tokens:
        - Symfony\Component\Security\Http\Authenticator\token\PostAuthenticationToken
    email:
        digits: 6
        enabled: true
        sender_email: no-reply@test.com
        sender_name: John Doe</code></pre>
                    <p>On va implémenter le "<span class="em">Scheb\TwoFactorBundle\Model\Email\TwoFactorInterface</span>" dans notre entité "User" avec les lignes suivantes :</p>
<pre><code>#[ORM\Column(type: 'string', nullable: true)]
private $authCode;

public function isEmailAuthEnabled(): bool
{
    return true;    // This can be a persist field to switch email code authentication on/off
}

public function getEmailAuthRecipient(): string
{
    return $this-&gt;email;
}

public function getEmailAuthCode(): string
{
    if (null === $this-&gt;authCode) {
        throw new \LogicException('The email authentication code was not set');
    }

    return $this-&gt;authCode;
}

public function setEmailAuthCode(string $authCode): void
{
    $this-&gt;authCode = $authCode;
}</code></pre>
                    <p>Maintenant qu'on a modifié l'entité "User", on va créer une nouvelle migration et on va la migrer. On va configurer le "MAILER_DSN" via Docker par exemple dans le fiche "docker-compose.yml" avec le contenu suivant :</p>
<pre><code>version: '3.7'
services:
    mailer:
    image: schickling/mailcatcher
    ports: [1025, 1080]</code></pre>
                    <p>On va démarrer notre petit serveur de mail Docker avec la commande :</p>
<pre><code>docker-compose up -d</code></pre>
                    <p>Ensuite, on va mettre en place les appareils de confiance pour ne pas chaque fois récupérer un code par email lors de la double authentification.</p>
                    <p>On va installer une nouvelle extension à ce bundle avec la commande :</p>
<pre><code>composer require scheb/2fa-trusted-device</code></pre>
                    <p>Dans notre fichier de configuration "scheb_2fa.yaml", on va rajouter les lignes suivantes :</p>
<pre><code>trusted_device:
    enabled: true   # If the trusted device feature should be enabled
    lifetime: 5184000   # Lifetime of the trusted device token
    extend_lifetime: false  # Automatically extend lifetime of the trusted cookie on re-login
    cookie_name: trusted_device # Name of the trusted device cookie
    cookie_secure: false    # Set the 'Secure' (HTTPS Only) flag on the trusted device cookie
    cookie_same_site: "lax" # The same-site option of the cookie, can be "lax" or "strict"
    cookie_path: "/"    # Path to use when setting the cookie</code></pre>
                    <p>Dans le "two_factor" de notre "main firewall" de notre "security.yaml", on rajoute la ligne :</p>
<pre><code>trusted_parameter_name: _trusted # Name of the parameter for the trusted device option</code></pre>
                    <h3>Étape 28 : Authentification à deux facteurs avec Google Authenticator :</h3>
                    <p>Avec le prochain package qu'on va installer, le site web va générer un QR Code qui va partager une "OTP Secret Key", l'"issuer" (l'émetteur) et la "period" (durée de validation du QR Code définie par défaut à 30 secondes).</p>
                    <p>Dans un terminal, on va cloner <a href="https://github.com/pentiminax/symfony-google-authenticator" target="_blank">le repository "symfony-google-authenticator" du youtubeur "Pentiminax"</a> dont les explications sont tirées avec la commande :</p>
<pre><code>git clone https://github.com/pentiminax/symfony-google-authenticator.git</code></pre>
                    <p>On va installer les packages composer et Symfony avec la commande :</p>
<pre><code>composer install</code></pre>
                    <p>On va lancer le serveur local avec la commande :</p>
<pre><code>php -S localhost:8000 -t public/</code></pre>
                    <p>Dans notre entité "User", on a une nouvelle propriété qui va stocker la clé secrète :</p>
<pre><code>#[ORM\Column(length: 255, nullable: true)]
private ?string $secret = null;</code></pre>
                    <p>Dans notre fichier de configuration des services, "services.yaml", on a un paramètre "app.issuer" avec la valeur "Amazaune" par exemple.</p>
                    <p>Pour commencer on va créer le service "AuthenticatorService" dans le dossier "src/Service" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Doctrine\ORM\EntityManagerInterface;
    use OTPHP\TOTP;
    use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

    class AuthenticatorService
    {
        public function __construct(
            private readonly ParameterBagInterface $parameters,
            private readonly EntityManagerInterface $em
        )
        {

        }

        public function getCodeUri(User $user): array
        {
            $totp = TOTP::generate();

            $totp-&gt;setIssuer($this-&gt;parameters-&gt;get('app.issuer'));
            $totp-&gt;setLabel($user-&gt;getUserIdentifier());

            $qrCodeUri = $totp-&gt;getQRCodeUri(
                'https://api.qrserver.com/v1/create-qr-code/?color=000&bgcolor=FFF&data=[DATA]&qzone=2&margin=0&size=300x300&ecc=M',
                '[DATA]'
            );

            return [$qrCodeUri, $totp-&gt;getSecret()];
        }

        public function validatePairing(User $user, string $secret): void
        {
            if (!$secret) {
                return;
            }

            $user-&gt;setSecret($secret);

            $this-&gt;em-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Dans le "AuthenticatorController", on va y modifier sa fonction "pair" comme ceci :</p>
<pre><code>&lt;?php

    namespace App\Controller;

    use App\Service\AuthenticatorService;
    ...

    class AuthenticatorController extends AbstractController
    {
        #[Route('authenticator/pair', name: 'app_authenticator_pair')]
        public function pair(AuthenticatorService $authenticatorService, Request $request): Response
        {
            if ($request-&gt;isMethod(Request::METHOD_POST)) {
                $authenticatorService-&gt;validatePairing($this-&gt;getUser(), $request-&gt;request-&gt;get('secret'));

                return $this-&gt;redirectToRoute('app_home_index');
            }

            [$qrCodeUri, $secret] = $authenticatorService-&gt;getQRCodeUri($this-&gt;getUser());

            return $this-&gt;render('authenticator/pair.html.twig', [
                'qrCodeUri' =&gt; $qrCodeUri,
                'secret' =&gt; $secret
            ]);
        }
    }

?&gt;</code></pre>
                    <p>On va modifier également le template pour qu'il puisse afficher les nouvelles valeurs comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}
    
{% block title %}Pair{% endblock %}

{% block body %}
    &lt;img alt="QR Code" src="{{ qrCodeUri }}"&gt;

    &lt;form method="post"&gt;
        &lt;input type="hidden" name="secret" value="{{ secret }}"&gt;
        &lt;button type="submit"&gt;Validate Pairing&lt;/button&gt;
    &lt;/form&gt;
{% endblock %}</code></pre>
                    <p>Enfin, on va vérifier le code dans la fonction "verify" du "AuthenticatorController" :</p>
<pre><code>#[Route('/authenticator/verify', name: 'app_authenticator_verify')]
public function verify(Request $request): Response
{
    if (is_null($this-&gt;getUser()-&gt;getSecret())) {
        return $this-&gt;redirectToRoute('app_authenticator_pair');
    }

    if ($request-&gt;isMethod(Request::METHOD_POST)) {
        $totp = TOTP::createFromSecret($this-&gt;getUser()-&gt;getSecret());

        $result = $totp-&gt;verify($request-&gt;request-&gt;getString('otp'));
    }

    return $this-&gt;render('authenticator/verify.html.twig', [
        'result' =&gt; $result ?? null;
    ]);
}</code></pre>
    <p>On modifie également son template comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Verify{% endblock %}

{% block body %}
    &lt;form method="post"&gt;
        &lt;label for="otp"&gt;OTP Code&lt;/label&gt;
        &lt;input type="text" name="otp" id="otp"&gt;
        &lt;button type="submit"&gt;Verify&lt;/button&gt;
    &lt;/form&gt;

    &lt;br/&gt;

    {% if result is not null %}
        &lt;p&gt;{{ result == true ? 'Le code est bon' : "C'est pas bon" }}&lt;/p&gt;
    {% endif %}
{% endblock %}</code></pre>
    <h3>À la découverte des variables d'environnement de Symfony :</h3>
    <p>Dans cette partie, nous allons partir à la découverte des variables d'environnement de Symfony, et vous allez voir qu'il y a une infinité de façons de les définir ou de les utiliser !</p>
    <h4>Initier notre projet Symfony :</h4>
    <p>Crérons notre projet et entrons dans le dossier :</p>
<pre><code>symfony new variables_environnement --webapp
cd variables_environnement</code></pre>
    <p>Créons un contrôleur de test :</p>
<pre><code>symfony console make:controller TestController</code></pre>
    <p>Démarrons notre application :</p>
<pre><code>symfony serve -d</code></pre>
    <p>Et supprimons toutes références à Webpack dans le fichier <span class="em">`templates/bas.html.twig`</span> :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;{% block title %}Welcome!{% endblock %}&lt;/title&gt;
        &lt;link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 128 128%22&gt;&lt;text y=%221.2em%22 font-size=%2296%22&gt;⚫️&lt;/text&gt;&lt;/svg&gt;"&gt;
        {# Run `composer require symfony/webpack-encore-bundle` to start using Symfony UX #}
        {% block stylesheets %}
        {% endblock %}

        {% block javascripts %}
        {% endblock %}
    &lt;/head&gt;
    &lt;body&gt;
        {% block body %}{% endblock %}
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
    <h4>Définir des variables d'environnement :</h4>
    <h5>Définir des variables d'environnement avec un fichier `.env` et `.env.local` :</h5>
    <p>Par défaut, Symfony utilise les variables d'environnement définies dans le fichier <span class="em">`.env`</span> pour définir les variables d'environnement.</p>
    <p>Si on consulte ce fichier on peut voir qu'il y a plusieurs variables d'environnement (j'ai supprimé les commentaires) :</p>
<pre><code>APP_ENV=dev
APP_SECRET=d039c490ad66d067877186a6640183ab
MESSENGER_TRANSPORT_DSN=doctrine://default?auto_setup=0
DATABASE_URL="postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8"</code></pre>
    <p>La bonne façon de définir des variables d'environnement est de créer un fichier <span class="em">`.env.local`</span> qui contient les variables d'environnement à utiliser pour le développement sur votre machine et de ne jamais définir des variables d'environnement dans le fichier <span class="em">`.env`</span> (qui est commit sur Git).</p>
    <p>Finalement, le fichier <span class="em">`.env`</span> est une sorte de <span class="em">template</span> qui permet de définir des variables d'environnement utilisées dans le projet.</p>
    <p>Copions donc le fichier <span class="em">`.env`</span> dans un fichier <span class="em">`.env.local`</span>.</p>
<pre><code>cp .env .env.local</code></pre>
    <p>Nous pouvons checker les variables d'environnement avec la debug barre :</p>
    <img src="../images/symfony_variables_environnement_1.webp" alt="">
    <p>Ajoutons une variable d'environnement :</p>
    <ul>
        <li>
            <p>Dans le fichier <span class="em">`.env`</span> <span class="em">`DEMO=`</span></p>
        </li>
        <li>
            <p>Dans le fichier <span class="em">`.env.local`</span> <span class="em">`DEMO="Ceci est une démo"`</span></p>
        </li>
    </ul>
    <p>Et checkons les variables d'environnement :</p>
    <img src="../images/symfony_variables_environnement_2.webp" alt="">
    <h5>Hiérarchie des fichiers de variables d'environnement :</h5>
    <p>Nous l'avons vu juste avant, le fichier <span class="em">`.env.local`</span> est prioritaire sur le fichier <span class="em">`.env`</span>.</p>
    <p>Mais il est possible d'ajouter encore de la finesse dans votre architecture de projet en créant un fichier <span class="em">`.env.dev`</span> qui contient des variables d'environnement spécifiques à un environnement de développement.</p>
    <p>Et copions le contenu du fichier <span class="em">`.env.local`</span> dans le fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>cp .env.local .env.dev</code></pre>
    <p>Et modifions légèrement le contenu du fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>DEMO="Ceci est une démo depuis le fichier .env.local"</code></pre>
    <p>Nous constatons que le fichier <span class="em">`env.dev`</span> est prioritaire sur le fichier <span class="em">`.env.local`</span> :</p>
    <img src="../images/symfony_variables_environnement_3.webp" alt="">
    <p>Poussons encore plus loin dans notre architecture de projet en créant un fichier <span class="em">`.env.dev.local`</span> en y copiant le contenu du fichier <span class="em">`.env.dev`</span> :</p>
<pre><code>cp .env.dev .env.dev.local</code></pre>
    <p>Nous constatons que le fichier <span class="em">`.env.dev.local`</span> est prioritaire sur le fichier <span class="em">`.env.dev`</span> :</p>
    <img src="../images/symfony_variables_environnement_3.webp" alt="">
    <h4>La CLI :</h4>
    <h5>Dumper les variables d'environnement :</h5>
    <p>Pour des raisons de performances, notamment en production, et afin d'évier de passer les fichiers <span class="em">`.env`</span> à chaque requête, nous pouvons utiliser la commande <span class="em">`dump-env`</span> pour afficher les variables d'environnement dans un fichier PHP :</p>
<pre><code>composer dump-env dev # ou prod</code></pre>
    <p>Un fichier <span class="em">`.env.php`</span> sera crée à la racine du projet :</p>
<pre><code>&lt;?php

    // This file was generated by running "composer dump-env dev"

    return array (
        'APP_ENV' => 'dev',
        'APP_SECRET' => 'd039c490ad66d067877186a6640183ab',
        'MESSENGER_TRANSPORT_DSN' => 'doctrine://default?auto_setup=0',
        'DATABASE_URL' => 'postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8',
        'DEMO' => 'Ceci est une démo depuis le fichier .env.dev.local',
    );

?&gt;</code></pre>
    <p>Modifions le contenu du fichier <span class="em">`.env.php`</span> (À ne jamais faire, c'est uniquement pour la démo) :</p>
<pre><code>&lt;?php

    // This file was generated by running "composer dump-env dev"

    return array (
        'APP_ENV' => 'dev',
        'APP_SECRET' => 'd039c490ad66d067877186a6640183ab',
        'MESSENGER_TRANSPORT_DSN' => 'doctrine://default?auto_setup=0',
        'DATABASE_URL' => 'postgresql://symfony:ChangeMe@127.0.0.1:5432/app?serverVersion=13&charset=utf8',
        'DEMO' => 'Ceci est une démo depuis le fichier .env.local.php',
    );

?&gt;</code></pre>
    <p>Et vérifions que les variables d'environnement sont bien modifiées :</p>
    <img src="../images/symfony_variables_environnement_4.webp" alt="">
    <h5>Lister les vaériables d'environnement en CLI :</h5>
    <p>La multiplicité des fichiers peut rendre la lecture des variables d'environnement difficile. C'est pourquoi il existe une commande qui permet de lister les variables d'environnement :</p>
<pre><code>symfony console debug:dotenv</code></pre>
    <p>Le résultat de la commande est hyper clair :</p>
    <img src="../images/symfony_variables_environnement_5.webp" alt="">
    <h4>Accéder aux variables d'environnement :</h4>
    <p>Maintenant que nous avons vu comment récupérer les variables d'environnement, nous pouvons les utiliser dans notre application.</p>
    <h5>Accéder aux variables d'environnement depuis les contrôleurs :</h5>
    <p>Afin d'accéder à vos variables d'environnement depuis les contrôleurs, nous devons les ajouter dans notre fichier <span class="em">`config/services.yaml`</span> :</p>
<pre><code>parameters:
    demo: '%env(DEMO)%'</code></pre>
    <p>Vérifions avec une nouvelle commande que notre variable d'environnement est bien présente :</p>
<pre><code>symfony console debug:container --env-vars</code></pre>
    <p>Dans notre contrôleur <span class="em">`src/Controller/TestController.php`</span> ajoutons de quoi accéder à la variable d'environnement :</p>
<pre><code>#[Route('/test', name: 'app_test')]
public function index(): Response
{
    $demo = $this-&gt;getParameter('DEMO');
    dd($demo);

    return $this-&gt;render('test/index.html.twig', [
    'controller_name' =&gt; 'TestController',
    ]);
}</code></pre>
    <p>Et vérifions !</p>
    <img src="../images/symfony_variables_environnement_6.webp" alt="">
    <h5>Accéder aux variables d'environnement depuis les services :</h5>
    <p>Voyons maintenant comment accéder aux variables d'environnement depuis les services.</p>
    <h6>la méthode "manuelle" :</h6>
    <p>Commençons par créer un service dans le fichier <span class="em">`src/Service/DemoService.php`</span> qui permet de récupérer les variables d'environnement :</p>
<pre><code>&lt;?php

    namespace App\Service;

    use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

    class DemoService
    {
        public function __construct(ParameterBagInterface $parameterBag)
        {
            $this-&gt;parameterBag = $parameterBag;
        }

        public function getDemo(): string
        {
            return $this-&gt;parameterBag-&gt;get('DEMO');
        }
    }

?&gt;</code></pre>
    <p>Et modifions notre contrôleur <span class="em">`src/Controller/TestController.php`</span> pour utiliser notre service :</p>
<pre><code>&lt;?php

    namespace App\Controller;

    use App\Service\DemoService;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Annotation\Route;

    class TestController extends AbstractController
    {

        #[Route('/test', name: 'app_test')]
        public function index(DemoService $demoService): Response
        {
            dd($demoService-&gt;getDemo());

            return $this-&gt;render('test/index.html.twig', [
                'controller_name' =&gt; 'TestController',
            ]);
        }
    }

?&gt;</code></pre>
    <p>On rafraîchit notre page, c'est bien le contenu de la variable d'environnement qui est affiché :</p>
    <img src="../images/symfony_variables_environnement_7.webp" alt="">
    <h6>La méthode "automatique" :</h6>
    <p>Plutôt que d'utiliser le <span class="em">`ParameterBagInterface`</span> dans le service pour récupérer les variables d'environnement, nous pouvons utiliser la méthode "automatique de Symfony pour injecter les variables d'environnement.</p>
    <p>Dans notre fichier <span class="em">`config/services.yaml`</span> ajoutons :</p>
<pre><code>parameters:
    DEMO: '%env(DEMO)%'

services:
    # ...
    App\Service\DemoService:
        arguments:
            $demo: '%env(DEMO)%'</code></pre>
    <p>Et utilions notre argument <span class="em">`$demo`</span> dans notre service :</p>
<pre><code>&lt;?php

    namespace App\Service;

    class DemoService
    {
        public function __construct(public string $demo)
        {

        }

        public function getDemo(): string
        {
            return $this-&gt;demo;
        }
    }

?&gt;</code></pre>
    <p>Nous pouvons vérifier que tout fonctionne :</p>
    <img src="../images/symfony_variables_environnement_8.webp" alt="">
    <h5>Accéder aux variables d'environnement depuis Twig :</h5>
    <p>Nous pouvons aussi accéder aux variables d'environnement depuis Twig.</p>
    <p>Pour cela, nous devons ajouter une variable d'environnement dans notre fichier <span class="em">`config/packages/twig.yaml`</span> :</p>
<pre><code>twig:
    default_path: '%kernel.project_dir%/templates'
    globals:
        DEMO: '%env(DEMO)%'</code></pre>
    <p>Et dansd notre fichier <span class="em">`templates/test/index.html.twig`</span> nous pouvons accéder à la variable d'environnement directement :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Hello TestController{% endblock %}

{% block body %}

    {{ DEMO }}

{% endblock %}</code></pre>
    <p>Et on rafraîchit notre page, c'est bien le contenu de la variable d'environnement qui est affiché :</p>
    <img src="../images/symfony_variables_environnement_9.webp" alt="">
    <h4>Mettez vos variables d'environnement en sécurité :</h4>
    <p>Comme nous l'avons vu jusqu'ici, nous pouvons accéder aux variables d'environnement depuis n'importe quel endroit de notre application. Nos stockons les variables d'environnement dans un <span class="em">simple</span> fichier.</p>
    <p>C'est certes pratique mais pas nécessairement sécurisé.</p>
    <h5>Utilisation du système de gestion des secrets de Symfony :</h5>
    <p>Symfony propose un système de gestion des secrets basé sur un système de clés cryptographiques.</p>
    <h6>Génération des clés :</h6>
    <p>Première étape, nous allons générer les clés :</p>
<pre><code>php bin/console secrets:generate-keys</code></pre>
    <p>Nous constatons que les clés sont générées avec succès dans les deux fichiers suivants :</p>
    <ul>
        <li>
            <p>config/secrets/dev/dev.decrypt.private.php</p>
        </li>
        <li>
            <p>config/secrets/dev/dev.decrypt.public.php</p>
        </li>
    </ul>
    <p>Si vous souhaitez générer les clés pour la production :</p>
<pre><code>APP_ENV=prod php bin/console secrets:generate-keys</code></pre>
    <p>Nous constatons que les clés sont générées avec succès dans le deux fichiers suivants :</p>
    <ul>
        <li>
            <p>config/secrets/prod/prod.decrypt.private.php</p>
        </li>
        <li>
            <p>config/secrets/prod/prod.decrypt.public.php</p>
        </li>
    </ul>
    <p class="em">Pensez à vérifier que votre fichier <span class="html">`prod.decrypt.private.php`</span> est bien présent dans votre <span class="html">`.gitignore`</span> :</p>
<pre><code>/config/secrets/prod/prod.decrypt.private.php</code></pre>
    <h6>Ajouter une variable d'environnement à la liste des secrets :</h6>
    <p>Pour ajouter un nouveau secret (<span class="em">`DEMO_SECRET: Ceci est un secret`</span>) nous devons utiliser la commande suivante :</p>
<pre><code>php bin/console secrets:set DEMO_SECRET</code></pre>
    <p>Pour la production :</p>
<pre><code>APP_RUNTIME_ENV=prod php bin/console secrets:set DEMO_SECRET</code></pre>
    <p>Nous constatons la création d'un nouveau fichier <span class="em">`config/secrets/dev/dev/DEMO_SECRET.80921a.php`</span> qui contient notre variable d'environnement chiffrée :</p>
<pre><code>&lt;?php // dev.DEMO_SECRET.80921a on Mon, 07 Mar 2022 10:07:38 +0100

    return "\xCD\x9B\x7F6\xDC\xC9\x82\xE6\xEB\xE2\x808\xBF\xA9P\xA8\x9BL\x3A\xA5\xC0\xBD\xA6\xA6\xA7\x7D\x10\xCD\xE9\xD0\xBEg\xA3ez\x8A\xC2\x91k\xD04DDLo\x9D\xB9\x17\xCD\xC9\x989\x24\x3A\xC3U\xFCFP\x5CQ\xC0\xB9\xA3T\x60";

?&gt;</code></pre>
    <p>Et accédons à notre variable d'environnement depuis Twig :</p>
<pre><code>twig:
        default_path: '%kernel.project_dir%templates'
        globals:
            DEMO: '%env(DEMO)%'
            DEMO_SECRET: '%env(DEMO_SECRET)%'</code></pre>
    <p>Modifions notre fichier twig <span class="em">`templates/test/index.html.twig`</span> :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Hello TestController!{% endblock %}

{% block body %}

    {{ DEMO_SECRET }}

{% endblock %}</code></pre>
    <p>Dumpons nos variables d'environnement :</p>
<pre><code>composer dump-env dev</code></pre>
    <p>Et constatons le résultat :</p>
    <img src="../images/symfony_variables_environnement_10.webp" alt="">
    <h6>Set d'un secret en local :</h6>
    <p>Vous pouvez aussi <span class="em">set</span> un secret en local (valable uniquement sur votre machine) :</p>
<pre><code>php bin/console secrets:set --local DEMO_SECRET</code></pre>
    <p>Dumpons nos variables d'environnement :</p>
<pre><code>composer dump-env dev</code></pre>
    <p>Et vérifions :</p>
    <img src="../images/symfony_variables_environnement_11.webp" alt="">
    <h6>Quelques outils pour gérer les secrets :</h6>
    <ul>
        <li>
            <p>Lister les secrets :</p>
<pre><code><span class="html">php bin/console secrets:list --reveal</span>
------------- ---------------------- ---------------------------- 
Secret        Value                  Local Value                 
------------- ---------------------- ---------------------------- 
DEMO_SECRET   "Ceci est un secret"   "Ceci est un secret local"  
------------- ---------------------- ----------------------------</code></pre>
        </li>
        <li>
            <p>Supprimer un secret :</p>
<pre><code>php bin/console secrets:remove DEMO_SECRET</code></pre>
        </li>
    </ul>
    <p>Dans le tutoriel suivant, nous aborderons Laravel, un autre framework PHP populaire pour le développement web.</p>
</article>
<article>
    <h2 id="intro_laravel">Introduction au Framework PHP Laravel :</h2>
    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Laravel. Laravel est un framework web élégant et puissant qui facilite le développement rapide d'applications web modernes.</p>
                    <h3>Étape 1 : Installation de Laravel :</h3>
                    <p>Avant de commencer, assurez-vous d'avoir PHP et le grestionnaire de dépendances Composer installés sur votre système.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Laravel en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project --prefer-dist laravel/laravel nom_du_projet</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Laravel propose un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>php artisan serve</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvre le fichier <span class="em">`routes/web.php`</span> avec votre éditeur de code préféré.</p>
                        </li>
                        <li>
                            <p>Définissez une nouvelle route pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette ligne au fichier web.php
Route::get('/', 'App\Http\Controllers\HomeController@index');</code></pre>
                        </li>
                        <li>
                            <p>Créez un nouveau contrôleur pour gérer cette route :</p>
<pre><code>php artisan make:controller HomeController</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Implémenter la logique du contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvrez le fihcier <span class="em">`app/Http/Controllers/HomeController.php`</span> avec votre éditeur de code.</p>
                        </li>
                        <li>
                            <p>Implémentez la logique du contôleur pour retourner la vue (template) :</p>
<pre><code>// Ajoutez cette méthode à la classe HomeController
public function index() {
    return view('homepage');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 5 : Création de la vue (template) :</h3>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`ressources/views/homepage.blade.php`</span> dans le répertoire du projet.</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Laravel&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Laravel !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenur sur Mon Projet Laravel !" sur la page d'accueil.</p>
                    <p>Félicitations ! Vous avez maintenant créé une application web simple en utilisant Laravel. Laravel propose de nombreuses fonctionnalités pratiques telles que la gestion des migrations de base de données, l'ORM Eloquent, les formulaires, l'authentification et bien olus encore.</p>
                    <p>Vous pouvez continuer à explorer la documentation officielle de Laravel pour découvrir davantage de fonctionnalités et d'outils puissants offerts par ce framework. Laravel dispose également d'une communauté active qui partage de nombreux packages et ressources pour faciliter le développement de vos projets web.</p>    
                </article>
                <article>
                    <p>Pour plus d'informations pour savoir comment choisir entre Laravel et Symfony, voici <a href="https://grafikart.fr/tutoriels/laravel-symfony-866" target="_blank">le tutoriel vidéo de Grafikart</a>.</p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>