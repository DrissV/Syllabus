<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Symfony et Laravel - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#choix_symfony_laravel">Le choix entre Symfony et Laravel</a></li>
                        <li><a href="#developpement_SOLID">Le développement SOLID</a></li>
                        <li><a href="#intro_symfony">Introduction à Symfony</a></li>
                        <li><a href="#intro_laravel">Introduction à Laravel</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Symfony et Laravel :</h1>
                </article>
                <article>
                    <p>Pour ceux qui utilisent Visual Studio Code, vous devez installer les extensions "PHP Namespace Resolver" et "PHP Docblocker" pour PHP mais également "PHP Intelephense" et "PHP Getters & Setters" si besoin.</p>
                    <h2 id="choix_symfony_laravel">Le choix entre Symfony et Laravel :</h2>
                    <p>Ce choix dépend de plusieurs facteurs, notamment vos besoins spécifiques, vos compétences en programmation, la taille du projet et la communauté de soutien. Les deux frameworks sont populaires et largement utilisés dans le développement web en PHP, mais ils ont des approches et des fonctionnalités différentes. Voici un bref aperçu de chacun :</p>
                    <h3>Symfony :</h3>
                    <ul>
                        <li>
                            <p>Symfony est un framework PHP mature et robuste, qui suit les principes de développement SOLID et encourage une approche modulaire pour la construction d'application web.</p>
                        </li>
                        <li>
                            <p>Il est hautement personnalisable et modulaire, vous permettant de choisir les composants dont vous avez besoin pour votre projet spécifique.</p>
                        </li>
                        <li>
                            <p>Symphony est connu pour sa stabilité, sa documentaion détaillée et sa grande communauté de développeurs. Il est souvent préféré pour les projets d'entreprise de grande envergure.</p>
                        </li>
                        <li>
                            <p>Il met l'accent sur la réutilisation du code grâce à ses composants réutilisables, ce qui peut accélérer le processus de développement.</p>
                        </li>
                        <li>
                            <p>Cependant, il peyt être plus verbeux que Laravel, nécessitant parfois plus de code pour accomplir certaines tâches.</p>
                        </li>
                    </ul>
                    <h3>Laravel :</h3>
                    <ul>
                        <li>
                            <p>Laravel est également un framework PHP populaire qui se concentre sur la simplicité et l'élégance du code. Il suit le modèle MVC (Modèle-Vue-Contrôleur) et propose une syntaxe expressive et concise.</p>
                        </li>
                        <li>
                            <p>Il est livré avec de nombreuses fonctionnalités intégrées, telles que l'ORM Eloquent, la gestion des migrations de base de données, le système de routage convivial, l'intégration de la messagerie et bien plus encore.</p>
                        </li>
                        <li>
                            <p>Laravel est souvent choisi pour les projets de taille moyenne à grande, mais il est également adapté aux petites applications en raison de sa courbe d'apprentissage douce.</p>
                        </li>
                        <li>
                            <p>Il dispose d'une communauté active et de documentation complète, ce qui facilite la résolution des problèmes et l'apprentissage du framework.</p>
                        </li>
                        <li>
                            <p>Cependant, en raison de son approche "magique", il peut être moins prévisible et modulaire que Symfony.</p>
                        </li>
                    </ul>
                    <p>En fin de compte, le choix entre Symfony et Laravel dépend de vos préférences personnelles, de votre expérience en développement PHP et des besoins spécifiques de votre projet. Si vous appréciez la modularité, la personnalisation et la réutilisation du code, Symfont pourrait être un bon choix. Si vous recherchez la simplicité, l'efficacité et la rapidité de développement, Laravel pourrait mieux vous convenir.</p>
                    <p>Il est recommandé de prendre le temps de tester les deux frameworks, de lire leur documentation, de consulter des tutoriels (dans la suite, j'introduis chacun d'eux) et de participer aux communautés pour vous faire une idée plus précise de leurs avantages et de leurs inconvénients. Quel que soit votre choix, les deux frameworks offrent d'excellentes solutions pour le développement web en PHP.</p>
                </article>
                <article>
                    <h2 id="developpement_SOLID">Le développement SOLID :</h2>
                    <p>Le développement SOLID est un ensemble de principes fondamentaux de conception de logiciels qui visent à créer des systèmes logiciels flexibles, maintenables et évolutifs. Le terme SOLID est un acronyme qui représente les cinq principes individuels qui le composent. Ces principes ont été formulés par Robert C. Martin (également connu sous le nom de "Uncle Bob") et sont largement utilisés dans le développement logiciel orienté objet.</p>
                    <p>Voici une brève description de chaque principe SOLID :</p>
                    <ol>
                        <li>
                            <h3>Principe de Responsabilité Unique (Single Responsibility Principle - SRP) :</h3>
                            <p>Ce principe stipule qu'une classe (ou un module) ne devrait avoir qu'une seule raison de changer. En d'autres termes, une classe ne doit être responsable que d'une seule fonctionnalité ou tâche spécifique. Cela favorise la sépération des responsabilités et permet de rendre les classes plus cohérentes et plus facilement modifiables.</p>
                        </li>
                        <li>
                            <h3>Principe Ouvert/Fermé (Open/Closed Principle - OCP) :</h3>
                            <p>Le principe OCP indique qu'une classe doit être ouverte à l'extension (ajout de nouvelles fonctionnalités) mais fermée à la modification (le comportement existant ne doit être modifié). Plutôt que de modifier une classe existante, vous devriez étendre ses fonctionnalités en créant de nouvelles classes qui héritent des fonctionnalités de la classe de base.</p>
                        </li>
                        <li>
                            <h3>Principe de Substitution de Liskov (Liskov Substitution Principle - LSP) :</h3>
                            <p>Ce principe souligne que les objets d'une classe dérivée doivent pouvoir être substitués aux objets de la classe de base sans affecter la cohérence du programme. En d'autres termes, une classe dérivée doit être en mesure de remplacer sa classe de base sans provoquer d'effets indésirables ou d'erreurs.</p>
                        </li>
                        <li>
                            <h3>Principe de Ségrégation des Interfaces (Interface Segregation Principle - ISP) :</h3>
                            <p>L'ISP suggère que les interfaces clients ne devraient pas être forcées de dépendre des méthodes qu'elles n'utilisent pas. Plutôt que de créer de grandes interfaces contenant de nombreuses méthodes, vous devriez diviser les interfaces en petites interfaces spécifiques à chaque client.</p>
                        </li>
                        <li>
                            <h3>Principe d'Inversion des Dépendances (Dependency Inversion Principle - DIP) :</h3>
                            <p>Le DIP met l'accent sur le fait que les modules de haut niveau ne doivent pas dépendre des modules de bas niveau, mais des abstractions. Cela signifie que les détails d'implémentation doivent dépendre des abstractions plutôt que l'inverse. En utilisant l'inversion des dépendances, vous pouvez rendre vos applications plus flexibles et plus faciles à étendre.</p>
                        </li>
                    </ol>
                    <p>En suivant ces principes SOLID, les développeurs peuvent créer des codes plus robustes, éviter les dépendances rigides et faciliter la maintenance et l'évolution des applications. Les principes SOLID sont largement considérés comme les meilleures pratiques de conception orientée objet et sont utilisés pour créer des logiciels de haute quantité et faciles à maintenir.</p>
                </article>
                <article>
                    <h2 id="intro_symfony">Introduction au Framework PHP Symfony :</h2>
                    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Symfony. Symfony est un framework web puissant et flexible qui facilite le développement d'applications web évolutives et de haute qualité.</p>
                    <p>Vous trouverez la documentation complète de Symfony à l'adresse suivante : <a href="https://symfony.com/doc/current/index.html" target="_blank">https://symfony.com/doc/current/index.html</a>.</p>
                    <h3>Étape 1 : Installation de Symfony :</h3>
                    <p>Avant de commencer, assurez-vous que vous disposez d'une installation de PHP et du gestionnaire de dépendances Composer sur votre système.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Symfony en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project symfony/website-skeleton nom_du_projet</code></pre>
                            <p>Ou encore, si vous avez installé le Symfony CLI et que vous l'avez mis dans le PATH, vous pouvez faire la même chose avec la commande :</p>
<pre><code>symfony new nom_du_projet --full</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                            <p>Remarque : Au moment où j'écris ces lignes, l'option <span class="em">--full</span> est déprécié, mais il existe l'option <span class="em">--webapp</span> à la place.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                            <p>Dans un projet Symfony typique, vous trouverez généralement les dossiers suivants à la racine du projet :</p>
                            <ol>
                                <li>
                                    <p><span class="em">bin/</span> : Contient des scripts exécutables, tels que <span class="html">console</span>, qui est utilisé pour exécuté des commandes Symfony en ligne de commande.</p>
                                </li>
                                <li>
                                    <p><span class="em">config/</span> : Contient les fichiers de configuration de l'application, tels que <span class="html">config.yaml</span> (ou <span class="html">config.yml</span>), <span class="html">services.yaml</span>, <span class="html">routes.yaml</span>, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">migrations/</span> : Dans les projets Symfony qui utilisent Doctrine, un outil de mapping objet-relationnel (ORM) pour PHP, contient les fichiers de migration de base de données.</p>
                                </li>
                                <li>
                                    <p><span class="em">public/</span> : Contient les fichiers accessibles publiquement par le navigateur, tels que les fichiers CSS, JavaScript, les images, ainsi que le fichier <span class="em">index.php</span> qui est le point d'entrée de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">src/</span> : Contient le code source de l'application. C'est ici que vous trouverez généralement les contrôleurs, les entités, les formulaires, les services, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">templates/</span> : Contient les fichiers de templates Twig utilisés pour générer les vues de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">tests/</span> : Contient les tests unitaires et fonctionnels de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">translations/</span> : Contient les fichiers de traduction de l'application.</p>
                                </li>
                                <li>
                                    <p><span class="em">var/</span> : Contient les fichiers générés par l'application, tels que les caches, les logs, les sessions, etc.</p>
                                </li>
                                <li>
                                    <p><span class="em">vendor/</span> : Contient les dépendances installées via Composer, le gestionnaire de dépendances de PHP.</p>
                                </li>
                                <li>
                                    <p><span class="html">.env</span> : Fichier de configuration de l'environnement, utilisé pour définir des variables d'environnement telles que les paramètres de connexion à la base de données, les clés secrètes, etc.</p>
                                </li>
                                <li>
                                    <p><span class="html">composer.json</span> et <span class="html">composer.lock</span> : Fichiers utilisés par Composer pour gérer les dépendances du projet.</p>
                                </li>
                                <li>
                                    <p><span class="html">symfony.lock</span> : Fichier utilisé par Symfony pour verouiller les versions des composants Symfony installés.</p>
                                </li>
                            </ol>
                            <p>Ce sont les principaux dossiers et fichiers que vous trouverez dans un projet Symfony standard. Le contenu exact peut varier en fonction de la version de Symfony et des besoins spécifiques du projet.</p>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Symfony fournit un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>symfony server:start</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Créez le contrôleur nommé <span class="em">DefaultController</span> en utilisant la commande suivante :</p>
<pre><code>php bin/console make:controller DefaultController</code></pre>
                            <p>Ou encore on utilise la syntaxe suivante qui fait la même chose :</p>
<pre><code>symfony console make:controller DefaultController</code></pre>
                        </li>
                        <li>
                            <p>Ouvrez le fichier <span class="em">`src/Controller/DefaultController.php`</span> avec votre éditeur de code préféré et voici le code généré par la commande :</p>
<pre><code>&lt;?php

    namespace App\Controller;
    
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\Routing\Attribute\Route;
    
    class DefaultController extends AbstractController
    {
        #[Route('/default', name: 'app_default')]
        public function index(): Response
        {
            return $this->render('default/index.html.twig', [
                'controller_name' =&gt; 'DefaultController',
            ]);
        }
    }

?&gt;</code></pre>
                        </li>
                        <li>
                            <p>Créez une nouvelle action (méthode) dans le contrôleur pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette méthode à la classe DefaultController
#[Route('/', 'home.index', methods: ['GET'])]
public function homepage() : Response {
    return $this-&gt;render('pages/homepage.html.twig');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Création de la vue (template) :</h3>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`templates/pages/homepage.html.twig`</span> dans le répertoire du projet (si le dossier "pages" n'existe pas encore, créez-le).</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Symfony&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                        <li>
                            <p>Modifiez le template pour qu'il étend de celui de base dans le fichier <span class="em">`templates/base.html.twig`</span> :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Mon Projet Symfony{% endblock %}

{% block body %}
    &lt;h1&gt;Bienvenue sur Mon Projet Symfony !&lt;/h1&gt;
{% endblock %}</code></pre>
                        </li>
                        <li>
                            <p>Vous pouvez également modifier votre template de base pour intégrer Bootstrap : dans le block <span class="em">stylesheets</span>, on met <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" target="_blank">le lien CDN CSS de Bootstrap</a> et, dans le block <span class="em">javascripts</span>, <a href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" target="_blank">le lien CDN JS de Bootstrap</a>.</p>
                        </li>
                        <li>
                            <p>On peut également inclure un template Twig dans un autre comme par exemple :</p>
<pre><code>{% include "partials/_header.html.twig" %}</code></pre>
                            <p>Ça permet donc d'inclure le fichier partiel "header" pour avoir le même header sur toutes les pages.</p>
                        </li>
                    </ol>
                    <h3>Étape 5 : Définir la route :</h3>
                    <ol>
                        <li>
                            <p>Ouvrez le fichier <span class="em">`config/routes.yaml`</span> avec votre éditeur de code.</p>
                        </li>
                        <li>
                            <p>Définissez une nouvelle route pour accéder à la page d'accueil :</p>
<pre><code># Ajoutez cette ligne au fichier routes.yaml
homepage:
    path: /
    controller: App\Controller\DefaultController::homepage</code></pre>
                            <p>En Symfony 7 et plus, on a plus besoin de la définir car elle est directement écrit dans le contrôleur.</p>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenur sur Mon Projet Symfony !" sur la page d'accueil.</p>
                    <p>C'est tout ! Vous avez maintenant créé une application web simple en utilisant Symfony. Vous pouvez continuer à explorer la documentation officielle de Symfony pour découvrir plus de fonctionnalités et d'outils puissants offerts par ce framework.</p>
                    <p>En 2024, je rajoute de nouvelles étapes pour améliorer ce tutoriel sur Symfony. Voici les nouveautés :</p>
                    <h3>Étape 7 : Notre première entité :</h3>
                    <p>Dans le fichier <span class="em">.env</span>, on va modifier la variable <span class="html">DATABASE_URL</span> pour que ça correspond bien à notre base de données. Sa syntaxe sera :</p>
<pre><code>DATABASE_URL="mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7"</code></pre>
                    <p>On doit remplacer "db_user", "db_password" et "db_name" par les valeurs que l'on a définies. Si la base de données avec le nom stocké dans "db_name" n'est pas encore dans PHP My Admin, on peut la créer avec la commande suivante :</p>
<pre><code>php bin/console doctrine:database:create</code></pre>
                    <p>Ou on peut utiliser la commande abrégée :</p>
<pre><code>php bin/console d:d:c</code></pre>
                    <p>Remarque : Ça lance une erreur si la base de données existe déjà. On verra sûrement un peu plus tard comment faire pour la supprimer.</p>
                    <p>Dans un projet de recettes de cuisine, on a besoin d'une entité pour l'ingrédient qui sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui ne pourra pas excéder plus de 50 caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un prix au kg (par exemple 2 euros le kilo) qui ne pourra être inférieur à 1 et supérieur à 200. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>Un champ contenant la date de création qui doit être générée automatiquement une fois l'ingrédient créé.</p>
                        </li>
                    </ul>
                    <p>Pour créer cette entité, on utilise la commande :</p>
<pre><code>php bin/console make:entity Ingredient</code></pre>
                    <p>Cette commande crée deux fichiers : <span class="em">`src/Entity/Ingredient.php`</span> et <span class="em">`src/Repository/IngredientRepository.php`</span>.</p>
                    <p>Ensuite, il demande le nom des propriétés, son type, sa longueur et s'il est nullable en base de données. Par exemple, la propriété "name" est une "string" de "50" caractères "no" nullable.</p>
                    <p>Voici la classe entité "Ingredient.php" (je ne mettrais pas tous les getters et les setters) :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this->createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <p>Ensuite, comme avec Laravel, on va faire une migration pour migrer les entités dans la base de données avec la commande :</p>
<pre><code>php bin/console make:migration</code></pre>
                    <p>Dans cette migration, on a du SQL pur et dur. Symfony a interprété l'entité en SQL et donc a fait un <span class="html">CREATE TABLE</span> dans la fonction <span class="em">up</span> et un <span class="html">DROP TABLE</span> dans la fonction <span class="em">down</span>.</p>
                    <p>Maintenant on va migrer toutes les migrations vers la base de données avec la commande :</p>
<pre><code>php bin/console doctrine:migrations:migrate</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Si la base de données était vide, ça rajoute une table supplémentaire de la table "Ingredient" de notre migration qui est nommée "doctrine_migration_versions" et qui contient la version de la migration, la date d'exécution et le temps d'exécution en milisecondes.</p>
                    <p>Pour gérer les différentes contraintes des données, comme par exemple que le prix ne doit pas être inférieur à 1, on utilise des <span class="html">Assert</span>. Reprenons l'exemple de notre entité "Ingredient" :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\IngredientRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

    #[ORM\Entity(repositoryClass: IngredientRepository::class)]
    #[UniqueEntity('name')]
    class Ingredient
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'float')]
        #[Assert\NotNull()]
        #[Assert\Positive()]
        #[Assert\LessThan(200)]
        private float $price;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        public function __construct()
        {
            $this->createdAt = new \DateTimeImmutable();
        }

        public function __toString()
        {
            return $this-&gt;name;
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;name;
        }

        public function setName(string name): self
        {
            $this-&gt;name = $name;
            
            return $this;
        }

    }

?&gt;</code></pre>
                    <h3>Étape 8 : Création des Fixtures :</h3>
                    <p>Dans la suite de ce tutoriel, on va créer des fixtures qui permettent de nous générer un jeu de fausses données comme un Faker.</p>
                    <p>Pour faire cela, on va installer les packages en développement :</p>
<pre><code>composer require --dev orm-fixtures</code></pre>
                    <p>Ainsi que la commande :</p>
<pre><code>composer require --dev fakerphp/faker</code></pre>
                    <p>Ces commandes ont créer le dossier <span class="em">`src\DataFixtures`</span> et dedans le fichier <span class="em">AppFixtures</span> avec le contenu que l'on va modifier comme cela :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $manager-&gt;persist($ingredient);
            }

            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Ensuite, on va les charger avec la commande :</p>
<pre><code>php bin/console doctrine:fixtures:load</code></pre>
                    <p>Ou encore avec la commande abrégée :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <h3>Étape 9 : CRUD sur la table "Ingredient" :</h3>
                    <p>Maintenant, on va enfin faire des CRUD sur la table "Ingredient". D'abord, on va afficher la liste des ingrédients.</p>
                    <p>Premièrement, on va créer un nouveau contrôleur "IngredientController" avec la commande :</p>
<pre><code>php bin/console make:controller IngredientController</code></pre>
                    <p>Remarque : Ça va créer le fichier <span class="em">`templates/ingredient/index.html.twig`</span>, mais, pour faire un peu le ménage, on va créer un dossier "pages" et donc on va y insérer dedans le dossier "ingredient".</p>
                    <h4>Lister tous les ingrédients :</h4>
                    <p>Modifions la fonction "index" de notre contrôleur fraîchement créé :</p>
<pre><code>#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository) : Response
{
    $ingredients = $repository->findAll();
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>On va modifier le fichier TWIG comme ceci :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Mes ingréidents{% endblock %}

{% block body %}
    &lt;div class="container mt-4"&gt;
        &lt;h1&gt;Mes ingrédients&lt;/h1&gt;

        &lt;table class="table table-hover"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th scope="col"&gt;Numéro&lt;/th&gt;
                    &lt;th scope="col"&gt;Nom&lt;/th&gt;
                    &lt;th scope="col"&gt;Prix&lt;/th&gt;
                    &lt;th scope="col"&gt;Date de création&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                {% for ingredient in ingredients %}
                    &lt;tr class="table-primary"&gt;
                        &lt;th scope="row"&gt;{{ ingredient.id }}&lt;/th&gt;
                        &lt;td&gt;{{ ingredient.name }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.price }}&lt;/td&gt;
                        &lt;td&gt;{{ ingredient.createdAt|date('d/m/Y') }}&lt;/td&gt;
                    &lt;/tr&gt;
                {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
        
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour la pagination dans la page, on va utiliser le bundle "KnpPaginatorBundle" en l'instalalnt avec la commande :</p>
<pre><code>composer require knplabs/knp-paginator-bundle</code></pre>
                    <p>On va créer le fichier <span class="em">`config/packages/knp_paginator.yaml`</span> avec le contenu suivant :</p>
<pre><code>knp_paginator:
    page_range: 5                       # number of links shown in the pagination menu (e.g: you have 10 pages, a page_range of 3, on the 5th page you'll see links to page 4, 5, 6)
    default_options:
        page_name: page                 # page query parameter name
        sort_field_name: sort           # sort field query parameter name
        sort_direction_name: direction  # sort direction query parameter name
        distinct: true                  # ensure distinct results, useful when ORM queries are using GROUP BY statements
        filter_field_name: filterField  # filter field query parameter name
        filter_value_name: filterValue  # filter value query parameter name
    template:
        pagination: '@KnpPaginator/Pagination/bootstrap_v5_pagination.html.twig'     # sliding pagination controls template
        rel_links: '@KnpPaginator/Pagination/rel_links.html.twig'     # &lt;link rel=...&gt; tags template
        sortable: '@KnpPaginator/Pagination/sortable_link.html.twig' # sort link template
        filtration: '@KnpPaginator/Pagination/filtration.html.twig'  # filters template</code></pre>
                    <p>Modifions notre fonction "index" de notre cotrôleur pour qu'elle prenne en compte la pagination :</p>
<pre><code>use Knp\Component\Pager\PaginatorInterface;
use Symfony\Component\HttpFoundation\Request;

/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository->findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10    
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>On va modifier également le fichier TWIG en ajoutant ceci :</p>
<pre><code>&lt;div class="count mt-4"&gt;
    &lt;p&gt;Il y a {{ ingredients.getTotalItemCount }} ingrédients au total&lt;/p&gt;
&lt;/div&gt;
    
&lt;div class="navigation d-flex justify-content-center mt-4"&gt;
    {{ knp_pagination_render(ingredients) }}
&lt;/div&gt;</code></pre>
                    <p>On peut faire un <span class="html">{% if not ingredients.items is same as([]) %}</span> pour vérifier que la liste n'est pas vide.</p>
                    <h4>Créer un nouvel ingrédient :</h4>
                    <p>Pour la création d'un nouvel ingrédient, on va créer un nouveau formulaire "IngredientType" avec l'entité "Ingredient" via la commande :</p>
<pre><code>php bin/console make:form</code></pre>
                    <p>Ça permet de créer le fichier <span class="em">`src/Form/IngredientType.php`</span> avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\Form;

    use App\Entity\Ingredient;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\Extension\Core\Type\MoneyType;
    use Symfony\Component\Form\Extension\Core\Type\SubmitType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\Form\OptionsResolver;

    use Symfony\Component\Validator\Constraints as Assert;

    class IngredientType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder
                -&gt;add('name', TextType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                        'minlength' =&gt; '2',
                        'maxlength' =&gt; '50'
                    ],
                    'label' =&gt; 'Nom',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                        new Assert\NotBlank()
                    ]
                ])
                -&gt;add('price', MoneyType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'form-control',
                    ],
                    'label' =&gt; 'Prix',
                    'label_attr' =&gt; [
                        'class' =&gt; 'form-label mt-4'
                    ],
                    'constraints' =&gt; [
                        new Assert\Positive(),
                        new Assert\LessThan(200),
                        new Assert\NotNull()
                    ]
                ])
                -&gt;add('submit', SubmitType::class, [
                    'attr' =&gt; [
                        'class' =&gt; 'btn btn-primary mt-4'
                    ],
                    'label' =&gt; 'Créer mon ingrédient'
                ]);
        }

        public function configureOptions(OptionsResolver $resolver): void
        {
            $resolver-&gt;setDefaults([
                'data_class' =&gt; Ingredient::class,
            ]);
        }
    }

?&gt;</code></pre>
                    <p>Dans notre IngredientController, on va créer une nouvelle fonction "new" :</p>
<pre><code>/**
*
* This controller show a form which create an ingredient
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/nouveau', 'ingredient.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $ingredient = new Ingredient();
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été créé avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va également créer le nouveau template <span class="em">`templates/ingredient/new.html.twig`</span> avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour ajouter des messages d'erreur, on va modifier le code précédent pour donner ceci :</p>
<pre><code>{% extends "base.html.twig" %}

{% block body %}
    &lt;div class="container"&gt;
    
    &lt;h1 class="mt-4"&gt;Création d'un ingrédient&lt;/h1&gt;

    {{ form_start(form) }}
        
        &lt;div class="form-group"&gt;
            {{ form_label(form.name) }}
            {{ form_widget(form.name) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.name) }}
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="form-group"&gt;
            {{ form_label(form.price) }}
            {{ form_widget(form.price) }}
            &lt;div class="form-error"&gt;
                {{ form_errors(form.price) }}
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="form-group"&gt;
            {{ form_row(form.submit) }}
        &lt;/div&gt;

        {{ form_end(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>On va afficher un message FLASH dans l'index pour dire que la création d'un ingrédient a eu un statut de succès ainsi qu'un lien qui permet d'accéder à la page de création d'un nouvel ingrédient. Voici le code à rajouter :</p>
<pre><code>&lt;a href="{{ path('ingredient.new') }} class="btn btn-primary"&gt;Créer un ingrédient&lt;/a&gt;

{# read and display just one flash message type #}
{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}</code></pre>
                    <p>Dans la navbar, on oublie pas de rajouter un lien vers "ingredient.index" pour accéder plus facilement à la liste des ingrédients.</p>
                    <h4>Éditer un ingrédient :</h4>
                    <p>Dans notre contrôleur, on va rajouter une nouvelle fonction pour pouvoir éditer un ingrédient :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param IngredientRepository $repository
* @param int $id
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(IngredientRepository $repository, int $id, Request $request, EntityManagerInterface $manager) : Response
{
    $ingredient = $repository-&gt;findBy(['id' =&gt; $id]);
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Ça c'est ce que la plupart des gens font d'habitude, mais nous on va utiliser un <span class="html">@ParamConverter</span> comme ceci :</p>
<pre><code>/**
*
* This controller show a form which edit an ingredient
*
* @param Ingredient $ingredient
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/ingredient/edition/{id}', 'ingredient.edit', methods: ['GET', 'POST'])]
public function edit(Ingredient $ingredient, Request $request, Entity $manager) : Response
{
    $form = $this-&gt;createForm(IngredientType::class, $ingredient);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $ingredient = $form-&gt;getData();
        
        $manager-&gt;persist($ingredient);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre ingrédient a été modifié avec succès !');

        return $this-&gt;redirectToRoute('ingredient.index');
    }

    return $this-&gt;render('pages/ingredient/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Ensuite, dans le "edit.html.twig", on va copier le contenu du "new.html.twig" et modifier "Création" par "Modification".</p>
                    <h4>Supprimer un ingrédient :</h4>
                    <p>Pour le delete, on rajoute une nouvelle fonction "delete" dans le contrôleur :</p>
<pre><code>#[Route('/ingredient/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Ingredient $ingredient) : Response
{
    $manager-&gt;remove($ingredient);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre ingrédient a été supprimé avec succès !');

    return $this-&gt;redirectToRoute('ingredient.index');
}</code></pre>
                    <p>Dans la liste des ingrédients, on va rajouter deux nouvelles colonnes : une pour l'édition et l'autre pour la suppression :</p>
<pre><code>&lt;th scope="col"&gt;Édition&lt;/th&gt;
&lt;th scope="col"&gt;Suppression&lt;/th&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.edit', { id: ingredient.id }) }}" class="btn btn-info"&gt;Modifier&lt;/a&gt;
&lt;/td&gt;

&lt;td&gt;
    &lt;a href="{{ path('ingredient.delete', { id: ingredient.id }) }}" class="btn btn-danger"&gt;Supprimer&lt;/a&gt;
&lt;/td&gt;</code></pre>
                    <h3>Étape 10 : CRUD pour la table "Recipe" :</h3>
                    <p>Maintenant, on va faire le CRUD pour la table "Recipe". Pour information, une recette sera définie par :</p>
                    <ul>
                        <li>
                            <p>Un nom qui sera obligatoire et ne pourra pas être vide, il ne pourra également pas excéder plus de 5à caractères et devra faire au minimum 2 caractères.</p>
                        </li>
                        <li>
                            <p>Un temps (en minutes) qui n'est pas obligatoire. S'il est rempli, il ne pourra pas être inférieur à une minute et ne pourra pas dépasser les 24h.</p>
                        </li>
                        <li>
                            <p>Un nombre de personnes qui n'est pas obligatoire. S'il est rempli, il devra être inférieur à 50.</p>
                        </li>
                        <li>
                            <p>Une difficulté n'est pas obligatoire. Si elle esy rentrée, elle sera comprise entre 1 et 5.</p>
                        </li>
                        <li>
                            <p>Une liste d'étapes à suivre/description qui sera obligatoire et ne pourra pas être vide.</p>
                        </li>
                        <li>
                            <p>Un prix qui ne sera pas obligatoire. S'il est renseigné, le prix ne pourra pas être inférieur à 0 et supérieur à 1000. Le prix pourra contenir des décimales.</p>
                        </li>
                        <li>
                            <p>La possibilité de définir la recette comme étant favorite ou non.</p>
                        </li>
                        <li>
                            <p>Une date de création.</p>
                        </li>
                        <li>
                            <p>Une date de mise à jour.</p>
                        </li>
                        <li>
                            <p>Une liste d'ingrédients.</p>
                        </li>
                    </ul>
                    <p>Remarque : La date de création et la date de mise à jour seront générées automatiquement une fois la recette créée et/ou modifiée.</p>
                    <p>Premièrement, on doit créer l'entité "Recipe" avec les propriétés "name" de type "string" non nullable, "time" de type "integer" nullable, "nbPeople" de type "integer" nullable, "difficulty" de type "integer" nullable, "description" de type "text" non nullable, "price" de type "float" nullable, "isFavorite" de type "boolean" non nullable, "createdAt" de type "datetime_immutable" non nullable, "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Pour la propriété "ingredients" qui définit la liste des ingrédients, on va dire qu'il est de type "relation" lié à l'entité "Ingredient" dont le type de relation est "ManyToMany" et on veut pas récupérer depuis les ingrédients les recettes qui ont cet ingrédient.</p>
                    <p>Voici donc le code généré par la commande <span class="html">php bin/console make:entity Recipe</span> sans tous les getters et les setters et qu'on va modifier en ajoutant les <span class="em">Assert</span> :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\RecipeRepository;
    use Doctrine\Common\Collections\ArrayCollection;
    use Doctrine\Common\Collections\Collection;
    use Doctrine\ORM\Mapping as ORM;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('name')]
    #[ORM\HasLifecycleCallbacks]
    #[ORM\Entity(repositoryClass: RecipeRepository::class)]
    class Recipe
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 50)]
        #[Assert\NotBlank()]
        #[Assert\Length(min: 2, max: 50)]
        private string $name;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1441)]
        private ?int $time;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(51)]
        private ?int $nbPeople;

        #[ORM\Column(type: 'integer', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(6)]
        private ?int $difficulty;

        #[ORM\Column(type: 'text')]
        #[Assert\NotBlank()]
        private string $description;

        #[ORM\Column(type: 'float', nullable: true)]
        #[Assert\Positive()]
        #[Assert\LessThan(1001)]
        private ?float $price;

        #[ORM\Column(type: 'boolean')]
        private bool $isFavorite;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $createdAt;

        #[ORM\Column(type: 'datetime_immutable')]
        #[Assert\NotNull()]
        private \DateTimeImmutable $updatedAt;

        #[ORM\ManyToMany(targetEntity: Ingredient::class)]
        private $ingredients;

        public function __construct() {
            $this-&gt;ingredients = new ArrayCollection();
            $this-&gt;createdAt = new \DateTimeImmutable();
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        #[ORM\PrePersist]
        public function setUpdatedAtValue()
        {
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        public function getName(): ?string
        {
            return $this-&gt;string;
        }

        public function setName(string $name) : self
        {
            $this-&gt;name = $name;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Dans ma solution, je vais d'abord "DROP" toute la base de données avec la commande :</p>
<pre><code>php bin/console d:d:d --force</code></pre>
                    <p>Avant de la recréer avec la commande :</p>
<pre><code>php bin/console d:d:c</code></pre>
                    <p>Afin de créer une nouvelle migration avec la commande :</p>
<pre><code>php bin/console make:migration</code></pre>
                    <p>Et de migrer dans la base de données toutes les migrations avec la commande :</p>
<pre><code>php bin/console d:m:m</code></pre>
                    <p>Deuxièmement, on va créer les fixtures en modifiant le fichier <span class="em">`src\DataFixtures\AppFixtures.php`</span> comme ceci :</p>
<pre><code>&lt;?php

    namespace App\DataFixtures;

    use Faker\Factory;
    use Faker\Generator;
    use App\Entity\Ingredient;
    use App\Entity\Recipe;
    use Doctrine\Bundle\FixturesBundle\Fixture;
    use Doctrine\Persistence\ObjectManager;

    class AppFixtures extends Fixture
    {
        /**
        * @var Generator
        */
        private Generator $faker;

        public function __construct()
        {
            $this-&gt;faker = Factory::create('fr_FR');
        }

        public function load(ObjectManager $manager): void
        {
            // Ingredients
            $ingredients = [];
            for ($i = 0; $i &lt; 50; $i++) {
                $ingredient = new Ingredient();
                $ingredient-&gt;setName($this-&gt;faker-&gt;word())-&gt;setPrice(mt_rand(0, 100));

                $ingredients[] = $ingredient;
                $manager-&gt;persist($ingredient);
            }

            // Recipes
            $recipes = [];
            for ($j = 0; $j &lt; 25; $j++) {
                $recipe = new Recipe();
                $recipe-&gt;setName($this-&gt;faker-&gt;word())
                    -&gt;setTime(mt_rand(0, 1) == 1 ? mt_rand(1, 1440) : null)
                    -&gt;setNbPeople(mt_rand(0, 1) == 1 ? mt_rand(1, 50) : null)
                    -&gt;setDifiiculty(mt_rand(0, 1) == 1 ? mt_rand(1, 5) : null)
                    -&gt;setDescription($this-&gt;faker-&gt;text(300))
                    -&gt;setPrice(mt_rand(0, 1) == 1 ? mt_rand(1, 1000) : null)
                    -&gt;setIsFavorite(mt_rand(0, 1) == 1);
                
                for ($k = 0; $k &lt; mt_rand(5, 15); $k++) {
                    $recipe-&gt;addIngredient($ingredients[array_rand($ingredients)]);
                }
            }

            $recipes[] = $recipe;
            $manager-&gt;flush();
        }
    }

?&gt;</code></pre>
                    <p>Et on va pouvoir charger les nouvelles données factives avec la commande :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <p>Troisièmement, on va commencer le CRUD par lister toutes les recettes. Pour cela, on va créer le contrôleur "RecipeController" avec la commande :</p>
<pre><code>php bin/console make:controller RecipeController</code></pre>
                    <p>Remarque : On oublie pas de déplacer le dossier templates "recipe" dans le dossier "pages" et d'ajouter un lien vers cette page dans la navbar.</p>
                    <p>Maintenant, modifions la fonction "index" du contrôleur comme ceci :</p>
<pre><code>/**
* This controller display all recipes
*
* @param RecipeRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/recette', name: 'recipe.index', methods: ['GET'])]
public function index(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findAll(),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe/index.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>Quatrièmement, on va créer un nouveau formulaire pour la création d'une recette en rajoutant déjà dans le contrôleur la fonction "new" :</p>
<pre><code>#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(): Response
{
    return $this-&gt;render('pages/recipe/new.html.twig');
}</code></pre>
                    <p>Cinquièmement, on va créer le formulaire "RecipeType" lié à l'entité "Recipe" avec la commande suivante :</p>
<pre><code>php bin/console make:form RecipeType Recipe</code></pre>
                    <p>On va améliorer sa fonction "buildForm" en ajoutant par exemple un submit :</p>
<pre><code>public function buildForm(FormBuilderInterface $builder, array $options): void
{
    $builder
        -&gt;add('name', TextType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'minlength' =&gt; '2',
                'maxlength' =&gt; '50'
            ],
            'label' =&gt; 'Nom',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50]),
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('time', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 1440
            ],
            'required' =&gt; false,
            'label' =&gt; 'Temps (en minutes)',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(1441)
            ]
        ])
        -&gt;add('nbPeople', IntegerType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
                'min' =&gt; 1,
                'max' =&gt; 50
            ],
            'required' =&gt; false,
            'label' =&gt; 'Nombre de personnes',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(51)
            ]
        ])
        -&gt;add('difficulty', RangeType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-range',
                'min' =&gt; 1,
                'max' =&gt; 5
            ],
            'required' =&gt; false,
            'label' =&gt; 'Difficulté',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Possitive(),
                new Assert\LessThan(6)
            ]
        ])
        -&gt;add('description', TextareaType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Description',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\NotBlank()
            ]
        ])
        -&gt;add('price', MoneyType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-control',
            ],
            'required' =&gt; false,
            'label' =&gt; 'Prix',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'constraints' =&gt; [
                new Assert\Positive(),
                new Assert\LessThan(1001),
                new Assert\NotNull()
            ]
        ])
        -&gt;add('isFavorite', CheckboxType::class, [
            'attr' =&gt; [
                'class' =&gt; 'form-check-input',
            ],
            'label' =&gt; 'Favoris ?',
            'label_attr' =&gt; [
                'class' =&gt; 'form-check-label'
            ],
            'constraints' =&gt; [
                new Assert\NotNull()
            ]
        ])
        -&gt;add('ingredients', EntityType::class, [
            'class' =&gt; Ingredient::class,
            'query_builder' =&gt; function(IngredientRepository $r) {
                return $r-&gt;createQueryBuilder('i')
                    -&gt;orderBy('i.name', 'ASC');
            },
            'label' =&gt; 'Les ingrédients',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ],
            'choice_label' =&gt; 'name',
            'multiple' =&gt; true,
            'expanded' =&gt; true
        ])
        -&gt;add('submit', SubmitType::class, [
            'attr' =&gt; [
                'class' =&gt; 'btn btn-primary mt-4'
            ],
            'label' =&gt; 'Créer ma recette'
        ]);
}</code></pre>
                    <p>On va modifier la fonction "new" précédemment créée :</p>
<pre><code>/**
* This controller allow us to create a new recipe
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/creation', 'recipe.new', methods: ['GET', 'POST'])]
public function new(Request $request, EntityManagerInterface $manager): Response
{
    $recipe = new Recipe();
    $form = $this-&gt;createForm(RecipeType::class, $recipe);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été créée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/new.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Sixièmement, on va créer dans le contrôleur la fonction "edit" :</p>
<pre><code>/**
* This controller allow us to edit a recipe
*
* @param Recipe $recipe
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/recette/edition/{id}', 'recipe.edit', methods: ['GET', 'POST'])]
public function edit(Recipe $recipe, Request $request, EntityManagerInterface $manager): Response
{
    $form = $this-&gt;createForm(RecipeType::class, $recipe);
    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $recipe = $form-&gt;getData();

        $manager-&gt;persist($recipe);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre recette a été modifiée avec succès !');

        return $this-&gt;redirectToRoute('recipe.index');
    }

    return $this-&gt;render('pages/recipe/edit.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>Septièmement, on rajoute également la méthode "delete" dans le contrôleur :</p>
<pre><code>/**
* This controller allows us to delete a recipe
*
* @param EntityManagerInterface $manager
* @param Recipe $recipe
* @return Response
*/
#[Route('/recette/suppression/{id}', 'ingredient.delete', methods: ['GET'])]
public function delete(EntityManagerInterface $manager, Recipe $recipe): Response
{
    $manager-&gt;remove($recipe);
    $manager-&gt;flush();

    $this-&gt;addFlash('success', 'Votre recette a été supprimée avec succès !');

    return $this-&gt;redirectToRoute('recipe.index');
}</code></pre>
                    <h3>Étape 11 : Sécurité & compte utilisateur :</h3>
                    <p>Un compte utilisateur sera défini par :</p>
                    <ul>
                        <li>
                            <p>Un nom et un prénom qui seront obligatoires. Ils devront faire entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Un pseudo qui sera facultatif et, s'il est renseigné, il devra également entre 2 et 50 caractères.</p>
                        </li>
                        <li>
                            <p>Une adresse email qui sera unique et servira d'identifiant lors de la connexion.</p>
                        </li>
                        <li>
                            <p>Un mot de passe qui sera encodé en base de données pour des questions de sécurité.</p>
                        </li>
                        <li>
                            <p>Une date de création qui sera générée seule.</p>
                        </li>
                        <li>
                            <p>Une date de modificaton sera également générée seule lors de la modification du profil utilisateur.</p>
                        </li>
                    </ul>
                    <p>Pour cela, on utilise le bundle "Security" déjà installé et qui a généré le fichier <span class="em">`config\packages\security.yaml`</span>. Dans Symfony, il y a une façon très simple de générer une classe utilisateur pour gérer la sécurité avec la commande :</p>
<pre><code>php bin/console make:user</code></pre>
                    <p>On nomme notre classe utilisateur "User", on la stocke dans la DB via Doctrine, on dit que la propriété "email" doit être unique et on a besoin de hasher les mots de passe. Voici le code généré (sans les getters et les setters) et que je modifie un peu :</p>
<pre><code>&lt;?php

    namespace App\Entity;

    use App\Repository\UserRepository;
    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
    use Symfony\Component\Security\Core\User\UserInterface;

    use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
    use Symfony\Component\Validator\Constraints as Assert;

    #[UniqueEntity('email')]
    #[ORM\Entity(repositoryClass: UserRepository::class)]
    class User implements UserInterface, PasswordAuthenticatedUserInterface
    {
        #[ORM\Id]
        #[ORM\GeneratedValue]
        #[ORM\Column(type: 'integer')]
        private ?int $id;

        #[ORM\Column(type: 'string', length: 180, unique: true)]
        #[Assert\Email()]
        #[Assert\Length(min: 2, max: 180)]
        private string $email;

        #[ORM\Column(type; 'json')]
        #[Assert\NotNull()]
        private array $roles = [];

        private ?string $plainPassword = null;

        #[ORM\Column(type: 'string')]
        #[Assert\NotBlank()]
        private string $password = 'password';

        public function __construct()
        {

        }

        public function getId(): ?int
        {
            return $this-&gt;id;
        }

        /**
        * A visual identifier that represents this user
        *
        * @see UserInterface
        */
        public function getUserIdentifier(): string
        {
            return (string) $this-&gt;email;
        }

        /**
        * @see UserInterface
        */
        public function getRoles(): array
        {
            $roles = $this-&gt;roles;
            // guarantee every user at least has ROLE_USER
            $roles[] = 'ROLE_USER';

            return array_unique($roles);
        }

        public function setRoles(array $roles): self
        {
            $this-&gt;roles = $roles;

            return $this;
        }
    }

?&gt;</code></pre>
                    <p>Avant de créer une migration pour cette entité et de la migrer, il faut modifier l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:entity User</code></pre>
                    <p>On va rajouter les propriétés "fullName" de taille "50" non nullable, "pseudo" de taille "50" nullable, "createdAt" de type "datetime_immutable" non nullable et "updatedAt" de type "datetime_immutable" non nullable.</p>
                    <p>Donc, avec la commande `<span class="html">php bin/console make:migration</span>` on crée la migration et avec `<span class="em">php bin/console d:m:m</span>` pour la migrer.</p>
                    <p>Ensuite, dans le fichier "<span class="em">security.yaml</span>", on va rajouter le provider comme suit :</p>
<pre><code>providers:
        # used to reload user from session & other features (e.g. switch user)
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email</code></pre>
                    <p>Pour hasher le mot de passe, on va définir un <span class="em">password_hashers</span> s'il n'est pas défini dans le fichier <span class="em">security.yaml</span> :</p>
<pre><code>password_hashers:
    Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: "auto"</code></pre>
                    <p>Dans notre fixture, on va créer des utilisateurs fictifs :</p>
<pre><code>// Users
$users = [];
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPassword('password');

    $users[] = $user;
    $manager-&gt;persist($user);
}</code></pre>
                    <p>On charge les nouveaux utilisateurs avec la commande :</p>
<pre><code>php bin/console d:f:l</code></pre>
                    <p>Ici, on peut voir que le mot de passe n'est pas encore crypté dans la base de données. Pour faire cela, on rajoute une propriété dans la classe "AppFixtures" et on modifie la fonction "load" :</p>
<pre><code>private UserPasswordHasherInterface $hasher;</code></pre>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER']);
    
    $hashPassword = $this-&gt;hasher-&gt;hashPassword($user, 'password');

    $user-&gt;setPassword($hashPassword);

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Le problème avec cette solution, c'est que n'importe où on doit toujours demander que le mot de passe soit hashé.</p>
                    <p>On voudrait exporter la logique de hashage du mot de passe à l'extérieur. Pour ce faire, on va utiliser les <span class="html">Entity Listeners</span> de Symfony qui, comme leur nom l'indique, vont écouter ce qui se passe au niveau des entités et faire plusieurs actions. On va de nouveau modifier la fonction "load" :</p>
<pre><code>// Users
for ($i = 0; $i &lt; 10; $i++) {
    $user = new User();
    $user-&gt;setFullName($this-&gt;faker-&gt;name())
        -&gt;setPseudo(mt_rand(0, 1) === 1 ? $this-&gt;faker-&gt;firstName() : null)
        -&gt;setEmail($this-&gt;faker-&gt;email())
        -&gt;setRoles(['ROLE_USER'])
        -&gt;setPlainPassword('password');

    $manager-&gt;persist($user);
}</code></pre>
                    <p>Ensuite, on va rajouter un nouveau service dans le fichier <span class="em">`config\services.yaml`</span> :</p>
<pre><code>App\EntityListener\
    resource: "../src/EntityListener/"
    tags: ["doctrine.orm.entity_listener"]
</code></pre>
                    <p>Avant la déclaration de la classe de l'entité "User", on rajoute la ligne suivante :</p>
<pre><code>#[ORM\EntityListeners(['App\EntityListener\UserListener'])]</code></pre>
                    <p>Dans le dossier "src", on va créer un dossier "EntityListener" et y insérer le fichier "UserListener.php" avec le contenu suivant :</p>
<pre><code>&lt;?php

    namespace App\EntityListener;

    use App\Entity\User;
    use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;

    class UserListener
    {

        private UserPasswordHasherInterface $hasher;

        public function __construct(UserPasswordHasherInterface $hasher)
        {
            $this-&gt;hasher = $hasher;
        }

        public function prePersist(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        public function preUpdate(User $user)
        {
            $this-&gt;encodePassword($user);
        }

        /**
        * Encode password based on plain password
        *
        * @param User $user
        * @return void
        */
        public function encodePassword(User $user)
        {
            if (is_null($user-&gt;getPlainPassword())) {
                return;
            }

            $user-&gt;setPassword(
                $this-&gt;hasher-&gt;hashPassword($user, $user-&gt;getPlainPassword())
            );

            $user-&gt;setPlainPassword(null);
        }
    }

?&gt;</code></pre>
                    <p>Remarques : Maintenant qu'on a le "$hasher" dans le "UserListener", on peut le supprimer dans les fixtures.</p>
                    <h3>Étape 12 : Firewall et formulaire de connexion :</h3>
                    <p>La section "Firewall" est la section la plus importante en terme de sécurité. Pour faire simple, le firewall sert à définir les parties de notre application qui sont sécurisées et comment les utilisateurs vont avoir la possibilité de s'authentifier (par exemple que ce soit via un formulaire de connexion ou par rapport à un token si on fait une API, etc).</p>
                    <p>On a deux firewalls : le "dev" et le "main". Le "dev" qui est un faux Firewall et le "main" qui de base n'est pas très sécurisé.</p>
                    <p>Maintenant, on va créer un nouveau contrôleur pour afficher la page de connexion que l'on nomme "SecurityController" avec la commande :</p>
<pre><code>php bin/console make:controller SecurityController</code></pre>
                    <p>Remarques : on déplace le dossier "templates\security" dans le dossier "templates\pages" et on renomme le fichier "index.html.twig" par "login.html.twig". Modifions la fonction "index" de ce nouveau contrôleur pour que ça devienne ceci :</p>
<pre><code>use Symfony\Component\Security\Http\authentification\AuthenticationUtils;

/**
* This controller allow us to login
*
* @param AuthenticationUtils $authenticationUtils
* @return Response
*/
#[Route('/connexion', name: 'security.login', methods: ['GET', 'POST'])]
public function login(AuthenticationUtils $authenticationUtils): Response
{
    $lastUsername = $authenticationUtils-&gt;getLastUsername();
    $error = $authenticationUtils-&gt;getLastAuthenticationError();

    return $this-&gt;render('pages/security/login.html.twig', [
        'last_username' =&gt; $lastUsername,
        'error' =&gt; $error
    ]);
}</code></pre>
                    <p>On va rajouter les lignes suivantes dans la configuration de notre "main" Firewall :</p>
<pre><code>form_login:
    login_path: security.login
    check_path: security.login</code></pre>
                    <p>On va ensuite créer la structure de notre formulaire de connexion dans "login.html.twig" :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Connexion{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de connexion&lt;/h1&gt;

        {% if error %}
            &lt;div class="alert alert-danger"&gt;
                {{ error.messageKey|trans(error.messageData, 'security') }}
            &lt;/div&gt;
        {% endif %}

        &lt;form action="{{ path('security.login') }}" method="post"&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="username" class="form-label mt-4"&gt;Adresse email&lt;/label&gt;
                &lt;input type="email" class="form-control" id="username" name="_username" value="{{ last_username }}"&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password" class="form-label mt-4"&gt;Mot de passe&lt;/label&gt;
                &lt;input type="password" class="form-control" id="password" name="_password"&gt;
            &lt;/div&gt;

            &lt;button type="submit" class="btn btn-primary mt-4"&gt;
                Se connecter
            &lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire fonctionne bien ! Passons vite fait à la déconnexion. Pour ce faire, on crée la fonction logout dans notre contrôleur et on rajoute les lignes suivantes dans le "main" Firewall :</p>
<pre><code>/**
* This controller allow us to logout
*
* @return void
*/
#[Route('/deconnexion', 'security.logout', methods: ['GET'])]
public function logout()
{
    // Nothing to do here...
}</code></pre>
<pre><code>logout:
    path: security.logout</code></pre>
                    <h3>Étape 13 : Formulaire d'inscription :</h3>
                    <p>D'abord, on va créer le formulaire "RegistrationType" basé sur l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form RegistrationType User</code></pre>
                    <p>Ça génèrera le code suivant dans la fonction "buildForm" qu'on va modifier :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'label' =&gt; 'Nom / Prénom',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\NotBlank(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('email', EmailType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '180',
        ],
        'label' =&gt; 'Adresse email',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Email(),
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 180])
        ]
    ])
    -&gt;add('plainPassword', RepeatedType::class, [
        'type' =&gt; PasswordType::class,
        'first_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'second_options' =&gt; [
            'attr' =&gt; [
                'class' =&gt; 'form-control'
            ],
            'label' =&gt; 'Confirmation du mot de passe',
            'label_attr' =&gt; [
                'class' =&gt; 'form-label mt-4'
            ]
        ],
        'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !'
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'S\'inscrire'
    ]);</code></pre>
                    <p>Dans notre "SecurityController", on rajoute la fonction "registration" :</p>
<pre><code>/**
* This controller allow us to RegistrationType
*
* @param Request $request
* @param EntityManagerInterface $manager
* @return Response
*/
#[Route('/inscription', 'security.registration', methods: ['GET', 'POST'])]
public function registration(Request $request, EntityManagerInterface $manager): Response
{
    $user = new User();
    $user-&gt;setRoles(['ROLE_USER']);

    $form = $this-&gt;createForm(RegistrationType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $user = $form-&gt;getData();

        $manager-&gt;persist($user);
        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre compte a bien été créé !');

        return $this-&gt;redirectToRoute('security.login');
    }

    return $this-&gt;render('pages/security/registration.html.twig', [
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va créer notre template avec le contenu suivant :</p>
<pre><code>{% extends "base.html.twig" %}

{% block title %}Inscription{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire d'inscription&lt;/h1&gt;

        {{ form(form) }}

    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Voilà le formulaire d'inscription est fonctionnel.</p>
                    <h3>Étape 14 : Édition du profil et du mot de passe :</h3>
                    <p>On va créer le formulaire "UserType" lié à l'entité "User" avec la commande :</p>
<pre><code>php bin/console make:form UserType User</code></pre>
                    <p>Comme précédemment, on va modifier la fonction "buildForm" comme ceci :</p>
<pre><code>$builder-&gt;add('fullName', TextType::class, [
    'attr' =&gt; [
        'class' =&gt; 'form-control',
        'minlength' =&gt; '2',
        'maxlength' =&gt; '50',
    ],
    'label' =&gt; 'Nom / Prénom',
    'label_attr' =&gt; [
        'class' =&gt; 'form_label mt-4'
    ],
    'constraints' =&gt; [
        new Assert\NotBlank(),
        new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
    ]
])
    -&gt;add('pseudo', TextType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control',
            'minlength' =&gt; '2',
            'maxlength' =&gt; '50',
        ],
        'required' =&gt; false,
        'label' =&gt; 'Pseudo (Facultatif)',
        'label_attr' =&gt; [
            'class' =&gt; 'form_label mt-4'
        ],
        'constraints' =&gt; [
            new Assert\Length(['min' =&gt; 2, 'max' =&gt; 50])
        ]
    ])
    -&gt;add('plainPassword', PasswordType::class, [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Modifier le profil'
    ]);</code></pre>
                    <p>Ensuite, on va créer un contrôleur "UserController", on met le dossier de template "user" dans le dossier "pages", on modifie le fichier "index.html.twig" en "edit.html.twig" et on modifie la fonction "index" du contrôleur en "edit" :</p>
<pre><code>/**
* This controller allow us to edit user's profile
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edition/{id}', name: 'user.edit', methods: ['GET', 'POST'])]
public function edit(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    if (!$this-&gt;getUser()) {
        return $this-&gt;redirectToRoute('security.login');
    }

    if ($this-&gt;getUser() !== $user) {
        return $this-&gt;redirectToRoute('recipe.index');
    }

    $form = $this-&gt;createForm(UserType::class, $user);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()-&gt;getPlainPassword()))
        {
            $user = $form-&gt;getData();
            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Les informations de votre compte ont bien été modifiées !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions le template ainsi :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification des informations de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>On crée un  nouveau formulaire "UserPasswordType" associer à l'entité "User" pour modifier le mot de passe :</p>
<pre><code>$builder-&gt;add('plainPassword', RepeatedType::class, [
    'type' =&gt; PasswordType::class,
    'first_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'second_options' =&gt; [
        'attr' =&gt; [
            'class' =&gt; 'form-control'
        ],
        'label' =&gt; 'Confirmation du mot de passe',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ],
    'invalid_message' =&gt; 'Les mots de passe ne correspondent pas !'
])
    -&gt;add('newPassword', PasswordType::class, [
        'attr' =&gt; ['class' =&gt; 'form-control'],
        'label' =&gt; 'Nouveau mot de passe',
        'label_attr' =&gt; ['class' &gt;= 'form-label mt-4'],
        'constraints' =&gt; [new Assert\NotBlank()]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Changer mon mot de passe'
    ]);</code></pre>
                    <p>On rajoute la fonction "editPassword" dans le contrôleur :</p>
<pre><code>/**
* This controller allow us to edit user's password
*
* @param User $user
* @param Request $request
* @param EntityManagerInterface $manager
* @param UserPasswordHasherInterface $hasher
* @return Response
*/
#[Route('/utilisateur/edit-mot-de-passe/{id}', 'user.edit.password', methods: ['GET, 'POST'])]
public function editPassword(User $user, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    $form = $this-&gt;createForm(UserPasswordType::class);

    $form-&gt;handleRequest($request);

    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        if ($hasher-&gt;isPasswordValid($user, $form-&gt;getData()['plainPassword'])) {
            $user-&gt;setUpdatedAt(new \DateTimeImmutable());
            $user-&gt;setPlainPassword($form-&gt;getData()['newPassword']);

            $manager-&gt;persist($user);
            $manager-&gt;flush();

            $this-&gt;addFlash('success', 'Le mot de passe a été modifié !');

            return $this-&gt;redirectToRoute('recipe.index');
        } else {
            $this-&gt;addFlash('warning', 'Le mot de passe renseigné est incorrect !');
        }
    }

    return $this-&gt;render('pages/user/edit_password.html.twig', [
        'form' =&gt; $form-&gt;createView(),
    ]);
}</code></pre>
                    <p>Modifions également le template :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}Modification du mot de passe de l'utilisateur{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;Formulaire de modification du mot de passe de l'utilisateur&lt;/h1&gt;

        {% for message in app.flashes('warning') %}
            &lt;div class="alert alert-warning mt-4"&gt;
                {{ message }}
            &lt;/div&gt;
        {% endfor %}

        {{ form(form) }}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <h3>Étape 15 : Assigner les entités à un utilisateur (ingrédient, recette) :</h3>
                    <p>Dans cette partie, on va mettre en place la relation entre l'entité "User" et l'entité "Ingredient". On doit également modifier les fixtures pour lier les ingrédients à un utilisateur, ainsi que lier un ingrédient à l'utilisateur connecté lors de la création et afficher uniquement les ingrédients reliés à l'utilisateur.</p>
                    <p>Pour commencer, on rajoute la propriété "ingredients" dans l'entité "User" de type "relation" lié à l'entité "Ingredient" et de type de relation "OneToMany".</p>
                    <p>On va dire que la propriété "user" non nullable sera rajouté dans l'entité "Ingredient" et on va ajouter le fait de supprimer l'ingrédient orphelin.</p>
                    <p>Dans les fixtures, on déplace le code des users au-dessus de celui des ingrédients que l'on va modifier ainsi :</p>
<pre><code>// Ingredients
$ingredients = [];
for ($i = 0; $i &lt; 50; $i++) {
    $ingredient = new Ingredient();
    $ingredient-&gt;setName($this-&gt;faker-&gt;word())
        -&gt;setPrice(mt_rand(0, 100))
        -&gt;setUser($users[array_range($users)]);
}</code></pre>
                    <p>On crée une nouvelle migration, on la migre et on load à nouveau les fixtures. Enfin, on modifie la fonction "index" de notre "IngredientController" pour qu'il affiche seulement les ingrédients lié à l'utilisateur connecté :</p>
<pre><code>/**
* This controller display all ingredients
*
* @param IngredientRepository $repository
* @param PaginatorInterface $paginator
* @param Request $request
* @return Response
*/
#[Route('/ingredient', name: 'ingredient.index', methods: ['GET'])]
public function index(IngredientRepository $repository, PaginatorInterface $paginator, Request $request) : Response
{

    $ingredients = $paginator-&gt;paginate(
        $repository->findBy(['user' =&gt; $this-&gt;getUser()]),
        $request-&gt;query-&gt;getInt('page', 1),
        10    
    );
    // dd($ingredients);

    return $this-&gt;render('pages/ingredient/index.html.twig', [
        'ingredients' =&gt; $ingredients
    ]);
}</code></pre>
                    <p>Pour lier l'utilisateur à un ingrédient lors de sa création, on va modifier la fonction "new" du "IngredientController" pour ajouter la ligne suivante :</p>
<pre><code>$ingredient-&gt;setUser($this-&gt;getUser());</code></pre>
                    <p>Ce sera pareil pour l'entité "Recipe" afin de la lier à celle de "User". On doit ajouter un constructeur et on doit modifier le "QueryBuilder" du formulaire pour lors de la création d'une recette, on affiche seulement tous les ingrédients de l'utilisateur connecté :</p>
<pre><code>use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;

private $token;

public function __construct(TokenStorageInterface $token)
{
    $this-&gt;token = $token;
}</code></pre>
<pre><code>'query_builder' =&gt; function(IngredientRepository $r) {
    return $r-&gt;createQueryBuilder('i')
        -&gt;where('i.user = :user')
        -&gt;orderBy('i.name', 'ASC')
        -&gt;setParameter('user', $this-&gt;token-&gt;getToken()-&gt;getUser());
}</code></pre>
                    <p>On va modifier la navbar qui sera différente si l'utilisateur est connecté ou pas avec <span class="html">{% if app.user %}</span>.</p>
                    <p>Les liens vers la connexion et l'inscription si l'utilisateur n'est pas connecté sinon les liens vers mes ingrédients et mes recettes comme par exemple :</p>
<pre><code>&lt;div class="d-flex"&gt;
    &lt;ul class="navbar-nav me-auto"&gt;
        {% if app.user %}
            &lt;li class="nav-item dropdown"&gt;
                &lt;a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false"&gt;{{ app.user.fullName }}&lt;/a&gt;
                &lt;div class="dropdown-menu dropdown-menu-end"&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit', {id: app.user.id}) }}"&gt;Modifier mes informations&lt;/a&gt;
                    &lt;a class="dropdown-item" href="{{ path('user.edit.password', {id: app.user.id}) }}"&gt;Modifier mon mot de passe&lt;/a&gt;
                    &lt;div class="dropdown-divider"&gt;&lt;/div&gt;
                    &lt;a class="dropdown-item" href="{{ path('security.logout') }}"&gt;Déconnexion&lt;/a&gt;
                &lt;/div&gt;
            &lt;/li&gt;
        {% else %}
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.login') }}"&gt;Connexion&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link" href="{{ path('security.registration') }}"&gt;Inscription&lt;/a&gt;
            &lt;/li&gt;
        {% endif %}
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    <h3>Étape 16 : Sécuriser les routes avec IS_GRANTED et SECURITY :</h3>
                    <p>Dans cette partie, on va gérer la gestion de l'accès des pages, c'est-à-dire qu'on va interdire l'accès à certaines pahes en fonction de différents critères.</p>
                    <p>Les annotations <span class="html">@Security</span> et <span class="html">@IsGranted</span> restreint l'accès aux contrôleurs et donc par extension aux pages.</p>
                    <p>L'annotation <span class="em">@IsGranted</span> est la plus simple pour restreindre par rôle ou encore par les variables passées au contrôleur.</p>
                    <p>L'annotation <span class="em">@Security</span> est plus flexible et plus complète qui permet de passer des expressions contenant de la logique.</p>
                    <p>Pour la page de la liste des ingrédients, on va donner l'accès aux utilisateurs ayant le rôle "ROLE_USER" en ajoutant sur la méthode "index" du "IngredientController" la ligne suivante :</p>
<pre><code>#[IsGranted('ROLE_USER')]</code></pre>
                    <p>Pour la modification des ingrédients, on doit aussi vérifier qu'en plus du rôle "ROLE_USER" que l'utilisateur connecté soit bien celui lié à cet ingrédient avec la ligne suivante :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === ingredient.getUser()")]</code></pre>
                    <p>Ce sera pareil pour les recettes. Pour la modification du profil de l'utilisateur ou encore pour la modification du mot de passe, on va supprimer les if de vérification pour les remplacer par la ligne suivante au-dessus de la fonction "edit" de l'"UserController" :</p>
<pre><code>#[Security("is_granted('ROLE_USER') and user === choosenUser")]
public function edit(User $choosenUser, Request $request, EntityManagerInterface $manager, UserPasswordHasherInterface $hasher): Response
{
    ...
}</code></pre>
                    <p>Remarque : On a modifié le "$user" par "$choosenUser" car il existe déjà la variable "user" dans l'annotation "Security".</p>
                    <h3>Étape 17 : Partager une recette :</h3>
                    <p>Pour partager une recette, on la rendre publique ou non avec les spécificités suivantes :</p>
                    <ul>
                        <li>Un utilisateur connecté aura à disposition un champ, pour chaque recette, lui permettant de choisir si la recette en question est disponible pour l'ensemble de la communauté.</li>
                        <li>Si la recette est rendue publique, alors les utilisateurs pourront la consulter.</li>
                        <li>Sinon, elle ne pourra pas être consultée par quelqu'un d'autre que le créateur.</li>
                    </ul>
                    <p>On va rajouter la propriété "isPublic" de type "boolean" non nullable dans l'entité "Recipe" avec la valeur par défaut à "false". On fait une nouvelle migration et on la migre. On va modifier la fixture pour ajouter la ligne suivante :</p>
<pre><code>-&gt;setIsPublic(mt_rand(0, 1) == 1);</code></pre>
                    <p>Dans le contrôleur "RecipeController", on va rajouter la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET'])]
public function show(Recipe $recipe): Response
{
    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe
    ]);
}</code></pre>
                    <p>Créons donc ce template avec le contenu suivant :</p>
<pre><code>{% extends 'base.html.twig' %}

{% block title %}
    {{ recipe.name }}
{% endblock %}

{% block body %}
    &lt;div class="container"&gt;
        &lt;h1 class="mt-4"&gt;{{ recipe.name }}&lt;/h1&gt;
        &lt;div&gt;
            &lt;span class="badge bg-primary"&gt;Créée le {{ recipe.createdAt|date('d/m/Y') }}&lt;/span&gt;
        &lt;/div&gt;

        {% if recipe.time %}
            &lt;p&gt;Temps (en minutes) : {{ recipe.time }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Temps non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.nbPeople %}
            &lt;p&gt;Pour {{ recipe.nbPeople }} personnes&lt;/p&gt;
        {% else %}
            &lt;p&gt;Nombre de personnes non renseigné&lt;/p&gt;
        {% endif %}

        {% if recipe.difficulty %}
            &lt;p&gt;Difficulté : {{ recipe.difficulty }}/5&lt;/p&gt;
        {% else %}
            &lt;p&gt;Difficulté non renseignée&lt;/p&gt;
        {% endif %}

        {% if recipe.price %}
            &lt;p&gt;Prix (en €) : {{ recipe.price }}&lt;/p&gt;
        {% else %}
            &lt;p&gt;Prix non renseigné&lt;/p&gt;
        {% endif %}

        &lt;div class="mt-4"&gt;
            {{ recipe.description|raw }}
        &lt;/div&gt;

        &lt;p class="mt-4"&gt;Ingrédients :&lt;/p&gt;
        {% for ingredient in recipe.ingredients %}
            &lt;span class="badge bg-primary"&gt;{{ ingredient.name }}&lt;/span&gt;
        {% endfor %}
    &lt;/div&gt;
{% endblock %}</code></pre>
                    <p>Pour afficher la page qui liste toutes les recettes qui ont été partagées par l'ensemble des personnes, on va créer dans le "RecipeController" une nouvelle fonction :</p>
<pre><code>#[Route('/recette/pblique', 'recipe.public', methods: ['GET'])]
public function indexPublic(RecipeRepository $repository, PaginatorInterface $paginator, Request $request): Response
{
    $recipes = $paginator-&gt;paginate(
        $repository-&gt;findPublicRecipe(null),
        $request-&gt;query-&gt;getInt('page', 1),
        10
    );

    return $this-&gt;render('pages/recipe.index_public.html.twig', [
        'recipes' =&gt; $recipes
    ]);
}</code></pre>
                    <p>On peut copier le même template que la liste des recettes mais sans les boutons de modification et de suppression. Ensuite, on va créer une fonction dans le "RecipeRepository" qui va permettre de récupérer un nombre x de recettes publiques :</p>
<pre><code>/**
* This method allow us to find public recipes based on number of recipes
*
* @param integer $nbRecipes
* @return array
*/
public function findPublicRecipe(?int $nbRecipes): array
{
    $queryBuilder = $this-&gt;createQueryBuilder('r')
        -&gt;where('r.isPublic = 1')
        -&gt;orderBy('r.createdAt', 'DESC');
    
    if ($nbRecipes !== 0 || !is_null($nbRecipes)) {
        $queryBuilder-&gt;setMaxResults($nbRecipes);
    }
    
    return $queryBuilder-&gt;getQuery()
        -&gt;getResult();
}</code></pre>
                    <p>Sur la page d'accueil, on pourrait afficher les 3 dernières recettes de la communauté en précisant la valeur de "$nbRecipes" à 3.</p>
                    <h3>Étape 18 : Noter une recette :</h3>
                    <p>Cette fonctionnalité va permettre aux différents utilisateurs de noter les recettes mises en mode "public" sur l'application. Une fois la recette mise en mode "public", elle est éligible aux votes des utilisateurs.</p>
                    <p>Un utilisateur connecté pourra donner une note entre 1 et 5. L'ensemble des notes deront une moyenne, et les utilisateurs pourront voir cette moyenne sur la page de la recette.</p>
                    <p>En logique et c'est très compréhensible, un utilisateur ne pourra pas noter sa propre recette et un utilisateur ne pourra pas non plus noter deux fois la même recette.</p>
                    <p>Pour commencer à coder cette fonctionnalité, on va d'abord créer une entité "Mark" ("note" en anglais) avec la commande suivante :</p>
<pre><code>php bin/console make:entity Mark</code></pre>
                    <p>Avec les propriétés "mark" de type "integer" non nullable, "user" de type "ManyToOne" non nullable liée à l'entité "User", "recipe" de type "ManyToOne" non nullable liée à l'entité "Recipe" et "createdAt" de type "datetime_immutable" non nullable.</p>
                    <p>On va modifier l'entité "Mark" comme ceci :</p>
<pre><code>#[ORM\Entity(repositoryClass: MarkRepository::class)]
#[UniqueEntity(
    fields: ['user', 'recipe'],
    errorpath: 'user',
    message: 'Cet utilisateur a déjà noté cette recette !'
)]
class Mark
{

    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'integer')]
    #[Assert\Positive()]
    #[Assert\LessThan(6)]
    private int $mark;

    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private User $user;

    #[ORM\ManyToOne(targetEntity: Recipe::class, inversedBy: 'marks')]
    #[ORM\JoinColumn(nullable: false)]
    private Recipe $recipe;

    #ORM\Column(type: 'datetime_immutable')]
    private ?\DateTimeImmutable $createdAt;

    public function __construct()
    {
        $this-&gt;createdAt = new \DateTimeImmutable();
    }

}</code></pre>
                    <p>On oublie pas de créer la migration et la migrer. Dans nos fixtures, on va rajouter les marks :</p>
<pre><code>// Marks
foreach ($recipes as $recipe) {
    for ($i = 0; $i &lt; mt_rand(0, 4); $i++) {
        $mark = new Mark();
        $mark-&gt;setMark(mt_rand(1, 5))
            -&gt;setUser($users[array_range($users)])
            -&gt;setRecipe($recipe);
        
        $manager-&gt;persist($mark);
    }
}</code></pre>
                    <p>Pour calculer la moyenne des notes de la recette, on rajouter un <span class="em">private ?float $average = null;</span> dans l'entité "Recipe" et y rajouter la fonction "getAverage" :</p>
<pre><code>/**
* Get the value of average
*/
public function getAverage()
{
    $marks = $this-&gt;marks;

    if ($marks-&gt;toArray() === []) {
        $this-&gt;average = null;
    } else {
        $total = 0;
        foreach ($marks as $mark) {
            $total += $mark-&gt;getMark();
        }
        $this-&gt;average = $total / count($marks);
    }

    return $this-&gt;average;
}</code></pre>
                    <p>On va créer un petit formulaire "MarkType" basé sur l'entité "Mark" pour pouvoir noter les recettes avec la commande suivante :</p>
<pre><code>php bin/console make:form MarkType Mark</code></pre>
                    <p>On va ensuite modifier la fonction "buildForm" de ce nouveau fichier comme ceci :</p>
<pre><code>$builder
    -&gt;add('mark', ChoiceType::class, [
        'choices' =&gt; [
            '1' =&gt; 1,
            '2' =&gt; 2,
            '3' =&gt; 3,
            '4' =&gt; 4,
            '5' =&gt; 5,
        ],
        'attr' =&gt; [
            'class' =&gt; 'form-select'
        ],
        'label' =&gt; 'Noter la recette',
        'label_attr' =&gt; [
            'class' =&gt; 'form-label mt-4'
        ]
    ])
    -&gt;add('submit', SubmitType::class, [
        'attr' =&gt; [
            'class' =&gt; 'btn btn-primary mt-4'
        ],
        'label' =&gt; 'Noter la recette'
    ]);</code></pre>
                    <p>On va modfifier dans le "RecipeController" la fonction "show" :</p>
<pre><code>/**
* This controller allow us to see a recipe if this one is public
*
* @param Recipe $recipe
* @param Request $request
* @param MarkRepository $markRepository
* @param EntityManagerInterface $manager
* @return Response
*/
#[Security("is_granted('ROLE_USER') and (recipe.getIsPublic() === true" || user === recipe.getUser()))]
#[Route('/recette/{id}', 'recipe.show', methods: ['GET', 'POST'])]
public function show(Recipe $recipe, Request $request, MarkRepository $markRepository, EntityManagerInterface $manager): Response
{

    $mark = new Mark();
    $form = $this-&gt;createForm(MarkType::class, $mark);

    $form-&gt;handleRequest($request);
    if ($form-&gt;isSubmitted() && $form-&gt;isValid()) {
        $mark-&gt;setUser($this-&gt;getUser())
            -&gt;setRecipe($recipe);

        $existingMark = $markRepository-&gt;findOneBy([
            'user' =&gt; $this-&gt;getUser(),
            'recipe' =&gt; $recipe
        ]);

        if (!$existingMark) {
            $manager-&gt;persist($mark);
        } else {
           $existingMark-&gt;setMark($form-&gt;getData()-&gt;getMark());
        }

        $manager-&gt;flush();

        $this-&gt;addFlash('success', 'Votre note a bien été prise en compte !');

        return $this-&gt;redirectToRoute('recipe.show', ['id' =&gt; $recipe-&gt;getId()]);
    }

    return $this-&gt;render('pages/recipe/show.html.twig', [
        'recipe' =&gt; $recipe,
        'form' =&gt; $form-&gt;createView()
    ]);
}</code></pre>
                    <p>On va modifier le template lié à cette fonction pour ajouter les lignes suivantes au bon endroit :</p>
<pre><code>{% for message in app.flashes('success') %}
    &lt;div class="alert alert-success mt-4"&gt;
        {{ message }}
    &lt;/div&gt;
{% endfor %}

&lt;p&gt;La moyenne de cette recette est de {{ recipe.average|number_format(2, '.', ',') }}/5 !&lt;/p&gt;

&lt;div class="mark"&gt;
    {{ form(form) }}
&lt;/div&gt;</code></pre>
                    <h3>Étape 19 : Upload une image :</h3>
                    <p>Pour uploader une image pour chaque recette, on va d'abord utiliser le bundle "VichUploaderBundle" et on va l'installer avec la commande suivante :</p>
<pre><code>composer require vich/uploader-bundle</code></pre>
                    <p>Cette commande va générer le fichier <span class="em">`config\packages\vich_uploader.yaml`</span> qui est le fichier de configuration de ce bundle qu'on va modifier :</p>
<pre><code>vich_uploader:
    db_driver: orm

    mappings:
        recipe_images:
            uri_prefix: /images/recette
            upload_destination: "%kernel.project_dir%/public/images/recette"
            namer: Vich\UploaderBundle\Naming\SmartUniqueNamer
</code></pre>
                    <p>On va rajouter des informations pour l'upload des images dans l'entité "Recipe" :</p>
<pre><code>...

use Symfony\Component\HttpFoundation\File\File;
use Vich\UploaderBundle\Mapping\Annotation as Vich;

...

#[Vich\Uploadable]
class Recipe
{

    ...

    /**
    * NOTE : This is not a mapped field of entity metadata, just a simple property.
    */
    #[Vich\UploadableField(mapping: 'recipe_images', fileNameProperty: 'imageName')]
    private ?File $imageFile = null;

    #[ORM\Column(type: 'string', nullable: true)]
    private ?string $imageName = null;

    ...

    /**
    * If manually uploading a file (i.e. not using Symfony Form) ensure an instance
    * of 'UploadedFile' is injected into this setter to trigger the update. If this
    * bundle's configuration parameter 'inject_on_load' is set to 'true' this setter
    * must be able to accept an instnace of 'File' as the bundle will inject one here
    * during Doctrine hydration.
    *
    * @param File|\Symfony\Component\HttpFoundation\File\UpdloadedFile|null $imageFile
    */
    public function setImageFile(?File $imageFile = null): void
    {
        $this-&gt;imageFile = $imageFile;

        if (null !== $imageFile) {
            // It is required that at least one field changes if you are using doctrine
            // otherwise the event listeners won't be called and the file is lost
            $this-&gt;updatedAt = new \DateTimeImmutable();
        }
    }

    public function getImageFile(): ?File
    {
        return $this-&gt;imageFile;
    }

    public function setImageName(?string $imageName): void
    {
        $this-&gt;imageName = $imageName;
    }

    ...
    
}</code></pre>
                    <p>Dans le formulaire de création d'une recette, on va rajouter un champ "imageFile" comme ceci :</p>
<pre><code>-&gt;add('imageFile', VichImageType::class, [
    'label' =&gt; 'Image de la recette',
    'label_attr' =&gt; [
        'class' =&gt; 'form-label mt-4'
    ]
])</code></pre>
                    <p>Et dans le template du formulaire de création/modification d'une recette :</p>
<pre><code>{{ form_row(form.imageFile) }}</code></pre>
                    <p>On oublie pas de créer la migration et la migrer. Pour afficher l'image dans le détail de la recette (show), on fait :</p>
<pre><code>&lt;div class="recipe_image"&gt;
    &lt;img style="max-width: 500px;" src="{{ vich_uploader_asset(recipe, 'imageFile') }}"&gt;
&lt;/div&gt;</code></pre>
                    <p>Dans le tutoriel suivant, nous aborderons Laravel, un autre framework PHP populaire pour le développement web.</p>
                </article>
                <article>
                    <h2 id="intro_laravel">Introduction au Framework PHP Laravel :</h2>
                    <p>Dans ce tutoriel, nous allons vous guider à travers les étapes pour commencer à utiliser le framework PHP Laravel. Laravel est un framework web élégant et puissant qui facilite le développement rapide d'applications web modernes.</p>
                    <h3>Étape 1 : Installation de Laravel :</h3>
                    <p>Avant de commencer, assurez-vous d'avoir PHP et le grestionnaire de dépendances Composer installés sur votre système.</p>
                    <ol>
                        <li>
                            <p>Ouvrez une ligne de commande ou un terminal.</p>
                        </li>
                        <li>
                            <p>Installez Laravel en utilisant Composer avec la commande suivante :</p>
<pre><code>composer create-project --prefer-dist laravel/laravel nom_du_projet</code></pre>
                            <p>Remplacez "nom_du_projet" par le nom que vous souhaitez donner à votre projet.</p>
                        </li>
                        <li>
                            <p>Changez de répertoire vers votre nouveau projet :</p>
<pre><code>cd nom_du_projet</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 2 : Lancer le serveur web local :</h3>
                    <p>Laravel propose un serveur de développement pour faciliter le test de votre application en local. Pour le lancer, utilisez la commande suivante :</p>
<pre><code>php artisan serve</code></pre>
                    <h3>Étape 3 : Création d'une route et d'un contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvre le fichier <span class="em">`routes/web.php`</span> avec votre éditeur de code préféré.</p>
                        </li>
                        <li>
                            <p>Définissez une nouvelle route pour gérer une page d'accueil :</p>
<pre><code>// Ajoutez cette ligne au fichier web.php
Route::get('/', 'App\Http\Controllers\HomeController@index');</code></pre>
                        </li>
                        <li>
                            <p>Créez un nouveau contrôleur pour gérer cette route :</p>
<pre><code>php artisan make:controller HomeController</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 4 : Implémenter la logique du contrôleur :</h3>
                    <ol>
                        <li>
                            <p>Ouvrez le fihcier <span class="em">`app/Http/Controllers/HomeController.php`</span> avec votre éditeur de code.</p>
                        </li>
                        <li>
                            <p>Implémentez la logique du contôleur pour retourner la vue (template) :</p>
<pre><code>// Ajoutez cette méthode à la classe HomeController
public function index() {
    return view('homepage');
}</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 5 : Création de la vue (template) :</h3>
                    <ol>
                        <li>
                            <p>Créez un nouveau fichier <span class="em">`ressources/views/homepage.blade.php`</span> dans le répertoire du projet.</p>
                        </li>
                        <li>
                            <p>Ajoutez du contenu HTML à votre template :</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
    &lt;head&gt;
        &lt;title&gt;Mon Projet Laravel&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Bienvenue sur Mon Projet Laravel !&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </li>
                    </ol>
                    <h3>Étape 6 : Accéder à votre application :</h3>
                    <p>Ouvrez votre navigateur web et accédez à l'URL : <span class="em">`http://localhost:8000`</span>. Vous devriez voir le message "Bienvenur sur Mon Projet Laravel !" sur la page d'accueil.</p>
                    <p>Félicitations ! Vous avez maintenant créé une application web simple en utilisant Laravel. Laravel propose de nombreuses fonctionnalités pratiques telles que la gestion des migrations de base de données, l'ORM Eloquent, les formulaires, l'authentification et bien olus encore.</p>
                    <p>Vous pouvez continuer à explorer la documentation officielle de Laravel pour découvrir davantage de fonctionnalités et d'outils puissants offerts par ce framework. Laravel dispose également d'une communauté active qui partage de nombreux packages et ressources pour faciliter le développement de vos projets web.</p>    
                </article>
                <article>
                    <p>Pour plus d'informations pour savoir comment choisir entre Laravel et Symfony, voici <a href="https://grafikart.fr/tutoriels/laravel-symfony-866" target="_blank">le tutoriel vidéo de Grafikart</a>.</p>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>