<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Angular - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_configuration">Installation et configuration</a></li>
                        <li><a href="#premier_projet">Premier projet</a></li>
                        <li><a href="#premier_composant">Premier composant</a></li>
                        <li><a href="#premier_exercice">Premier exercice</a></li>
                        <li><a href="#templates">Les templates</a></li>
                        <li><a href="#directives">Les directives</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Angular :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Angular est un framework open-source de développement front-end maintenu par Google. Il est conçu pour créer des applications web dynamiques, interactives et performantes. Angular utilise TypeScript, un superset de JavaScript, pour offrir des fonctionnalités avancées comme le typage statique, les décorateurs et les interfaces.</p>
                    <h3>Principales caractéristiques d'Angular :</h3>
                    <ul>
                        <li>
                            <p><span class="em">Basé sur des composants</span> : Chaque partie de l'interface utilisateur est décomposée en composants réutilisables.</p>
                        </li>
                        <li>
                            <p><span class="em">Two-way Data Binding</span> : Synchronisation automatique des données entre le modèle et la vue.</p>
                        </li>
                        <li>
                            <p><span class="em">Modularité</span> : Les applications Angular sont organisées en modules pour une meilleure organisation et maintenabilité.</p>
                        </li>
                        <li>
                            <p><span class="em">Support de RxJS</span> : Gère les flux de données asynchrones avec Observables.</p>
                        </li>
                        <li>
                            <p><span class="em">Routage puissant</span> : Pour créer des applications à plusieurs pages et gérer les chemins d'accès facilement.</p>
                        </li>
                    </ul>
                    <h3>Différences entre AngularJS et Angular :</h3>
                    <p>Il existent différentes versions d'Angular. La première version, <span class="em">Angular 1</span>, est appelée <span class="em">AngularJS</span>.</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>AngularJS</th>
                                <th>Angular</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Basé sur JavaScript</td>
                                <td>Basé sur TypeScript</td>
                            </tr>
                            <tr>
                                <td>MVC (Model-View-Controller)</td>
                                <td>Achitecture composant</td>
                            </tr>
                            <tr>
                                <td>Moins performant</td>
                                <td>Optimisé pour des applications modernes</td>
                                <tr>
                                    <td>Créé en 2010</td>
                                    <td>Introduit en 2016.</td>
                                </tr>
                            </tr>
                        </tbody>
                    </table>
                    <p>En résumé, Angular est un framework JavaScript permettant la création de "Single Page Applications" (SPA).</p>
                </article>
                <article>
                    <h2 id="installation_configuration">Installation et configuration :</h2>
                    <p>Angular nécessite Node.js pour gérer les dépendances et exécuter des scripts. Pour ce faire, assurez-vous de télécharger et d'installer une version LTS (Long Term Support) de <a href="https://nodejs.org/fr" target="_blank">Node.js</a>.</p>
                    <p>Pour rappel, Node.js et npm sont installés en même temps.</p>
                    <p>Sous Linux, on peut le faire en lignes de commandes comme ceci :</p>
<pre><code>sudo apt-get update
sudo apt-get install nodejs npm</code></pre>
                    <p>Pour vérifier l'installation, vous pouvez taper les commandes suivantes dans un terminal :</p>
<pre><code>node -v</code></pre>
<pre><code>npm -v</code></pre>
                    <p>Angular CLI (Command Line Interface) facilite la création, le développement et le déploiement des applications Angular.</p>
<pre><code>npm install -g @angular/cli</code></pre>
                    <p>Pour vérifier l'installation du CLI, on tape ceci :</p>
<pre><code>ng version</code></pre>
                </article>
                <article>
                    <h2 id="premier_projet">Premier projet :</h2>
                    <p>Pour créer un projet Angular de base, on utilise la commande ci-dessous :</p>
<pre><code>ng new mon-premier-projet</code></pre>
                    <p>Les options demandées sont :</p>
                    <ul>
                        <li>
                            <p>Utiliser TypeScript strict : Oui</p>
                        </li>
                        <li>
                            <p>Ajouter Angular Routing : Oui</p>
                        </li>
                        <li>
                            <p>Sélectionner le style (CSS, SCSS, etc.) : CSS</p>
                        </li>
                    </ul>
                    <p>On peut utiliser les attributs suivants dans la commande ci-dessus pour configurer ces options en ligne de commande : <span class="html">--minimal</span> et <span class="html">--style=css</span>.</p>
                    <p>Ensuite, on va dans le répertoire du projet :</p>
<pre><code>cd mon-premier-projet</code></pre>
                    <p>Pour ouvrir ce dossier dans notre éditeur de code qu'est Visual Studio Code, on peut utiliser la commande suivante :</p>
<pre><code>code .</code></pre>
                    <p>On démarre le serveur de développement avec la commande suivante :</p>
<pre><code>ng serve</code></pre>
                    <p>On peut donc ouvrir notre navigateur et accéder à <a href="http://localhost:4200" target="_blank">http://localhost:4200</a>.</p>
                    <h3>Structure d'un projet Angular :</h3>
                    <p>Après la création du projet, la structure suivante est générée :</p>
<pre><code>mon-premier-projet/
├── src/
│   ├── app/                  # Contient les composants et les modules.
│   ├── assets/               # Fichiers statiques comme les images.
│   ├── environments/         # Configurations pour différents environnements.
│   ├── index.html            # Point d'entrée de l'application.
│   └── main.ts               # Fichier principal de l'application.
├── angular.json              # Configuration Angular CLI.
├── package.json              # Dépendances du projet.
└── README.md                 # Documentation du projet.</code></pre>
                </article>
                <article>
                    <h2 id="premier_composant">Premier composant :</h2>
                    <p>Lorsque vous créez un projet Angular, un composant de base appelée <span class="em">App</span> est généré automatiquement. Ce composant sert de point d'entrée principal pour l'affichage de votre application. Dans le dossier `<span class="em">src/app</span> se trouvent les fichiers suivants :</p>
                    <ul>
                        <li>
                            <p><span class="em">app.component.html</span> : Ce fichier contient le <span class="em">template HTML</span> du composant. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.component.ts</span> : Ce fichier contient la classe <span class="html">TypeScript</span> du composant. Il sert à gérer la logique métier et à définir les données (propriétés) liées au template. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: []
})

export class AppComponent {
    title = 'Bienvenue sur notre application Angular !'
}</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.component.spec.ts</span> : Ce fichier contient les <span class="em">tests unitaires</span> pour le composant. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () =&gt; {
    let component: AppComponent;
    let fixture: ComponentFixture&lt;AppComponent&gt;;

    BeforeEach(async () =&gt; {
        await TestBed.configureTestingModule({
            declarations: [AppComponent]
        }).compileComponents();
    });

    it('devrait créer le composant', () =&gt; {
        fixture = TestBed.createComponent(AppComponent);
        component = fixture.componentInstance;
        expect(component).toBeTruthy();
    });
});</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.module.ts</span> : Ce fichier contient la définition du <span class="em">module principal</span> de l'application. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
    declarations: [
        AppComponent // Déclaration du composant App
    ],
    imports: [
        BrowserModule // Module requis pour les applications Angular
    ],
    providers: [],
    bootstrap: [AppComponent] // Point d'entrée principal de l'application
})

export class AppModule {}</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app-routing.module.ts</span> : Ce fichier sert à configurer les <span class="em">routes</span> de l'application. Les routes permettent de naviguer entre les fifférents composants et d'afficher le contenu correspondant dans la vue. Ce fichier n'est pas toujours généré automatiquement lorsqu'on crée un projet Angular. Cependant, si vous utilisez l'option <span class="html">--routing</span> lors de la création du projet avec Angular CLI, ce fichier sera inclus dans votre projet. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AppComponent } from './app.component'; // Exemple de composant
import { PageNotFoundComponent } from './page-not-found/page-not-found.component'; // Composant de gestion des erreurs

// Déclaration des routes
const routes: Routes = [
    { path: '', component: AppComponent }, // Route par défaut
    { path: 'page-not-found', component: PageNotFoundComponent }, // Route pour les erreurs 404
    { path: '**', redirectTo: 'page-not-found' } // Redirection pour les chemins non trouvés
];

@NgModule({
    imports: [RouterModule.forRoot(routes)], // Configuration des routes pour l'application
    exports: [RouterModule] // Exportation pour permettre l'utilisation dans AppModule
})

export class AppRoutingModule {}</code></pre>
                        </li>
                    </ul>
                    <p>Ces fichiers, lorsqu'ils travaillent ensemble, forment un composant Angular fonctionnel. Le fichier HTML fournit la structure, le fichier TS gère la logique, le fichier de styles (non mentionné ici, mais généralement nommé <span class="em">app.component.css</span>) définit l'apparence, et le fichier <span class="em">spec.ts</span> vérifie que tout fonctionne correctement.</p>
                    <p>Dans notre fichier <span class="em">tsconfig.json</span> à la racine de notre projet, on doit vérifier qu'on a la propriété <span class="html">strictPropertyInitialization</span> à <span class="em">false</span> afin d'éviter que le compilateur TypeScript nous embête lorsqu'on veut typer nos variables.</p>
                    <p>Voici également les différentes méthodes du cycle de vie d'un composant ainsi que leurs descriptions :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Méthode</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <p class="html">ngOnChanges</p>
                                </td>
                                <td>
                                    <p>C'est la méthode appelée en premier lors de la création d'un composant, avant même <span class="html">ngOnInit</span>, et à chaque fois que Angular détecte que les valeurs d'une propriété du composant sont modifiées.</p>
                                    <p>La méthode reçoit en paramètre un objet représentant les valeurs actuelles et les valeurs précédentes disponibles pour ce composant.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngOnInit</p>
                                </td>
                                <td>
                                    <p>Cette méthode est appelée juste après le premier appel à <span class="html">ngOnChanges</span>, et elle initialise le composant après que Angular ait initialisé les propriétés du composant.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngDoCheck</p>
                                </td>
                                <td>
                                    <p>On peut implémenter cette interface pour étendre le comportement par défaut de la méthode <span class="html">ngOnChanges</span>, afin de pouvoir détecter et agir sur des changements qu'Angular ne peut pas détecter par lui-même.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngAfterViewInit</p>
                                </td>
                                <td>
                                    <p>Cette méthode est appelée juste après la mise en place de la vue d'un composant (et des vues de ses composants fils s'il en a).</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngOnDestroy</p>
                                </td>
                                <td>
                                    <p>Appelée en dernier, cette méthode est appelée avant qu'Angular ne détruise et ne retire du DOM le composant.</p>
                                    <p>Cela peut se produire lorsqu'un utilisateur navigue d'un composant à un autre par exemple.</p>
                                    <p>Afin d'éviter les fuites de mémoire, c'est cans cette méthode que nous effectuerons un certain nombre d'opérations afin de laisser de l'application "propre" (nous détacherons les gestionnaires d'événements par exemple).</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Même si elles ne sont pas redéclarées, ces méthodes existent dans le noyau d'Angular.</p>
                    <p>Voici un exemple de code utilisant le cycle de vie :</p>
<pre><code>import { Component, OnInit } from '@angular/core';

@Component({
    selector: 'app-root',
    template: '&lt;h1&gt;Welcome to {{ pokemonList[0] }}&lt;/h1&gt;'
})

export class AppComponent implements OnInit {
    pokemonList = ['Bulbizarre', 'Salamèche', 'Carapuce'];

    ngOnInit() {
        console.table(this.pokemonList);
        this.selectPokemon('Bulbizarre');
    }

    selectPokemon(pokemonName: string) {
        console.log(`Vous avez cliqué sur le pokémon ${pokemonName}`);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="premier_exercice">Premier exercice :</h2>
                    <p>On va créer plusieurs fichiers différents afin de séparer la logique métier de notre application de pokémon.</p>
                    <p>Le premier fichier à ajouter dans notre dossier <span class="em">src/app</span> est le <span class="em">pokemon.ts</span> dont voici le contenu :</p>
<pre><code>export class Pokemon {
    id: number;
    hp: number;
    cp: number;
    name: string;
    picture : string;
    types: Array&lt;string&gt;;
    created: Date;
}</code></pre>
                    <p>On va ensuite créer le mock avec la liste des pokémons dans le fichier <span class="em">mock-pokemon-list.ts</span> :</p>
<pre><code>import { Pokemon } from './pokemon';

export const POKEMONS: Pokemon[] = [
    {
        id: 1,
        name: "Bulbizarre",
        hp: 25,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/001.png",
        types: ["Plante", "Poison"],
        created: new Date()
    },
    {
        id: 2,
        name: "Salamèche",
        hp: 28,
        cp: 6,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/004.png",
        types: ["Feu"],
        created: new Date()
    },
    {
        id: 3,
        name: "Carapuce",
        hp: 21,
        cp: 4,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/007.png",
        types: ["Eau"],
        created: new Date()
    },
    {
        id: 4,
        name: "Aspicot",
        hp: 16,
        cp: 2,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/013.png",
        types: ["Insecte", "Poison"],
        created: new Date()
    },
    {
        id: 5,
        name: "Roucool",
        hp: 30,
        cp: 7,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/016.png",
        types: ["Normal", "Vol"],
        created: new Date()
    },
    {
        id: 6,
        name: "Rattata",
        hp: 18,
        cp: 6,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/019.png",
        types: ["Normal"],
        created: new Date()
    },
    {
        id: 7,
        name: "Piafabec",
        hp: 14,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/021.png",
        types: ["Normal", "Vol"],
        created: new Date()
    },
    {
        id: 8,
        name: "Abo",
        hp: 16,
        cp: 4,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/023.png",
        types: ["Poison"],
        created: new Date()
    },
    {
        id: 9,
        name: "Pikachu",
        hp: 21,
        cp: 7,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/025.png",
        types: ["Electrik"],
        created: new Date()
    },
    {
        id: 10,
        name: "Sabelette",
        hp: 19,
        cp: 3,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/027.png",
        types: ["Normal"],
        created: new Date()
    },
    {
        id: 11,
        name: "Mélofée",
        hp: 25,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/035.png",
        types: ["Fée"],
        created: new Date()
    },
    {
        id: 12,
        name: "Groupix",
        hp: 17,
        cp: 8,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/037.png",
        types: ["Feu"],
        created: new Date()
    }
];</code></pre>
                    <p>On va modifier notre template ainsi que charger dans <span class="em">pokemonList</span> la liste des pokémons contenus dans le mock :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-root',
    template: `&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;`
})

export class AppComponent implements OnInit {
    pokemonList: Pokemon[] = POKEMONS;

    ngOnInit() {
        console.table(this.pokemonList);
        this.selectPokemon(this.pokemonList[0]);
    }

    selectPokemon(pokemon: Pokemon) {
        console.log(`Vous avez cliqué sur le pokémon ${pokemon.name}`);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="templates">Les templates :</h2>
                    <p>Pour rappel, les templates sont les vues de nos composants et ils contiennent le code de notre interface utilisateur.</p>
                    <p>On ne mélange pas la vue et la logique et c'est pour ça qu'on crée un fichier HTML, <span class="em">app.component.html</span>, et on remplace la propriété <span class="html">template</span> du composant par la propriété <span class="html">templateUrl</span> comme ceci :</p>
<pre><code>@Component({
    selector: 'app-root',
    templateUrl: 'app.component.html'
})</code></pre>
                    <p>On va utiliser l'interpolation afin d'afficher les valeurs des variables de notre composant en utilisant la syntaxe des doubles accolades. Par exemple, on peut afficher les pokémons dans divers paragraphes :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Comme on l'a vu, l'interpolation est très pratique pour lier notre template et la classe de notre composant. Cependant, pour notre culture générale, pour monter en compétence, on va prendre connaissance d'autres manières de créer des liaisons entre le template et la classe d'un composant avec Angular. Voici un tableau récapitulatif des différentes façons de faire cela :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Propriétés</th>
                                <th>Code</th>
                                <th>Explications</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Propriété d'éléments</td>
                                <td>
<pre><code>&lt;img [src]='someImageUrl"&gt;</code></pre>
                                    <p>Ce code se traduit comme ceci avec l'interpolation :</p>
<pre><code>&lt;img src="{{ someImageUrl }}"&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On utilise les crochets pour lier directement la source de l'image à la propriété du composant <span class="em">someImageUrl</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété d'attribut</td>
                                <td>
<pre><code>&lt;label [attr.for]="someLabelId"&gt;...&lt;/label&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On lie l'attribut <span class="em">for</span> de l'élément label avec la propriété de notre composant <span class="em">someLabelId</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété de la classe</td>
                                <td>
<pre><code>&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt;</code></pre>
                                </td>
                                <td>
                                    <p>Fonctionnement similaire, pour attribuer ou non la classe <span class="em">special</span> à l'élément <span class="html">div</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété de style</td>
                                <td>
<pre><code>&lt;button [style.color]="isSpecial?'red':'green'"&gt;
    Special
&lt;/button&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On peut également définir un style pour nos éléments de manière dynamique : ici on définit la couleur de notre bouton en fonction de la propriété <span class="">isSpecial</span>, soit rouge, soit vert (c'est un opérateur ternaire que l'on utilise comme expression).</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Maintenant, on va gérer les interactions avec l'utilisateur comme les clics par exemple. Voici un exemple simple de l'utilisation d'un click sur le premier pokémon :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;p (click)="selectPokemon(pokemonList[0])"&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Voyons à présent comment intercepter tous les événements du DOM et pas que le click. On va ajouter un input dans notre vue et on va modifier le paramètre de notre méthode <span class="em">selectPokemon</span> :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input type="number" (click)="selectPokemon($event)"&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
<pre><code>selectPokemon(event: MouseEvent) {
    const index: number = +(event.target as HTMLInputElement).value;
    console.log(`Vous avez cliqué sur le pokémon ${this.pokemonList[index].name}`);
}</code></pre>
                    <p>Attention, n'oubliez pas que <span class="em">null</span> casté en <span class="em">number</span> est égal à <span class="em">0</span>.</p>
                    <p>Ensuite, on va parler des variables référencées dans le template car c'est super cool de travailler avec le <span class="html">$event</span>. On utilise le <span class="html">#</span> dans le template pour référencer une nouvelle variable.</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup)="0" type="number"&gt;
&lt;p&gt;Nombre saisi : {{ input.value }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>On va faire un petit exercice pour créer un flux de données bidirectionnel. On va avoir une nouvelle variable nommée <span class="em">pokemonSelected</span>.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-root',
    templateUrl: 'app.component.html'
})

export class AppComponent implements OnInit {
    pokemonList: Pokemon[] = POKEMONS;
    pokemonSelected: Pokemon|undefined;

    ngOnInit() {
        console.table(this.pokemonList);
    }

    selectPokemon(pokemonId: string) {
        const pokemon: Pokemon|undefined = this.pokemonList.find(pokemon =&gt; pokemon.id == +pokemonId);

        if (pokemon) {
            console.log(`Vous avez demandé le pokémon ${pokemon.name}`);
            this.pokemonSelected = pokemon;
        } else {
            console.log(`Vous avez demandé un pokémon qui n'existe pas.`);
            this.pokemonSelected = pokemon;
        }
    }
}</code></pre>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup)="selectPokemon(input.value)" type="number"&gt;
&lt;p&gt;Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Peut importe quelles touches on appuie, ça fonctionne. Enfin, on voudrait qu'une fois la touche "Enter" ou "Entrée" est appuyée ça fonctionne. Pour cela, on rajoute le mot <span class="em">enter</span> au <span class="em">keyup</span> dans notre vue :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p&gt;Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Ce sont des pseudo-évenments d'Angular. Enfin, je vais vous monter comment conditionner un affichage avec <span class="html">ngIf</span> et le boucler avec <span class="html">ngFor</span> :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p *ngIf="pokemonSelected"&gt;
    Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}
&lt;/p&gt;
&lt;p *ngIf="!pokemonSelected"&gt;
    Aucun pokémon n'a pas été trouvé.
&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Attention, l'astéristique <span class="em">*</span> est très importante. Il faut pas oublier la mettre devant <span class="html">ngIf</span> et <span class="html">ngFor</span> ou même devant n'importe quelle autre directive structurelle.</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p *ngIf="pokemonSelected"&gt;
    Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}
&lt;/p&gt;
&lt;p *ngIf="!pokemonSelected"&gt;
    Aucun pokémon n'a pas été trouvé.
&lt;/p&gt;

&lt;p *ngFor="let pokemon of pokemonList"&gt;
    {{ pokemon.name }}
&lt;/p&gt;</code></pre>
                    <p>Pour la partie CSS de notre application, on peut intégrer dans notre fichier <span class="em">index.html</span> Materialize dans une balise <span class="html">link</span> :</p>
<pre><code>&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"&gt;</code></pre>
<pre><code>&lt;h1 class="center"&gt;&gt;Liste de Pokémons&lt;/h1&gt;

&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div *ngFor="let pokemon of pokemonList" class="col m4 s6"&gt;
            &lt;div class="card horizontal"&gt;
                &lt;div class="card-image"&gt;
                    &lt;img [src]="pokemon.picture"&gt;
                &lt;/div&gt;
                &lt;div class="card-stacked"&gt;
                    &lt;div class="card-content"&gt;
                        &lt;p&gt;{{ pokemon.name }}&lt;/p&gt;
                        &lt;p&gt;&lt;small&gt;{{ pokemon.created }}&lt;/small&gt;&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                </article>
                <article>
                    <h2 id="directives">Les directives :</h2>
                    <p>La première question à se poser, c'est qu'est-ce qu'une directive ? Une directive est une classe Angular qui ressemble beaucoup à un composant sauf qu'elle n'a pas de template. D'ailleurs, au sein du framework, la classe <span class="html">Component</span> hérite de la classe <span class="html">Directive</span>. Voici les trois types de directives qui existent :</p>
                    <ol>
                        <li>
                            <p>Les composants</p>
                        </li>
                        <li>
                            <p>Les directives d'attributs</p>
                        </li>
                        <li>
                            <p>Les directives structurelles</p>
                        </li>
                    </ol>
                    <p>On va créer une directive d'attribut pour notre application. Ce type de directive va nous permettre de changer l'apparence ou le comportement d'un élément.</p>
                    <p>Par exemple, on va créer la directive <span class="em">BorderCardDirective</span> qui, comme son nom l'indique, permettra d'ajouter une bordure de couleur sur les pokémons de notre liste lorsque l'utilisateur les survolera avec son curseur.</p>
                    <p>On va utiliser Angular CLI pour générer la directive avec la commande suivante :</p>
<pre><code>ng generate directive border-card</code></pre>
                    <p>Cette commande permet de créer le fichier <span class="em">border-card.directive.ts</span> et à modifier le fichier <span class="em">app.module.ts</span> pour déclarer la directive. Voici le code généré :</p>
<pre><code>import { Directive } from '@angular/core';

@Directive({
    selector: '[appBorderCard]'
})

export class BorderCardDirective {

    constructor() { }

}</code></pre>
                    <p>On va récupérer la card du pokémon à laquelle on rajoute la bordure dans le constructeur de notre directive :</p>
<pre><code>import { Directive, ElementRef } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

}</code></pre>
                    <p>Pour détecter un événement tel que le survol d'un élément, on va utiliser une nouvelle annotation nommée <span class="html">@HostListener</span> qui permet de lier notre directive à un élément donné :</p>
<pre><code>import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder('#009688');
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder('#F5F5F5');
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                    <p>Dans le template, on rajoute l'attribut <span class="em">pokemonBorderCard</span> dans notre <span class="html">div</span> contenant la card :</p>
<pre><code>&lt;div class="card horizontal" ... pokemonBorderCard&gt;</code></pre>
                    <p>Pour le moment, notre directive <span class="em">pokemonBorderCard</span> n'est pas personnalisable. À chaque utilisation, cette directive impose une couleur unique aux bordures. On va préciser une propriété d'entrée dans notre directive via l'annotation <span class="html">@Input</span> :</p>
<pre><code>import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    @Input('pokemonBorderCard') borderColor: string;

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder(this.borderColor || '#009688');
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder('#F5F5F5');
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                    <p>Dans notre template, on remodifie la <span class="html">div</span> contenant notre card comme ceci afin que cette fois-ci la bordure soit <span class="em">red</span> au survol :</p>
<pre><code>&lt;div class="card horizontal" ... pokemonBorderCard="red"&gt;</code></pre>
                    <p>Il y a deux façons de déclarer une propriété d'entrée : avec ou sans alias. Voici la différence :</p>
<pre><code>@Input('pokemonBorderCard') borderColor: string; // avec alias
@Input() pokemonBorderCard: string; // sans alias</code></pre>
                    <p>Enfin, pour terminer le développement de notre directive, on va remplacer les valeurs entrées en dur par des propriétés telles que <span class="em">initialColor</span>, <span class="em">defaultColor</span> et <span class="em">defaultHeight</span>.</p>
<pre><code>import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    @Input('pokemonBorderCard') borderColor: string;

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder(this.borderColor || '#009688');
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder('#F5F5F5');
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>