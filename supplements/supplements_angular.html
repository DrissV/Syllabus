<!DOCTYPE html>
<html lang="fr">

    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Le langage Angular - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>

    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main" tabindex="-1">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#installation_configuration">Installation et configuration</a></li>
                        <li><a href="#premier_projet">Premier projet</a></li>
                        <li><a href="#premier_composant">Premier composant</a></li>
                        <li><a href="#premier_exercice">Premier exercice</a></li>
                        <li><a href="#templates">Les templates</a></li>
                        <li><a href="#directives">Les directives</a></li>
                        <li><a href="#pipes">Les pipes</a></li>
                        <li><a href="#routes">Les routes</a></li>
                        <li><a href="#modules">Les modules</a></li>
                        <li><a href="#services">Les services</a></li>
                        <li><a href="#formulaires">Les formulaires</a></li>
                        <li><a href="#programmation_reactive">La programmation réactive</a></li>
                        <li><a href="#requetes_HTTP">Les requêtes HTTP</a></li>
                        <li><a href="#librairie_RxJS">La librairie RxJS</a></li>
                        <li><a href="#authentification_securite">Authentification et sécurité</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside" role="complementary">
                    <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Le langage Angular :</h1>
                </article>
                <article>
                    <h2 id="introduction">Introduction :</h2>
                    <p>Angular est un framework open-source de développement front-end maintenu par Google. Il est conçu pour créer des applications web dynamiques, interactives et performantes. Angular utilise TypeScript, un superset de JavaScript, pour offrir des fonctionnalités avancées comme le typage statique, les décorateurs et les interfaces.</p>
                    <h3>Principales caractéristiques d'Angular :</h3>
                    <ul>
                        <li>
                            <p><span class="em">Basé sur des composants</span> : Chaque partie de l'interface utilisateur est décomposée en composants réutilisables.</p>
                        </li>
                        <li>
                            <p><span class="em">Two-way Data Binding</span> : Synchronisation automatique des données entre le modèle et la vue.</p>
                        </li>
                        <li>
                            <p><span class="em">Modularité</span> : Les applications Angular sont organisées en modules pour une meilleure organisation et maintenabilité.</p>
                        </li>
                        <li>
                            <p><span class="em">Support de RxJS</span> : Gère les flux de données asynchrones avec Observables.</p>
                        </li>
                        <li>
                            <p><span class="em">Routage puissant</span> : Pour créer des applications à plusieurs pages et gérer les chemins d'accès facilement.</p>
                        </li>
                    </ul>
                    <h3>Différences entre AngularJS et Angular :</h3>
                    <p>Il existent différentes versions d'Angular. La première version, <span class="em">Angular 1</span>, est appelée <span class="em">AngularJS</span>.</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>AngularJS</th>
                                <th>Angular</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Basé sur JavaScript</td>
                                <td>Basé sur TypeScript</td>
                            </tr>
                            <tr>
                                <td>MVC (Model-View-Controller)</td>
                                <td>Achitecture composant</td>
                            </tr>
                            <tr>
                                <td>Moins performant</td>
                                <td>Optimisé pour des applications modernes</td>
                                <tr>
                                    <td>Créé en 2010</td>
                                    <td>Introduit en 2016.</td>
                                </tr>
                            </tr>
                        </tbody>
                    </table>
                    <p>En résumé, Angular est un framework JavaScript permettant la création de "Single Page Applications" (SPA).</p>
                </article>
                <article>
                    <h2 id="installation_configuration">Installation et configuration :</h2>
                    <p>Angular nécessite Node.js pour gérer les dépendances et exécuter des scripts. Pour ce faire, assurez-vous de télécharger et d'installer une version LTS (Long Term Support) de <a href="https://nodejs.org/fr" target="_blank">Node.js</a>.</p>
                    <p>Pour rappel, Node.js et npm sont installés en même temps.</p>
                    <p>Sous Linux, on peut le faire en lignes de commandes comme ceci :</p>
<pre><code>sudo apt-get update
sudo apt-get install nodejs npm</code></pre>
                    <p>Pour vérifier l'installation, vous pouvez taper les commandes suivantes dans un terminal :</p>
<pre><code>node -v</code></pre>
<pre><code>npm -v</code></pre>
                    <p>Angular CLI (Command Line Interface) facilite la création, le développement et le déploiement des applications Angular.</p>
<pre><code>npm install -g @angular/cli</code></pre>
                    <p>Pour vérifier l'installation du CLI, on tape ceci :</p>
<pre><code>ng version</code></pre>
                </article>
                <article>
                    <h2 id="premier_projet">Premier projet :</h2>
                    <p>Pour créer un projet Angular de base, on utilise la commande ci-dessous :</p>
<pre><code>ng new mon-premier-projet</code></pre>
                    <p>Les options demandées sont :</p>
                    <ul>
                        <li>
                            <p>Utiliser TypeScript strict : Oui</p>
                        </li>
                        <li>
                            <p>Ajouter Angular Routing : Oui</p>
                        </li>
                        <li>
                            <p>Sélectionner le style (CSS, SCSS, etc.) : CSS</p>
                        </li>
                    </ul>
                    <p>On peut utiliser les attributs suivants dans la commande ci-dessus pour configurer ces options en ligne de commande : <span class="html">--minimal</span> et <span class="html">--style=css</span>.</p>
                    <p>Ensuite, on va dans le répertoire du projet :</p>
<pre><code>cd mon-premier-projet</code></pre>
                    <p>Pour ouvrir ce dossier dans notre éditeur de code qu'est Visual Studio Code, on peut utiliser la commande suivante :</p>
<pre><code>code .</code></pre>
                    <p>On démarre le serveur de développement avec la commande suivante :</p>
<pre><code>ng serve</code></pre>
                    <p>On peut donc ouvrir notre navigateur et accéder à <a href="http://localhost:4200" target="_blank">http://localhost:4200</a>.</p>
                    <h3>Structure d'un projet Angular :</h3>
                    <p>Après la création du projet, la structure suivante est générée :</p>
<pre><code>mon-premier-projet/
├── src/
│   ├── app/                  # Contient les composants et les modules.
│   ├── assets/               # Fichiers statiques comme les images.
│   ├── environments/         # Configurations pour différents environnements.
│   ├── index.html            # Point d'entrée de l'application.
│   └── main.ts               # Fichier principal de l'application.
├── angular.json              # Configuration Angular CLI.
├── package.json              # Dépendances du projet.
└── README.md                 # Documentation du projet.</code></pre>
                </article>
                <article>
                    <h2 id="premier_composant">Premier composant :</h2>
                    <p>Lorsque vous créez un projet Angular, un composant de base appelée <span class="em">App</span> est généré automatiquement. Ce composant sert de point d'entrée principal pour l'affichage de votre application. Dans le dossier `<span class="em">src/app</span> se trouvent les fichiers suivants :</p>
                    <ul>
                        <li>
                            <p><span class="em">app.component.html</span> : Ce fichier contient le <span class="em">template HTML</span> du composant. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;app-header&gt;&lt;/app-header&gt;
&lt;app-footer&gt;&lt;/app-footer&gt;</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.component.ts</span> : Ce fichier contient la classe <span class="html">TypeScript</span> du composant. Il sert à gérer la logique métier et à définir les données (propriétés) liées au template. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: []
})

export class AppComponent {
    title = 'Bienvenue sur notre application Angular !'
}</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.component.spec.ts</span> : Ce fichier contient les <span class="em">tests unitaires</span> pour le composant. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () =&gt; {
    let component: AppComponent;
    let fixture: ComponentFixture&lt;AppComponent&gt;;

    BeforeEach(async () =&gt; {
        await TestBed.configureTestingModule({
            declarations: [AppComponent]
        }).compileComponents();
    });

    it('devrait créer le composant', () =&gt; {
        fixture = TestBed.createComponent(AppComponent);
        component = fixture.componentInstance;
        expect(component).toBeTruthy();
    });
});</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app.module.ts</span> : Ce fichier contient la définition du <span class="em">module principal</span> de l'application. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
    declarations: [
        AppComponent // Déclaration du composant App
    ],
    imports: [
        BrowserModule // Module requis pour les applications Angular
    ],
    providers: [],
    bootstrap: [AppComponent] // Point d'entrée principal de l'application
})

export class AppModule {}</code></pre>
                        </li>
                        <li>
                            <p><span class="em">app-routing.module.ts</span> : Ce fichier sert à configurer les <span class="em">routes</span> de l'application. Les routes permettent de naviguer entre les fifférents composants et d'afficher le contenu correspondant dans la vue. Ce fichier n'est pas toujours généré automatiquement lorsqu'on crée un projet Angular. Cependant, si vous utilisez l'option <span class="html">--routing</span> lors de la création du projet avec Angular CLI, ce fichier sera inclus dans votre projet. Voici un exemple de code que devrait contenir ce fichier :</p>
<pre><code>import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AppComponent } from './app.component'; // Exemple de composant
import { PageNotFoundComponent } from './page-not-found/page-not-found.component'; // Composant de gestion des erreurs

// Déclaration des routes
const routes: Routes = [
    { path: '', component: AppComponent }, // Route par défaut
    { path: 'page-not-found', component: PageNotFoundComponent }, // Route pour les erreurs 404
    { path: '**', redirectTo: 'page-not-found' } // Redirection pour les chemins non trouvés
];

@NgModule({
    imports: [RouterModule.forRoot(routes)], // Configuration des routes pour l'application
    exports: [RouterModule] // Exportation pour permettre l'utilisation dans AppModule
})

export class AppRoutingModule {}</code></pre>
                        </li>
                    </ul>
                    <p>Ces fichiers, lorsqu'ils travaillent ensemble, forment un composant Angular fonctionnel. Le fichier HTML fournit la structure, le fichier TS gère la logique, le fichier de styles (non mentionné ici, mais généralement nommé <span class="em">app.component.css</span>) définit l'apparence, et le fichier <span class="em">spec.ts</span> vérifie que tout fonctionne correctement.</p>
                    <p>Dans notre fichier <span class="em">tsconfig.json</span> à la racine de notre projet, on doit vérifier qu'on a la propriété <span class="html">strictPropertyInitialization</span> à <span class="em">false</span> afin d'éviter que le compilateur TypeScript nous embête lorsqu'on veut typer nos variables.</p>
                    <p>Voici également les différentes méthodes du cycle de vie d'un composant ainsi que leurs descriptions :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Méthode</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <p class="html">ngOnChanges</p>
                                </td>
                                <td>
                                    <p>C'est la méthode appelée en premier lors de la création d'un composant, avant même <span class="html">ngOnInit</span>, et à chaque fois que Angular détecte que les valeurs d'une propriété du composant sont modifiées.</p>
                                    <p>La méthode reçoit en paramètre un objet représentant les valeurs actuelles et les valeurs précédentes disponibles pour ce composant.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngOnInit</p>
                                </td>
                                <td>
                                    <p>Cette méthode est appelée juste après le premier appel à <span class="html">ngOnChanges</span>, et elle initialise le composant après que Angular ait initialisé les propriétés du composant.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngDoCheck</p>
                                </td>
                                <td>
                                    <p>On peut implémenter cette interface pour étendre le comportement par défaut de la méthode <span class="html">ngOnChanges</span>, afin de pouvoir détecter et agir sur des changements qu'Angular ne peut pas détecter par lui-même.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngAfterViewInit</p>
                                </td>
                                <td>
                                    <p>Cette méthode est appelée juste après la mise en place de la vue d'un composant (et des vues de ses composants fils s'il en a).</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p class="html">ngOnDestroy</p>
                                </td>
                                <td>
                                    <p>Appelée en dernier, cette méthode est appelée avant qu'Angular ne détruise et ne retire du DOM le composant.</p>
                                    <p>Cela peut se produire lorsqu'un utilisateur navigue d'un composant à un autre par exemple.</p>
                                    <p>Afin d'éviter les fuites de mémoire, c'est cans cette méthode que nous effectuerons un certain nombre d'opérations afin de laisser de l'application "propre" (nous détacherons les gestionnaires d'événements par exemple).</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Même si elles ne sont pas redéclarées, ces méthodes existent dans le noyau d'Angular.</p>
                    <p>Voici un exemple de code utilisant le cycle de vie :</p>
<pre><code>import { Component, OnInit } from '@angular/core';

@Component({
    selector: 'app-root',
    template: '&lt;h1&gt;Welcome to {{ pokemonList[0] }}&lt;/h1&gt;'
})

export class AppComponent implements OnInit {
    pokemonList = ['Bulbizarre', 'Salamèche', 'Carapuce'];

    ngOnInit() {
        console.table(this.pokemonList);
        this.selectPokemon('Bulbizarre');
    }

    selectPokemon(pokemonName: string) {
        console.log(`Vous avez cliqué sur le pokémon ${pokemonName}`);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="premier_exercice">Premier exercice :</h2>
                    <p>On va créer plusieurs fichiers différents afin de séparer la logique métier de notre application de pokémon.</p>
                    <p>Le premier fichier à ajouter dans notre dossier <span class="em">src/app</span> est le <span class="em">pokemon.ts</span> dont voici le contenu :</p>
<pre><code>export class Pokemon {
    id: number;
    hp: number;
    cp: number;
    name: string;
    picture : string;
    types: Array&lt;string&gt;;
    created: Date;
}</code></pre>
                    <p>On va ensuite créer le mock avec la liste des pokémons dans le fichier <span class="em">mock-pokemon-list.ts</span> :</p>
<pre><code>import { Pokemon } from './pokemon';

export const POKEMONS: Pokemon[] = [
    {
        id: 1,
        name: "Bulbizarre",
        hp: 25,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/001.png",
        types: ["Plante", "Poison"],
        created: new Date()
    },
    {
        id: 2,
        name: "Salamèche",
        hp: 28,
        cp: 6,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/004.png",
        types: ["Feu"],
        created: new Date()
    },
    {
        id: 3,
        name: "Carapuce",
        hp: 21,
        cp: 4,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/007.png",
        types: ["Eau"],
        created: new Date()
    },
    {
        id: 4,
        name: "Aspicot",
        hp: 16,
        cp: 2,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/013.png",
        types: ["Insecte", "Poison"],
        created: new Date()
    },
    {
        id: 5,
        name: "Roucool",
        hp: 30,
        cp: 7,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/016.png",
        types: ["Normal", "Vol"],
        created: new Date()
    },
    {
        id: 6,
        name: "Rattata",
        hp: 18,
        cp: 6,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/019.png",
        types: ["Normal"],
        created: new Date()
    },
    {
        id: 7,
        name: "Piafabec",
        hp: 14,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/021.png",
        types: ["Normal", "Vol"],
        created: new Date()
    },
    {
        id: 8,
        name: "Abo",
        hp: 16,
        cp: 4,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/023.png",
        types: ["Poison"],
        created: new Date()
    },
    {
        id: 9,
        name: "Pikachu",
        hp: 21,
        cp: 7,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/025.png",
        types: ["Electrik"],
        created: new Date()
    },
    {
        id: 10,
        name: "Sabelette",
        hp: 19,
        cp: 3,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/027.png",
        types: ["Normal"],
        created: new Date()
    },
    {
        id: 11,
        name: "Mélofée",
        hp: 25,
        cp: 5,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/035.png",
        types: ["Fée"],
        created: new Date()
    },
    {
        id: 12,
        name: "Groupix",
        hp: 17,
        cp: 8,
        picture: "https://assets.pokemon.com/assets/cms2/img/pokedex/detail/037.png",
        types: ["Feu"],
        created: new Date()
    }
];</code></pre>
                    <p>On va modifier notre template ainsi que charger dans <span class="em">pokemonList</span> la liste des pokémons contenus dans le mock :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-root',
    template: `&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;`
})

export class AppComponent implements OnInit {
    pokemonList: Pokemon[] = POKEMONS;

    ngOnInit() {
        console.table(this.pokemonList);
        this.selectPokemon(this.pokemonList[0]);
    }

    selectPokemon(pokemon: Pokemon) {
        console.log(`Vous avez cliqué sur le pokémon ${pokemon.name}`);
    }
}</code></pre>
                </article>
                <article>
                    <h2 id="templates">Les templates :</h2>
                    <p>Pour rappel, les templates sont les vues de nos composants et ils contiennent le code de notre interface utilisateur.</p>
                    <p>On ne mélange pas la vue et la logique et c'est pour ça qu'on crée un fichier HTML, <span class="em">app.component.html</span>, et on remplace la propriété <span class="html">template</span> du composant par la propriété <span class="html">templateUrl</span> comme ceci :</p>
<pre><code>@Component({
    selector: 'app-root',
    templateUrl: 'app.component.html'
})</code></pre>
                    <p>On va utiliser l'interpolation afin d'afficher les valeurs des variables de notre composant en utilisant la syntaxe des doubles accolades. Par exemple, on peut afficher les pokémons dans divers paragraphes :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Comme on l'a vu, l'interpolation est très pratique pour lier notre template et la classe de notre composant. Cependant, pour notre culture générale, pour monter en compétence, on va prendre connaissance d'autres manières de créer des liaisons entre le template et la classe d'un composant avec Angular. Voici un tableau récapitulatif des différentes façons de faire cela :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Propriétés</th>
                                <th>Code</th>
                                <th>Explications</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Propriété d'éléments</td>
                                <td>
<pre><code>&lt;img [src]='someImageUrl"&gt;</code></pre>
                                    <p>Ce code se traduit comme ceci avec l'interpolation :</p>
<pre><code>&lt;img src="{{ someImageUrl }}"&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On utilise les crochets pour lier directement la source de l'image à la propriété du composant <span class="em">someImageUrl</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété d'attribut</td>
                                <td>
<pre><code>&lt;label [attr.for]="someLabelId"&gt;...&lt;/label&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On lie l'attribut <span class="em">for</span> de l'élément label avec la propriété de notre composant <span class="em">someLabelId</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété de la classe</td>
                                <td>
<pre><code>&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt;</code></pre>
                                </td>
                                <td>
                                    <p>Fonctionnement similaire, pour attribuer ou non la classe <span class="em">special</span> à l'élément <span class="html">div</span>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Propriété de style</td>
                                <td>
<pre><code>&lt;button [style.color]="isSpecial?'red':'green'"&gt;
    Special
&lt;/button&gt;</code></pre>
                                </td>
                                <td>
                                    <p>On peut également définir un style pour nos éléments de manière dynamique : ici on définit la couleur de notre bouton en fonction de la propriété <span class="">isSpecial</span>, soit rouge, soit vert (c'est un opérateur ternaire que l'on utilise comme expression).</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Maintenant, on va gérer les interactions avec l'utilisateur comme les clics par exemple. Voici un exemple simple de l'utilisation d'un click sur le premier pokémon :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;p (click)="selectPokemon(pokemonList[0])"&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Voyons à présent comment intercepter tous les événements du DOM et pas que le click. On va ajouter un input dans notre vue et on va modifier le paramètre de notre méthode <span class="em">selectPokemon</span> :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input type="number" (click)="selectPokemon($event)"&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
<pre><code>selectPokemon(event: MouseEvent) {
    const index: number = +(event.target as HTMLInputElement).value;
    console.log(`Vous avez cliqué sur le pokémon ${this.pokemonList[index].name}`);
}</code></pre>
                    <p>Attention, n'oubliez pas que <span class="em">null</span> casté en <span class="em">number</span> est égal à <span class="em">0</span>.</p>
                    <p>Ensuite, on va parler des variables référencées dans le template car c'est super cool de travailler avec le <span class="html">$event</span>. On utilise le <span class="html">#</span> dans le template pour référencer une nouvelle variable.</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup)="0" type="number"&gt;
&lt;p&gt;Nombre saisi : {{ input.value }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>On va faire un petit exercice pour créer un flux de données bidirectionnel. On va avoir une nouvelle variable nommée <span class="em">pokemonSelected</span>.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-root',
    templateUrl: 'app.component.html'
})

export class AppComponent implements OnInit {
    pokemonList: Pokemon[] = POKEMONS;
    pokemonSelected: Pokemon|undefined;

    ngOnInit() {
        console.table(this.pokemonList);
    }

    selectPokemon(pokemonId: string) {
        const pokemon: Pokemon|undefined = this.pokemonList.find(pokemon =&gt; pokemon.id == +pokemonId);

        if (pokemon) {
            console.log(`Vous avez demandé le pokémon ${pokemon.name}`);
            this.pokemonSelected = pokemon;
        } else {
            console.log(`Vous avez demandé un pokémon qui n'existe pas.`);
            this.pokemonSelected = pokemon;
        }
    }
}</code></pre>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup)="selectPokemon(input.value)" type="number"&gt;
&lt;p&gt;Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Peut importe quelles touches on appuie, ça fonctionne. Enfin, on voudrait qu'une fois la touche "Enter" ou "Entrée" est appuyée ça fonctionne. Pour cela, on rajoute le mot <span class="em">enter</span> au <span class="em">keyup</span> dans notre vue :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p&gt;Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Ce sont des pseudo-évenments d'Angular. Enfin, je vais vous monter comment conditionner un affichage avec <span class="html">ngIf</span> et le boucler avec <span class="html">ngFor</span> :</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p *ngIf="pokemonSelected"&gt;
    Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}
&lt;/p&gt;
&lt;p *ngIf="!pokemonSelected"&gt;
    Aucun pokémon n'a pas été trouvé.
&lt;/p&gt;

&lt;p&gt;{{ pokemonList[0].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[1].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[2].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[3].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[4].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[5].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[6].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[7].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[8].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[9].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[10].name }}&lt;/p&gt;
&lt;p&gt;{{ pokemonList[11].name }}&lt;/p&gt;</code></pre>
                    <p>Attention, l'astéristique <span class="em">*</span> est très importante. Il faut pas oublier la mettre devant <span class="html">ngIf</span> et <span class="html">ngFor</span> ou même devant n'importe quelle autre directive structurelle.</p>
<pre><code>&lt;h1&gt;Liste de Pokémons&lt;/h1&gt;
&lt;input #input (keyup.enter)="selectPokemon(input.value)" type="number"&gt;
&lt;p *ngIf="pokemonSelected"&gt;
    Vous avez sélectionné le pokémon : {{ pokemonSelected?.name }}
&lt;/p&gt;
&lt;p *ngIf="!pokemonSelected"&gt;
    Aucun pokémon n'a pas été trouvé.
&lt;/p&gt;

&lt;p *ngFor="let pokemon of pokemonList"&gt;
    {{ pokemon.name }}
&lt;/p&gt;</code></pre>
                    <p>Pour la partie CSS de notre application, on peut intégrer dans notre fichier <span class="em">index.html</span> Materialize dans une balise <span class="html">link</span> :</p>
<pre><code>&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"&gt;</code></pre>
<pre><code>&lt;h1 class="center"&gt;&gt;Liste de Pokémons&lt;/h1&gt;

&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div *ngFor="let pokemon of pokemonList" class="col m4 s6"&gt;
            &lt;div class="card horizontal"&gt;
                &lt;div class="card-image"&gt;
                    &lt;img [src]="pokemon.picture"&gt;
                &lt;/div&gt;
                &lt;div class="card-stacked"&gt;
                    &lt;div class="card-content"&gt;
                        &lt;p&gt;{{ pokemon.name }}&lt;/p&gt;
                        &lt;p&gt;&lt;small&gt;{{ pokemon.created }}&lt;/small&gt;&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                </article>
                <article>
                    <h2 id="directives">Les directives :</h2>
                    <p>La première question à se poser, c'est qu'est-ce qu'une directive ? Une directive est une classe Angular qui ressemble beaucoup à un composant sauf qu'elle n'a pas de template. D'ailleurs, au sein du framework, la classe <span class="html">Component</span> hérite de la classe <span class="html">Directive</span>. Voici les trois types de directives qui existent :</p>
                    <ol>
                        <li>
                            <p>Les composants</p>
                        </li>
                        <li>
                            <p>Les directives d'attributs</p>
                        </li>
                        <li>
                            <p>Les directives structurelles</p>
                        </li>
                    </ol>
                    <p>On va créer une directive d'attribut pour notre application. Ce type de directive va nous permettre de changer l'apparence ou le comportement d'un élément.</p>
                    <p>Par exemple, on va créer la directive <span class="em">BorderCardDirective</span> qui, comme son nom l'indique, permettra d'ajouter une bordure de couleur sur les pokémons de notre liste lorsque l'utilisateur les survolera avec son curseur.</p>
                    <p>On va utiliser Angular CLI pour générer la directive avec la commande suivante :</p>
<pre><code>ng generate directive border-card</code></pre>
                    <p>Cette commande permet de créer le fichier <span class="em">border-card.directive.ts</span> et à modifier le fichier <span class="em">app.module.ts</span> pour déclarer la directive. Voici le code généré :</p>
<pre><code>import { Directive } from '@angular/core';

@Directive({
    selector: '[appBorderCard]'
})

export class BorderCardDirective {

    constructor() { }

}</code></pre>
                    <p>On va récupérer la card du pokémon à laquelle on rajoute la bordure dans le constructeur de notre directive :</p>
<pre><code>import { Directive, ElementRef } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

}</code></pre>
                    <p>Pour détecter un événement tel que le survol d'un élément, on va utiliser une nouvelle annotation nommée <span class="html">@HostListener</span> qui permet de lier notre directive à un élément donné :</p>
<pre><code>import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder('#009688');
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder('#F5F5F5');
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                    <p>Dans le template, on rajoute l'attribut <span class="em">pokemonBorderCard</span> dans notre <span class="html">div</span> contenant la card :</p>
<pre><code>&lt;div class="card horizontal" ... pokemonBorderCard&gt;</code></pre>
                    <p>Pour le moment, notre directive <span class="em">pokemonBorderCard</span> n'est pas personnalisable. À chaque utilisation, cette directive impose une couleur unique aux bordures. On va préciser une propriété d'entrée dans notre directive via l'annotation <span class="html">@Input</span> :</p>
<pre><code>import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    constructor(private el: ElementRef) {
        this.setBorder('#F5F5F5');
        this.setHeight(180);
    }

    @Input('pokemonBorderCard') borderColor: string;

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder(this.borderColor || '#009688');
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder('#F5F5F5');
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                    <p>Dans notre template, on remodifie la <span class="html">div</span> contenant notre card comme ceci afin que cette fois-ci la bordure soit <span class="em">red</span> au survol :</p>
<pre><code>&lt;div class="card horizontal" ... pokemonBorderCard="red"&gt;</code></pre>
                    <p>Il y a deux façons de déclarer une propriété d'entrée : avec ou sans alias. Voici la différence :</p>
<pre><code>@Input('pokemonBorderCard') borderColor: string; // avec alias
@Input() pokemonBorderCard: string; // sans alias</code></pre>
                    <p>Enfin, pour terminer le développement de notre directive, on va remplacer les valeurs entrées en dur par des propriétés telles que <span class="em">initialColor</span>, <span class="em">defaultColor</span> et <span class="em">defaultHeight</span>.</p>
<pre><code>import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
    selector: '[pokemonBorderCard]'
})

export class BorderCardDirective {

    private initialColor: string = 'F5F5F5';
    private defaultColor: string = '#009688';
    private defaultHeight: number = 180;

    constructor(private el: ElementRef) {
        this.setBorder(this.initialColor);
        this.setHeight(this.defaultColor);
    }

    @Input('pokemonBorderCard') borderColor: string;

    @HostListener('mouseenter') onMouseEnter() {
        this.setBorder(this.borderColor || this.defaultColor);
    }

    @HostListener('mouseleave') onMouseLeave() {
        this.setBorder(this.initialColor);
    }

    private setBorder(color: string) {
        this.el.nativeElement.style.border = `solid 4px ${color}`;
    }

    private setHeight(height: number) {
        this.el.nativeElement.style.height = `${height}px`;
    }

}</code></pre>
                </article>
                <article>
                    <h2 id="pipes">Les pipes :</h2>
                    <p>Maintenant, on va modifier la date affichée dans notre card pour qu'elle ait un bon format via le pipe (ou |).</p>
<pre><code>&lt;p&gt;&lt;small&gt;{{ pokemon.created | date }}&lt;/small&gt;&lt;/p&gt;</code></pre>
                    <p>Angular possède d'autres pipes disponibles dans tous nos templates tels que le <span class="html">DatePipe</span> qu'on vient d'utiliser, le <span class="html">UpperCasePipe</span>, le <span class="html">LowerCasePipe</span>, le <span class="html">CurrencyPipe</span> pour les devises, et le <span class="html">PercentPipe</span>.</p>
                    <p>On peut même combiner plusieurs pipes ensemble comme ceci par exemple :</p>
<pre><code>&lt;p&gt;&lt;small&gt;{{ pokemon.created | date | uppercase }}&lt;/small&gt;&lt;/p&gt;</code></pre>
                    <p>Attention, l'ordre des pipes est important. Cela se lit de la gauche vers la droite.</p>
                    <p>On peut également paramétrer notre pipe comme le format de la date par exemple :</p>
<pre><code>&lt;p&gt;&lt;small&gt;{{ pokemon.created | date:"dd/MM/yyyy" }}&lt;/small&gt;&lt;/p&gt;</code></pre>
                    <p>Angular permet de créer notre pipe personnalisé pour des besoins spécifiques à notre application. Par exemple, on va créer le pipe <span class="em">PokemonTypeColorPipe</span> dans notre application avec Angular CLI avec la commande suivante :</p>
<pre><code>ng generate pipe pokemon-type-color</code></pre>
                    <p>Cette commande crée un fichier <span class="em">pokemon-type-color.pipe.ts</span> et modifier le fichier <span class="em">app.module.ts</span> pour déclarer le pipe. Voici le contenu généré :</p>
<pre><code>import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
    name: 'pokemonTypeColor'
})

export class PokemonTypeColorPipe implements PipeTransform {
    
    transform(value: unknown, ...args: unknown[]): unknown {
        return null;
    }

}</code></pre>
                    <p>On va modifier le code généré afin d'implémenter la logique pour afficher la couleur correspondant au type du pokémon :</p>
<pre><code>import { Pipe, PipeTransform } from '@angular/core';

/*
* Affiche la couleur correspondant au type du pokémon.
* Prend en argument le type du pokémon.
* Exemple d'utilisation:
*   {{ pokemon.type | pokemonTypeColor }}
*/
@Pipe({
    name: 'pokemonTypeColor'
})

export class PokemonTypeColorPipe implements PipeTransform {

    transform(type: string): string {
    
        let color: string;
        
        switch (type) {
            case 'Feu':
                color = 'red lighten-1';
                break;
            case 'Eau':
                color = 'blue lighten-1';
                break;
            case 'Plante':
                color = 'green lighten-1';
                break;
            case 'Insecte':
                color = 'brown lighten-1';
                break;
            case 'Normal':
                color = 'grey lighten-3';
                break;
            case 'Vol':
                color = 'blue lighten-3';
                break;
            case 'Poison':
                color = 'deep-purple accent-1';
                break;
            case 'Fée':
                color = 'pink lighten-4';
                break;
            case 'Psy':
                color = 'deep-purple darken-2';
                break;
            case 'Electrik':
                color = 'lime accent-1';
                break;
            case 'Combat':
                color = 'deep-orange';
                break;
            default:
                color = 'grey';
                break;
        }
        
        return 'chip ' + color;
    }
}</code></pre>
                    <p>On va utiliser ce nouveau pipe dans notre template en rajoutant dans le contenu de la card la liste des types de chaque pokémon :</p>
<pre><code>&lt;span *ngFor="let type of pokemon.types" class="{{ type | pokemonTypeColor }}"&gt;
    {{ type }}
&lt;/span&gt;</code></pre>
                </article>
                <article>
                    <h2 id="routes">Les routes :</h2>
                    <p>Pour l'instant, notre application est assez limitée car elle est constituée d'un seul composant accessible par défaut au démarrage de l'application. Nous ne pouvons donc pas développer une application plus complexe avec plusieurs composants et une navigation avec des URLs différentes. Je vous propose de remédier à ce problème en dotant notre application d'un système de navigation digne de ce nom. La question <q>Comment mettre en place plusieurs pages dans mon application Angular ?</q> n'aura plus de secret pour vous.</p>
                    <p>Tout d'abord, vous devez savoir que le système de naviagtion fourni par Angular simule parfaitement la navigation auprès de votre navigateur.</p>
                    <p>Pour pouvoir mettre en place un système de navigation dans notre application, on va donc avoir besoin d'au moins deux composants. On va créer deux nouveaux composants via Angular CLI :</p>
<pre><code>ng generate component list-pokemon --inline-template=false</code></pre>
                    <p>Le paramètre <span class="html">--inline-template=false</span> de notre commande permet de séparer la vue de la logique de notre composant, c'est-dire que cette commande créera deux fichiers, <span class="em">list-pokemon.component.html</span> et <span class="em">list-pokemon.component.ts</span>, dans le dossier <span class="em">src/app/list-pokemon</span>. Il a déclaré ce composant dans notre <span class="em">app.module.ts</span>. On va créer le deuxième composant, <span class="em">detail-pokemon</span>, comme ceci :</p>
<pre><code>ng generate component detail-pokemon --inline-template=false</code></pre>
                    <p>On va déclarer les nouvelles routes dans le fichier <span class="em">app-routing.module.ts</span> :</p>
<pre><code>import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { ListPokemonComponent } from './list-pokemon/list-pokemon.component';
import { DetailPokemonComponent } from './detail-pokemon/detail-pokemon.component';

const routes: Routes = [
    { path: 'pokemons', component: ListPokemonComponent },
    { path: 'pokemon/:id', component: DetailComponent },
    { path: '', redirectTo: 'pokemons', pathMatch: 'full' }
];

@NgModule({
    imports: [RouterModule.forRoot(routes)],
    exports: [RouterModule]
})

export class AppRoutingModule { }</code></pre>
                    <p>Il nous manque un petit quelque chose pour mettre en place un système de routes avec nos deux composants. Pour commencer, ce qu'il faut comprendre, c'est que côté template, dans notre composant racine, on va devoir ajouter un élément qui s'appelle <span class="html">router-outlet</span> et qui va venir en fait permettre de relier les routes qu'on a définies avec notre template.</p>
                    <p>Donc, dans notre fichier <span class="em">app.component.html</span>, on va modifier son contenu comme ceci :</p>
<pre><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre>
                    <p>On va également modifier la logique du composant par défaut, <span class="em">AppComponent</span> :</p>
<pre><code>import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    templateUrl: 'app.component.html'
})

export class AppComponent {}</code></pre>
                    <p>On va modifier le composant et le template de notre liste de pokémons dans le dossier <span class="em">src/app/list-pokemon</span> :</p>
<pre><code>&lt;h1 class="center"&gt;Liste de Pokémons&lt;/h1&gt;

&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div *ngFor="let pokemon of pokemonList" class="col m4 s6"&gt;
            &lt;div class="card horizontal"&gt;
                &lt;div class="card-image"&gt;
                    &lt;img [src]="pokemon.picture"&gt;
                &lt;/div&gt;
                &lt;div class="card-stacked"&gt;
                    &lt;div class="card-content"&gt;
                        &lt;p&gt;{{ pokemon.name }}&lt;/p&gt;
                        &lt;p&gt;&lt;small&gt;{{ pokemon.created }}&lt;/small&gt;&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code>import { Component } from '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-list-pokemon',
    templateUrl: './list-pokemon.component.html'
})

export class ListPokemonComponent {

    pokemonList: Pokemon[] = POKEMONS;

}</code></pre>
                    <p>Enfin, on va modifier le template et le composant <span class="em">detail-pokemon</span> dans le dossier <span class="em">src/app/detail-pokemon</span> afin de le dynamiser :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { POKEMONS } from '../mock-pokemon-list';
import { Pokemon } from '../pokemon';

@Component({
    selector: 'app-detail-pokemon',
    templateUrl: './detail-pokemon.component.html'
})

export class DetailPokemonComponent implements OnInit {

    pokemonList: Pokemon[];
    pokemon: Pokemon|undefined;

    constructor(private route: ActivatedRoute) { }

    ngOnInit() {
        this.pokemonList = POKEMONS;
        const pokemonId: string|null = this.route.snapshot.paramMap.get('id');
        
        if (pokemonId) {
            this.pokemon = this.pokemonList.find(pokemon =&gt; pokemon.id == +pokemonId);
        }
    }

}</code></pre>
<pre><code>&lt;div *ngIf="pokemon" class="row"&gt;
    &lt;div class="col s12 m8 offset-m2"&gt;
        &lt;h2 class="header center"&gt;{{ pokemon.name }}&lt;/h2&gt;
        &lt;div class="card horizontal hoverable"&gt;
            &lt;div class="card-image"&gt;
                &lt;img [src]="pokemon.picture"&gt;
            &lt;/div&gt;
            &lt;div class="card-stacked"&gt;
                &lt;div class="card-content"&gt;
                    &lt;table class="bordered striped"&gt;
                        &lt;tbody&gt;
                            &lt;tr&gt;
                                &lt;td&gt;Nom&lt;/td&gt;
                                &lt;td&gt;&lt;strong&gt;{{ pokemon.name }}&lt;/strong&gt;&lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;td&gt;Points de vie&lt;/td&gt;
                                &lt;td&gt;&lt;strong&gt;{{ pokemon.hp }}&lt;/strong&gt;&lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;td&gt;Dégâts&lt;/td&gt;
                                &lt;td&gt;&lt;strong&gt;{{ pokemon.cp }}&lt;/strong&gt;&lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;td&gt;Types&lt;/td&gt;
                                &lt;td&gt;
                                    &lt;span *ngFor="let type of pokemon.types" class="{{ type | pokemonTypeColor }}"&gt;{{ type }}&lt;/span&gt;
                                &lt;/td&gt;
                            &lt;/tr&gt;
                            &lt;tr&gt;
                                &lt;td&gt;Date de création&lt;/td&gt;
                                &lt;td&gt;&lt;em&gt;{{ pokemon.created | date:"dd/MM/yyyy" }}&lt;/em&gt;&lt;/td&gt;
                            &lt;/tr&gt;
                        &lt;/tbody&gt;
                    &lt;/table&gt;
                &lt;/div&gt;
                &lt;div class="card-action"&gt;
                    &lt;a&gt;Retour&lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;h2 *ngIf='!pokemon' class="center"&gt;Aucun pokémon à afficher !&lt;/h2&gt;</code></pre>
                    <p>On va maintenant voir comment relier les deux composants entre eux et la page d'erreur 404 lorsqu'on arrive sur une URL inconnue. Pour commencer, on va ajouter une barre de navigation dans le template de notre composant par défaut :</p>
<pre><code>&lt;nav&gt;
    &lt;div class="now-wrapper teal"&gt;
        &lt;a href="#" class="brand-logo center"&gt;
            Pokédex
        &lt;/a&gt;
    &lt;/div&gt;
&lt;/nav&gt;

&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre>
                    <p>Deuxièmement, on va rajouter un click sur le bouton "Retour" du composant <span class="em">detail-pokemon</span> :</p>
<pre><code>&lt;a (click)="goToPokemonList()"&gt;Retour&lt;/a&gt;</code></pre>
                    <p>Comme la méthode <span class="em">goToPokemonList</span> n'existe pas, il faut la rajouter dans la logique du composant :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { POKEMONS } from '../mock-pokemon-list';
import { Pokemon } from '../pokemon';

@Component({
    selector: 'app-detail-pokemon',
    templateUrl: './detail-pokemon.component.html'
})

export class DetailPokemonComponent implements OnInit {

    pokemonList: Pokemon[];
    pokemon: Pokemon|undefined;

    constructor(private route: ActivatedRoute, private router : Router) { }

    ngOnInit() {
        this.pokemonList = POKEMONS;
        const pokemonId: string|null = this.route.snapshot.paramMap.get('id');
        
        if (pokemonId) {
            this.pokemon = this.pokemonList.find(pokemon =&gt; pokemon.id == +pokemonId);
        }
    }

    goToPokemonList() {
        this.router.navigate(['/pokemons']);
    }

}</code></pre>
                    <p>Troisièmement, on va ajouter un click sur la card d'un pokémon pour accéder à son détail. Cette-fois-ci, on commence par la logique du composant :</p>
<pre><code>import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Component({
    selector: 'app-list-pokemon',
    templateUrl: './list-pokemon.component.html'
})

export class ListPokemonComponent {

    pokemonList: Pokemon[] = POKEMONS;

    constructor(private router: Router) {}

    goToPokemon(pokemon: Pokemon) {
        this.router.navigate(['/pokemon', pokemon.id]);
    }

}</code></pre>
<pre><code>&lt;div class="card horizontal" pokemonBorderCard (click)="goToPokemon(pokemon)"&gt;</code></pre>
                    <p>La toute dernière chose à faire niveau route est de gérer les erreurs 404. On va créer un nouveau composant <span class="em">page-not-found</span> via Angular CLI :</p>
<pre><code>ng generate component page-not-found</code></pre>
                    <p>Cette commande nous a créé le fichier <span class="em">page-not-found.component.ts</span> avec le contenu qu'on va modifier :</p>
<pre><code>import { Component } from '@angular/core';

@Component({
    selector: 'app-page-not-found',
    template: `
        &lt;div class="center"&gt;
            &lt;img src="http://assets.pokemons.com/cms2/img/pokemon/full/035.png"&gt;
            &lt;h1&gt;Hey, cette page n'existe pas !&lt;/h1&gt;
            &lt;a routerLink="/pokemons" class="waves-effect waves-teal btn-flat"&gt;
                Retourner à l'accueil
            &lt;/a&gt;
        &lt;/div&gt;
    `,
    styles: []
})

export class PageNotFoundComponent { }</code></pre>
                    <p>Dans notre fichier de routage, <span class="em">app-routing.module.ts</span>, on rajoute cette route par défaut :</p>
<pre><code>{ path '**', component: PageNotFoundComponent }</code></pre>
                </article>
                <article>
                    <h2 id="modules">Les modules :</h2>
                    <p>Les applications Angular sont modulaires et possèdent leurs propres systèmes de modules.</p>
                    <p>Chaque application possède au minimum un module : c'est le module racine qui est nommé <span class="em">app.module</span> par convention.</p>
                    <p>La plupart des projets ont besoin de plusieurs modules. On parle souvent de modules de fonctionnalités car, pour chaque fonctionnalité dans le projet, on va rajouter un nouveau module.</p>
                    <p>Un module de fonctionnalités est un ensemble de classes et d'éléments lié à un domaine spécifique de votre application.</p>
                    <p>Quelque soit la nature du module, un module est toujours une classe avec le décorateur <span class="html">@NgModule</span>. Par exemple, voici le code de <span class="em">app.module.ts</span> :</p>
<pre><code>import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';

import { AppComponent } from './app.component';
import { ListPokemonComponent } from './list-pokemon.component';
import { DetailPokemonComponent } from './detail-pokemon.component';
import { PageNotFoundComponent } from './page-not-found.component';

import { BorderCardDirective } from './border-card.directive';
import { PokemonTypeColorPipe } from './pokemon-type-color.pipe';

@NgModule({
    imports: [BrowserModule, AppRoutingModule],
    declarations: [
        AppComponent,
        BorderCardDirective,
        PokemonTypeColorPipe,
        ListPokemonComponent,
        DetailPokemonComponent,
        PageNotFoundComponent
    ],
    bootstrap: [AppComponent]
})

export class AppModule { }</code></pre>
                    <p>Dans la propriété <span class="html">declarations</span> de <span class="html">@NgModule</span>, on met dans un tableau les classes de vues qui appartiennent à ce module. Angular a trois types de classes de vues : les <span class="em">composants</span>, les <span class="em">directives</span> et les <span class="em">pipes</span>.</p>
                    <p>Il existe également la propriété <span class="html">exports</span> de <span class="html">@NgModule</span> qui contient un sous-ensemble de classes de vues à exporter dans des templates de composant d'autres modules.</p>
                    <p>La propriété <span class="html">imports</span> de <span class="html">@NgModule</span> contient toutes les classes exportées depuis d'autres modules qu'on a besoin dans ce module-ci.</p>
                    <p>La propriété <span class="html">providers</span> de <span class="html">@NgModule</span> concerne les services et l'injection de dépendances qu'on traitera un peu plus tard dans ce cours.</p>
                    <p>La propriété <span class="html">bootstrap</span> de <span class="html">@NgModule</span> concerne que le module racine pour y renseigner le composant racine, c'est-à-dire le composant qui sera affiché au lancement de l'application.</p>
                    <p>JavaScript a son propre système de modules qui complètement différent et sans rapport avec le système de modules d'Angular.</p>
                    <p>En JavaScript, chaque fichier est un module et tous les objets définis dans ce fichier appartiennent au module. Le module JavaScript déclare certains objes <span class="html">public</span> en les déclarant avec le mot-clé <span class="html">export</span>. Ensuite, d'autres modules JavaScript utilise le mot-clé <span class="html">import</span> pour accéder à ces objets.</p>
                    <p>C'est ce mécanisme que l'on utilise lorsqu'on fait par exemple <span class="html">export class AppComponent</span> et qu'ensuite, ailleurs dans notre application, nous faisons <span class="html">import AppComponent from ...</span>.</p>
                    <p>Les systèmes de modules de JavaScript et d'Angular sont différents mais complémentaires et nous utilisons bien les deux pour écrire notre application.</p>
                    <p>Passons maintenant à la pratique ! On va créer un nouveau module Angular permettant de centraliser tous les éléments qui concernent la gestion des Pokémons dans notre application.</p>
                    <p>Pour créer ce module <span class="em">pokemon</span>, on va utiliser Angular CLI avec la commande :</p>
<pre><code>ng generate module pokemon</code></pre>
                    <p>Cette commande a permis de créer un fichier <span class="em">src/app/pokemon/pokemon.module.ts</span>. On va déplacer tous les éléments que nous avons déjà développés dans le dossier du module et de venir brancher ces éléments dans le <span class="html">@NgModule</span> du nouveau module.</p>
                    <p>Donc, on a le composant qui permet d'afficher la liste des Pokémons. On a celui qui qui affiche le détail de la liste des Pokémons. On a aussi développé un pipe pour la coloration des types. On a également une directive : la <span class="em">BorderCardDirective</span>. Puis, on a le modèle <span class="em">pokemon.ts</span> et le fichier de mock, <span class="em">mock-pokemon-list.ts</span>.</p>
                    <p>On va mettre à jour les importations dans chaque fichier pour que les chemins relatifs de nos fichiers sont bien corrects vu qu'on a déplacer tous nos éléments liés à nos pokémons.</p>
                    <p>Normalement, on doit couper <span class="html">ng serve</span> avant les modifications et le relancer juste après.</p>
                    <p>Dans notre nouveau module, on voit qu'Angular a par défaut importer le <span class="html">CommonModule</span> de <span class="html">@angular/common</span> qui est, en fait, une base que vous allez avoir besoin dans n'importe quel module et qui comprend par exemple les directives structurelles <span class="html">ngIf</span> et <span class="html">ngFor</span>, c'est-à-dire que, dans tous nos composants rattachés à ce module, vous pourrez utiliser ces directives sans avoir à les importer.</p>
                    <p>Dans les <span class="em">declarations</span> de notre module, on va rajouter nos deux composants, notre directive et notre pipe pour pouvoir les utiliser dans le <span class="em">PokemonModule</span>. L'intérêt de les déclarer dans ce module et pas à la racine est que ce sont des éléments que l'on a besoin qu'au niveau de la fonctionnalité des Pokémons.</p>
                    <p>Voici donc le contenu de notre fichier <span class="em">pokemon.module.ts</span> une fois que tous les éléments ont été déclarés :</p>
<pre><code>import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ListPokemonComponent } from './list-pokemon.component';
import { DetailPokemonComponent } from './detail-pokemon.component';
import { BorderCardDirective } from './border-card.directive';
import { PokemonTypeColorPipe } from './pokemon-type-color.pipe';

@NgModule({
    declarations: [
        BorderCardDirective,
        PokemonTypeColorPipe,
        ListPokemonComponent,
        DetailPokemonComponent
    ],
    imports: [
        CommonModule
    ]
})

export class PokemonModule { }</code></pre>
                    <p>Puis, on va venir déclarer les routes propres à la fonctionnalité des Pokémons et bien directement au niveau de ce module plutôt que de passer par les routes racines.</p>
                    <p>Donc, dans notre <span class="em">app-routing.module.ts</span>, on va supprimer les deux routes liées aux Pokémons. Dans notre module, <span class="em">pokemon.module.ts</span>, on va déclarer ces routes supprimées :</p>
<pre><code>import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ListPokemonComponent } from './list-pokemon.component';
import { DetailPokemonComponent } from './detail-pokemon.component';
import { BorderCardDirective } from './border-card.directive';
import { PokemonTypeColorPipe } from './pokemon-type-color.pipe';
import { RouterModule, Routes } from '@angular/router';

const pokemonRoutes: Routes = [
    { path: 'pokemons', component: ListPokemonComponent },
    { path: 'pokemon/:id', component: DetailPokemonComponent }
];

@NgModule({
    declarations: [
        BorderCardDirective,
        PokemonTypeColorPipe,
        ListPokemonComponent,
        DetailPokemonComponent
    ],
    imports: [
        CommonModule,
        RouterModule.forChild(pokemonRoutes)
    ]
})

export class PokemonModule { }</code></pre>
                    <p>On va importer notre <span class="em">PokemonModule</span> dans notre module racine comme ceci :</p>
<pre><code>import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { PageNotFoundComponent } from './page-not-found.component';
import { PokemonModule } from './pokemon/pokemon.module';

@NgModule({
    declarations: [
        AppComponent,
        PageNotFoundComponent
    ],
    imports: [
        BrowserModule,
        PokemonModule,
        AppRoutingModule
    ],
    providers: [],
    bootstrap: [AppComponent]
})

export class AppModule { }</code></pre>
                    <p>Voilà toutes les modifications sont finies. On va relancer notre <span class="html">ng serve</span>. Attention à l'ordre des routes car, si on met le <span class="em">AppRoutingModule</span> avant le <span class="em">PokemonModule</span>, on arrivera tout le temps sur la page d'erreurs 404.</p>
                    <p>Je vous propose maintenant de réfléchir à l'architecture finale de notre application. Nous voulons créer un simple gestionnaire de Pokémon qui permettra à l'utilsiateur de se connecter et de modifier les Pokémons à sa guise. On va devoir créer un <span class="em">LoginComponent</span> à la racine de notre application pour permettre à l'utilisateur de se connecter.</p>
                    <p>Ce que nous aurions pu faire depuis le début, c'est anticiper la conception de notre application en déterminant quelles fonctionnalités allaient dans quel module.</p>
                </article>
                <article>
                    <h2 id="services">Les services :</h2>
                    <p>On va enrichir notre application avec des services. Nos deux composants vont avoir besoin d'accéder au Pokémon et d'effectuer des opérations dessus. Nous allons donc centraliser ces données et ces opérations dans un service. Ce service sera utilisavle pour tous les composants du <span class="em">PokemonModule</span> afin de leur fournir un accès et des méthodes prêtes à l'emploi pour gérer les Pokémons.</p>
                    <p>Nous allons créer un service qui s'occupe de fournir des données et des méthodes pour gérer nos Pokémons à tous les composants de notre <span class="em">PokemonModule</span>. L'objectif est de masquer à nos composants la façon dont nous récupérons les données et le fonctionnement interne de certaines méthodes. Puis, ça va nous permettre aussi de factoriser des comportements communs entre plusieurs composants.</p>
                    <p>On va utiliser Angular CLI pour générer notre service avec la commande suivante :</p>
<pre><code>ng generate service pokemon/pokemon</code></pre>
                    <p>Cette commande va créer le fichier <span class="em">src/app/pokemon.pokemon.service.ts</span> avec le contenu suivant :</p>
<pre><code>import { Injectable } form '@angular/core';

@Injectable({
    providedIn: 'root'
})

export class PokemonService {

    constructor() { }

}</code></pre>
                    <p>Dans ce code, on voit pas de décorateur nommé <span class="html">@Service</span> comme on aurait pu penser comme les pipes ou les directives. On a la place le décoration <span class="html">@Injectable</span> qui permet d'indiquer à Angular que notre service <span class="em">PokemonService</span> peut lui-même avoir d'autres dépendances.</p>
                    <p>Même si pour l'instant notre service n'a pas de dépendances, on doit quand même ajouter ce décorateur pour venir en fait brancher ce service avec le mécanisme d'injection de dépendances d'Angular.</p>
                    <p>Cela va nous permettre à la fois d'utiliser ce service ailleurs dans notre application et de venir importer dans ce service d'autres services. Pour rappel, on pouvait injecter des services dans les constructeurs de nos composants grâce à <span class="html">@Injectable</span>.</p>
                    <p>La propriété <span class="html">providedIn</span> du décorateur avec la valeur <span class="em">root</span> va permettre d'indiquer à Angular qu'on veut utiliser la même instance du service à travers toute l'application. C'est-à-dire qu'on va jamais créer une instance du <span class="em">PokemonService</span> en faisant un <span class="em">new PokemonService()</span> nous-même.</p>
                    <p>Nos composants ont aussi des dépendances et pourtant on écrit <span class="html">@Component</span> et non <span class="html">@Injectable</span> car, en fait, le <span class="html">@Injectable</span> est déjà caché dans le <span class="html">@Component</span>.</p>
                    <p>On va créer un service avec des vraies méthodes qui va nous service ailleurs dans notre application. On va soulager nos composants en utilisant les méthodes que l'on va écrire dans notre service. L'avantage de ces méthodes vont pouvoir être utilisées à la fois par le <span class="em">ListPokemonComponent</span> et également par le <span class="em">DetailPokemonComponent</span>.</p>
                    <p>Dans notre <span class="em">PokemonService</span>, on va créer trois méthodes : <span class="em">getPokemonList()</span> qui, comme son nom l'indique, renverra la liste des Pokémons, <span class="em">getPokemonById(id)</span> qui renverra, comme son nom l'indique, le Pokémon selon l'id et <span class="em">getPokemonTypeList()</span> qui renverra en fait tous les types de Pokémon qui sont autorisés dans l'application :</p>
<pre><code>import { Injectable } form '@angular/core';
import { POKEMONS } from './mock-pokemon-list';
import { Pokemon } from './pokemon';

@Injectable({
    providedIn: 'root'
})

export class PokemonService {

    getPokemonList(): Pokemon[] {
        return POKEMONS;
    }

    getPokemonById(pokemonId: number): Pokemon|undefined {
        return POKEMONS.find(pokemon =&gt; pokemon.id == pokemonId);
    }

    getPokemonTypeList(): string[] {
        return [
            'Plante',
            'Feu',
            'Eau',
            'Insecte',
            'Normal',
            'Electrik',
            'Poison',
            'Fée',
            'Vol',
            'Combat',
            'Psy'
        ];
    }

}</code></pre>
                    <p>On va voir maintenant comment injecter ce service dans nos composants pour utiliser qu'on vient de créer. Voici la modification du contenu de <span class="em">list-pokemon.component.ts</span> :</p>
<pre><code>import { Component, OnInit } from '@angular/core;
import { Router } from '@angular/router';
import { Pokemon } from '../pokemon';
import { PokemonService } from '../pokemon.service';

@Component({
    selector: 'app-list-pokemon',
    templateUrl: './list-pokemon.component.html'
})

export class ListPokemonComponent implements OnInit {
    
    pokemonList: Pokemon[];

    constructor(
        private router: Router,
        private pokemonService: PokemonService
    ) { }

    ngOnInit() {
        this.pokemonList = this.pokemonService.getPokemonList();
    }

    getPokemonTypeList(pokemon: Pokemon) {
        this.router.navigate(['/pokemon', pokemon.id]);
    }
}</code></pre>
                    <p>On va aussi modifier le contenu de <span class="em">detail-pokemon.component.ts</span> :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Pokemon } from '../pokemon';
import { PokemonService } from '../pokemon.service';

@Component({
    selector: 'app-detail-pokemon',
    templateUrl: './detail-pokemon.component.html'
})

export class DetailPokemonComponent implements OnInit {
    
    pokemon: Pokemon|undefined;

    constructor(
        private route: ActivatedRoute,
        private router: Router,
        private pokemonService: PokemonService
    ) { }

    ngOnInit() {
        const pokemonId: string|null = this.route.snapshot.paramMap.get('id');
        
        if (pokemonId) {
            this.pokemon = this.pokemonService.getPokemonById(+pokemonId);
        }
    }

    goToPokemonList() {
        this.router.navigate(['/pokemons']);
    }
}</code></pre>
                    <p>Enfin, on va voir comment délimiter un espace dans notre application dans lequel le service sera disponible. Angular dispose de son propre framework d'injections. On ne peut pas développer cette application sans cet outil.</p>
                    <p>L'injection de dépendances est un modèle de développement ou <span class="em">design pattern</span> en anglais dans lequel chaque classe reçoit ses dépendances d'une source externe ou en les créant elle-même.</p>
                    <p>Si on veut que notre <span class="em">PokemonService</span> soit uniquement lié à notre <span class="em">PokemonModule</span> et non à toute notre application, on va supprimer la propriété <span class="html">providedIn</span> du <span class="html">@Injectable()</span> de notre service et rajouter notre service dans le tableau de la propriété <span class="html">providers</span> du <span class="html">@NgModule</span> de notre module.</p>
                    <p>On peut égalemnt fournir notre service au niveau de nos composants directement. Cela a peu d'intérêt car, si on fait cela, chaque composant aura une instance différente de notre service donc on perd un peu le <span class="em">pattern Singleton</span>. On peut utiliser la propriété <span class="html">providers</span> dans <span class="html">@Component</span>. On utilise rarement ce code mais il faut juste savoir qu'il existe.</p>
                </article>
                <article>
                    <h2 id="formulaires">Les formulaires :</h2>
                    <p>Les formulaires sont omnis présents dans les applications. Cependant, la gestion des formulaires a souvent été complexe. Entre le traitement des données de l'utilisateur, la validation, l'affichae de messages d'erreur ou de succès, il faut souvent beaucoup de travail aux développeurs pour offrir une expérience complète et agréable aux utilisateurs.</p>
                    <p>Heureusement, Angular peut nous permettre de créer des formulaires et nous faciliter le travail.</p>
                    <p>On va créer un formulaire qui va permettre à un utilisateur de modifier un pokémon avec un bouton "éditer" sur la fiche du pokémon en question.</p>
                    <p>Lorsque vous souhaitez créer un formulaire avec Angular, vous avez la possibilité d'utiliser deux modules différents : <span class="html">Form</span> et <span class="html">ReactiveForm</span>. Ils répondent au même besoin mais avec une approche différente.</p>
                    <p>Le premier, le <span class="html">FormsModule</span>, développe une partie importante du formulaire dans le template. On parle de <span class="Em">template-drive form</span>.</p>
                    <p>Le second, le <span class="html">ReactiveFormsModule</span>, est plus centré sur le développeement du formulaire côté composant.</p>
                    <p>Il n'y a pas une méthode mieux qu'une autre dans l'absolu. Cependant, le <span class="html">FormsModule</span> est plus adapté pour les petits formulaires et pour les débutants. Pour information, ces deux modules proviennent de la même librairie : <span class="html">@angular/forms</span>.</p>
                    <p>Avant d'aborder le vif du sujet, il y a deux directives que je dois vous présenter : <span class="html">ngForm</span> et <span class="html">ngModel</span>. Ces deux directives proviennent du <span class="html">FormsModule</span>.</p>
                    <p>Pour chaque formulaire où la directive <span class="html">ngForm</span> est appliquée, elle va créer une instance d'un objet nommé <span class="html">FormGroup</span> au niveau global du formulaire. En tout cas, sachez qu'une référence à cette directive nous permet de savoir si le formulaire que remplit l'utilisateur est valide ou non au fur et à mesure que l'utilisateur complète ce formulaire. De plus, on peut être notifié lorsque l'utilisateur déclenchera la soumission du formulaire.</p>
                    <p>La directive <span class="html">ngModel</span> doit s'appliquer sur chacun des champs du formulaire et ce pour plusieurs raisons. Premièrement, cette directive créera une instance d'un objet nommé <span class="html">FormControl</span> pour chaque champ de votre formulaire comme par exemple <span class="html">input</span> ou <span class="html">select</span>. Ensuite, chaque instance de <span class="html">FormControl</span> constituera une brique élémentaire du formulaire qui encapsulera l'état donné d'un champ. Il a pour rôle de traquer la valeur du champ, les interactions avec l'utilisateur, la validité des données saisies et de garder la vue synchronisée avec les données. Troisièmement, chaque <span class="html">FormControl</span> doit être définie avec un nom et, pour cela, il suffit d'ajouter l'attribut <span class="html">name</span> à la balise HTML associée. Quatrièmement, lorsque cette directive est utilisée au sein d'une balise <span class="html">&lt;form&gt;</span>, la directive s'occuper pour nous de l'enregistrer auprès du formulaire comme un élément fils de ce formulaire.</p>
                    <p>En combinant ces deux directives, on peut donc savour en temps réel si le formulaire est valide ou non. Enfin, dernier point, on peut aussi utiliser la directive <span class="html">ngModelGroup</span> pour créer des sous-groupes de champs à l'intérieur du formulaire.</p>
                    <p>En plus, la directive <span class="html">ngModel</span> s'occupe de mettre en place une liaison de données bidirectionnelle pour chacun des champs du formulaire. On aura souvent de cette liaison pour gérer les interactions de l'utilisateur côté template et traiter les données saisies côté composant. Ce n'est pas tout car cette directive s'occupe également d'ajouter ou de retirer des classes spécifiques sur chaque champ. Nous pouvons ainsi savoir si l'utilisateur a cliqué sur un champ, si la valeur du champ a changé ou s'il est devenu invalide. En fonction de ces informations, nous pourrons changer l'apparence d'un champ et faire apparaître un message d'erreur ou de succès à l'utilisateur.</p>
                    <p>On va devoir injecter le <span class="html">FormsModule</span> dans notre module racine pour rendre utilisable ces deux directives dans nos composants. Attention à l'ordre des importations même si ça change presque rien mais on préfère nos propres modules en tout dernier et ceux de Angular en premier, c'est-à-dire que le <span class="html">FormsModule</span> doit être entre le <span class="html">BrowserModule</span> et le <span class="html">PokemonModule</span>. On va également l'importer dans notre <span class="em">PokemonModule</span> malgré qu'il est importé à la racine.</p>
                    <p>On doit savoir ce qu'on avoir besoin dans ce formulaire avant de créer celui-ci. Le formulaire que l'on va créer en premier va permettre d'éditer certaines propriétés d'un Pokémon, c'est-à-dire que l'id et la date de création d'un pokémon ne sont appelés à être modifier.</p>
                    <p>Un truc à prendre en compte est que notre formulaire sera un composant à part entière chargé de gérer les données saisies par l'utilisateur et qui permettra d'éditer un Pokémon.</p>
                    <p>Nous allons découper le template et le composant du formulaire dans deux fichiers séparés dans le dossier <span class="em">src/app/pokemon/pokemon-form</span> : <span class="em">pokemon-form.component.ts</span> et <span class="em">pokemon-form.component.html</span>. Pour créer ces fichiers, on utilise Angular CLI avec la commande :</p>
<pre><code>ng generate component pokemon/pokemon-form --inline-template=false</code></pre>
                    <p>Suite à cette commande, ce composant nouvellement créé est déclaré dans le <span class="em">PokemonModule</span>. Voici le contenu du template de notre formulaire :</p>
<pre><code>&lt;form *ngIf="pokemon" (ngSubmit)="onSubmit()" #pokemonForm="ngForm"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col s8 offset-s2"&gt;
            &lt;div class="card-panel"&gt;
        
                &lt;!-- Pokemon name --&gt;
                &lt;div class="form-group"&gt;
                    &lt;label for="name"&gt;Nom&lt;/label&gt;
                    &lt;input type="text" class="form-control" id="name" required pattern="^[a-zA-Z0-9àéèç]{1,25}$" [(ngModel)]="pokemon.name" name="name" #name="ngModel"&gt;
                    &lt;div [hidden]="name.valid || name.pristine" class="card-panel red accent-1"&gt;
                        Le nom du pokémon est requis (1-25).
                    &lt;/div&gt;
                &lt;/div&gt;
            
                &lt;!-- Pokemon hp --&gt;
                &lt;div class="form-group"&gt;
                    &lt;label for="hp"&gt;Point de vie&lt;/label&gt;
                    &lt;input type="number" class="form-control" id="hp" required pattern="^[0-9]{1,3}$" [(ngModel)]="pokemon.hp" name="hp" #hp="ngModel"&gt;
                    &lt;div [hidden]="hp.valid || hp.pristine" class="card-panel red accent-1"&gt;
                        Les points de vie du pokémon sont compris entre 0 et 999.
                    &lt;/div&gt;
                &lt;/div&gt;
            
                &lt;!-- Pokemon cp --&gt;
                &lt;div class="form-group"&gt;
                    &lt;label for="cp"&gt;Dégâts&lt;/label&gt;
                    &lt;input type="number" class="form-control" id="cp" required pattern="^[0-9]{1,2}$" [(ngModel)]="pokemon.cp" name="cp" #cp="ngModel"&gt;
                    &lt;div [hidden]="cp.valid || cp.pristine" class="card-panel red accent-1"&gt;
                        Les dégâts du pokémon sont compris entre 0 et 99.
                    &lt;/div&gt;
                &lt;/div&gt;
            
                &lt;!-- Pokemon types --&gt;
                &lt;form class="form-group"&gt;
                    &lt;label for="types"&gt;Types&lt;/label&gt;
                    &lt;p *ngFor="let type of types"&gt;
                    &lt;label&gt;
                        &lt;input type="checkbox" class="filled-in" id="{{ type }}" [value]="type" [checked]="hasType(type)" [disabled]="!isTypesValid(type)" (change)="selectType($event, type)"&gt;
                        &lt;span [attr.for]="type"&gt;
                            &lt;div class="{{ type | pokemonTypeColor }}"&gt;
                                {{ type }}
                            &lt;/div&gt;
                        &lt;/span&gt;
                    &lt;/label&gt;
                    &lt;/p&gt;
                &lt;/form&gt;
            
                &lt;!-- Submit button --&gt;
                &lt;div class="divider"&gt;&lt;/div&gt;
                &lt;div class="section center"&gt;
                    &lt;button type="submit" class="waves-effect waves-light btn" [disabled]="!pokemonForm.form.valid"&gt;
                        Valider
                    &lt;/button&gt;
                &lt;/div&gt;

            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;h2 *ngIf="!pokemon" class="center"&gt;Aucun pokémon à éditer...&lt;/h2&gt;</code></pre>
                    <p>On va maintenant implémenter la logique dans le fichier <span class="em">pokemon-form.component.ts</span> comme ceci :</p>
<pre><code>import { Component, OnInit, Input } from '@angular/core';
import { Router } from '@angular/router';
import { Pokemon } from '../pokemon';
import { PokemonService } from '../pokemon.service';

@Component({
    selector: 'app-pokemon-form',
    templateUrl: './pokemon-form.component.html',
    styleUrls: [
    ]
})

export class PokemonFormComponent implements OnInit {

    @Input() pokemon: Pokemon;
    pokemonTypeList: string[];

    constructor(
        private pokemonService: PokemonService,
        private router: Router
    ) { }

    ngOnInit() {
        this.pokemonTypeList = this.pokemonService.getPokemonTypeList();
    }

    hasType(type: string): boolean {
        return this.pokemon.types.includes(type);
    }

    selectType($event: Event, type: string) {
        const isChecked: boolean = ($event.target as HTMLInputElement).checked;

        if (isChecked) {
            this.pokemon.types.push(type);
        } else {
            const index = this.pokemon.types.indexOf(type);
            this.pokemon.types.splice(index, 1);
        }
    }

    onSubmit() {
        console.log('Submit Form !');
        this.router.navigate(['/pokemon', this.pokemon.id]);
    }

}</code></pre>
                    <p>L'évenement <span class="html">ngSubmit</span> dans notre formulaire est un évenement généré par Angular qui est construit par dessus l'évenement <span class="html">submit</span> natif du DOM dans le navigateur, mais qui fait exactement la même chose, c'est-à-dire ça déclenche cette méthode lorsque l'utilisateur va soumettre notre formulaire.</p>
                    <p>Le <span class="em">#pokemonForm="ngForm"</span> est une variable référencée par le template vers mon élément du DOM (ici, c'est <span class="html">form</span>) à laquelle j'attribue le résultat de la directive <span class="html">ngForm</span>. Cette variable va devenir un objet géré par Angular avec juste beaucoup d'informations que juste la balise HTML 5. Par exemple, ça va nous permettre d'avoir accès à l'état de validité du formulaire en temps réel.</p>
                    <p>On va lier nos attributs HTML 5 de validation de nos champs à Angular pour qu'il sache en temps réel que le champ est valide ou non en se basant sur ces règles de validation HTML 5.</p>
                    <p>La partie <span class="em">[(ngModel)]="pokemon.name"</span> contient à la fois des crochets, c'est-à-dire du property binding qui permet de pousser des données de la classe du composant vers le template, et, en même temps, on a aussi des parenthèses qui est la syntaxe de liaison d'évenements, c'est-à-dire pour remonter des évenements du template du composant vers sa classe. Donc, en combinaisant les deux, c'est-à-dire avec cette syntaxe crochet et à l'intérieur des parenthèses, ça nous permet de mettre en place une liaison de données bidirectionnelle. Quand l'utilisateur va modifier le nom d'un Pokémon, on va être informé de ça côté composant et, du côté composant, si on pilote le Pokémon et son nom, la vue va aussi se mettre à jour automatiquement.</p>
                    <p>Le <span class="html">.pristine</span> veut dire que le champ n'a pas été touché ou n'a pas encore été bougé par l'utilisateur. Par exemple, au chargement du formulaire, on pourrait avoir un champ vide où on attend que l'utilisateur rentre quelque chose et même si le champ vide n'est pas une donnée valide puisque c'est <span class="html">required</span>.</p>
                    <p>Dans notre template, le <span class="html">isTypesValid(type)</span> de nos checkbox est en rouge dans Visual Studio Code car cette méthode n'a pas encore été implémentée dans notre composant car on a pas encore regardé la validation du formulaire.</p>
                    <p>Avant de comment ajouter les règles de validation, je vous propose de définir quelle restruction nous souhaitons implémenter sur chaque champ. On a les attributs HTML 5 <span class="html">required</span> et <span class="html">pattern</span> qui permet de rendre les champs obligatoires et utilisant une certaine expression régulière.</p>
                    <p>Comme on n'aura pas recours aux attributs HTML 5 pour la validation des types, on va devoir définir une méthode de validation côté composant :</p>
<pre><code>isTypesValid(type: string): boolean {
    
    if (this.pokemon.types.length == 1 &amp;&amp; thiS.hasType(type)) {
        return false;
    }

    if (this.pokemon.types.length &gt; 2 &amp;&amp; !this.hasType(type)) {
        return false;
    }

    return true;
}</code></pre>
                    <p>Pour les messages d'erreur ou de succès, il faut rajouter à notre composant au minimum une feuille de style, c'est-à-dire un fichier CSS. On va devoir créer un fichier et puis, on devra rajoute la propriété <span class="html">styleUrls</span> à notre <span class="html">@Component</span> comme ceci :</p>
<pre><code>@Component({
    selector: 'app-pokemon-form',
    templateUrl: './pokemon-form.component.html',
    styleUrls: ['./pokemon-form.component.css']
})</code></pre>
                    <p>Voici le contenu de notre fichier CSS en interceptant les classes fournies par Angular :</p>
<pre><code>.ng-valid[required] {
    border-left: 5px solid #42A948;
}

.ng-invalid:not(form) {
    border-left: 5px solid #A94442;
}</code></pre>
                    <p>Cela permet de mettre sur nos champs une bordure à gauche en vert ou en rouge selon la validation de chaque champs.</p>
                    <p>On va intégrer notre formulaire dans les routes de notre module afin d'y accéder et aussi créer un bouton "Éditer" dans le détail d'un pokémon pour y accéder. Pour faire cela, on va créer un nouveau composant <span class="em">EditPokemonComponent</span> qui va matcher à la route qu'on va créer avec Angular CLI avec la commande suivante :</p>
<pre><code>ng generate component pokemon/edit-pokemon</code></pre>
                    <p>Cette commande créera le fichier <span class="em">src/app/pokemon/edit-pokemon/edit-pokemon.component.ts</span> dont on va modifier le contenu comme ci-dessous :</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Pokemon } from '../pokemon';
import { PokemonService } from '../pokemon.service';

@Component({
    selector: 'app-edit-pokemon',
    template: `
        &lt;h1 class="center"&gt;Éditer {{ pokemon?.name }}&lt;/h1&gt;
        &lt;p *ngIf="pokemon" class="center"&gt;
            &lt;img [src]=pokemon.picture"&gt;
        &lt;/p&gt;
        &lt;app-pokemon-form *ngIf="pokemon" [pokemon]="pokemon"&gt;&lt;/app-pokemon-form&gt;
    `,
    styles: [
    ]
})

export class EditPokemonComponent implements OnInit {
    
    pokemon: Pokemon|undefined;

    constructor(
        private route: ActivatedRoute,
        private pokemonService: PokemonService
    ) { }

    ngOnInit() {
        const pokemonId: string|null = this.route.snapshot.paramMap.get('id');

        if (pokemonId) {
            this.pokemon = this.pokemonService.getPokemonById(+pokemonId);
        }
    }

}</code></pre>
                    <p>Vous vous posez sûrement la question pourquoi on n'a pas développé directement notre formulaire dans le <span class="em">EditPokemonComponent</span>. Il est possible de le faire mais il y a deux choses qui nous font savoir que c'est mieux ainsi : premièrement, par la suite, on peut réutiliser le formulaire qu'on a créé pour gérer le cas d'ajout d'un nouveau pokémon dans l'application et, deuxièmement, l'avantage est la séparation des objectifs, c'est-à-dire le découpage. Le formulaire en soit est déjà une tâche suffisament conséquente pour mériter d'avoir son propre composant.</p>
                    <p>On va rajouter la route dans le fichier <span class="em">pokemon.module.ts</span> :</p>
<pre><code>{ path : 'edit/pokemon/:id', component: EditPokemonComponent }</code></pre>
                    <p>L'ordre des routes est important : la route la plus spécifique en haut et les routes globales en dessous.</p>
                    <p>On va rajouter le fameux bouton "Éditer" avec une méthode <span class="em">goToEditPokemon(pokemon)</span> dans notre <span class="em">DetailPokemonComponent</span> :</p>
<pre><code>goToEditPokemon(pokemon: Pokemon) {
    this.router.navigate(['/edit/pokemon', pokemon.id]);
}</code></pre>
<pre><code>&lt;a (click)="goToEditPokemon(pokemon)"&gt;Éditer&lt;/a&gt;</code></pre>
                </article>
                <article>
                    <h2 id="programmation_reactive">La programmation réactive :</h2>
                    <p>Il y a un élément indispensable à la plupart des applications qu'on a pas encore aborder: <q>Comment communiquer avec un serveur distant ?</q>. Comme pour les formulaires, il y a plusieurs manières de faire. On peut faire des appels sur le réseau avec des <span class="html">Promise</span> ou avec des <span class="html">Observable</span> et la programmation réactive.</p>
                    <p>Nous verrons quels sont les outils existants pour intéragir avec un serveur distant et comment ils fonctionnent. Les promesses (ou <span class="html">Promise</span> en anglais) sont natives en JavaScript depuis l'arrivée de ES6. Les promesses sont quand même là pour simplifier la programmation asynchrone. Cette dernière desssigne un mode de fonctionnement dans lequel les opérations sont non-bloquantes. Voici quelques exemples de <span class="html">Promise</span> :</p>
<pre><code>/***************************
* Exemple n°1
* Cet exemple permet de récupérer un utilisateur depuis un serveur distant
* à partir de son identifiant.
***************************/
let recupererUtilisateur = function(idUtilisateur) {
    return new Promise(function(resolve, reject) {
        // App assynchrone au serveur pour récupérer les informations d'un utilisateur.
        // À partir de la réponse du serveur, on extrait les données de l'utilisateur.
        let utilisateur = response.data.utilisateur;

        if (response.status === 200) {
            resolve(utilisateur);
        } else {
            reject('Cet utilisateur n\'existe pas !');
        }
    });
};

/***************************
* Exemple n°2
* Cet exemple est une fonction qui renvoie une promesse
* contenant les informations de l'utilisateur.
***************************/
recupererUtilisateur(idUtilisateur)
    .then(function(utilisateur) { // success
        console.log(utilisateur);
        this.user = utilisateur;
    }, function(error) { // error
        console.log(error);
    });

/***************************
* Exemple n°3
* Même exemple que le n°2, mais avec l'utilisation des 'Arrow functions'.
***************************/
recupererUtilisateur(idUtilisateur)
    .then(utilisateur =&gt; { // success
        console.log(utilisateur);
        this.user = utilisateur;
    }, error =&gt; consolelog(error));</code></pre>
                    <p>On dit alors que la programmation réactive est égale à la programmation avec des flux de données asynchrones.</p>
                    <p>Un flux est une séquence d'évenements en cours qui sont ordonnés dans le temps. La succession de clics peut être modélisée comme un flux d'évenements. Ce qui est intéressant est qu'on peut appliquer des opérations sur ce flux d'évenements.</p>
                    <p>Par exemple, on peut détecter les double-clics de l'utilisateur et ignorer les clics simples. On peut considérer qu'il y a double-clic s'il y a moins de 250 ms d'écart entre deux clics.</p>
                    <p>On peut faire plus que s'abonner à un flux. Les flux peuvent émettre trois types de réponses différentes et pour chaque type on peut définir une fonction exécutée. Premièrement, une fonction peut traitée les différentes valeurs de la réponse : un nombre, un tableau, des objets, etc. Ensuite, une fonction pour traiter le cas d'erreur et, enfin, une fonction pour traiter le signal de fin, c'est-à-dire que le flux est terminé et n'émettra plus d'évenements.</p>
                    <p>Ce qu'il faut retenir c'est que les évenements du flux représentent soit les valeurs de la réponse en cas de succès, soit des erreurs ou alors des terminaisons. Il y a donc que trois cas possibles.</p>
                    <p>Pour faciliter l'implémentation de la programmation réactive, on utilise souvent des librairies spécifiques. La plus populaire dans l'écosystème JavaScript est RxJS et c'est celle choisie par les développeurs d'Angular.</p>
                    <p>Dans RxJS, un flux est représenté par un objet appelé <span class="html">Observable</span>. Ils sont très similaires à des tableaux car ils contiennent une collection de valeurs.</p>
                    <p>Cet objet ajoute juste la notion de valeur reportée dans le temps. On peut traiter celui-ci avec des opérateurs similaires à ceux des tableaux.</p>
                    <p>Voici un exemple d'<span class="html">Observable</span> :</p>
<pre><code>Observable.fromArray([1, 2, 3, 4, 5])
    .filter(x =&gt; x &gt; 2) // 3, 4, 5
    .map(x =&gt; x * 2) // 6, 8, 10
    .subscribe(x =&gt; console.log(x)); // affiche le résultat</code></pre>
                    <p>Les <span class="html">Observable</span> sont différents des promesses même s'ils sont se ressemblent sur certains aspects comme la gestion de valeurs asynchrones. Un <span class="html">Observable</span> n'est pas quelque chose à usage unique. Il continuera d'émettre des évenements jusqu'à ce qu'il émette un évenement de terminaison ou que l'on se désabonne de lui. Globalement, l'utilisation des promesses est plus simple et, dans de nombreux cas, elles sont suffisantes pour répondre aux besoins de votre application. Enfin, il est possible de transformer un <span class="html">Observable</span> en une promesse très simplement grâce à la méthode <span class="em">toPromise()</span> de RxJS comme ceci :</p>
<pre><code>import 'rxjs/add/operator/toPromise';

function giveMePromiseFromObservable() {
    return Observable.fromArray([1, 2, 3, 4, 5])
        .filter(x =&gt; x &gt; 2) // 3, 4, 5
        .map(x =&gt; x * 2) // 6, 8, 10
        .toPromise();
}</code></pre>
                </article>
                <article>
                    <h2 id="requetes_HTTP">Les requêtes HTTP :</h2>
                    <p>Revenons sur notre application de gestions de Pokémon. Pour rappel, une API est une interface de programmation.</p>
                    <p>Pour commencer, on va mettre en place le client via le <span class="em">HttpClientModule</span> compris dans Angular.</p>
                    <p>Le <span class="em">HttpClientModule</span> ne fournit pas d'éléments au niveau de la vue, c'est-à-dire pas de directives, de composants ou de pipes. On va l'injecter une seule fois à la racine de notre projet afin d'être disponible pour tous nos composants.</p>
                    <p>Donc, dans le fichier <span class="em">app.module.ts</span>, on va l'importer avant nos modules mais après les modules Angular déjà importés :</p>
<pre><code>import { HttpClientModule } from '@angular/common/http';</code></pre>
                    <p>Jusqu'à maintenant, nous avons stocké et récupérer nos données depuis le <span class="em">PokemonService</span>. On va simuler maintenant une API sans utiliser de base de données ni d'API RESTful.</p>
                    <p>Pour faire cela, on va installer un nouveau package de dépendances via la commande suivante :</p>
<pre><code>npm install angular-in-memory-web-api --save-dev</code></pre>
                    <p>Ensuite, on va créer un service pour simuler une base de données dans notre application Angular via Angular CLI avec la commande ci-dessous :</p>
<pre><code>ng generate service in-memory-data</code></pre>
                    <p>Cela crée à la racine de notre dossier <span class="em">app</span> le fichier <span class="em">in-memory-data.service.ts</span> avec le contenu modifié suivant :</p>
<pre><code>import { Injectable } from '@angular/core';
import { InMemoryDbService } from 'angular-in-memory-web-api':
import { POKEMONS } from './pokemon/mock-pokemon-list';

@Injectable({
    providedIn: 'root'
})

export class InMemoryDataService implements InMemoryDbService {

    createDb() {
        const pokemons = POKEMONS;
        return { pokemons };
    }

}</code></pre>
                    <p>On va importer, dans le <span class="em">app.module.ts</span>, juste en dessous du <span class="em">HttpClientModule</span> le nouveau module :</p>
<pre><code>// ...
import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemonyDataService } from './in-memory-data.service';

// ...

        HttpClientInMemoryWebApiModule.forRoot(InMemoryDataService, { dataEncapsulation: false }),

// ...</code></pre>
                    <p>On met le <span class="em">dataEncapsulation</span> à <span class="em">false</span> car sinon, par défaut, cette librairie, à chaque fois qu'on va la requêter, va encapsuler toutes nos réponses dans un élément <span class="em">data</span>.</p>
                    <p>Dans notre <span class="em">PokemonServive</span>, on va faire un certain nombre de modifications. Par exemple, dans la méthode <span class="em">getPokemonList()</span>, on va faire une requête réseau même si elle est simulée auprès d'un serveur distant et ensuite récupérer les données. Cette méthode deviendra asynchrone.</p>
                    <p>Voici les différentes modifications de ce service :</p>
<pre><code>import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, tap, of } from 'rxjs';
import { Pokemon } from './pokemon';

@Injectable()
export class PokemonService {

    constructor(private http: HttpClient) { }

    getPokemonList: Observable&lt;Pokemon[]&gt; {
        return this.http.get&lt;Pokemon[]&gt;('api/pokemons').pipe(
            tap((response) =&gt; this.log(response)),
            catchError((error) =&gt; this.handleError(error, []))
        );
    }

    getPokemonById(pokemonId: number): Observable&lt;Pokemon|undefined&gt; {
        return this.http.get&lt;Pokemon&gt;(`api/pokemons/${pokemonId}`).pipe(
            tap((response) =&gt; this.log(response)),
            catchError((error) =&gt; this.handleError(error, undefined))
        );
    }

    private log(response: any) {
        console.table(response);
    }

    private handleError(error: Error, errorValue: any) {
        console.error(error);
        return of(errorValue);
    }

    getPokemonTypeList(): string[] {
        return [
            'Plante',
            'Feu',
            'Eau',
            'Insecte',
            'Normal',
            'Electrik',
            'Poison',
            'Fée',
            'Vol',
            'Combat',
            'Psy'
        ];
    }
}
</code></pre>
                    <p>On va adapter nos composants pour accéder à ces nouvelles données asynchrones. Premièrement, modifions le <span class="em">ListPokemonComponent</span> :</p>
<pre><code>ngOnInit() {
    this.pokemonService.getPokemonList()
        .subscribe((pokemonList) =&gt; this.pokemonList = pokemonList);
}</code></pre>
                    <p>Deuxièmement, on va modifier le <span class="em">DetailPokemonComponent</span> et le <span class="em">EditPokemonComponent</span> avec le contenu suivant :</p>
<pre><code>ngOnInit() {
    const pokemonId: string|null = this.route.snapshot.paramMap.get('id');

    if (pokemonId) {
        this.pokemonService.getPokemonById(+pokemonId)
            .subscribe((pokemon) =&gt; this.pokemon = pokemon);
    }
}</code></pre>
                    <p>Quand notre application utilisait une liste de données issue d'un fichier statique, les modifications étaient répercutées directement au Pokémon de cette liste unique commune à toute l'application. Mais, maintenant que nous extrayons les données à partir d'une API, si nous voulons persister nos changements nous aurions besoin de les écrire sur le serveur, c'est-à-dire de faire une requête HTTP pour enregistrer nos modifications.</p>
                    <p>Pour cela, on va créer une méthode de modification dans notre <span class="em">PokemonService</span> :</p>
<pre><code>import { HttpClient, HttpHeaders } from '@angular/common/http';

// ...

    updatePokemon(pokemon: Pokemon): Observable&lt;null&gt; {
        const httpOptions = {
            headers: new HttpHeaders({ 'Content-Type': 'application/json' })
        };

        return this.http.put('api/pokemons', pokemon, httpOptions).pipe(
            tap((response) =&gt; this.log(response)),
            catchError((error) =&gt; this.handleError(error, null));
        );
    }

// ...</code></pre>
                    <p>On va se servir de cette méthode dans notre <span class="em">PokemonFormComponent</span> :</p>
<pre><code>onSubmit() {
    this.pokemonService.updatePokemon(this.pokemon)
        .subscribe(() =&gt; this.router.navigate(['/pokemon', this.pokemon.id]));
}</code></pre>
                    <p>On va essayer de supprimer un pokémon. Dans notre <span class="em">PokemonService</span>, on va créer une nouvelle méthode :</p>
<pre><code>deletePokemonById(pokemonId: number): Observable&lt;null&gt; {
    return this.http.delete(`api/pokemons/${pokemonId}`).pipe(
        tap((response) =&gt; this.log(response)),
        catchError((error) =&gt; this.handleError(error, null))
    );
}</code></pre>
                    <p>Dans notre <span class="em">DetailPokemonComponent</span>, on va rajouter le bouton "Supprimer" :</p>
<pre><code>deletePokemon(pokemon: Pokemon) {
    this.pokemonService.deletePokemonById(pokemon.id)
        .subscribe(() =&gt; this.goToPokemonList());
}</code></pre>
<pre><code>&lt;a (click)="deletePokemon(pokemon)"&gt;Supprimer&lt;/a&gt;</code></pre>
                    <p>Maintenant qu'on a vidé notre pokédex, on va permettre à l'utilisateur d'ajouter un nouveau Pokémon. Premièrement, on va bien sûr ajouter une méthode dans notre <span class="em">PokemonService</span> qui va permettre de persister le nouveau Pokémon niveau serveur :</p>
<pre><code>addPokemon(pokemon: Pokemon): Observable&lt;Pokemon&gt; {
    cons httpOptions = {
        headers: new HttpHeaders({ 'Content-Type': 'application/json' })
    };
    
    return this.http.post&lt;Pokemon&gt;('api/pokemons', pokemon, httpOptions).pipe(
        tap((response) =&gt; this.log(response)),
        catchError((error) =&gt; this.handleError(error, null))
    );
}</code></pre>
                    <p>Ensuite, on va créer un composant <span class="em">AddPokemon</span> qui va réutiliser notre formulaire de Pokémon mais pour en créer un nouveau. Avec Angular CLI, on utilise la commande suivante :</p>
<pre><code>ng generate component pokemon/add-pokemon</code></pre>
                    <p>Cela crée le fichier <span class="em">app/pokemon/add-pokemon/add-pokemon.component.ts</span> avec le contenu modifié suivant :</p>
<pre><code>import { Component, OnInit } from '@angular/core';

@Component({
    selector: 'app-add-pokemon',
    template: `
        &lt;h1 class="center"&gt;Ajouter un pokémon&lt;/h1&gt;
        &lt;app-pokemon-form [pokemon]="pokemon"&gt;&lt;/appp-pokemon-form&gt;
    `
})

export class AddPokemonComponent implements OnInit {

    pokemon: Pokemon;

    ngOnInit() {
        this.pokemon = new Pokemon();
    }

}</code></pre>
                    <p>On va modifier notre modèle <span class="em">Pokemon</span> pour créer un pokémon avec des valeurs par défaut :</p>
<pre><code>export class Pokemon {

    id: number;
    name: string;
    hp: number;
    cp: number;
    picture: string;
    types: string[];
    created: Date;

    constructor(
        name: string = 'Entrez un nom...',
        hp: number = 100,
        cp: number= 10,
        picture: string = 'https://assets.pokemon.com/assets/cms2/img/pokedex/detail/xxx.png',
        types: string[] = ['Normal'],
        created: Date = new Date()
    ) {
        this.name = name;
        this.hp = hp;
        this.cp = cp;
        this.picture = picture;
        this.types = types;
        this.created = created;
    }
}</code></pre>
                    <p>Troisièmement, on va modifier ce formulaire pour qu'il puisse gérer à la fois l'ajout d'un nouveau Pokémon et la modification d'un Pokémon :</p>
<pre><code>// ...
    
isAddForm: boolean;

// ...

ngOnInit() {
    this.types = this.pokemonService.getPokemonTypeList();
    this.isAddForm = this.router.url.includes('add');
}

onSubmit() {
    if (isAddForm) {
        this.pokemonService.addPokemon(this.pokemon)
            .subscribe((pokemon: Pokemon) =&gt; this.router.navigate(['/pokemon', pokemon.id]));
    } else {
        this.pokemonService.updatePokemon(this.pokemon)
            .subscribe(() =&gt; this.router.navigate(['/pokemon', this.pokemon.id]));
    }
}

// ...</code></pre>
<pre><code>&lt;!-- Pokemon picture --&gt;
&lt;div *ngIf="isAddForm" class="form-group"&gt;
    &lt;label="picture"&gt;Image&lt;/label&gt;
    &lt;input type="url" class="form-control" id="picture" required [(ngModel)]="pokemon.picture" name="picture" #picture="ngModel"&gt;

    &lt;div [hidden]="picture.valid || picture.pristine" class="card-panel red accent-1"&gt;
        L'image du pokémon est requise.
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    <p>Enfin, on va rajouter un bouton "Ajouter" qui va rediriger vers la page qui crée le nouveau Pokémon, c'est-à-dire déclarer une route et un lien vers cette route :</p>
<pre><code>{ path: 'pokemon/add', component: AddPokemonComponent },</code></pre>
<pre><code>&lt;a class="btn-floating btn-large waves-effect waves-light red 2-depth-3" style="position: fixed; bottom: 25px; right: 25px;" routerLink="/pokemon/add"&gt;
    +
&lt;/a&gt;</code></pre>
                </article>
                <article>
                    <h2 id="librairie_RxJS">La librairie RxJS :</h2>
                    <p>Je vous propose d'ajouter une nouvelle fonctionnalité pour pouvoir rechercher des Pokémons via leur nom sous la forme d'un champ de recherche.</p>
                    <p>Ce dernier devra implémenter l'auto-complétion, c'est-à-dire qu'au fur et à mesure que l'utilisateur tapera un terme de recherche, nous afficherons une liste de Pokémons correspondant aux critères de recherche.</p>
                    <p>Pour commencer, on va créer une nouvelle méthode dans notre <span class="em">PokemonService</span> :</p>
<pre><code>searchPokemonList(term: string): Observable&lt;Pokemon[]&gt; {
    if (term.length &lt;= 1) {
        return of([]);
    }

    return this.http.get&lt;Pokemon[]&gt;(`api/pokemons/?name=${term}`).pipe(
        tap((response) =&gt; this.log(response)),
        catchError((error) =&gt; this.handleError(error, []))
    );
}</code></pre>
                    <p>Ensuite, on va créer un composant contenant ce fameux champ de recherche via Angular CLI via la commande suivante :</p>
<pre><code>ng generate component pokemon/search-pokemon --inline-template=false</code></pre>
                    <p>Cette commande crée les fichiers <span class="em">search-pokemon.component.ts</span> et <span class="em">search-pokemon.component.html</span> dans le dossier <span class="em">pokemon/search-pokemon</span> et modifiera le <span class="em">PokemonModule</span> pour déclarer ce composant.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { Observable, Subject, switchMap } from 'rxjs';
import { Pokemon } from '../pokemon';
import { PokemonService } from '../pokemon.service';

@Component({
    selector: 'app-search-pokemon',
    templateUrl: './search-pokemon.component.html',
})

export class SearchPokemonComponent implements OnInit {
    // {..."a".."ab"..."abz".."ab"..."abc".....}
    searchTerms = new Subject&lt;string&gt;();
    // {...pokemonList(a)...pokemonList(ab).....}
    pokemons$: Observable&lt;Pokemon[]&gt;;

    constructor(
        private router: Router,
        private pokemonService: PokemonService
    ) { }

    ngOnInit() {
        this.pokemons$ = this.searchTerms.pipe(
            // {..."a"."ab"..."abz"."ab"..."abc".....}
            debounceTime(300),
            // {..."ab"...."ab"..."abc".....}
            distinctUntilChanged(),
            // {..."ab"......."abc".....}
            switchMap((term) =&gt; this.pokemonService.searchPokemonList(term))
            // {...pokemonList(ab).......pokemonList(abc).....}
        );
    }

    search(term: string) {
        this.searchTerms.next(term);
    }

    goToDetail(pokemon: Pokemon) {
        this.router.navigate(['/pokemon', pokemon.id]);
    }
    
}</code></pre>
                    <p>La variable <span class="em">pokemons$</span> est une convention Angular pour indiquer qu'elle contient un flux de données. On a utilisé la programmation réactive de RxJS dans le <span class="html">ngOnInit</span>. Voici le template :</p>
<pre><code>&lt;div class="row"&gt;
    &lt;div class="col s112 m6 offset-m3"&gt;
        &lt;div class="card"&gt;
            &lt;div class="card-content"&gt;
                &lt;div class="input-field"&gt;
                    &lt;input type="search" #searchBox (keyup)="search(searchBox.value)" placeholder="Rechercher un pokémon"&gt;
                    &lt;div class="collection"&gt;
                        &lt;a *ngFor="let pokemon of pokemons$ | async" (click)="goToDetail(pokemon)" class="collection-item"&gt;
                            {{ pokemon.name }}
                        &lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    <p>Le <span class="em">pokemons$ | async</span> va faire exactement pareil que le <span class="em">this.pokemons$.subscribe(pokemons =&gt; this.pokemons = pokemons);</span> dans le <span class="html">ngOnInit</span>. On va rajouter le rajouter dans le template de notre <span class="em">ListPokemon</span> juste avant la liste :</p>
<pre><code>&lt;app-search-pokemon&gt;&lt;/app-search-pokemon&gt;</code></pre>
                    <p>On va ajouter une icône de chargementcar l'application est un peu plus lente depuis qu'elle utilise l'API. Pour cela, on va créer un nouveau composant avec Angular CLI avec la commande suivante :</p>
<pre><code>ng generate component pokemon/loader</code></pre>
                    <p>Cela crée le fichier <span class="em">pokemon/loader/loader.component.ts</span> avec le contenu modifié :</p>
<pre><code>import { Component } from '@angular/core';

@Component({
    selector: 'app-loader',
    template: `
        &lt;div class="preloader-wrapper big active"&gt;
            &lt;div class="spinner-layer spinner-blue"&gt;
                &lt;div class="circle-clipper left"&gt;
                    &lt;div class="circle"&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="gap-patch"&gt;
                    &lt;div class="circle"&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="circle-clipper right"&gt;
                    &lt;div class="circle"&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `
})

export class LoaderComponent { }</code></pre>
                    <p>On va modifier le message s'il y a aucun Pokémon à afficher dans le template de notre <span class="em">DetailPokemonComponent</span> et on va devoir faire pareil pour le message dans le template du <span class="em">PokemonFormComponent</span> :</p>
<pre><code>&lt;h2 *ngIf="!pokemon" class="center"&gt;
    &lt;app-loader&gt;&lt;/app-loader&gt;
&lt;/h2&gt;</code></pre>
                </article>
                <article>
                    <h2 id="authentification_securite">Authentification et sécurité :</h2>
                    <p>Pour mettre en place l'authentification, on aura besoin d'un <span class="em">Guard</span>. Un <span class="em">Guard</span> est un mécanisme de protection utilisé par Angular pour mettre en place l'authentification mais pas seulement.</p>
                    <p>Le <span class="em">Guard</span> retourne un <span class="em">booléen</span> qui permet de contrôler le comportement de la naviagtion. Par exemple :</p>
                    <ul>
                        <li>
                            <p>Si ça retourne <span class="html">true</span>, le processus de navigation continue.</p>
                        </li>
                        <li>
                            <p>Si ça retourne <span class="html">false</span>, le processus de navigation cesse et l'utilisateur reste sur la même page.</p>
                        </li>
                    </ul>
                    <p>Dans la plupart des cas, un <span class="em">Guard</span> ne peut pas renvoyer un résultat de manière synchrone car il doit attendre une réponse.</p>
                    <p>C'est-à-dire que le type de retour d'un <span class="em">Guard</span> est un <span class="em">Observable&lt;boolean&gt;</span> ou une <span class="em">Promise&lt;boolean&gt;</span> et le routeur attendra la réponse pour agir sur la navigation.</p>
                    <p>Même si un <span class="em">Guard</span> est conçu pour intéragir avec la navigation, il en existe des types différents :</p>
                    <ul>
                        <li>
                            <p><span class="html">CanActivate</span> : Il peut influencer sur la navigation d'une route comme la bloquer par exemple. C'est ce type de <span class="em">Guard</span> qu'on va utiliser pour construire un système d'authentification dans notre application.</p>
                        </li>
                        <li>
                            <p><span class="html">CanActivateChild</span> : Il peut influencer sur la navigation d'une route fille.</p>
                        </li>
                        <li>
                            <p><span class="html">CanDeactivate</span> : Il empêche l'utilisateur de naviguer en dehors de la route courante. Cela peut être utile lorsqu'un utilisateur a oublié de valider un formulaire avant de continuer la navigation.</p>
                        </li>
                        <li>
                            <p><span class="html">Resolve</span> : Il effectue une récupération de données avant de naviguer.</p>
                        </li>
                        <li>
                            <p><span class="html">CanLoad</span> : Il peut gérer la navigation vers un sous-module chargé de manière asynchrone.</p>
                        </li>
                    </ul>
                    <p>Bien sûr, on peut avoir différents <span class="em">Guard</span> à tous les niveaux du système de navigation. Cependendant, si à un moment un <span class="em">Guard</span> retourne <span class="html">false</span>, tous les autres <span class="em">Guard</span> en attente seront annulés et la navigation sera bloquée.</p>
                    
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
        <script src="../pre.js"></script>
    </body>
</html>