<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Algo et SD - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                        <li><a href="#rsa">Cryptage du RSA</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                   <p>Liens utiles :</p>
                    <ul>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Algorithme et Structure de données :</h1>
                    <p>Les exemples de ce cours sont illustrés en Java, mais la notin d'algorithme reste le mêmepour d'autres langages de programmation.</p>
                </article>
                <article>
                    <h2 id="notions_base">Notions de base :</h2>
                    <p>Un <span class="em">programme</span> informatique est, en gros, une séquence d'<span class="em">instructions</span>, d'ordres données à un ordinateur afin de lui faire accomplir une tâche précise. Un même programme est en général appelé à être exécuté plusieurs fois. Bien qu'on ait parlé de "tâche précise", chacune des exécutions d'un "<span class="em">alternatives</span>", c'est-à-dire des sous-séquences d'instructions qui seront exécutées ou non en fonctions des circonstances extérieures.</p>
                    <p>Si l'on retire du paragraphe précédent le mot "ordinateur", cette définition pourrait aussi s'appliquer à une recette de cuisine, telle qu'elle figuererait dans un livre de recettes. En voici un exemple (plutôt élémentaire !) :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une salade :</p>
                                    <ol type="a">
                                        <li>prendre une belle laitue, séparer les feuilles en retirant les plus abîmées</li>
                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                        <li>mettre dans un saladier3 cuillers à soupe d'huile, une de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                        <li>bien mélanger ces ingrédients</li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Jusqu'ici, dans cet exemple, il n'ya qu'un seul cheminement possible. Mais l'on pourrait imaginer la recette suivante :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une salade :</p>
                                    <ol type="a">
                                        <li>
                                            <p><span class="em">SI</span> on dispose d'une laitue qui a été vendue déjà nettoyée et découpée</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> ouvrir le sachet</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>prendre une belle laitue, séparer les feuilles en retirant les plus abîmées</li>
                                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <p><span class="em">SI</span> on a de la vinaigrette toute faite</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> mettre 4 cuillers à soupe de vinaigrette dans un saladier</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>mettre dans un saladier 3 cuillers à soupe d'huile, de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                                        <li>bien mélanger ces ingrédients</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Dans de très nombreux programmes informatiques, en outre, une même sous-séquence d’instructions est appelée à être exécutée plusieurs fois d’affilée. Cette situation est assez naturelle, si l’on pense que l’ordinateur est surtout destiné à exécuter très rapidement des tâches de routine, c’est-à-dire des tâches répétitives.</p>
                    <p>Pour revenir à notre exemple de salade, on pourrait rencontrer les instructions suivantes :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p><span class="em">POUR CHACUNE</span> des feuilles de laitue :</p>
                                            <ol>
                                                <li>détacher la feuille délicatement de la laitue</li>
                                                <li>l'examiner pour voir si elle ne possède pas de tâche ou de partie froissée</li>
                                                <li>retirer les parties suspectes</li>
                                                <li>couper la feuille en morceaux et mettre ceux-ci dans l'eau de nettoyage</li>
                                            </ol>
                                        </li>
                                        <li>gôuter la vinaigrette</li>
                                        <li>
                                            <p><span class="em">TANT QUE</span> la vinaigrette n'est pas assez piquante :</p>
                                            <ol>
                                                <li>rajouter un peu de moutarde</li>
                                                <li>rajouter un peu de vinaigre</li>
                                                <li>bien mélanger</li>
                                                <li>goûter de nouveau la vinaigrette</li>
                                            </ol>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Les programmeurs parleront, dans un tel cas, de "<span class="em">répétitive</span>", d'"<span class="em">itérative</span>", ou encore de "<span class="em">boucle</span>".</p>
                    <p>Enfin, de nombreux livres de cuisine renvoient le lecteur d’une recette à l’autre, lorsqu’un mets plus élaboré en inclut un autre, plus simple. Ainsi la recette de salade pourrait se résumer à :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> péparer une salade :</p>
                                    <ol type="a">
                                        <li>préparer des feuilles de laitue (voir page XXX)</li>
                                        <li>préparer une vinaigrette (voir page YYY) et la mettre dans un sablier</li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>À la page XXX, on trouverait :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer des feuilles de laitue :</p>
                                    <ol type="a">
                                        <li>
                                            <p><span class="em">SI</span> on dispose d'une laitue qui a été venue déjà nettoyée et découpée</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> ouvrir le sachet</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>prendre une laitue, séparer les feuilles en retirant les plus abîmées</li>
                                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>et la page YYY :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une vinaigrette :</p>
                                    <ul>
                                        <li>mettre dans un saladier 3 cuillers à soupe d'huile, une de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                        <li>bien mélanger ces ingrédients</li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Cette dernière situation est rencontrée aussi en programmation : un programme fait souvent appel à un "<span class="em">sous-programme</span>" qui doit exécuter pour lui une partie du traitement. Et cette sous-traitance peut se répercuter en cascade : le sous-programme peu à son tour sous-traiter à un autre sous-programme une partie de tâche qui lui a été confiée par le "programme principal", etc.</p>
                    <p>On parlera, selon les langages et les contextes, de "<span class="em">sous-programmes</span>", de "<span class="em">procédures</span>", de "<span class="em">fonctions</span>, de "<span class="em">méthodes</span>, etc.</p>
                </article>
                <article>
                    <h2 id="cycle_vie_programme">Le cycle de vie d'un programme :</h2>
                    <p>Pour concevoir un programme, ou à fortiori toute une "<span class="em">application informatique</span>" (qui peut
                        elle-même être constituée de plusieurs programmes), l’informaticien doit d’abord faire une analyse
                        fouillée de la situation et de ce qu’on lui demande de réaliser : c’est la phase d’"<span class="em">analyse</span>", située en amont de la programmation proprement dite.</p>
                        <p>Ensuite, il doit élaborer, structurer la séquence d’instructions qui permettront de réaliser la tâche demandée. Une telle séquence d’actions, structurées à l’aide d’alternatives, de répétitives, de sousprogrammes, est appelée un "<span class="em">algorithme</span>".</p>
                        <p>Une fois conçus sur papier, les algorithmes n’auront alors plus qu’à être "<span class="em">implémentés</span>" ou "<span class="em">programmés</span> sur une machine, via un langage informatique, avant d'être <span class="em">exécutés</span>.</p>
                        <p>Enfin, la phase de <span class="em">test</span> est de <span class="em">mise au point</span> est tout à fait essentielle. Elle doit être réalisée de manière professionnelle, c’est-à-dire systématique et rigoureuse. (L’idéal est de prévoir déjà les tests avant d’écrire le programme : on pense ainsi dès le départ à tous les cas que devra traiter ce programme.)</p>
                        <p>Et il ne faut pas négliger la mise en oeuvre effective, la formation éventuelle des utilisateurs (par exemple via un "manuel d'utilisation"), et les réaménagements ultérieurs (ce qu'on appelle la "<span class="em">maintenance</span>" du programme).</p>
                        <p>Pour accompagner tout ce cheminement, une <span class="em">documentation</span> complète, précise et bien mise à jour est indispensable : elle figuera dans un <span class="em">dossier</span> (sur papier ou sur support informatique) accompagnant le programme, ainsi que dans les <span class="em">commentaires</span> insérés dans celui-ci.</p>
                </article>
                <article>
                    <h2 id="types_reference">Les types de référence :</h2>
                    <p>La <span class="em">déclaration</span> d'une variable sert :</p>
                    <ul>
                        <li>à donner à la variable son <span class="em">type</span></li>
                        <li>à demander à l'ordinateur de réserver une zone de mémoire pour elle, zone dont la taille dépendra du type</li>
                        <li>à fixer la <span class="em">portée</span> de la variable : où et quand sera-t-elle accessible ?</li>
                    </ul>
                    <p>Une variable possédera à tout moment une <span class="em">valeur</span> : c’est cette valeur qui sera stockée dans la zone de mémoire propre à la variable. Cette valeur peut changer au fur et à mesure de l’exécution du programme, d’où le terme de "variable". Mais la valeur doit toujours être conforme au "type" de la variable.</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>type</th>
                                <th>type Java</th>
                                <th>valeurs</th>
                                <th>valeur par défaut</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>nombre entier</td>
                                <td>int</td>
                                <td>325, -65, 0, 1234567890</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>nombre réel simple précision</td>
                                <td>float</td>
                                <td>32.56, -0.001, 1.03e+04(= 10300.0)</td>
                                <td>0.0</td>
                            </tr>
                            <tr>
                                <td>nombre réel double précision</td>
                                <td>double</td>
                                <td>32.56, -0.001, 1.03e+04(= 10300.0)</td>
                                <td>0.0</td>
                            </tr>
                            <tr>
                                <td>caractère</td>
                                <td>char</td>
                                <td>'A', '2', '+', ' '</td>
                                <td>''</td>
                            </tr>
                            <tr>
                                <td>booléen</td>
                                <td>boolean</td>
                                <td>true, false</td>
                                <td>false</td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h2 id="inputs_outputs">Les inputs/outputs :</h2>
                    <p>On définit une varibale servant de "lecteur" des entrées :</p>
<pre class="taille60"><code>Scanner scanner = new Scanner(System.in);</code></pre>
                    <p>On l'utilise pour lire une valeur :</p>
<pre class="taille60"><code>int nombre = scanner.nextInt();</code></pre>
                    <p>Comme le montre le tableau suivant, cette instruction diffère légèrement en fonction du type de la variable que l'on désire lire :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Instruction</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>int</td>
                                <td>int nombre = scanner.nextInt();</td>
                            </tr>
                            <tr>
                                <td>char</td>
                                <td>char caractere = scanner.nextChar();</td>
                            </tr>
                            <tr>
                                <td>String</td>
                                <td>String texte = scanner.next();</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Cette instruction est un peu délicate à manier car à la moindre erreur d’entrée de l’utilisateur, si rien n’est fait pour rattraper celle-ci, le programme s’arrêtera.</p>
                    <p>Pour écrire dans la console, on utilise :</p>
<pre class="taille60"><code>System.out.println("texte à écrire dans la console");</code></pre>
                    <p><span class="souligne">ASTUCE :</span> Sur Eclipse, écrire "sysout" et taper simultanément sur les touches "Ctrl" et "Space" permet d'écrire plus facilement le "System.out.println".</p>
                    <p>Cette instruction permet d'écrire le texte situé entre parenthèses dans la console et on passe à la ligne. Si on met "print" au lieu de "println", le texte sera écrit dans la console mais sans le saut à la ligne.</p>
                </article>
                <article>
                    <h2 id="alternatives">Les alternatives :</h2>
                    <p>Une alternative est une instruction qui permet l'ordinateur, au moment de l'exécution du programme, de choisir la partie de code à exécuter : ce choix s'effectue en fonction de certaines conditions qui, en général, font intervenir les valeurs d'une ou plusieurs variables.</p>
                    <p>Il existe deux familles d'alternatives : les alternatives à deux branches et celles à nombre quelconque de branches.</p>
                    <p>En Java, l'alternative à deux branches s'écrit comme suit :</p>
<pre class="taille60"><code><span class="em">if</span> (condition) {
    instruction_1_1;
    instruction_1_2;
    ...
    instruction_1_N;
} <span class="em">else</span> {
    instruction_2_1;
    instruction_2_2;
    ...
    instruction_2_N;
} // FIN if</code></pre>
                    <p>Une alternative n’est au final qu’une instruction comme les autres et peut donc être utilisée au sein d’une autre alternative ! C’est ce qu’on appelle "alternative imbriquée".</p>
<pre class="taille60"><code><span class="em">if</span> (x &gt; y) {
    System.out.println("x est le plus grand");
} <span class="em">else</span> {
    <span class="em">if</span> (y &gt; x) {
        System.out.println("y estle plus grand");
    } <span class="em">else</span> {
        System.out.println("x et y sont égaux");
    }
}</code></pre>
                    <p>Pour éviter de multiplier les if imbriqués, il existe une instruction permettant d'exprimer plus de deux cas : le switch-case. C'est une des alternatives à <span class="em">N branches</span>.</p>
<pre class="taille60"><code><span class="em">switch</span> (expression) {
    <span class="em">case</span> valeur_1 :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_N1;
    <span class="em">case</span> valeur_2 :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_N2;
    <span class="em">case</span> valeur_M :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_NM;
    <span class="em">default</span> :
        instruction_1_1;
        instruction_1_2;
        ...
}</code></pre>
                    <p>La <span class="souligne">sémantique</span> de l'instruction switch est la suivante :</p>
                    <ol>
                        <li>On évalue l'expression entre parenthèses. (Si nécessaire, on la convertit en <span class="em">int</span>.)</li>
                        <li>On compare sa valeur aux valeurs des différentes "expressions constantes".</li>
                        <li>Si sa valeur a été trouvée, on exécute toutes les instructions qui suivent cette constante, y compris celles qui sont situées au-delà des mots "<span class="em">case</span>" et "<span class="em">default</span>" suivants.</li>
                        <li>Si sa valeur n'a été trouvée, et qu'il y a une branche "<span class="em">default</span>", on passe directement à l'instruction "<span class="em">break;</span>, on quitte le switch.</li>
                        <li>Dans tous les cas, après l'exécution de ce qu'il fait, on continue en exécutant les instructions situées au-delà de l'instruction <span class="em">switch</span> (sauf bien sûr si l'on a rencontré au passage une instruction qui nous fait sortir du bloc où se trouve ce switch : <span class="em">return</span>, <span class="em">throw</span>, ...).</li>
                    </ol>
                    <p>L'expression du switch ne peut être que d'un type dont les valeurs peuvent être énumérées (int, char, ...) et donc ni des float ni des objets (pas de String non plus).</p>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>En Java,</p>
                    <ul>
                        <li>l'opérateur OU (inclusif) s'écrit <span class="em">|</span> ou <span class="em">||</span> (voir plus loin la différence)</li>
                        <li>l'opérateur ET s'écrit <span class="em">&amp;</span> ou <span class="em">&amp;&amp;</span> (voir plus loin la différence)</li>
                        <li>l'opérateur NON s'écrit <span class="em">!</span></li>
                    </ul>
                    <p>En Java, les opérateurs ET et OU sont dédoublés :</p>
                    <ul>
                        <li>
                            <p>&amp; et | imposent une évaluation complète</p>
                            <ul>
                                <li>l'ordinateur évalue exp1</li>
                                <li>puis il évalue exp2</li>
                                <li>puis il effectue l'opérateur "ET" ou "OU"</li>
                            </ul>
                        </li>
                        <li>
                            <p>&amp;&amp; et ||  demandent une évaluation court-circuitée</p>
                            <ul>
                                <li>l'ordinateur évalue exp1</li>
                                <li>si la valeur de exp1 est <span class="em">true</span>, il sait que le résultat de l'ensemble est aussi <span class="em">true</span> dans l'opération "OU", sans qu'il n'ait dû évaluer exp2</li>
                                <li>si la valeur exp1 est <span class="em">false</span> dans l'opération "OU", il évalue exp2, et le résultat de l'ensemble est égal à la valeur de exp2</li>
                            </ul>
                        </li>
                    </ul>
                    <p>La différence entre les deux consiste surtout en un gain de temps, surtout dans le cas où exp2 est une expression dont l’évaluation prend du temps : l’évaluation court-circuitée permet d’éviter ce temps inutilement dépensé.</p>
                    <dl>
                        <dt>Remarquons que :</dt>
                        <dd>(expression1) &amp; (expression2)</dd>
                        <dt>Est (en général) "équivalent à" :</dt>
                        <dd>(expression2) &amp; (expression1)</dd>
                        <dt>Ce qui n'est plus le cas si l'on utilise l'opérateur &amp;&amp;.</dt>
                        <dt>La même remarque s'applique à | et ||.</dt>
                    </dl>
                    <p>Les opérateurs de relation :</p>
                    <ul>
                        <li><span class="em">=</span> (<span class="em">==</span> en Java), <span class="em">!=</span></li>
                        <li><span class="em">&lt;</span>, <span class="em">&lt;=</span>, <span class="em">&gt;</span>, <span class="em">&gt;=</span></li>
                    </ul>
                    <p class="souligne">Quelques conseils de styles :</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Au dieu d'écrire :</th>
                                <th>Écrivez plutôt</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>if (trouve == true) { ... }</li>
                                        <li>while (file == false) { ... }</li>
                                        <li>
                                            <p>if ((a &gt; b) || (x == y)) b1 = true;</p>
                                            <p>else b2 = false;</p>
                                        </li>
                                        <li>if (a == b + c) b1 = true;</li>
                                        <li>if (a == 0) b1 = false;</li>
                                        <li>
                                            <p>boolean b = (a &gt; b) || (x == y);</p>
                                            <p>return b;</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>if (trouve) { ... }</li>
                                        <li>while (!fini) { ... }</li>
                                        <li>b1 = (a &gt; b) || (x == y);</li>
                                        <li>b1 = b1 | (a == b + c); (lisibilité discutable)</li>
                                        <li>b1 = b1 &amp; !(a == 0); (lisibilité discutable)</li>
                                        <li>return (a &gt; b) || (x == y);</li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En Java, l'opérateur ternaire : "... <span class="em">?</span> ... <span class="em">:</span> ..." permet aussi d'éviter certains "if" :</p>
                    <ul>
                        <li>
                            <p>au lieu de :</p>
<pre class="taille60"><code>if (a &gt; b) max = a;
else max = b;</code></pre>
                        </li>
                        <li>
                            <p>on écrira :</p>
<pre class="taille60"><code>max = (a &gt; b) ? a : b;</code></pre>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="repetitives">Les répétitives :</h2>
                    <p>Une répétitive (ou itérative, ou boucle) est une instruction demandant à l'ordinateur d'exécuter plusieurs fois un groupe d'instructions spécifiées (le mot "plusieurs" est à prendre ici au sens large, englobant les cas 0 et 1).</p>
                    <p>Les types de répétitives sont très variables d’un langage à l’autre, et certains langages en présentent même une grande diversité. Ces types de répétitives se différencient essentiellement par la façon dont on spécifie le <span class="souligne">nombre d'exécutions</span>.</p>
                    <p>Nous présenterons ici celle de Java ainsi que quelques macro-algorithmes.</p>
                    <ol>
                        <li>
                            <h3 id="for">La boucle for :</h3>
                            <p>Le modèle général de la boucle <span class="em">for</span> en Java est le suivant :</p>
<pre class="taille60"><code>for ( &lt;init var de contrôle&gt;; &lt;cond. de continuation&gt;; &lt;increment&gt; ) {
    &lt;Action_1&gt;;
    &lt;Action_2&gt;;
    &lt;Action_3&gt;;
    ...
    &lt;Action_N&gt;;
}</code></pre>
                            <p>Exemple :</p>
<pre class="taille60"><code>for (int i = 1; i &lt;= nombreJoueurs; i++) {
    donnerUneCarte();
}</code></pre>
                            <p>La sémantique de cette instruction est résumée par le schéma suivant :</p>
                            <img src="../images/for.png" alt="boucle for">
                            <p>Le <span class="em">corps de la boucle</span> situé entre les deux accolades est la suite d'instructions à répéter.</p>
                            <p>La <span class="em">variable de contrôle</span> de la répétitive sert à contrôler le nombre de répétitions. Il s'agit en général d'une variable entière, d'autres types sont possibles : le type caractère par exemple. Elle doit être <span class="souligne">déclarée</span> et <span class="souligne">initialisée</span> dans la boucle. Dans l'exemple donné i est la variable de contrôle. Elle est de type int est initialisée à 1.</p>
                            <p>La <span class="em">condition de continuation</span> dela répétitive est une expression de type booléen. Le corps de la boucle est répété tant que cette condition est vraie (true). Il s'agit d'une condition de continuation car on continue la boucle tant que la condition est vraie.</p>
                            <p>L'<span class="em">incrément</span> sert à augmenter (ou dimuer) la valeur de la variable de contrôle.</p>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>
                                            <p><span class="bold">ATTENTION :</span> La boucle for est <span class="bold souligne">impérativement</span> soumise aux <span class="em">deux contraintes</span> ci-dessous, au risque de gravement porter atteinte à la lisibilité du programme, et donc en particulier d'entraver sa maintenance :</p>
                                            <ol>
                                                <li>Ne JAMAIS modifier la valeur de la variable de contrôle à l'intérieur de la répétitive !</li>
                                                <li>Après sortie de la répétitive, la variable de contrôle est censée n'avoir plus aucune valeur : elle est "indéterminée" (comme en début d'exécution d'un programme).</li>
                                            </ol>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <h3 id="while_do_while">La boucle while et do while :</h3>
                            <table>
                                <tbody>
                                    <tr>
                                        <td>
<pre class="taille60"><code>while (&lt;condition&gt;) {
    &lt;action_1&gt;
    ...
    &lt;action_n&gt;
}</code></pre>
                                        </td>
                                        <td>D'abord letest (donc : min. 0 passage</td>
                                    </tr>
                                    <tr>
                                        <td>
<pre class="taille60"><code>do {
    &lt;action_1&gt;
    ...
    &lt;action_2&gt;
} while ( &lt;condition&gt; );</code></pre>
                                        </td>
                                        <td>D'abord les actions (donc : min. 1 passage)</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Tout comme la boucle for, la condition des while et do while est une <span class="em">condition de continuation</span>.</p>
                            <p>Si on connaît le nombre de fois qu'il faut répéter l'action et que le pas est lui aussi connu à l'avance, on emploiera une boucle <span class="em">for</span>.</p>
                            <p>Si l'on ne connaît pas le nombre de tour de boucle ou si le pas d'incrémentation n'est pas constant, on devrait utiliser une boucle <span class="em">while</span> ou <span class="em">do while</span>.</p>
                            <p>Les instructions que l’on place à l’intérieur d’une répétitive peuvent être de tout type, en particulier il peut s’agir d’autres répétitives. On obtient ainsi des boucles imbriquées dans d’autres boucles.</p>
                            <p>Une des erreurs les plus fréquentes lorsque l'on écrit des répétitives est ce que l'on appelle la boucle infinie : une répétitive qui ne s'arrête jamais.</p>
                            <p>La façon la plus simple d'avoir une boucle infinie est d'écrire une condition constante true :</p>
<pre class="taille60"><code>while(true) {
    System.out.println("Rien ne l'arrêtera !");
}</code></pre>
                            <p>De façon évidente, si l'on ne modifie aucune des variables composants la condition de la boucle, on peut avoir une boucle infinie :</p>
<pre class="taille60"><code>int a = 3, b = 5, c = 6;
while (a &lt; b) {
    c--;
}</code></pre>
                            <p>Ici, a et b conserveront leurs valeurs initiales et la condition a&lt;b est éternellement vraie.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="string">Les String :</h2>
                    <p>Une chaîne de caractères est une suite ordonnée de 0,1 ou plusieurs caractères, que l'on peut en général manipuler globalement ou caractère par caractère. En Java, le type String représente les chaînes de caractères.</p>
                    <p>Un littéral de type String commence et termine par des guillemets doubles. Entre eux, on peut trouver :</p>
                    <ul>
                        <li>des caractères autres que " et \</li>
                        <li>
                            <p>des caractères spéciaux marqués sous forme du caractère\ suivi d'un autre caractère :</p>
                            <ul>
                                <li>\" qui représente "</li>
                                <li>\\ qui représente \</li>
                                <li>\n qui représente un passage à la ligne</li>
                                <li>\t qui représente une tabulation</li>
                                <li>etc.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>En Java, les chaînes de caractères ne constituent pas un type primitif, mais un type objet (un "type référence").</p>
                    <p>Ou, plus exactement, deux types objet. Ce langage met en effet à notre disposition deux classes, appelées String et StringBuffer. La seconde permet plus de manipulations à l'intérieur de la chaîne. Par contre, un objet de type String est "immuable" : on ne peut le modifier, si ce n'est en constituant une nouvelle chaîne.</p>
                    <p>On peut facilement construire une String à partir d'un StringBuffer, et vice-versa.</p>
                    <p>L’opérateur de concaténation (+) fournit une String comme résultat, obtenue par mise bout à bout des deux opérandes. Il s’applique en principe à deux Strings, mais, si un des opérandes du + est une String et l’autre pas, il y a conversion automatique de cet autre en String. (Si aucun des deux opérandes n’est une String, il s’agit de l’opérateur d’addition !).</p>
                    <p>Rappelons que l'associativité est à gauche, ce qui a de l'importance dans certains cas.</p>
                    <p>La classe String présente une dizaine de constructeurs, mais la plupart du temps on peut s’en passer, car la syntaxe du Java permet, par facilité, une notation similaire à celle des types primitfs.</p>
                    <p>Par exemple : à la place de l'écriture "orientée objet" suivante :</p>
<pre class="taille60"><code>String chaine = new String("Hello !");</code></pre>
                    <p>Le Java accepte l'écriture équivalente suivante :</p>
<pre class="taille60"><code>String chaine = "Hello !";</code></pre>
                    <p>La documentation du Java, en ligne ou trouvée dans un livre, vous donnera la liste complète des méthodes de la classe String. En voici quelques-unes  :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Fonction</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>public char char (int indice);</td>
                                <td>renvoie le caractère n°"indice" de la chaîne (NB : on commence à compter à 0).</td>
                            </tr>
                            <tr>
                                <td>public int compareTo (String autreChaine);</td>
                                <td>renvoie un entier positif, nul ou négatif selon que la chaîne-cible soit "supérieure", "égale" ou "inférieure" à la chaîne passée en paramètre; la comparaison se fait selon l'ordre "lexicographique".</td>
                            </tr>
                            <tr>
                                <td>public boolean equals (Object unObjet);</td>
                                <td>renvoie true seulement si l'objet passé en paramètre est une String, et que cette String a la même valeur que la chaîne-cible.</td>
                            </tr>
                            <tr>
                                <td>public boolean equalsIgnoreCase (String autreChaine);</td>
                                <td>renvoie true seulement si les deux chaînes sont identiques, sans tenir compte toutefois de la distinction entre majuscules et minuscules.</td>
                            </tr>
                            <tr>
                                <td>public int indexOf (String sousChaine);</td>
                                <td>
                                    <p>renvoie la position de la première occurence de la sous-chaîne dans la chaîne-cible; exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>int position = chaine.indexOf("ou"); &#8594; 4</p>
                                    <p>S'il n'y a pas d'occurence, on renvoie -1.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public int indexOf (String sousChaine, int depart);</td>
                                <td>
                                    <p>renvoie la position de la première occurence de la sous-chaîne dans la chaîne-cibe, à partir de l'indice "départ"; exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>int position = chaine.indexOf("ou", 8"); &#8594; 11</p>
                                    <p>S'il n'y a pas d'occurence, on renvoie -1.</p>
                                    <p>Rappel : on commence à l'indice 0.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public int length();</td>
                                <td>
                                    <p>renvoie la longueur de la chaîne, c'est-à-dire le nombre de caractères qu'elle contient. Ex :</p>
                                    <p>String chaine "Un coucou tout fou";</p>
                                    <p>int longueur = chaine.length;</p>
                                    <p>char dernierCaractere = chaine.charAt(longueur - 1);</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public String substring (int debut, int fin);</td>
                                <td>
                                    <p>renvoie une sous-chaîne, obtenue en prenant dans la chaîne-cible tous les caractères depuis celui de l'indice "début" jusqu'à celui situé juste avant l'indice "fin" (rappel : on commence à compter à 0); exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>String ssch = chaine.substring(3,9); &#8594; "coucou"</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>public String toUpperCase();</p>
                                    <p>public String toLowerCase();</p>
                                </td>
                                <td>
                                    <p>convertissent respectivement les minuscules en majuscules (tout en conservant inchangés tous les caractères) et vice-versa.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h2 id="tableaux">Les tableaux :</h2>
                    <p>Remarque : dans de nombreux langages, la souplesse de programmation en utilisant les tableaux est un peu atténuée par le fait qu’il faut dimensionner les tableaux dans les déclarations de variables, dès la phase d’écriture du programme; cet inconvénient est résolu par un surdimensionnement systématique de tels tableaux.</p>
                    <p>En Java cependant, on peut créer un tableau en ne connaissant sa taille qu'au moment de l'exécution en suivant par exemple le code suivant :</p>
<pre class="taille60"><code>int taille = scanner.nextInt();
int[] tab = new int[taille];</code></pre>
                    <p><span class="souligne">Attention :</span> Il est à noter qu'en Java les tableaux commencent toujours à la case 0. Le tableau créé compte taille cases : de 0 à taille - 1.</p>
                    <p><span class="souligne">Remarque :</span> Un danger non négligeable de l'outil "tableaux" est cependant la tentation d'en abuser.</p>
                    <p>Dans les langages classiques, un <span class="em">tableau</span> (ou une <span class="em">table</span>, ou une <space class="em">variable indicée</space>), c'est un groupe de "cases de mémoire"</p>
                    <ul>
                        <li>toute de même "type".</li>
                        <li>donc forcément de même taille.</li>
                        <li>possédant un nom (identificateur) commun.</li>
                        <li>différenciées les unes des autres par la valeur d'un (ou de plusieurs) indice(s).</li>
                    </ul>
                    <p>Si le tableau n'a qu'un seul indice, comme dans l'exemple donné, on parle parfois de <span class="em">vecteur</span>, et s'il en a deux, de <span class="em">matrice</span>.</p>
                    <p>Les indices commencent, selon les langages, à une valeur imposée (toujours 0 en Java, toujours 1 dans certains langages) ou au contraire à une valeur au choix du programmeur (en Pascal par exemple, on peut décider de créer un tableau indicé de 5 à 20, ou encore de -1850 à -127).</p>
                    <p>Le type des indices est souvent réduit aux nombres entiers, mais certains langages acceptent d'autres types, comme le type caractère.</p>
                    <p>En Java, les tableaux sont des constructions hybrides : ce sont des "objets" sous certains aspects, mais pas sous tous.</p>
                    <p>Un tableau est toujours une référence. L'espace-mémoire du tableau doit être construit par l'utilisation de l'opérateur "<span class="em">new</span>" (ou par un "array initializer").</p>
                    <p>Un tableau possède un "champ, qui représente sa longueur physique et s'appelle <span class="em">length</span>.</p>
                    <p>Les éléments du tableau peuvent être de n'importe quel type Java, y compris un type objet ou un type tableau (ce dernier cas, tableau de tableaux, permet d'implémenter des tableaux à plusieurs dimensions).</p>
                    <p>En Java, tous les tableaux sont indicés à partir de 0. Ceci est une limitation du Java (par exemple par rapport au PHP).</p>
                    <p>On peut aussi déclarer et allouer et initialiser le tableau tableDEntiers en utilisant un "array initializer" :</p>
<pre class="taille60"><code>int[] tableDEntiers = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18};</code></pre>
                    <p>Ceci n'est cependant possible que pour des tableaux d'éléments d'un type primitif (int dans l'exemple).</p>
                    <p>Attirons aussi sur le fait que la fixation de la taille du table et donc aussi l'allocation de mémoire se font dynamiquement, lors de l'exécution (et pourra donc être différente d'une exécution à l'autre !). D'oùl'intérêt du champ "length" qui donne la longueur physique d'un tableau, comptée en nombre de "cases", c'est-à-dire en nombre de valeurs différentes de l'indice. Comme l'indice commence toujours à 0, cette longueur est aussi égale à la plus grande valeur de l'indice, plus 1.</p>
                    <h3 id="taille_physique_taille_logique">Taille physique et taille logique :</h3>
                    <p>Un tableau est conçu en vue de stocker, durant l’exécution d’un programme ou une partie de celle-ci, un certain nombre d’informations de même nature. Le nombre de telles informations effectivement mémorisées à un moment donné peut être ou bien fixe ou bien variable. Dans ce dernier cas, étant donné qu’un tableau doit en général être pré-dimensionné lors de l’écriture du programme, ou en tout cas lors de sa création, il y a une distinction à opérer entre :</p>
                    <ul>
                        <li>la <span class="em">taille physique</span> du tablau : le nombre de "cases" réservées dans les déclarations de variables ou lors de la construction (le "prédimensionnement").</li>
                        <li>la <span class="em">taille logique</span> du tableau : le nombre de "cases effectivement occupées à un moment donné par des informations pertinentes (autres donc que des "crasses").</li>
                    </ul>
                    <p>La <span class="souligne">taille physique</span>apparaît dans les déclarations de variables ou dans l'appel au constructeur : elle ne pose pas de problème particulier, sinon qu'il faut veuiller, lors de tout adressage à un élément du tableau, à ne pas "sortir" des limites autorisées.</p>
                    <p>Selon les langages, les compilateurs et parfois même les options de compilation, le comportement peut varier si l’on sort malencontreusement de ces limites. En Java, qui est un langage plein de garde-fous, une telle erreur provoque la levée d’une "exception" et, au pire, l'arrêt du programme avec un message d’erreur. Ailleurs, on peut avoir une situation où aucun contrôle n’est effectué et où, tout en croyant qu’on se "promène" dans le tableau, on se trouve dans une autre partie de la mémoire... (d'où des risques de catastrophes imprévisibles !)</p>
                    <p>Quant à la <span class="em">taille logique</span>, il revient au programmeur de la gérer convenablement dans son programme. Les deux techniques les plus fréquentes à cet égard sont :</p>
                    <ol>
                      <li>
                        <p>Au tableau proprement dit, on adjoint un attribut de la gérer, qui sert à dire <span class="em">jusqu'où</span> le tableau est rempli. On s'arrange dans ce cas pour que tous les éléments "utiles" du tableau soient toujours rassemblés au début de celui-ci.</p>
                        <ul>
                            <li>Si les indices commencent à 1, cette variable représente à la fois le <span class="em">nombre</span> d'éléments utiles (donc la taille logique) et l'<span class="em">indice</span> du dernier d'entre eux.</li>
                            <li>S'ils commencent à 0, comme c'est le cas en Java, cette variable représente à la fois le nombre d'éléments utiles et l'indice de la première case inutilisée.</li>
                        </ul>
                      </li>
                      <li>Si les N premières cases du tableau sont utilisées et pas les suivantes, on met en position N + 1 un "élément-bidons" dans toutes les cases inoccupées).</li>
                    </ol>
                    <p>La seconde de ces techniques présente divers inconvénients :</p>
                    <ul>
                        <li>Le tableau doit avoir une "case" de plus que le plus grand nombre possible d'éléments.</li>
                        <li>Il n'existe pas toujours un "élément-bidon" qui ne peut être égal à aucune valeur "normale" des éléments du tableau.</li>
                        <li>Le tableau contient des informations de deux natures différentes : d'une part les éléments proprement dits, et d'autre part le signal de fin.</li>
                        <li>Certains algorithmes (recherche dichotomique par exemple) sont fort alourdis.</li>
                    </ul>
                    <p>Nous préconisons donc la première technique, et suggérons même de déclarer les tables sous forme de <span class="em">classes</span> contenant le tableau proprement dit et sa dimension logique. Exemple :</p>
<pre class="taille60"><code>public class TableauDeTailleVariable {
    int nombreElements;
    VotreClasse[] tab;
}</code></pre>
                    <p>Ainsi, lorsqu'une telle table sera par exemple transmise comme paramètre à une <span class="em">méthode</span>, elle ne se présentera que sous forme d'un seul paramètre tout en véhiculant l'information complète.</p>
                    <p>Par ailleurs en Java, on peut aussi utiliser la classe toute faite "Vector".</p>
                    <h3 id="classement_tableaux_types_cles">Classement des tableaux selon les types de clés :</h3>
                    <p>La "<span class="em">clé</span>" est une information connue d'un tableau et permet de trouver la bonne case.</p>
                    <ol>
                        <li>La clé est l'indice. Exemple : un tableau indicé de 1 à N.</li>
                        <li>La clé et l'indice sont liés par une fonction bijective simple : c'est une variante trivale du cas précédent. Exemple : un tableau commençant à 0.</li>
                        <li>
                            <p>La clé est un des champs de l'objet, et la table n'est pas triée (ou du moins n'est pas triée suivant cette clé). Exemple : nous avons un tableau d'articles, chaque "case" pointe vers un objet qui contient un numéro d'article et un total, la clé étant le numéro :</p>
                            <img src="../images/classement_tableaux_types_cles_1.png" alt="">
                            <p>Pour conaître ou modifier le total de l'article n°175, il fau d'abord faire une <span class="souligne">recherche</span> pour localiser la case où se trouve cet article.</p>
                        </li>
                        <li>
                            <p>La clé est un des champs de l'objet, et la table est <span class="em">triée</span> suivant cette clé. Exemple : chaque "case" contient un numéro d'article et un total. Les numéros d'articles se présentent cette fois en ordre croissant et constituent toujours la clé.</p>
                            <img src="../images/classement_tableaux_types_cles_2.png" alt="">
                            <p>De nouveau, une recherche est nécessaire avant toute intervention, mais cette recherche pourra être améliorée grâce au classement du tableau (recherche de dichotomique, par exemple).</p>
                        </li>
                        <li>
                            <p>La clé est un des champs de l'objet, et la table n'est pas triée; la table contient des "trous". Ici, les "trous" sont concrétisés par une valeur null (représentée par un point sur la figure).</p>
                            <img src="../images/classement_tableaux_types_cles_3.png" alt="">
                        </li>
                        <li>
                            <p>Idem, avec table triée (sauf pour les éléments "trous" qui sont intercalés n'importe où entre les éléments triés).</p>
                        </li>
                    </ol>
                    <h3 id="insertion_table_non_riee">Insertion dans une table non triée :</h3>
                    <p>Dans les exemples, nous présenterons des algorithmes travaillant sur des tableaux d'entiers ou sur des tableaux d'objets.</p>
                    <p>Nous allons travailler sur base des classes TableauDArticles qui contiendront le tableau et le nombre d'éléments réellement présents dans cette table. Ce nombre d'éléments est la <span class="souligne">taille logique</span> du tableau :</p>
<pre class="taille60"><code>public class TableauDEntiers {
    public static final int MAX_ELEM = 30;
    int[] tab = new int[MAX_ELEM];
    int nbEntiers = 0;
}</code></pre>
<pre class="taille60"><code>public class TableauDArticles {
    public static final int MAX_ELEM = 30;
    Article[] tab = new Article[MAX_ELEM];
    int nbArticles = 0;
}</code></pre>
                    <p>Nous donnons ici un premier exemple d’algorithme, en choisissant un cas extrêmement simple. Le but de cet exemple est essentiellement de montrer comment écrire proprement ce type d’algorithme : sous forme d’une méthode où l’on indique clairement les paramètres, avec commentaires Javadoc explicatifs, et en n’oubliant pas les tests de validité.</p>
                    <p>En cas d’impossibilité de l’insertion, la méthode renvoie cette information d’échec dans sa valeur de retour de type booléen : cette attitude est à adapter aux nécessités lorsqu’on implémente cet algorithme dans un programme réel (dans certains cas, il n’y a rien à faire en cas d’échec, dans d’autres, il suffira d’afficher un message à l’écran, dans d’autres encore, il faudra arrêter toute l’exécution du programme, etc.).</p>
<pre class="taille60"><code>/**
* Insère un nouvel entier dans le Tableau
* @param elem l'entier à insérer
* @return faux si le tableau est plein, true sinon
*/
public boolean inserer (int elem) {
    if (nbEntiers == MAX_ELEM) {
        return false;
    }
    tab[nbEntiers] = elem;
    nbEntiers++;
    return true;
}</code></pre>
                    <p>L’insertion décrite dans cet algorithme consiste simplement à insérer le nouvele entier après le dernier élément logique. Vu qu’en Java les tableaux commencent à l’indice 0, de façon assez commode le dernier élément logique est à l’indice nbEntiers – 1 et l’on fait donc l’insertion à l’indice nbEntiers.</p>
                    <p>L’inconvénient de cette méthode est qu’une fois le tableau plein on ne peut plus rien faire. Voici une méthode permettant d’augmenter la taille du tableau une fois celui-ci complètement rempli :</p>
<pre class="taille60"><code>/**
* Insère un nouvel entier dans le Tableau
* Si la table est pleine, on double sa taille
* @param elem l'entier à insérer
*/
public boolean inserer (int elem) {
    if (nbEntiers == tab.length) {
        // Plus de place ? On double la taille du tableau
        int[] tmp = new int[tab.length * 2];
        for (int i = 0; i &lt; nbEntiers; i++) {
            tmp[i] = tab[i];
        }
        tab = tmp;
    }
    tab[nbEntiers] = elem;
    nbEntiers++;
    return true;
}</code></pre>
                    <p>Ici lorsque l’on détecte que le tableau est plein, on crée un deuxième tableau deux fois plus grand dans lequel on vient recopier les éléments du tableau original. Ensuite l’instruction tab = tmp remplace l’ancien tableau par le nouveau. Cela est possible car en Java les tableaux sont traités comme des objets et la table tab contient une référence vers le tableau. tab = tmp change donc uniquement les références.</p>
                    <h3 id="insertion_table_triee">Insertion dans une table triée :</h3>
                    <p>Lors de cette insertion, nous devons conserver le caractère trié du tableau. Nous ne pouvons donc pas simplement insérer l’élément en dernière position.</p>
                    <p>Si la case prévue pour le nouvel élément est occupée, nous allons déplacé les éléments situés entre l’indice de la case occupée et l’indice du dernier élément. Ce déplacement ne pourra pas se faire d’un seul coup. Nous devrons les déplacer un à un en commençant par le dernier :</p>
<pre class="taille60"><code>/**
* Insère un nouvel entier dans le tableau
* Les entiers sont triés par ordre croissant de numéro.
* @param elem l'entier à insérer
* @return false si le tableau est plein, true sinon
*/
public boolean inserer (int elem) {
    if (nbEntiers == MAX_ELEM) {
        return false;
    }
    int i = nbEntiers - 1;
    while (i &gt;= 0 &amp;&amp; tab[i] &gt; elem) {
        tab[i + 1] = tab[i];
        i = i - 1;
    }
    tab[i + 1] = elem;
    nbEntiers++;
    return true;
}</code></pre>
                    <p>Nous pourrions écrire un algorithme équivalent pour un tableau d’objets. La différence avec l’algorithme sur le tableau d’entiers est qu’ici nous devons explicitement aller chercher la clef des éléments avec la méthode getNumero() :</p>
<pre class="taille60"><code>public class TableauDArticle {

    public static final int MAX_ARTICLES = 30;
    Article[] tabArticles = new Article[MAX_ARTICLES];
    int nbArticles = 0;

    /**
    * Insère un nouvel article dans le Tableau
    * Les articles sont triés par ordre croissant de numéro.
    * @param a l'article à Insérer
    * @return false si le tableau est plein, true sinon
    */
    public boolean inserer (Article a) {
        if (nbArticles == MAX_ARTICLES) {
            return false;
        }
        int i = nbArticles - 1;
        while (i &gt; 0 &amp;&amp; tabArticles[i].getNumero() &gt; a.getNumero()) {
            tabArticles[i + 1] = tabArticles[i];
            i = i - 1;
        }
        tab[i + 1] = a;
        nbArticles++;
        return true;
    }
}</code></pre>
                    <h3 id="recherche_sequentielle_table_triee">Recherche séquentielle dans une table triée :</h3>
<pre class="taille60"><code>/**
* Recherche si elem se trouve dans le tableau
* et renvoie son indice si nécessaire
* @param elem clef de l'élément cherché
* @return -1 si elem n'est pas présent, l'indice
* dans le tableau sinon
*/
public int chercherIndice (int elem) {
    if (nbEntiers == 0) {
        return -1;
    }
    int pos = 0;
    while (pos &lt; nbEntiers - 1 &amp;&amp; tab[pos] &lt; elem) {
        pos++;
    }
    if (tab[pos] == elem) {
        return pos;
    } else {
        return -1;
    }
}</code></pre>
                    <h3 id="recherche_dichotomique_table_triee">Recherche dichotomique dans une table triée :</h3>
                    <h4>Version 1 :</h4>
<pre class="taille60"><code>/**
* Recherche si elem se trouve dans le tableau
* et renvoie son indice si nécessaire
* @param elem clef de l'élément cherché
* @return -1 si elem n'est pas présent, l'indice
* dans le tableau sinon
*/
public int chercherIndiceDicho (int elem) {
    if (nbEntiers == 0) {
        return -1;
    }
    int debut = 0, fin = nbEntiers - 1;
    int milieu;
    while (debut &lt;= fin) {
       milieu = (debut + fin) / 2;
       if (tab[milieu] == elem) {
        debut = milieu + 1;
       } else {
        fin = milieu - 1;
       }
    }
    return -1;
}</code></pre>
                    <h4>Version 2 :</h4>
<pre class="taille60"><code>public int chercherIndiceDicho2 (int elem) {
    if (nbEntiers == 0) {
        return -1;
    }
    int debut = 0, fin = nbEntiers - 1;
    int milieu = 0;
    while (debut &lt; fin) {
        milieu = (debut + fin) / 2;
        if (tab[milieu] &gt;= elem) {
            fin = milieu;
        } else {
            debut = milieu + 1;
        }
    }
    if (tab[milieu] == elem) {
        return fin;
    } else {
        return -1;
    }
}</code></pre>
                    <p>Intuitivement, on pourrait être tenté de croire que rechercheDichoomique1 est plus efficace : en effet, si on tombe directement (ou en cours de traitement) sur l’élément cherché lui-même, on sort directement de la répétitive : on gagne du temps dans ce cas-là.</p>
                    <p>Mais... y gagne-t-on en moyenne ?</p>
                    <p>La réponse est sûrement affirmative pour un traitement humain (recherche de la bonne fiche dans un tas de fiches cartonnées bien triées), car, pour nous, il est aussi rapide (voire plus rapide !) de trouver quelle relation est correcte parmi "A &gt; B", "A = B", et "A &lt; B" que de trouver quelle relation est correcte parmi "A &gt;= B" et "A &lt;= B". Pour un ordinateur cependant, cette dernière tâche demande une seule comparaison, alors que la première en demande deux (qui se présentent comme deux "SI" imbriqués) ! Il faut donc regarder de plus près ce quel'on gagne et ce que l'on perd.</p>
                    <p>Conclusion : si ce sont les comparaisons qui prennent le plus de temps, rechercheDichotomique2 est presque 2 fois plus rapide que rechercherDichotomique1 (en moyenne), bien que ces deux algorithmes soient tous deux en O(log n); si les comparaisons sont moins coûteuses que la simple manipulation de la répétitive (par exemple si les clés sont de simples entiers), le gain es moins flagrant mais reste net.</p>
                </article>
                <article>
                    <h2 id="algorithmes_tri">Algorithmes de tri :</h2>
                    <p>Un <span class="em">algorithme de tri interne</span> a pour but de trier le contenu d'une table unidimensionnelle dans la mémoire centrale de l'ordinateur (à l'opposé d'un tri externe, qui trie des données situées à l'extérieur de l'ordinateur, donc dans un fichier).</p>
                    <p>Le verbe "trier" est utilisé ici dans le sens où on le rencontre dans le jargon des informaticiens; le verbe "ordonner" serait plus approprié, puisqu'il s'agit en fait de <span class="em">modifier l'ordre de rangement des éléments dans la table de façon à les placer en ordre croissant (ou décroissant d'une certaine clé</span>.</p>
                    <p>On essaie en général que ces algorithmes n’utilisent pas d’espace supplémentaire par rapport à la table elle-même, à l’exception d’une ou deux zones servant à stocker temporairement un élément de la table. On ne travaille donc pas sur une seconde table !</p>
                    <p>Un algorithme de tri est dit <span class="em">stable</span> si l'ordre relatif de deux éléments ayant même valeur de clé est toujours conservé, et instable dans le cas contraire. Le caractère de stabilité d'un tri est essentiel dans certaines applications, et inintéressant dans d'autres : l'informaticien saura tenir compte de ce critère dans le choix d'un algorithme !</p>
                    <h3 id="tri_par_insertion">Le tri par insertion :</h3>
                    <p>Cet algorithme part du fait que la sous-table constituée du seul premier élément est trivialement déjà triée (comme toute table d’un seul élément !). Ensuite, il considère successivement chacun des éléments du deuxième jusqu’au dernier, il insère chacun d’eux dans la partie de la table déjà triée, celle-ci gonflant progressivement jusqu’à recouvrir la table complète. S’il y a N éléments à trier, cet algorithme effectue donc N – 1 opérations d’insertion dans une table triée.</p>
<pre class="taille60"><code>// Les éléments 0 ... i-1 sont triés
for (int i = 1; i &lt; nbEntiers - 1; i++) {
    int elem = tab[i] // élément à insérer
    int j = i - 1;
    while (j &gt;= 0 &amp;&amp; tab[j] &gt; elem) {
        tab[j + 1] = tab[j];
        j = j - 1;
    }
    tab[j + 1] = elem;
}</code></pre>
                    <p>Cet algorithme de tri est <span class="em">stable</span>.</p>
                    <p>Sa <span class="em">complexité</span> est en O(N<sup>2</sup>), le nombre de comparaisons et le nombre de déplacements étant tous deux en moyenne approximativement égaux à N<sup>2</sup>/4.</p>
                    <h3 id="tri_par_selection">Le tri par sélection (ou extraction) :</h3>
                    <p>L’idée est encore plus simple : on cherche d’abord dans toute la table quel est le plus petit élément, et on vient le placer en première position en le permutant avec celui qui s’y trouve. Ensuite, on recommence pour le plus petit de ceux qui restent, et on le place en deuxième position. Et ainsi de suite jusqu’à l’avant-dernier. Le dernier est forcément déjà bien placé quand on y arrive.</p>
<pre class="taille60"><code>// Le tableau 0 ... i - 1 est trié
// Tous les éléments en i ... nbEntiers - 1
// sont plus grands que tab[i - 1]
for (int i = 0; i &lt; nbEntiers - 1; i++) {
    // On va chercher le min dans le tableau i ... nbEntiers - 1
    int indiceMin = i;
    for (int j = i + 1; j &lt; nbEntiers; j++) {
        if (tab[j] &lt; tab[indiceMin]) {
            indiceMin = j;
        }
    }
    // On échange le min avec l'élément en pos i
    int tmp = tab[i];
    tab[i] = tab[indiceMin];
    tab[indiceMin] = tmp;
}</code></pre>
                    <p>Cet algorithme n’est pas stable, comme on peut aisément s’en assurer. En effet, lorsque l’on échange deux éléments, on perd l’ordre entre les ex-aequos.</p>
                    <p>Sa complexité est en O(N<sup>2</sup>), mais seules les opérateurs de comparaison sont effectivement de cette complexité, tandis que le nombre de déplacements d'éléments est seulement en O(N) : cet algorithme sera donc à privilégier lorsque les éléments seront de grande taille, mais les clés petites.</p>
                    <h3 id="tri_bulles">Le tri-bulles (Bubble-sort) :</h3>
                    <p>Ce tri est, à juste titre, considéré comme <span class="em">le plus lent</span> des tris classiques : il est donc à éviter à tout prix, sauf dans des situations particulières (tables très petites par exemple).</p>
                    <p>On n’y compare chaque fois que deux éléments consécutifs, et on les permute si leur ordre relatif est incorrect. En répétant cette opération un très grand nombre de fois, on finit par obtenir une table ordonnée.</p>
<pre class="taille60"><code>// Le tableau i + 1 ... nbEntiers - 1 est trié
for (int i = nbEntiers - 1; i &gt;= 1; i--) {
    // inverser tous les éléments consécutifs qui ne
    // sont pas dans le bon ordre
    for (int j = 1; j &lt;= i; j++) {
        if (tab[j + 1] &gt; tab[j]) {
            int tmp = tab[j];
            tab[j] = tab[j + 1];
            tab[j + 1] = tmp;
        }
    }
}</code></pre>
                    <p>Cet algorithme est stable. Sa complexité est en O(N<sup>2</sup>). Au total : environ N passes, et à chacune en moyenne N/2 comparaisons et N/4 échanges, soit en tout environ N<sup>2</sup>/2 comparaisons et 3N<sup>2</sup>/4 déplacements.</p>
                </article>
                <article>
                    <h2 id="tableaux_plusieurs_dimensions">Les tableaux à plusieurs dimensions :</h2>
                    <p>Dans de nombreux langages, en particulier en Java, une table à plusieurs dimensions n’est pas un nouveau concept. En effet, elle n’est rien d’autre qu’une table à une dimension, mais dont les éléments sont eux-mêmes des tables.</p>
                    <p>L'organisation dans la mémoire de l'ordinateur peut être deux espèces :</p>
                    <ol type="A">
                        <li>
                            <p>Dans un langage où les tableaux sont accessibles directement, sans l'intermédiaire de "pointeurs", on a une organisation en mémoire selon les schémas suivants :</p>
                            <img src="../images/tableaux_multidimensionnels_1.png" alt="">
                            <p>En particulier, on pourrait avoir la situation où le "n'importe quoi" est à son tour un tableau :</p>
                            <img src="../images/tableaux_multidimensionnels_2.png" alt="">
                        </li>
                        <li>
                            <p>Dans des langages comme le Java, où les tableaux sont accessibles via des "pointeurs", la situation est la suivante :</p>
                            <img src="../images/tableaux_multidimensionnels_3.png" alt="">
                            <img src="../images/tableaux_multidimensionnels_4.png" alt="">
                            <p>Dans les deux cas, on pourra écrire :</p>
                            <p>Parfois, la notation condensée <span class="em">t[i, j]</span> peut <span class="em">t[i][j]</span>, ce qui donne l'illusion d'un rôle similaire pour les deux indices.</p>
                            <p>La représentation d'un tableau bidimensionnel <span class="em">sous forme de lignes et de colonnes</span> n'est qu'une facilité de présentation pour l'oeil humain. Souvent, on convient que le premier indice est le numéro de la ligne et le second celui de la colonne, mais ce n'est qu'une pure convention, qui n'intervient en rien dans la définition du langage de programmation lui-même.</p>
                            <img src="../images/tableaux_multidimensionnels_5.png" alt="">
                            <p class="souligne">En Java :</p>
                            <p>Soit la déclaration suivante :</p>
<pre class="taille60"><code>int[][] matrice; // tableau de tableaux d'entiers</code></pre>
                            <p>La variable <span class="em">matrice</span> est un tableau à une dimension d'éléments qui sont du type <span class="em">int[]</span>, c'est-à-dire eux-mêmes des tableaux à une dimension de nombres entiers. Supposons que cette variable soit construite par l'instruction :</p>
<pre class="taille60"><code>matrice = new int[5][];</code></pre>
                            <p>On a ainsi construit un tableau de 5 "cases" qui contiennent en fait 5 "pointeurs" vers des objets non encore alloués, qui seront des tableaux d'entiers.</p>
                            <p>On peut alors allouer chaucun de ces 5 tableaux. Il y a deux cas :</p>
                            <ol>
                                <li>
                                    <p>Ces 5 tableaux d'entiers ont la même taille :</p>
<pre class="taille60"><code>for (int i = 0; i &lt; 5; i++) {
    matrice[i] = new int[7];
}</code></pre>
                                    <p>On a ainsi créé au total un tableau de 5 éléments qui sont eux-mêmes des tableaux de 7 entiers. On peut voir cela comme un tableau à deux dimensions, ou encore une "matrice" 5x7. (N.B. Il s'agit ici d'une "matrice à 5 lignes et 7 colonnes", selon la convention fréquente; mais ce n'est qu'une convention de considérer que le premier indice est l'indice de ligne et le second indice celui de colonne : l'inverse est tout aussi admissible !).</p>
                                    <p>La construction du tableau complet peut aussi se faire en un coup :</p>
<pre class="taille60"><code>matrice = new int[5][7];</code></pre>
                                    <p>Les éléments de la matrice seront désignés dans les instructions par <span class="em">matrice[ligne][colonne]</span> où ligne et colonne peuvent être remplacées par des expressions quelconques fournissant des nombres entiers.</p>
                                </li>
                                <li>
                                    <p><span class="em">Ces 5 tableaux ont des tailles différentes.</span> On ne parlera alors plus de "matrice" ou de "tableau à plusieurs dimensions" mais simplement de "tableau de tableaux".</p>
                                    <p>Exemple :</p>
<pre class="taille60"><code>int[][] tabTab = new int[5][];
tabTab[0] = new int[7];
tabTab[1] = new int[9];
tabTab[2] = new int[2];
tabTab[3] = new int[15];
tabTab[4] = new int[7];</code></pre>
                                    <p>On pourra ainsi utiliser les variables entières <span class="em">tabTab[0][4]</span> et <span class="em">tabTab[3][14]</span> mais pas <span class="em">tabTab[0][14]</span>.</p>
                                    <p>Tout ceci peut être étendu à des dimensions plus élevées. Exemple :</p>
<pre class="taille60"><code>float[][][] tableauTridimensionnel = new float[5][10][5];
for (int i = 0; i &lt; 5; i++) {
    for (int j = 0; j &lt; 10; j++) {
        for (int k = 0; k &lt; 5; k++) {
            tableauTridimensionnel[i][j][k] = 0.0;
        }
    }
}</code></pre>
                                    <p>Tant conceptuellement que techniquement, tout ce qui a été dit à propos des tableaux à deux dimensions (ou "matrices") peut s'étendre à un nombre arbitraire de dimensions. Seule la représentation graphique en est plus malaisée : cela est uniquement dû au caractère dimensionnel des écrans et feuilles de papier (ainsi que de notre rétine !).</p>
                                    <p>Voici un exemple :</p>
                                    <p>L'horaire de cours de l'Institut Paul Lambin, pour lequel on va supposer pour simplifier tous les cours débutent à une heure "ronde" (8h, 9h, 10h, ...), peut être représenté comme :</p>
                                    <ul>
                                        <li>Un tableau de deux éléments correspondant aux deux semestres, constitués chacun de :</li>
                                        <li>Un tableau de 5 éléments correspondant aux 5 sections, chacun étant constitué de :</li>
                                        <li>Un tableau de 3 éléments correspondant aux 3 années, chacun étant constitué de :</li>
                                        <li>Un tableau de X éléments correspondant aux X séries de cette section et de cette année, chacun étant constitué de :</li>
                                        <li>Un tableau de 5 éléments correspondant aux 5 jours de la semaine, chacun étant constitué de :</li>
                                        <li>Un tableau de 11 éléments, correspondant aux 11 heures de la journée (de 8h à 19h), chacun étant constitué de :</li>
                                        <li>Un nom de cours, un numéro de local, un professeur.</li>
                                    </ul>
                                    <p>Nous pouvons donc utiliser un tableau à 6 dimensions, ou plutôt un "tableau de tableaux de tableaux de tableaux de tableaux".</p>
                                    <p>Par exemple :</p>
<pre class="taille60"><code>int [] [] [] [] [] [] horaire = new int [0] [4] [0] [7] [2] [10];</code></pre>
                                    <p>Désignera l'activité, durantle premier semestre (0), des étudiants de la série 7 de 1<sup>ère</sup> (0) informatique (4) le mercredi (jour n°2) à 17h (heure n°10).</p>
                                    <p>Et pour imprimer tout l'horaire de cette série en 5 colonnes correspondant aux 5 jours et en 11 lignes correspondant aux 11 heures, le tout sur deux pages correspondant aux deux semestres, on peut écrire :</p>
<pre class="taille60"><code>for (int semestre = 0; semestre &lt; 2; semestre++) {

    saut_de_page;
    imprimer("semestre numéro "+ (semestre + 1));

    for (int jour = 0; jour &lt; 5; jour++) {
        imprimer(nomDuJour[jour]); // titre colonnes
        passer_à_la_ligne;

        for (int heure = 0; heure &lt; 11; heure++) {
            imprimer(heure + 8); // titre lignes
            for (int jour = 0; jour &lt; 5; jour++) {
                imprimer(horaire[semestre][4][0][7][jour][heure]);
                passer_à_la_ligne;
            }
        }
    }
</code></pre>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="resume_algo_apoo">Résumé d'Algo et d'APOO :</h2>
<pre class="taille60">import java.util.Iterator;

public class NomDeLaClasse extends ClasseParent implements Interface1, Interface2 {

    // dÃ©clarer des attributs d'une classe en private
    // remplacer typeDeMaVariable par un type primitif (int, char, float, boolean)
    // ou par un type référence (String, Object, ...)
    // le nom d'une variable utilise le camelCase (première lettre de chaque mot en
    // Majuscules) et ne possède
    // ni accents ni caractères spéciaux ('_' par exemple)
    private typeDeMaVariable maVariable;
    private typeDeMaVariable[] monTableau;
    private int tailleLogique;
    // une constante est toujours static et final et en MAJUSCULES
    private static final typeDeMaVariable MA_CONSTANTE;

    // Le constructeur de la classe est public et initialise tous les attributs de
    // la classe lors de l'initialisation
    // il porte le même nom que la classe et n'a pas de typeDeRetour
    public NomDeLaClasse (typeDeMaVariable maVariable, int taillePhysique) {
        // this permet de différencier l'attribut de la classe au paramètre
        this.maVariable = maVariable;
        this.monTableau = new typeDeMaVariable[taillePhysique];
        this.tailleLogique = 0;
    }
    
    // un getter est un accesseur
    public typeDeMaVariable getMaVariable() {
        return maVariable;
    }
    
    // un setter est un modificateur
    public void setMaVariable(typeDeMaVariable maVariable) {
        this.maVariable = maVariable;
    }
    
    public boolean ajouterElem(typeDeMaVariable elem) {
        int taillePhysique = monTableau.length;
        // test si le tableau est rempli
        if (taillePhysique == tailleLogique) {
            return false;
        }
        monTableau[tailleLogique] = elem;
        tailleLogique++;
        return true;
    }
    
}<code></code></pre>
                </article>
                <article>
                    <h2 id="rsa">Cryptage du RSA :</h2>
                    <p>Dans le fichier "MathEXception.java" :</p>
<pre class="taille60"><code class="html">package crypto;

public class MathException extends RuntimeException {

    /**
    * 
    */
    private static final long serialVersionUID = 1L;

    public MathException() {
        super();
    }

    public MathException(String message) {
        super(message);
    }

}</code></pre>
                    <p>Dans le fichier "Zn.java" :</p>
<pre class="taille60"><code class="html">package crypto;

/*
* Classe représentant Z_n : l'ensemble des entiers modulo n
*/
public class Zn {

    private long n;

    public Zn(long n) {
        if (n <= 0) {
            throw new IllegalArgumentException("n's less that 0 !");
        }
        this.n = n;
    }

    // renvoie le cardinal de Z_n
    public long getN() {
        return n;
    }

    // renvoie true si l'entier x appartient à Z_n, false sinon
    public boolean contient(long x) {
        return x < n && x >= 0;
    }

    // calcule a + b dans Z_n
    // renvoie une IllegalArgumentException si a ou b n'appartient pas à Z_n
    public long plus(long a, long b) {
        if (!contient(a) || !contient(b)) {
            throw new IllegalArgumentException("nor a or b are in Zn");
        }
        return (a + b) % n;
    }

    // calcule a * b dans Z_n
    // renvoie une IllegalArgumentException si a ou b n'appartient pas à Z_n
    public long fois(long a, long b) {
        if (!contient(a) || !contient(b)) {
            throw new IllegalArgumentException("nor a or b are in Zn");
        }
        return (a * b) % n;
    }

    // calcule l'inverse de x dans Z_n en utilisant l'algorithme d'Euclide étendu
    // lance une IllegalArgumentException si x n'est pasdans Z_n
    // lance une MathException si x n'admet pas d'inverse dans Z_n
    public long inverse(long x) { // TODO
        if (!contient(x)) {
            throw new IllegalArgumentException("x's not in Zn");
        }
        if (x == 0) {
            throw new MathException("x cannot be 0 because 0 is not invertible");
        }
        long vi0 = 0;
        long vi1 = 1;
        long lastVi0 = 0;
        long lastVi1 = 1;
        long ri0 = n;
        long ri1 = x;
        long qi = ri0 / ri1; // initiate Qi
        long ri = ri0 % ri1; // initiate Ri
        while (n > 1) {
            // viGen2 = n
            // n = ri;
            
            // z swap value
            long temp = vi0;
            vi0 = lastVi1 - qi *vi0; // put value lastVi - 2 + (-Qi * ViGen-2) in ViGen-2
            lastVi1 = temp;
            
            // z swap value
            temp = vi1;
            vi1 = lastVi0 - qi *vi1; // do same for ViGen-1
            lastVi0 = temp;
        }
        if (ri == 1) {
            if (vi0 < 0) {
                return (n - Math.negateExact(vi0)) % n;
            }
            return vi0;
        } else {
            throw new MathException("x is not invertible");
        }
    }
    
    // calcule x^a dans Z_n en utilisant l'algorithme récursif d'exponentiation rapide modulaire
    // lance une IllegalArgumentExcepyion si x n'est pas dans Z_n ou si l'exposant est strictement négatif
    // lance une MathException si x  = 0 et a = 0 (0^0 est une indetermination)
    public long puissance (long x, long a) {
        if (a == 0 && x == 0) {
            throw new MathException("indetermined case0^0");
        }
        if (!contient(x) || a < 0) {
            throw new IllegalArgumentException("either x is not in Zn or a is negative !");
        }
        if (a % 2 != 0) { // if the exponen's odd
            long p = puissance(x, (a - 1) / 2);
            return x * p * p;
        } else {
            long p = puissance(x, a / 2);
            return p * p;
        }
    }
}</code></pre>
                    <p>Dans le fichier "TestZn.java" :</p>
<pre class="taille60"><code class="html">package crypto;

import java.lang.reflect.Field;
import java.util.Scanner;

public class TestZn {

    private static Class<Zn> classe = Zn.class;
    private static Field cardinal;
    private static final Scanner scanner = new Scanner(System.in);
    private static final String[] NOMS_METHODES = { "du constructeur Zn(int n)", "de la méthode contient",
            "de la méthode plus", "de la méthode fois", "de la méthode inverse", "de la méthode puissance" };

    public static void main(String[] args) throws IllegalAccessException {
        Field[] champs = classe.getDeclaredFields();
        for (Field f : champs) {
            if (f.getType() == long.class) {
                if ("n".equals(f.getName())) {
                    cardinal = f;
                    cardinal.setAccessible(true);
                }
            }
        }

        System.out.println("*********************************");
        System.out.println("Programme Test pour la classe Zn ");
        System.out.println("*********************************");

        int choix = 0;
        while (true) {
            for (int i = 0; i < NOMS_METHODES.length; i++) {
                System.out.println((i + 1) + " -> Test " + NOMS_METHODES[i]);
            }
            System.out.println("autre -> Quitter");

            choix = scanner.nextInt();
            boolean testOK;
            switch (choix) {
            case 1:
                testOK = testConstructeur();
                break;
            case 2:
                testOK = testContient();
                break;
            case 3:
                testOK = testPlus();
                break;
            case 4:
                testOK = testFois();
                break;
            case 5:
                testOK = testInverse();
                break;
            case 6:
                testOK = testPuissance();
                break;
            default:
                return;
            }
            if (testOK) {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a réussi.");
            } else {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a échoué.");
            }
            System.out.println();
        }
    }

    private static boolean testConstructeur() throws IllegalAccessException {

        Zn zn;

        System.out.println("Test 1");
        System.out.println();

        try {
            zn = new Zn(0);
            System.out.println("Il fallait une exception car n = 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancer la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            zn = new Zn(-1);
            System.out.println("Il fallait une exception car n est négatif");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancer la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            long exemple = 5;
            zn = new Zn(exemple);
            long n = cardinal.getLong(zn);
            if (n != exemple) {
                System.out.println("Le cardinal deZn n'est pas bon : attendu : " + exemple + " reçu : " + n);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception");
        }

        return true;
    }

    private static boolean testContient() throws IllegalAccessException {

        if (!testConstructeur()) {
            System.out.println("Il faut d'abord écrire le constructeur de manière correcte.");
            return false;
        }

        System.out.println("Constructeur OK");
        System.out.println("Début des tests de la méthode contient");
        System.out.println();
        System.out.println("Test 1");
        System.out.println();

        long exemple = 32;
        Zn zn = new Zn(exemple);
        if (zn.contient(exemple)) {
            System.out.println(exemple + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        exemple = 33;
        if (zn.contient(exemple)) {
            System.out.println(exemple + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        exemple = 355;
        if (zn.contient(exemple)) {
            System.out.println(exemple + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        exemple = -1;
        if (zn.contient(exemple)) {
            System.out.println(exemple + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        exemple = -32;
        if (zn.contient(exemple)) {
            System.out.println(exemple + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        exemple = 0;
        if (!zn.contient(exemple)) {
            System.out.println(exemple + " appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        exemple = 1;
        if (!zn.contient(exemple)) {
            System.out.println(exemple + " appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        exemple = 31;
        if (!zn.contient(exemple)) {
            System.out.println(exemple + " appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        }

        return true;
    }

    private static boolean testPlus() throws IllegalAccessException {
        if (!testConstructeur()) {
            System.out.println("Il faut d'abord écrire le constructeur de manière correcte.");
            return false;
        }

        System.out.println("Constructeur OK");
        System.out.println("Début des tests de la méthode plus");
        System.out.println();
        System.out.println("Test 1");
        System.out.println();

        Zn zn = new Zn(8);
        long somme;

        try {
            somme = zn.plus(-1, 2);
            System.out.println("Il fallait une exception car a = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            somme = zn.plus(8, 2);
            System.out.println("Il fallait une exception car a = 8 >= n = 8");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            somme = zn.plus(2, -1);
            System.out.println("Il fallait une exception car b = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            somme = zn.plus(2, 8);
            System.out.println("Il fallait une exception car b = 8 >= n = 8");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        try {
            somme = zn.plus(-1, 2);
            System.out.println("Il fallait une exception car a = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        try {
            somme = zn.plus(0, 3);
            if (somme != 3) {
                System.out.println("(0 + 3) mod 8 = 3 | reçu : (0 + 3) mod 8 = " + somme);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        try {
            somme = zn.plus(5, 0);
            if (somme != 5) {
                System.out.println("(5 + 0) mod 8 = 5 | reçu : (5 + 0) mod 8 = " + somme);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        try {
            somme = zn.plus(5, 2);
            if (somme != 7) {
                System.out.println("(5 + 2) mod 8 = 7 | reçu : (5 + 2) mod 8 = " + somme);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 9");
        System.out.println();

        try {
            somme = zn.plus(5, 7);
            if (somme != 4) {
                System.out.println("(5 + 7) mod 8 = 4 | reçu : (5 + 7) mod 8 = " + somme);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        return true;
    }

    private static boolean testFois() throws IllegalAccessException {
        if (!testConstructeur()) {
            System.out.println("Il faut d'abord écrire le constructeur de manière correcte.");
            return false;
        }

        System.out.println("Constructeur OK");
        System.out.println("Début des tests de la méthode fois");
        System.out.println();
        System.out.println("Test 1");
        System.out.println();

        Zn zn = new Zn(6);
        long produit;

        try {
            produit = zn.fois(-1, 2);
            System.out.println("Il fallait une exception car a = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            produit = zn.fois(6, 2);
            System.out.println("Il fallait une exception car a = 6 >= n = 6");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            produit = zn.fois(2, -1);
            System.out.println("Il fallait une exception car b = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            produit = zn.fois(2, 6);
            System.out.println("Il fallait une exception car b = 6 >= n = 6");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        try {
            produit = zn.fois(-1, 2);
            System.out.println("Il fallait une exception car a = -1 < 0");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        try {
            produit = zn.fois(0, 3);
            if (produit != 0) {
                System.out.println("(0 * 3) mod 6 = 0 | reçu : (0 * 3) mod 6 = " + produit);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        try {
            produit = zn.fois(5, 0);
            if (produit != 0) {
                System.out.println("(5 * 0) mod 6 = 0 | reçu : (5 * 0) mod 6 = " + produit);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        try {
            produit = zn.fois(1, 2);
            if (produit != 2) {
                System.out.println("(1 * 2) mod 6 = 2 | reçu : (1 * 2) mod 6 = " + produit);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 9");
        System.out.println();

        try {
            produit = zn.fois(5, 3);
            if (produit != 3) {
                System.out.println("(5 * 3) mod 6 = 3 | reçu : (5 * 3) mod 6 = " + produit);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 10");
        System.out.println();

        try {
            produit = zn.fois(5, 5);
            if (produit != 1) {
                System.out.println("(5 * 5) mod 6 = 1 | reçu : (5 * 5) mod 6 = " + produit);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        return true;
    }

    private static boolean testInverse() throws IllegalAccessException {
        if (!testConstructeur()) {
            System.out.println("Il faut d'abord écrire le constructeur de manière correcte.");
            return false;
        }

        System.out.println("Constructeur OK");
        System.out.println("Début des tests de la méthode inverse");
        System.out.println();
        System.out.println("Test 1");
        System.out.println();

        Zn zn = new Zn(21);
        long inverse;
        long exemple;

        try {
            exemple = -1;
            inverse = zn.inverse(exemple);
            System.out.println("Il fallait lancer une IllegalArgumentException car " + exemple
                    + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            exemple = 21;
            inverse = zn.inverse(exemple);
            System.out.println("Il fallait lancer une IllegalArgumentException car " + exemple
                    + " n'appartient pas à Z_" + cardinal.getLong(zn));
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            exemple = 0;
            inverse = zn.inverse(exemple);
            System.out.println("Il fallait lancer une MathException car " + exemple + " n'a pas d'inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        } catch (MathException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            exemple = 14;
            inverse = zn.inverse(exemple);
            System.out.println("Il fallait lancer une MathException car " + exemple + " n'a pas d'inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        } catch (MathException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        exemple = 1;
        try {
            inverse = zn.inverse(exemple);
            if (inverse != 1) {
                System.out.println(
                        "L'inverse de " + exemple + " dans Z_" + cardinal.getLong(zn) + " est 1. Reçu : " + inverse);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception car " + exemple + " a un inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        exemple = 2;
        try {
            inverse = zn.inverse(exemple);
            if (inverse != 11) {
                System.out.println(
                        "L'inverse de " + exemple + " dans Z_" + cardinal.getLong(zn) + " est 11. Reçu : " + inverse);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception car " + exemple + " a un inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        exemple = 7;
        zn = new Zn(279180);
        try {
            inverse = zn.inverse(exemple);
            if (inverse != 39883) {
                System.out.println("L'inverse de " + exemple + " dans Z_" + cardinal.getLong(zn) + " est 39883. Reçu : "
                        + inverse);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception car " + exemple + " a un inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        zn = new Zn(26);
        try {
            inverse = zn.inverse(exemple);
            if (inverse != 15) {
                System.out.println(
                        "L'inverse de " + exemple + " dans Z_" + cardinal.getLong(zn) + " est 15. Reçu : " + inverse);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception car " + exemple + " a un inverse dans Z_"
                    + cardinal.getLong(zn));
            return false;
        }

        return true;
    }

    private static boolean testPuissance() throws IllegalAccessException {
        if (!testConstructeur()) {
            System.out.println("Il faut d'abord écrire le constructeur de manière correcte.");
            return false;
        }

        System.out.println("Constructeur OK");
        System.out.println("Début des tests de la méthode puissance");
        System.out.println();
        System.out.println("Test 1");
        System.out.println();

        Zn zn = new Zn(21);
        long puissance;

        try {
            puissance = zn.puissance(-1, -1);
            System.out.println("Il fallait lancer une IllegalArgumentException car -1 n'appartient pas à Z_"
                    + cardinal.getLong(zn));
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            puissance = zn.puissance(21, 1);
            System.out.println("Il fallait lancer une IllegalArgumentException car 21 n'appartient pas à Z_"
                    + cardinal.getLong(zn));
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            puissance = zn.puissance(2, -1);
            System.out.println("Il fallait lancer une IllegalArgumentException car l'exposant est négatif");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            puissance = zn.puissance(0, 0);
            System.out.println("Il fallait lancer une MathException car 0^0 est indéterminé.");
            return false;
        } catch (MathException e) {

        } catch (Exception e) {
            System.out.println("Vous n'avez pas lancé la bonne exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        try {
            puissance = zn.puissance(0, 2);
            if (puissance != 0) {
                System.out.println("0^2 mod 21 = 0 | reçu : 0^2 mod 21 = " + puissance);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception 0^2 mod 21 = 0.");
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        try {
            puissance = zn.puissance(2, 0);
            if (puissance != 1) {
                System.out.println("2^0 mod 21 = 1 | reçu : 2^0 mod 21 = " + puissance);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception 2^0 mod 21 = 1.");
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        try {
            puissance = zn.puissance(2, 5);
            if (puissance != 11) {
                System.out.println("2^5 mod 21 = 11 | reçu : 2^5 mod 21 = " + puissance);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception 2^5 mod 21 = 11.");
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        zn = new Zn(280453);
        try {
            puissance = zn.puissance(60521, 39883);
            if (puissance != 38597) {
                System.out.println("60521^39883 mod 280453 = 38597 | reçu : 60571^39883 mod 280453 = " + puissance);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception 60521^39883 mod 280453 = 38597.");
            return false;
        }

        System.out.println();
        System.out.println("Test 9");
        System.out.println();

        try {
            long p = 69073;
            long q = 69389;
            long puissanceCorrecte = 4133696652l;
            zn = new Zn(p * q);
            puissance = zn.puissance(2011407, 5);
            if (puissance != puissanceCorrecte) {
                System.out.println(
                        "2011407^5 mod 4792906397 = 4133696652  | reçu : 2011407^5 mod 4792906397 = " + puissance);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception 2011407^5 mod 4792906397 = 4133696652.");
            return false;
        }

        return true;
    }

}</code></pre>
                    <p>Dans le fichier "RSAClefPrivee.java" :</p>
<pre class="taille60"><code class="html">package crypto;

/*
* Classe représentant une clef privée de codage RSA
*/
public class RSAClefPrivee {

    private long d;
    private Zn zn;

    // crée une nouvelle clef privée (d, p, q)
    public RSAClefPrivee(long d, long p, long q) {
        zn = new Zn(p * q);
        this.d = d;
    }

    // renvoie une String représentant le message M décodé par this
    // lance une IllegalArgumentException si M n'est pas dans zn
    public String decoder(long M) {
        if (!zn.contient(M)) {
            throw new IllegalArgumentException("M n'est pas dans z_n");
        }
        return convertir(zn.puissance(M, d));
    }

    // converti en texte l'entier m
    public static String convertir(long m) {
        long x = m;
        String texte = "";
        while (x != 0) {
            char lettre = (char) (x % 100 + 64);
            texte = lettre + texte;
            x /= 100;
        }
        return texte;
    }

}</code></pre>
                    <p>Dans le fichier "RSAClefPublique.java" :</p>
<pre class="taille60"><code class="html">package crypto;

/*
* Classe représentant une clef publique de codage RSA
*/
public class RSAClefPublique {

    private long e;
    private Zn zn;

    // crée une nouvelle clef publique (e,n)
    public RSAClefPublique(long e, long n) {
        this.e = e;
        zn = new Zn(n);
    }

    // renvoie un entier représentant message codé par this.
    // lance une IllegalArgumentException si message est null ou vide,
    // si l'entier représentant message n'est pas dans zn
    public long coder(String message) {
        // TODO
        if (message == null || message.isEmpty()) {
            throw new IllegalArgumentException("Le message est null ou vide !");
        }
        if (!zn.contient(e)) {
            throw new IllegalArgumentException("L'entier 'e' représentant le message n'est pas dans z_n");
        }
        long m = convertir(message);
        return zn.puissance(m, e);
    }

    // converti le String texte en un nombre entier
    public static long convertir(String texte) {
        long m = 0;
        for (char c : texte.toCharArray()) {
            m = 100 * m + (int) c - 64;
        }
        return m;
    }

}</code></pre>
                    <p>Pour le fichier "TestRSAClefs.java" :</p>
<pre class="taille60"><code class="html">package crypto;

import java.util.Scanner;

public class TestRSAClefs {

    private static final Scanner scanner = new Scanner(System.in);
    private static final String[] NOMS_METHODES = { "de la méthode coder de la classe RSAClefPublique",
            "de la méthode decoder de la classe RSAClefPrivee" };

    public static void main(String[] args) throws IllegalAccessException {

        System.out.println("*****************************************************************");
        System.out.println("Programme Test pour les classes RSAClefPublique et RSAClefPrivee ");
        System.out.println("*****************************************************************");

        int choix = 0;
        while (true) {
            for (int i = 0; i < NOMS_METHODES.length; i++) {
                System.out.println((i + 1) + " -> Test " + NOMS_METHODES[i]);
            }
            System.out.println("autre -> Quitter");

            choix = scanner.nextInt();
            boolean testOK;
            switch (choix) {
            case 1:
                testOK = testCoder();
                break;
            case 2:
                testOK = testDecoder();
                break;
            default:
                return;
            }
            if (testOK) {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a réussi.");
            } else {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a échoué.");
            }
            System.out.println();
        }
    }

    private static boolean testCoder() throws IllegalAccessException {

        long M;

        RSAClefPublique cp = new RSAClefPublique(27, 598153);

        System.out.println("Test 1");
        System.out.println();

        try {
            String texte = "null";
            M = cp.coder(texte);
            System.out.println("Il fallait une IllegalArguementException car le texte est null !");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e2) {
            System.out.println("Vous n'avez pas lancé la bonne exception.");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            String texte = "";
            M = cp.coder(texte);
            System.out.println("Il fallait une exception car le texte est vide!");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e2) {
            System.out.println("Vous n'avez pas lancé la bonne exception.");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            String texte = "GOUUUU";
            M = cp.coder(texte);
            System.out.println("Il fallait une exception car le texte est trop grand!");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e2) {
            System.out.println("Vous n'avez pas lancé la bonne exception.");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            String texte = "GO";
            M = cp.coder(texte);
            if (M != 418483) {
                System.out.println("Texte : GO : codé attendu : 418483 | reçu : " + M);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        cp = new RSAClefPublique(39883, 280453);
        try {
            String texte = "FEU";
            M = cp.coder(texte);
            if (M != 38597) {
                System.out.println("Texte : FEU : codé attendu : 38597 | reçu : " + M);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        cp = new RSAClefPublique(5, 204255253);
        try {
            String texte = "BOUM";
            M = cp.coder(texte);
            if (M != 90252728) {
                System.out.println("Texte : BOUM : codé attendu : 38597 | reçu : " + M);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        return true;
    }

    private static boolean testDecoder() throws IllegalAccessException {

        String texteAttendu;
        String texte;

        System.out.println("Test 1");
        System.out.println();

        RSAClefPrivee cp = new RSAClefPrivee(176755, 587, 1019);

        try {
            long M = -1;
            texte = cp.decoder(M);
            System.out.println("Il fallait une IllegalArguementException car le message est negatif !");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e2) {
            System.out.println("Vous n'avez pas lancé la bonne exception.");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            long M = 598153;
            texte = cp.decoder(M);
            System.out.println("Il fallait une exception car le message est trop grand.");
            return false;
        } catch (IllegalArgumentException e) {

        } catch (Exception e2) {
            System.out.println("Vous n'avez pas lancé la bonne exception.");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        try {
            long M = 418483;
            texte = cp.decoder(M);
            texteAttendu = "GO";
            if (!texte.equals(texteAttendu)) {
                System.out.println("Texte attendu : " + texteAttendu + " | reçu : " + texte);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        cp = new RSAClefPrivee(7, 283, 991);
        try {
            long M = 38597;
            texte = cp.decoder(M);
            texteAttendu = "FEU";
            if (!texte.equals(texteAttendu)) {
                System.out.println("Texte attendu : " + texteAttendu + " | reçu : " + texte);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        cp = new RSAClefPrivee(122536001, 14107, 14479);

        try {
            long M = 90252728;
            texte = cp.decoder(M);
            texteAttendu = "BOUM";
            if (!texte.equals(texteAttendu)) {
                System.out.println("Texte attendu : " + texteAttendu + " | reçu : " + texte);
                return false;
            }
        } catch (Exception e) {
            System.out.println("Il ne fallait pas d'exception");
            return false;
        }

        return true;
    }

}</code></pre>
                    <p>Pour le fichier "CodageRSA.java" :</p>
<pre class="taille60"><code class="html">package crypto;

import java.util.HashMap;

public class CodageRSA {

    private RSAClefPrivee clefPrivee;
    private RSAClefPublique clefPublique;
    private String proprietaire;
    private static final HashMap<String, RSAClefPublique> REGISTRE = new HashMap<String, RSAClefPublique>(); // registre
                                                                                                                // contenant
                                                                                                                // toutes
                                                                                                                // les
                                                                                                                // clefs
                                                                                                                // publiques
                                                                                                                // existantes

    // construit le codeage et publie la clef publique
    // lance une IllegalArgumentException si p et q négatif,
    // si p ou q n'est pas premier,
    // si e n'est dans Z_phi,
    // si (e, p * q) n'est pas une clef publique valable,
    // si proprietaire est vide ou null
    public CodageRSA(long e, long p, long q, String proprietaire) {
        if (p <= 0 || q <= 0 || e <= 0) {
            throw new IllegalArgumentException();
        }
        if (!estPremier(p) || !estPremier(q)) {
            throw new IllegalArgumentException();
        }
        long phi = (p - 1) * (q - 1);
        Zn znPhi = new Zn(phi);
        if (!znPhi.contient(e)) {
            throw new IllegalArgumentException();
        }
        if (pgcd(p * q, e) != 1) {
            throw new IllegalArgumentException();
        }
        if (proprietaire == null || proprietaire.isEmpty()) {
            throw new IllegalArgumentException();
        }
        this.proprietaire = proprietaire;
        clefPublique = new RSAClefPublique(e, p * q);
        clefPrivee = new RSAClefPrivee(znPhi.inverse(e), p, q);
        publier(proprietaire, clefPublique);
    }

    // renvoie la clef privée du codage
    public RSAClefPrivee getClefPrivee() {
        return clefPrivee;
    }

    // renvoie la clef publique du codage
    public RSAClefPublique getClefPublique() {
        return clefPublique;
    }

    // méthode publiant la clef (elle ajoute la clef dans le registre des clefs)
    private void publier(String proprietaire, RSAClefPublique clef) {
        CodageRSA.REGISTRE.put(proprietaire, clef);
    }

    // renvoie la clef publique associé à propriétaire s'il y en a une, null sinon
    public static RSAClefPublique obtenirClefPublique(String proprietaire) {
        return CodageRSA.REGISTRE.get(proprietaire);
    }

    // renvoie true si le nombre entier x est premier et false sinon
    public static boolean estPremier(long x) {
        if (x <= 1) {
            return false;
        }
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static long pgcd(long m, long n) {
        long r;
        while (n != 0) {
            r = m % n;
            m = n;
            n = r;
        }
        return m;
    }

}</code></pre>
                    <p>Dans le fichier "TestCodageRSA.java" :</p>
<pre class="taille60"><code class="html">package crypto;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Scanner;

public class TestCodageRSA {

    private static Class<CodageRSA> classe = CodageRSA.class;
    private static Class<RSAClefPrivee> classeCPr = RSAClefPrivee.class;
    private static Class<RSAClefPublique> classeCPu = RSAClefPublique.class;
    private static Field clefPrivee;
    private static Field clefPublique;
    private static Field proprietaire;
    private static Field registre;
    private static Field znPr;
    private static Field znPu;
    private static Field e;
    private static Field d;
    private static final Scanner scanner = new Scanner(System.in);
    private static final String[] NOMS_METHODES = {
            "du constructeur CodageRSA(long e, long p, long q, String proprietaire)", "estPremier(long x)" };

    public static void main(String[] args) throws IllegalAccessException {
        Field[] champs = classe.getDeclaredFields();
        for (Field f : champs) {
            if (f.getType() == RSAClefPrivee.class) {
                if ("clefPrivee".equals(f.getName())) {
                    clefPrivee = f;
                    clefPrivee.setAccessible(true);
                }
            } else if (f.getType() == RSAClefPublique.class) {
                if ("clefPublique".equals(f.getName())) {
                    clefPublique = f;
                    clefPublique.setAccessible(true);
                }
            } else if (f.getType() == java.lang.String.class) {
                if ("proprietaire".equals(f.getName())) {
                    proprietaire = f;
                    proprietaire.setAccessible(true);
                }
            } else if (f.getType() == java.util.HashMap.class) {
                if ("REGISTRE".equals(f.getName())) {
                    registre = f;
                    registre.setAccessible(true);
                }
            }
        }

        Field[] champsPr = classeCPr.getDeclaredFields();
        for (Field f : champsPr) {
            if (f.getType() == long.class) {
                if ("d".equals(f.getName())) {
                    d = f;
                    d.setAccessible(true);
                }
            } else if (f.getType() == Zn.class) {
                if ("zn".equals(f.getName())) {
                    znPr = f;
                    znPr.setAccessible(true);
                }
            }
        }

        Field[] champsPu = classeCPu.getDeclaredFields();
        for (Field f : champsPu) {
            if (f.getType() == long.class) {
                if ("e".equals(f.getName())) {
                    e = f;
                    e.setAccessible(true);
                }
            } else if (f.getType() == Zn.class) {
                if ("zn".equals(f.getName())) {
                    znPu = f;
                    znPu.setAccessible(true);
                }
            }
        }

        System.out.println("****************************************");
        System.out.println("Programme Test pour la classe CodageRSA ");
        System.out.println("****************************************");

        int choix = 0;
        while (true) {
            for (int i = 0; i < NOMS_METHODES.length; i++) {
                System.out.println((i + 1) + " -> Test " + NOMS_METHODES[i]);
            }
            System.out.println("autre -> Quitter");

            choix = scanner.nextInt();
            boolean testOK;
            switch (choix) {
            case 1:
                testOK = testConstructeur();
                HashMap<String, RSAClefPublique> registreCodage = (HashMap<String, RSAClefPublique>) registre
                        .get(new CodageRSA(7, 3, 5, "moi"));
                registreCodage.clear();
                break;
            case 2:
                testOK = testEstPremier();
                break;
            default:
                return;
            }
            if (testOK) {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a réussi.");
            } else {
                System.out.println("Le test " + NOMS_METHODES[choix - 1] + " a échoué.");
            }
            System.out.println();
        }
    }

    private static boolean testConstructeur() throws IllegalAccessException {

        CodageRSA codage;

        System.out.println("Test 1");
        System.out.println();

        try {
            codage = new CodageRSA(-1, 5, 7, "loic");
            System.out.println("Il fallait une exception car e < 0");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            codage = new CodageRSA(0, 5, 7, "loic");
            System.out.println("Il fallait une exception car e = 0 n'est pas premier avec phi(n)");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        try {
            codage = new CodageRSA(24, 5, 7, "loic");
            System.out.println("Il fallait une exception car e >= phi(n)");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        try {
            codage = new CodageRSA(30, 5, 7, "loic");
            System.out.println("Il fallait une exception car e > phi(n)");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        try {
            codage = new CodageRSA(24, 5, 7, "loic");
            System.out.println("Il fallait une exception car e >= phi(n)");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        try {
            codage = new CodageRSA(15, 5, 7, "loic");
            System.out.println("Il fallait une exception car e = 15 n'a pas d'inverse dans Z_phi(n)");
            System.out.println("car 15 n'est pas premier avec phi(n)=24");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        try {
            codage = new CodageRSA(15, 144, 17, "loic");
            System.out.println("Il fallait une exception car p = 144 n'est pas premier");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        try {
            codage = new CodageRSA(15, 5, 22, "loic");
            System.out.println("Il fallait une exception car q = 22 n'est pas premier");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 9");
        System.out.println();

        try {
            codage = new CodageRSA(13, 5, 7, null);
            System.out.println("Il fallait une exception car proprietaire est null");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 10");
        System.out.println();

        try {
            codage = new CodageRSA(13, 5, 7, "");
            System.out.println("Il fallait une exception car proprietaire est vide");
            return false;
        } catch (IllegalArgumentException e) {
            if (CodageRSA.obtenirClefPublique("Loic") != null) {
                System.out.println("Vous avez publié la clef publique alors qu'elle n'était pas valable");
                return false;
            }
        } catch (Exception f) {
            System.out.println("Vous n'avez pas lancer la bonne exception : " + f.getClass());
            return false;
        }

        System.out.println();
        System.out.println("Test 11");
        System.out.println();

        try {
            codage = new CodageRSA(13, 5, 11, "Loic");
            String prop = (String) proprietaire.get(codage);
            if (prop == null) {
                System.out.println("L'attribut proprietaire n'a pas été initialisé");
                return false;
            }
            if (!prop.equals("Loic")) {
                System.out.println("L'attribut proprietaire n'a pas été bien initialisé");
                System.out.println("Attendu : Loic  |   Reçu : " + prop);
                return false;
            }

            RSAClefPublique cPu = (RSAClefPublique) clefPublique.get(codage);
            if (cPu == null) {
                System.out.println("L'attribut clefPublique n'a pas été initialisé");
                return false;
            }
            long ePu = e.getLong(cPu);
            if (ePu != 13) {
                System.out.println("L'attribut e de la clef publique n'a pas été bien initialisée : attendu : 13"
                        + " | reçu : " + ePu);
                return false;
            }

            Zn znPuO = (Zn) znPu.get(cPu);
            if (znPuO.getN() != 55) {
                System.out.println("Le Zn de la clef publique n'a pas été bien initialisée : attendu n = 55 "
                        + "| reçu n = " + znPuO.getN());
                return false;
            }

            RSAClefPrivee cPr = (RSAClefPrivee) clefPrivee.get(codage);
            if (cPr == null) {
                System.out.println("L'attribut clefPrivee n'a pas été initialisé");
                return false;
            }
            long dPr = d.getLong(cPr);
            if (dPr != 37) {
                System.out.println("L'attribut d de la clef privee n'a pas été bien initialisée : attendu : 37"
                        + " | reçu : " + dPr);
                return false;
            }

            Zn znPrO = (Zn) znPr.get(cPr);
            if (znPrO.getN() != 55) {
                System.out.println("L'attribut Zn de la clef privee n'a pas été bien initialisée : attendu : 55 "
                        + "| reçu : " + znPrO.getN());
                return false;
            }

            if (CodageRSA.obtenirClefPublique("Loic") == null) {
                System.out.println("Vous n'avez pas publiée la clef publique");
                return false;
            }

        } catch (Exception e) {
            System.out.println("Il ne fallait pas lancer d'exception : " + e.getClass());
            e.printStackTrace();
            return false;
        }

        return true;
    }

    private static boolean testEstPremier() throws IllegalAccessException {

        System.out.println("Test 1");
        System.out.println();
        if (CodageRSA.estPremier(-3)) {
            System.out.println("-3 n'est pas premier car divisible par -1");
            return false;
        }

        System.out.println();
        System.out.println("Test 2");
        System.out.println();

        if (CodageRSA.estPremier(0)) {
            System.out.println("0 n'est pas premier car divisible par n'importe quel entier !");
            return false;
        }

        System.out.println();
        System.out.println("Test 3");
        System.out.println();

        if (CodageRSA.estPremier(1)) {
            System.out.println("1 n'est pas premier car n'admet que lui-même comme diviseur.");
            return false;
        }

        System.out.println();
        System.out.println("Test 4");
        System.out.println();

        if (CodageRSA.estPremier(169)) {
            System.out.println("169 n'est pas premier car admet 13 comme diviseur");
            return false;
        }

        System.out.println();
        System.out.println("Test 5");
        System.out.println();

        if (CodageRSA.estPremier(4)) {
            System.out.println("4 n'est pas premier car admet 2 comme diviseur");
            return false;
        }

        System.out.println();
        System.out.println("Test 6");
        System.out.println();

        long p = 999983;
        p = p * p;

        if (CodageRSA.estPremier(p)) {
            System.out.println(p + " n'est pas premier car admet 999983 comme diviseur");
            return false;
        }

        System.out.println();
        System.out.println("Test 7");
        System.out.println();

        p = 103 * 113;

        if (CodageRSA.estPremier(p)) {
            System.out.println(p + " n'est pas premier car admet 103 comme diviseur");
            return false;
        }

        System.out.println();
        System.out.println("Test 8");
        System.out.println();

        p = 2;

        if (!CodageRSA.estPremier(p)) {
            System.out.println(p + " est premier car divisible uniquement par 1 et lui même.");
            return false;
        }

        System.out.println();
        System.out.println("Test 9");
        System.out.println();

        p = 101;

        if (!CodageRSA.estPremier(p)) {
            System.out.println(p + " est premier car divisible uniquement par 1 et lui-même.");
            return false;
        }

        System.out.println();
        System.out.println("Test 10");
        System.out.println();

        p = 999983;

        if (!CodageRSA.estPremier(p)) {
            System.out.println(p + " est premier car divisible uniquement par 1 et lui-même.");
            return false;
        }

        return true;
    }

}</code></pre>
                </article>
                <article>
                    <h2 id="vecteur">Vecteur (VECTOR) :</h2>
                    <p>Un vecteur est une suite d'objets de même type, possédant un ordre bien précis, et dont le nombre est variable.</p>
                    <p>Un vecteur peut être vide !</p>
                    <p>L'ordre des éléments est important.</p>
                    <p>On accède à un élément via son <span class="em">rang</span>.</p>
                    <p>On appelle <span class="em">rang</span> d'un élément d'une structure linéaire, le nombre d'éléments situés avant lui. On abstrait ainsi la notion d'indice du tableau.</p>
                    <h3>Méthodes de l'interface Vecteur :</h3>
<pre class="taille60"><code class="html">public int taille ()
public boolean estVide ()
public String toString ()
public Object element (int rang) throws VecteurOutException
public void insere (int rang, Object element) throws VecteurOutException
public void ajoute (Object valeur)
public Object remplace (int rang, Object element) throws VecteurOutException
public Object supprime (int rang) throws VecteurOutException
<span class="em">public Iterator iterator()</span></code></pre>
                    <p><img src="../images/vecteur.png" alt=""></p>
<pre class="taille60"><code class="html">public class VecteurImpl implements Vecteur {

    private Object[] table;
    private int taille;

    public VecteurImpl () {
        this(16);
    }

    public VecteurImpl (int taille-) {
        this.table = new Object[taille];
        this.taille = 0;
    }

    public boolean estVide() {
        return taille == 0;
    }

    // taille logique
    public int taille() {
        return taille;
    }

    public String toString() {
        String aRenvoyer = "";
        if (taille > 0) {
            aRenvoyer += table[0];
            for (int i = 1; i &lt; taille; i++) {
                aRenvoyer += " " + table[i];
            }
        }
        return aRenvoyer;
    }

    private void testRang (int rang) throws VecteurOutException {
        if (rang &lt; 0 || rang &gt;= taille) {
            throw new VecteurOutException();
        }
    }

    private void testRangPourAjout (int rang) throws VecteurOutException{
        if (rang &lt; 0 || rang &gt; taille) {
            throw new VecteurOutException();
        }
    }

    public Object element (int rang) throws VecteurOutException {
        testRang(rang);
        return table[rang];
    }

    // conserve l'ordre des objets (décalages)
    public void insere (int rang, Objet element) throws VecteurOutException {
        testRangPourAjout(rang);
        if (taille == table.length) {
            Object[] temp = new Object[table.length * 2];
            for (int i = 0; i &lt; taille; i++) {
                temp[i] = table[i];
            }
            table = temp;
        }
        for (int i = taille - 1; i &gt;= rang; i--) {
            table[i + 1] = table[i];
        }
        taille++;
        table[rang] = element;
    }

    // ajout en fin de table
    public void ajoute (Object element) {
        try {
            insere(taille, element);
        } catch (VecteurOutException e) {
            e.printStackTrace();
        }
    }

    public Object remplace (int rang, Object element) throws VecteurOutException {
        testRang(rang);
        Object aRenvoyer = table[rang];
        table[rang] = element;
        return aRenvoyer;
    }

    // conserve l'ordre des objets (décalages)
    public Object supprime  (int rang) throws VecteurOutException {
        testRang(rang);
        Object aRenvoyer = table[rang];
        for (int i = rang; i &lt; taille - 1; i++) {
            table[i] = table[i + 1];
        }
        taille--;
        return aRenvoyer;
    }

}</code></pre>
                </article>
                <article>
                    <h2 id="pile">Pile (STACK) :</h2>
                    <p>Une  pile est une suite d'objets de même type, possédant un ordre bien précis, et dont le nombre est variable.</p>
                    <p>Une pile peut être vide !</p>
                    <p>L'ajout et le retrait se font "au sommet" de la pile.</p>
                    <p>ajouter &#8596; empiler &#8596; push</p>
                    <p>retirer &#8596; dépiler &#8596; pop</p>
                    <p>L.I.F.O. (Last In First Out)</p>
                    <h3>Méthodes de l'interface Pile :</h3>
<pre class="taille60"><code class="html">public int taille ()
public boolean estVide ()
public void push (Object c)
public Object pop () throws PileVideException
public Object sommet () throws PileVideException</code></pre>
                    <p><img src="../images/pile.png" alt=""></p>
                    <p><img src="../images/pile_impl.png" alt=""></p>
<pre class="taille60"><code class="html">public class PileImpl implements Pile {

    Object[] table;
    int taille;

    public PileImpl() {
        this(4);
    }

    public PileImpl(int capacite) {
        table = new Object[capacite];
        taille = 0;
    }

    // renvoie le nombre d'objets contenus dans la pile
    public int taille() {
        return taille;
    }

    public boolean estVide() {
        return taille == 0;
    }

    // ajoute l'élément sur la pile
    pubic void push (Object element) {
        if (taille == table.length) {
            Object[] temp = new Object[table.length * 2];
            for (int i = 0; i &lt; taille; i++) {
                tmp[i] = table[i];
            }
            table = temp;
        }
        table[taille] = element;
        taille++;
    }

    // enlève et renvoie l'objet qui se trouve au sommet de la pile
    public Object pop() throws PileVideException {
        if (estVide()) {
            throw new PileVideException();
        }
        taille--;
        return table[taille];
    }

    // renvoie l'objet qui se trouve au sommet de la pile sans l'enlever de la pile
    public Objectt sommet() throws PileVideException {
        if (estVide()) {
            throw new PileVideException();
        }
        return table[taille - 1];
    }

}</code></pre>
                </article>
                <article>
                    <h2 id="classes_internes">Les classes internes :</h2>
                    <p>Attention : les itérateurs des collections seront des classes internes.</p>
                    <p>Une classe interne (ou <span class="em">Inner class</span> en anglais) est une classe définie dans une autre classe.</p>
                    <p>Une classe externe ou englobante (ou <span class="em">Outer class</span> en anglais) est une clsse qui contient la ou les classe(s) interne(s).</p>
                    <p>Une classe interne a un accès direct aux attributs et méthodes de la classe englobante (à ses propriétés).</p>
                    <ul>
                        <li>
                            <p>Avantage : une classe qui manipule les attributs d'une autre classe sans pour autant que cette seconde ne doive les rendre publics ou accessibles via getter/setter.</p>
                        </li>
                        <li>
                            <p>À la construction, inutile de passer en paramètre les données de la classe englobante.</p>
                        </li>
                    </ul>
                    <p>Une classe interne a les mêmes règles de visibilité que pour les attributs et méthodes de la classse englobante.</p>
                </article>
                <article>
                    <h2 id="iterable_iterator">L'interface Iterable&lt;T&gt; et l'interface Iterator&lt;T&gt; :</h2>
                    <p><span class="html">public Iterator&lt;T&gt; iterator() {...}</span> est la méthode imposée par l'ubrerface <span class="html">Iterable&lt;T&gt;</span>.</p>
                    <ul>
                        <li>
                            <p>Un itérateur permet de parcourir qui se trouve dans une collection.</p>
                        </li>
                        <li>
                            <p><span class="html">&lt;T&gt;</span> : type d'objet contenu dans la liste.</p>
                        </li>
                        <li>
                            <p>L'interface <span class="html">Iterator&lt;T&gt;</span> impose les méthodes suivantes :</p>
                            <ul>
                                <li>
                                    <p class="html">public boolean hashNext() {...}</p>
                                </li>
                                <li>
                                    <p class="html">public &lt;T&gt; next() {...}</p>
                                </li>
                                <li>
                                    <p class="html">public void remove() {...}</p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <p>La méthode <span class="html">public hasNext() {...}</span> a comme responsabilité de signaler s'il reste un élément de la collection qui n'a pas encore été consulté. Elle renvoie <span class="html">true</span> s'il y a encore un élément à consulter et <span class="html">false</span> s'il y en a plus.</p>
                    <p>La méthode <span class="html">public &lt;T&gt; next() {...}</span> a comme responsabilité de renvoyer l'élément suivant, présent dans la collection parcourue par l'itérateur. Elle renvoie donc l'élément suivant de type <span class="html">&lt;T&gt;</span>. Une <span class="html">NoSuchElementException</span> est levée s'il n'y a plus d'élément à consulter. Une <span class="html">ConcurrentModificationException</span> est levée si la collection a été modifée, autrement que via l'itérateur, depuis le moment où l'iterateur a été créé.</p>
                    <p>La méthode <span class="html">public void remove() {...}</span> a comme responsabilité de supprimer l'élément de la collection qui a été renvoyée par le dernier <span class="html">next()</span>. Une <span class="html">UnsupportedOperationException</span> est levée si les suppressions sont interdites. Une <span class="html">IllegalStateException</span> est levée si un appel à <span class="html">remove()</span> vient d'être fait ou si la méthode <span class="html">next()</span> n'a pas encore été appelée. Une <span class="html">ConcurrentModificationException</span> est levée si la collection a été modifiée, autrement que via l'itérateur, depuis le moment où l'itérateur a été créé.</p>
                    <table class="tableBalises" role="presentation">
                        <thead>
                            <tr>
                                <th>VecteurImpl</th>
                                <th>ArrayList</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>VecteurImpl ()</td>
                                <td>ArrayList ()</td>
                            </tr>
                            <tr>
                                <td>VecteurImpl (int capacite)</td>
                                <td>ArrayList (int initialCapacity)</td>
                            </tr>
                            <tr>
                                <td>int taille ()</td>
                                <td>int size ()</td>
                            </tr>
                            <tr>
                                <td>boolean estVide ()</td>
                                <td>boolean isEmpty ()</td>
                            </tr>
                            <tr>
                                <td>Object element (int rang) throws VecteurOutException</td>
                                <td>E get (int index) throw indexOutOfBoundsException</td>
                            </tr>
                            <tr>
                                <td>void insere (int rang, Object element) throws VecteurOutException</td>
                                <td>void add (int index, E element) throws indexOutOfBoundsException</td>
                            </tr>
                            <tr>
                                <td>void ajoute (Object valeur)</td>
                                <td>boolean remplace (E element)</td>
                            </tr>
                            <tr>
                                <td>Object remplace (int rang, Object element) throws VecteurOutException</td>
                                <td>E set (int index, E element) throws IndexOutOfBoundsException</td>
                            </tr>
                            <tr>
                                <td>Object supprime (int rang) throws VecteurOutException</td>
                                <td>E remove (int index) throws IndexOutOfBoundsException</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>boolean contains (Object o)</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>int indexOf (Object o)</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>boolean remove (Object o)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><img src="../images/uml_iterateur.png" alt=""></p>
                    <p>Exemple :</p>
<pre class="taille60"><code class="html">import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class ListeDeCercles implements Iterable {

    private Cercle[] cercles;
    private int nombreDeCercles;
    private int numVersion = 0;

    public ListeDeCercles() {
        this.cercles = new Cercle[20];
    }

    ...

    public boolean ajouter (Cercle c) {
        if (c == null) {
            throw new IllegalArguementException();
        }
        if (contains(c)) {
            return false;
        }
        if (cercle.length == nombreDeCercles) {
            return false;
        }
        numVersion++;
        cercles[nombreDeCercles] = c;
        nombreDeCercles++;
        return true;
    }

    public Iterator iterator() {
        return new CercleIterateur();
    }

    // Classe interne : itérateur
    public class CercleIterateur implements Iterator&lt;Cercle&gt; {

        private int indice;
        private int version;
        private boolean removeAutorise;

        public CerclceIterateur() {
            this.version = numVersion;
            this.indice = 0;
            this.removeAutorise = false;
        }

        public boolean hashNext() {
            return indice &lt; nombreDeCercles;
        }

        public Cercle next() {
            if (numVersion != version) {
                throw new ConcurrentModificationException();
            }
            if(!hasNext()){
                throw new NoSuchElementException();
            }
            removeAutorise = true;
            Cercle cercle = cercles[indice];
            indice++;
            return cercle;
        }

        public void remove() {
            if (!removeAutorise) {
                throw new IllegalArguementException();
            }
            if (numVersion != version) {
                throw new ConcurrentModificationException();
            }
            removeAutorise = false;
            cercles[indice - 1] = cercles[nombreDeCercles - 1];
            cercles[nombreDeCercles - 1] = null;
            indice--;
            nombreDeCercles--;
        }

    } // fin de la classe interne

    ...

} // fin de la classe ListeDeCercles</code></pre>
                </article>
                <article>
                    <h2 id="complexite_algorithme">La complexité d'un algorithme :</h2>
                    <p>Soit f(n) une fonction de n.</p>
                    <p>On dira qu'un algorithme est en <span class="html">O(f(n))</span> si son temps d'exécution est proportionnel à f(n).</p>
                    <p>On dira qu'un algorithme est en O(f(n)) s'il existe deux nombres positifs constants k et n<sub>0</sub> tels que T(n) &lt;= k * f(n) quand n = n<sub>0</sub>.</p>
                    <p>La fonction d(n) est appelée l'<span class="em">ordre de complexité</span> de l'algorithme.</p>
                    <p>Les cas les plus fréquemment rencontrés sont les suivants :</p>
                    <ul>
                        <li>
                            <p><span class="html">O(1)</span> : durée indépendante de n</p>
                        </li>
                        <li>
                            <p><span class="html">O(log n)</span> : complexité logarithmique</p>
                        </li>
                        <li>
                            <p><span class="html">O(n)</span> : complexité linéaire</p>
                        </li>
                        <li>
                            <p><span class="html">O(n * log n)</span> : complexité  quasi-linéaire</p>
                        </li>
                        <li>
                            <p><span class="html">O(n<sup>2</sup>)</span> : complexité quadratique</p>
                        </li>
                        <li>
                            <p class="em"><span class="html">O(n<sup>3</sup>)</span> : complexité cubique</p>
                        </li>
                        <li>
                            <p class="em"><span class="html">O(n<sup>d</sup>)</span> : complexité polynomiale</p>
                        </li>
                        <li>
                            <p class="em"><span class="html">O(2<sup>n</sup>)</span> : complexité exponentielle</p>
                        </li>
                        <li>
                            <p class="em"><span class="html">O(n<sup>!</sup>)</span> : complexité factorielle</p>
                        </li>
                    </ul>
                    <p>Le facteur de proportionnalité est négligé. Il ne sera utilisé que pour départager deux agorithmes qui le même ordre de complexité.</p>
                    <p>Par exemple : <span class="html">O(n/2)</span>, <span class="html">O(n)</span> et <span class="html">O(2n) &#8594; O(n)</span>.</p>
                </article>
                <article>
                    <h2 id="file">FILE (QUEUE) :</h2>
                    <p>Une file d'attente est une suite d'objets de même type, possédant un ordre bien précis, et dont le nombre est variable.</p>
                    <p>Une file peut être vide !</p>
                    <p>L'ajout se fait en queue (fin).</p>
                    <p>Le retrait se fait en tête (début).</p>
                    <p>ajouter &#8596; enfiler &#8596; enfile</p>
                    <p>retirer &#8596; défiler &#8596; defile</p>
                    <p>F.I.F.O. (Fist In First Out)</p>
                    <p>Méthode de l'interface File :</p>
<pre class="taille60"><code class="html">public int taille ()
public boolean estVide ()
public void enfile (Object c)
public Object defile () throws FileVideException
public premier () throws FileVideException</code></pre>
                    <p><img src="../images/file.png" alt=""></p>
                    <p><img src="../images/file_circulaire.png" alt=""></p>
                    <table role="presentation" class="tableBalises">
                        <thead>
                            <tr>
                                <th>FileImpl</th>
                                <th>ArrayDeque</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>int taille ()</td>
                                <td>int size ()</td>
                            </tr>
                            <tr>
                                <td>boolean estVide ()</td>
                                <td>boolean isEmpty ()</td>
                            </tr>
                            <tr>
                                <td>Object defile () throws FileVideException</td>
                                <td>E removeFirst () throws NoSuchElementException</td>
                            </tr>
                            <tr>
                                <td>Object premier () throws FileVideException</td>
                                <td>E getFirst () throws NoSuchElementException</td>
                            </tr>
                        </tbody>
                    </table>
<pre class="taille60"><code class="html">// implémentation de l'interface File via une table circulaire
public class FileImpl implements File {

    Object[] table;
    int tete;
    int queue;
    int taille;

    public FileImpl() {
        table = new Object[4];
        tete = queue = taille = 0;
    }

    // renvoie true ssi la file est vide
    public boolean estVide() {
        return taille == 0;
    }

    // renvoie le nombre d'objets contenus dans la file
    public int taille() {
        return taille;
    }

    // ajoute l'objet element en queue de file
    public void enfile(Object element) {
        if (!estVide() && tete == queue) {
            doublerTaille(table);
        }
        table[queue] = element;
        queue = (queue + 1) % table.length;
        taille++;
    }

    // enlève et renvoie l'objet qui se trouve en tête
    public Object defile() throws FileVideException {
        if (estVide()) {
            throw new FileVideException("la file est vide");
        }
        return table[tete];
    }

    private void doublerTaille(Object[] file) {
        Object[] tmp = new Object[taille.length * 2];
        int indice = 0;
        for (int i = tete; i &lt; file.length; i++) {
            tmp[i] = table[i];
            indice++;
        }
        for (int j = 0; j  &lt; tete; j++) {
            tmp[indice] = file[j];
            indice++;
        }
        tete = 0;
        queue = indice;
        table = tmp;
    }

}</code></pre>
                </article>
            <!-- fin de section -->
            </section>
        </main>
        <footer role="contentinfo">
            <div>
                <address>
                    Professeurs :
                    <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                    <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                </address>
            </div>
            <div>
                <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
            </div>
            <div id="version">
                <p>Syllabus HTML</p>
                <p>Version 5.0</p>
            </div>
        </footer>
    </body>
</html>