<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="author" content="Choquet Olivier & Vandenheede Driss">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Algo et SD - Suppléments - e-Syllabus HTML5 et CSS3</title>
        <!-- une icône dans la barre du navigateur -->
        <link rel="icon" href="../images/favicon.png" type="image/png">
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
        <!-- liens d'évitement -->
        <ul class="a11y-nav">
            <li>
                <a href="#container">Passer directement au contenu</a>
            </li>
            <li>
                <a href="#menu">Accéder au menu secondaire de la page</a>
            </li>
            <li>
                <a href="#aside">Accéder aux liens utiles</a>
            </li>
        </ul>
        <!-- bannière et menu -->
        <header role="banner">
            <div class="logoTitle">
                <h1>Cours d'introduction au Web</h1>
                <h2>HTML5 et CSS3</h2>
            </div>
            <nav role="navigation" aria-label="Menu principal de navigation">
                <ul>
                    <li><a href="../index.html">Le cours</a></li>
                    <li><a href="../internet.html">Internet</a></li>
                    <li><a href="../html5.html">HTML5</a></li>
                    <li><a href="../css3.html">CSS3</a></li>
                    <li><a href="../methodologie.html">Méthodologie</a></li>
                    <li><a href="../lexique.html">Lexique</a></li>
                    <li><a href="../supplements.html" class="current">Suppléments</a></li>
                </ul>
            </nav>
        </header>
        <main id="container" role="main">
            <div id="menu">
                <nav role="navigation">
                    <ol>
                        <li><a href="../supplements.html">Retour au sommaire</a></li>
                    </ol>
                </nav>
                <!-- aside lié à la page et pas à l'article donc pas à l'intérieur de article -->
                <aside id="aside">
                   <p>Liens utiles :</p>
                    <ul>
                        <li><a href="http://www.w3schools.com/js/default.asp" target="_blank">Tutoriel JavaScript de W3Schools</a></li>
                        <li><a href="http://www.w3.org/" target="_blank">W3C</a></li>
                        <li><a href="http://fr.openclassrooms.com/informatique/cours/apprenez-a-creer-votre-site-web-avec-html5-et-css3" target="_blank">Open Classroom</a></li>
                        <li><a href="http://www.w3.org/TR/html5/" target="_blank">Norme HTML5</a></li>
                        <li><a href="http://www.w3schools.com/" target="_blank">W3Schools</a></li>
                        <li><a href="http://www.alsacreations.com/" target="_blank">Alsa Création</a></li>
                        <li><a href="https://www.youtube.com/c/LeDesignerduWeb/videos">Le Designer du web</a></li>
                    </ul>
                </aside>
            </div>
            <section id="mainSection">
                <article>
                    <h1>Algorithme et Structure de données :</h1>
                </article>
                <article>
                    <h2 id="notions_base">Notions de base :</h2>
                    <p>Un <span class="em">programme</span> informatique est, en gros, une séquence d'<span class="em">instructions</span>, d'ordres données à un ordinateur afin de lui faire accomplir une tâche précise. Un même programme est en général appelé à être exécuté plusieurs fois. Bien qu'on ait parlé de "tâche précise", chacune des exécutions d'un "<span class="em">alternatives</span>", c'est-à-dire des sous-séquences d'instructions qui seront exécutées ou non en fonctions des circonstances extérieures.</p>
                    <p>Si l'on retire du paragraphe précédent le mot "ordinateur", cette définition pourrait aussi s'appliquer à une recette de cuisine, telle qu'elle figuererait dans un livre de recettes. En voici un exemple (plutôt élémentaire !) :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une salade :</p>
                                    <ol type="a">
                                        <li>prendre une belle laitue, séparer les feuilles en retirant les plus abîmées</li>
                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                        <li>mettre dans un saladier3 cuillers à soupe d'huile, une de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                        <li>bien mélanger ces ingrédients</li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Jusqu'ici, dans cet exemple, il n'ya qu'un seul cheminement possible. Mais l'on pourrait imaginer la recette suivante :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une salade :</p>
                                    <ol type="a">
                                        <li>
                                            <p><span class="em">SI</span> on dispose d'une laitue qui a été vendue déjà nettoyée et découpée</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> ouvrir le sachet</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>prendre une belle laitue, séparer les feuilles en retirant les plus abîmées</li>
                                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>
                                            <p><span class="em">SI</span> on a de la vinaigrette toute faite</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> mettre 4 cuillers à soupe de vinaigrette dans un saladier</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>mettre dans un saladier 3 cuillers à soupe d'huile, de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                                        <li>bien mélanger ces ingrédients</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Dans de très nombreux programmes informatiques, en outre, une même sous-séquence d’instructions est appelée à être exécutée plusieurs fois d’affilée. Cette situation est assez naturelle, si l’on pense que l’ordinateur est surtout destiné à exécuter très rapidement des tâches de routine, c’est-à-dire des tâches répétitives.</p>
                    <p>Pour revenir à notre exemple de salade, on pourrait rencontrer les instructions suivantes :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>
                                            <p><span class="em">POUR CHACUNE</span> des feuilles de laitue :</p>
                                            <ol>
                                                <li>détacher la feuille délicatement de la laitue</li>
                                                <li>l'examiner pour voir si elle ne possède pas de tâche ou de partie froissée</li>
                                                <li>retirer les parties suspectes</li>
                                                <li>couper la feuille en morceaux et mettre ceux-ci dans l'eau de nettoyage</li>
                                            </ol>
                                        </li>
                                        <li>gôuter la vinaigrette</li>
                                        <li>
                                            <p><span class="em">TANT QUE</span> la vinaigrette n'est pas assez piquante :</p>
                                            <ol>
                                                <li>rajouter un peu de moutarde</li>
                                                <li>rajouter un peu de vinaigre</li>
                                                <li>bien mélanger</li>
                                                <li>goûter de nouveau la vinaigrette</li>
                                            </ol>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Les programmeurs parleront, dans un tel cas, de "<span class="em">répétitive</span>", d'"<span class="em">itérative</span>", ou encore de "<span class="em">boucle</span>".</p>
                    <p>Enfin, de nombreux livres de cuisine renvoient le lecteur d’une recette à l’autre, lorsqu’un mets plus élaboré en inclut un autre, plus simple. Ainsi la recette de salade pourrait se résumer à :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> péparer une salade :</p>
                                    <ol type="a">
                                        <li>préparer des feuilles de laitue (voir page XXX)</li>
                                        <li>préparer une vinaigrette (voir page YYY) et la mettre dans un sablier</li>
                                        <li>rajouter les feuilles de laitue et remuer le tout au moment de servir</li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>À la page XXX, on trouverait :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer des feuilles de laitue :</p>
                                    <ol type="a">
                                        <li>
                                            <p><span class="em">SI</span> on dispose d'une laitue qui a été venue déjà nettoyée et découpée</p>
                                            <ul>
                                                <li><span class="em">ALORS</span> ouvrir le sachet</li>
                                                <li>
                                                    <p class="em">SINON</p>
                                                    <ul>
                                                        <li>prendre une laitue, séparer les feuilles en retirant les plus abîmées</li>
                                                        <li>laver soigneusement les feuilles, puis bien les sécher</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ol>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>et la page YYY :</p>
                    <table>
                        <tbody>
                            <tr>
                                <td>
                                    <p><span class="em">POUR</span> préparer une vinaigrette :</p>
                                    <ul>
                                        <li>mettre dans un saladier 3 cuillers à soupe d'huile, une de vinaigre, un peu de moutarde, de sel et de poivre</li>
                                        <li>bien mélanger ces ingrédients</li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Cette dernière situation est rencontrée aussi en programmation : un programme fait souvent appel à un "<span class="em">sous-programme</span>" qui doit exécuter pour lui une partie du traitement. Et cette sous-traitance peut se répercuter en cascade : le sous-programme peu à son tour sous-traiter à un autre sous-programme une partie de tâche qui lui a été confiée par le "programme principal", etc.</p>
                    <p>On parlera, selon les langages et les contextes, de "<span class="em">sous-programmes</span>", de "<span class="em">procédures</span>", de "<span class="em">fonctions</span>, de "<span class="em">méthodes</span>, etc.</p>
                </article>
                <article>
                    <h2 id="cycle_vie_programme">Le cycle de vie d'un programme :</h2>
                    <p>Pour concevoir un programme, ou à fortiori toute une "<span class="em">application informatique</span>" (qui peut
                        elle-même être constituée de plusieurs programmes), l’informaticien doit d’abord faire une analyse
                        fouillée de la situation et de ce qu’on lui demande de réaliser : c’est la phase d’"<span class="em">analyse</span>", située en amont de la programmation proprement dite.</p>
                        <p>Ensuite, il doit élaborer, structurer la séquence d’instructions qui permettront de réaliser la tâche demandée. Une telle séquence d’actions, structurées à l’aide d’alternatives, de répétitives, de sousprogrammes, est appelée un "<span class="em">algorithme</span>".</p>
                        <p>Une fois conçus sur papier, les algorithmes n’auront alors plus qu’à être "<span class="em">implémentés</span>" ou "<span class="em">programmés</span> sur une machine, via un langage informatique, avant d'être <span class="em">exécutés</span>.</p>
                        <p>Enfin, la phase de <span class="em">test</span> est de <span class="em">mise au point</span> est tout à fait essentielle. Elle doit être réalisée de manière professionnelle, c’est-à-dire systématique et rigoureuse. (L’idéal est de prévoir déjà les tests avant d’écrire le programme : on pense ainsi dès le départ à tous les cas que devra traiter ce programme.)</p>
                        <p>Et il ne faut pas négliger la mise en oeuvre effective, la formation éventuelle des utilisateurs (par exemple via un "manuel d'utilisation"), et les réaménagements ultérieurs (ce qu'on appelle la "<span class="em">maintenance</span>" du programme).</p>
                        <p>Pour accompagner tout ce cheminement, une <span class="em">documentation</span> complète, précise et bien mise à jour est indispensable : elle figuera dans un <span class="em">dossier</span> (sur papier ou sur support informatique) accompagnant le programme, ainsi que dans les <span class="em">commentaires</span> insérés dans celui-ci.</p>
                </article>
                <article>
                    <h2 id="types_reference">Les types de référence :</h2>
                    <p>La <span class="em">déclaration</span> d'une variable sert :</p>
                    <ul>
                        <li>à donner à la variable son <span class="em">type</span></li>
                        <li>à demander à l'ordinateur de réserver une zone de mémoire pour elle, zone dont la taille dépendra du type</li>
                        <li>à fixer la <span class="em">portée</span> de la variable : où et quand sera-t-elle accessible ?</li>
                    </ul>
                    <p>Une variable possédera à tout moment une <span class="em">valeur</span> : c’est cette valeur qui sera stockée dans la zone de mémoire propre à la variable. Cette valeur peut changer au fur et à mesure de l’exécution du programme, d’où le terme de "variable". Mais la valeur doit toujours être conforme au "type" de la variable.</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>type</th>
                                <th>type Java</th>
                                <th>valeurs</th>
                                <th>valeur par défaut</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>nombre entier</td>
                                <td>int</td>
                                <td>325, -65, 0, 1234567890</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>nombre réel simple précision</td>
                                <td>float</td>
                                <td>32.56, -0.001, 1.03e+04(= 10300.0)</td>
                                <td>0.0</td>
                            </tr>
                            <tr>
                                <td>nombre réel double précision</td>
                                <td>double</td>
                                <td>32.56, -0.001, 1.03e+04(= 10300.0)</td>
                                <td>0.0</td>
                            </tr>
                            <tr>
                                <td>caractère</td>
                                <td>char</td>
                                <td>'A', '2', '+', ' '</td>
                                <td>''</td>
                            </tr>
                            <tr>
                                <td>booléen</td>
                                <td>boolean</td>
                                <td>true, false</td>
                                <td>false</td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h2 id="inputs_outputs">Les inputs/outputs :</h2>
                    <p>On définit une varibale servant de "lecteur" des entrées :</p>
<pre class="taille60"><code>Scanner scanner = new Scanner(System.in);</code></pre>
                    <p>On l'utilise pour lire une valeur :</p>
<pre class="taille60"><code>int nombre = scanner.nextInt();</code></pre>
                    <p>Comme le montre le tableau suivant, cette instruction diffère légèrement en fonction du type de la variable que l'on désire lire :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Instruction</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>int</td>
                                <td>int nombre = scanner.nextInt();</td>
                            </tr>
                            <tr>
                                <td>char</td>
                                <td>char caractere = scanner.nextChar();</td>
                            </tr>
                            <tr>
                                <td>String</td>
                                <td>String texte = scanner.next();</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Cette instruction est un peu délicate à manier car à la moindre erreur d’entrée de l’utilisateur, si rien n’est fait pour rattraper celle-ci, le programme s’arrêtera.</p>
                    <p>Pour écrire dans la console, on utilise :</p>
<pre class="taille60"><code>System.out.println("texte à écrire dans la console");</code></pre>
                    <p><span class="souligne">ASTUCE :</span> Sur Eclipse, écrire "sysout" et taper simultanément sur les touches "Ctrl" et "Space" permet d'écrire plus facilement le "System.out.println".</p>
                    <p>Cette instruction permet d'écrire le texte situé entre parenthèses dans la console et on passe à la ligne. Si on met "print" au lieu de "println", le texte sera écrit dans la console mais sans le saut à la ligne.</p>
                </article>
                <article>
                    <h2 id="alternatives">Les alternatives :</h2>
                    <p>Une alternative est une instruction qui permet l'ordinateur, au moment de l'exécution du programme, de choisir la partie de code à exécuter : ce choix s'effectue en fonction de certaines conditions qui, en général, font intervenir les valeurs d'une ou plusieurs variables.</p>
                    <p>Il existe deux familles d'alternatives : les alternatives à deux branches et celles à nombre quelconque de branches.</p>
                    <p>En Java, l'alternative à deux branches s'écrit comme suit :</p>
<pre class="taille60"><code><span class="em">if</span> (condition) {
    instruction_1_1;
    instruction_1_2;
    ...
    instruction_1_N;
} <span class="em">else</span> {
    instruction_2_1;
    instruction_2_2;
    ...
    instruction_2_N;
} // FIN if</code></pre>
                    <p>Une alternative n’est au final qu’une instruction comme les autres et peut donc être utilisée au sein d’une autre alternative ! C’est ce qu’on appelle "alternative imbriquée".</p>
<pre class="taille60"><code><span class="em">if</span> (x &gt; y) {
    System.out.println("x est le plus grand");
} <span class="em">else</span> {
    <span class="em">if</span> (y &gt; x) {
        System.out.println("y estle plus grand");
    } <span class="em">else</span> {
        System.out.println("x et y sont égaux");
    }
}</code></pre>
                    <p>Pour éviter de multiplier les if imbriqués, il existe une instruction permettant d'exprimer plus de deux cas : le switch-case. C'est une des alternatives à <span class="em">N branches</span>.</p>
<pre class="taille60"><code><span class="em">switch</span> (expression) {
    <span class="em">case</span> valeur_1 :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_N1;
    <span class="em">case</span> valeur_2 :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_N2;
    <span class="em">case</span> valeur_M :
        instruction_1_1;
        instruction_1_2;
        ...
        instruction_1_NM;
    <span class="em">default</span> :
        instruction_1_1;
        instruction_1_2;
        ...
}</code></pre>
                    <p>La <span class="souligne">sémantique</span> de l'instruction switch est la suivante :</p>
                    <ol>
                        <li>On évalue l'expression entre parenthèses. (Si nécessaire, on la convertit en <span class="em">int</span>.)</li>
                        <li>On compare sa valeur aux valeurs des différentes "expressions constantes".</li>
                        <li>Si sa valeur a été trouvée, on exécute toutes les instructions qui suivent cette constante, y compris celles qui sont situées au-delà des mots "<span class="em">case</span>" et "<span class="em">default</span>" suivants.</li>
                        <li>Si sa valeur n'a été trouvée, et qu'il y a une branche "<span class="em">default</span>", on passe directement à l'instruction "<span class="em">break;</span>, on quitte le switch.</li>
                        <li>Dans tous les cas, après l'exécution de ce qu'il fait, on continue en exécutant les instructions situées au-delà de l'instruction <span class="em">switch</span> (sauf bien sûr si l'on a rencontré au passage une instruction qui nous fait sortir du bloc où se trouve ce switch : <span class="em">return</span>, <span class="em">throw</span>, ...).</li>
                    </ol>
                    <p>L'expression du switch ne peut être que d'un type dont les valeurs peuvent être énumérées (int, char, ...) et donc ni des float ni des objets (pas de String non plus).</p>
                </article>
                <article>
                    <h2 id="operateurs">Les opérateurs :</h2>
                    <p>En Java,</p>
                    <ul>
                        <li>l'opérateur OU (inclusif) s'écrit <span class="em">|</span> ou <span class="em">||</span> (voir plus loin la différence)</li>
                        <li>l'opérateur ET s'écrit <span class="em">&amp;</span> ou <span class="em">&amp;&amp;</span> (voir plus loin la différence)</li>
                        <li>l'opérateur NON s'écrit <span class="em">!</span></li>
                    </ul>
                    <p>En Java, les opérateurs ET et OU sont dédoublés :</p>
                    <ul>
                        <li>
                            <p>&amp; et | imposent une évaluation complète</p>
                            <ul>
                                <li>l'ordinateur évalue exp1</li>
                                <li>puis il évalue exp2</li>
                                <li>puis il effectue l'opérateur "ET" ou "OU"</li>
                            </ul>
                        </li>
                        <li>
                            <p>&amp;&amp; et ||  demandent une évaluation court-circuitée</p>
                            <ul>
                                <li>l'ordinateur évalue exp1</li>
                                <li>si la valeur de exp1 est <span class="em">true</span>, il sait que le résultat de l'ensemble est aussi <span class="em">true</span> dans l'opération "OU", sans qu'il n'ait dû évaluer exp2</li>
                                <li>si la valeur exp1 est <span class="em">false</span> dans l'opération "OU", il évalue exp2, et le résultat de l'ensemble est égal à la valeur de exp2</li>
                            </ul>
                        </li>
                    </ul>
                    <p>La différence entre les deux consiste surtout en un gain de temps, surtout dans le cas où exp2 est une expression dont l’évaluation prend du temps : l’évaluation court-circuitée permet d’éviter ce temps inutilement dépensé.</p>
                    <dl>
                        <dt>Remarquons que :</dt>
                        <dd>(expression1) &amp; (expression2)</dd>
                        <dt>Est (en général) "équivalent à" :</dt>
                        <dd>(expression2) &amp; (expression1)</dd>
                        <dt>Ce qui n'est plus le cas si l'on utilise l'opérateur &amp;&amp;.</dt>
                        <dt>La même remarque s'applique à | et ||.</dt>
                    </dl>
                    <p>Les opérateurs de relation :</p>
                    <ul>
                        <li><span class="em">=</span> (<span class="em">==</span> en Java), <span class="em">!=</span></li>
                        <li><span class="em">&lt;</span>, <span class="em">&lt;=</span>, <span class="em">&gt;</span>, <span class="em">&gt;=</span></li>
                    </ul>
                    <p class="souligne">Quelques conseils de styles :</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Au dieu d'écrire :</th>
                                <th>Écrivez plutôt</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <ul>
                                        <li>if (trouve == true) { ... }</li>
                                        <li>while (file == false) { ... }</li>
                                        <li>
                                            <p>if ((a &gt; b) || (x == y)) b1 = true;</p>
                                            <p>else b2 = false;</p>
                                        </li>
                                        <li>if (a == b + c) b1 = true;</li>
                                        <li>if (a == 0) b1 = false;</li>
                                        <li>
                                            <p>boolean b = (a &gt; b) || (x == y);</p>
                                            <p>return b;</p>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>if (trouve) { ... }</li>
                                        <li>while (!fini) { ... }</li>
                                        <li>b1 = (a &gt; b) || (x == y);</li>
                                        <li>b1 = b1 | (a == b + c); (lisibilité discutable)</li>
                                        <li>b1 = b1 &amp; !(a == 0); (lisibilité discutable)</li>
                                        <li>return (a &gt; b) || (x == y);</li>
                                    </ul>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>En Java, l'opérateur ternaire : "... <span class="em">?</span> ... <span class="em">:</span> ..." permet aussi d'éviter certains "if" :</p>
                    <ul>
                        <li>
                            <p>au lieu de :</p>
<pre class="taille60"><code>if (a &gt; b) max = a;
else max = b;</code></pre>
                        </li>
                        <li>
                            <p>on écrira :</p>
<pre class="taille60"><code>max = (a &gt; b) ? a : b;</code></pre>
                        </li>
                    </ul>
                </article>
                <article>
                    <h2 id="repetitives">Les répétitives :</h2>
                    <p>Une répétitive (ou itérative, ou boucle) est une instruction demandant à l'ordinateur d'exécuter plusieurs fois un groupe d'instructions spécifiées (le mot "plusieurs" est à prendre ici au sens large, englobant les cas 0 et 1).</p>
                    <p>Les types de répétitives sont très variables d’un langage à l’autre, et certains langages en présentent même une grande diversité. Ces types de répétitives se différencient essentiellement par la façon dont on spécifie le <span class="souligne">nombre d'exécutions</span>.</p>
                    <p>Nous présenterons ici celle de Java ainsi que quelques macro-algorithmes.</p>
                    <ol>
                        <li>
                            <h3 id="for">La boucle for :</h3>
                            <p>Le modèle général de la boucle <span class="em">for</span> en Java est le suivant :</p>
<pre class="taille60"><code>for ( &lt;init var de contrôle&gt;; &lt;cond. de continuation&gt;; &lt;increment&gt; ) {
    &lt;Action_1&gt;;
    &lt;Action_2&gt;;
    &lt;Action_3&gt;;
    ...
    &lt;Action_N&gt;;
}</code></pre>
                            <p>Exemple :</p>
<pre class="taille60"><code>for (int i = 1; i &lt;= nombreJoueurs; i++) {
    donnerUneCarte();
}</code></pre>
                            <p>La sémantique de cette instruction est résumée par le schéma suivant :</p>
                            <img src="../images/for.png" alt="boucle for">
                            <p>Le <span class="em">corps de la boucle</span> situé entre les deux accolades est la suite d'instructions à répéter.</p>
                            <p>La <span class="em">variable de contrôle</span> de la répétitive sert à contrôler le nombre de répétitions. Il s'agit en général d'une variable entière, d'autres types sont possibles : le type caractère par exemple. Elle doit être <span class="souligne">déclarée</span> et <span class="souligne">initialisée</span> dans la boucle. Dans l'exemple donné i est la variable de contrôle. Elle est de type int est initialisée à 1.</p>
                            <p>La <span class="em">condition de continuation</span> dela répétitive est une expression de type booléen. Le corps de la boucle est répété tant que cette condition est vraie (true). Il s'agit d'une condition de continuation car on continue la boucle tant que la condition est vraie.</p>
                            <p>L'<span class="em">incrément</span> sert à augmenter (ou dimuer) la valeur de la variable de contrôle.</p>
                            <table class="tableBalises">
                                <tbody>
                                    <tr>
                                        <td>
                                            <p><span class="bold">ATTENTION :</span> La boucle for est <span class="bold souligne">impérativement</span> soumise aux <span class="em">deux contraintes</span> ci-dessous, au risque de gravement porter atteinte à la lisibilité du programme, et donc en particulier d'entraver sa maintenance :</p>
                                            <ol>
                                                <li>Ne JAMAIS modifier la valeur de la variable de contrôle à l'intérieur de la répétitive !</li>
                                                <li>Après sortie de la répétitive, la variable de contrôle est censée n'avoir plus aucune valeur : elle est "indéterminée" (comme en début d'exécution d'un programme).</li>
                                            </ol>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <h3 id="while_do_while">La boucle while et do while :</h3>
                            <table>
                                <tbody>
                                    <tr>
                                        <td>
<pre class="taille60"><code>while (&lt;condition&gt;) {
    &lt;action_1&gt;
    ...
    &lt;action_n&gt;
}</code></pre>
                                        </td>
                                        <td>D'abord letest (donc : min. 0 passage</td>
                                    </tr>
                                    <tr>
                                        <td>
<pre class="taille60"><code>do {
    &lt;action_1&gt;
    ...
    &lt;action_2&gt;
} while ( &lt;condition&gt; );</code></pre>
                                        </td>
                                        <td>D'abord les actions (donc : min. 1 passage)</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Tout comme la boucle for, la condition des while et do while est une <span class="em">condition de continuation</span>.</p>
                            <p>Si on connaît le nombre de fois qu'il faut répéter l'action et que le pas est lui aussi connu à l'avance, on emploiera une boucle <span class="em">for</span>.</p>
                            <p>Si l'on ne connaît pas le nombre de tour de boucle ou si le pas d'incrémentation n'est pas constant, on devrait utiliser une boucle <span class="em">while</span> ou <span class="em">do while</span>.</p>
                            <p>Les instructions que l’on place à l’intérieur d’une répétitive peuvent être de tout type, en particulier il peut s’agir d’autres répétitives. On obtient ainsi des boucles imbriquées dans d’autres boucles.</p>
                            <p>Une des erreurs les plus fréquentes lorsque l'on écrit des répétitives est ce que l'on appelle la boucle infinie : une répétitive qui ne s'arrête jamais.</p>
                            <p>La façon la plus simple d'avoir une boucle infinie est d'écrire une condition constante true :</p>
<pre class="taille60"><code>while(true) {
    System.out.println("Rien ne l'arrêtera !");
}</code></pre>
                            <p>De façon évidente, si l'on ne modifie aucune des variables composants la condition de la boucle, on peut avoir une boucle infinie :</p>
<pre class="taille60"><code>int a = 3, b = 5, c = 6;
while (a &lt; b) {
    c--;
}</code></pre>
                            <p>Ici, a et b conserveront leurs valeurs initiales et la condition a&lt;b est éternellement vraie.</p>
                        </li>
                    </ol>
                </article>
                <article>
                    <h2 id="string">Les String :</h2>
                    <p>Une chaîne de caractères est une suite ordonnée de 0,1 ou plusieurs caractères, que l'on peut en général manipuler globalement ou caractère par caractère. En Java, le type String représente les chaînes de caractères.</p>
                    <p>Un littéral de type String commence et termine par des guillemets doubles. Entre eux, on peut trouver :</p>
                    <ul>
                        <li>des caractères autres que " et \</li>
                        <li>
                            <p>des caractères spéciaux marqués sous forme du caractère\ suivi d'un autre caractère :</p>
                            <ul>
                                <li>\" qui représente "</li>
                                <li>\\ qui représente \</li>
                                <li>\n qui représente un passage à la ligne</li>
                                <li>\t qui représente une tabulation</li>
                                <li>etc.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>En Java, les chaînes de caractères ne constituent pas un type primitif, mais un type objet (un "type référence").</p>
                    <p>Ou, plus exactement, deux types objet. Ce langage met en effet à notre disposition deux classes, appelées String et StringBuffer. La seconde permet plus de manipulations à l'intérieur de la chaîne. Par contre, un objet de type String est "immuable" : on ne peut le modifier, si ce n'est en constituant une nouvelle chaîne.</p>
                    <p>On peut facilement construire une String à partir d'un StringBuffer, et vice-versa.</p>
                    <p>L’opérateur de concaténation (+) fournit une String comme résultat, obtenue par mise bout à bout des deux opérandes. Il s’applique en principe à deux Strings, mais, si un des opérandes du + est une String et l’autre pas, il y a conversion automatique de cet autre en String. (Si aucun des deux opérandes n’est une String, il s’agit de l’opérateur d’addition !).</p>
                    <p>Rappelons que l'associativité est à gauche, ce qui a de l'importance dans certains cas.</p>
                    <p>La classe String présente une dizaine de constructeurs, mais la plupart du temps on peut s’en passer, car la syntaxe du Java permet, par facilité, une notation similaire à celle des types primitfs.</p>
                    <p>Par exemple : à la place de l'écriture "orientée objet" suivante :</p>
<pre class="taille60"><code>String chaine = new String("Hello !");</code></pre>
                    <p>Le Java accepte l'écriture équivalente suivante :</p>
<pre class="taille60"><code>String chaine = "Hello !";</code></pre>
                    <p>La documentation du Java, en ligne ou trouvée dans un livre, vous donnera la liste complète des méthodes de la classe String. En voici quelques-unes  :</p>
                    <table class="tableBalises">
                        <thead>
                            <tr>
                                <th>Fonction</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>public char char (int indice);</td>
                                <td>renvoie le caractère n°"indice" de la chaîne (NB : on commence à compter à 0).</td>
                            </tr>
                            <tr>
                                <td>public int compareTo (String autreChaine);</td>
                                <td>renvoie un entier positif, nul ou négatif selon que la chaîne-cible soit "supérieure", "égale" ou "inférieure" à la chaîne passée en paramètre; la comparaison se fait selon l'ordre "lexicographique".</td>
                            </tr>
                            <tr>
                                <td>public boolean equals (Object unObjet);</td>
                                <td>renvoie true seulement si l'objet passé en paramètre est une String, et que cette String a la même valeur que la chaîne-cible.</td>
                            </tr>
                            <tr>
                                <td>public boolean equalsIgnoreCase (String autreChaine);</td>
                                <td>renvoie true seulement si les deux chaînes sont identiques, sans tenir compte toutefois de la distinction entre majuscules et minuscules.</td>
                            </tr>
                            <tr>
                                <td>public int indexOf (String sousChaine);</td>
                                <td>
                                    <p>renvoie la position de la première occurence de la sous-chaîne dans la chaîne-cible; exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>int position = chaine.indexOf("ou"); &#8594; 4</p>
                                    <p>S'il n'y a pas d'occurence, on renvoie -1.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public int indexOf (String sousChaine, int depart);</td>
                                <td>
                                    <p>renvoie la position de la première occurence de la sous-chaîne dans la chaîne-cibe, à partir de l'indice "départ"; exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>int position = chaine.indexOf("ou", 8"); &#8594; 11</p>
                                    <p>S'il n'y a pas d'occurence, on renvoie -1.</p>
                                    <p>Rappel : on commence à l'indice 0.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public int length();</td>
                                <td>
                                    <p>renvoie la longueur de la chaîne, c'est-à-dire le nombre de caractères qu'elle contient. Ex :</p>
                                    <p>String chaine "Un coucou tout fou";</p>
                                    <p>int longueur = chaine.length;</p>
                                    <p>char dernierCaractere = chaine.charAt(longueur - 1);</p>
                                </td>
                            </tr>
                            <tr>
                                <td>public String substring (int debut, int fin);</td>
                                <td>
                                    <p>renvoie une sous-chaîne, obtenue en prenant dans la chaîne-cible tous les caractères depuis celui de l'indice "début" jusqu'à celui situé juste avant l'indice "fin" (rappel : on commence à compter à 0); exemple :</p>
                                    <p>String chaine = "Un coucou tout fou";</p>
                                    <p>String ssch = chaine.substring(3,9); &#8594; "coucou"</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>public String toUpperCase();</p>
                                    <p>public String toLowerCase();</p>
                                </td>
                                <td>
                                    <p>convertissent respectivement les minuscules en majuscules (tout en conservant inchangés tous les caractères) et vice-versa.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h2 id="tableaux">Les tableaux :</h2>
                    <p>Remarque : dans de nombreux langages, la souplesse de programmation en utilisant les tableaux est un peu atténuée par le fait qu’il faut dimensionner les tableaux dans les déclarations de variables, dès la phase d’écriture du programme; cet inconvénient est résolu par un surdimensionnement systématique de tels tableaux.</p>
                    <p>En Java cependant, on peut créer un tableau en ne connaissant sa taille qu'au moment de l'exécution en suivant par exemple le code suivant :</p>
<pre class="taille60"><code>int taille = scanner.nextInt();
int[] tab = new int[taille];</code></pre>
                    <p><span class="souligne">Attention :</span> Il est à noter qu'en Java les tableaux commencent toujours à la case 0. Le tableau créé compte taille cases : de 0 à taille - 1.</p>
                    <p><span class="souligne">Remarque :</span> Un danger non négligeable de l'outil "tableaux" est cependant la tentation d'en abuser.</p>
                    <p>Dans les langages classiques, un <span class="em">tableau</span> (ou une <span class="em">table</span>, ou une <space class="em">variable indicée</space>), c'est un groupe de "cases de mémoire"</p>
                    <ul>
                        <li>toute de même "type".</li>
                        <li>donc forcément de même taille.</li>
                        <li>possédant un nom (identificateur) commun.</li>
                        <li>différenciées les unes des autres par la valeur d'un (ou de plusieurs) indice(s).</li>
                    </ul>
                    <p>Si le tableau n'a qu'un seul indice, comme dans l'exemple donné, on parle parfois de <span class="em">vecteur</span>, et s'il en a deux, de <span class="em">matrice</span>.</p>
                    <p>Les indices commencent, selon les langages, à une valeur imposée (toujours 0 en Java, toujours 1 dans certains langages) ou au contraire à une valeur au choix du programmeur (en Pascal par exemple, on peut décider de créer un tableau indicé de 5 à 20, ou encore de -1850 à -127).</p>
                    <p>Le type des indices est souvent réduit aux nombres entiers, mais certains langages acceptent d'autres types, comme le type caractère.</p>
                    <p>En Java, les tableaux sont des constructions hybrides : ce sont des "objets" sous certains aspects, mais pas sous tous.</p>
                    <p>Un tableau est toujours une référence. L'espace-mémoire du tableau doit être construit par l'utilisation de l'opérateur "<span class="em">new</span>" (ou par un "array initializer").</p>
                    <p>Un tableau possède un "champ, qui représente sa longueur physique et s'appelle <span class="em">length</span>.</p>
                    <p>Les éléments du tableau peuvent être de n'importe quel type Java, y compris un type objet ou un type tableau (ce dernier cas, tableau de tableaux, permet d'implémenter des tableaux à plusieurs dimensions).</p>
                    <p>En Java, tous les tableaux sont indicés à partir de 0. Ceci est une limitation du Java (par exemple par rapport au PHP).</p>
                    <p>On peut aussi déclarer et allouer et initialiser le tableau tableDEntiers en utilisant un "array initializer" :</p>
<pre class="taille60"><code>int[] tableDEntiers = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18};</code></pre>
                    <p>Ceci n'est cependant possible que pour des tableaux d'éléments d'un type primitif (int dans l'exemple).</p>
                    <p>Attirons aussi sur le fait que la fixation de la taille du table et donc aussi l'allocation de mémoire se font dynamiquement, lors de l'exécution (et pourra donc être différente d'une exécution à l'autre !). D'oùl'intérêt du champ "length" qui donne la longueur physique d'un tableau, comptée en nombre de "cases", c'est-à-dire en nombre de valeurs différentes de l'indice. Comme l'indice commence toujours à 0, cette longueur est aussi égale à la plus grande valeur de l'indice, plus 1.</p>
                    <h3 id="taille_physique_taille_logique">Taille physique et taille logique :</h3>
                    <p>Un tableau est conçu en vue de stocker, durant l’exécution d’un programme ou une partie de celle-ci, un certain nombre d’informations de même nature. Le nombre de telles informations effectivement mémorisées à un moment donné peut être ou bien fixe ou bien variable. Dans ce dernier cas, étant donné qu’un tableau doit en général être pré-dimensionné lors de l’écriture du programme, ou en tout cas lors de sa création, il y a une distinction à opérer entre :</p>
                    <ul>
                        <li>la <span class="em">taille physique</span> du tablau : le nombre de "cases" réservées dans les déclarations de variables ou lors de la construction (le "prédimensionnement").</li>
                        <li>la <span class="em">taille logique</span> du tableau : le nombre de "cases effectivement occupées à un moment donné par des informations pertinentes (autres donc que des "crasses").</li>
                    </ul>
                    <p></p>
                </article>
            <!-- fin de section -->
            </section>
            <footer role="contentinfo">
                <div>
                    <address>
                        Professeurs :
                        <a class="mail" href="mailto:olivier.choquet@vinci.be">Choquet Olivier</a>
                        <a class="mail" href="mailto:driss.vandenheede.techinfo@gmail.com">Vandenheede Driss</a>
                    </address>
                </div>
                <div>
                    <p>Si vous détectez une erreur, une faute d'orthographe, n'hésitez pas à envoyer un mail aux adresses juste à côté avec le nom de la page et l'erreur détectée.</p>
                </div>
                <div id="version">
                    <p>Syllabus HTML</p>
                    <p>Version 5.0</p>
                </div>
            </footer>
        </main>
    </body>
</html>